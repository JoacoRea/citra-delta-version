// shader: 8B30, 9934EB13987DB0BD

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 3F41287AC35EF0E8, 9934EB13987DB0BD
// program: 0000000000000000, 0000000000000000, 9934EB13987DB0BD
// shader: 8B30, 501767FED21C5F25

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: B2FC2A64F1CA3B20, 501767FED21C5F25
// program: 0000000000000000, 0000000000000000, 501767FED21C5F25
// shader: 8B31, BAF5CB3693892DB3

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define mul_safe(x, y) mix(x * y, vec4(0.0), isnan(x * y))

float rcp_safe(float x) {
    if (x == 0.0f) return x;
    return 1.0f / x;
}


float rsq_safe(float x) {
    if (x == 0.0f) return x;
    return inversesqrt(x);
}

#define fma_safe(x, y, z) (mul_safe(x, y) + z)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_4096();
bool sub_7_12();
bool sub_9_10();
bool sub_14_15();
bool sub_18_30();
bool sub_20_21();
bool sub_21_25();
bool sub_22_23();
bool sub_23_24();
bool sub_30_40();
bool sub_44_45();
bool sub_45_49();
bool sub_46_47();
bool sub_47_48();
bool sub_56_61();
bool sub_61_70();
bool sub_70_83();
bool sub_83_251();
bool sub_89_189();
bool sub_96_125();
bool sub_107_111();
bool sub_125_184();
bool sub_126_158();
bool sub_137_141();
bool sub_158_183();
bool sub_169_173();
bool sub_189_250();
bool sub_192_202();
bool sub_202_207();
bool sub_208_220();
bool sub_220_245();
bool sub_221_239();
bool sub_239_244();
bool sub_251_268();
bool sub_268_344();
bool sub_307_327();
bool sub_308_313();
bool sub_313_326();
bool sub_317_320();
bool sub_320_325();
bool sub_327_340();
bool sub_328_333();
bool sub_333_339();

bool exec_shader() {
    sub_0_4096();
    return true;
}

bool sub_0_4096() {
    // 0: call
    {
        sub_83_251();
    }
    // 1: mov
    reg_tmp8.xy = (uniforms.f[93].xxxx).xy;
    // 2: mov
    reg_tmp0.y = (uniforms.f[7].wwww).y;
    // 3: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.xyyy));
    // 4: mov
    reg_tmp9.xyz = (uniforms.f[93].xxxx).xyz;
    // 5: mov
    reg_tmp9.w = (uniforms.f[21].wwww).w;
    // 6: ifc
    if (conditional_code.y) {
        sub_7_12();
    }
    // 12: cmp
    conditional_code = equal(vec2(uniforms.f[93].xxxx), vec2(reg_tmp8.xyyy));
    // 13: ifc
    if (all(conditional_code)) {
        sub_14_15();
    }
    // 15: max
    vs_out_attr3 = max(uniforms.f[93].xxxx, reg_tmp9);
    // 16: mov
    reg_tmp0.xy = (uniforms.f[10].xxxx).xy;
    // 17: ifu
    if (uniforms.b[9]) {
        sub_18_30();
    } else {
        sub_30_40();
    }
    // 40: nop
    // 41: mov
    reg_tmp0.xy = (uniforms.f[10].yyyy).xy;
    // 42: cmp
    conditional_code = equal(vec2(uniforms.f[93].yzzz), vec2(reg_tmp0.xyyy));
    // 43: ifc
    if (all(not(conditional_code))) {
        sub_44_45();
    } else {
        sub_45_49();
    }
    // 49: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 50: dp4
    reg_tmp4.x = dot(mul_safe(uniforms.f[14].xywz, reg_tmp6), vec4(1.0));
    // 51: dp4
    reg_tmp4.y = dot(mul_safe(uniforms.f[15].xywz, reg_tmp6), vec4(1.0));
    // 52: mov
    vs_out_attr5 = reg_tmp4;
    // 53: nop
    // 54: end
    return true;
}
bool sub_7_12() {
    // 7: mul
    reg_tmp0 = mul_safe(uniforms.f[7].wwww, vs_in_reg3);
    // 8: ifu
    if (uniforms.b[7]) {
        sub_9_10();
    }
    // 10: mul
    reg_tmp9.xyz = (mul_safe(uniforms.f[20].wwww, reg_tmp0.xyzz)).xyz;
    // 11: mov
    reg_tmp8.x = (uniforms.f[93].yyyy).x;
    return false;
}
bool sub_9_10() {
    // 9: mul
    reg_tmp9.w = (mul_safe(reg_tmp9.wwww, reg_tmp0.wwww)).w;
    return false;
}
bool sub_14_15() {
    // 14: mov
    reg_tmp9 = uniforms.f[21];
    return false;
}
bool sub_18_30() {
    // 18: cmp
    conditional_code = equal(vec2(uniforms.f[93].yzzz), vec2(reg_tmp0.xyyy));
    // 19: ifc
    if (all(not(conditional_code))) {
        sub_20_21();
    } else {
        sub_21_25();
    }
    // 25: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 26: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[11].xywz, reg_tmp6), vec4(1.0));
    // 27: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[12].xywz, reg_tmp6), vec4(1.0));
    // 28: mov
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    // 29: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_20_21() {
    // 20: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
    return false;
}
bool sub_21_25() {
    // 21: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_22_23();
    } else {
        sub_23_24();
    }
    // 24: nop
    return false;
}
bool sub_22_23() {
    // 22: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
    return false;
}
bool sub_23_24() {
    // 23: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
    return false;
}
bool sub_30_40() {
    // 30: cmp
    conditional_code = equal(vec2(uniforms.f[95].xyyy), vec2(reg_tmp0.xyyy));
    // 31: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 32: mov
    reg_tmp6 = reg_tmp10;
    // 33: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[11], reg_tmp6), vec4(1.0));
    // 34: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[12], reg_tmp6), vec4(1.0));
    // 35: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[13], reg_tmp6), vec4(1.0));
    // 36: mul
    reg_tmp0.xy = (mul_safe(uniforms.f[19].xyyy, reg_tmp3.zzzz)).xy;
    // 37: add
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    // 38: nop
    // 39: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_44_45() {
    // 44: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
    return false;
}
bool sub_45_49() {
    // 45: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_46_47();
    } else {
        sub_47_48();
    }
    // 48: nop
    return false;
}
bool sub_46_47() {
    // 46: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
    return false;
}
bool sub_47_48() {
    // 47: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
    return false;
}
bool sub_56_61() {
    // 56: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 57: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 58: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 59: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 60: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    return false;
}
bool sub_61_70() {
    // 61: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 62: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 63: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 64: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 65: dp3
    reg_tmp4.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 66: dp3
    reg_tmp4.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 67: dp3
    reg_tmp4.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 68: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 69: mad
    reg_tmp12 = fma_safe(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_70_83() {
    // 70: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 71: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 72: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 73: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 74: dp3
    reg_tmp4.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 75: dp3
    reg_tmp4.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 76: dp3
    reg_tmp4.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 77: dp3
    reg_tmp5.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 78: dp3
    reg_tmp5.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 79: dp3
    reg_tmp5.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 80: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 81: mad
    reg_tmp12 = fma_safe(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    // 82: mad
    reg_tmp11 = fma_safe(reg_tmp1.wwww, reg_tmp5, reg_tmp11);
    return false;
}
bool sub_83_251() {
    // 83: mul
    reg_tmp15.xyz = (mul_safe(uniforms.f[7].xxxx, vs_in_reg0)).xyz;
    // 84: mul
    reg_tmp14.xyz = (mul_safe(uniforms.f[7].yyyy, vs_in_reg1)).xyz;
    // 85: mul
    reg_tmp13.xyz = (mul_safe(uniforms.f[7].zzzz, vs_in_reg2)).xyz;
    // 86: add
    reg_tmp15.xyz = (uniforms.f[6] + reg_tmp15).xyz;
    // 87: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 88: ifu
    if (uniforms.b[1]) {
        sub_89_189();
    } else {
        sub_189_250();
    }
    // 250: nop
    return false;
}
bool sub_89_189() {
    // 89: mov
    reg_tmp0 = uniforms.f[7];
    // 90: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.yzzz));
    // 91: mov
    reg_tmp7 = uniforms.f[93].xxxx;
    // 92: mov
    reg_tmp12 = uniforms.f[93].xxxx;
    // 93: mov
    reg_tmp11 = uniforms.f[93].xxxx;
    // 94: mul
    reg_tmp2 = mul_safe(uniforms.f[93].wwww, vs_in_reg7);
    // 95: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_96_125();
    } else {
        sub_125_184();
    }
    // 184: mov
    vs_out_attr2 = -reg_tmp15;
    // 185: dp4
    vs_out_attr0.x = dot(mul_safe(uniforms.f[86], reg_tmp15), vec4(1.0));
    // 186: dp4
    vs_out_attr0.y = dot(mul_safe(uniforms.f[87], reg_tmp15), vec4(1.0));
    // 187: dp4
    vs_out_attr0.z = dot(mul_safe(uniforms.f[88], reg_tmp15), vec4(1.0));
    // 188: dp4
    vs_out_attr0.w = dot(mul_safe(uniforms.f[89], reg_tmp15), vec4(1.0));
    return false;
}
bool sub_96_125() {
    // 96: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 97: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 98: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 99: call
    {
        sub_61_70();
    }
    // 100: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 101: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 102: call
    {
        sub_61_70();
    }
    // 103: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 104: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 105: callc
    if (conditional_code.x) {
        sub_61_70();
    }
    // 106: ifu
    if (uniforms.b[8]) {
        sub_107_111();
    }
    // 111: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 112: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 113: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 114: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 115: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 116: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 117: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 118: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 119: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 120: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 121: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 122: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 123: call
    {
        sub_251_268();
    }
    // 124: nop
    return false;
}
bool sub_107_111() {
    // 107: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 108: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 109: callc
    if (conditional_code.y) {
        sub_61_70();
    }
    // 110: nop
    return false;
}
bool sub_125_184() {
    // 125: ifc
    if (all(conditional_code)) {
        sub_126_158();
    } else {
        sub_158_183();
    }
    // 183: nop
    return false;
}
bool sub_126_158() {
    // 126: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 127: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 128: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 129: call
    {
        sub_70_83();
    }
    // 130: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 131: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 132: call
    {
        sub_70_83();
    }
    // 133: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 134: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 135: callc
    if (conditional_code.x) {
        sub_70_83();
    }
    // 136: ifu
    if (uniforms.b[8]) {
        sub_137_141();
    }
    // 141: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 142: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 143: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 144: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 145: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 146: dp3
    reg_tmp13.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp11)), vec3(1.0));
    // 147: dp3
    reg_tmp13.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp11)), vec3(1.0));
    // 148: dp3
    reg_tmp13.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp11)), vec3(1.0));
    // 149: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 150: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 151: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 152: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 153: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 154: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 155: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 156: call
    {
        sub_268_344();
    }
    // 157: nop
    return false;
}
bool sub_137_141() {
    // 137: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 138: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 139: callc
    if (conditional_code.y) {
        sub_70_83();
    }
    // 140: nop
    return false;
}
bool sub_158_183() {
    // 158: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 159: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 160: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 161: call
    {
        sub_56_61();
    }
    // 162: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 163: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 164: call
    {
        sub_56_61();
    }
    // 165: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 166: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 167: callc
    if (conditional_code.x) {
        sub_56_61();
    }
    // 168: ifu
    if (uniforms.b[8]) {
        sub_169_173();
    }
    // 173: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 174: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 175: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 176: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 177: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 178: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 179: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 180: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 181: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 182: mov
    vs_out_attr1 = uniforms.f[93].xxxx;
    return false;
}
bool sub_169_173() {
    // 169: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 170: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 171: callc
    if (conditional_code.y) {
        sub_56_61();
    }
    // 172: nop
    return false;
}
bool sub_189_250() {
    // 189: mov
    reg_tmp0 = uniforms.f[7];
    // 190: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.yzzz));
    // 191: ifu
    if (uniforms.b[2]) {
        sub_192_202();
    } else {
        sub_202_207();
    }
    // 207: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_208_220();
    } else {
        sub_220_245();
    }
    // 245: mov
    vs_out_attr2 = -reg_tmp15;
    // 246: dp4
    vs_out_attr0.x = dot(mul_safe(uniforms.f[86], reg_tmp15), vec4(1.0));
    // 247: dp4
    vs_out_attr0.y = dot(mul_safe(uniforms.f[87], reg_tmp15), vec4(1.0));
    // 248: dp4
    vs_out_attr0.z = dot(mul_safe(uniforms.f[88], reg_tmp15), vec4(1.0));
    // 249: dp4
    vs_out_attr0.w = dot(mul_safe(uniforms.f[89], reg_tmp15), vec4(1.0));
    return false;
}
bool sub_192_202() {
    // 192: mul
    reg_tmp1.x = (mul_safe(uniforms.f[93].wwww, vs_in_reg7.xxxx)).x;
    // 193: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 194: dp4
    reg_tmp7.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 195: dp4
    reg_tmp7.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 196: dp4
    reg_tmp7.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 197: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 198: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 199: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 200: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 201: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_202_207() {
    // 202: mova
    address_registers.x = (ivec2(uniforms.f[93].xxxx)).x;
    // 203: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[25], reg_tmp15), vec4(1.0));
    // 204: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[26], reg_tmp15), vec4(1.0));
    // 205: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[27], reg_tmp15), vec4(1.0));
    // 206: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_208_220() {
    // 208: dp3
    reg_tmp12.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 209: dp3
    reg_tmp12.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 210: dp3
    reg_tmp12.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 211: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 212: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 213: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 214: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 215: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 216: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 217: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 218: call
    {
        sub_251_268();
    }
    // 219: nop
    return false;
}
bool sub_220_245() {
    // 220: ifc
    if (all(conditional_code)) {
        sub_221_239();
    } else {
        sub_239_244();
    }
    // 244: nop
    return false;
}
bool sub_221_239() {
    // 221: dp3
    reg_tmp12.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 222: dp3
    reg_tmp12.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 223: dp3
    reg_tmp12.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 224: dp3
    reg_tmp11.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 225: dp3
    reg_tmp11.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 226: dp3
    reg_tmp11.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 227: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 228: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 229: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 230: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 231: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 232: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 233: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 234: dp3
    reg_tmp13.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp11)), vec3(1.0));
    // 235: dp3
    reg_tmp13.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp11)), vec3(1.0));
    // 236: dp3
    reg_tmp13.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp11)), vec3(1.0));
    // 237: call
    {
        sub_268_344();
    }
    // 238: nop
    return false;
}
bool sub_239_244() {
    // 239: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 240: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 241: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 242: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 243: mov
    vs_out_attr1 = uniforms.f[93].xxxx;
    return false;
}
bool sub_251_268() {
    uint jmp_to = 251u;
    while (true) {
        switch (jmp_to) {
        case 251u: {
            // 251: dp3
            reg_tmp6.x = dot(vec3(mul_safe(reg_tmp14, reg_tmp14)), vec3(1.0));
            // 252: dp3
            reg_tmp7.x = dot(vec3(mul_safe(reg_tmp12, reg_tmp12)), vec3(1.0));
            // 253: rsq
            reg_tmp6.x = rsq_safe(reg_tmp6.xxxx.x);
            // 254: rsq
            reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
            // 255: mul
            reg_tmp14.xyz = (mul_safe(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 256: mul
            reg_tmp12.xyz = (mul_safe(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 257: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 258: jmpu
            if (!uniforms.b[15]) {
                { jmp_to = 267u; break; }
            }
            // 259: add
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            // 260: mul
            reg_tmp4 = mul_safe(uniforms.f[94].zzzz, reg_tmp4);
            // 261: cmp
            conditional_code = greaterThanEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp4.xxxx));
            // 262: rsq
            reg_tmp4 = vec4(rsq_safe(reg_tmp4.xxxx.x));
            // 263: mul
            reg_tmp5 = mul_safe(uniforms.f[94].zzzz, reg_tmp14);
            // 264: jmpc
            if (conditional_code.x) {
                { jmp_to = 267u; break; }
            }
            // 265: rcp
            reg_tmp0.z = rcp_safe(reg_tmp4.xxxx.x);
            // 266: mul
            reg_tmp0.xy = (mul_safe(reg_tmp5, reg_tmp4)).xy;
        }
        case 267u: {
            // 267: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_268_344() {
    uint jmp_to = 268u;
    while (true) {
        switch (jmp_to) {
        case 268u: {
            // 268: dp3
            reg_tmp6.x = dot(vec3(mul_safe(reg_tmp14, reg_tmp14)), vec3(1.0));
            // 269: dp3
            reg_tmp7.x = dot(vec3(mul_safe(reg_tmp12, reg_tmp12)), vec3(1.0));
            // 270: rsq
            reg_tmp6.x = rsq_safe(reg_tmp6.xxxx.x);
            // 271: rsq
            reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
            // 272: mul
            reg_tmp14.xyz = (mul_safe(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 273: mul
            reg_tmp12.xyz = (mul_safe(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 274: mul
            reg_tmp13.xyz = (mul_safe(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            // 275: mul
            reg_tmp11.xyz = (mul_safe(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            // 276: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 277: jmpu
            if (!uniforms.b[15]) {
                { jmp_to = 343u; break; }
            }
            // 278: mul
            reg_tmp13.xyz = (mul_safe(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            // 279: mul
            reg_tmp11.xyz = (mul_safe(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            // 280: mul
            reg_tmp5 = mul_safe(reg_tmp14.yzxx, reg_tmp13.zxyy);
            // 281: mad
            reg_tmp5 = fma_safe(-reg_tmp13.yzxx, reg_tmp14.zxyy, reg_tmp5);
            // 282: dp3
            reg_tmp5.w = dot(vec3(mul_safe(reg_tmp5, reg_tmp5)), vec3(1.0));
            // 283: rsq
            reg_tmp5.w = rsq_safe(reg_tmp5.wwww.x);
            // 284: mul
            reg_tmp5 = mul_safe(reg_tmp5, reg_tmp5.wwww);
            // 285: add
            reg_tmp6.w = (reg_tmp14.zzzz + reg_tmp5.yyyy).w;
            // 286: mul
            reg_tmp13 = mul_safe(reg_tmp5.yzxx, reg_tmp14.zxyy);
            // 287: mad
            reg_tmp13 = fma_safe(-reg_tmp14.yzxx, reg_tmp5.zxyy, reg_tmp13);
            // 288: add
            reg_tmp6.w = (reg_tmp13.xxxx + reg_tmp6).w;
            // 289: mov
            reg_tmp13.w = (reg_tmp5.zzzz).w;
            // 290: mov
            reg_tmp5.z = (reg_tmp13.xxxx).z;
            // 291: add
            reg_tmp6.w = (uniforms.f[93].yyyy + reg_tmp6).w;
            // 292: mov
            reg_tmp14.w = (reg_tmp5.xxxx).w;
            // 293: mov
            reg_tmp5.x = (reg_tmp14.zzzz).x;
            // 294: cmp
            conditional_code = lessThan(vec2(uniforms.f[94].yyyy), vec2(reg_tmp6.wwww));
            // 295: mov
            reg_tmp6.x = (uniforms.f[93].yyyy).x;
            // 296: mov
            reg_tmp6.y = (-uniforms.f[93].yyyy).y;
            // 297: jmpc
            if (!conditional_code.x) {
                { jmp_to = 305u; break; }
            }
            // 298: add
            reg_tmp7.xz = (reg_tmp13.wwyy + -reg_tmp14.yyww).xz;
            // 299: add
            reg_tmp7.y = (reg_tmp14.xxxx + -reg_tmp13.zzzz).y;
            // 300: mov
            reg_tmp7.w = (reg_tmp6).w;
            // 301: dp4
            reg_tmp6 = vec4(dot(mul_safe(reg_tmp7, reg_tmp7), vec4(1.0)));
            // 302: rsq
            reg_tmp6 = vec4(rsq_safe(reg_tmp6.xxxx.x));
            // 303: mul
            reg_tmp0 = mul_safe(reg_tmp7, reg_tmp6);
            // 304: jmpu
            if (uniforms.b[0]) {
                { jmp_to = 343u; break; }
            }
        }
        case 305u: {
            // 305: cmp
            conditional_code = greaterThan(vec2(reg_tmp5.zyyy), vec2(reg_tmp5.yxxx));
            // 306: ifc
            if (conditional_code.x) {
                sub_307_327();
            } else {
                sub_327_340();
            }
            // 340: dp4
            reg_tmp6 = vec4(dot(mul_safe(reg_tmp8, reg_tmp8), vec4(1.0)));
            // 341: rsq
            reg_tmp6 = vec4(rsq_safe(reg_tmp6.xxxx.x));
            // 342: mul
            reg_tmp0 = mul_safe(reg_tmp8, reg_tmp6);
        }
        case 343u: {
            // 343: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_307_327() {
    // 307: ifc
    if (conditional_code.y) {
        sub_308_313();
    } else {
        sub_313_326();
    }
    // 326: mov
    reg_tmp8.w = (-reg_tmp8).w;
    return false;
}
bool sub_308_313() {
    // 308: mul
    reg_tmp8 = mul_safe(reg_tmp13.yyzw, reg_tmp6.xxxy);
    // 309: add
    reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
    // 310: add
    reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
    // 311: add
    reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
    // 312: add
    reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
    return false;
}
bool sub_313_326() {
    // 313: cmp
    conditional_code = greaterThan(vec2(reg_tmp5.zzzz), vec2(reg_tmp5.xxxx));
    // 314: mul
    reg_tmp8 = mul_safe(reg_tmp13.yyzw, reg_tmp6.xxxy);
    // 315: add
    reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
    // 316: ifc
    if (conditional_code.x) {
        sub_317_320();
    } else {
        sub_320_325();
    }
    // 325: nop
    return false;
}
bool sub_317_320() {
    // 317: add
    reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
    // 318: add
    reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
    // 319: add
    reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
    return false;
}
bool sub_320_325() {
    // 320: mul
    reg_tmp8 = mul_safe(reg_tmp13.zwwy, reg_tmp6.xxxy);
    // 321: add
    reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
    // 322: add
    reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
    // 323: add
    reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
    // 324: add
    reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
    return false;
}
bool sub_327_340() {
    // 327: ifc
    if (conditional_code.y) {
        sub_328_333();
    } else {
        sub_333_339();
    }
    // 339: nop
    return false;
}
bool sub_328_333() {
    // 328: mul
    reg_tmp8 = mul_safe(reg_tmp13.yywz, reg_tmp6.xxxy);
    // 329: add
    reg_tmp8.y = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).y;
    // 330: add
    reg_tmp9 = reg_tmp5.yyyy + -reg_tmp5.xxxx;
    // 331: add
    reg_tmp8.xzw = (reg_tmp8 + reg_tmp14.wwyx).xzw;
    // 332: add
    reg_tmp8.y = (reg_tmp9 + reg_tmp8).y;
    return false;
}
bool sub_333_339() {
    // 333: mul
    reg_tmp8 = mul_safe(reg_tmp13.zwwy, reg_tmp6.xxxy);
    // 334: add
    reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
    // 335: add
    reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
    // 336: add
    reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
    // 337: add
    reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
    // 338: mov
    reg_tmp8.w = (-reg_tmp8).w;
    return false;
}
// reference: DE1D69C0622FB996, BAF5CB3693892DB3
// shader: 8DD9, 3B3AE026C742C7D5

layout(triangles) in;
layout(triangle_strip, max_vertices = 3) out;

out vec4 primary_color;
out vec2 texcoord0;
out vec2 texcoord1;
out vec2 texcoord2;
out float texcoord0_w;
out vec4 normquat;
out vec3 view;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

 in vec4 vs_out_attr0[];
 in vec4 vs_out_attr1[];
 in vec4 vs_out_attr2[];
 in vec4 vs_out_attr3[];
 in vec4 vs_out_attr4[];
 in vec4 vs_out_attr5[];

struct Vertex {
    vec4 attributes[6];
};

vec4 GetVertexQuaternion(Vertex vtx) {
    return vec4(vtx.attributes[1].x, vtx.attributes[1].y, vtx.attributes[1].z, vtx.attributes[1].w);
}

void EmitVtx(Vertex vtx, bool quats_opposite) {
    vec4 vtx_pos = vec4(vtx.attributes[0].x, vtx.attributes[0].y, vtx.attributes[0].z, vtx.attributes[0].w);
    gl_Position = vtx_pos;
#if !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)
    gl_ClipDistance[0] = -vtx_pos.z;
    gl_ClipDistance[1] = dot(clip_coef, vtx_pos);
#endif // !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)

    vec4 vtx_quat = GetVertexQuaternion(vtx);
    normquat = mix(vtx_quat, -vtx_quat, bvec4(quats_opposite));

    vec4 vtx_color = vec4(vtx.attributes[3].x, vtx.attributes[3].y, vtx.attributes[3].z, vtx.attributes[3].w);
    primary_color = min(abs(vtx_color), vec4(1.0));

    texcoord0 = vec2(vtx.attributes[4].x, vtx.attributes[4].y);
    texcoord1 = vec2(vtx.attributes[5].x, vtx.attributes[5].y);

    texcoord0_w = vtx.attributes[4].z;
    view = vec3(vtx.attributes[2].x, vtx.attributes[2].y, vtx.attributes[2].z);

    texcoord2 = vec2(0.0, 0.0);

    EmitVertex();
}

bool AreQuaternionsOpposite(vec4 qa, vec4 qb) {
    return (dot(qa, qb) < 0.0);
}

void EmitPrim(Vertex vtx0, Vertex vtx1, Vertex vtx2) {
    EmitVtx(vtx0, false);
    EmitVtx(vtx1, AreQuaternionsOpposite(GetVertexQuaternion(vtx0), GetVertexQuaternion(vtx1)));
    EmitVtx(vtx2, AreQuaternionsOpposite(GetVertexQuaternion(vtx0), GetVertexQuaternion(vtx2)));
    EndPrimitive();
}

void main() {
    Vertex prim_buffer[3];
    prim_buffer[0].attributes = vec4[6](vs_out_attr0[0], vs_out_attr1[0], vs_out_attr2[0], vs_out_attr3[0], vs_out_attr4[0], vs_out_attr5[0]);
    prim_buffer[1].attributes = vec4[6](vs_out_attr0[1], vs_out_attr1[1], vs_out_attr2[1], vs_out_attr3[1], vs_out_attr4[1], vs_out_attr5[1]);
    prim_buffer[2].attributes = vec4[6](vs_out_attr0[2], vs_out_attr1[2], vs_out_attr2[2], vs_out_attr3[2], vs_out_attr4[2], vs_out_attr5[2]);
    EmitPrim(prim_buffer[0], prim_buffer[1], prim_buffer[2]);
}
// reference: 46A0C2E6B155D5CD, 3B3AE026C742C7D5
// shader: 8B30, 93E967909E672D88

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((secondary_fragment_color.r) * (1.0 - const_color[0].a) + (secondary_fragment_color.b) * (1.0 - (1.0 - const_color[0].a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((secondary_fragment_color.ggg) * (last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((rounded_primary_color.a) * (const_color[4].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: B908DBC879ED6C62, 93E967909E672D88
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, 93E967909E672D88
// reference: D071D0AD10946707, 93E967909E672D88
// shader: 8B30, EBB618B91CD249A6

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((secondary_fragment_color.r) * (1.0 - const_color[0].a) + (secondary_fragment_color.b) * (1.0 - (1.0 - const_color[0].a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((secondary_fragment_color.ggg) * (last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((rounded_primary_color.a) * (const_color[4].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 5DCCD2B31FBD5830, EBB618B91CD249A6
// program: 0000000000000000, 0000000000000000, EBB618B91CD249A6
// reference: E9BBB11479ED6C62, 93E967909E672D88
// shader: 8B30, FB41A178D3256723

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb) * (texcolor0.rgb) + (const_color[0].rgb) * (vec3(1.0) - (texcolor0.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.r) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: E918A8FA8474610F, FB41A178D3256723
// program: 0000000000000000, 0000000000000000, FB41A178D3256723
// reference: 52ACE698622FB996, BAF5CB3693892DB3
// reference: 9EF8DB0410946707, 93E967909E672D88
// reference: 1345D91A1FBD5830, EBB618B91CD249A6
// shader: 8B30, D8A369D59E3997EA

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 2584B8EB83D54929, D8A369D59E3997EA
// program: 0000000000000000, 0000000000000000, D8A369D59E3997EA
// reference: 2584B8EB547A6191, D8A369D59E3997EA
// shader: 8B30, FB41A17829976A8A

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb) * (texcolor0.rgb) + (const_color[0].rgb) * (vec3(1.0) - (texcolor0.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 3712860A8474610F, FB41A17829976A8A
// program: 0000000000000000, 0000000000000000, FB41A17829976A8A
// reference: CBF99ED9B99618D1, BAF5CB3693892DB3
// shader: 8B30, 6775B824F2B62B1B

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (const_color[1].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: CF42EAA20782F4B4, 6775B824F2B62B1B
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, 6775B824F2B62B1B
// reference: CF42EAA275322D78, 6775B824F2B62B1B
// shader: 8B30, 30DAB74CA24CBC58

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: AE4C834531371254, 30DAB74CA24CBC58
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, 30DAB74CA24CBC58
// reference: 9786E2FC584E1931, 30DAB74CA24CBC58
// reference: D071D0AD6224BECB, 93E967909E672D88
// reference: 9786E2FC2AFEC0FD, 30DAB74CA24CBC58
// reference: 5DCCD2B36D0D81FC, EBB618B91CD249A6
// shader: 8B30, 9F0AC915A32BAB2C

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((secondary_fragment_color.r) * (1.0 - const_color[1].a) + (secondary_fragment_color.g) * (1.0 - (1.0 - const_color[1].a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((combiner_buffer.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((secondary_fragment_color.ggg) * (last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((rounded_primary_color.a) * (const_color[4].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 7422FA542D26C35A, 9F0AC915A32BAB2C
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, 9F0AC915A32BAB2C
// shader: 8B30, E9B666E15E8A05C6

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((secondary_fragment_color.r) * (1.0 - const_color[1].a) + (secondary_fragment_color.g) * (1.0 - (1.0 - const_color[1].a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((combiner_buffer.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((secondary_fragment_color.ggg) * (last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((rounded_primary_color.a) * (const_color[4].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 19FAFE8DC3BDAD30, E9B666E15E8A05C6
// program: 0000000000000000, 0000000000000000, E9B666E15E8A05C6
// reference: 7422FA545F961A96, 9F0AC915A32BAB2C
// reference: 19FAFE8DB10D74FC, E9B666E15E8A05C6
// shader: 8B30, 88C72E1182AD101F

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((secondary_fragment_color.r) * (1.0 - const_color[0].a) + (secondary_fragment_color.b) * (1.0 - (1.0 - const_color[0].a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((secondary_fragment_color.ggg) * (last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((rounded_primary_color.a) * (const_color[4].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 3F32C69ED1F7F15F, 88C72E1182AD101F
// program: 0000000000000000, 0000000000000000, 88C72E1182AD101F
// reference: AE4C834530F57863, 30DAB74CA24CBC58
// reference: 9786E2FC2B3CAACA, 30DAB74CA24CBC58
// reference: D071D0AD11560D30, 93E967909E672D88
// reference: D071D0AD63E6D4FC, 93E967909E672D88
// shader: 8B31, EC7233A0BD4CF3D2

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define mul_safe(x, y) mix(x * y, vec4(0.0), isnan(x * y))

float rcp_safe(float x) {
    if (x == 0.0f) return x;
    return 1.0f / x;
}


float rsq_safe(float x) {
    if (x == 0.0f) return x;
    return inversesqrt(x);
}

#define fma_safe(x, y, z) (mul_safe(x, y) + z)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_4096();
bool sub_22_27();
bool sub_33_35();
bool sub_35_46();
bool sub_38_39();
bool sub_40_41();
bool sub_42_43();
bool sub_44_45();
bool sub_48_51();
bool sub_52_55();
bool sub_56_59();
bool sub_60_63();
bool sub_65_99();
bool sub_67_86();
bool sub_70_73();
bool sub_74_77();
bool sub_78_81();
bool sub_82_85();
bool sub_88_98();
bool sub_90_93();
bool sub_94_97();

bool exec_shader() {
    sub_0_4096();
    return true;
}

bool sub_0_4096() {
    // 0: mova
    address_registers.x = (ivec2(vs_in_reg0)).x;
    // 1: mov
    reg_tmp0 = uniforms.f[6 + address_registers.x].wzyx;
    // 2: mov
    reg_tmp1.xy = (vs_in_reg0.zwzw).xy;
    // 3: mov
    reg_tmp1.zw = (uniforms.f[5].xyxy).zw;
    // 4: mova
    address_registers.xy = ivec2(reg_tmp0.xyyy);
    // 5: mov
    reg_tmp2.xw = (uniforms.f[64 + address_registers.y].wwyy).xw;
    // 6: mov
    reg_tmp2.yz = (uniforms.f[5].xxxx).yz;
    // 7: dp4
    reg_tmp4.x = dot(mul_safe(reg_tmp1, reg_tmp2), vec4(1.0));
    // 8: mov
    reg_tmp2.yw = (uniforms.f[64 + address_registers.y].zzxx).yw;
    // 9: mov
    reg_tmp2.xz = (uniforms.f[5].xxxx).xz;
    // 10: dp4
    reg_tmp4.y = dot(mul_safe(reg_tmp1, reg_tmp2), vec4(1.0));
    // 11: mov
    reg_tmp4.zw = (reg_tmp1.zwzw).zw;
    // 12: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[32 + address_registers.x].wzyx, reg_tmp4), vec4(1.0));
    // 13: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[33 + address_registers.x].wzyx, reg_tmp4), vec4(1.0));
    // 14: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[34 + address_registers.x].wzyx, reg_tmp4), vec4(1.0));
    // 15: mov
    reg_tmp3.w = (reg_tmp1.wwww).w;
    // 16: mov
    reg_tmp4.z = (uniforms.f[34 + address_registers.x].xxxx).z;
    // 17: max
    reg_tmp4.z = (max(reg_tmp4.zzzz, -reg_tmp4.zzzz)).z;
    // 18: add
    reg_tmp4.z = (uniforms.f[4].yyyy + reg_tmp4.zzzz).z;
    // 19: mov
    reg_tmp4.x = (uniforms.f[4].wwww).x;
    // 20: cmp
    conditional_code = notEqual(vec2(uniforms.f[5].xxxx), vec2(reg_tmp4.xzzz));
    // 21: ifc
    if (all(conditional_code)) {
        sub_22_27();
    }
    // 27: dp4
    vs_out_attr0.x = dot(mul_safe(uniforms.f[0].wzyx, reg_tmp3), vec4(1.0));
    // 28: dp4
    vs_out_attr0.y = dot(mul_safe(uniforms.f[1].wzyx, reg_tmp3), vec4(1.0));
    // 29: dp4
    vs_out_attr0.z = dot(mul_safe(uniforms.f[2].wzyx, reg_tmp3), vec4(1.0));
    // 30: dp4
    vs_out_attr0.w = dot(mul_safe(uniforms.f[3].wzyx, reg_tmp3), vec4(1.0));
    // 31: cmp
    conditional_code = greaterThanEqual(vec2(uniforms.f[5].yyyy), vec2(reg_tmp0.wwww));
    // 32: ifc
    if (all(conditional_code)) {
        sub_33_35();
    } else {
        sub_35_46();
    }
    // 46: cmp
    conditional_code = notEqual(vec2(uniforms.f[5].xxxx), vec2(reg_tmp1.xyyy));
    // 47: ifc
    if (all(not(conditional_code))) {
        sub_48_51();
    }
    // 51: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_52_55();
    }
    // 55: ifc
    if (all(bvec2(!conditional_code.x, conditional_code.y))) {
        sub_56_59();
    }
    // 59: ifc
    if (all(conditional_code)) {
        sub_60_63();
    }
    // 63: mov
    reg_tmp8 = uniforms.f[5].xxxx;
    // 64: loop
    address_registers.z = int(uniforms.i[0].y);
    for (uint loop64 = 0u; loop64 <= uniforms.i[0].x; address_registers.z += int(uniforms.i[0].z), ++loop64) {
        sub_65_99();
    }
    // 99: mov
    vs_out_attr2 = reg_tmp5;
    // 100: mov
    vs_out_attr3 = reg_tmp6;
    // 101: mov
    vs_out_attr4 = reg_tmp7;
    // 102: end
    return true;
}
bool sub_22_27() {
    // 22: mov
    reg_tmp4.x = (uniforms.f[4].wwww).x;
    // 23: add
    reg_tmp4.y = (-uniforms.f[4].zzzz + reg_tmp4.zzzz).y;
    // 24: rcp
    reg_tmp4.z = rcp_safe(reg_tmp4.zzzz.x);
    // 25: mul
    reg_tmp4.z = (mul_safe(reg_tmp4.yyyy, reg_tmp4.zzzz)).z;
    // 26: mad
    reg_tmp3.x = (fma_safe(reg_tmp4.xxxx, reg_tmp4.zzzz, reg_tmp3.xxxx)).x;
    return false;
}
bool sub_33_35() {
    // 33: mov
    vs_out_attr1.xyz = (uniforms.f[5].yyyy).xyz;
    // 34: mov
    vs_out_attr1.w = (reg_tmp0.wwww).w;
    return false;
}
bool sub_35_46() {
    // 35: mova
    address_registers.y = (ivec2(reg_tmp0.wwww)).y;
    // 36: cmp
    conditional_code = notEqual(vec2(uniforms.f[5].xxxx), vec2(reg_tmp1.xyyy));
    // 37: ifc
    if (all(not(conditional_code))) {
        sub_38_39();
    }
    // 39: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_40_41();
    }
    // 41: ifc
    if (all(bvec2(!conditional_code.x, conditional_code.y))) {
        sub_42_43();
    }
    // 43: ifc
    if (all(conditional_code)) {
        sub_44_45();
    }
    // 45: nop
    return false;
}
bool sub_38_39() {
    // 38: mov
    vs_out_attr1 = uniforms.f[32 + address_registers.y].wzyx;
    return false;
}
bool sub_40_41() {
    // 40: mov
    vs_out_attr1 = uniforms.f[33 + address_registers.y].wzyx;
    return false;
}
bool sub_42_43() {
    // 42: mov
    vs_out_attr1 = uniforms.f[34 + address_registers.y].wzyx;
    return false;
}
bool sub_44_45() {
    // 44: mov
    vs_out_attr1 = uniforms.f[35 + address_registers.y].wzyx;
    return false;
}
bool sub_48_51() {
    // 48: mov
    reg_tmp5 = uniforms.f[5].xyyy;
    // 49: mov
    reg_tmp6 = uniforms.f[5].xyyy;
    // 50: mov
    reg_tmp7 = uniforms.f[5].xyyy;
    return false;
}
bool sub_52_55() {
    // 52: mov
    reg_tmp5 = uniforms.f[5].yyyy;
    // 53: mov
    reg_tmp6 = uniforms.f[5].yyyy;
    // 54: mov
    reg_tmp7 = uniforms.f[5].yyyy;
    return false;
}
bool sub_56_59() {
    // 56: mov
    reg_tmp5 = uniforms.f[5].xxyy;
    // 57: mov
    reg_tmp6 = uniforms.f[5].xxyy;
    // 58: mov
    reg_tmp7 = uniforms.f[5].xxyy;
    return false;
}
bool sub_60_63() {
    // 60: mov
    reg_tmp5 = uniforms.f[5].yxyy;
    // 61: mov
    reg_tmp6 = uniforms.f[5].yxyy;
    // 62: mov
    reg_tmp7 = uniforms.f[5].yxyy;
    return false;
}
bool sub_65_99() {
    // 65: cmp
    conditional_code = equal(vec2(uniforms.f[5].yyyy), vec2(reg_tmp8));
    // 66: ifc
    if (all(conditional_code)) {
        sub_67_86();
    }
    // 86: cmp
    conditional_code = lessThan(vec2(uniforms.f[5].wwww), vec2(reg_tmp8));
    // 87: ifc
    if (all(conditional_code)) {
        sub_88_98();
    }
    // 98: add
    reg_tmp8 = uniforms.f[5].yyyy + reg_tmp8;
    return false;
}
bool sub_67_86() {
    // 67: mova
    address_registers.y = (ivec2(reg_tmp0.zzzz)).y;
    // 68: cmp
    conditional_code = notEqual(vec2(uniforms.f[5].xxxx), vec2(reg_tmp1.xyyy));
    // 69: ifc
    if (all(not(conditional_code))) {
        sub_70_73();
    }
    // 73: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_74_77();
    }
    // 77: ifc
    if (all(bvec2(!conditional_code.x, conditional_code.y))) {
        sub_78_81();
    }
    // 81: ifc
    if (all(conditional_code)) {
        sub_82_85();
    }
    // 85: nop
    return false;
}
bool sub_70_73() {
    // 70: mov
    reg_tmp5.xy = (uniforms.f[64 + address_registers.y].wzzz).xy;
    // 71: mov
    reg_tmp6.xy = (uniforms.f[65 + address_registers.y].wzzz).xy;
    // 72: mov
    reg_tmp7.xy = (uniforms.f[66 + address_registers.y].wzzz).xy;
    return false;
}
bool sub_74_77() {
    // 74: mov
    reg_tmp5.xy = (uniforms.f[64 + address_registers.y].yzzz).xy;
    // 75: mov
    reg_tmp6.xy = (uniforms.f[65 + address_registers.y].yzzz).xy;
    // 76: mov
    reg_tmp7.xy = (uniforms.f[66 + address_registers.y].yzzz).xy;
    return false;
}
bool sub_78_81() {
    // 78: mov
    reg_tmp5.xy = (uniforms.f[64 + address_registers.y].wxxx).xy;
    // 79: mov
    reg_tmp6.xy = (uniforms.f[65 + address_registers.y].wxxx).xy;
    // 80: mov
    reg_tmp7.xy = (uniforms.f[66 + address_registers.y].wxxx).xy;
    return false;
}
bool sub_82_85() {
    // 82: mov
    reg_tmp5.xy = (uniforms.f[64 + address_registers.y].yxxx).xy;
    // 83: mov
    reg_tmp6.xy = (uniforms.f[65 + address_registers.y].yxxx).xy;
    // 84: mov
    reg_tmp7.xy = (uniforms.f[66 + address_registers.y].yxxx).xy;
    return false;
}
bool sub_88_98() {
    // 88: cmp
    conditional_code = notEqual(vec2(uniforms.f[5].xxxx), vec2(reg_tmp1.xyyy));
    // 89: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_90_93();
    }
    // 93: ifc
    if (all(bvec2(!conditional_code.x, conditional_code.y))) {
        sub_94_97();
    }
    // 97: nop
    return false;
}
bool sub_90_93() {
    // 90: mov
    reg_tmp5.xy = (uniforms.f[67 + address_registers.y].yxxx).xy;
    // 91: mov
    reg_tmp6.xy = (uniforms.f[68 + address_registers.y].yxxx).xy;
    // 92: mov
    reg_tmp7.xy = (uniforms.f[69 + address_registers.y].yxxx).xy;
    return false;
}
bool sub_94_97() {
    // 94: mov
    reg_tmp5.xy = (uniforms.f[67 + address_registers.y].wzzz).xy;
    // 95: mov
    reg_tmp6.xy = (uniforms.f[68 + address_registers.y].wzzz).xy;
    // 96: mov
    reg_tmp7.xy = (uniforms.f[69 + address_registers.y].wzzz).xy;
    return false;
}
// reference: A0955C54BD083DC7, EC7233A0BD4CF3D2
// shader: 8DD9, 5D764F9A6220D694

layout(triangles) in;
layout(triangle_strip, max_vertices = 3) out;

out vec4 primary_color;
out vec2 texcoord0;
out vec2 texcoord1;
out vec2 texcoord2;
out float texcoord0_w;
out vec4 normquat;
out vec3 view;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

 in vec4 vs_out_attr0[];
 in vec4 vs_out_attr1[];
 in vec4 vs_out_attr2[];
 in vec4 vs_out_attr3[];
 in vec4 vs_out_attr4[];

struct Vertex {
    vec4 attributes[5];
};

vec4 GetVertexQuaternion(Vertex vtx) {
    return vec4(0.0, 0.0, 0.0, 0.0);
}

void EmitVtx(Vertex vtx, bool quats_opposite) {
    vec4 vtx_pos = vec4(vtx.attributes[0].x, vtx.attributes[0].y, vtx.attributes[0].z, vtx.attributes[0].w);
    gl_Position = vtx_pos;
#if !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)
    gl_ClipDistance[0] = -vtx_pos.z;
    gl_ClipDistance[1] = dot(clip_coef, vtx_pos);
#endif // !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)

    vec4 vtx_quat = GetVertexQuaternion(vtx);
    normquat = mix(vtx_quat, -vtx_quat, bvec4(quats_opposite));

    vec4 vtx_color = vec4(vtx.attributes[1].x, vtx.attributes[1].y, vtx.attributes[1].z, vtx.attributes[1].w);
    primary_color = min(abs(vtx_color), vec4(1.0));

    texcoord0 = vec2(vtx.attributes[2].x, vtx.attributes[2].y);
    texcoord1 = vec2(vtx.attributes[3].x, vtx.attributes[3].y);

    texcoord0_w = 0.0;
    view = vec3(0.0, 0.0, 0.0);

    texcoord2 = vec2(vtx.attributes[4].x, vtx.attributes[4].y);

    EmitVertex();
}

bool AreQuaternionsOpposite(vec4 qa, vec4 qb) {
    return (dot(qa, qb) < 0.0);
}

void EmitPrim(Vertex vtx0, Vertex vtx1, Vertex vtx2) {
    EmitVtx(vtx0, false);
    EmitVtx(vtx1, AreQuaternionsOpposite(GetVertexQuaternion(vtx0), GetVertexQuaternion(vtx1)));
    EmitVtx(vtx2, AreQuaternionsOpposite(GetVertexQuaternion(vtx0), GetVertexQuaternion(vtx2)));
    EndPrimitive();
}

void main() {
    Vertex prim_buffer[3];
    prim_buffer[0].attributes = vec4[5](vs_out_attr0[0], vs_out_attr1[0], vs_out_attr2[0], vs_out_attr3[0], vs_out_attr4[0]);
    prim_buffer[1].attributes = vec4[5](vs_out_attr0[1], vs_out_attr1[1], vs_out_attr2[1], vs_out_attr3[1], vs_out_attr4[1]);
    prim_buffer[2].attributes = vec4[5](vs_out_attr0[2], vs_out_attr1[2], vs_out_attr2[2], vs_out_attr3[2], vs_out_attr4[2]);
    EmitPrim(prim_buffer[0], prim_buffer[1], prim_buffer[2]);
}
// reference: 5DAD5699F59B3586, 5D764F9A6220D694
// shader: 8B30, DCF79763677AC8BD

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((secondary_fragment_color.r) * (1.0 - const_color[0].a) + (secondary_fragment_color.b) * (1.0 - (1.0 - const_color[0].a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((secondary_fragment_color.ggg) * (last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb) * (vec3(1.0) - texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a) * (1.0 - texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (texcolor0.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (texcolor0.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: C036C25FAB94E9C9, DCF79763677AC8BD
// program: EC7233A0BD4CF3D2, 5D764F9A6220D694, DCF79763677AC8BD
// reference: 39C0241566B19C80, EC7233A0BD4CF3D2
// shader: 8B30, 77A843D46C489EFC

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((secondary_fragment_color.r) * (1.0 - const_color[0].a) + (secondary_fragment_color.b) * (1.0 - (1.0 - const_color[0].a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((secondary_fragment_color.ggg) * (last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb) * (vec3(1.0) - texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a) * (1.0 - texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (texcolor0.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (texcolor0.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: C036C25F5C7A3216, 77A843D46C489EFC
// program: 0000000000000000, 0000000000000000, 77A843D46C489EFC
// reference: FEFFE999604612BF, 30DAB74CA24CBC58
// shader: 8B30, 4928FE8C468A68D1

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((secondary_fragment_color.r) * (1.0 - const_color[0].a) + (secondary_fragment_color.b) * (1.0 - (1.0 - const_color[0].a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((secondary_fragment_color.ggg) * (last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb) * (vec3(1.0) - texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a) * (1.0 - texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (texcolor0.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (texcolor0.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 4D8BC0416EEEF9DE, 4928FE8C468A68D1
// program: 0000000000000000, 0000000000000000, 4928FE8C468A68D1
// shader: 8B30, 6A138F8AFA46FAFC

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb) * (vec3(1.0) - texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a) * (1.0 - texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (texcolor0.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (texcolor0.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: EFF8FBA8CAC51E81, 6A138F8AFA46FAFC
// program: EC7233A0BD4CF3D2, 5D764F9A6220D694, 6A138F8AFA46FAFC
// shader: 8B30, 09025DBCE79F7A1A

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb) * (vec3(1.0) - texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a) * (1.0 - texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (texcolor0.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (texcolor0.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 6245F9B60FBF0E96, 09025DBCE79F7A1A
// program: 0000000000000000, 0000000000000000, 09025DBCE79F7A1A
// shader: 8B30, 5B6311BC465DABFF

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb) * (vec3(1.0) - texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a) * (1.0 - texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (texcolor0.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (texcolor0.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: EFF8FBA83D2BC55E, 5B6311BC465DABFF
// program: 0000000000000000, 0000000000000000, 5B6311BC465DABFF
// shader: 8B30, 9F2A1B30F3F69366

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: F578F6D1739B6EEB, 9F2A1B30F3F69366
// program: 0000000000000000, 0000000000000000, 9F2A1B30F3F69366
// shader: 8B30, B74549B94C6A1F3F

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 78C5F4CF410FA523, B74549B94C6A1F3F
// program: 0000000000000000, 0000000000000000, B74549B94C6A1F3F
// shader: 8B30, 6B579E1CE02B2169

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 9786E2FC16815E35, 6B579E1CE02B2169
// program: 0000000000000000, 0000000000000000, 6B579E1CE02B2169
// shader: 8B30, 9C4704EFB4D445A9

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 1A3BE0E2241595FD, 9C4704EFB4D445A9
// program: 0000000000000000, 0000000000000000, 9C4704EFB4D445A9
// shader: 8B30, BDD69B95D0B1B7E1

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((vec3(1.0) - texcolor0.rgb) * (const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((texcolor0.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((texcolor0.rgb) * (const_color[4].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((1.0 - texcolor0.a) * (const_color[4].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 20601F574B3A083B, BDD69B95D0B1B7E1
// program: EC7233A0BD4CF3D2, 5D764F9A6220D694, BDD69B95D0B1B7E1
// shader: 8B30, 870F66C2585EC0BC

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((vec3(1.0) - texcolor0.rgb) * (const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((texcolor0.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((texcolor0.rgb) * (const_color[4].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((1.0 - texcolor0.a) * (const_color[4].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (const_color[5].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 20601F5705C28121, 870F66C2585EC0BC
// program: EC7233A0BD4CF3D2, 5D764F9A6220D694, 870F66C2585EC0BC
// shader: 8B30, B6E5EC666FD74EAA

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((vec3(1.0) - texcolor0.rgb) * (const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((texcolor0.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((texcolor0.rgb) * (const_color[4].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((1.0 - texcolor0.a) * (const_color[4].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: ADDD1D498E40182C, B6E5EC666FD74EAA
// program: 0000000000000000, 0000000000000000, B6E5EC666FD74EAA
// shader: 8B30, 4AD2C97240195A76

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += ((light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[2].position + view);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * LookupLightingLUTUnsigned(18,clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[2].specular_0) + (light_src[2].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(18,clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[3].position + view);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * LookupLightingLUTUnsigned(19,clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[3].specular_0) + (light_src[3].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(19,clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) + (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: F0811ECAA63DB4E7, 4AD2C97240195A76
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, 4AD2C97240195A76
// shader: 8B30, 666154B1BFC0A909

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += ((light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[2].position + view);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * LookupLightingLUTUnsigned(18,clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[2].specular_0) + (light_src[2].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(18,clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[3].position + view);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * LookupLightingLUTUnsigned(19,clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[3].specular_0) + (light_src[3].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(19,clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: DAB3C4832C03C0B1, 666154B1BFC0A909
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, 666154B1BFC0A909
// shader: 8B30, C27F787C261C6045

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (const_color[1].aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (const_color[1].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 487D8D2DBEC85929, C27F787C261C6045
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, C27F787C261C6045
// reference: 6C4AD557D7ECD73C, C27F787C261C6045
// reference: C63F3C132CAD7002, C27F787C261C6045
// shader: 8B30, C74CA00DB8E95117

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += ((light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[2].position + view);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * LookupLightingLUTUnsigned(18,clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[2].specular_0) + (light_src[2].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(18,clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[3].position + view);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * LookupLightingLUTUnsigned(19,clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[3].specular_0) + (light_src[3].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(19,clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor1.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor1.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_4 = byteround(clamp((vec3(1.0) - textureProj(tex0, vec3(texcoord0, texcoord0_w)).rgb) * (const_color[4].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((combiner_buffer.rgb) * (vec3(1.0) - last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: E379FD983F863A8F, C74CA00DB8E95117
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, C74CA00DB8E95117
// reference: 943A978856FF31EA, C74CA00DB8E95117
// shader: 8B31, 3DBC6131A77F0199

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;
 out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define mul_safe(x, y) mix(x * y, vec4(0.0), isnan(x * y))

float rcp_safe(float x) {
    if (x == 0.0f) return x;
    return 1.0f / x;
}


float rsq_safe(float x) {
    if (x == 0.0f) return x;
    return inversesqrt(x);
}

#define fma_safe(x, y, z) (mul_safe(x, y) + z)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_56_61();
bool sub_61_70();
bool sub_70_83();
bool sub_83_251();
bool sub_89_189();
bool sub_96_125();
bool sub_107_111();
bool sub_125_184();
bool sub_126_158();
bool sub_137_141();
bool sub_158_183();
bool sub_169_173();
bool sub_189_250();
bool sub_192_202();
bool sub_202_207();
bool sub_208_220();
bool sub_220_245();
bool sub_221_239();
bool sub_239_244();
bool sub_251_268();
bool sub_268_344();
bool sub_307_327();
bool sub_308_313();
bool sub_313_326();
bool sub_317_320();
bool sub_320_325();
bool sub_327_340();
bool sub_328_333();
bool sub_333_339();
bool sub_344_4096();
bool sub_351_356();
bool sub_353_354();
bool sub_358_359();
bool sub_362_374();
bool sub_364_365();
bool sub_365_369();
bool sub_366_367();
bool sub_367_368();
bool sub_374_384();
bool sub_388_389();
bool sub_389_393();
bool sub_390_391();
bool sub_391_392();
bool sub_401_402();
bool sub_402_406();
bool sub_403_404();
bool sub_404_405();

bool exec_shader() {
    sub_344_4096();
    return true;
}

bool sub_56_61() {
    // 56: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 57: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 58: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 59: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 60: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    return false;
}
bool sub_61_70() {
    // 61: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 62: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 63: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 64: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 65: dp3
    reg_tmp4.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 66: dp3
    reg_tmp4.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 67: dp3
    reg_tmp4.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 68: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 69: mad
    reg_tmp12 = fma_safe(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_70_83() {
    // 70: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 71: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 72: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 73: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 74: dp3
    reg_tmp4.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 75: dp3
    reg_tmp4.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 76: dp3
    reg_tmp4.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 77: dp3
    reg_tmp5.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 78: dp3
    reg_tmp5.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 79: dp3
    reg_tmp5.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 80: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 81: mad
    reg_tmp12 = fma_safe(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    // 82: mad
    reg_tmp11 = fma_safe(reg_tmp1.wwww, reg_tmp5, reg_tmp11);
    return false;
}
bool sub_83_251() {
    // 83: mul
    reg_tmp15.xyz = (mul_safe(uniforms.f[7].xxxx, vs_in_reg0)).xyz;
    // 84: mul
    reg_tmp14.xyz = (mul_safe(uniforms.f[7].yyyy, vs_in_reg1)).xyz;
    // 85: mul
    reg_tmp13.xyz = (mul_safe(uniforms.f[7].zzzz, vs_in_reg2)).xyz;
    // 86: add
    reg_tmp15.xyz = (uniforms.f[6] + reg_tmp15).xyz;
    // 87: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 88: ifu
    if (uniforms.b[1]) {
        sub_89_189();
    } else {
        sub_189_250();
    }
    // 250: nop
    return false;
}
bool sub_89_189() {
    // 89: mov
    reg_tmp0 = uniforms.f[7];
    // 90: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.yzzz));
    // 91: mov
    reg_tmp7 = uniforms.f[93].xxxx;
    // 92: mov
    reg_tmp12 = uniforms.f[93].xxxx;
    // 93: mov
    reg_tmp11 = uniforms.f[93].xxxx;
    // 94: mul
    reg_tmp2 = mul_safe(uniforms.f[93].wwww, vs_in_reg7);
    // 95: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_96_125();
    } else {
        sub_125_184();
    }
    // 184: mov
    vs_out_attr2 = -reg_tmp15;
    // 185: dp4
    vs_out_attr0.x = dot(mul_safe(uniforms.f[86], reg_tmp15), vec4(1.0));
    // 186: dp4
    vs_out_attr0.y = dot(mul_safe(uniforms.f[87], reg_tmp15), vec4(1.0));
    // 187: dp4
    vs_out_attr0.z = dot(mul_safe(uniforms.f[88], reg_tmp15), vec4(1.0));
    // 188: dp4
    vs_out_attr0.w = dot(mul_safe(uniforms.f[89], reg_tmp15), vec4(1.0));
    return false;
}
bool sub_96_125() {
    // 96: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 97: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 98: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 99: call
    {
        sub_61_70();
    }
    // 100: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 101: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 102: call
    {
        sub_61_70();
    }
    // 103: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 104: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 105: callc
    if (conditional_code.x) {
        sub_61_70();
    }
    // 106: ifu
    if (uniforms.b[8]) {
        sub_107_111();
    }
    // 111: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 112: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 113: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 114: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 115: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 116: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 117: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 118: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 119: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 120: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 121: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 122: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 123: call
    {
        sub_251_268();
    }
    // 124: nop
    return false;
}
bool sub_107_111() {
    // 107: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 108: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 109: callc
    if (conditional_code.y) {
        sub_61_70();
    }
    // 110: nop
    return false;
}
bool sub_125_184() {
    // 125: ifc
    if (all(conditional_code)) {
        sub_126_158();
    } else {
        sub_158_183();
    }
    // 183: nop
    return false;
}
bool sub_126_158() {
    // 126: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 127: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 128: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 129: call
    {
        sub_70_83();
    }
    // 130: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 131: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 132: call
    {
        sub_70_83();
    }
    // 133: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 134: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 135: callc
    if (conditional_code.x) {
        sub_70_83();
    }
    // 136: ifu
    if (uniforms.b[8]) {
        sub_137_141();
    }
    // 141: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 142: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 143: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 144: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 145: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 146: dp3
    reg_tmp13.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp11)), vec3(1.0));
    // 147: dp3
    reg_tmp13.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp11)), vec3(1.0));
    // 148: dp3
    reg_tmp13.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp11)), vec3(1.0));
    // 149: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 150: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 151: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 152: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 153: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 154: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 155: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 156: call
    {
        sub_268_344();
    }
    // 157: nop
    return false;
}
bool sub_137_141() {
    // 137: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 138: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 139: callc
    if (conditional_code.y) {
        sub_70_83();
    }
    // 140: nop
    return false;
}
bool sub_158_183() {
    // 158: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 159: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 160: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 161: call
    {
        sub_56_61();
    }
    // 162: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 163: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 164: call
    {
        sub_56_61();
    }
    // 165: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 166: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 167: callc
    if (conditional_code.x) {
        sub_56_61();
    }
    // 168: ifu
    if (uniforms.b[8]) {
        sub_169_173();
    }
    // 173: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 174: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 175: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 176: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 177: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 178: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 179: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 180: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 181: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 182: mov
    vs_out_attr1 = uniforms.f[93].xxxx;
    return false;
}
bool sub_169_173() {
    // 169: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 170: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 171: callc
    if (conditional_code.y) {
        sub_56_61();
    }
    // 172: nop
    return false;
}
bool sub_189_250() {
    // 189: mov
    reg_tmp0 = uniforms.f[7];
    // 190: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.yzzz));
    // 191: ifu
    if (uniforms.b[2]) {
        sub_192_202();
    } else {
        sub_202_207();
    }
    // 207: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_208_220();
    } else {
        sub_220_245();
    }
    // 245: mov
    vs_out_attr2 = -reg_tmp15;
    // 246: dp4
    vs_out_attr0.x = dot(mul_safe(uniforms.f[86], reg_tmp15), vec4(1.0));
    // 247: dp4
    vs_out_attr0.y = dot(mul_safe(uniforms.f[87], reg_tmp15), vec4(1.0));
    // 248: dp4
    vs_out_attr0.z = dot(mul_safe(uniforms.f[88], reg_tmp15), vec4(1.0));
    // 249: dp4
    vs_out_attr0.w = dot(mul_safe(uniforms.f[89], reg_tmp15), vec4(1.0));
    return false;
}
bool sub_192_202() {
    // 192: mul
    reg_tmp1.x = (mul_safe(uniforms.f[93].wwww, vs_in_reg7.xxxx)).x;
    // 193: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 194: dp4
    reg_tmp7.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 195: dp4
    reg_tmp7.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 196: dp4
    reg_tmp7.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 197: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 198: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 199: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 200: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 201: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_202_207() {
    // 202: mova
    address_registers.x = (ivec2(uniforms.f[93].xxxx)).x;
    // 203: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[25], reg_tmp15), vec4(1.0));
    // 204: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[26], reg_tmp15), vec4(1.0));
    // 205: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[27], reg_tmp15), vec4(1.0));
    // 206: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_208_220() {
    // 208: dp3
    reg_tmp12.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 209: dp3
    reg_tmp12.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 210: dp3
    reg_tmp12.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 211: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 212: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 213: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 214: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 215: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 216: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 217: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 218: call
    {
        sub_251_268();
    }
    // 219: nop
    return false;
}
bool sub_220_245() {
    // 220: ifc
    if (all(conditional_code)) {
        sub_221_239();
    } else {
        sub_239_244();
    }
    // 244: nop
    return false;
}
bool sub_221_239() {
    // 221: dp3
    reg_tmp12.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 222: dp3
    reg_tmp12.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 223: dp3
    reg_tmp12.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 224: dp3
    reg_tmp11.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 225: dp3
    reg_tmp11.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 226: dp3
    reg_tmp11.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 227: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 228: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 229: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 230: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 231: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 232: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 233: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 234: dp3
    reg_tmp13.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp11)), vec3(1.0));
    // 235: dp3
    reg_tmp13.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp11)), vec3(1.0));
    // 236: dp3
    reg_tmp13.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp11)), vec3(1.0));
    // 237: call
    {
        sub_268_344();
    }
    // 238: nop
    return false;
}
bool sub_239_244() {
    // 239: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 240: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 241: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 242: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 243: mov
    vs_out_attr1 = uniforms.f[93].xxxx;
    return false;
}
bool sub_251_268() {
    uint jmp_to = 251u;
    while (true) {
        switch (jmp_to) {
        case 251u: {
            // 251: dp3
            reg_tmp6.x = dot(vec3(mul_safe(reg_tmp14, reg_tmp14)), vec3(1.0));
            // 252: dp3
            reg_tmp7.x = dot(vec3(mul_safe(reg_tmp12, reg_tmp12)), vec3(1.0));
            // 253: rsq
            reg_tmp6.x = rsq_safe(reg_tmp6.xxxx.x);
            // 254: rsq
            reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
            // 255: mul
            reg_tmp14.xyz = (mul_safe(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 256: mul
            reg_tmp12.xyz = (mul_safe(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 257: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 258: jmpu
            if (!uniforms.b[15]) {
                { jmp_to = 267u; break; }
            }
            // 259: add
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            // 260: mul
            reg_tmp4 = mul_safe(uniforms.f[94].zzzz, reg_tmp4);
            // 261: cmp
            conditional_code = greaterThanEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp4.xxxx));
            // 262: rsq
            reg_tmp4 = vec4(rsq_safe(reg_tmp4.xxxx.x));
            // 263: mul
            reg_tmp5 = mul_safe(uniforms.f[94].zzzz, reg_tmp14);
            // 264: jmpc
            if (conditional_code.x) {
                { jmp_to = 267u; break; }
            }
            // 265: rcp
            reg_tmp0.z = rcp_safe(reg_tmp4.xxxx.x);
            // 266: mul
            reg_tmp0.xy = (mul_safe(reg_tmp5, reg_tmp4)).xy;
        }
        case 267u: {
            // 267: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_268_344() {
    uint jmp_to = 268u;
    while (true) {
        switch (jmp_to) {
        case 268u: {
            // 268: dp3
            reg_tmp6.x = dot(vec3(mul_safe(reg_tmp14, reg_tmp14)), vec3(1.0));
            // 269: dp3
            reg_tmp7.x = dot(vec3(mul_safe(reg_tmp12, reg_tmp12)), vec3(1.0));
            // 270: rsq
            reg_tmp6.x = rsq_safe(reg_tmp6.xxxx.x);
            // 271: rsq
            reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
            // 272: mul
            reg_tmp14.xyz = (mul_safe(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 273: mul
            reg_tmp12.xyz = (mul_safe(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 274: mul
            reg_tmp13.xyz = (mul_safe(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            // 275: mul
            reg_tmp11.xyz = (mul_safe(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            // 276: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 277: jmpu
            if (!uniforms.b[15]) {
                { jmp_to = 343u; break; }
            }
            // 278: mul
            reg_tmp13.xyz = (mul_safe(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            // 279: mul
            reg_tmp11.xyz = (mul_safe(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            // 280: mul
            reg_tmp5 = mul_safe(reg_tmp14.yzxx, reg_tmp13.zxyy);
            // 281: mad
            reg_tmp5 = fma_safe(-reg_tmp13.yzxx, reg_tmp14.zxyy, reg_tmp5);
            // 282: dp3
            reg_tmp5.w = dot(vec3(mul_safe(reg_tmp5, reg_tmp5)), vec3(1.0));
            // 283: rsq
            reg_tmp5.w = rsq_safe(reg_tmp5.wwww.x);
            // 284: mul
            reg_tmp5 = mul_safe(reg_tmp5, reg_tmp5.wwww);
            // 285: add
            reg_tmp6.w = (reg_tmp14.zzzz + reg_tmp5.yyyy).w;
            // 286: mul
            reg_tmp13 = mul_safe(reg_tmp5.yzxx, reg_tmp14.zxyy);
            // 287: mad
            reg_tmp13 = fma_safe(-reg_tmp14.yzxx, reg_tmp5.zxyy, reg_tmp13);
            // 288: add
            reg_tmp6.w = (reg_tmp13.xxxx + reg_tmp6).w;
            // 289: mov
            reg_tmp13.w = (reg_tmp5.zzzz).w;
            // 290: mov
            reg_tmp5.z = (reg_tmp13.xxxx).z;
            // 291: add
            reg_tmp6.w = (uniforms.f[93].yyyy + reg_tmp6).w;
            // 292: mov
            reg_tmp14.w = (reg_tmp5.xxxx).w;
            // 293: mov
            reg_tmp5.x = (reg_tmp14.zzzz).x;
            // 294: cmp
            conditional_code = lessThan(vec2(uniforms.f[94].yyyy), vec2(reg_tmp6.wwww));
            // 295: mov
            reg_tmp6.x = (uniforms.f[93].yyyy).x;
            // 296: mov
            reg_tmp6.y = (-uniforms.f[93].yyyy).y;
            // 297: jmpc
            if (!conditional_code.x) {
                { jmp_to = 305u; break; }
            }
            // 298: add
            reg_tmp7.xz = (reg_tmp13.wwyy + -reg_tmp14.yyww).xz;
            // 299: add
            reg_tmp7.y = (reg_tmp14.xxxx + -reg_tmp13.zzzz).y;
            // 300: mov
            reg_tmp7.w = (reg_tmp6).w;
            // 301: dp4
            reg_tmp6 = vec4(dot(mul_safe(reg_tmp7, reg_tmp7), vec4(1.0)));
            // 302: rsq
            reg_tmp6 = vec4(rsq_safe(reg_tmp6.xxxx.x));
            // 303: mul
            reg_tmp0 = mul_safe(reg_tmp7, reg_tmp6);
            // 304: jmpu
            if (uniforms.b[0]) {
                { jmp_to = 343u; break; }
            }
        }
        case 305u: {
            // 305: cmp
            conditional_code = greaterThan(vec2(reg_tmp5.zyyy), vec2(reg_tmp5.yxxx));
            // 306: ifc
            if (conditional_code.x) {
                sub_307_327();
            } else {
                sub_327_340();
            }
            // 340: dp4
            reg_tmp6 = vec4(dot(mul_safe(reg_tmp8, reg_tmp8), vec4(1.0)));
            // 341: rsq
            reg_tmp6 = vec4(rsq_safe(reg_tmp6.xxxx.x));
            // 342: mul
            reg_tmp0 = mul_safe(reg_tmp8, reg_tmp6);
        }
        case 343u: {
            // 343: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_307_327() {
    // 307: ifc
    if (conditional_code.y) {
        sub_308_313();
    } else {
        sub_313_326();
    }
    // 326: mov
    reg_tmp8.w = (-reg_tmp8).w;
    return false;
}
bool sub_308_313() {
    // 308: mul
    reg_tmp8 = mul_safe(reg_tmp13.yyzw, reg_tmp6.xxxy);
    // 309: add
    reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
    // 310: add
    reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
    // 311: add
    reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
    // 312: add
    reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
    return false;
}
bool sub_313_326() {
    // 313: cmp
    conditional_code = greaterThan(vec2(reg_tmp5.zzzz), vec2(reg_tmp5.xxxx));
    // 314: mul
    reg_tmp8 = mul_safe(reg_tmp13.yyzw, reg_tmp6.xxxy);
    // 315: add
    reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
    // 316: ifc
    if (conditional_code.x) {
        sub_317_320();
    } else {
        sub_320_325();
    }
    // 325: nop
    return false;
}
bool sub_317_320() {
    // 317: add
    reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
    // 318: add
    reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
    // 319: add
    reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
    return false;
}
bool sub_320_325() {
    // 320: mul
    reg_tmp8 = mul_safe(reg_tmp13.zwwy, reg_tmp6.xxxy);
    // 321: add
    reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
    // 322: add
    reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
    // 323: add
    reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
    // 324: add
    reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
    return false;
}
bool sub_327_340() {
    // 327: ifc
    if (conditional_code.y) {
        sub_328_333();
    } else {
        sub_333_339();
    }
    // 339: nop
    return false;
}
bool sub_328_333() {
    // 328: mul
    reg_tmp8 = mul_safe(reg_tmp13.yywz, reg_tmp6.xxxy);
    // 329: add
    reg_tmp8.y = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).y;
    // 330: add
    reg_tmp9 = reg_tmp5.yyyy + -reg_tmp5.xxxx;
    // 331: add
    reg_tmp8.xzw = (reg_tmp8 + reg_tmp14.wwyx).xzw;
    // 332: add
    reg_tmp8.y = (reg_tmp9 + reg_tmp8).y;
    return false;
}
bool sub_333_339() {
    // 333: mul
    reg_tmp8 = mul_safe(reg_tmp13.zwwy, reg_tmp6.xxxy);
    // 334: add
    reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
    // 335: add
    reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
    // 336: add
    reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
    // 337: add
    reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
    // 338: mov
    reg_tmp8.w = (-reg_tmp8).w;
    return false;
}
bool sub_344_4096() {
    // 344: call
    {
        sub_83_251();
    }
    // 345: mov
    reg_tmp8.xy = (uniforms.f[93].xxxx).xy;
    // 346: mov
    reg_tmp0.y = (uniforms.f[7].wwww).y;
    // 347: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.xyyy));
    // 348: mov
    reg_tmp9.xyz = (uniforms.f[93].xxxx).xyz;
    // 349: mov
    reg_tmp9.w = (uniforms.f[21].wwww).w;
    // 350: ifc
    if (conditional_code.y) {
        sub_351_356();
    }
    // 356: cmp
    conditional_code = equal(vec2(uniforms.f[93].xxxx), vec2(reg_tmp8.xyyy));
    // 357: ifc
    if (all(conditional_code)) {
        sub_358_359();
    }
    // 359: max
    vs_out_attr3 = max(uniforms.f[93].xxxx, reg_tmp9);
    // 360: mov
    reg_tmp0.xy = (uniforms.f[10].xxxx).xy;
    // 361: ifu
    if (uniforms.b[9]) {
        sub_362_374();
    } else {
        sub_374_384();
    }
    // 384: nop
    // 385: mov
    reg_tmp0.xy = (uniforms.f[10].yyyy).xy;
    // 386: cmp
    conditional_code = equal(vec2(uniforms.f[93].yzzz), vec2(reg_tmp0.xyyy));
    // 387: ifc
    if (all(not(conditional_code))) {
        sub_388_389();
    } else {
        sub_389_393();
    }
    // 393: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 394: dp4
    reg_tmp4.x = dot(mul_safe(uniforms.f[14].xywz, reg_tmp6), vec4(1.0));
    // 395: dp4
    reg_tmp4.y = dot(mul_safe(uniforms.f[15].xywz, reg_tmp6), vec4(1.0));
    // 396: mov
    vs_out_attr5 = reg_tmp4;
    // 397: nop
    // 398: mov
    reg_tmp0.xy = (uniforms.f[10].zzzz).xy;
    // 399: cmp
    conditional_code = equal(vec2(uniforms.f[93].yzzz), vec2(reg_tmp0.xyyy));
    // 400: ifc
    if (all(not(conditional_code))) {
        sub_401_402();
    } else {
        sub_402_406();
    }
    // 406: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 407: dp4
    reg_tmp5.x = dot(mul_safe(uniforms.f[17].xywz, reg_tmp6), vec4(1.0));
    // 408: dp4
    reg_tmp5.y = dot(mul_safe(uniforms.f[18].xywz, reg_tmp6), vec4(1.0));
    // 409: mov
    vs_out_attr6 = reg_tmp5;
    // 410: nop
    // 411: end
    return true;
}
bool sub_351_356() {
    // 351: mul
    reg_tmp0 = mul_safe(uniforms.f[7].wwww, vs_in_reg3);
    // 352: ifu
    if (uniforms.b[7]) {
        sub_353_354();
    }
    // 354: mul
    reg_tmp9.xyz = (mul_safe(uniforms.f[20].wwww, reg_tmp0.xyzz)).xyz;
    // 355: mov
    reg_tmp8.x = (uniforms.f[93].yyyy).x;
    return false;
}
bool sub_353_354() {
    // 353: mul
    reg_tmp9.w = (mul_safe(reg_tmp9.wwww, reg_tmp0.wwww)).w;
    return false;
}
bool sub_358_359() {
    // 358: mov
    reg_tmp9 = uniforms.f[21];
    return false;
}
bool sub_362_374() {
    // 362: cmp
    conditional_code = equal(vec2(uniforms.f[93].yzzz), vec2(reg_tmp0.xyyy));
    // 363: ifc
    if (all(not(conditional_code))) {
        sub_364_365();
    } else {
        sub_365_369();
    }
    // 369: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 370: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[11].xywz, reg_tmp6), vec4(1.0));
    // 371: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[12].xywz, reg_tmp6), vec4(1.0));
    // 372: mov
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    // 373: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_364_365() {
    // 364: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
    return false;
}
bool sub_365_369() {
    // 365: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_366_367();
    } else {
        sub_367_368();
    }
    // 368: nop
    return false;
}
bool sub_366_367() {
    // 366: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
    return false;
}
bool sub_367_368() {
    // 367: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
    return false;
}
bool sub_374_384() {
    // 374: cmp
    conditional_code = equal(vec2(uniforms.f[95].xyyy), vec2(reg_tmp0.xyyy));
    // 375: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 376: mov
    reg_tmp6 = reg_tmp10;
    // 377: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[11], reg_tmp6), vec4(1.0));
    // 378: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[12], reg_tmp6), vec4(1.0));
    // 379: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[13], reg_tmp6), vec4(1.0));
    // 380: mul
    reg_tmp0.xy = (mul_safe(uniforms.f[19].xyyy, reg_tmp3.zzzz)).xy;
    // 381: add
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    // 382: nop
    // 383: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_388_389() {
    // 388: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
    return false;
}
bool sub_389_393() {
    // 389: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_390_391();
    } else {
        sub_391_392();
    }
    // 392: nop
    return false;
}
bool sub_390_391() {
    // 390: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
    return false;
}
bool sub_391_392() {
    // 391: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
    return false;
}
bool sub_401_402() {
    // 401: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
    return false;
}
bool sub_402_406() {
    // 402: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_403_404();
    } else {
        sub_404_405();
    }
    // 405: nop
    return false;
}
bool sub_403_404() {
    // 403: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
    return false;
}
bool sub_404_405() {
    // 404: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
    return false;
}
// reference: 64BD0C9E7810A4F3, 3DBC6131A77F0199
// shader: 8DD9, AD7922A63ED54CA7

layout(triangles) in;
layout(triangle_strip, max_vertices = 3) out;

out vec4 primary_color;
out vec2 texcoord0;
out vec2 texcoord1;
out vec2 texcoord2;
out float texcoord0_w;
out vec4 normquat;
out vec3 view;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

 in vec4 vs_out_attr0[];
 in vec4 vs_out_attr1[];
 in vec4 vs_out_attr2[];
 in vec4 vs_out_attr3[];
 in vec4 vs_out_attr4[];
 in vec4 vs_out_attr5[];
 in vec4 vs_out_attr6[];

struct Vertex {
    vec4 attributes[7];
};

vec4 GetVertexQuaternion(Vertex vtx) {
    return vec4(vtx.attributes[1].x, vtx.attributes[1].y, vtx.attributes[1].z, vtx.attributes[1].w);
}

void EmitVtx(Vertex vtx, bool quats_opposite) {
    vec4 vtx_pos = vec4(vtx.attributes[0].x, vtx.attributes[0].y, vtx.attributes[0].z, vtx.attributes[0].w);
    gl_Position = vtx_pos;
#if !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)
    gl_ClipDistance[0] = -vtx_pos.z;
    gl_ClipDistance[1] = dot(clip_coef, vtx_pos);
#endif // !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)

    vec4 vtx_quat = GetVertexQuaternion(vtx);
    normquat = mix(vtx_quat, -vtx_quat, bvec4(quats_opposite));

    vec4 vtx_color = vec4(vtx.attributes[3].x, vtx.attributes[3].y, vtx.attributes[3].z, vtx.attributes[3].w);
    primary_color = min(abs(vtx_color), vec4(1.0));

    texcoord0 = vec2(vtx.attributes[4].x, vtx.attributes[4].y);
    texcoord1 = vec2(vtx.attributes[5].x, vtx.attributes[5].y);

    texcoord0_w = vtx.attributes[4].z;
    view = vec3(vtx.attributes[2].x, vtx.attributes[2].y, vtx.attributes[2].z);

    texcoord2 = vec2(vtx.attributes[6].x, vtx.attributes[6].y);

    EmitVertex();
}

bool AreQuaternionsOpposite(vec4 qa, vec4 qb) {
    return (dot(qa, qb) < 0.0);
}

void EmitPrim(Vertex vtx0, Vertex vtx1, Vertex vtx2) {
    EmitVtx(vtx0, false);
    EmitVtx(vtx1, AreQuaternionsOpposite(GetVertexQuaternion(vtx0), GetVertexQuaternion(vtx1)));
    EmitVtx(vtx2, AreQuaternionsOpposite(GetVertexQuaternion(vtx0), GetVertexQuaternion(vtx2)));
    EndPrimitive();
}

void main() {
    Vertex prim_buffer[3];
    prim_buffer[0].attributes = vec4[7](vs_out_attr0[0], vs_out_attr1[0], vs_out_attr2[0], vs_out_attr3[0], vs_out_attr4[0], vs_out_attr5[0], vs_out_attr6[0]);
    prim_buffer[1].attributes = vec4[7](vs_out_attr0[1], vs_out_attr1[1], vs_out_attr2[1], vs_out_attr3[1], vs_out_attr4[1], vs_out_attr5[1], vs_out_attr6[1]);
    prim_buffer[2].attributes = vec4[7](vs_out_attr0[2], vs_out_attr1[2], vs_out_attr2[2], vs_out_attr3[2], vs_out_attr4[2], vs_out_attr5[2], vs_out_attr6[2]);
    EmitPrim(prim_buffer[0], prim_buffer[1], prim_buffer[2]);
}
// reference: FC74FA4ACA1C8C74, AD7922A63ED54CA7
// program: 3DBC6131A77F0199, AD7922A63ED54CA7, C74CA00DB8E95117
// shader: 8B31, B582B9861A22E219

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define mul_safe(x, y) mix(x * y, vec4(0.0), isnan(x * y))

float rcp_safe(float x) {
    if (x == 0.0f) return x;
    return 1.0f / x;
}


float rsq_safe(float x) {
    if (x == 0.0f) return x;
    return inversesqrt(x);
}

#define fma_safe(x, y, z) (mul_safe(x, y) + z)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_4096();
bool sub_7_12();
bool sub_9_10();
bool sub_14_15();
bool sub_18_30();
bool sub_20_21();
bool sub_21_25();
bool sub_22_23();
bool sub_23_24();
bool sub_30_40();
bool sub_44_45();
bool sub_45_49();
bool sub_46_47();
bool sub_47_48();
bool sub_56_61();
bool sub_61_70();
bool sub_70_83();
bool sub_83_293();
bool sub_89_210();
bool sub_96_130();
bool sub_107_111();
bool sub_130_199();
bool sub_131_168();
bool sub_142_146();
bool sub_168_198();
bool sub_179_183();
bool sub_208_209();
bool sub_210_292();
bool sub_211_221();
bool sub_221_226();
bool sub_229_246();
bool sub_246_281();
bool sub_247_270();
bool sub_270_280();
bool sub_290_291();
bool sub_293_310();
bool sub_310_386();
bool sub_349_369();
bool sub_350_355();
bool sub_355_368();
bool sub_359_362();
bool sub_362_367();
bool sub_369_382();
bool sub_370_375();
bool sub_375_381();

bool exec_shader() {
    sub_0_4096();
    return true;
}

bool sub_0_4096() {
    // 0: call
    {
        sub_83_293();
    }
    // 1: mov
    reg_tmp8.xy = (uniforms.f[93].xxxx).xy;
    // 2: mov
    reg_tmp0.y = (uniforms.f[7].wwww).y;
    // 3: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.xyyy));
    // 4: mov
    reg_tmp9.xyz = (uniforms.f[93].xxxx).xyz;
    // 5: mov
    reg_tmp9.w = (uniforms.f[21].wwww).w;
    // 6: ifc
    if (conditional_code.y) {
        sub_7_12();
    }
    // 12: cmp
    conditional_code = equal(vec2(uniforms.f[93].xxxx), vec2(reg_tmp8.xyyy));
    // 13: ifc
    if (all(conditional_code)) {
        sub_14_15();
    }
    // 15: max
    vs_out_attr3 = max(uniforms.f[93].xxxx, reg_tmp9);
    // 16: mov
    reg_tmp0.xy = (uniforms.f[10].xxxx).xy;
    // 17: ifu
    if (uniforms.b[9]) {
        sub_18_30();
    } else {
        sub_30_40();
    }
    // 40: nop
    // 41: mov
    reg_tmp0.xy = (uniforms.f[10].yyyy).xy;
    // 42: cmp
    conditional_code = equal(vec2(uniforms.f[93].yzzz), vec2(reg_tmp0.xyyy));
    // 43: ifc
    if (all(not(conditional_code))) {
        sub_44_45();
    } else {
        sub_45_49();
    }
    // 49: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 50: dp4
    reg_tmp4.x = dot(mul_safe(uniforms.f[14].xywz, reg_tmp6), vec4(1.0));
    // 51: dp4
    reg_tmp4.y = dot(mul_safe(uniforms.f[15].xywz, reg_tmp6), vec4(1.0));
    // 52: mov
    vs_out_attr5 = reg_tmp4;
    // 53: nop
    // 54: end
    return true;
}
bool sub_7_12() {
    // 7: mul
    reg_tmp0 = mul_safe(uniforms.f[7].wwww, vs_in_reg3);
    // 8: ifu
    if (uniforms.b[7]) {
        sub_9_10();
    }
    // 10: mul
    reg_tmp9.xyz = (mul_safe(uniforms.f[20].wwww, reg_tmp0.xyzz)).xyz;
    // 11: mov
    reg_tmp8.x = (uniforms.f[93].yyyy).x;
    return false;
}
bool sub_9_10() {
    // 9: mul
    reg_tmp9.w = (mul_safe(reg_tmp9.wwww, reg_tmp0.wwww)).w;
    return false;
}
bool sub_14_15() {
    // 14: mov
    reg_tmp9 = uniforms.f[21];
    return false;
}
bool sub_18_30() {
    // 18: cmp
    conditional_code = equal(vec2(uniforms.f[93].yzzz), vec2(reg_tmp0.xyyy));
    // 19: ifc
    if (all(not(conditional_code))) {
        sub_20_21();
    } else {
        sub_21_25();
    }
    // 25: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 26: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[11].xywz, reg_tmp6), vec4(1.0));
    // 27: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[12].xywz, reg_tmp6), vec4(1.0));
    // 28: mov
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    // 29: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_20_21() {
    // 20: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
    return false;
}
bool sub_21_25() {
    // 21: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_22_23();
    } else {
        sub_23_24();
    }
    // 24: nop
    return false;
}
bool sub_22_23() {
    // 22: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
    return false;
}
bool sub_23_24() {
    // 23: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
    return false;
}
bool sub_30_40() {
    // 30: cmp
    conditional_code = equal(vec2(uniforms.f[95].xyyy), vec2(reg_tmp0.xyyy));
    // 31: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 32: mov
    reg_tmp6 = reg_tmp10;
    // 33: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[11], reg_tmp6), vec4(1.0));
    // 34: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[12], reg_tmp6), vec4(1.0));
    // 35: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[13], reg_tmp6), vec4(1.0));
    // 36: mul
    reg_tmp0.xy = (mul_safe(uniforms.f[19].xyyy, reg_tmp3.zzzz)).xy;
    // 37: add
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    // 38: nop
    // 39: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_44_45() {
    // 44: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
    return false;
}
bool sub_45_49() {
    // 45: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_46_47();
    } else {
        sub_47_48();
    }
    // 48: nop
    return false;
}
bool sub_46_47() {
    // 46: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
    return false;
}
bool sub_47_48() {
    // 47: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
    return false;
}
bool sub_56_61() {
    // 56: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 57: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 58: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 59: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 60: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    return false;
}
bool sub_61_70() {
    // 61: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 62: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 63: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 64: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 65: dp3
    reg_tmp4.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 66: dp3
    reg_tmp4.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 67: dp3
    reg_tmp4.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 68: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 69: mad
    reg_tmp12 = fma_safe(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_70_83() {
    // 70: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 71: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 72: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 73: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 74: dp3
    reg_tmp4.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 75: dp3
    reg_tmp4.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 76: dp3
    reg_tmp4.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 77: dp3
    reg_tmp5.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 78: dp3
    reg_tmp5.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 79: dp3
    reg_tmp5.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 80: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 81: mad
    reg_tmp12 = fma_safe(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    // 82: mad
    reg_tmp11 = fma_safe(reg_tmp1.wwww, reg_tmp5, reg_tmp11);
    return false;
}
bool sub_83_293() {
    // 83: mul
    reg_tmp15.xyz = (mul_safe(uniforms.f[7].xxxx, vs_in_reg0)).xyz;
    // 84: mul
    reg_tmp14.xyz = (mul_safe(uniforms.f[7].yyyy, vs_in_reg1)).xyz;
    // 85: mul
    reg_tmp13.xyz = (mul_safe(uniforms.f[7].zzzz, vs_in_reg2)).xyz;
    // 86: add
    reg_tmp15.xyz = (uniforms.f[6] + reg_tmp15).xyz;
    // 87: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 88: ifu
    if (uniforms.b[1]) {
        sub_89_210();
    } else {
        sub_210_292();
    }
    // 292: nop
    return false;
}
bool sub_89_210() {
    // 89: mov
    reg_tmp0 = uniforms.f[7];
    // 90: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.yzzz));
    // 91: mov
    reg_tmp7 = uniforms.f[93].xxxx;
    // 92: mov
    reg_tmp12 = uniforms.f[93].xxxx;
    // 93: mov
    reg_tmp11 = uniforms.f[93].xxxx;
    // 94: mul
    reg_tmp2 = mul_safe(uniforms.f[93].wwww, vs_in_reg7);
    // 95: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_96_130();
    } else {
        sub_130_199();
    }
    // 199: mov
    vs_out_attr2 = -reg_tmp15;
    // 200: dp4
    reg_tmp0.x = dot(mul_safe(uniforms.f[86], reg_tmp15), vec4(1.0));
    // 201: dp4
    reg_tmp0.y = dot(mul_safe(uniforms.f[87], reg_tmp15), vec4(1.0));
    // 202: dp4
    reg_tmp0.z = dot(mul_safe(uniforms.f[88], reg_tmp15), vec4(1.0));
    // 203: dp4
    reg_tmp0.w = dot(mul_safe(uniforms.f[89], reg_tmp15), vec4(1.0));
    // 204: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 205: mul
    reg_tmp1.y = (mul_safe(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
    // 206: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 207: ifc
    if (all(conditional_code)) {
        sub_208_209();
    }
    // 209: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_96_130() {
    // 96: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 97: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 98: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 99: call
    {
        sub_61_70();
    }
    // 100: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 101: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 102: call
    {
        sub_61_70();
    }
    // 103: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 104: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 105: callc
    if (conditional_code.x) {
        sub_61_70();
    }
    // 106: ifu
    if (uniforms.b[8]) {
        sub_107_111();
    }
    // 111: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 112: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 113: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 114: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 115: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 116: mov
    reg_tmp7 = reg_tmp10;
    // 117: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[22], reg_tmp7), vec4(1.0));
    // 118: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[23], reg_tmp7), vec4(1.0));
    // 119: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[24], reg_tmp7), vec4(1.0));
    // 120: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 121: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 122: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 123: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 124: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 125: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 126: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 127: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 128: call
    {
        sub_293_310();
    }
    // 129: nop
    return false;
}
bool sub_107_111() {
    // 107: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 108: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 109: callc
    if (conditional_code.y) {
        sub_61_70();
    }
    // 110: nop
    return false;
}
bool sub_130_199() {
    // 130: ifc
    if (all(conditional_code)) {
        sub_131_168();
    } else {
        sub_168_198();
    }
    // 198: nop
    return false;
}
bool sub_131_168() {
    // 131: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 132: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 133: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 134: call
    {
        sub_70_83();
    }
    // 135: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 136: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 137: call
    {
        sub_70_83();
    }
    // 138: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 139: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 140: callc
    if (conditional_code.x) {
        sub_70_83();
    }
    // 141: ifu
    if (uniforms.b[8]) {
        sub_142_146();
    }
    // 146: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 147: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 148: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 149: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 150: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 151: mov
    reg_tmp7 = reg_tmp10;
    // 152: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[22], reg_tmp7), vec4(1.0));
    // 153: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[23], reg_tmp7), vec4(1.0));
    // 154: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[24], reg_tmp7), vec4(1.0));
    // 155: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 156: dp3
    reg_tmp13.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp11)), vec3(1.0));
    // 157: dp3
    reg_tmp13.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp11)), vec3(1.0));
    // 158: dp3
    reg_tmp13.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp11)), vec3(1.0));
    // 159: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 160: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 161: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 162: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 163: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 164: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 165: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 166: call
    {
        sub_310_386();
    }
    // 167: nop
    return false;
}
bool sub_142_146() {
    // 142: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 143: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 144: callc
    if (conditional_code.y) {
        sub_70_83();
    }
    // 145: nop
    return false;
}
bool sub_168_198() {
    // 168: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 169: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 170: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 171: call
    {
        sub_56_61();
    }
    // 172: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 173: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 174: call
    {
        sub_56_61();
    }
    // 175: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 176: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 177: callc
    if (conditional_code.x) {
        sub_56_61();
    }
    // 178: ifu
    if (uniforms.b[8]) {
        sub_179_183();
    }
    // 183: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 184: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 185: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 186: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 187: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 188: mov
    reg_tmp7 = reg_tmp10;
    // 189: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[22], reg_tmp7), vec4(1.0));
    // 190: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[23], reg_tmp7), vec4(1.0));
    // 191: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[24], reg_tmp7), vec4(1.0));
    // 192: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 193: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 194: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 195: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 196: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 197: mov
    vs_out_attr1 = uniforms.f[93].xxxx;
    return false;
}
bool sub_179_183() {
    // 179: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 180: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 181: callc
    if (conditional_code.y) {
        sub_56_61();
    }
    // 182: nop
    return false;
}
bool sub_208_209() {
    // 208: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_210_292() {
    // 210: ifu
    if (uniforms.b[2]) {
        sub_211_221();
    } else {
        sub_221_226();
    }
    // 226: mov
    reg_tmp0 = uniforms.f[7];
    // 227: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.yzzz));
    // 228: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_229_246();
    } else {
        sub_246_281();
    }
    // 281: mov
    vs_out_attr2 = -reg_tmp15;
    // 282: dp4
    reg_tmp0.x = dot(mul_safe(uniforms.f[86], reg_tmp15), vec4(1.0));
    // 283: dp4
    reg_tmp0.y = dot(mul_safe(uniforms.f[87], reg_tmp15), vec4(1.0));
    // 284: dp4
    reg_tmp0.z = dot(mul_safe(uniforms.f[88], reg_tmp15), vec4(1.0));
    // 285: dp4
    reg_tmp0.w = dot(mul_safe(uniforms.f[89], reg_tmp15), vec4(1.0));
    // 286: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 287: mul
    reg_tmp1.y = (mul_safe(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
    // 288: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 289: ifc
    if (all(conditional_code)) {
        sub_290_291();
    }
    // 291: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_211_221() {
    // 211: mul
    reg_tmp1.x = (mul_safe(uniforms.f[93].wwww, vs_in_reg7.xxxx)).x;
    // 212: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 213: dp4
    reg_tmp7.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 214: dp4
    reg_tmp7.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 215: dp4
    reg_tmp7.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 216: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 217: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 218: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 219: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 220: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_221_226() {
    // 221: mova
    address_registers.x = (ivec2(uniforms.f[93].xxxx)).x;
    // 222: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[25], reg_tmp15), vec4(1.0));
    // 223: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[26], reg_tmp15), vec4(1.0));
    // 224: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[27], reg_tmp15), vec4(1.0));
    // 225: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_229_246() {
    // 229: dp3
    reg_tmp12.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 230: dp3
    reg_tmp12.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 231: dp3
    reg_tmp12.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 232: mov
    reg_tmp7 = reg_tmp10;
    // 233: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[22], reg_tmp7), vec4(1.0));
    // 234: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[23], reg_tmp7), vec4(1.0));
    // 235: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[24], reg_tmp7), vec4(1.0));
    // 236: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 237: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 238: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 239: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 240: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 241: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 242: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 243: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 244: call
    {
        sub_293_310();
    }
    // 245: nop
    return false;
}
bool sub_246_281() {
    // 246: ifc
    if (all(conditional_code)) {
        sub_247_270();
    } else {
        sub_270_280();
    }
    // 280: nop
    return false;
}
bool sub_247_270() {
    // 247: dp3
    reg_tmp12.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 248: dp3
    reg_tmp12.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 249: dp3
    reg_tmp12.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 250: dp3
    reg_tmp11.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 251: dp3
    reg_tmp11.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 252: dp3
    reg_tmp11.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 253: mov
    reg_tmp7 = reg_tmp10;
    // 254: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[22], reg_tmp7), vec4(1.0));
    // 255: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[23], reg_tmp7), vec4(1.0));
    // 256: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[24], reg_tmp7), vec4(1.0));
    // 257: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 258: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 259: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 260: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 261: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 262: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 263: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 264: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 265: dp3
    reg_tmp13.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp11)), vec3(1.0));
    // 266: dp3
    reg_tmp13.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp11)), vec3(1.0));
    // 267: dp3
    reg_tmp13.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp11)), vec3(1.0));
    // 268: call
    {
        sub_310_386();
    }
    // 269: nop
    return false;
}
bool sub_270_280() {
    // 270: mov
    reg_tmp7 = reg_tmp10;
    // 271: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[22], reg_tmp7), vec4(1.0));
    // 272: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[23], reg_tmp7), vec4(1.0));
    // 273: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[24], reg_tmp7), vec4(1.0));
    // 274: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 275: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 276: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 277: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 278: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 279: mov
    vs_out_attr1 = uniforms.f[93].xxxx;
    return false;
}
bool sub_290_291() {
    // 290: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_293_310() {
    uint jmp_to = 293u;
    while (true) {
        switch (jmp_to) {
        case 293u: {
            // 293: dp3
            reg_tmp6.x = dot(vec3(mul_safe(reg_tmp14, reg_tmp14)), vec3(1.0));
            // 294: dp3
            reg_tmp7.x = dot(vec3(mul_safe(reg_tmp12, reg_tmp12)), vec3(1.0));
            // 295: rsq
            reg_tmp6.x = rsq_safe(reg_tmp6.xxxx.x);
            // 296: rsq
            reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
            // 297: mul
            reg_tmp14.xyz = (mul_safe(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 298: mul
            reg_tmp12.xyz = (mul_safe(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 299: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 300: jmpu
            if (!uniforms.b[15]) {
                { jmp_to = 309u; break; }
            }
            // 301: add
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            // 302: mul
            reg_tmp4 = mul_safe(uniforms.f[94].zzzz, reg_tmp4);
            // 303: cmp
            conditional_code = greaterThanEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp4.xxxx));
            // 304: rsq
            reg_tmp4 = vec4(rsq_safe(reg_tmp4.xxxx.x));
            // 305: mul
            reg_tmp5 = mul_safe(uniforms.f[94].zzzz, reg_tmp14);
            // 306: jmpc
            if (conditional_code.x) {
                { jmp_to = 309u; break; }
            }
            // 307: rcp
            reg_tmp0.z = rcp_safe(reg_tmp4.xxxx.x);
            // 308: mul
            reg_tmp0.xy = (mul_safe(reg_tmp5, reg_tmp4)).xy;
        }
        case 309u: {
            // 309: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_310_386() {
    uint jmp_to = 310u;
    while (true) {
        switch (jmp_to) {
        case 310u: {
            // 310: dp3
            reg_tmp6.x = dot(vec3(mul_safe(reg_tmp14, reg_tmp14)), vec3(1.0));
            // 311: dp3
            reg_tmp7.x = dot(vec3(mul_safe(reg_tmp12, reg_tmp12)), vec3(1.0));
            // 312: rsq
            reg_tmp6.x = rsq_safe(reg_tmp6.xxxx.x);
            // 313: rsq
            reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
            // 314: mul
            reg_tmp14.xyz = (mul_safe(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 315: mul
            reg_tmp12.xyz = (mul_safe(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 316: mul
            reg_tmp13.xyz = (mul_safe(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            // 317: mul
            reg_tmp11.xyz = (mul_safe(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            // 318: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 319: jmpu
            if (!uniforms.b[15]) {
                { jmp_to = 385u; break; }
            }
            // 320: mul
            reg_tmp13.xyz = (mul_safe(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            // 321: mul
            reg_tmp11.xyz = (mul_safe(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            // 322: mul
            reg_tmp5 = mul_safe(reg_tmp14.yzxx, reg_tmp13.zxyy);
            // 323: mad
            reg_tmp5 = fma_safe(-reg_tmp13.yzxx, reg_tmp14.zxyy, reg_tmp5);
            // 324: dp3
            reg_tmp5.w = dot(vec3(mul_safe(reg_tmp5, reg_tmp5)), vec3(1.0));
            // 325: rsq
            reg_tmp5.w = rsq_safe(reg_tmp5.wwww.x);
            // 326: mul
            reg_tmp5 = mul_safe(reg_tmp5, reg_tmp5.wwww);
            // 327: add
            reg_tmp6.w = (reg_tmp14.zzzz + reg_tmp5.yyyy).w;
            // 328: mul
            reg_tmp13 = mul_safe(reg_tmp5.yzxx, reg_tmp14.zxyy);
            // 329: mad
            reg_tmp13 = fma_safe(-reg_tmp14.yzxx, reg_tmp5.zxyy, reg_tmp13);
            // 330: add
            reg_tmp6.w = (reg_tmp13.xxxx + reg_tmp6).w;
            // 331: mov
            reg_tmp13.w = (reg_tmp5.zzzz).w;
            // 332: mov
            reg_tmp5.z = (reg_tmp13.xxxx).z;
            // 333: add
            reg_tmp6.w = (uniforms.f[93].yyyy + reg_tmp6).w;
            // 334: mov
            reg_tmp14.w = (reg_tmp5.xxxx).w;
            // 335: mov
            reg_tmp5.x = (reg_tmp14.zzzz).x;
            // 336: cmp
            conditional_code = lessThan(vec2(uniforms.f[94].yyyy), vec2(reg_tmp6.wwww));
            // 337: mov
            reg_tmp6.x = (uniforms.f[93].yyyy).x;
            // 338: mov
            reg_tmp6.y = (-uniforms.f[93].yyyy).y;
            // 339: jmpc
            if (!conditional_code.x) {
                { jmp_to = 347u; break; }
            }
            // 340: add
            reg_tmp7.xz = (reg_tmp13.wwyy + -reg_tmp14.yyww).xz;
            // 341: add
            reg_tmp7.y = (reg_tmp14.xxxx + -reg_tmp13.zzzz).y;
            // 342: mov
            reg_tmp7.w = (reg_tmp6).w;
            // 343: dp4
            reg_tmp6 = vec4(dot(mul_safe(reg_tmp7, reg_tmp7), vec4(1.0)));
            // 344: rsq
            reg_tmp6 = vec4(rsq_safe(reg_tmp6.xxxx.x));
            // 345: mul
            reg_tmp0 = mul_safe(reg_tmp7, reg_tmp6);
            // 346: jmpu
            if (uniforms.b[0]) {
                { jmp_to = 385u; break; }
            }
        }
        case 347u: {
            // 347: cmp
            conditional_code = greaterThan(vec2(reg_tmp5.zyyy), vec2(reg_tmp5.yxxx));
            // 348: ifc
            if (conditional_code.x) {
                sub_349_369();
            } else {
                sub_369_382();
            }
            // 382: dp4
            reg_tmp6 = vec4(dot(mul_safe(reg_tmp8, reg_tmp8), vec4(1.0)));
            // 383: rsq
            reg_tmp6 = vec4(rsq_safe(reg_tmp6.xxxx.x));
            // 384: mul
            reg_tmp0 = mul_safe(reg_tmp8, reg_tmp6);
        }
        case 385u: {
            // 385: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_349_369() {
    // 349: ifc
    if (conditional_code.y) {
        sub_350_355();
    } else {
        sub_355_368();
    }
    // 368: mov
    reg_tmp8.w = (-reg_tmp8).w;
    return false;
}
bool sub_350_355() {
    // 350: mul
    reg_tmp8 = mul_safe(reg_tmp13.yyzw, reg_tmp6.xxxy);
    // 351: add
    reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
    // 352: add
    reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
    // 353: add
    reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
    // 354: add
    reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
    return false;
}
bool sub_355_368() {
    // 355: cmp
    conditional_code = greaterThan(vec2(reg_tmp5.zzzz), vec2(reg_tmp5.xxxx));
    // 356: mul
    reg_tmp8 = mul_safe(reg_tmp13.yyzw, reg_tmp6.xxxy);
    // 357: add
    reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
    // 358: ifc
    if (conditional_code.x) {
        sub_359_362();
    } else {
        sub_362_367();
    }
    // 367: nop
    return false;
}
bool sub_359_362() {
    // 359: add
    reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
    // 360: add
    reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
    // 361: add
    reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
    return false;
}
bool sub_362_367() {
    // 362: mul
    reg_tmp8 = mul_safe(reg_tmp13.zwwy, reg_tmp6.xxxy);
    // 363: add
    reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
    // 364: add
    reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
    // 365: add
    reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
    // 366: add
    reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
    return false;
}
bool sub_369_382() {
    // 369: ifc
    if (conditional_code.y) {
        sub_370_375();
    } else {
        sub_375_381();
    }
    // 381: nop
    return false;
}
bool sub_370_375() {
    // 370: mul
    reg_tmp8 = mul_safe(reg_tmp13.yywz, reg_tmp6.xxxy);
    // 371: add
    reg_tmp8.y = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).y;
    // 372: add
    reg_tmp9 = reg_tmp5.yyyy + -reg_tmp5.xxxx;
    // 373: add
    reg_tmp8.xzw = (reg_tmp8 + reg_tmp14.wwyx).xzw;
    // 374: add
    reg_tmp8.y = (reg_tmp9 + reg_tmp8).y;
    return false;
}
bool sub_375_381() {
    // 375: mul
    reg_tmp8 = mul_safe(reg_tmp13.zwwy, reg_tmp6.xxxy);
    // 376: add
    reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
    // 377: add
    reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
    // 378: add
    reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
    // 379: add
    reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
    // 380: mov
    reg_tmp8.w = (-reg_tmp8).w;
    return false;
}
// reference: C36AFE7DB92C4CC6, B582B9861A22E219
// shader: 8B30, 18CD6F34EF819318

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(light_vector, normal)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((secondary_fragment_color.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((primary_fragment_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_4 = byteround(clamp((vec3(1.0) - textureProj(tex0, vec3(texcoord0, texcoord0_w)).rgb) * (const_color[4].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((combiner_buffer.rgb) * (vec3(1.0) - last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D290B1ECDA334771, 18CD6F34EF819318
// program: B582B9861A22E219, 3B3AE026C742C7D5, 18CD6F34EF819318
// reference: C36AFE7D5615DF87, B582B9861A22E219
// reference: 974AD4F708578713, BAF5CB3693892DB3
// shader: 8B30, B29EF1BFC4D10886

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: C40776ED598C7306, B29EF1BFC4D10886
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, B29EF1BFC4D10886
// shader: 8B30, 85967F14F07719A7

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(light_vector, normal)));
refl_value.g = (lut_scale_rg * LookupLightingLUTSigned(5, dot(light_vector, normal)));
refl_value.b = (lut_scale_rb * LookupLightingLUTSigned(4, dot(light_vector, normal)));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((secondary_fragment_color.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((primary_fragment_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_4 = byteround(clamp((vec3(1.0) - textureProj(tex0, vec3(texcoord0, texcoord0_w)).rgb) * (const_color[4].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((combiner_buffer.rgb) * (vec3(1.0) - last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 63CE8E81CD3204B2, 85967F14F07719A7
// program: B582B9861A22E219, 3B3AE026C742C7D5, 85967F14F07719A7
// shader: 8B30, 98677AC22B9A3E1A

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor1.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor1.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_4 = byteround(clamp((vec3(1.0) - textureProj(tex0, vec3(texcoord0, texcoord0_w)).rgb) * (const_color[4].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((combiner_buffer.rgb) * (vec3(1.0) - last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D90FB1F72370825D, 98677AC22B9A3E1A
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, 98677AC22B9A3E1A
// reference: 380E46B0C9D13B31, 3DBC6131A77F0199
// reference: 3A31C41C74FC82FA, C74CA00DB8E95117
// reference: 974AD4F7E76E1452, BAF5CB3693892DB3
// shader: 8B31, 7BB64A39FB1F4E77

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;
 out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define mul_safe(x, y) mix(x * y, vec4(0.0), isnan(x * y))

float rcp_safe(float x) {
    if (x == 0.0f) return x;
    return 1.0f / x;
}


float rsq_safe(float x) {
    if (x == 0.0f) return x;
    return inversesqrt(x);
}

#define fma_safe(x, y, z) (mul_safe(x, y) + z)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_4096();
bool sub_34_73();
bool sub_73_90();
bool sub_166_183();
bool sub_172_177();
bool sub_174_175();
bool sub_181_182();
bool sub_183_229();
bool sub_187_228();
bool sub_192_194();
bool sub_194_218();
bool sub_197_202();
bool sub_208_217();
bool sub_212_213();
bool sub_213_216();
bool sub_220_227();
bool sub_229_239();
bool sub_236_237();
bool sub_239_266();
bool sub_241_246();
bool sub_246_265();
bool sub_249_255();
bool sub_255_264();
bool sub_256_260();
bool sub_260_263();
bool sub_266_274();
bool sub_268_269();
bool sub_269_273();
bool sub_270_271();
bool sub_271_272();
bool sub_274_281();
bool sub_281_285();
bool sub_285_309();
bool sub_287_291();
bool sub_291_308();
bool sub_292_306();
bool sub_295_302();
bool sub_302_305();
bool sub_306_307();
bool sub_309_325();
bool sub_311_315();
bool sub_315_324();
bool sub_316_322();
bool sub_322_323();

bool exec_shader() {
    sub_0_4096();
    return true;
}

bool sub_0_4096() {
    // 0: call
    {
        sub_34_73();
    }
    // 1: call
    {
        sub_166_183();
    }
    // 2: call
    {
        sub_239_266();
    }
    // 3: call
    {
        sub_285_309();
    }
    // 4: call
    {
        sub_309_325();
    }
    // 5: end
    return true;
}
bool sub_34_73() {
    // 34: mul
    reg_tmp15.xyz = (mul_safe(uniforms.f[7].xxxx, vs_in_reg0)).xyz;
    // 35: mul
    reg_tmp14.xyz = (mul_safe(uniforms.f[7].yyyy, vs_in_reg1)).xyz;
    // 36: mul
    reg_tmp13.xyz = (mul_safe(uniforms.f[7].zzzz, vs_in_reg2)).xyz;
    // 37: add
    reg_tmp15.xyz = (uniforms.f[6] + reg_tmp15).xyz;
    // 38: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 39: mov
    reg_tmp0 = uniforms.f[7];
    // 40: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[25], reg_tmp15), vec4(1.0));
    // 41: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[26], reg_tmp15), vec4(1.0));
    // 42: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[27], reg_tmp15), vec4(1.0));
    // 43: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 44: dp3
    reg_tmp12.x = dot(vec3(mul_safe(uniforms.f[25], reg_tmp14)), vec3(1.0));
    // 45: dp3
    reg_tmp12.y = dot(vec3(mul_safe(uniforms.f[26], reg_tmp14)), vec3(1.0));
    // 46: dp3
    reg_tmp12.z = dot(vec3(mul_safe(uniforms.f[27], reg_tmp14)), vec3(1.0));
    // 47: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 48: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 49: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 50: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 51: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 52: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 53: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 54: call
    {
        sub_73_90();
    }
    // 55: nop
    // 56: mov
    vs_out_attr2 = -reg_tmp15;
    // 57: mov
    reg_tmp0.x = (uniforms.f[93].yyyy).x;
    // 58: mova
    address_registers.x = (ivec2(vs_in_reg3.xxxx)).x;
    // 59: mul
    reg_tmp0.x = (mul_safe(uniforms.f[28 + address_registers.x].xxxx, reg_tmp0.xxxx)).x;
    // 60: mova
    address_registers.x = (ivec2(vs_in_reg3.yyyy)).x;
    // 61: mul
    reg_tmp0.x = (mul_safe(uniforms.f[28 + address_registers.x].yyyy, reg_tmp0.xxxx)).x;
    // 62: nop
    // 63: mova
    address_registers.x = (ivec2(vs_in_reg3.zzzz)).x;
    // 64: mul
    reg_tmp0.x = (mul_safe(uniforms.f[28 + address_registers.x].zzzz, reg_tmp0.xxxx)).x;
    // 65: mova
    address_registers.x = (ivec2(vs_in_reg3.wwww)).x;
    // 66: mul
    reg_tmp0.x = (mul_safe(uniforms.f[28 + address_registers.x].wwww, reg_tmp0.xxxx)).x;
    // 67: mul
    reg_tmp15.xyz = (mul_safe(reg_tmp15.xyzz, reg_tmp0.xxxx)).xyz;
    // 68: dp4
    vs_out_attr0.x = dot(mul_safe(uniforms.f[86], reg_tmp15), vec4(1.0));
    // 69: dp4
    vs_out_attr0.y = dot(mul_safe(uniforms.f[87], reg_tmp15), vec4(1.0));
    // 70: dp4
    vs_out_attr0.z = dot(mul_safe(uniforms.f[88], reg_tmp15), vec4(1.0));
    // 71: dp4
    vs_out_attr0.w = dot(mul_safe(uniforms.f[89], reg_tmp15), vec4(1.0));
    // 72: nop
    return false;
}
bool sub_73_90() {
    uint jmp_to = 73u;
    while (true) {
        switch (jmp_to) {
        case 73u: {
            // 73: dp3
            reg_tmp6.x = dot(vec3(mul_safe(reg_tmp14, reg_tmp14)), vec3(1.0));
            // 74: dp3
            reg_tmp7.x = dot(vec3(mul_safe(reg_tmp12, reg_tmp12)), vec3(1.0));
            // 75: rsq
            reg_tmp6.x = rsq_safe(reg_tmp6.xxxx.x);
            // 76: rsq
            reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
            // 77: mul
            reg_tmp14.xyz = (mul_safe(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 78: mul
            reg_tmp12.xyz = (mul_safe(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 79: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 80: jmpu
            if (!uniforms.b[15]) {
                { jmp_to = 89u; break; }
            }
            // 81: add
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            // 82: mul
            reg_tmp4 = mul_safe(uniforms.f[94].zzzz, reg_tmp4);
            // 83: cmp
            conditional_code = greaterThanEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp4.xxxx));
            // 84: rsq
            reg_tmp4 = vec4(rsq_safe(reg_tmp4.xxxx.x));
            // 85: mul
            reg_tmp5 = mul_safe(uniforms.f[94].zzzz, reg_tmp14);
            // 86: jmpc
            if (conditional_code.x) {
                { jmp_to = 89u; break; }
            }
            // 87: rcp
            reg_tmp0.z = rcp_safe(reg_tmp4.xxxx.x);
            // 88: mul
            reg_tmp0.xy = (mul_safe(reg_tmp5, reg_tmp4)).xy;
        }
        case 89u: {
            // 89: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_166_183() {
    // 166: mov
    reg_tmp8.xy = (uniforms.f[93].xxxx).xy;
    // 167: mov
    reg_tmp0.y = (uniforms.f[7].wwww).y;
    // 168: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.xyyy));
    // 169: mov
    reg_tmp9.xyz = (uniforms.f[93].xxxx).xyz;
    // 170: mov
    reg_tmp9.w = (uniforms.f[21].wwww).w;
    // 171: ifc
    if (conditional_code.y) {
        sub_172_177();
    }
    // 177: callu
    if (uniforms.b[12]) {
        sub_183_229();
    }
    // 178: callu
    if (uniforms.b[5]) {
        sub_229_239();
    }
    // 179: cmp
    conditional_code = equal(vec2(uniforms.f[93].xxxx), vec2(reg_tmp8.xyyy));
    // 180: ifc
    if (all(conditional_code)) {
        sub_181_182();
    }
    // 182: max
    vs_out_attr3 = max(uniforms.f[93].xxxx, reg_tmp9);
    return false;
}
bool sub_172_177() {
    // 172: mul
    reg_tmp0 = mul_safe(uniforms.f[7].wwww, vs_in_reg3);
    // 173: ifu
    if (uniforms.b[7]) {
        sub_174_175();
    }
    // 175: mul
    reg_tmp9.xyz = (mul_safe(uniforms.f[20].wwww, reg_tmp0.xyzz)).xyz;
    // 176: mov
    reg_tmp8.x = (uniforms.f[93].yyyy).x;
    return false;
}
bool sub_174_175() {
    // 174: mul
    reg_tmp9.w = (mul_safe(reg_tmp9.wwww, reg_tmp0.wwww)).w;
    return false;
}
bool sub_181_182() {
    // 181: mov
    reg_tmp9 = uniforms.f[21];
    return false;
}
bool sub_183_229() {
    // 183: mov
    reg_tmp1 = uniforms.f[20];
    // 184: mov
    reg_tmp2 = uniforms.f[21];
    // 185: mov
    reg_tmp3 = uniforms.f[93].xxxx;
    // 186: loop
    address_registers.z = int(uniforms.i[0].y);
    for (uint loop186 = 0u; loop186 <= uniforms.i[0].x; address_registers.z += int(uniforms.i[0].z), ++loop186) {
        sub_187_228();
    }
    // 228: mov
    reg_tmp8.x = (uniforms.f[93].yyyy).x;
    return false;
}
bool sub_187_228() {
    // 187: mova
    address_registers.x = (ivec2(reg_tmp3)).x;
    // 188: mov
    reg_tmp4.x = (uniforms.f[49 + address_registers.x].wwww).x;
    // 189: mov
    reg_tmp4.y = (uniforms.f[51 + address_registers.x].wwww).y;
    // 190: cmp
    conditional_code = equal(vec2(uniforms.f[93].xyyy), vec2(reg_tmp4.xyyy));
    // 191: ifc
    if (conditional_code.x) {
        sub_192_194();
    } else {
        sub_194_218();
    }
    // 218: cmp
    conditional_code.x = uniforms.f[93].xxxx.x == reg_tmp6.xyyy.x;
    conditional_code.y = uniforms.f[93].xxxx.y < reg_tmp6.xyyy.y;
    // 219: ifc
    if (conditional_code.y) {
        sub_220_227();
    }
    // 227: add
    reg_tmp3 = -uniforms.f[95].wwww + reg_tmp3;
    return false;
}
bool sub_192_194() {
    // 192: dp3
    reg_tmp6.x = dot(vec3(mul_safe(uniforms.f[49 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 193: mov
    reg_tmp6.y = (uniforms.f[93].yyyy).y;
    return false;
}
bool sub_194_218() {
    // 194: add
    reg_tmp4 = uniforms.f[49 + address_registers.x] + -reg_tmp15;
    // 195: mov
    reg_tmp6.y = (uniforms.f[93].yyyy).y;
    // 196: ifc
    if (conditional_code.y) {
        sub_197_202();
    }
    // 202: mov
    reg_tmp5 = uniforms.f[50 + address_registers.x];
    // 203: cmp
    conditional_code = equal(vec2(uniforms.f[93].yyyy), vec2(reg_tmp5.wwww));
    // 204: dp3
    reg_tmp4.w = dot(vec3(mul_safe(reg_tmp4, reg_tmp4)), vec3(1.0));
    // 205: rsq
    reg_tmp4.w = rsq_safe(reg_tmp4.wwww.x);
    // 206: mul
    reg_tmp4 = mul_safe(reg_tmp4, reg_tmp4.wwww);
    // 207: ifc
    if (conditional_code.x) {
        sub_208_217();
    }
    // 217: dp3
    reg_tmp6.x = dot(vec3(mul_safe(reg_tmp14, reg_tmp4)), vec3(1.0));
    return false;
}
bool sub_197_202() {
    // 197: mov
    reg_tmp5.x = (uniforms.f[93].yyyy).x;
    // 198: dp3
    reg_tmp5.z = dot(vec3(mul_safe(reg_tmp4, reg_tmp4)), vec3(1.0));
    // 199: mul
    reg_tmp5.y = (mul_safe(reg_tmp5.zzzz, reg_tmp5.zzzz)).y;
    // 200: dp3
    reg_tmp6.y = dot(vec3(mul_safe(uniforms.f[51 + address_registers.x], reg_tmp5)), vec3(1.0));
    // 201: rcp
    reg_tmp6.y = rcp_safe(reg_tmp6.yyyy.x);
    return false;
}
bool sub_208_217() {
    // 208: dp3
    reg_tmp5.x = dot(vec3(mul_safe(uniforms.f[50 + address_registers.x], -reg_tmp4)), vec3(1.0));
    // 209: slti
    reg_tmp5.y = (vec4(lessThan(reg_tmp5.xxxx,uniforms.f[52 + address_registers.x].yyyy))).y;
    // 210: cmp
    conditional_code = equal(vec2(uniforms.f[93].yyyy), vec2(reg_tmp5.xyyy));
    // 211: ifc
    if (conditional_code.y) {
        sub_212_213();
    } else {
        sub_213_216();
    }
    // 216: mul
    reg_tmp6.y = (mul_safe(reg_tmp6.yyyy, reg_tmp5.xxxx)).y;
    return false;
}
bool sub_212_213() {
    // 212: mov
    reg_tmp5.x = (uniforms.f[93].xxxx).x;
    return false;
}
bool sub_213_216() {
    // 213: log
    reg_tmp5.y = log2(reg_tmp5.xxxx.x);
    // 214: mul
    reg_tmp5.y = (mul_safe(uniforms.f[52 + address_registers.x].xxxx, reg_tmp5.yyyy)).y;
    // 215: exp
    reg_tmp5.x = exp2(reg_tmp5.yyyy.x);
    return false;
}
bool sub_220_227() {
    // 220: max
    reg_tmp6.x = (max(uniforms.f[93].xxxx, reg_tmp6.xxxx)).x;
    // 221: mad
    reg_tmp9.xyz = (fma_safe(reg_tmp1.xyzz, uniforms.f[47 + address_registers.x].xyzz, reg_tmp9.xyzz)).xyz;
    // 222: mul
    reg_tmp4 = mul_safe(uniforms.f[48 + address_registers.x], reg_tmp2);
    // 223: mul
    reg_tmp5.xyz = (mul_safe(reg_tmp6.xxxx, reg_tmp4.xyzz)).xyz;
    // 224: mul
    reg_tmp5.xyz = (mul_safe(reg_tmp6.yyyy, reg_tmp5.xyzz)).xyz;
    // 225: add
    reg_tmp9.xyz = (reg_tmp9.xyzz + reg_tmp5.xyzz).xyz;
    // 226: add
    reg_tmp9.w = (reg_tmp9.wwww + reg_tmp4.wwww).w;
    return false;
}
bool sub_229_239() {
    // 229: dp3
    reg_tmp1 = vec4(dot(vec3(mul_safe(uniforms.f[24], reg_tmp14)), vec3(1.0)));
    // 230: mov
    reg_tmp2 = uniforms.f[24].wwww;
    // 231: mad
    reg_tmp1 = fma_safe(reg_tmp1, reg_tmp2, reg_tmp2);
    // 232: mov
    reg_tmp3 = uniforms.f[22];
    // 233: add
    reg_tmp2 = uniforms.f[23] + -reg_tmp3;
    // 234: mad
    reg_tmp4 = fma_safe(reg_tmp2, reg_tmp1, reg_tmp3);
    // 235: ifu
    if (uniforms.b[6]) {
        sub_236_237();
    }
    // 237: mad
    reg_tmp9.xyz = (fma_safe(reg_tmp4, uniforms.f[21], reg_tmp9)).xyz;
    // 238: mov
    reg_tmp8.x = (uniforms.f[93].yyyy).x;
    return false;
}
bool sub_236_237() {
    // 236: mul
    reg_tmp4 = mul_safe(reg_tmp4, reg_tmp9.wwww);
    return false;
}
bool sub_239_266() {
    // 239: mov
    reg_tmp0.xy = (uniforms.f[10].xxxx).xy;
    // 240: ifu
    if (uniforms.b[9]) {
        sub_241_246();
    } else {
        sub_246_265();
    }
    // 265: nop
    return false;
}
bool sub_241_246() {
    // 241: call
    {
        sub_266_274();
    }
    // 242: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[11].xywz, reg_tmp6), vec4(1.0));
    // 243: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[12].xywz, reg_tmp6), vec4(1.0));
    // 244: mov
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    // 245: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_246_265() {
    // 246: cmp
    conditional_code = equal(vec2(uniforms.f[95].xyyy), vec2(reg_tmp0.xyyy));
    // 247: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 248: ifc
    if (all(not(conditional_code))) {
        sub_249_255();
    } else {
        sub_255_264();
    }
    // 264: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_249_255() {
    // 249: mov
    reg_tmp6 = reg_tmp10;
    // 250: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[11], reg_tmp6), vec4(1.0));
    // 251: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[12], reg_tmp6), vec4(1.0));
    // 252: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[13], reg_tmp6), vec4(1.0));
    // 253: mul
    reg_tmp0.xy = (mul_safe(uniforms.f[19].xyyy, reg_tmp3.zzzz)).xy;
    // 254: add
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_255_264() {
    // 255: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_256_260();
    } else {
        sub_260_263();
    }
    // 263: nop
    return false;
}
bool sub_256_260() {
    // 256: call
    {
        sub_274_281();
    }
    // 257: dp3
    reg_tmp3.x = dot(vec3(mul_safe(uniforms.f[11], reg_tmp6)), vec3(1.0));
    // 258: dp3
    reg_tmp3.y = dot(vec3(mul_safe(uniforms.f[12], reg_tmp6)), vec3(1.0));
    // 259: dp3
    reg_tmp3.z = dot(vec3(mul_safe(uniforms.f[13], reg_tmp6)), vec3(1.0));
    return false;
}
bool sub_260_263() {
    // 260: call
    {
        sub_281_285();
    }
    // 261: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[11], reg_tmp6), vec4(1.0));
    // 262: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[12], reg_tmp6), vec4(1.0));
    return false;
}
bool sub_266_274() {
    // 266: cmp
    conditional_code = equal(vec2(uniforms.f[93].yzzz), vec2(reg_tmp0.xyyy));
    // 267: ifc
    if (all(not(conditional_code))) {
        sub_268_269();
    } else {
        sub_269_273();
    }
    // 273: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_268_269() {
    // 268: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
    return false;
}
bool sub_269_273() {
    // 269: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_270_271();
    } else {
        sub_271_272();
    }
    // 272: nop
    return false;
}
bool sub_270_271() {
    // 270: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
    return false;
}
bool sub_271_272() {
    // 271: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
    return false;
}
bool sub_274_281() {
    // 274: mov
    reg_tmp2 = -reg_tmp15;
    // 275: dp3
    reg_tmp2.w = dot(vec3(mul_safe(reg_tmp2, reg_tmp2)), vec3(1.0));
    // 276: rsq
    reg_tmp2.w = rsq_safe(reg_tmp2.wwww.x);
    // 277: mul
    reg_tmp2 = mul_safe(reg_tmp2, reg_tmp2.wwww);
    // 278: dp3
    reg_tmp1 = vec4(dot(vec3(mul_safe(reg_tmp2, reg_tmp14)), vec3(1.0)));
    // 279: add
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    // 280: mad
    reg_tmp6 = fma_safe(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_281_285() {
    // 281: mov
    reg_tmp1.xy = (uniforms.f[94].zzzz).xy;
    // 282: mov
    reg_tmp1.zw = (uniforms.f[93].xxxx).zw;
    // 283: mad
    reg_tmp6 = fma_safe(reg_tmp14, reg_tmp1, reg_tmp1);
    // 284: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_285_309() {
    // 285: mov
    reg_tmp0.xy = (uniforms.f[10].yyyy).xy;
    // 286: ifu
    if (uniforms.b[10]) {
        sub_287_291();
    } else {
        sub_291_308();
    }
    // 308: nop
    return false;
}
bool sub_287_291() {
    // 287: call
    {
        sub_266_274();
    }
    // 288: dp4
    reg_tmp4.x = dot(mul_safe(uniforms.f[14].xywz, reg_tmp6), vec4(1.0));
    // 289: dp4
    reg_tmp4.y = dot(mul_safe(uniforms.f[15].xywz, reg_tmp6), vec4(1.0));
    // 290: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_291_308() {
    // 291: ifu
    if (uniforms.b[13]) {
        sub_292_306();
    } else {
        sub_306_307();
    }
    // 307: nop
    return false;
}
bool sub_292_306() {
    // 292: cmp
    conditional_code = equal(vec2(uniforms.f[95].xyyy), vec2(reg_tmp0.xyyy));
    // 293: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 294: ifc
    if (all(not(conditional_code))) {
        sub_295_302();
    } else {
        sub_302_305();
    }
    // 305: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_295_302() {
    // 295: mov
    reg_tmp6 = reg_tmp10;
    // 296: dp4
    reg_tmp4.x = dot(mul_safe(uniforms.f[14], reg_tmp6), vec4(1.0));
    // 297: dp4
    reg_tmp4.y = dot(mul_safe(uniforms.f[15], reg_tmp6), vec4(1.0));
    // 298: dp4
    reg_tmp4.z = dot(mul_safe(uniforms.f[16], reg_tmp6), vec4(1.0));
    // 299: rcp
    reg_tmp6.w = rcp_safe(reg_tmp4.zzzz.x);
    // 300: mul
    reg_tmp4.xy = (mul_safe(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    // 301: add
    reg_tmp4.xy = (uniforms.f[19].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_302_305() {
    // 302: call
    {
        sub_281_285();
    }
    // 303: dp4
    reg_tmp4.x = dot(mul_safe(uniforms.f[14], reg_tmp6), vec4(1.0));
    // 304: dp4
    reg_tmp4.y = dot(mul_safe(uniforms.f[15], reg_tmp6), vec4(1.0));
    return false;
}
bool sub_306_307() {
    // 306: mov
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_309_325() {
    // 309: mov
    reg_tmp0.xy = (uniforms.f[10].zzzz).xy;
    // 310: ifu
    if (uniforms.b[11]) {
        sub_311_315();
    } else {
        sub_315_324();
    }
    // 324: nop
    return false;
}
bool sub_311_315() {
    // 311: call
    {
        sub_266_274();
    }
    // 312: dp4
    reg_tmp5.x = dot(mul_safe(uniforms.f[17].xywz, reg_tmp6), vec4(1.0));
    // 313: dp4
    reg_tmp5.y = dot(mul_safe(uniforms.f[18].xywz, reg_tmp6), vec4(1.0));
    // 314: mov
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_315_324() {
    // 315: ifu
    if (uniforms.b[14]) {
        sub_316_322();
    } else {
        sub_322_323();
    }
    // 323: nop
    return false;
}
bool sub_316_322() {
    // 316: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 317: mov
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    // 318: call
    {
        sub_281_285();
    }
    // 319: dp4
    reg_tmp5.x = dot(mul_safe(uniforms.f[17], reg_tmp6), vec4(1.0));
    // 320: dp4
    reg_tmp5.y = dot(mul_safe(uniforms.f[18], reg_tmp6), vec4(1.0));
    // 321: mov
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_322_323() {
    // 322: mov
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
// reference: 59593DFA4B783905, 7BB64A39FB1F4E77
// shader: 8B30, 8C2ECA480D7B7AB5

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += ((light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[2].position + view);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * LookupLightingLUTUnsigned(18,clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[2].specular_0) + (light_src[2].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(18,clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[3].position + view);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * LookupLightingLUTUnsigned(19,clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[3].specular_0) + (light_src[3].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(19,clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((secondary_fragment_color.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (last_tex_env_out.aaa), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((combiner_buffer.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 481A2F7F75B058A1, 8C2ECA480D7B7AB5
// program: 7BB64A39FB1F4E77, AD7922A63ED54CA7, 8C2ECA480D7B7AB5
// reference: 15ACF31C5615DF87, B582B9861A22E219
// reference: 418CD99608578713, BAF5CB3693892DB3
// shader: 8B30, 06A8A4F9432C9B26

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += ((light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[2].position + view);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * LookupLightingLUTUnsigned(18,clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[2].specular_0) + (light_src[2].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(18,clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[3].position + view);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * LookupLightingLUTUnsigned(19,clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[3].specular_0) + (light_src[3].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(19,clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 893250922C03C0B1, 06A8A4F9432C9B26
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, 06A8A4F9432C9B26
// reference: EEC84BD1C9D13B31, 3DBC6131A77F0199
// shader: 8B30, E2B05A5EEE3BCE11

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += ((light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[2].position + view);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * LookupLightingLUTUnsigned(18,clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[2].specular_0) + (light_src[2].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(18,clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[3].position + view);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * LookupLightingLUTUnsigned(19,clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[3].specular_0) + (light_src[3].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(19,clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor1.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor1.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor2.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) + (secondary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (const_color[2].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (last_tex_env_out.aaa) + (combiner_buffer.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((texcolor1.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_4 = byteround(clamp((vec3(1.0) - textureProj(tex0, vec3(texcoord0, texcoord0_w)).rgb) * (const_color[4].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((combiner_buffer.rgb) * (vec3(1.0) - last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 00D052785EEEAB33, E2B05A5EEE3BCE11
// program: 3DBC6131A77F0199, AD7922A63ED54CA7, E2B05A5EEE3BCE11
// reference: EEC84BD126E8A870, 3DBC6131A77F0199
// reference: 418CD996E76E1452, BAF5CB3693892DB3
// shader: 8B30, 6508155727F8E389

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += ((light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[2].position + view);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * LookupLightingLUTUnsigned(18,clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[2].specular_0) + (light_src[2].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(18,clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[3].position + view);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * LookupLightingLUTUnsigned(19,clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[3].specular_0) + (light_src[3].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(19,clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor1.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor1.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_4 = byteround(clamp((vec3(1.0) - textureProj(tex0, vec3(texcoord0, texcoord0_w)).rgb) * (const_color[4].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((combiner_buffer.rgb) * (vec3(1.0) - last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 70284790F2EDAD59, 6508155727F8E389
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, 6508155727F8E389
// shader: 8B30, 23F262D2CA8E6488

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += ((light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[2].position + view);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * LookupLightingLUTUnsigned(18,clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[2].specular_0) + (light_src[2].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(18,clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[3].position + view);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
specular_sum.a = (lut_scale_fr * LookupLightingLUTSigned(3, dot(normal, normalize(view))));
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * LookupLightingLUTUnsigned(19,clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[3].specular_0) + (light_src[3].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(19,clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((vec3(1.0) - secondary_fragment_color.aaa) * (texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor1.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((secondary_fragment_color.aaa) * (texcolor2.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((texcolor1.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_4 = byteround(clamp((vec3(1.0) - textureProj(tex0, vec3(texcoord0, texcoord0_w)).rgb) * (const_color[4].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((combiner_buffer.rgb) * (vec3(1.0) - last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 3F4D457F5FC9F7B0, 23F262D2CA8E6488
// program: 3DBC6131A77F0199, AD7922A63ED54CA7, 23F262D2CA8E6488
// shader: 8B30, 7FF280648EA22926

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += ((light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[2].position + view);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * LookupLightingLUTUnsigned(18,clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[2].specular_0) + (light_src[2].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(18,clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[3].position + view);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * LookupLightingLUTUnsigned(19,clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[3].specular_0) + (light_src[3].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(19,clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 89325092C0B42BB2, 7FF280648EA22926
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, 7FF280648EA22926
// shader: 8B30, 8B353D67743458EE

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += ((light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[2].position + view);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * LookupLightingLUTUnsigned(18,clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[2].specular_0) + (light_src[2].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(18,clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[3].position + view);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * LookupLightingLUTUnsigned(19,clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[3].specular_0) + (light_src[3].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(19,clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor1.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor1.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_4 = byteround(clamp((vec3(1.0) - textureProj(tex0, vec3(texcoord0, texcoord0_w)).rgb) * (const_color[4].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((combiner_buffer.rgb) * (vec3(1.0) - last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 943A9788BA48DAE9, 8B353D67743458EE
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, 8B353D67743458EE
// shader: 8B30, 82B30867377518C0

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: F72DB75B598C7306, 82B30867377518C0
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, 82B30867377518C0
// shader: 8B30, 48869468E89D649B

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += ((light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[2].position + view);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * LookupLightingLUTUnsigned(18,clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[2].specular_0) + (light_src[2].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(18,clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[3].position + view);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * LookupLightingLUTUnsigned(19,clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[3].specular_0) + (light_src[3].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(19,clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor1.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_4 = byteround(clamp((vec3(1.0) - textureProj(tex0, vec3(texcoord0, texcoord0_w)).rgb) * (const_color[4].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((combiner_buffer.rgb) * (vec3(1.0) - last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 7028479027403241, 48869468E89D649B
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, 48869468E89D649B
// shader: 8B30, 2F84956AB5DBE86B

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += ((light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[2].position + view);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * LookupLightingLUTUnsigned(18,clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[2].specular_0) + (light_src[2].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(18,clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[3].position + view);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * LookupLightingLUTUnsigned(19,clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[3].specular_0) + (light_src[3].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(19,clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.aaa) * (texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor1.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.aaa), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_4 = byteround(clamp((vec3(1.0) - textureProj(tex0, vec3(texcoord0, texcoord0_w)).rgb) * (const_color[4].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((combiner_buffer.rgb) * (vec3(1.0) - last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: A2BAD562BC24034E, 2F84956AB5DBE86B
// program: 3DBC6131A77F0199, AD7922A63ED54CA7, 2F84956AB5DBE86B
// shader: 8B30, 45B9B5821FF15384

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += ((light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[2].position + view);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * LookupLightingLUTUnsigned(18,clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[2].specular_0) + (light_src[2].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(18,clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[3].position + view);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * LookupLightingLUTUnsigned(19,clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[3].specular_0) + (light_src[3].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(19,clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor2.rgb) * (texcolor2.aaa), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor1.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (secondary_fragment_color.aaa), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_4 = byteround(clamp((vec3(1.0) - textureProj(tex0, vec3(texcoord0, texcoord0_w)).rgb) * (const_color[4].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((combiner_buffer.rgb) * (vec3(1.0) - last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: FFF7BA5372492619, 45B9B5821FF15384
// program: 3DBC6131A77F0199, AD7922A63ED54CA7, 45B9B5821FF15384
// shader: 8B30, 39C07F205AF70F59

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += ((light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[2].position + view);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * LookupLightingLUTUnsigned(18,clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[2].specular_0) + (light_src[2].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(18,clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[3].position + view);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
specular_sum.a = (lut_scale_fr * LookupLightingLUTSigned(3, dot(normal, normalize(view))));
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * LookupLightingLUTUnsigned(19,clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[3].specular_0) + (light_src[3].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(19,clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((vec3(1.0) - secondary_fragment_color.aaa) * (texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor1.a) * (1.0 - secondary_fragment_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor2.a) * (secondary_fragment_color.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((secondary_fragment_color.aaa) * (texcolor2.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_4 = byteround(clamp((vec3(1.0) - textureProj(tex0, vec3(texcoord0, texcoord0_w)).rgb) * (const_color[4].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((combiner_buffer.rgb) * (vec3(1.0) - last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 3C4DE45023948EEF, 39C07F205AF70F59
// program: 3DBC6131A77F0199, AD7922A63ED54CA7, 39C07F205AF70F59
// shader: 8B30, 2F3A3851E4476855

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb) * (vec3(1.0) - const_color[0].aaa) + (const_color[0].rgb) * (vec3(1.0) - (vec3(1.0) - const_color[0].aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (texcolor1.b) + (1.0 - texcolor1.b) * (1.0 - (texcolor1.b)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (const_color[1].r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D5E7AAC841A86FE2, 2F3A3851E4476855
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, 2F3A3851E4476855
// shader: 8B30, 9DB6533B8FE11441

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb) * (vec3(1.0) - const_color[0].aaa) + (const_color[0].rgb) * (vec3(1.0) - (vec3(1.0) - const_color[0].aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (texcolor1.b) + (1.0 - texcolor1.b) * (1.0 - (texcolor1.b)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (const_color[1].r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 86663ED941A86FE2, 9DB6533B8FE11441
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, 9DB6533B8FE11441
// shader: 8B30, 16C4B2DE63D43BF1

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb) + (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 5989E34F598C7306, 16C4B2DE63D43BF1
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, 16C4B2DE63D43BF1
// shader: 8B31, 7F132D830BF35BC2

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;
 out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define mul_safe(x, y) mix(x * y, vec4(0.0), isnan(x * y))

float rcp_safe(float x) {
    if (x == 0.0f) return x;
    return 1.0f / x;
}


float rsq_safe(float x) {
    if (x == 0.0f) return x;
    return inversesqrt(x);
}

#define fma_safe(x, y, z) (mul_safe(x, y) + z)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_4096();
bool sub_10_28();
bool sub_16_21();
bool sub_18_19();
bool sub_25_26();
bool sub_28_74();
bool sub_32_73();
bool sub_37_39();
bool sub_39_63();
bool sub_42_47();
bool sub_53_62();
bool sub_57_58();
bool sub_58_61();
bool sub_65_72();
bool sub_74_84();
bool sub_81_82();
bool sub_84_111();
bool sub_86_91();
bool sub_91_110();
bool sub_94_100();
bool sub_100_109();
bool sub_101_105();
bool sub_105_108();
bool sub_111_119();
bool sub_113_114();
bool sub_114_118();
bool sub_115_116();
bool sub_116_117();
bool sub_119_126();
bool sub_126_130();
bool sub_130_154();
bool sub_132_136();
bool sub_136_153();
bool sub_137_151();
bool sub_140_147();
bool sub_147_150();
bool sub_151_152();
bool sub_154_170();
bool sub_156_160();
bool sub_160_169();
bool sub_161_167();
bool sub_167_168();

bool exec_shader() {
    sub_0_4096();
    return true;
}

bool sub_0_4096() {
    // 0: mov
    reg_tmp0 = vs_in_reg0;
    // 1: mov
    vs_out_attr0 = reg_tmp0;
    // 2: mov
    vs_out_attr2 = reg_tmp0;
    // 3: mov
    vs_out_attr1 = reg_tmp0;
    // 4: call
    {
        sub_10_28();
    }
    // 5: call
    {
        sub_84_111();
    }
    // 6: call
    {
        sub_130_154();
    }
    // 7: call
    {
        sub_154_170();
    }
    // 8: end
    return true;
}
bool sub_10_28() {
    // 10: mov
    reg_tmp8.xy = (uniforms.f[93].xxxx).xy;
    // 11: mov
    reg_tmp0.y = (uniforms.f[7].wwww).y;
    // 12: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.xyyy));
    // 13: mov
    reg_tmp9.xyz = (uniforms.f[93].xxxx).xyz;
    // 14: mov
    reg_tmp9.w = (uniforms.f[21].wwww).w;
    // 15: ifc
    if (conditional_code.y) {
        sub_16_21();
    }
    // 21: callu
    if (uniforms.b[12]) {
        sub_28_74();
    }
    // 22: callu
    if (uniforms.b[5]) {
        sub_74_84();
    }
    // 23: cmp
    conditional_code = equal(vec2(uniforms.f[93].xxxx), vec2(reg_tmp8.xyyy));
    // 24: ifc
    if (all(conditional_code)) {
        sub_25_26();
    }
    // 26: add
    reg_tmp9 = uniforms.f[74] + reg_tmp9;
    // 27: max
    vs_out_attr3 = max(uniforms.f[93].xxxx, reg_tmp9);
    return false;
}
bool sub_16_21() {
    // 16: mul
    reg_tmp0 = mul_safe(uniforms.f[7].wwww, vs_in_reg3);
    // 17: ifu
    if (uniforms.b[7]) {
        sub_18_19();
    }
    // 19: mul
    reg_tmp9.xyz = (mul_safe(uniforms.f[20].wwww, reg_tmp0.xyzz)).xyz;
    // 20: mov
    reg_tmp8.x = (uniforms.f[93].yyyy).x;
    return false;
}
bool sub_18_19() {
    // 18: mul
    reg_tmp9.w = (mul_safe(reg_tmp9.wwww, reg_tmp0.wwww)).w;
    return false;
}
bool sub_25_26() {
    // 25: mov
    reg_tmp9 = uniforms.f[21];
    return false;
}
bool sub_28_74() {
    // 28: mov
    reg_tmp1 = uniforms.f[20];
    // 29: mov
    reg_tmp2 = uniforms.f[21];
    // 30: mov
    reg_tmp3 = uniforms.f[93].xxxx;
    // 31: loop
    address_registers.z = int(uniforms.i[0].y);
    for (uint loop31 = 0u; loop31 <= uniforms.i[0].x; address_registers.z += int(uniforms.i[0].z), ++loop31) {
        sub_32_73();
    }
    // 73: mov
    reg_tmp8.x = (uniforms.f[93].yyyy).x;
    return false;
}
bool sub_32_73() {
    // 32: mova
    address_registers.x = (ivec2(reg_tmp3)).x;
    // 33: mov
    reg_tmp4.x = (uniforms.f[69 + address_registers.x].wwww).x;
    // 34: mov
    reg_tmp4.y = (uniforms.f[71 + address_registers.x].wwww).y;
    // 35: cmp
    conditional_code = equal(vec2(uniforms.f[93].xyyy), vec2(reg_tmp4.xyyy));
    // 36: ifc
    if (conditional_code.x) {
        sub_37_39();
    } else {
        sub_39_63();
    }
    // 63: cmp
    conditional_code.x = uniforms.f[93].xxxx.x == reg_tmp6.xyyy.x;
    conditional_code.y = uniforms.f[93].xxxx.y < reg_tmp6.xyyy.y;
    // 64: ifc
    if (conditional_code.y) {
        sub_65_72();
    }
    // 72: add
    reg_tmp3 = -uniforms.f[95].wwww + reg_tmp3;
    return false;
}
bool sub_37_39() {
    // 37: dp3
    reg_tmp6.x = dot(vec3(mul_safe(uniforms.f[69 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 38: mov
    reg_tmp6.y = (uniforms.f[93].yyyy).y;
    return false;
}
bool sub_39_63() {
    // 39: add
    reg_tmp4 = uniforms.f[69 + address_registers.x] + -reg_tmp15;
    // 40: mov
    reg_tmp6.y = (uniforms.f[93].yyyy).y;
    // 41: ifc
    if (conditional_code.y) {
        sub_42_47();
    }
    // 47: mov
    reg_tmp5 = uniforms.f[70 + address_registers.x];
    // 48: cmp
    conditional_code = equal(vec2(uniforms.f[93].yyyy), vec2(reg_tmp5.wwww));
    // 49: dp3
    reg_tmp4.w = dot(vec3(mul_safe(reg_tmp4, reg_tmp4)), vec3(1.0));
    // 50: rsq
    reg_tmp4.w = rsq_safe(reg_tmp4.wwww.x);
    // 51: mul
    reg_tmp4 = mul_safe(reg_tmp4, reg_tmp4.wwww);
    // 52: ifc
    if (conditional_code.x) {
        sub_53_62();
    }
    // 62: dp3
    reg_tmp6.x = dot(vec3(mul_safe(reg_tmp14, reg_tmp4)), vec3(1.0));
    return false;
}
bool sub_42_47() {
    // 42: mov
    reg_tmp5.x = (uniforms.f[93].yyyy).x;
    // 43: dp3
    reg_tmp5.z = dot(vec3(mul_safe(reg_tmp4, reg_tmp4)), vec3(1.0));
    // 44: mul
    reg_tmp5.y = (mul_safe(reg_tmp5.zzzz, reg_tmp5.zzzz)).y;
    // 45: dp3
    reg_tmp6.y = dot(vec3(mul_safe(uniforms.f[71 + address_registers.x], reg_tmp5)), vec3(1.0));
    // 46: rcp
    reg_tmp6.y = rcp_safe(reg_tmp6.yyyy.x);
    return false;
}
bool sub_53_62() {
    // 53: dp3
    reg_tmp5.x = dot(vec3(mul_safe(uniforms.f[70 + address_registers.x], -reg_tmp4)), vec3(1.0));
    // 54: slti
    reg_tmp5.y = (vec4(lessThan(reg_tmp5.xxxx,uniforms.f[72 + address_registers.x].yyyy))).y;
    // 55: cmp
    conditional_code = equal(vec2(uniforms.f[93].yyyy), vec2(reg_tmp5.xyyy));
    // 56: ifc
    if (conditional_code.y) {
        sub_57_58();
    } else {
        sub_58_61();
    }
    // 61: mul
    reg_tmp6.y = (mul_safe(reg_tmp6.yyyy, reg_tmp5.xxxx)).y;
    return false;
}
bool sub_57_58() {
    // 57: mov
    reg_tmp5.x = (uniforms.f[93].xxxx).x;
    return false;
}
bool sub_58_61() {
    // 58: log
    reg_tmp5.y = log2(reg_tmp5.xxxx.x);
    // 59: mul
    reg_tmp5.y = (mul_safe(uniforms.f[72 + address_registers.x].xxxx, reg_tmp5.yyyy)).y;
    // 60: exp
    reg_tmp5.x = exp2(reg_tmp5.yyyy.x);
    return false;
}
bool sub_65_72() {
    // 65: max
    reg_tmp6.x = (max(uniforms.f[93].xxxx, reg_tmp6.xxxx)).x;
    // 66: mad
    reg_tmp9.xyz = (fma_safe(reg_tmp1.xyzz, uniforms.f[67 + address_registers.x].xyzz, reg_tmp9.xyzz)).xyz;
    // 67: mul
    reg_tmp4 = mul_safe(uniforms.f[68 + address_registers.x], reg_tmp2);
    // 68: mul
    reg_tmp5.xyz = (mul_safe(reg_tmp6.xxxx, reg_tmp4.xyzz)).xyz;
    // 69: mul
    reg_tmp5.xyz = (mul_safe(reg_tmp6.yyyy, reg_tmp5.xyzz)).xyz;
    // 70: add
    reg_tmp9.xyz = (reg_tmp9.xyzz + reg_tmp5.xyzz).xyz;
    // 71: add
    reg_tmp9.w = (reg_tmp9.wwww + reg_tmp4.wwww).w;
    return false;
}
bool sub_74_84() {
    // 74: dp3
    reg_tmp1 = vec4(dot(vec3(mul_safe(uniforms.f[24], reg_tmp14)), vec3(1.0)));
    // 75: mov
    reg_tmp2 = uniforms.f[24].wwww;
    // 76: mad
    reg_tmp1 = fma_safe(reg_tmp1, reg_tmp2, reg_tmp2);
    // 77: mov
    reg_tmp3 = uniforms.f[22];
    // 78: add
    reg_tmp2 = uniforms.f[23] + -reg_tmp3;
    // 79: mad
    reg_tmp4 = fma_safe(reg_tmp2, reg_tmp1, reg_tmp3);
    // 80: ifu
    if (uniforms.b[6]) {
        sub_81_82();
    }
    // 82: mad
    reg_tmp9.xyz = (fma_safe(reg_tmp4, uniforms.f[21], reg_tmp9)).xyz;
    // 83: mov
    reg_tmp8.x = (uniforms.f[93].yyyy).x;
    return false;
}
bool sub_81_82() {
    // 81: mul
    reg_tmp4 = mul_safe(reg_tmp4, reg_tmp9.wwww);
    return false;
}
bool sub_84_111() {
    // 84: mov
    reg_tmp0.xy = (uniforms.f[10].xxxx).xy;
    // 85: ifu
    if (uniforms.b[9]) {
        sub_86_91();
    } else {
        sub_91_110();
    }
    // 110: nop
    return false;
}
bool sub_86_91() {
    // 86: call
    {
        sub_111_119();
    }
    // 87: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[11].xywz, reg_tmp6), vec4(1.0));
    // 88: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[12].xywz, reg_tmp6), vec4(1.0));
    // 89: mov
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    // 90: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_91_110() {
    // 91: cmp
    conditional_code = equal(vec2(uniforms.f[95].xyyy), vec2(reg_tmp0.xyyy));
    // 92: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 93: ifc
    if (all(not(conditional_code))) {
        sub_94_100();
    } else {
        sub_100_109();
    }
    // 109: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_94_100() {
    // 94: mov
    reg_tmp6 = reg_tmp10;
    // 95: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[11], reg_tmp6), vec4(1.0));
    // 96: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[12], reg_tmp6), vec4(1.0));
    // 97: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[13], reg_tmp6), vec4(1.0));
    // 98: mul
    reg_tmp0.xy = (mul_safe(uniforms.f[19].xyyy, reg_tmp3.zzzz)).xy;
    // 99: add
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_100_109() {
    // 100: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_101_105();
    } else {
        sub_105_108();
    }
    // 108: nop
    return false;
}
bool sub_101_105() {
    // 101: call
    {
        sub_119_126();
    }
    // 102: dp3
    reg_tmp3.x = dot(vec3(mul_safe(uniforms.f[11], reg_tmp6)), vec3(1.0));
    // 103: dp3
    reg_tmp3.y = dot(vec3(mul_safe(uniforms.f[12], reg_tmp6)), vec3(1.0));
    // 104: dp3
    reg_tmp3.z = dot(vec3(mul_safe(uniforms.f[13], reg_tmp6)), vec3(1.0));
    return false;
}
bool sub_105_108() {
    // 105: call
    {
        sub_126_130();
    }
    // 106: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[11], reg_tmp6), vec4(1.0));
    // 107: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[12], reg_tmp6), vec4(1.0));
    return false;
}
bool sub_111_119() {
    // 111: cmp
    conditional_code = equal(vec2(uniforms.f[93].yzzz), vec2(reg_tmp0.xyyy));
    // 112: ifc
    if (all(not(conditional_code))) {
        sub_113_114();
    } else {
        sub_114_118();
    }
    // 118: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_113_114() {
    // 113: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
    return false;
}
bool sub_114_118() {
    // 114: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_115_116();
    } else {
        sub_116_117();
    }
    // 117: nop
    return false;
}
bool sub_115_116() {
    // 115: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
    return false;
}
bool sub_116_117() {
    // 116: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
    return false;
}
bool sub_119_126() {
    // 119: mov
    reg_tmp2 = -reg_tmp15;
    // 120: dp3
    reg_tmp2.w = dot(vec3(mul_safe(reg_tmp2, reg_tmp2)), vec3(1.0));
    // 121: rsq
    reg_tmp2.w = rsq_safe(reg_tmp2.wwww.x);
    // 122: mul
    reg_tmp2 = mul_safe(reg_tmp2, reg_tmp2.wwww);
    // 123: dp3
    reg_tmp1 = vec4(dot(vec3(mul_safe(reg_tmp2, reg_tmp14)), vec3(1.0)));
    // 124: add
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    // 125: mad
    reg_tmp6 = fma_safe(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_126_130() {
    // 126: mov
    reg_tmp1.xy = (uniforms.f[94].zzzz).xy;
    // 127: mov
    reg_tmp1.zw = (uniforms.f[93].xxxx).zw;
    // 128: mad
    reg_tmp6 = fma_safe(reg_tmp14, reg_tmp1, reg_tmp1);
    // 129: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_130_154() {
    // 130: mov
    reg_tmp0.xy = (uniforms.f[10].yyyy).xy;
    // 131: ifu
    if (uniforms.b[10]) {
        sub_132_136();
    } else {
        sub_136_153();
    }
    // 153: nop
    return false;
}
bool sub_132_136() {
    // 132: call
    {
        sub_111_119();
    }
    // 133: dp4
    reg_tmp4.x = dot(mul_safe(uniforms.f[14].xywz, reg_tmp6), vec4(1.0));
    // 134: dp4
    reg_tmp4.y = dot(mul_safe(uniforms.f[15].xywz, reg_tmp6), vec4(1.0));
    // 135: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_136_153() {
    // 136: ifu
    if (uniforms.b[13]) {
        sub_137_151();
    } else {
        sub_151_152();
    }
    // 152: nop
    return false;
}
bool sub_137_151() {
    // 137: cmp
    conditional_code = equal(vec2(uniforms.f[95].xyyy), vec2(reg_tmp0.xyyy));
    // 138: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 139: ifc
    if (all(not(conditional_code))) {
        sub_140_147();
    } else {
        sub_147_150();
    }
    // 150: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_140_147() {
    // 140: mov
    reg_tmp6 = reg_tmp10;
    // 141: dp4
    reg_tmp4.x = dot(mul_safe(uniforms.f[14], reg_tmp6), vec4(1.0));
    // 142: dp4
    reg_tmp4.y = dot(mul_safe(uniforms.f[15], reg_tmp6), vec4(1.0));
    // 143: dp4
    reg_tmp4.z = dot(mul_safe(uniforms.f[16], reg_tmp6), vec4(1.0));
    // 144: rcp
    reg_tmp6.w = rcp_safe(reg_tmp4.zzzz.x);
    // 145: mul
    reg_tmp4.xy = (mul_safe(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    // 146: add
    reg_tmp4.xy = (uniforms.f[19].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_147_150() {
    // 147: call
    {
        sub_126_130();
    }
    // 148: dp4
    reg_tmp4.x = dot(mul_safe(uniforms.f[14], reg_tmp6), vec4(1.0));
    // 149: dp4
    reg_tmp4.y = dot(mul_safe(uniforms.f[15], reg_tmp6), vec4(1.0));
    return false;
}
bool sub_151_152() {
    // 151: mov
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_154_170() {
    // 154: mov
    reg_tmp0.xy = (uniforms.f[10].zzzz).xy;
    // 155: ifu
    if (uniforms.b[11]) {
        sub_156_160();
    } else {
        sub_160_169();
    }
    // 169: nop
    return false;
}
bool sub_156_160() {
    // 156: call
    {
        sub_111_119();
    }
    // 157: dp4
    reg_tmp5.x = dot(mul_safe(uniforms.f[17].xywz, reg_tmp6), vec4(1.0));
    // 158: dp4
    reg_tmp5.y = dot(mul_safe(uniforms.f[18].xywz, reg_tmp6), vec4(1.0));
    // 159: mov
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_160_169() {
    // 160: ifu
    if (uniforms.b[14]) {
        sub_161_167();
    } else {
        sub_167_168();
    }
    // 168: nop
    return false;
}
bool sub_161_167() {
    // 161: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 162: mov
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    // 163: call
    {
        sub_126_130();
    }
    // 164: dp4
    reg_tmp5.x = dot(mul_safe(uniforms.f[17], reg_tmp6), vec4(1.0));
    // 165: dp4
    reg_tmp5.y = dot(mul_safe(uniforms.f[18], reg_tmp6), vec4(1.0));
    // 166: mov
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_167_168() {
    // 167: mov
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
// reference: 3C15408B8562FAD3, 7F132D830BF35BC2
// shader: 8B30, D375021927AD9455

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((vec3(1.0) - texcolor0.rrr) - (vec3(1.0) - texcolor1.rrr), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((1.0 - texcolor0.r) - (1.0 - texcolor2.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0 * 4.0, alpha_output_0 * 4.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) + (last_tex_env_out.aaa), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1 * 4.0, alpha_output_1 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2 * 4.0, alpha_output_2 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp(min((last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(1.0)) * (vec3(1.0) - texcolor0.rrr), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((vec3(1.0) - last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((texcolor0.rgb) + (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((1.0 - last_tex_env_out.r) - (const_color[5].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: B1A5DBDE4D845B60, D375021927AD9455
// program: 7F132D830BF35BC2, AD7922A63ED54CA7, D375021927AD9455
// reference: A54038CA5EDB5B94, 7F132D830BF35BC2
// shader: 8B30, FB2B5B4178346715

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((vec3(1.0) - texcolor0.rrr) - (vec3(1.0) - texcolor1.rrr), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((1.0 - texcolor0.r) - (1.0 - texcolor2.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0 * 4.0, alpha_output_0 * 4.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) + (last_tex_env_out.aaa), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1 * 4.0, alpha_output_1 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2 * 4.0, alpha_output_2 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp(min((last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(1.0)) * (vec3(1.0) - texcolor0.rrr), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((vec3(1.0) - last_tex_env_out.rgb) + (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((1.0 - last_tex_env_out.r) + (const_color[4].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 1EC8268EF7368957, FB2B5B4178346715
// program: 7F132D830BF35BC2, AD7922A63ED54CA7, FB2B5B4178346715
// reference: D8D9A1D7D3EE2654, BAF5CB3693892DB3
// shader: 8B30, 82DDCA85272BD2AC

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 5978E236DA580ADF, 82DDCA85272BD2AC
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, 82DDCA85272BD2AC
// shader: 8B31, 1E6C0649B5CE7F1C

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;
 out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define mul_safe(x, y) mix(x * y, vec4(0.0), isnan(x * y))

float rcp_safe(float x) {
    if (x == 0.0f) return x;
    return 1.0f / x;
}


float rsq_safe(float x) {
    if (x == 0.0f) return x;
    return inversesqrt(x);
}

#define fma_safe(x, y, z) (mul_safe(x, y) + z)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_4096();
bool sub_7_12();
bool sub_12_21();
bool sub_21_34();
bool sub_34_254();
bool sub_40_176();
bool sub_47_86();
bool sub_58_62();
bool sub_86_165();
bool sub_87_129();
bool sub_98_102();
bool sub_129_164();
bool sub_140_144();
bool sub_174_175();
bool sub_176_253();
bool sub_179_189();
bool sub_189_194();
bool sub_205_217();
bool sub_217_242();
bool sub_218_236();
bool sub_236_241();
bool sub_251_252();
bool sub_254_271();
bool sub_271_347();
bool sub_310_330();
bool sub_311_316();
bool sub_316_329();
bool sub_320_323();
bool sub_323_328();
bool sub_330_343();
bool sub_331_336();
bool sub_336_342();
bool sub_347_369();
bool sub_353_358();
bool sub_355_356();
bool sub_361_362();
bool sub_369_415();
bool sub_373_414();
bool sub_378_380();
bool sub_380_404();
bool sub_383_388();
bool sub_394_403();
bool sub_398_399();
bool sub_399_402();
bool sub_406_413();

bool exec_shader() {
    sub_0_4096();
    return true;
}

bool sub_0_4096() {
    // 0: call
    {
        sub_34_254();
    }
    // 1: call
    {
        sub_347_369();
    }
    // 2: mov
    vs_out_attr4 = uniforms.f[93].xxxx;
    // 3: mov
    vs_out_attr5 = uniforms.f[93].xxxx;
    // 4: mov
    vs_out_attr6 = uniforms.f[93].xxxx;
    // 5: end
    return true;
}
bool sub_7_12() {
    // 7: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 8: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 9: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 10: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 11: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    return false;
}
bool sub_12_21() {
    // 12: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 13: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 14: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 15: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 16: dp3
    reg_tmp4.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 17: dp3
    reg_tmp4.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 18: dp3
    reg_tmp4.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 19: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 20: mad
    reg_tmp12 = fma_safe(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_21_34() {
    // 21: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 22: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 23: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 24: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 25: dp3
    reg_tmp4.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 26: dp3
    reg_tmp4.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 27: dp3
    reg_tmp4.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 28: dp3
    reg_tmp5.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 29: dp3
    reg_tmp5.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 30: dp3
    reg_tmp5.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 31: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 32: mad
    reg_tmp12 = fma_safe(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    // 33: mad
    reg_tmp11 = fma_safe(reg_tmp1.wwww, reg_tmp5, reg_tmp11);
    return false;
}
bool sub_34_254() {
    // 34: mul
    reg_tmp15.xyz = (mul_safe(uniforms.f[7].xxxx, vs_in_reg0)).xyz;
    // 35: mul
    reg_tmp14.xyz = (mul_safe(uniforms.f[7].yyyy, vs_in_reg1)).xyz;
    // 36: mul
    reg_tmp13.xyz = (mul_safe(uniforms.f[7].zzzz, vs_in_reg2)).xyz;
    // 37: add
    reg_tmp15.xyz = (uniforms.f[6] + reg_tmp15).xyz;
    // 38: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 39: ifu
    if (uniforms.b[1]) {
        sub_40_176();
    } else {
        sub_176_253();
    }
    // 253: nop
    return false;
}
bool sub_40_176() {
    // 40: mov
    reg_tmp0 = uniforms.f[7];
    // 41: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.yzzz));
    // 42: mov
    reg_tmp7 = uniforms.f[93].xxxx;
    // 43: mov
    reg_tmp12 = uniforms.f[93].xxxx;
    // 44: mov
    reg_tmp11 = uniforms.f[93].xxxx;
    // 45: mul
    reg_tmp2 = mul_safe(uniforms.f[93].wwww, vs_in_reg7);
    // 46: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_47_86();
    } else {
        sub_86_165();
    }
    // 165: mov
    vs_out_attr2 = -reg_tmp15;
    // 166: dp4
    reg_tmp0.x = dot(mul_safe(uniforms.f[86], reg_tmp15), vec4(1.0));
    // 167: dp4
    reg_tmp0.y = dot(mul_safe(uniforms.f[87], reg_tmp15), vec4(1.0));
    // 168: dp4
    reg_tmp0.z = dot(mul_safe(uniforms.f[88], reg_tmp15), vec4(1.0));
    // 169: dp4
    reg_tmp0.w = dot(mul_safe(uniforms.f[89], reg_tmp15), vec4(1.0));
    // 170: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 171: mul
    reg_tmp1.y = (mul_safe(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
    // 172: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 173: ifc
    if (all(conditional_code)) {
        sub_174_175();
    }
    // 175: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_47_86() {
    // 47: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 48: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 49: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 50: call
    {
        sub_12_21();
    }
    // 51: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 52: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 53: call
    {
        sub_12_21();
    }
    // 54: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 55: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 56: callc
    if (conditional_code.x) {
        sub_12_21();
    }
    // 57: ifu
    if (uniforms.b[8]) {
        sub_58_62();
    }
    // 62: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 63: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 64: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 65: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 66: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 67: add
    reg_tmp6.y = (-uniforms.f[85].wwww + reg_tmp10.yyyy).y;
    // 68: mov
    reg_tmp9.xyz = (uniforms.f[85].xyzz).xyz;
    // 69: dp4
    reg_tmp7.x = dot(mul_safe(reg_tmp9.xyzz, reg_tmp9.xyzz), vec4(1.0));
    // 70: rsq
    reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
    // 71: mul
    reg_tmp7.xyz = (mul_safe(reg_tmp9.xyzz, reg_tmp7.xxxx)).xyz;
    // 72: rcp
    reg_tmp8.y = rcp_safe(-reg_tmp7.yyyy.x);
    // 73: mul
    reg_tmp8.y = (mul_safe(reg_tmp6.yyyy, reg_tmp8.yyyy)).y;
    // 74: mul
    reg_tmp7.xyz = (mul_safe(reg_tmp7.xyzz, reg_tmp8.yyyy)).xyz;
    // 75: add
    reg_tmp10.xyz = (reg_tmp10.xyzz + reg_tmp7.xyzz).xyz;
    // 76: add
    reg_tmp10.y = (uniforms.f[94].zzzz + reg_tmp10.yyyy).y;
    // 77: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 78: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 79: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 80: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 81: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 82: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 83: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 84: call
    {
        sub_254_271();
    }
    // 85: nop
    return false;
}
bool sub_58_62() {
    // 58: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 59: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 60: callc
    if (conditional_code.y) {
        sub_12_21();
    }
    // 61: nop
    return false;
}
bool sub_86_165() {
    // 86: ifc
    if (all(conditional_code)) {
        sub_87_129();
    } else {
        sub_129_164();
    }
    // 164: nop
    return false;
}
bool sub_87_129() {
    // 87: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 88: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 89: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 90: call
    {
        sub_21_34();
    }
    // 91: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 92: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 93: call
    {
        sub_21_34();
    }
    // 94: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 95: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 96: callc
    if (conditional_code.x) {
        sub_21_34();
    }
    // 97: ifu
    if (uniforms.b[8]) {
        sub_98_102();
    }
    // 102: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 103: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 104: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 105: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 106: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 107: dp3
    reg_tmp13.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp11)), vec3(1.0));
    // 108: dp3
    reg_tmp13.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp11)), vec3(1.0));
    // 109: dp3
    reg_tmp13.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp11)), vec3(1.0));
    // 110: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 111: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 112: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 113: add
    reg_tmp6.y = (-uniforms.f[85].wwww + reg_tmp10.yyyy).y;
    // 114: mov
    reg_tmp9.xyz = (uniforms.f[85].xyzz).xyz;
    // 115: dp4
    reg_tmp7.x = dot(mul_safe(reg_tmp9.xyzz, reg_tmp9.xyzz), vec4(1.0));
    // 116: rsq
    reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
    // 117: mul
    reg_tmp7.xyz = (mul_safe(reg_tmp9.xyzz, reg_tmp7.xxxx)).xyz;
    // 118: rcp
    reg_tmp8.y = rcp_safe(-reg_tmp7.yyyy.x);
    // 119: mul
    reg_tmp8.y = (mul_safe(reg_tmp6.yyyy, reg_tmp8.yyyy)).y;
    // 120: mul
    reg_tmp7.xyz = (mul_safe(reg_tmp7.xyzz, reg_tmp8.yyyy)).xyz;
    // 121: add
    reg_tmp10.xyz = (reg_tmp10.xyzz + reg_tmp7.xyzz).xyz;
    // 122: add
    reg_tmp10.y = (uniforms.f[94].zzzz + reg_tmp10.yyyy).y;
    // 123: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 124: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 125: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 126: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 127: call
    {
        sub_271_347();
    }
    // 128: nop
    return false;
}
bool sub_98_102() {
    // 98: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 99: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 100: callc
    if (conditional_code.y) {
        sub_21_34();
    }
    // 101: nop
    return false;
}
bool sub_129_164() {
    // 129: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 130: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 131: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 132: call
    {
        sub_7_12();
    }
    // 133: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 134: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 135: call
    {
        sub_7_12();
    }
    // 136: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 137: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 138: callc
    if (conditional_code.x) {
        sub_7_12();
    }
    // 139: ifu
    if (uniforms.b[8]) {
        sub_140_144();
    }
    // 144: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 145: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 146: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 147: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 148: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 149: add
    reg_tmp6.y = (-uniforms.f[85].wwww + reg_tmp10.yyyy).y;
    // 150: mov
    reg_tmp9.xyz = (uniforms.f[85].xyzz).xyz;
    // 151: dp4
    reg_tmp7.x = dot(mul_safe(reg_tmp9.xyzz, reg_tmp9.xyzz), vec4(1.0));
    // 152: rsq
    reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
    // 153: mul
    reg_tmp7.xyz = (mul_safe(reg_tmp9.xyzz, reg_tmp7.xxxx)).xyz;
    // 154: rcp
    reg_tmp8.y = rcp_safe(-reg_tmp7.yyyy.x);
    // 155: mul
    reg_tmp8.y = (mul_safe(reg_tmp6.yyyy, reg_tmp8.yyyy)).y;
    // 156: mul
    reg_tmp7.xyz = (mul_safe(reg_tmp7.xyzz, reg_tmp8.yyyy)).xyz;
    // 157: add
    reg_tmp10.xyz = (reg_tmp10.xyzz + reg_tmp7.xyzz).xyz;
    // 158: add
    reg_tmp10.y = (uniforms.f[94].zzzz + reg_tmp10.yyyy).y;
    // 159: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 160: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 161: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 162: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 163: mov
    vs_out_attr1 = uniforms.f[93].xxxx;
    return false;
}
bool sub_140_144() {
    // 140: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 141: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 142: callc
    if (conditional_code.y) {
        sub_7_12();
    }
    // 143: nop
    return false;
}
bool sub_174_175() {
    // 174: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_176_253() {
    // 176: mov
    reg_tmp0 = uniforms.f[7];
    // 177: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.yzzz));
    // 178: ifu
    if (uniforms.b[2]) {
        sub_179_189();
    } else {
        sub_189_194();
    }
    // 194: add
    reg_tmp6.y = (-uniforms.f[85].wwww + reg_tmp10.yyyy).y;
    // 195: mov
    reg_tmp9.xyz = (uniforms.f[85].xyzz).xyz;
    // 196: dp4
    reg_tmp7.x = dot(mul_safe(reg_tmp9.xyzz, reg_tmp9.xyzz), vec4(1.0));
    // 197: rsq
    reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
    // 198: mul
    reg_tmp7.xyz = (mul_safe(reg_tmp9.xyzz, reg_tmp7.xxxx)).xyz;
    // 199: rcp
    reg_tmp8.y = rcp_safe(-reg_tmp7.yyyy.x);
    // 200: mul
    reg_tmp8.y = (mul_safe(reg_tmp6.yyyy, reg_tmp8.yyyy)).y;
    // 201: mul
    reg_tmp7.xyz = (mul_safe(reg_tmp7.xyzz, reg_tmp8.yyyy)).xyz;
    // 202: add
    reg_tmp10.xyz = (reg_tmp10.xyzz + reg_tmp7.xyzz).xyz;
    // 203: add
    reg_tmp10.y = (uniforms.f[94].zzzz + reg_tmp10.yyyy).y;
    // 204: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_205_217();
    } else {
        sub_217_242();
    }
    // 242: mov
    vs_out_attr2 = -reg_tmp15;
    // 243: dp4
    reg_tmp0.x = dot(mul_safe(uniforms.f[86], reg_tmp15), vec4(1.0));
    // 244: dp4
    reg_tmp0.y = dot(mul_safe(uniforms.f[87], reg_tmp15), vec4(1.0));
    // 245: dp4
    reg_tmp0.z = dot(mul_safe(uniforms.f[88], reg_tmp15), vec4(1.0));
    // 246: dp4
    reg_tmp0.w = dot(mul_safe(uniforms.f[89], reg_tmp15), vec4(1.0));
    // 247: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 248: mul
    reg_tmp1.y = (mul_safe(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
    // 249: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 250: ifc
    if (all(conditional_code)) {
        sub_251_252();
    }
    // 252: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_179_189() {
    // 179: mul
    reg_tmp1.x = (mul_safe(uniforms.f[93].wwww, vs_in_reg7.xxxx)).x;
    // 180: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 181: dp4
    reg_tmp7.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 182: dp4
    reg_tmp7.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 183: dp4
    reg_tmp7.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 184: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 185: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 186: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 187: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 188: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_189_194() {
    // 189: mova
    address_registers.x = (ivec2(uniforms.f[93].xxxx)).x;
    // 190: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[25], reg_tmp15), vec4(1.0));
    // 191: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[26], reg_tmp15), vec4(1.0));
    // 192: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[27], reg_tmp15), vec4(1.0));
    // 193: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_205_217() {
    // 205: dp3
    reg_tmp12.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 206: dp3
    reg_tmp12.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 207: dp3
    reg_tmp12.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 208: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 209: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 210: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 211: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 212: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 213: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 214: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 215: call
    {
        sub_254_271();
    }
    // 216: nop
    return false;
}
bool sub_217_242() {
    // 217: ifc
    if (all(conditional_code)) {
        sub_218_236();
    } else {
        sub_236_241();
    }
    // 241: nop
    return false;
}
bool sub_218_236() {
    // 218: dp3
    reg_tmp12.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 219: dp3
    reg_tmp12.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 220: dp3
    reg_tmp12.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 221: dp3
    reg_tmp11.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 222: dp3
    reg_tmp11.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 223: dp3
    reg_tmp11.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 224: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 225: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 226: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 227: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 228: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 229: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 230: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 231: dp3
    reg_tmp13.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp11)), vec3(1.0));
    // 232: dp3
    reg_tmp13.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp11)), vec3(1.0));
    // 233: dp3
    reg_tmp13.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp11)), vec3(1.0));
    // 234: call
    {
        sub_271_347();
    }
    // 235: nop
    return false;
}
bool sub_236_241() {
    // 236: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 237: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 238: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 239: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 240: mov
    vs_out_attr1 = uniforms.f[93].xxxx;
    return false;
}
bool sub_251_252() {
    // 251: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_254_271() {
    uint jmp_to = 254u;
    while (true) {
        switch (jmp_to) {
        case 254u: {
            // 254: dp3
            reg_tmp6.x = dot(vec3(mul_safe(reg_tmp14, reg_tmp14)), vec3(1.0));
            // 255: dp3
            reg_tmp7.x = dot(vec3(mul_safe(reg_tmp12, reg_tmp12)), vec3(1.0));
            // 256: rsq
            reg_tmp6.x = rsq_safe(reg_tmp6.xxxx.x);
            // 257: rsq
            reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
            // 258: mul
            reg_tmp14.xyz = (mul_safe(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 259: mul
            reg_tmp12.xyz = (mul_safe(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 260: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 261: jmpu
            if (!uniforms.b[15]) {
                { jmp_to = 270u; break; }
            }
            // 262: add
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            // 263: mul
            reg_tmp4 = mul_safe(uniforms.f[94].zzzz, reg_tmp4);
            // 264: cmp
            conditional_code = greaterThanEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp4.xxxx));
            // 265: rsq
            reg_tmp4 = vec4(rsq_safe(reg_tmp4.xxxx.x));
            // 266: mul
            reg_tmp5 = mul_safe(uniforms.f[94].zzzz, reg_tmp14);
            // 267: jmpc
            if (conditional_code.x) {
                { jmp_to = 270u; break; }
            }
            // 268: rcp
            reg_tmp0.z = rcp_safe(reg_tmp4.xxxx.x);
            // 269: mul
            reg_tmp0.xy = (mul_safe(reg_tmp5, reg_tmp4)).xy;
        }
        case 270u: {
            // 270: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_271_347() {
    uint jmp_to = 271u;
    while (true) {
        switch (jmp_to) {
        case 271u: {
            // 271: dp3
            reg_tmp6.x = dot(vec3(mul_safe(reg_tmp14, reg_tmp14)), vec3(1.0));
            // 272: dp3
            reg_tmp7.x = dot(vec3(mul_safe(reg_tmp12, reg_tmp12)), vec3(1.0));
            // 273: rsq
            reg_tmp6.x = rsq_safe(reg_tmp6.xxxx.x);
            // 274: rsq
            reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
            // 275: mul
            reg_tmp14.xyz = (mul_safe(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 276: mul
            reg_tmp12.xyz = (mul_safe(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 277: mul
            reg_tmp13.xyz = (mul_safe(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            // 278: mul
            reg_tmp11.xyz = (mul_safe(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            // 279: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 280: jmpu
            if (!uniforms.b[15]) {
                { jmp_to = 346u; break; }
            }
            // 281: mul
            reg_tmp13.xyz = (mul_safe(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            // 282: mul
            reg_tmp11.xyz = (mul_safe(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            // 283: mul
            reg_tmp5 = mul_safe(reg_tmp14.yzxx, reg_tmp13.zxyy);
            // 284: mad
            reg_tmp5 = fma_safe(-reg_tmp13.yzxx, reg_tmp14.zxyy, reg_tmp5);
            // 285: dp3
            reg_tmp5.w = dot(vec3(mul_safe(reg_tmp5, reg_tmp5)), vec3(1.0));
            // 286: rsq
            reg_tmp5.w = rsq_safe(reg_tmp5.wwww.x);
            // 287: mul
            reg_tmp5 = mul_safe(reg_tmp5, reg_tmp5.wwww);
            // 288: add
            reg_tmp6.w = (reg_tmp14.zzzz + reg_tmp5.yyyy).w;
            // 289: mul
            reg_tmp13 = mul_safe(reg_tmp5.yzxx, reg_tmp14.zxyy);
            // 290: mad
            reg_tmp13 = fma_safe(-reg_tmp14.yzxx, reg_tmp5.zxyy, reg_tmp13);
            // 291: add
            reg_tmp6.w = (reg_tmp13.xxxx + reg_tmp6).w;
            // 292: mov
            reg_tmp13.w = (reg_tmp5.zzzz).w;
            // 293: mov
            reg_tmp5.z = (reg_tmp13.xxxx).z;
            // 294: add
            reg_tmp6.w = (uniforms.f[93].yyyy + reg_tmp6).w;
            // 295: mov
            reg_tmp14.w = (reg_tmp5.xxxx).w;
            // 296: mov
            reg_tmp5.x = (reg_tmp14.zzzz).x;
            // 297: cmp
            conditional_code = lessThan(vec2(uniforms.f[94].yyyy), vec2(reg_tmp6.wwww));
            // 298: mov
            reg_tmp6.x = (uniforms.f[93].yyyy).x;
            // 299: mov
            reg_tmp6.y = (-uniforms.f[93].yyyy).y;
            // 300: jmpc
            if (!conditional_code.x) {
                { jmp_to = 308u; break; }
            }
            // 301: add
            reg_tmp7.xz = (reg_tmp13.wwyy + -reg_tmp14.yyww).xz;
            // 302: add
            reg_tmp7.y = (reg_tmp14.xxxx + -reg_tmp13.zzzz).y;
            // 303: mov
            reg_tmp7.w = (reg_tmp6).w;
            // 304: dp4
            reg_tmp6 = vec4(dot(mul_safe(reg_tmp7, reg_tmp7), vec4(1.0)));
            // 305: rsq
            reg_tmp6 = vec4(rsq_safe(reg_tmp6.xxxx.x));
            // 306: mul
            reg_tmp0 = mul_safe(reg_tmp7, reg_tmp6);
            // 307: jmpu
            if (uniforms.b[0]) {
                { jmp_to = 346u; break; }
            }
        }
        case 308u: {
            // 308: cmp
            conditional_code = greaterThan(vec2(reg_tmp5.zyyy), vec2(reg_tmp5.yxxx));
            // 309: ifc
            if (conditional_code.x) {
                sub_310_330();
            } else {
                sub_330_343();
            }
            // 343: dp4
            reg_tmp6 = vec4(dot(mul_safe(reg_tmp8, reg_tmp8), vec4(1.0)));
            // 344: rsq
            reg_tmp6 = vec4(rsq_safe(reg_tmp6.xxxx.x));
            // 345: mul
            reg_tmp0 = mul_safe(reg_tmp8, reg_tmp6);
        }
        case 346u: {
            // 346: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_310_330() {
    // 310: ifc
    if (conditional_code.y) {
        sub_311_316();
    } else {
        sub_316_329();
    }
    // 329: mov
    reg_tmp8.w = (-reg_tmp8).w;
    return false;
}
bool sub_311_316() {
    // 311: mul
    reg_tmp8 = mul_safe(reg_tmp13.yyzw, reg_tmp6.xxxy);
    // 312: add
    reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
    // 313: add
    reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
    // 314: add
    reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
    // 315: add
    reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
    return false;
}
bool sub_316_329() {
    // 316: cmp
    conditional_code = greaterThan(vec2(reg_tmp5.zzzz), vec2(reg_tmp5.xxxx));
    // 317: mul
    reg_tmp8 = mul_safe(reg_tmp13.yyzw, reg_tmp6.xxxy);
    // 318: add
    reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
    // 319: ifc
    if (conditional_code.x) {
        sub_320_323();
    } else {
        sub_323_328();
    }
    // 328: nop
    return false;
}
bool sub_320_323() {
    // 320: add
    reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
    // 321: add
    reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
    // 322: add
    reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
    return false;
}
bool sub_323_328() {
    // 323: mul
    reg_tmp8 = mul_safe(reg_tmp13.zwwy, reg_tmp6.xxxy);
    // 324: add
    reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
    // 325: add
    reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
    // 326: add
    reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
    // 327: add
    reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
    return false;
}
bool sub_330_343() {
    // 330: ifc
    if (conditional_code.y) {
        sub_331_336();
    } else {
        sub_336_342();
    }
    // 342: nop
    return false;
}
bool sub_331_336() {
    // 331: mul
    reg_tmp8 = mul_safe(reg_tmp13.yywz, reg_tmp6.xxxy);
    // 332: add
    reg_tmp8.y = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).y;
    // 333: add
    reg_tmp9 = reg_tmp5.yyyy + -reg_tmp5.xxxx;
    // 334: add
    reg_tmp8.xzw = (reg_tmp8 + reg_tmp14.wwyx).xzw;
    // 335: add
    reg_tmp8.y = (reg_tmp9 + reg_tmp8).y;
    return false;
}
bool sub_336_342() {
    // 336: mul
    reg_tmp8 = mul_safe(reg_tmp13.zwwy, reg_tmp6.xxxy);
    // 337: add
    reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
    // 338: add
    reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
    // 339: add
    reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
    // 340: add
    reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
    // 341: mov
    reg_tmp8.w = (-reg_tmp8).w;
    return false;
}
bool sub_347_369() {
    // 347: mov
    reg_tmp8.xy = (uniforms.f[93].xxxx).xy;
    // 348: mov
    reg_tmp0.y = (uniforms.f[7].wwww).y;
    // 349: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.xyyy));
    // 350: mov
    reg_tmp9.xyz = (uniforms.f[93].xxxx).xyz;
    // 351: mov
    reg_tmp9.w = (uniforms.f[21].wwww).w;
    // 352: ifc
    if (conditional_code.y) {
        sub_353_358();
    }
    // 358: callu
    if (uniforms.b[12]) {
        sub_369_415();
    }
    // 359: cmp
    conditional_code = equal(vec2(uniforms.f[93].xxxx), vec2(reg_tmp8.xyyy));
    // 360: ifc
    if (all(conditional_code)) {
        sub_361_362();
    }
    // 362: add
    reg_tmp0.xyz = (uniforms.f[24].xyzz + -reg_tmp10.xyzz).xyz;
    // 363: rcp
    reg_tmp0.w = rcp_safe(uniforms.f[24].wwww.x);
    // 364: dp3
    reg_tmp1.w = dot(vec3(mul_safe(reg_tmp0.xyzz, reg_tmp0.xyzz)), vec3(1.0));
    // 365: mul
    reg_tmp1.w = (mul_safe(reg_tmp0.wwww, reg_tmp1.wwww)).w;
    // 366: min
    reg_tmp1.w = (min(uniforms.f[93].yyyy, reg_tmp1.wwww)).w;
    // 367: add
    reg_tmp9.w = (uniforms.f[93].yyyy + -reg_tmp1.wwww).w;
    // 368: max
    vs_out_attr3 = max(uniforms.f[93].xxxx, reg_tmp9);
    return false;
}
bool sub_353_358() {
    // 353: mul
    reg_tmp0 = mul_safe(uniforms.f[7].wwww, vs_in_reg3);
    // 354: ifu
    if (uniforms.b[7]) {
        sub_355_356();
    }
    // 356: mul
    reg_tmp9.xyz = (mul_safe(uniforms.f[20].wwww, reg_tmp0.xyzz)).xyz;
    // 357: mov
    reg_tmp8.x = (uniforms.f[93].yyyy).x;
    return false;
}
bool sub_355_356() {
    // 355: mul
    reg_tmp9.w = (mul_safe(reg_tmp9.wwww, reg_tmp0.wwww)).w;
    return false;
}
bool sub_361_362() {
    // 361: mov
    reg_tmp9 = uniforms.f[21];
    return false;
}
bool sub_369_415() {
    // 369: mov
    reg_tmp1 = uniforms.f[20];
    // 370: mov
    reg_tmp2 = uniforms.f[21];
    // 371: mov
    reg_tmp3 = uniforms.f[93].xxxx;
    // 372: loop
    address_registers.z = int(uniforms.i[0].y);
    for (uint loop372 = 0u; loop372 <= uniforms.i[0].x; address_registers.z += int(uniforms.i[0].z), ++loop372) {
        sub_373_414();
    }
    // 414: mov
    reg_tmp8.x = (uniforms.f[93].yyyy).x;
    return false;
}
bool sub_373_414() {
    // 373: mova
    address_registers.x = (ivec2(reg_tmp3)).x;
    // 374: mov
    reg_tmp4.x = (uniforms.f[81 + address_registers.x].wwww).x;
    // 375: mov
    reg_tmp4.y = (uniforms.f[83 + address_registers.x].wwww).y;
    // 376: cmp
    conditional_code = equal(vec2(uniforms.f[93].xyyy), vec2(reg_tmp4.xyyy));
    // 377: ifc
    if (conditional_code.x) {
        sub_378_380();
    } else {
        sub_380_404();
    }
    // 404: cmp
    conditional_code.x = uniforms.f[93].xxxx.x == reg_tmp6.xyyy.x;
    conditional_code.y = uniforms.f[93].xxxx.y < reg_tmp6.xyyy.y;
    // 405: ifc
    if (conditional_code.y) {
        sub_406_413();
    }
    // 413: add
    reg_tmp3 = -uniforms.f[95].wwww + reg_tmp3;
    return false;
}
bool sub_378_380() {
    // 378: dp3
    reg_tmp6.x = dot(vec3(mul_safe(uniforms.f[81 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 379: mov
    reg_tmp6.y = (uniforms.f[93].yyyy).y;
    return false;
}
bool sub_380_404() {
    // 380: add
    reg_tmp4 = uniforms.f[81 + address_registers.x] + -reg_tmp15;
    // 381: mov
    reg_tmp6.y = (uniforms.f[93].yyyy).y;
    // 382: ifc
    if (conditional_code.y) {
        sub_383_388();
    }
    // 388: mov
    reg_tmp5 = uniforms.f[82 + address_registers.x];
    // 389: cmp
    conditional_code = equal(vec2(uniforms.f[93].yyyy), vec2(reg_tmp5.wwww));
    // 390: dp3
    reg_tmp4.w = dot(vec3(mul_safe(reg_tmp4, reg_tmp4)), vec3(1.0));
    // 391: rsq
    reg_tmp4.w = rsq_safe(reg_tmp4.wwww.x);
    // 392: mul
    reg_tmp4 = mul_safe(reg_tmp4, reg_tmp4.wwww);
    // 393: ifc
    if (conditional_code.x) {
        sub_394_403();
    }
    // 403: dp3
    reg_tmp6.x = dot(vec3(mul_safe(reg_tmp14, reg_tmp4)), vec3(1.0));
    return false;
}
bool sub_383_388() {
    // 383: mov
    reg_tmp5.x = (uniforms.f[93].yyyy).x;
    // 384: dp3
    reg_tmp5.z = dot(vec3(mul_safe(reg_tmp4, reg_tmp4)), vec3(1.0));
    // 385: mul
    reg_tmp5.y = (mul_safe(reg_tmp5.zzzz, reg_tmp5.zzzz)).y;
    // 386: dp3
    reg_tmp6.y = dot(vec3(mul_safe(uniforms.f[83 + address_registers.x], reg_tmp5)), vec3(1.0));
    // 387: rcp
    reg_tmp6.y = rcp_safe(reg_tmp6.yyyy.x);
    return false;
}
bool sub_394_403() {
    // 394: dp3
    reg_tmp5.x = dot(vec3(mul_safe(uniforms.f[82 + address_registers.x], -reg_tmp4)), vec3(1.0));
    // 395: slti
    reg_tmp5.y = (vec4(lessThan(reg_tmp5.xxxx,uniforms.f[84 + address_registers.x].yyyy))).y;
    // 396: cmp
    conditional_code = equal(vec2(uniforms.f[93].yyyy), vec2(reg_tmp5.xyyy));
    // 397: ifc
    if (conditional_code.y) {
        sub_398_399();
    } else {
        sub_399_402();
    }
    // 402: mul
    reg_tmp6.y = (mul_safe(reg_tmp6.yyyy, reg_tmp5.xxxx)).y;
    return false;
}
bool sub_398_399() {
    // 398: mov
    reg_tmp5.x = (uniforms.f[93].xxxx).x;
    return false;
}
bool sub_399_402() {
    // 399: log
    reg_tmp5.y = log2(reg_tmp5.xxxx.x);
    // 400: mul
    reg_tmp5.y = (mul_safe(uniforms.f[84 + address_registers.x].xxxx, reg_tmp5.yyyy)).y;
    // 401: exp
    reg_tmp5.x = exp2(reg_tmp5.yyyy.x);
    return false;
}
bool sub_406_413() {
    // 406: max
    reg_tmp6.x = (max(uniforms.f[93].xxxx, reg_tmp6.xxxx)).x;
    // 407: mad
    reg_tmp9.xyz = (fma_safe(reg_tmp1.xyzz, uniforms.f[79 + address_registers.x].xyzz, reg_tmp9.xyzz)).xyz;
    // 408: mul
    reg_tmp4 = mul_safe(uniforms.f[80 + address_registers.x], reg_tmp2);
    // 409: mul
    reg_tmp5.xyz = (mul_safe(reg_tmp6.xxxx, reg_tmp4.xyzz)).xyz;
    // 410: mul
    reg_tmp5.xyz = (mul_safe(reg_tmp6.yyyy, reg_tmp5.xyzz)).xyz;
    // 411: add
    reg_tmp9.xyz = (reg_tmp9.xyzz + reg_tmp5.xyzz).xyz;
    // 412: add
    reg_tmp9.w = (reg_tmp9.wwww + reg_tmp4.wwww).w;
    return false;
}
// reference: E93DB1C60A6E310D, 1E6C0649B5CE7F1C
// shader: 8B30, AAD077FFD85152AB

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((vec3(1.0) - rounded_primary_color.aaa) + (const_color[0].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) + (vec3(1.0) - const_color[1].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 8020625A39D3AA43, AAD077FFD85152AB
// program: 1E6C0649B5CE7F1C, AD7922A63ED54CA7, AAD077FFD85152AB
// reference: 575FBDB42B67B872, BAF5CB3693892DB3
// shader: 8B30, AEA8529257EA252C

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((vec3(1.0) - rounded_primary_color.aaa) + (const_color[0].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) + (vec3(1.0) - const_color[1].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 8020625AE8D9B5BF, AEA8529257EA252C
// program: 0000000000000000, 0000000000000000, AEA8529257EA252C
// reference: B70A0F5291C75ADF, EC7233A0BD4CF3D2
// shader: 8B30, 68475D8B9F916549

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((vec3(1.0) - rounded_primary_color.aaa) + (const_color[0].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) + (vec3(1.0) - const_color[1].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb) * (vec3(1.0) - texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a) * (1.0 - texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (texcolor0.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (texcolor0.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: F7FE8CEB7D506E1D, 68475D8B9F916549
// program: EC7233A0BD4CF3D2, 5D764F9A6220D694, 68475D8B9F916549
// reference: 2E5F77134A7EFB98, EC7233A0BD4CF3D2
// shader: 8B30, A8ADD30A63E76265

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((vec3(1.0) - rounded_primary_color.aaa) + (const_color[0].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) + (vec3(1.0) - const_color[1].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb) * (vec3(1.0) - texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a) * (1.0 - texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (texcolor0.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (texcolor0.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 7A438EF5B82A7E0A, A8ADD30A63E76265
// program: 0000000000000000, 0000000000000000, A8ADD30A63E76265
// reference: CE0AC5F5F0DE1935, BAF5CB3693892DB3
// reference: DAB3C4835EB3197D, 666154B1BFC0A909
// reference: 487D8D2DCC7880E5, C27F787C261C6045
// reference: C63F3C135E1DA9CE, C27F787C261C6045
// reference: 943A9788244FE826, C74CA00DB8E95117
// reference: F81B2FF3EAE10450, 3DBC6131A77F0199
// reference: 1B6FEA60B92C4CC6, B582B9861A22E219
// reference: 1B6FEA605615DF87, B582B9861A22E219
// reference: 4F4FC0EA08578713, BAF5CB3693892DB3
// reference: E00B52ADC9D13B31, 3DBC6131A77F0199
// reference: 3A31C41C244FE826, C74CA00DB8E95117
// reference: 4F4FC0EAE76E1452, BAF5CB3693892DB3
// reference: AC515EDF4B783905, 7BB64A39FB1F4E77
// reference: 3F59456F0700816D, 8C2ECA480D7B7AB5
// reference: E0A490395615DF87, B582B9861A22E219
// reference: B484BAB308578713, BAF5CB3693892DB3
// reference: D290B1ECA8839EBD, 18CD6F34EF819318
// reference: 1BC028F4C9D13B31, 3DBC6131A77F0199
// reference: 1BC028F426E8A870, 3DBC6131A77F0199
// reference: B484BAB3E76E1452, BAF5CB3693892DB3
// reference: 70284790805D7495, 6508155727F8E389
// reference: 63CE8E81BF82DD7E, 85967F14F07719A7
// reference: 3F4D457F0F7A9D6C, 23F262D2CA8E6488
// reference: 89325092B204F27E, 7FF280648EA22926
// reference: 893250925EB3197D, 06A8A4F9432C9B26
// reference: A2BAD562EC976992, 2F84956AB5DBE86B
// reference: FFF7BA5300F9FFD5, 45B9B5821FF15384
// reference: 3C4DE4507327E433, 39C07F205AF70F59
// reference: D5E7AAC83318B62E, 2F3A3851E4476855
// shader: 8B30, 528296AD4921766A

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (1.0 - texcolor0.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 30195BBB1519A68B, 528296AD4921766A
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, 528296AD4921766A
// reference: 86663ED93318B62E, 9DB6533B8FE11441
// reference: C91D23AE8562FAD3, 7F132D830BF35BC2
// reference: 50485BEF5EDB5B94, 7F132D830BF35BC2
// reference: 2DD1C2F2D3EE2654, BAF5CB3693892DB3
// reference: BE081563CF44BF82, 4AD2C97240195A76
// reference: A0327416A63DB4E7, 4AD2C97240195A76
// reference: C94B7F73D48D6D2B, 4AD2C97240195A76
// reference: 87C274DABDF4664E, 4AD2C97240195A76
// reference: 87C274DAD48D6D2B, 4AD2C97240195A76
// reference: A0327416D48D6D2B, 4AD2C97240195A76
// shader: 8B30, FA9C11D88771DF9F

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((vec3(1.0) - rounded_primary_color.aaa) + (const_color[0].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) + (vec3(1.0) - const_color[1].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb) * (vec3(1.0) - texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a) * (1.0 - texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (texcolor0.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (texcolor0.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (const_color[5].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: F7FE8CEB33A8E707, FA9C11D88771DF9F
// program: EC7233A0BD4CF3D2, 5D764F9A6220D694, FA9C11D88771DF9F
// shader: 8B30, 09AA976E69641246

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((vec3(1.0) - rounded_primary_color.aaa) + (const_color[0].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) + (vec3(1.0) - const_color[1].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((vec3(1.0) - texcolor0.rgb) * (const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((texcolor0.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((texcolor0.rgb) * (const_color[4].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((1.0 - texcolor0.a) * (const_color[4].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 38666814FCAF78A7, 09AA976E69641246
// program: EC7233A0BD4CF3D2, 5D764F9A6220D694, 09AA976E69641246
// reference: 7028479055F0EB8D, 48869468E89D649B
// reference: 575FBDB4C45E2B33, BAF5CB3693892DB3
// shader: 8B30, B1928C77DA82D8DC

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += ((light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[2].position + view);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * LookupLightingLUTUnsigned(18,clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[2].specular_0) + (light_src[2].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(18,clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[3].position + view);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * LookupLightingLUTUnsigned(19,clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[3].specular_0) + (light_src[3].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(19,clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: B3CACFE6C0B42BB2, B1928C77DA82D8DC
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, B1928C77DA82D8DC
// reference: DAB3C483C0B42BB2, B1928C77DA82D8DC
// shader: 8B30, BD3EBAD315031A9C

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += ((light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[2].position + view);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * LookupLightingLUTUnsigned(18,clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[2].specular_0) + (light_src[2].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(18,clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[3].position + view);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * LookupLightingLUTUnsigned(19,clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[3].specular_0) + (light_src[3].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(19,clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb) + (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 473D51212C03C0B1, BD3EBAD315031A9C
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, BD3EBAD315031A9C
// shader: 8B30, 5AB91AFAAFD32BB6

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += ((light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[2].position + view);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * LookupLightingLUTUnsigned(18,clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[2].specular_0) + (light_src[2].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(18,clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[3].position + view);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * LookupLightingLUTUnsigned(19,clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[3].specular_0) + (light_src[3].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(19,clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_2 = byteround(clamp((texcolor1.rgb) + (secondary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (const_color[2].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (last_tex_env_out.aaa) + (combiner_buffer.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 4E5901733C16DE87, 5AB91AFAAFD32BB6
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, 5AB91AFAAFD32BB6
// reference: 32D659F78562FAD3, 7F132D830BF35BC2
// reference: AB8321B65EDB5B94, 7F132D830BF35BC2
// reference: D61AB8ABD3EE2654, BAF5CB3693892DB3
// reference: 473D51215EB3197D, BD3EBAD315031A9C
// reference: 4E5901734EA6074B, 5AB91AFAAFD32BB6
// reference: 8A00AE5FDB7DF91B, B1928C77DA82D8DC
// reference: DAB3C483A9CD20D7, B1928C77DA82D8DC
// reference: 823A92218DAC7EC0, B582B9861A22E219
// reference: 337DE45DCD3204B2, 85967F14F07719A7
// reference: 00D052782C5E72FF, E2B05A5EEE3BCE11
// reference: 337DE45DBF82DD7E, 85967F14F07719A7
// reference: E00B52AD26E8A870, 3DBC6131A77F0199
// shader: 8B30, AB9CD65F41BDEFA0

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = 2.0 * (texcolor1).rgb - 1.0;
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += ((light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[2].position + view);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * LookupLightingLUTUnsigned(18,clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[2].specular_0) + (light_src[2].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(18,clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[3].position + view);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * LookupLightingLUTUnsigned(19,clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[3].specular_0) + (light_src[3].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(19,clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((secondary_fragment_color.r) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (last_tex_env_out.aaa), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((combiner_buffer.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 4FC2F0579565A846, AB9CD65F41BDEFA0
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, AB9CD65F41BDEFA0
// reference: 943A9788C8F80325, 8B353D67743458EE
// shader: 8B30, 98125BD9033DAC4C

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb) * (vec3(1.0) - const_color[0].aaa) + (const_color[0].rgb) * (vec3(1.0) - (vec3(1.0) - const_color[0].aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (texcolor1.b) + (1.0 - texcolor1.b) * (1.0 - (texcolor1.b)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (const_color[1].r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 3A925354C96D5899, 98125BD9033DAC4C
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, 98125BD9033DAC4C
// reference: 4FC2F057E7D5718A, AB9CD65F41BDEFA0
// reference: 3A925354BBDD8155, 98125BD9033DAC4C
// reference: 806EDD4B30F57863, 82B30867377518C0
// shader: 8B30, A4FE917C39832451

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += ((light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[2].position + view);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * LookupLightingLUTUnsigned(18,clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[2].specular_0) + (light_src[2].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(18,clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[3].position + view);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * LookupLightingLUTUnsigned(19,clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[3].specular_0) + (light_src[3].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(19,clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 633681DCEFBDA294, A4FE917C39832451
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, A4FE917C39832451
// reference: 104E2359E10782E3, 7F132D830BF35BC2
// reference: 891B5B183ABE23A4, 7F132D830BF35BC2
// shader: 8B30, 8A76329CB25030B1

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp(vec3(dot((texcolor0.rgb) - vec3(0.5), (texcolor1.rgb) - vec3(0.5)) * 4.0), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) + (1.0 - texcolor1.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_1 = byteround(clamp(vec3(dot((texcolor0.rgb) - vec3(0.5), (texcolor2.rgb) - vec3(0.5)) * 4.0), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp(min((texcolor1.a) + (1.0 - texcolor0.a), 1.0) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (combiner_buffer.rgb) + (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp(min((texcolor0.a) + (1.0 - texcolor2.a), 1.0) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp(min((texcolor2.a) + (1.0 - texcolor0.a), 1.0) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a) - (const_color[4].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4 * 1.0, alpha_output_4 * 4.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (last_tex_env_out.aaa) + (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a) - (primary_fragment_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5 * 1.0, alpha_output_5 * 4.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 51511626FE35BA0C, 8A76329CB25030B1
// program: 7F132D830BF35BC2, AD7922A63ED54CA7, 8A76329CB25030B1
// reference: 253BAF9977B093B6, EC7233A0BD4CF3D2
// shader: 8B30, 0B496AE87480A30D

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((vec3(1.0) - texcolor0.rrr) - (vec3(1.0) - texcolor1.rrr), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((1.0 - texcolor0.r) - (1.0 - texcolor2.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0 * 4.0, alpha_output_0 * 4.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) + (last_tex_env_out.aaa), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1 * 4.0, alpha_output_1 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2 * 4.0, alpha_output_2 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb) * (vec3(1.0) - texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a) * (1.0 - texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (texcolor0.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (texcolor0.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: DF03A27AC00E02D7, 0B496AE87480A30D
// program: EC7233A0BD4CF3D2, 5D764F9A6220D694, 0B496AE87480A30D
// reference: BC6ED7D8AC0932F1, EC7233A0BD4CF3D2
// shader: 8B30, 9984ECD2B5F69CEC

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((vec3(1.0) - texcolor0.rrr) - (vec3(1.0) - texcolor1.rrr), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((1.0 - texcolor0.r) - (1.0 - texcolor2.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0 * 4.0, alpha_output_0 * 4.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) + (last_tex_env_out.aaa), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1 * 4.0, alpha_output_1 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2 * 4.0, alpha_output_2 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb) * (vec3(1.0) - texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a) * (1.0 - texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (texcolor0.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (texcolor0.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 52BEA064057412C0, 9984ECD2B5F69CEC
// program: 0000000000000000, 0000000000000000, 9984ECD2B5F69CEC
// shader: 8B31, AA5284D8354BC7F4

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define mul_safe(x, y) mix(x * y, vec4(0.0), isnan(x * y))

float rcp_safe(float x) {
    if (x == 0.0f) return x;
    return 1.0f / x;
}


float rsq_safe(float x) {
    if (x == 0.0f) return x;
    return inversesqrt(x);
}

#define fma_safe(x, y, z) (mul_safe(x, y) + z)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_6_11();
bool sub_11_20();
bool sub_20_29();
bool sub_37_197();
bool sub_42_139();
bool sub_48_76();
bool sub_59_63();
bool sub_76_129();
bool sub_77_104();
bool sub_88_92();
bool sub_104_128();
bool sub_115_119();
bool sub_137_138();
bool sub_139_194();
bool sub_142_152();
bool sub_152_157();
bool sub_158_168();
bool sub_168_184();
bool sub_169_179();
bool sub_179_183();
bool sub_192_193();
bool sub_197_214();
bool sub_203_208();
bool sub_205_206();
bool sub_212_213();
bool sub_214_260();
bool sub_218_259();
bool sub_223_225();
bool sub_225_249();
bool sub_228_233();
bool sub_239_248();
bool sub_243_244();
bool sub_244_247();
bool sub_251_258();
bool sub_260_270();
bool sub_267_268();
bool sub_279_288();
bool sub_321_329();
bool sub_323_324();
bool sub_324_328();
bool sub_325_326();
bool sub_326_327();
bool sub_329_333();
bool sub_333_4096();
bool sub_339_366();
bool sub_341_346();
bool sub_346_365();
bool sub_349_355();
bool sub_355_364();
bool sub_356_360();
bool sub_360_363();
bool sub_366_373();

bool exec_shader() {
    sub_333_4096();
    return true;
}

bool sub_6_11() {
    // 6: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 7: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 8: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 9: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 10: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    return false;
}
bool sub_11_20() {
    // 11: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 12: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 13: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 14: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 15: dp3
    reg_tmp4.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 16: dp3
    reg_tmp4.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 17: dp3
    reg_tmp4.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 18: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 19: mad
    reg_tmp12 = fma_safe(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_20_29() {
    // 20: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 21: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 22: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 23: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 24: dp3
    reg_tmp4.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 25: dp3
    reg_tmp4.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 26: dp3
    reg_tmp4.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 27: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 28: mad
    reg_tmp12 = fma_safe(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_37_197() {
    // 37: mul
    reg_tmp15.xyz = (mul_safe(uniforms.f[7].xxxx, vs_in_reg0)).xyz;
    // 38: mul
    reg_tmp14.xyz = (mul_safe(uniforms.f[7].yyyy, vs_in_reg1)).xyz;
    // 39: add
    reg_tmp15.xyz = (uniforms.f[6] + reg_tmp15).xyz;
    // 40: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 41: ifu
    if (uniforms.b[1]) {
        sub_42_139();
    } else {
        sub_139_194();
    }
    // 194: nop
    // 195: mov
    vs_out_attr1 = uniforms.f[93].xxxx;
    // 196: mov
    vs_out_attr2 = uniforms.f[93].xxxx;
    return false;
}
bool sub_42_139() {
    // 42: mov
    reg_tmp0 = uniforms.f[7];
    // 43: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.yzzz));
    // 44: mov
    reg_tmp7 = uniforms.f[93].xxxx;
    // 45: mov
    reg_tmp12 = uniforms.f[93].xxxx;
    // 46: mul
    reg_tmp2 = mul_safe(uniforms.f[93].wwww, vs_in_reg7);
    // 47: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_48_76();
    } else {
        sub_76_129();
    }
    // 129: dp4
    reg_tmp0.x = dot(mul_safe(uniforms.f[86], reg_tmp15), vec4(1.0));
    // 130: dp4
    reg_tmp0.y = dot(mul_safe(uniforms.f[87], reg_tmp15), vec4(1.0));
    // 131: dp4
    reg_tmp0.z = dot(mul_safe(uniforms.f[88], reg_tmp15), vec4(1.0));
    // 132: dp4
    reg_tmp0.w = dot(mul_safe(uniforms.f[89], reg_tmp15), vec4(1.0));
    // 133: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 134: mul
    reg_tmp1.y = (mul_safe(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
    // 135: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 136: ifc
    if (all(conditional_code)) {
        sub_137_138();
    }
    // 138: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_48_76() {
    // 48: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 49: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 50: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 51: call
    {
        sub_11_20();
    }
    // 52: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 53: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 54: call
    {
        sub_11_20();
    }
    // 55: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 56: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 57: callc
    if (conditional_code.x) {
        sub_11_20();
    }
    // 58: ifu
    if (uniforms.b[8]) {
        sub_59_63();
    }
    // 63: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 64: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 65: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 66: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 67: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 68: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 69: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 70: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 71: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 72: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 73: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 74: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 75: nop
    return false;
}
bool sub_59_63() {
    // 59: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 60: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 61: callc
    if (conditional_code.y) {
        sub_11_20();
    }
    // 62: nop
    return false;
}
bool sub_76_129() {
    // 76: ifc
    if (all(conditional_code)) {
        sub_77_104();
    } else {
        sub_104_128();
    }
    // 128: nop
    return false;
}
bool sub_77_104() {
    // 77: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 78: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 79: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 80: call
    {
        sub_20_29();
    }
    // 81: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 82: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 83: call
    {
        sub_20_29();
    }
    // 84: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 85: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 86: callc
    if (conditional_code.x) {
        sub_20_29();
    }
    // 87: ifu
    if (uniforms.b[8]) {
        sub_88_92();
    }
    // 92: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 93: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 94: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 95: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 96: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 97: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 98: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 99: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 100: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 101: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 102: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 103: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_88_92() {
    // 88: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 89: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 90: callc
    if (conditional_code.y) {
        sub_20_29();
    }
    // 91: nop
    return false;
}
bool sub_104_128() {
    // 104: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 105: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 106: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 107: call
    {
        sub_6_11();
    }
    // 108: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 109: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 110: call
    {
        sub_6_11();
    }
    // 111: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 112: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 113: callc
    if (conditional_code.x) {
        sub_6_11();
    }
    // 114: ifu
    if (uniforms.b[8]) {
        sub_115_119();
    }
    // 119: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 120: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 121: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 122: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 123: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 124: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 125: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 126: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 127: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_115_119() {
    // 115: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 116: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 117: callc
    if (conditional_code.y) {
        sub_6_11();
    }
    // 118: nop
    return false;
}
bool sub_137_138() {
    // 137: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_139_194() {
    // 139: mov
    reg_tmp0 = uniforms.f[7];
    // 140: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.yzzz));
    // 141: ifu
    if (uniforms.b[2]) {
        sub_142_152();
    } else {
        sub_152_157();
    }
    // 157: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_158_168();
    } else {
        sub_168_184();
    }
    // 184: dp4
    reg_tmp0.x = dot(mul_safe(uniforms.f[86], reg_tmp15), vec4(1.0));
    // 185: dp4
    reg_tmp0.y = dot(mul_safe(uniforms.f[87], reg_tmp15), vec4(1.0));
    // 186: dp4
    reg_tmp0.z = dot(mul_safe(uniforms.f[88], reg_tmp15), vec4(1.0));
    // 187: dp4
    reg_tmp0.w = dot(mul_safe(uniforms.f[89], reg_tmp15), vec4(1.0));
    // 188: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 189: mul
    reg_tmp1.y = (mul_safe(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
    // 190: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 191: ifc
    if (all(conditional_code)) {
        sub_192_193();
    }
    // 193: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_142_152() {
    // 142: mul
    reg_tmp1.x = (mul_safe(uniforms.f[93].wwww, vs_in_reg7.xxxx)).x;
    // 143: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 144: dp4
    reg_tmp7.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 145: dp4
    reg_tmp7.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 146: dp4
    reg_tmp7.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 147: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 148: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 149: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 150: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 151: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_152_157() {
    // 152: mova
    address_registers.x = (ivec2(uniforms.f[93].xxxx)).x;
    // 153: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[25], reg_tmp15), vec4(1.0));
    // 154: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[26], reg_tmp15), vec4(1.0));
    // 155: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[27], reg_tmp15), vec4(1.0));
    // 156: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_158_168() {
    // 158: dp3
    reg_tmp12.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 159: dp3
    reg_tmp12.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 160: dp3
    reg_tmp12.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 161: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 162: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 163: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 164: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 165: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 166: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 167: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_168_184() {
    // 168: ifc
    if (all(conditional_code)) {
        sub_169_179();
    } else {
        sub_179_183();
    }
    // 183: nop
    return false;
}
bool sub_169_179() {
    // 169: dp3
    reg_tmp12.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 170: dp3
    reg_tmp12.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 171: dp3
    reg_tmp12.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 172: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 173: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 174: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 175: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 176: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 177: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 178: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_179_183() {
    // 179: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 180: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 181: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 182: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_192_193() {
    // 192: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_197_214() {
    // 197: mov
    reg_tmp8.xy = (uniforms.f[93].xxxx).xy;
    // 198: mov
    reg_tmp0.y = (uniforms.f[7].wwww).y;
    // 199: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.xyyy));
    // 200: mov
    reg_tmp9.xyz = (uniforms.f[93].xxxx).xyz;
    // 201: mov
    reg_tmp9.w = (uniforms.f[21].wwww).w;
    // 202: ifc
    if (conditional_code.y) {
        sub_203_208();
    }
    // 208: callu
    if (uniforms.b[12]) {
        sub_214_260();
    }
    // 209: callu
    if (uniforms.b[5]) {
        sub_260_270();
    }
    // 210: cmp
    conditional_code = equal(vec2(uniforms.f[93].xxxx), vec2(reg_tmp8.xyyy));
    // 211: ifc
    if (all(conditional_code)) {
        sub_212_213();
    }
    // 213: max
    vs_out_attr3 = max(uniforms.f[93].xxxx, reg_tmp9);
    return false;
}
bool sub_203_208() {
    // 203: mul
    reg_tmp0 = mul_safe(uniforms.f[7].wwww, vs_in_reg3);
    // 204: ifu
    if (uniforms.b[7]) {
        sub_205_206();
    }
    // 206: mul
    reg_tmp9.xyz = (mul_safe(uniforms.f[20].wwww, reg_tmp0.xyzz)).xyz;
    // 207: mov
    reg_tmp8.x = (uniforms.f[93].yyyy).x;
    return false;
}
bool sub_205_206() {
    // 205: mul
    reg_tmp9.w = (mul_safe(reg_tmp9.wwww, reg_tmp0.wwww)).w;
    return false;
}
bool sub_212_213() {
    // 212: mov
    reg_tmp9 = uniforms.f[21];
    return false;
}
bool sub_214_260() {
    // 214: mov
    reg_tmp1 = uniforms.f[20];
    // 215: mov
    reg_tmp2 = uniforms.f[21];
    // 216: mov
    reg_tmp3 = uniforms.f[93].xxxx;
    // 217: loop
    address_registers.z = int(uniforms.i[0].y);
    for (uint loop217 = 0u; loop217 <= uniforms.i[0].x; address_registers.z += int(uniforms.i[0].z), ++loop217) {
        sub_218_259();
    }
    // 259: mov
    reg_tmp8.x = (uniforms.f[93].yyyy).x;
    return false;
}
bool sub_218_259() {
    // 218: mova
    address_registers.x = (ivec2(reg_tmp3)).x;
    // 219: mov
    reg_tmp4.x = (uniforms.f[81 + address_registers.x].wwww).x;
    // 220: mov
    reg_tmp4.y = (uniforms.f[83 + address_registers.x].wwww).y;
    // 221: cmp
    conditional_code = equal(vec2(uniforms.f[93].xyyy), vec2(reg_tmp4.xyyy));
    // 222: ifc
    if (conditional_code.x) {
        sub_223_225();
    } else {
        sub_225_249();
    }
    // 249: cmp
    conditional_code.x = uniforms.f[93].xxxx.x == reg_tmp6.xyyy.x;
    conditional_code.y = uniforms.f[93].xxxx.y < reg_tmp6.xyyy.y;
    // 250: ifc
    if (conditional_code.y) {
        sub_251_258();
    }
    // 258: add
    reg_tmp3 = -uniforms.f[95].wwww + reg_tmp3;
    return false;
}
bool sub_223_225() {
    // 223: dp3
    reg_tmp6.x = dot(vec3(mul_safe(uniforms.f[81 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 224: mov
    reg_tmp6.y = (uniforms.f[93].yyyy).y;
    return false;
}
bool sub_225_249() {
    // 225: add
    reg_tmp4 = uniforms.f[81 + address_registers.x] + -reg_tmp15;
    // 226: mov
    reg_tmp6.y = (uniforms.f[93].yyyy).y;
    // 227: ifc
    if (conditional_code.y) {
        sub_228_233();
    }
    // 233: mov
    reg_tmp5 = uniforms.f[82 + address_registers.x];
    // 234: cmp
    conditional_code = equal(vec2(uniforms.f[93].yyyy), vec2(reg_tmp5.wwww));
    // 235: dp3
    reg_tmp4.w = dot(vec3(mul_safe(reg_tmp4, reg_tmp4)), vec3(1.0));
    // 236: rsq
    reg_tmp4.w = rsq_safe(reg_tmp4.wwww.x);
    // 237: mul
    reg_tmp4 = mul_safe(reg_tmp4, reg_tmp4.wwww);
    // 238: ifc
    if (conditional_code.x) {
        sub_239_248();
    }
    // 248: dp3
    reg_tmp6.x = dot(vec3(mul_safe(reg_tmp14, reg_tmp4)), vec3(1.0));
    return false;
}
bool sub_228_233() {
    // 228: mov
    reg_tmp5.x = (uniforms.f[93].yyyy).x;
    // 229: dp3
    reg_tmp5.z = dot(vec3(mul_safe(reg_tmp4, reg_tmp4)), vec3(1.0));
    // 230: mul
    reg_tmp5.y = (mul_safe(reg_tmp5.zzzz, reg_tmp5.zzzz)).y;
    // 231: dp3
    reg_tmp6.y = dot(vec3(mul_safe(uniforms.f[83 + address_registers.x], reg_tmp5)), vec3(1.0));
    // 232: rcp
    reg_tmp6.y = rcp_safe(reg_tmp6.yyyy.x);
    return false;
}
bool sub_239_248() {
    // 239: dp3
    reg_tmp5.x = dot(vec3(mul_safe(uniforms.f[82 + address_registers.x], -reg_tmp4)), vec3(1.0));
    // 240: slti
    reg_tmp5.y = (vec4(lessThan(reg_tmp5.xxxx,uniforms.f[84 + address_registers.x].yyyy))).y;
    // 241: cmp
    conditional_code = equal(vec2(uniforms.f[93].yyyy), vec2(reg_tmp5.xyyy));
    // 242: ifc
    if (conditional_code.y) {
        sub_243_244();
    } else {
        sub_244_247();
    }
    // 247: mul
    reg_tmp6.y = (mul_safe(reg_tmp6.yyyy, reg_tmp5.xxxx)).y;
    return false;
}
bool sub_243_244() {
    // 243: mov
    reg_tmp5.x = (uniforms.f[93].xxxx).x;
    return false;
}
bool sub_244_247() {
    // 244: log
    reg_tmp5.y = log2(reg_tmp5.xxxx.x);
    // 245: mul
    reg_tmp5.y = (mul_safe(uniforms.f[84 + address_registers.x].xxxx, reg_tmp5.yyyy)).y;
    // 246: exp
    reg_tmp5.x = exp2(reg_tmp5.yyyy.x);
    return false;
}
bool sub_251_258() {
    // 251: max
    reg_tmp6.x = (max(uniforms.f[93].xxxx, reg_tmp6.xxxx)).x;
    // 252: mad
    reg_tmp9.xyz = (fma_safe(reg_tmp1.xyzz, uniforms.f[79 + address_registers.x].xyzz, reg_tmp9.xyzz)).xyz;
    // 253: mul
    reg_tmp4 = mul_safe(uniforms.f[80 + address_registers.x], reg_tmp2);
    // 254: mul
    reg_tmp5.xyz = (mul_safe(reg_tmp6.xxxx, reg_tmp4.xyzz)).xyz;
    // 255: mul
    reg_tmp5.xyz = (mul_safe(reg_tmp6.yyyy, reg_tmp5.xyzz)).xyz;
    // 256: add
    reg_tmp9.xyz = (reg_tmp9.xyzz + reg_tmp5.xyzz).xyz;
    // 257: add
    reg_tmp9.w = (reg_tmp9.wwww + reg_tmp4.wwww).w;
    return false;
}
bool sub_260_270() {
    // 260: dp3
    reg_tmp1 = vec4(dot(vec3(mul_safe(uniforms.f[24], reg_tmp14)), vec3(1.0)));
    // 261: mov
    reg_tmp2 = uniforms.f[24].wwww;
    // 262: mad
    reg_tmp1 = fma_safe(reg_tmp1, reg_tmp2, reg_tmp2);
    // 263: mov
    reg_tmp3 = uniforms.f[22];
    // 264: add
    reg_tmp2 = uniforms.f[23] + -reg_tmp3;
    // 265: mad
    reg_tmp4 = fma_safe(reg_tmp2, reg_tmp1, reg_tmp3);
    // 266: ifu
    if (uniforms.b[6]) {
        sub_267_268();
    }
    // 268: mad
    reg_tmp9.xyz = (fma_safe(reg_tmp4, uniforms.f[21], reg_tmp9)).xyz;
    // 269: mov
    reg_tmp8.x = (uniforms.f[93].yyyy).x;
    return false;
}
bool sub_267_268() {
    // 267: mul
    reg_tmp4 = mul_safe(reg_tmp4, reg_tmp9.wwww);
    return false;
}
bool sub_279_288() {
    // 279: dp3
    reg_tmp5.x = dot(vec3(mul_safe(uniforms.f[90], reg_tmp12.xyzz)), vec3(1.0));
    // 280: dp3
    reg_tmp5.y = dot(vec3(mul_safe(uniforms.f[91], reg_tmp12.xyzz)), vec3(1.0));
    // 281: dp3
    reg_tmp5.z = dot(vec3(mul_safe(uniforms.f[92], reg_tmp12.xyzz)), vec3(1.0));
    // 282: dp4
    reg_tmp4.x = dot(mul_safe(reg_tmp5.xyzz, reg_tmp5.xyzz), vec4(1.0));
    // 283: rsq
    reg_tmp4.x = rsq_safe(reg_tmp4.xxxx.x);
    // 284: mul
    reg_tmp4.xyz = (mul_safe(reg_tmp5.xyzz, reg_tmp4.xxxx)).xyz;
    // 285: mul
    reg_tmp4 = mul_safe(uniforms.f[94].zzzz, reg_tmp4);
    // 286: add
    reg_tmp12 = uniforms.f[94].zzzz + reg_tmp4;
    // 287: mov
    vs_out_attr5 = reg_tmp12;
    return false;
}
bool sub_321_329() {
    // 321: cmp
    conditional_code = equal(vec2(uniforms.f[93].yzzz), vec2(reg_tmp0.xyyy));
    // 322: ifc
    if (all(not(conditional_code))) {
        sub_323_324();
    } else {
        sub_324_328();
    }
    // 328: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_323_324() {
    // 323: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
    return false;
}
bool sub_324_328() {
    // 324: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_325_326();
    } else {
        sub_326_327();
    }
    // 327: nop
    return false;
}
bool sub_325_326() {
    // 325: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
    return false;
}
bool sub_326_327() {
    // 326: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
    return false;
}
bool sub_329_333() {
    // 329: mov
    reg_tmp1.xy = (uniforms.f[94].zzzz).xy;
    // 330: mov
    reg_tmp1.zw = (uniforms.f[93].xxxx).zw;
    // 331: mad
    reg_tmp6 = fma_safe(reg_tmp14, reg_tmp1, reg_tmp1);
    // 332: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_333_4096() {
    // 333: call
    {
        sub_37_197();
    }
    // 334: call
    {
        sub_197_214();
    }
    // 335: call
    {
        sub_339_366();
    }
    // 336: call
    {
        sub_279_288();
    }
    // 337: end
    return true;
}
bool sub_339_366() {
    // 339: mov
    reg_tmp0.xy = (uniforms.f[10].xxxx).xy;
    // 340: ifu
    if (uniforms.b[9]) {
        sub_341_346();
    } else {
        sub_346_365();
    }
    // 365: nop
    return false;
}
bool sub_341_346() {
    // 341: call
    {
        sub_321_329();
    }
    // 342: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[11].xywz, reg_tmp6), vec4(1.0));
    // 343: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[12].xywz, reg_tmp6), vec4(1.0));
    // 344: mov
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    // 345: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_346_365() {
    // 346: cmp
    conditional_code = equal(vec2(uniforms.f[95].xyyy), vec2(reg_tmp0.xyyy));
    // 347: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 348: ifc
    if (all(not(conditional_code))) {
        sub_349_355();
    } else {
        sub_355_364();
    }
    // 364: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_349_355() {
    // 349: mov
    reg_tmp6 = reg_tmp10;
    // 350: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[11], reg_tmp6), vec4(1.0));
    // 351: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[12], reg_tmp6), vec4(1.0));
    // 352: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[13], reg_tmp6), vec4(1.0));
    // 353: mul
    reg_tmp0.xy = (mul_safe(uniforms.f[19].xyyy, reg_tmp3.zzzz)).xy;
    // 354: add
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_355_364() {
    // 355: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_356_360();
    } else {
        sub_360_363();
    }
    // 363: nop
    return false;
}
bool sub_356_360() {
    // 356: call
    {
        sub_366_373();
    }
    // 357: dp3
    reg_tmp3.x = dot(vec3(mul_safe(uniforms.f[11], reg_tmp6)), vec3(1.0));
    // 358: dp3
    reg_tmp3.y = dot(vec3(mul_safe(uniforms.f[12], reg_tmp6)), vec3(1.0));
    // 359: dp3
    reg_tmp3.z = dot(vec3(mul_safe(uniforms.f[13], reg_tmp6)), vec3(1.0));
    return false;
}
bool sub_360_363() {
    // 360: call
    {
        sub_329_333();
    }
    // 361: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[11], reg_tmp6), vec4(1.0));
    // 362: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[12], reg_tmp6), vec4(1.0));
    return false;
}
bool sub_366_373() {
    // 366: mov
    reg_tmp2 = -reg_tmp15;
    // 367: dp3
    reg_tmp2.w = dot(vec3(mul_safe(reg_tmp2, reg_tmp2)), vec3(1.0));
    // 368: rsq
    reg_tmp2.w = rsq_safe(reg_tmp2.wwww.x);
    // 369: mul
    reg_tmp2 = mul_safe(reg_tmp2, reg_tmp2.wwww);
    // 370: dp3
    reg_tmp1 = vec4(dot(vec3(mul_safe(reg_tmp2, reg_tmp14)), vec3(1.0)));
    // 371: add
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    // 372: mad
    reg_tmp6 = fma_safe(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
// reference: CCC00D8626CAC551, AA5284D8354BC7F4
// shader: 8B30, 09998F9B86E3CF69

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: FB35E2F47BA2E1ED, 09998F9B86E3CF69
// program: AA5284D8354BC7F4, 3B3AE026C742C7D5, 09998F9B86E3CF69
// reference: 559575C7FD736416, AA5284D8354BC7F4
// shader: 8B30, 964E0B11E50F8F6E

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: FB35E2F4B7D17575, 964E0B11E50F8F6E
// program: AA5284D8354BC7F4, 3B3AE026C742C7D5, 964E0B11E50F8F6E
// shader: 8B31, 4D9765BCC73533ED

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;
 out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define mul_safe(x, y) mix(x * y, vec4(0.0), isnan(x * y))

float rcp_safe(float x) {
    if (x == 0.0f) return x;
    return 1.0f / x;
}


float rsq_safe(float x) {
    if (x == 0.0f) return x;
    return inversesqrt(x);
}

#define fma_safe(x, y, z) (mul_safe(x, y) + z)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_4096();
bool sub_7_12();
bool sub_12_21();
bool sub_21_34();
bool sub_34_214();
bool sub_40_146();
bool sub_47_76();
bool sub_58_62();
bool sub_76_135();
bool sub_77_109();
bool sub_88_92();
bool sub_109_134();
bool sub_120_124();
bool sub_144_145();
bool sub_146_213();
bool sub_149_159();
bool sub_159_164();
bool sub_165_177();
bool sub_177_202();
bool sub_178_196();
bool sub_196_201();
bool sub_211_212();
bool sub_214_231();
bool sub_231_307();
bool sub_270_290();
bool sub_271_276();
bool sub_276_289();
bool sub_280_283();
bool sub_283_288();
bool sub_290_303();
bool sub_291_296();
bool sub_296_302();
bool sub_307_351();
bool sub_351_378();
bool sub_353_358();
bool sub_358_377();
bool sub_361_367();
bool sub_367_376();
bool sub_368_372();
bool sub_372_375();
bool sub_378_386();
bool sub_380_381();
bool sub_381_385();
bool sub_382_383();
bool sub_383_384();
bool sub_386_393();
bool sub_393_397();
bool sub_397_421();
bool sub_399_403();
bool sub_403_420();
bool sub_404_418();
bool sub_407_414();
bool sub_414_417();
bool sub_418_419();
bool sub_421_437();
bool sub_423_427();
bool sub_427_436();
bool sub_428_434();
bool sub_434_435();

bool exec_shader() {
    sub_0_4096();
    return true;
}

bool sub_0_4096() {
    // 0: call
    {
        sub_34_214();
    }
    // 1: call
    {
        sub_307_351();
    }
    // 2: call
    {
        sub_351_378();
    }
    // 3: call
    {
        sub_397_421();
    }
    // 4: call
    {
        sub_421_437();
    }
    // 5: end
    return true;
}
bool sub_7_12() {
    // 7: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 8: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 9: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 10: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 11: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    return false;
}
bool sub_12_21() {
    // 12: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 13: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 14: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 15: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 16: dp3
    reg_tmp4.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 17: dp3
    reg_tmp4.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 18: dp3
    reg_tmp4.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 19: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 20: mad
    reg_tmp12 = fma_safe(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_21_34() {
    // 21: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 22: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 23: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 24: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 25: dp3
    reg_tmp4.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 26: dp3
    reg_tmp4.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 27: dp3
    reg_tmp4.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 28: dp3
    reg_tmp5.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 29: dp3
    reg_tmp5.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 30: dp3
    reg_tmp5.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 31: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 32: mad
    reg_tmp12 = fma_safe(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    // 33: mad
    reg_tmp11 = fma_safe(reg_tmp1.wwww, reg_tmp5, reg_tmp11);
    return false;
}
bool sub_34_214() {
    // 34: mul
    reg_tmp15.xyz = (mul_safe(uniforms.f[7].xxxx, vs_in_reg0)).xyz;
    // 35: mul
    reg_tmp14.xyz = (mul_safe(uniforms.f[7].yyyy, vs_in_reg1)).xyz;
    // 36: mul
    reg_tmp13.xyz = (mul_safe(uniforms.f[7].zzzz, vs_in_reg2)).xyz;
    // 37: add
    reg_tmp15.xyz = (uniforms.f[6] + reg_tmp15).xyz;
    // 38: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 39: ifu
    if (uniforms.b[1]) {
        sub_40_146();
    } else {
        sub_146_213();
    }
    // 213: nop
    return false;
}
bool sub_40_146() {
    // 40: mov
    reg_tmp0 = uniforms.f[7];
    // 41: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.yzzz));
    // 42: mov
    reg_tmp7 = uniforms.f[93].xxxx;
    // 43: mov
    reg_tmp12 = uniforms.f[93].xxxx;
    // 44: mov
    reg_tmp11 = uniforms.f[93].xxxx;
    // 45: mul
    reg_tmp2 = mul_safe(uniforms.f[93].wwww, vs_in_reg7);
    // 46: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_47_76();
    } else {
        sub_76_135();
    }
    // 135: mov
    vs_out_attr2 = -reg_tmp15;
    // 136: dp4
    reg_tmp0.x = dot(mul_safe(uniforms.f[86], reg_tmp15), vec4(1.0));
    // 137: dp4
    reg_tmp0.y = dot(mul_safe(uniforms.f[87], reg_tmp15), vec4(1.0));
    // 138: dp4
    reg_tmp0.z = dot(mul_safe(uniforms.f[88], reg_tmp15), vec4(1.0));
    // 139: dp4
    reg_tmp0.w = dot(mul_safe(uniforms.f[89], reg_tmp15), vec4(1.0));
    // 140: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 141: mul
    reg_tmp1.y = (mul_safe(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
    // 142: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 143: ifc
    if (all(conditional_code)) {
        sub_144_145();
    }
    // 145: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_47_76() {
    // 47: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 48: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 49: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 50: call
    {
        sub_12_21();
    }
    // 51: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 52: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 53: call
    {
        sub_12_21();
    }
    // 54: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 55: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 56: callc
    if (conditional_code.x) {
        sub_12_21();
    }
    // 57: ifu
    if (uniforms.b[8]) {
        sub_58_62();
    }
    // 62: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 63: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 64: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 65: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 66: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 67: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 68: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 69: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 70: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 71: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 72: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 73: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 74: call
    {
        sub_214_231();
    }
    // 75: nop
    return false;
}
bool sub_58_62() {
    // 58: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 59: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 60: callc
    if (conditional_code.y) {
        sub_12_21();
    }
    // 61: nop
    return false;
}
bool sub_76_135() {
    // 76: ifc
    if (all(conditional_code)) {
        sub_77_109();
    } else {
        sub_109_134();
    }
    // 134: nop
    return false;
}
bool sub_77_109() {
    // 77: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 78: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 79: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 80: call
    {
        sub_21_34();
    }
    // 81: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 82: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 83: call
    {
        sub_21_34();
    }
    // 84: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 85: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 86: callc
    if (conditional_code.x) {
        sub_21_34();
    }
    // 87: ifu
    if (uniforms.b[8]) {
        sub_88_92();
    }
    // 92: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 93: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 94: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 95: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 96: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 97: dp3
    reg_tmp13.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp11)), vec3(1.0));
    // 98: dp3
    reg_tmp13.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp11)), vec3(1.0));
    // 99: dp3
    reg_tmp13.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp11)), vec3(1.0));
    // 100: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 101: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 102: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 103: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 104: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 105: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 106: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 107: call
    {
        sub_231_307();
    }
    // 108: nop
    return false;
}
bool sub_88_92() {
    // 88: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 89: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 90: callc
    if (conditional_code.y) {
        sub_21_34();
    }
    // 91: nop
    return false;
}
bool sub_109_134() {
    // 109: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 110: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 111: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 112: call
    {
        sub_7_12();
    }
    // 113: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 114: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 115: call
    {
        sub_7_12();
    }
    // 116: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 117: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 118: callc
    if (conditional_code.x) {
        sub_7_12();
    }
    // 119: ifu
    if (uniforms.b[8]) {
        sub_120_124();
    }
    // 124: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 125: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 126: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 127: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 128: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 129: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 130: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 131: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 132: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 133: mov
    vs_out_attr1 = uniforms.f[93].xxxx;
    return false;
}
bool sub_120_124() {
    // 120: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 121: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 122: callc
    if (conditional_code.y) {
        sub_7_12();
    }
    // 123: nop
    return false;
}
bool sub_144_145() {
    // 144: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_146_213() {
    // 146: mov
    reg_tmp0 = uniforms.f[7];
    // 147: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.yzzz));
    // 148: ifu
    if (uniforms.b[2]) {
        sub_149_159();
    } else {
        sub_159_164();
    }
    // 164: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_165_177();
    } else {
        sub_177_202();
    }
    // 202: mov
    vs_out_attr2 = -reg_tmp15;
    // 203: dp4
    reg_tmp0.x = dot(mul_safe(uniforms.f[86], reg_tmp15), vec4(1.0));
    // 204: dp4
    reg_tmp0.y = dot(mul_safe(uniforms.f[87], reg_tmp15), vec4(1.0));
    // 205: dp4
    reg_tmp0.z = dot(mul_safe(uniforms.f[88], reg_tmp15), vec4(1.0));
    // 206: dp4
    reg_tmp0.w = dot(mul_safe(uniforms.f[89], reg_tmp15), vec4(1.0));
    // 207: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 208: mul
    reg_tmp1.y = (mul_safe(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
    // 209: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 210: ifc
    if (all(conditional_code)) {
        sub_211_212();
    }
    // 212: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_149_159() {
    // 149: mul
    reg_tmp1.x = (mul_safe(uniforms.f[93].wwww, vs_in_reg7.xxxx)).x;
    // 150: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 151: dp4
    reg_tmp7.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 152: dp4
    reg_tmp7.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 153: dp4
    reg_tmp7.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 154: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 155: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 156: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 157: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 158: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_159_164() {
    // 159: mova
    address_registers.x = (ivec2(uniforms.f[93].xxxx)).x;
    // 160: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[25], reg_tmp15), vec4(1.0));
    // 161: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[26], reg_tmp15), vec4(1.0));
    // 162: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[27], reg_tmp15), vec4(1.0));
    // 163: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_165_177() {
    // 165: dp3
    reg_tmp12.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 166: dp3
    reg_tmp12.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 167: dp3
    reg_tmp12.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 168: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 169: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 170: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 171: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 172: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 173: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 174: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 175: call
    {
        sub_214_231();
    }
    // 176: nop
    return false;
}
bool sub_177_202() {
    // 177: ifc
    if (all(conditional_code)) {
        sub_178_196();
    } else {
        sub_196_201();
    }
    // 201: nop
    return false;
}
bool sub_178_196() {
    // 178: dp3
    reg_tmp12.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 179: dp3
    reg_tmp12.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 180: dp3
    reg_tmp12.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 181: dp3
    reg_tmp11.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 182: dp3
    reg_tmp11.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 183: dp3
    reg_tmp11.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 184: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 185: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 186: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 187: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 188: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 189: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 190: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 191: dp3
    reg_tmp13.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp11)), vec3(1.0));
    // 192: dp3
    reg_tmp13.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp11)), vec3(1.0));
    // 193: dp3
    reg_tmp13.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp11)), vec3(1.0));
    // 194: call
    {
        sub_231_307();
    }
    // 195: nop
    return false;
}
bool sub_196_201() {
    // 196: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 197: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 198: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 199: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 200: mov
    vs_out_attr1 = uniforms.f[93].xxxx;
    return false;
}
bool sub_211_212() {
    // 211: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_214_231() {
    uint jmp_to = 214u;
    while (true) {
        switch (jmp_to) {
        case 214u: {
            // 214: dp3
            reg_tmp6.x = dot(vec3(mul_safe(reg_tmp14, reg_tmp14)), vec3(1.0));
            // 215: dp3
            reg_tmp7.x = dot(vec3(mul_safe(reg_tmp12, reg_tmp12)), vec3(1.0));
            // 216: rsq
            reg_tmp6.x = rsq_safe(reg_tmp6.xxxx.x);
            // 217: rsq
            reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
            // 218: mul
            reg_tmp14.xyz = (mul_safe(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 219: mul
            reg_tmp12.xyz = (mul_safe(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 220: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 221: jmpu
            if (!uniforms.b[15]) {
                { jmp_to = 230u; break; }
            }
            // 222: add
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            // 223: mul
            reg_tmp4 = mul_safe(uniforms.f[94].zzzz, reg_tmp4);
            // 224: cmp
            conditional_code = greaterThanEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp4.xxxx));
            // 225: rsq
            reg_tmp4 = vec4(rsq_safe(reg_tmp4.xxxx.x));
            // 226: mul
            reg_tmp5 = mul_safe(uniforms.f[94].zzzz, reg_tmp14);
            // 227: jmpc
            if (conditional_code.x) {
                { jmp_to = 230u; break; }
            }
            // 228: rcp
            reg_tmp0.z = rcp_safe(reg_tmp4.xxxx.x);
            // 229: mul
            reg_tmp0.xy = (mul_safe(reg_tmp5, reg_tmp4)).xy;
        }
        case 230u: {
            // 230: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_231_307() {
    uint jmp_to = 231u;
    while (true) {
        switch (jmp_to) {
        case 231u: {
            // 231: dp3
            reg_tmp6.x = dot(vec3(mul_safe(reg_tmp14, reg_tmp14)), vec3(1.0));
            // 232: dp3
            reg_tmp7.x = dot(vec3(mul_safe(reg_tmp12, reg_tmp12)), vec3(1.0));
            // 233: rsq
            reg_tmp6.x = rsq_safe(reg_tmp6.xxxx.x);
            // 234: rsq
            reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
            // 235: mul
            reg_tmp14.xyz = (mul_safe(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 236: mul
            reg_tmp12.xyz = (mul_safe(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 237: mul
            reg_tmp13.xyz = (mul_safe(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            // 238: mul
            reg_tmp11.xyz = (mul_safe(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            // 239: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 240: jmpu
            if (!uniforms.b[15]) {
                { jmp_to = 306u; break; }
            }
            // 241: mul
            reg_tmp13.xyz = (mul_safe(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            // 242: mul
            reg_tmp11.xyz = (mul_safe(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            // 243: mul
            reg_tmp5 = mul_safe(reg_tmp14.yzxx, reg_tmp13.zxyy);
            // 244: mad
            reg_tmp5 = fma_safe(-reg_tmp13.yzxx, reg_tmp14.zxyy, reg_tmp5);
            // 245: dp3
            reg_tmp5.w = dot(vec3(mul_safe(reg_tmp5, reg_tmp5)), vec3(1.0));
            // 246: rsq
            reg_tmp5.w = rsq_safe(reg_tmp5.wwww.x);
            // 247: mul
            reg_tmp5 = mul_safe(reg_tmp5, reg_tmp5.wwww);
            // 248: add
            reg_tmp6.w = (reg_tmp14.zzzz + reg_tmp5.yyyy).w;
            // 249: mul
            reg_tmp13 = mul_safe(reg_tmp5.yzxx, reg_tmp14.zxyy);
            // 250: mad
            reg_tmp13 = fma_safe(-reg_tmp14.yzxx, reg_tmp5.zxyy, reg_tmp13);
            // 251: add
            reg_tmp6.w = (reg_tmp13.xxxx + reg_tmp6).w;
            // 252: mov
            reg_tmp13.w = (reg_tmp5.zzzz).w;
            // 253: mov
            reg_tmp5.z = (reg_tmp13.xxxx).z;
            // 254: add
            reg_tmp6.w = (uniforms.f[93].yyyy + reg_tmp6).w;
            // 255: mov
            reg_tmp14.w = (reg_tmp5.xxxx).w;
            // 256: mov
            reg_tmp5.x = (reg_tmp14.zzzz).x;
            // 257: cmp
            conditional_code = lessThan(vec2(uniforms.f[94].yyyy), vec2(reg_tmp6.wwww));
            // 258: mov
            reg_tmp6.x = (uniforms.f[93].yyyy).x;
            // 259: mov
            reg_tmp6.y = (-uniforms.f[93].yyyy).y;
            // 260: jmpc
            if (!conditional_code.x) {
                { jmp_to = 268u; break; }
            }
            // 261: add
            reg_tmp7.xz = (reg_tmp13.wwyy + -reg_tmp14.yyww).xz;
            // 262: add
            reg_tmp7.y = (reg_tmp14.xxxx + -reg_tmp13.zzzz).y;
            // 263: mov
            reg_tmp7.w = (reg_tmp6).w;
            // 264: dp4
            reg_tmp6 = vec4(dot(mul_safe(reg_tmp7, reg_tmp7), vec4(1.0)));
            // 265: rsq
            reg_tmp6 = vec4(rsq_safe(reg_tmp6.xxxx.x));
            // 266: mul
            reg_tmp0 = mul_safe(reg_tmp7, reg_tmp6);
            // 267: jmpu
            if (uniforms.b[0]) {
                { jmp_to = 306u; break; }
            }
        }
        case 268u: {
            // 268: cmp
            conditional_code = greaterThan(vec2(reg_tmp5.zyyy), vec2(reg_tmp5.yxxx));
            // 269: ifc
            if (conditional_code.x) {
                sub_270_290();
            } else {
                sub_290_303();
            }
            // 303: dp4
            reg_tmp6 = vec4(dot(mul_safe(reg_tmp8, reg_tmp8), vec4(1.0)));
            // 304: rsq
            reg_tmp6 = vec4(rsq_safe(reg_tmp6.xxxx.x));
            // 305: mul
            reg_tmp0 = mul_safe(reg_tmp8, reg_tmp6);
        }
        case 306u: {
            // 306: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_270_290() {
    // 270: ifc
    if (conditional_code.y) {
        sub_271_276();
    } else {
        sub_276_289();
    }
    // 289: mov
    reg_tmp8.w = (-reg_tmp8).w;
    return false;
}
bool sub_271_276() {
    // 271: mul
    reg_tmp8 = mul_safe(reg_tmp13.yyzw, reg_tmp6.xxxy);
    // 272: add
    reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
    // 273: add
    reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
    // 274: add
    reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
    // 275: add
    reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
    return false;
}
bool sub_276_289() {
    // 276: cmp
    conditional_code = greaterThan(vec2(reg_tmp5.zzzz), vec2(reg_tmp5.xxxx));
    // 277: mul
    reg_tmp8 = mul_safe(reg_tmp13.yyzw, reg_tmp6.xxxy);
    // 278: add
    reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
    // 279: ifc
    if (conditional_code.x) {
        sub_280_283();
    } else {
        sub_283_288();
    }
    // 288: nop
    return false;
}
bool sub_280_283() {
    // 280: add
    reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
    // 281: add
    reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
    // 282: add
    reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
    return false;
}
bool sub_283_288() {
    // 283: mul
    reg_tmp8 = mul_safe(reg_tmp13.zwwy, reg_tmp6.xxxy);
    // 284: add
    reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
    // 285: add
    reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
    // 286: add
    reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
    // 287: add
    reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
    return false;
}
bool sub_290_303() {
    // 290: ifc
    if (conditional_code.y) {
        sub_291_296();
    } else {
        sub_296_302();
    }
    // 302: nop
    return false;
}
bool sub_291_296() {
    // 291: mul
    reg_tmp8 = mul_safe(reg_tmp13.yywz, reg_tmp6.xxxy);
    // 292: add
    reg_tmp8.y = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).y;
    // 293: add
    reg_tmp9 = reg_tmp5.yyyy + -reg_tmp5.xxxx;
    // 294: add
    reg_tmp8.xzw = (reg_tmp8 + reg_tmp14.wwyx).xzw;
    // 295: add
    reg_tmp8.y = (reg_tmp9 + reg_tmp8).y;
    return false;
}
bool sub_296_302() {
    // 296: mul
    reg_tmp8 = mul_safe(reg_tmp13.zwwy, reg_tmp6.xxxy);
    // 297: add
    reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
    // 298: add
    reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
    // 299: add
    reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
    // 300: add
    reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
    // 301: mov
    reg_tmp8.w = (-reg_tmp8).w;
    return false;
}
bool sub_307_351() {
    // 307: mov
    reg_tmp1.xyz = (uniforms.f[93].xxyx).xyz;
    // 308: dp3
    reg_tmp8.x = dot(vec3(mul_safe(uniforms.f[0], reg_tmp12.xyzz)), vec3(1.0));
    // 309: dp3
    reg_tmp8.y = dot(vec3(mul_safe(uniforms.f[1], reg_tmp12.xyzz)), vec3(1.0));
    // 310: dp3
    reg_tmp8.z = dot(vec3(mul_safe(uniforms.f[2], reg_tmp12.xyzz)), vec3(1.0));
    // 311: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[90], reg_tmp8.xyzz)), vec3(1.0));
    // 312: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[91], reg_tmp8.xyzz)), vec3(1.0));
    // 313: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[92], reg_tmp8.xyzz)), vec3(1.0));
    // 314: mov
    reg_tmp14.w = (uniforms.f[93].xxxx).w;
    // 315: mov
    reg_tmp8 = reg_tmp14;
    // 316: dp4
    reg_tmp14.x = dot(mul_safe(reg_tmp8, reg_tmp8), vec4(1.0));
    // 317: rsq
    reg_tmp14.x = rsq_safe(reg_tmp14.xxxx.x);
    // 318: mul
    reg_tmp14 = mul_safe(reg_tmp8, reg_tmp14.xxxx);
    // 319: mov
    reg_tmp0 = uniforms.f[23];
    // 320: dp3
    reg_tmp8.x = dot(vec3(mul_safe(uniforms.f[0], reg_tmp0.xyzz)), vec3(1.0));
    // 321: dp3
    reg_tmp8.y = dot(vec3(mul_safe(uniforms.f[1], reg_tmp0.xyzz)), vec3(1.0));
    // 322: dp3
    reg_tmp8.z = dot(vec3(mul_safe(uniforms.f[2], reg_tmp0.xyzz)), vec3(1.0));
    // 323: dp3
    reg_tmp6.x = dot(vec3(mul_safe(uniforms.f[90], reg_tmp8.xyzz)), vec3(1.0));
    // 324: dp3
    reg_tmp6.y = dot(vec3(mul_safe(uniforms.f[91], reg_tmp8.xyzz)), vec3(1.0));
    // 325: dp3
    reg_tmp6.z = dot(vec3(mul_safe(uniforms.f[92], reg_tmp8.xyzz)), vec3(1.0));
    // 326: add
    reg_tmp8.xyz = (reg_tmp6.xyzz + reg_tmp1.xyzz).xyz;
    // 327: mov
    reg_tmp8.w = (uniforms.f[93].xxxx).w;
    // 328: dp4
    reg_tmp0.x = dot(mul_safe(reg_tmp8, reg_tmp8), vec4(1.0));
    // 329: rsq
    reg_tmp0.x = rsq_safe(reg_tmp0.xxxx.x);
    // 330: mul
    reg_tmp0 = mul_safe(reg_tmp8, reg_tmp0.xxxx);
    // 331: dp3
    reg_tmp8.x = dot(vec3(mul_safe(reg_tmp14.xyzz, -reg_tmp6)), vec3(1.0));
    // 332: dp3
    reg_tmp8.y = dot(vec3(mul_safe(reg_tmp1.xyzz, -reg_tmp6)), vec3(1.0));
    // 333: max
    reg_tmp8 = max(uniforms.f[93].xxxx, reg_tmp8);
    // 334: mul
    reg_tmp2.y = (mul_safe(reg_tmp8.xxxx, reg_tmp8.yyyy)).y;
    // 335: dp3
    reg_tmp9.z = dot(vec3(mul_safe(reg_tmp14.xyzz, reg_tmp0)), vec3(1.0));
    // 336: max
    reg_tmp9.z = (max(uniforms.f[93].xxxx, reg_tmp9.zzzz)).z;
    // 337: min
    reg_tmp9.z = (min(uniforms.f[93].yyyy, reg_tmp9.zzzz)).z;
    // 338: log
    reg_tmp9.z = log2(reg_tmp9.zzzz.x);
    // 339: mul
    reg_tmp9.z = (mul_safe(uniforms.f[22].zzzz, reg_tmp9.zzzz)).z;
    // 340: exp
    reg_tmp9.z = exp2(reg_tmp9.zzzz.x);
    // 341: mul
    reg_tmp2.z = (mul_safe(uniforms.f[22].wwww, reg_tmp9.zzzz)).z;
    // 342: dp3
    reg_tmp9.x = dot(vec3(mul_safe(reg_tmp14, reg_tmp1)), vec3(1.0));
    // 343: max
    reg_tmp9.x = (max(uniforms.f[93].xxxx, reg_tmp9.xxxx)).x;
    // 344: min
    reg_tmp9.x = (min(uniforms.f[93].yyyy, reg_tmp9.xxxx)).x;
    // 345: add
    reg_tmp9.x = (uniforms.f[93].yyyy + -reg_tmp9.xxxx).x;
    // 346: log
    reg_tmp9.x = log2(reg_tmp9.xxxx.x);
    // 347: mul
    reg_tmp9.x = (mul_safe(uniforms.f[22].xxxx, reg_tmp9.xxxx)).x;
    // 348: exp
    reg_tmp9.x = exp2(reg_tmp9.xxxx.x);
    // 349: mul
    reg_tmp2.w = (mul_safe(uniforms.f[22].yyyy, reg_tmp9.xxxx)).w;
    // 350: mov
    vs_out_attr3 = reg_tmp2;
    return false;
}
bool sub_351_378() {
    // 351: mov
    reg_tmp0.xy = (uniforms.f[10].xxxx).xy;
    // 352: ifu
    if (uniforms.b[9]) {
        sub_353_358();
    } else {
        sub_358_377();
    }
    // 377: nop
    return false;
}
bool sub_353_358() {
    // 353: call
    {
        sub_378_386();
    }
    // 354: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[11].xywz, reg_tmp6), vec4(1.0));
    // 355: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[12].xywz, reg_tmp6), vec4(1.0));
    // 356: mov
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    // 357: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_358_377() {
    // 358: cmp
    conditional_code = equal(vec2(uniforms.f[95].xyyy), vec2(reg_tmp0.xyyy));
    // 359: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 360: ifc
    if (all(not(conditional_code))) {
        sub_361_367();
    } else {
        sub_367_376();
    }
    // 376: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_361_367() {
    // 361: mov
    reg_tmp6 = reg_tmp10;
    // 362: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[11], reg_tmp6), vec4(1.0));
    // 363: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[12], reg_tmp6), vec4(1.0));
    // 364: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[13], reg_tmp6), vec4(1.0));
    // 365: mul
    reg_tmp0.xy = (mul_safe(uniforms.f[19].xyyy, reg_tmp3.zzzz)).xy;
    // 366: add
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_367_376() {
    // 367: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_368_372();
    } else {
        sub_372_375();
    }
    // 375: nop
    return false;
}
bool sub_368_372() {
    // 368: call
    {
        sub_386_393();
    }
    // 369: dp3
    reg_tmp3.x = dot(vec3(mul_safe(uniforms.f[11], reg_tmp6)), vec3(1.0));
    // 370: dp3
    reg_tmp3.y = dot(vec3(mul_safe(uniforms.f[12], reg_tmp6)), vec3(1.0));
    // 371: dp3
    reg_tmp3.z = dot(vec3(mul_safe(uniforms.f[13], reg_tmp6)), vec3(1.0));
    return false;
}
bool sub_372_375() {
    // 372: call
    {
        sub_393_397();
    }
    // 373: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[11], reg_tmp6), vec4(1.0));
    // 374: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[12], reg_tmp6), vec4(1.0));
    return false;
}
bool sub_378_386() {
    // 378: cmp
    conditional_code = equal(vec2(uniforms.f[93].yzzz), vec2(reg_tmp0.xyyy));
    // 379: ifc
    if (all(not(conditional_code))) {
        sub_380_381();
    } else {
        sub_381_385();
    }
    // 385: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_380_381() {
    // 380: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
    return false;
}
bool sub_381_385() {
    // 381: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_382_383();
    } else {
        sub_383_384();
    }
    // 384: nop
    return false;
}
bool sub_382_383() {
    // 382: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
    return false;
}
bool sub_383_384() {
    // 383: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
    return false;
}
bool sub_386_393() {
    // 386: mov
    reg_tmp2 = -reg_tmp15;
    // 387: dp3
    reg_tmp2.w = dot(vec3(mul_safe(reg_tmp2, reg_tmp2)), vec3(1.0));
    // 388: rsq
    reg_tmp2.w = rsq_safe(reg_tmp2.wwww.x);
    // 389: mul
    reg_tmp2 = mul_safe(reg_tmp2, reg_tmp2.wwww);
    // 390: dp3
    reg_tmp1 = vec4(dot(vec3(mul_safe(reg_tmp2, reg_tmp14)), vec3(1.0)));
    // 391: add
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    // 392: mad
    reg_tmp6 = fma_safe(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_393_397() {
    // 393: mov
    reg_tmp1.xy = (uniforms.f[94].zzzz).xy;
    // 394: mov
    reg_tmp1.zw = (uniforms.f[93].xxxx).zw;
    // 395: mad
    reg_tmp6 = fma_safe(reg_tmp14, reg_tmp1, reg_tmp1);
    // 396: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_397_421() {
    // 397: mov
    reg_tmp0.xy = (uniforms.f[10].yyyy).xy;
    // 398: ifu
    if (uniforms.b[10]) {
        sub_399_403();
    } else {
        sub_403_420();
    }
    // 420: nop
    return false;
}
bool sub_399_403() {
    // 399: call
    {
        sub_378_386();
    }
    // 400: dp4
    reg_tmp4.x = dot(mul_safe(uniforms.f[14].xywz, reg_tmp6), vec4(1.0));
    // 401: dp4
    reg_tmp4.y = dot(mul_safe(uniforms.f[15].xywz, reg_tmp6), vec4(1.0));
    // 402: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_403_420() {
    // 403: ifu
    if (uniforms.b[13]) {
        sub_404_418();
    } else {
        sub_418_419();
    }
    // 419: nop
    return false;
}
bool sub_404_418() {
    // 404: cmp
    conditional_code = equal(vec2(uniforms.f[95].xyyy), vec2(reg_tmp0.xyyy));
    // 405: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 406: ifc
    if (all(not(conditional_code))) {
        sub_407_414();
    } else {
        sub_414_417();
    }
    // 417: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_407_414() {
    // 407: mov
    reg_tmp6 = reg_tmp10;
    // 408: dp4
    reg_tmp4.x = dot(mul_safe(uniforms.f[14], reg_tmp6), vec4(1.0));
    // 409: dp4
    reg_tmp4.y = dot(mul_safe(uniforms.f[15], reg_tmp6), vec4(1.0));
    // 410: dp4
    reg_tmp4.z = dot(mul_safe(uniforms.f[16], reg_tmp6), vec4(1.0));
    // 411: rcp
    reg_tmp6.w = rcp_safe(reg_tmp4.zzzz.x);
    // 412: mul
    reg_tmp4.xy = (mul_safe(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    // 413: add
    reg_tmp4.xy = (uniforms.f[19].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_414_417() {
    // 414: call
    {
        sub_393_397();
    }
    // 415: dp4
    reg_tmp4.x = dot(mul_safe(uniforms.f[14], reg_tmp6), vec4(1.0));
    // 416: dp4
    reg_tmp4.y = dot(mul_safe(uniforms.f[15], reg_tmp6), vec4(1.0));
    return false;
}
bool sub_418_419() {
    // 418: mov
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_421_437() {
    // 421: mov
    reg_tmp0.xy = (uniforms.f[10].zzzz).xy;
    // 422: ifu
    if (uniforms.b[11]) {
        sub_423_427();
    } else {
        sub_427_436();
    }
    // 436: nop
    return false;
}
bool sub_423_427() {
    // 423: call
    {
        sub_378_386();
    }
    // 424: dp4
    reg_tmp5.x = dot(mul_safe(uniforms.f[17].xywz, reg_tmp6), vec4(1.0));
    // 425: dp4
    reg_tmp5.y = dot(mul_safe(uniforms.f[18].xywz, reg_tmp6), vec4(1.0));
    // 426: mov
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_427_436() {
    // 427: ifu
    if (uniforms.b[14]) {
        sub_428_434();
    } else {
        sub_434_435();
    }
    // 435: nop
    return false;
}
bool sub_428_434() {
    // 428: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 429: mov
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    // 430: call
    {
        sub_393_397();
    }
    // 431: dp4
    reg_tmp5.x = dot(mul_safe(uniforms.f[17], reg_tmp6), vec4(1.0));
    // 432: dp4
    reg_tmp5.y = dot(mul_safe(uniforms.f[18], reg_tmp6), vec4(1.0));
    // 433: mov
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_434_435() {
    // 434: mov
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
// reference: 441121A8FA898B18, 4D9765BCC73533ED
// shader: 8B30, CB541D02F0C32C04

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(light_vector, normal)));
refl_value.g = (lut_scale_rg * LookupLightingLUTSigned(5, dot(light_vector, normal)));
refl_value.b = (lut_scale_rb * LookupLightingLUTSigned(4, dot(light_vector, normal)));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((secondary_fragment_color.r) * (1.0 - const_color[0].a) + (secondary_fragment_color.b) * (1.0 - (1.0 - const_color[0].a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((secondary_fragment_color.ggg) * (last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) + (texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a) * (const_color[5].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 59FA65499FEF8E4A, CB541D02F0C32C04
// program: 4D9765BCC73533ED, AD7922A63ED54CA7, CB541D02F0C32C04
// reference: DD4459E921302A5F, 4D9765BCC73533ED
// reference: 09A37E958BDC1BB4, 7F132D830BF35BC2
// reference: 90F606D45065BAF3, 7F132D830BF35BC2
// shader: 8B30, C32574EA415A8ECF

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((vec3(1.0) - texcolor0.rrr) - (vec3(1.0) - texcolor1.rrr), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((1.0 - texcolor0.r) - (1.0 - texcolor2.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0 * 4.0, alpha_output_0 * 4.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) + (last_tex_env_out.aaa), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1 * 4.0, alpha_output_1 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2 * 4.0, alpha_output_2 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp(min((last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(1.0)) * (vec3(1.0) - texcolor0.rrr), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((vec3(1.0) - last_tex_env_out.rgb) + (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((1.0 - last_tex_env_out.r) + (const_color[4].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 1EC8268EE4436578, C32574EA415A8ECF
// program: 0000000000000000, 0000000000000000, C32574EA415A8ECF
// reference: 3CD6F2551D6B0AE1, EC7233A0BD4CF3D2
// reference: A5838A14C6D2ABA6, EC7233A0BD4CF3D2
// reference: 205C35B20C6BE757, AA5284D8354BC7F4
// reference: B9094DF3D7D24610, AA5284D8354BC7F4
// reference: 59FA6549ED5F5786, CB541D02F0C32C04
// shader: 8B30, E712D1F015FA0270

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((vec3(1.0) - texcolor0.rrr) - (vec3(1.0) - texcolor1.rrr), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((1.0 - texcolor0.r) - (1.0 - texcolor2.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0 * 4.0, alpha_output_0 * 4.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) + (last_tex_env_out.aaa), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1 * 4.0, alpha_output_1 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2 * 4.0, alpha_output_2 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((texcolor0.rgb) * (const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((texcolor0.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((vec3(1.0) - texcolor0.rgb) * (const_color[4].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((1.0 - texcolor0.a) * (const_color[4].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 63E9A8D441F1146D, E712D1F015FA0270
// program: EC7233A0BD4CF3D2, 5D764F9A6220D694, E712D1F015FA0270
// shader: 8B30, ED7F62B87BCBA8C3

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((vec3(1.0) - texcolor0.rrr) - (vec3(1.0) - texcolor1.rrr), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((1.0 - texcolor0.r) - (1.0 - texcolor2.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0 * 4.0, alpha_output_0 * 4.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) + (last_tex_env_out.aaa), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1 * 4.0, alpha_output_1 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2 * 4.0, alpha_output_2 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((vec3(1.0) - texcolor0.rgb) * (const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((texcolor0.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((texcolor0.rgb) * (const_color[4].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((1.0 - texcolor0.a) * (const_color[4].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 109B468541F1146D, ED7F62B87BCBA8C3
// program: EC7233A0BD4CF3D2, 5D764F9A6220D694, ED7F62B87BCBA8C3
// shader: 8B30, 10ADC50FC532FE6E

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp(min((texcolor0.rrr) + (texcolor0.ggg), vec3(1.0)) * (const_color[0].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor0.bbb) * (const_color[1].aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (vec3(1.0) - const_color[2].aaa) + (const_color[2].rgb) * (vec3(1.0) - (vec3(1.0) - const_color[2].aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((texcolor0.rgb) * (vec3(1.0) - const_color[4].aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (vec3(1.0) - const_color[4].aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: ABF0C5439B17931E, 10ADC50FC532FE6E
// program: 7F132D830BF35BC2, AD7922A63ED54CA7, 10ADC50FC532FE6E
// shader: 8B30, 81D5ADAAF3D0CA91

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp(min((texcolor0.rrr) + (texcolor0.ggg), vec3(1.0)) * (const_color[0].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor0.bbb) * (const_color[1].aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (vec3(1.0) - const_color[2].aaa) + (const_color[2].rgb) * (vec3(1.0) - (vec3(1.0) - const_color[2].aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb) * (vec3(1.0) - texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a) * (1.0 - texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (texcolor0.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (texcolor0.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: F2D2CEC25BAE6BF2, 81D5ADAAF3D0CA91
// program: EC7233A0BD4CF3D2, 5D764F9A6220D694, 81D5ADAAF3D0CA91
// shader: 8B30, CE59663341BA1DD1

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((vec3(1.0) - texcolor0.rrr) - (vec3(1.0) - texcolor1.rrr), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((1.0 - texcolor0.r) - (1.0 - texcolor2.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0 * 4.0, alpha_output_0 * 4.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) + (last_tex_env_out.aaa), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1 * 4.0, alpha_output_1 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2 * 4.0, alpha_output_2 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((vec3(1.0) - texcolor0.rgb) * (const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((texcolor0.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((texcolor0.rgb) * (const_color[4].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((1.0 - texcolor0.a) * (const_color[4].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 9D26449B848B047A, CE59663341BA1DD1
// program: 0000000000000000, 0000000000000000, CE59663341BA1DD1
// shader: 8B31, CD1237CA557B3805

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define mul_safe(x, y) mix(x * y, vec4(0.0), isnan(x * y))

float rcp_safe(float x) {
    if (x == 0.0f) return x;
    return 1.0f / x;
}


float rsq_safe(float x) {
    if (x == 0.0f) return x;
    return inversesqrt(x);
}

#define fma_safe(x, y, z) (mul_safe(x, y) + z)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_4096();
bool sub_6_11();
bool sub_11_20();
bool sub_20_29();
bool sub_37_197();
bool sub_42_139();
bool sub_48_76();
bool sub_59_63();
bool sub_76_129();
bool sub_77_104();
bool sub_88_92();
bool sub_104_128();
bool sub_115_119();
bool sub_137_138();
bool sub_139_194();
bool sub_142_152();
bool sub_152_157();
bool sub_158_168();
bool sub_168_184();
bool sub_169_179();
bool sub_179_183();
bool sub_192_193();
bool sub_197_214();
bool sub_203_208();
bool sub_205_206();
bool sub_212_213();
bool sub_214_260();
bool sub_218_259();
bool sub_223_225();
bool sub_225_249();
bool sub_228_233();
bool sub_239_248();
bool sub_243_244();
bool sub_244_247();
bool sub_251_258();
bool sub_260_270();
bool sub_267_268();
bool sub_270_279();
bool sub_297_321();
bool sub_299_303();
bool sub_303_320();
bool sub_304_318();
bool sub_307_314();
bool sub_314_317();
bool sub_318_319();
bool sub_321_329();
bool sub_323_324();
bool sub_324_328();
bool sub_325_326();
bool sub_326_327();
bool sub_329_333();

bool exec_shader() {
    sub_0_4096();
    return true;
}

bool sub_0_4096() {
    // 0: call
    {
        sub_37_197();
    }
    // 1: call
    {
        sub_197_214();
    }
    // 2: call
    {
        sub_270_279();
    }
    // 3: call
    {
        sub_297_321();
    }
    // 4: end
    return true;
}
bool sub_6_11() {
    // 6: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 7: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 8: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 9: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 10: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    return false;
}
bool sub_11_20() {
    // 11: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 12: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 13: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 14: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 15: dp3
    reg_tmp4.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 16: dp3
    reg_tmp4.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 17: dp3
    reg_tmp4.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 18: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 19: mad
    reg_tmp12 = fma_safe(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_20_29() {
    // 20: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 21: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 22: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 23: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 24: dp3
    reg_tmp4.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 25: dp3
    reg_tmp4.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 26: dp3
    reg_tmp4.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 27: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 28: mad
    reg_tmp12 = fma_safe(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_37_197() {
    // 37: mul
    reg_tmp15.xyz = (mul_safe(uniforms.f[7].xxxx, vs_in_reg0)).xyz;
    // 38: mul
    reg_tmp14.xyz = (mul_safe(uniforms.f[7].yyyy, vs_in_reg1)).xyz;
    // 39: add
    reg_tmp15.xyz = (uniforms.f[6] + reg_tmp15).xyz;
    // 40: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 41: ifu
    if (uniforms.b[1]) {
        sub_42_139();
    } else {
        sub_139_194();
    }
    // 194: nop
    // 195: mov
    vs_out_attr1 = uniforms.f[93].xxxx;
    // 196: mov
    vs_out_attr2 = uniforms.f[93].xxxx;
    return false;
}
bool sub_42_139() {
    // 42: mov
    reg_tmp0 = uniforms.f[7];
    // 43: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.yzzz));
    // 44: mov
    reg_tmp7 = uniforms.f[93].xxxx;
    // 45: mov
    reg_tmp12 = uniforms.f[93].xxxx;
    // 46: mul
    reg_tmp2 = mul_safe(uniforms.f[93].wwww, vs_in_reg7);
    // 47: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_48_76();
    } else {
        sub_76_129();
    }
    // 129: dp4
    reg_tmp0.x = dot(mul_safe(uniforms.f[86], reg_tmp15), vec4(1.0));
    // 130: dp4
    reg_tmp0.y = dot(mul_safe(uniforms.f[87], reg_tmp15), vec4(1.0));
    // 131: dp4
    reg_tmp0.z = dot(mul_safe(uniforms.f[88], reg_tmp15), vec4(1.0));
    // 132: dp4
    reg_tmp0.w = dot(mul_safe(uniforms.f[89], reg_tmp15), vec4(1.0));
    // 133: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 134: mul
    reg_tmp1.y = (mul_safe(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
    // 135: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 136: ifc
    if (all(conditional_code)) {
        sub_137_138();
    }
    // 138: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_48_76() {
    // 48: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 49: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 50: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 51: call
    {
        sub_11_20();
    }
    // 52: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 53: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 54: call
    {
        sub_11_20();
    }
    // 55: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 56: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 57: callc
    if (conditional_code.x) {
        sub_11_20();
    }
    // 58: ifu
    if (uniforms.b[8]) {
        sub_59_63();
    }
    // 63: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 64: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 65: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 66: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 67: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 68: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 69: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 70: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 71: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 72: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 73: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 74: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 75: nop
    return false;
}
bool sub_59_63() {
    // 59: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 60: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 61: callc
    if (conditional_code.y) {
        sub_11_20();
    }
    // 62: nop
    return false;
}
bool sub_76_129() {
    // 76: ifc
    if (all(conditional_code)) {
        sub_77_104();
    } else {
        sub_104_128();
    }
    // 128: nop
    return false;
}
bool sub_77_104() {
    // 77: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 78: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 79: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 80: call
    {
        sub_20_29();
    }
    // 81: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 82: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 83: call
    {
        sub_20_29();
    }
    // 84: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 85: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 86: callc
    if (conditional_code.x) {
        sub_20_29();
    }
    // 87: ifu
    if (uniforms.b[8]) {
        sub_88_92();
    }
    // 92: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 93: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 94: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 95: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 96: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 97: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 98: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 99: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 100: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 101: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 102: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 103: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_88_92() {
    // 88: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 89: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 90: callc
    if (conditional_code.y) {
        sub_20_29();
    }
    // 91: nop
    return false;
}
bool sub_104_128() {
    // 104: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 105: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 106: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 107: call
    {
        sub_6_11();
    }
    // 108: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 109: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 110: call
    {
        sub_6_11();
    }
    // 111: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 112: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 113: callc
    if (conditional_code.x) {
        sub_6_11();
    }
    // 114: ifu
    if (uniforms.b[8]) {
        sub_115_119();
    }
    // 119: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 120: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 121: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 122: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 123: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 124: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 125: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 126: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 127: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_115_119() {
    // 115: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 116: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 117: callc
    if (conditional_code.y) {
        sub_6_11();
    }
    // 118: nop
    return false;
}
bool sub_137_138() {
    // 137: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_139_194() {
    // 139: mov
    reg_tmp0 = uniforms.f[7];
    // 140: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.yzzz));
    // 141: ifu
    if (uniforms.b[2]) {
        sub_142_152();
    } else {
        sub_152_157();
    }
    // 157: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_158_168();
    } else {
        sub_168_184();
    }
    // 184: dp4
    reg_tmp0.x = dot(mul_safe(uniforms.f[86], reg_tmp15), vec4(1.0));
    // 185: dp4
    reg_tmp0.y = dot(mul_safe(uniforms.f[87], reg_tmp15), vec4(1.0));
    // 186: dp4
    reg_tmp0.z = dot(mul_safe(uniforms.f[88], reg_tmp15), vec4(1.0));
    // 187: dp4
    reg_tmp0.w = dot(mul_safe(uniforms.f[89], reg_tmp15), vec4(1.0));
    // 188: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 189: mul
    reg_tmp1.y = (mul_safe(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
    // 190: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 191: ifc
    if (all(conditional_code)) {
        sub_192_193();
    }
    // 193: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_142_152() {
    // 142: mul
    reg_tmp1.x = (mul_safe(uniforms.f[93].wwww, vs_in_reg7.xxxx)).x;
    // 143: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 144: dp4
    reg_tmp7.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 145: dp4
    reg_tmp7.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 146: dp4
    reg_tmp7.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 147: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 148: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 149: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 150: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 151: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_152_157() {
    // 152: mova
    address_registers.x = (ivec2(uniforms.f[93].xxxx)).x;
    // 153: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[25], reg_tmp15), vec4(1.0));
    // 154: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[26], reg_tmp15), vec4(1.0));
    // 155: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[27], reg_tmp15), vec4(1.0));
    // 156: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_158_168() {
    // 158: dp3
    reg_tmp12.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 159: dp3
    reg_tmp12.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 160: dp3
    reg_tmp12.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 161: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 162: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 163: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 164: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 165: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 166: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 167: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_168_184() {
    // 168: ifc
    if (all(conditional_code)) {
        sub_169_179();
    } else {
        sub_179_183();
    }
    // 183: nop
    return false;
}
bool sub_169_179() {
    // 169: dp3
    reg_tmp12.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 170: dp3
    reg_tmp12.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 171: dp3
    reg_tmp12.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 172: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 173: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 174: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 175: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 176: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 177: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 178: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_179_183() {
    // 179: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 180: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 181: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 182: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_192_193() {
    // 192: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_197_214() {
    // 197: mov
    reg_tmp8.xy = (uniforms.f[93].xxxx).xy;
    // 198: mov
    reg_tmp0.y = (uniforms.f[7].wwww).y;
    // 199: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.xyyy));
    // 200: mov
    reg_tmp9.xyz = (uniforms.f[93].xxxx).xyz;
    // 201: mov
    reg_tmp9.w = (uniforms.f[21].wwww).w;
    // 202: ifc
    if (conditional_code.y) {
        sub_203_208();
    }
    // 208: callu
    if (uniforms.b[12]) {
        sub_214_260();
    }
    // 209: callu
    if (uniforms.b[5]) {
        sub_260_270();
    }
    // 210: cmp
    conditional_code = equal(vec2(uniforms.f[93].xxxx), vec2(reg_tmp8.xyyy));
    // 211: ifc
    if (all(conditional_code)) {
        sub_212_213();
    }
    // 213: max
    vs_out_attr3 = max(uniforms.f[93].xxxx, reg_tmp9);
    return false;
}
bool sub_203_208() {
    // 203: mul
    reg_tmp0 = mul_safe(uniforms.f[7].wwww, vs_in_reg3);
    // 204: ifu
    if (uniforms.b[7]) {
        sub_205_206();
    }
    // 206: mul
    reg_tmp9.xyz = (mul_safe(uniforms.f[20].wwww, reg_tmp0.xyzz)).xyz;
    // 207: mov
    reg_tmp8.x = (uniforms.f[93].yyyy).x;
    return false;
}
bool sub_205_206() {
    // 205: mul
    reg_tmp9.w = (mul_safe(reg_tmp9.wwww, reg_tmp0.wwww)).w;
    return false;
}
bool sub_212_213() {
    // 212: mov
    reg_tmp9 = uniforms.f[21];
    return false;
}
bool sub_214_260() {
    // 214: mov
    reg_tmp1 = uniforms.f[20];
    // 215: mov
    reg_tmp2 = uniforms.f[21];
    // 216: mov
    reg_tmp3 = uniforms.f[93].xxxx;
    // 217: loop
    address_registers.z = int(uniforms.i[0].y);
    for (uint loop217 = 0u; loop217 <= uniforms.i[0].x; address_registers.z += int(uniforms.i[0].z), ++loop217) {
        sub_218_259();
    }
    // 259: mov
    reg_tmp8.x = (uniforms.f[93].yyyy).x;
    return false;
}
bool sub_218_259() {
    // 218: mova
    address_registers.x = (ivec2(reg_tmp3)).x;
    // 219: mov
    reg_tmp4.x = (uniforms.f[81 + address_registers.x].wwww).x;
    // 220: mov
    reg_tmp4.y = (uniforms.f[83 + address_registers.x].wwww).y;
    // 221: cmp
    conditional_code = equal(vec2(uniforms.f[93].xyyy), vec2(reg_tmp4.xyyy));
    // 222: ifc
    if (conditional_code.x) {
        sub_223_225();
    } else {
        sub_225_249();
    }
    // 249: cmp
    conditional_code.x = uniforms.f[93].xxxx.x == reg_tmp6.xyyy.x;
    conditional_code.y = uniforms.f[93].xxxx.y < reg_tmp6.xyyy.y;
    // 250: ifc
    if (conditional_code.y) {
        sub_251_258();
    }
    // 258: add
    reg_tmp3 = -uniforms.f[95].wwww + reg_tmp3;
    return false;
}
bool sub_223_225() {
    // 223: dp3
    reg_tmp6.x = dot(vec3(mul_safe(uniforms.f[81 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 224: mov
    reg_tmp6.y = (uniforms.f[93].yyyy).y;
    return false;
}
bool sub_225_249() {
    // 225: add
    reg_tmp4 = uniforms.f[81 + address_registers.x] + -reg_tmp15;
    // 226: mov
    reg_tmp6.y = (uniforms.f[93].yyyy).y;
    // 227: ifc
    if (conditional_code.y) {
        sub_228_233();
    }
    // 233: mov
    reg_tmp5 = uniforms.f[82 + address_registers.x];
    // 234: cmp
    conditional_code = equal(vec2(uniforms.f[93].yyyy), vec2(reg_tmp5.wwww));
    // 235: dp3
    reg_tmp4.w = dot(vec3(mul_safe(reg_tmp4, reg_tmp4)), vec3(1.0));
    // 236: rsq
    reg_tmp4.w = rsq_safe(reg_tmp4.wwww.x);
    // 237: mul
    reg_tmp4 = mul_safe(reg_tmp4, reg_tmp4.wwww);
    // 238: ifc
    if (conditional_code.x) {
        sub_239_248();
    }
    // 248: dp3
    reg_tmp6.x = dot(vec3(mul_safe(reg_tmp14, reg_tmp4)), vec3(1.0));
    return false;
}
bool sub_228_233() {
    // 228: mov
    reg_tmp5.x = (uniforms.f[93].yyyy).x;
    // 229: dp3
    reg_tmp5.z = dot(vec3(mul_safe(reg_tmp4, reg_tmp4)), vec3(1.0));
    // 230: mul
    reg_tmp5.y = (mul_safe(reg_tmp5.zzzz, reg_tmp5.zzzz)).y;
    // 231: dp3
    reg_tmp6.y = dot(vec3(mul_safe(uniforms.f[83 + address_registers.x], reg_tmp5)), vec3(1.0));
    // 232: rcp
    reg_tmp6.y = rcp_safe(reg_tmp6.yyyy.x);
    return false;
}
bool sub_239_248() {
    // 239: dp3
    reg_tmp5.x = dot(vec3(mul_safe(uniforms.f[82 + address_registers.x], -reg_tmp4)), vec3(1.0));
    // 240: slti
    reg_tmp5.y = (vec4(lessThan(reg_tmp5.xxxx,uniforms.f[84 + address_registers.x].yyyy))).y;
    // 241: cmp
    conditional_code = equal(vec2(uniforms.f[93].yyyy), vec2(reg_tmp5.xyyy));
    // 242: ifc
    if (conditional_code.y) {
        sub_243_244();
    } else {
        sub_244_247();
    }
    // 247: mul
    reg_tmp6.y = (mul_safe(reg_tmp6.yyyy, reg_tmp5.xxxx)).y;
    return false;
}
bool sub_243_244() {
    // 243: mov
    reg_tmp5.x = (uniforms.f[93].xxxx).x;
    return false;
}
bool sub_244_247() {
    // 244: log
    reg_tmp5.y = log2(reg_tmp5.xxxx.x);
    // 245: mul
    reg_tmp5.y = (mul_safe(uniforms.f[84 + address_registers.x].xxxx, reg_tmp5.yyyy)).y;
    // 246: exp
    reg_tmp5.x = exp2(reg_tmp5.yyyy.x);
    return false;
}
bool sub_251_258() {
    // 251: max
    reg_tmp6.x = (max(uniforms.f[93].xxxx, reg_tmp6.xxxx)).x;
    // 252: mad
    reg_tmp9.xyz = (fma_safe(reg_tmp1.xyzz, uniforms.f[79 + address_registers.x].xyzz, reg_tmp9.xyzz)).xyz;
    // 253: mul
    reg_tmp4 = mul_safe(uniforms.f[80 + address_registers.x], reg_tmp2);
    // 254: mul
    reg_tmp5.xyz = (mul_safe(reg_tmp6.xxxx, reg_tmp4.xyzz)).xyz;
    // 255: mul
    reg_tmp5.xyz = (mul_safe(reg_tmp6.yyyy, reg_tmp5.xyzz)).xyz;
    // 256: add
    reg_tmp9.xyz = (reg_tmp9.xyzz + reg_tmp5.xyzz).xyz;
    // 257: add
    reg_tmp9.w = (reg_tmp9.wwww + reg_tmp4.wwww).w;
    return false;
}
bool sub_260_270() {
    // 260: dp3
    reg_tmp1 = vec4(dot(vec3(mul_safe(uniforms.f[24], reg_tmp14)), vec3(1.0)));
    // 261: mov
    reg_tmp2 = uniforms.f[24].wwww;
    // 262: mad
    reg_tmp1 = fma_safe(reg_tmp1, reg_tmp2, reg_tmp2);
    // 263: mov
    reg_tmp3 = uniforms.f[22];
    // 264: add
    reg_tmp2 = uniforms.f[23] + -reg_tmp3;
    // 265: mad
    reg_tmp4 = fma_safe(reg_tmp2, reg_tmp1, reg_tmp3);
    // 266: ifu
    if (uniforms.b[6]) {
        sub_267_268();
    }
    // 268: mad
    reg_tmp9.xyz = (fma_safe(reg_tmp4, uniforms.f[21], reg_tmp9)).xyz;
    // 269: mov
    reg_tmp8.x = (uniforms.f[93].yyyy).x;
    return false;
}
bool sub_267_268() {
    // 267: mul
    reg_tmp4 = mul_safe(reg_tmp4, reg_tmp9.wwww);
    return false;
}
bool sub_270_279() {
    // 270: dp3
    reg_tmp5.x = dot(vec3(mul_safe(uniforms.f[90], reg_tmp12.xyzz)), vec3(1.0));
    // 271: dp3
    reg_tmp5.y = dot(vec3(mul_safe(uniforms.f[91], reg_tmp12.xyzz)), vec3(1.0));
    // 272: dp3
    reg_tmp5.z = dot(vec3(mul_safe(uniforms.f[92], reg_tmp12.xyzz)), vec3(1.0));
    // 273: dp4
    reg_tmp4.x = dot(mul_safe(reg_tmp5.xyzz, reg_tmp5.xyzz), vec4(1.0));
    // 274: rsq
    reg_tmp4.x = rsq_safe(reg_tmp4.xxxx.x);
    // 275: mul
    reg_tmp4.xyz = (mul_safe(reg_tmp5.xyzz, reg_tmp4.xxxx)).xyz;
    // 276: mul
    reg_tmp4 = mul_safe(uniforms.f[94].zzzz, reg_tmp4);
    // 277: add
    reg_tmp12 = uniforms.f[94].zzzz + reg_tmp4;
    // 278: mov
    vs_out_attr4 = reg_tmp12;
    return false;
}
bool sub_297_321() {
    // 297: mov
    reg_tmp0.xy = (uniforms.f[10].yyyy).xy;
    // 298: ifu
    if (uniforms.b[10]) {
        sub_299_303();
    } else {
        sub_303_320();
    }
    // 320: nop
    return false;
}
bool sub_299_303() {
    // 299: call
    {
        sub_321_329();
    }
    // 300: dp4
    reg_tmp4.x = dot(mul_safe(uniforms.f[14].xywz, reg_tmp6), vec4(1.0));
    // 301: dp4
    reg_tmp4.y = dot(mul_safe(uniforms.f[15].xywz, reg_tmp6), vec4(1.0));
    // 302: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_303_320() {
    // 303: ifu
    if (uniforms.b[13]) {
        sub_304_318();
    } else {
        sub_318_319();
    }
    // 319: nop
    return false;
}
bool sub_304_318() {
    // 304: cmp
    conditional_code = equal(vec2(uniforms.f[95].xyyy), vec2(reg_tmp0.xyyy));
    // 305: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 306: ifc
    if (all(not(conditional_code))) {
        sub_307_314();
    } else {
        sub_314_317();
    }
    // 317: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_307_314() {
    // 307: mov
    reg_tmp6 = reg_tmp10;
    // 308: dp4
    reg_tmp4.x = dot(mul_safe(uniforms.f[14], reg_tmp6), vec4(1.0));
    // 309: dp4
    reg_tmp4.y = dot(mul_safe(uniforms.f[15], reg_tmp6), vec4(1.0));
    // 310: dp4
    reg_tmp4.z = dot(mul_safe(uniforms.f[16], reg_tmp6), vec4(1.0));
    // 311: rcp
    reg_tmp6.w = rcp_safe(reg_tmp4.zzzz.x);
    // 312: mul
    reg_tmp4.xy = (mul_safe(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    // 313: add
    reg_tmp4.xy = (uniforms.f[19].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_314_317() {
    // 314: call
    {
        sub_329_333();
    }
    // 315: dp4
    reg_tmp4.x = dot(mul_safe(uniforms.f[14], reg_tmp6), vec4(1.0));
    // 316: dp4
    reg_tmp4.y = dot(mul_safe(uniforms.f[15], reg_tmp6), vec4(1.0));
    return false;
}
bool sub_318_319() {
    // 318: mov
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_321_329() {
    // 321: cmp
    conditional_code = equal(vec2(uniforms.f[93].yzzz), vec2(reg_tmp0.xyyy));
    // 322: ifc
    if (all(not(conditional_code))) {
        sub_323_324();
    } else {
        sub_324_328();
    }
    // 328: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_323_324() {
    // 323: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
    return false;
}
bool sub_324_328() {
    // 324: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_325_326();
    } else {
        sub_326_327();
    }
    // 327: nop
    return false;
}
bool sub_325_326() {
    // 325: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
    return false;
}
bool sub_326_327() {
    // 326: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
    return false;
}
bool sub_329_333() {
    // 329: mov
    reg_tmp1.xy = (uniforms.f[94].zzzz).xy;
    // 330: mov
    reg_tmp1.zw = (uniforms.f[93].xxxx).zw;
    // 331: mad
    reg_tmp6 = fma_safe(reg_tmp14, reg_tmp1, reg_tmp1);
    // 332: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
// reference: 205C35B2222ABFE3, CD1237CA557B3805
// shader: 8B30, 24B822D609CE0531

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 3F41287A4ACE2CDA, 24B822D609CE0531
// program: CD1237CA557B3805, 3B3AE026C742C7D5, 24B822D609CE0531
// reference: B9094DF3F9931EA4, CD1237CA557B3805
// shader: 8B30, 6320E09DD2EF8330

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(light_vector, normal)));
refl_value.g = (lut_scale_rg * LookupLightingLUTSigned(5, dot(light_vector, normal)));
refl_value.b = (lut_scale_rb * LookupLightingLUTSigned(4, dot(light_vector, normal)));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((secondary_fragment_color.r) * (1.0 - const_color[0].a) + (secondary_fragment_color.b) * (1.0 - (1.0 - const_color[0].a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((secondary_fragment_color.ggg) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) - (texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: F247A4AAA9CCACA1, 6320E09DD2EF8330
// program: 4D9765BCC73533ED, AD7922A63ED54CA7, 6320E09DD2EF8330
// reference: F247A4AADB7C756D, 6320E09DD2EF8330
// reference: 309685BC59B4026E, BAF5CB3693892DB3
// reference: C73588204245A1AF, 30DAB74CA24CBC58
// reference: A9C3FDFD820DA329, BAF5CB3693892DB3
// shader: 8B31, 5746FEF0B06D455B

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;
 out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define mul_safe(x, y) mix(x * y, vec4(0.0), isnan(x * y))

float rcp_safe(float x) {
    if (x == 0.0f) return x;
    return 1.0f / x;
}


float rsq_safe(float x) {
    if (x == 0.0f) return x;
    return inversesqrt(x);
}

#define fma_safe(x, y, z) (mul_safe(x, y) + z)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_4096();
bool sub_7_12();
bool sub_12_21();
bool sub_21_34();
bool sub_34_214();
bool sub_40_146();
bool sub_47_76();
bool sub_58_62();
bool sub_76_135();
bool sub_77_109();
bool sub_88_92();
bool sub_109_134();
bool sub_120_124();
bool sub_144_145();
bool sub_146_213();
bool sub_149_159();
bool sub_159_164();
bool sub_165_177();
bool sub_177_202();
bool sub_178_196();
bool sub_196_201();
bool sub_211_212();
bool sub_214_231();
bool sub_231_307();
bool sub_270_290();
bool sub_271_276();
bool sub_276_289();
bool sub_280_283();
bool sub_283_288();
bool sub_290_303();
bool sub_291_296();
bool sub_296_302();
bool sub_307_321();
bool sub_313_318();
bool sub_315_316();
bool sub_321_339();
bool sub_326_337();
bool sub_339_349();
bool sub_346_347();
bool sub_349_376();
bool sub_351_356();
bool sub_356_375();
bool sub_359_365();
bool sub_365_374();
bool sub_366_370();
bool sub_370_373();
bool sub_376_384();
bool sub_378_379();
bool sub_379_383();
bool sub_380_381();
bool sub_381_382();
bool sub_384_391();
bool sub_391_395();
bool sub_395_419();
bool sub_397_401();
bool sub_401_418();
bool sub_402_416();
bool sub_405_412();
bool sub_412_415();
bool sub_416_417();
bool sub_419_435();
bool sub_421_425();
bool sub_425_434();
bool sub_426_432();
bool sub_432_433();

bool exec_shader() {
    sub_0_4096();
    return true;
}

bool sub_0_4096() {
    // 0: call
    {
        sub_34_214();
    }
    // 1: call
    {
        sub_307_321();
    }
    // 2: call
    {
        sub_349_376();
    }
    // 3: call
    {
        sub_395_419();
    }
    // 4: call
    {
        sub_419_435();
    }
    // 5: end
    return true;
}
bool sub_7_12() {
    // 7: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 8: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 9: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 10: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 11: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    return false;
}
bool sub_12_21() {
    // 12: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 13: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 14: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 15: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 16: dp3
    reg_tmp4.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 17: dp3
    reg_tmp4.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 18: dp3
    reg_tmp4.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 19: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 20: mad
    reg_tmp12 = fma_safe(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_21_34() {
    // 21: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 22: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 23: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 24: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 25: dp3
    reg_tmp4.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 26: dp3
    reg_tmp4.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 27: dp3
    reg_tmp4.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 28: dp3
    reg_tmp5.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 29: dp3
    reg_tmp5.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 30: dp3
    reg_tmp5.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 31: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 32: mad
    reg_tmp12 = fma_safe(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    // 33: mad
    reg_tmp11 = fma_safe(reg_tmp1.wwww, reg_tmp5, reg_tmp11);
    return false;
}
bool sub_34_214() {
    // 34: mul
    reg_tmp15.xyz = (mul_safe(uniforms.f[7].xxxx, vs_in_reg0)).xyz;
    // 35: mul
    reg_tmp14.xyz = (mul_safe(uniforms.f[7].yyyy, vs_in_reg1)).xyz;
    // 36: mul
    reg_tmp13.xyz = (mul_safe(uniforms.f[7].zzzz, vs_in_reg2)).xyz;
    // 37: add
    reg_tmp15.xyz = (uniforms.f[6] + reg_tmp15).xyz;
    // 38: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 39: ifu
    if (uniforms.b[1]) {
        sub_40_146();
    } else {
        sub_146_213();
    }
    // 213: nop
    return false;
}
bool sub_40_146() {
    // 40: mov
    reg_tmp0 = uniforms.f[7];
    // 41: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.yzzz));
    // 42: mov
    reg_tmp7 = uniforms.f[93].xxxx;
    // 43: mov
    reg_tmp12 = uniforms.f[93].xxxx;
    // 44: mov
    reg_tmp11 = uniforms.f[93].xxxx;
    // 45: mul
    reg_tmp2 = mul_safe(uniforms.f[93].wwww, vs_in_reg7);
    // 46: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_47_76();
    } else {
        sub_76_135();
    }
    // 135: mov
    vs_out_attr2 = -reg_tmp15;
    // 136: dp4
    reg_tmp0.x = dot(mul_safe(uniforms.f[86], reg_tmp15), vec4(1.0));
    // 137: dp4
    reg_tmp0.y = dot(mul_safe(uniforms.f[87], reg_tmp15), vec4(1.0));
    // 138: dp4
    reg_tmp0.z = dot(mul_safe(uniforms.f[88], reg_tmp15), vec4(1.0));
    // 139: dp4
    reg_tmp0.w = dot(mul_safe(uniforms.f[89], reg_tmp15), vec4(1.0));
    // 140: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 141: mul
    reg_tmp1.y = (mul_safe(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
    // 142: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 143: ifc
    if (all(conditional_code)) {
        sub_144_145();
    }
    // 145: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_47_76() {
    // 47: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 48: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 49: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 50: call
    {
        sub_12_21();
    }
    // 51: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 52: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 53: call
    {
        sub_12_21();
    }
    // 54: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 55: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 56: callc
    if (conditional_code.x) {
        sub_12_21();
    }
    // 57: ifu
    if (uniforms.b[8]) {
        sub_58_62();
    }
    // 62: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 63: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 64: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 65: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 66: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 67: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 68: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 69: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 70: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 71: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 72: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 73: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 74: call
    {
        sub_214_231();
    }
    // 75: nop
    return false;
}
bool sub_58_62() {
    // 58: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 59: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 60: callc
    if (conditional_code.y) {
        sub_12_21();
    }
    // 61: nop
    return false;
}
bool sub_76_135() {
    // 76: ifc
    if (all(conditional_code)) {
        sub_77_109();
    } else {
        sub_109_134();
    }
    // 134: nop
    return false;
}
bool sub_77_109() {
    // 77: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 78: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 79: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 80: call
    {
        sub_21_34();
    }
    // 81: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 82: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 83: call
    {
        sub_21_34();
    }
    // 84: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 85: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 86: callc
    if (conditional_code.x) {
        sub_21_34();
    }
    // 87: ifu
    if (uniforms.b[8]) {
        sub_88_92();
    }
    // 92: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 93: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 94: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 95: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 96: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 97: dp3
    reg_tmp13.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp11)), vec3(1.0));
    // 98: dp3
    reg_tmp13.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp11)), vec3(1.0));
    // 99: dp3
    reg_tmp13.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp11)), vec3(1.0));
    // 100: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 101: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 102: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 103: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 104: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 105: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 106: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 107: call
    {
        sub_231_307();
    }
    // 108: nop
    return false;
}
bool sub_88_92() {
    // 88: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 89: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 90: callc
    if (conditional_code.y) {
        sub_21_34();
    }
    // 91: nop
    return false;
}
bool sub_109_134() {
    // 109: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 110: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 111: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 112: call
    {
        sub_7_12();
    }
    // 113: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 114: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 115: call
    {
        sub_7_12();
    }
    // 116: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 117: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 118: callc
    if (conditional_code.x) {
        sub_7_12();
    }
    // 119: ifu
    if (uniforms.b[8]) {
        sub_120_124();
    }
    // 124: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 125: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 126: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 127: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 128: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 129: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 130: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 131: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 132: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 133: mov
    vs_out_attr1 = uniforms.f[93].xxxx;
    return false;
}
bool sub_120_124() {
    // 120: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 121: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 122: callc
    if (conditional_code.y) {
        sub_7_12();
    }
    // 123: nop
    return false;
}
bool sub_144_145() {
    // 144: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_146_213() {
    // 146: mov
    reg_tmp0 = uniforms.f[7];
    // 147: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.yzzz));
    // 148: ifu
    if (uniforms.b[2]) {
        sub_149_159();
    } else {
        sub_159_164();
    }
    // 164: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_165_177();
    } else {
        sub_177_202();
    }
    // 202: mov
    vs_out_attr2 = -reg_tmp15;
    // 203: dp4
    reg_tmp0.x = dot(mul_safe(uniforms.f[86], reg_tmp15), vec4(1.0));
    // 204: dp4
    reg_tmp0.y = dot(mul_safe(uniforms.f[87], reg_tmp15), vec4(1.0));
    // 205: dp4
    reg_tmp0.z = dot(mul_safe(uniforms.f[88], reg_tmp15), vec4(1.0));
    // 206: dp4
    reg_tmp0.w = dot(mul_safe(uniforms.f[89], reg_tmp15), vec4(1.0));
    // 207: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 208: mul
    reg_tmp1.y = (mul_safe(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
    // 209: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 210: ifc
    if (all(conditional_code)) {
        sub_211_212();
    }
    // 212: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_149_159() {
    // 149: mul
    reg_tmp1.x = (mul_safe(uniforms.f[93].wwww, vs_in_reg7.xxxx)).x;
    // 150: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 151: dp4
    reg_tmp7.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 152: dp4
    reg_tmp7.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 153: dp4
    reg_tmp7.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 154: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 155: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 156: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 157: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 158: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_159_164() {
    // 159: mova
    address_registers.x = (ivec2(uniforms.f[93].xxxx)).x;
    // 160: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[25], reg_tmp15), vec4(1.0));
    // 161: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[26], reg_tmp15), vec4(1.0));
    // 162: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[27], reg_tmp15), vec4(1.0));
    // 163: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_165_177() {
    // 165: dp3
    reg_tmp12.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 166: dp3
    reg_tmp12.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 167: dp3
    reg_tmp12.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 168: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 169: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 170: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 171: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 172: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 173: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 174: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 175: call
    {
        sub_214_231();
    }
    // 176: nop
    return false;
}
bool sub_177_202() {
    // 177: ifc
    if (all(conditional_code)) {
        sub_178_196();
    } else {
        sub_196_201();
    }
    // 201: nop
    return false;
}
bool sub_178_196() {
    // 178: dp3
    reg_tmp12.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 179: dp3
    reg_tmp12.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 180: dp3
    reg_tmp12.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 181: dp3
    reg_tmp11.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 182: dp3
    reg_tmp11.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 183: dp3
    reg_tmp11.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 184: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 185: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 186: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 187: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 188: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 189: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 190: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 191: dp3
    reg_tmp13.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp11)), vec3(1.0));
    // 192: dp3
    reg_tmp13.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp11)), vec3(1.0));
    // 193: dp3
    reg_tmp13.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp11)), vec3(1.0));
    // 194: call
    {
        sub_231_307();
    }
    // 195: nop
    return false;
}
bool sub_196_201() {
    // 196: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 197: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 198: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 199: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 200: mov
    vs_out_attr1 = uniforms.f[93].xxxx;
    return false;
}
bool sub_211_212() {
    // 211: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_214_231() {
    uint jmp_to = 214u;
    while (true) {
        switch (jmp_to) {
        case 214u: {
            // 214: dp3
            reg_tmp6.x = dot(vec3(mul_safe(reg_tmp14, reg_tmp14)), vec3(1.0));
            // 215: dp3
            reg_tmp7.x = dot(vec3(mul_safe(reg_tmp12, reg_tmp12)), vec3(1.0));
            // 216: rsq
            reg_tmp6.x = rsq_safe(reg_tmp6.xxxx.x);
            // 217: rsq
            reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
            // 218: mul
            reg_tmp14.xyz = (mul_safe(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 219: mul
            reg_tmp12.xyz = (mul_safe(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 220: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 221: jmpu
            if (!uniforms.b[15]) {
                { jmp_to = 230u; break; }
            }
            // 222: add
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            // 223: mul
            reg_tmp4 = mul_safe(uniforms.f[94].zzzz, reg_tmp4);
            // 224: cmp
            conditional_code = greaterThanEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp4.xxxx));
            // 225: rsq
            reg_tmp4 = vec4(rsq_safe(reg_tmp4.xxxx.x));
            // 226: mul
            reg_tmp5 = mul_safe(uniforms.f[94].zzzz, reg_tmp14);
            // 227: jmpc
            if (conditional_code.x) {
                { jmp_to = 230u; break; }
            }
            // 228: rcp
            reg_tmp0.z = rcp_safe(reg_tmp4.xxxx.x);
            // 229: mul
            reg_tmp0.xy = (mul_safe(reg_tmp5, reg_tmp4)).xy;
        }
        case 230u: {
            // 230: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_231_307() {
    uint jmp_to = 231u;
    while (true) {
        switch (jmp_to) {
        case 231u: {
            // 231: dp3
            reg_tmp6.x = dot(vec3(mul_safe(reg_tmp14, reg_tmp14)), vec3(1.0));
            // 232: dp3
            reg_tmp7.x = dot(vec3(mul_safe(reg_tmp12, reg_tmp12)), vec3(1.0));
            // 233: rsq
            reg_tmp6.x = rsq_safe(reg_tmp6.xxxx.x);
            // 234: rsq
            reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
            // 235: mul
            reg_tmp14.xyz = (mul_safe(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 236: mul
            reg_tmp12.xyz = (mul_safe(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 237: mul
            reg_tmp13.xyz = (mul_safe(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            // 238: mul
            reg_tmp11.xyz = (mul_safe(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            // 239: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 240: jmpu
            if (!uniforms.b[15]) {
                { jmp_to = 306u; break; }
            }
            // 241: mul
            reg_tmp13.xyz = (mul_safe(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            // 242: mul
            reg_tmp11.xyz = (mul_safe(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            // 243: mul
            reg_tmp5 = mul_safe(reg_tmp14.yzxx, reg_tmp13.zxyy);
            // 244: mad
            reg_tmp5 = fma_safe(-reg_tmp13.yzxx, reg_tmp14.zxyy, reg_tmp5);
            // 245: dp3
            reg_tmp5.w = dot(vec3(mul_safe(reg_tmp5, reg_tmp5)), vec3(1.0));
            // 246: rsq
            reg_tmp5.w = rsq_safe(reg_tmp5.wwww.x);
            // 247: mul
            reg_tmp5 = mul_safe(reg_tmp5, reg_tmp5.wwww);
            // 248: add
            reg_tmp6.w = (reg_tmp14.zzzz + reg_tmp5.yyyy).w;
            // 249: mul
            reg_tmp13 = mul_safe(reg_tmp5.yzxx, reg_tmp14.zxyy);
            // 250: mad
            reg_tmp13 = fma_safe(-reg_tmp14.yzxx, reg_tmp5.zxyy, reg_tmp13);
            // 251: add
            reg_tmp6.w = (reg_tmp13.xxxx + reg_tmp6).w;
            // 252: mov
            reg_tmp13.w = (reg_tmp5.zzzz).w;
            // 253: mov
            reg_tmp5.z = (reg_tmp13.xxxx).z;
            // 254: add
            reg_tmp6.w = (uniforms.f[93].yyyy + reg_tmp6).w;
            // 255: mov
            reg_tmp14.w = (reg_tmp5.xxxx).w;
            // 256: mov
            reg_tmp5.x = (reg_tmp14.zzzz).x;
            // 257: cmp
            conditional_code = lessThan(vec2(uniforms.f[94].yyyy), vec2(reg_tmp6.wwww));
            // 258: mov
            reg_tmp6.x = (uniforms.f[93].yyyy).x;
            // 259: mov
            reg_tmp6.y = (-uniforms.f[93].yyyy).y;
            // 260: jmpc
            if (!conditional_code.x) {
                { jmp_to = 268u; break; }
            }
            // 261: add
            reg_tmp7.xz = (reg_tmp13.wwyy + -reg_tmp14.yyww).xz;
            // 262: add
            reg_tmp7.y = (reg_tmp14.xxxx + -reg_tmp13.zzzz).y;
            // 263: mov
            reg_tmp7.w = (reg_tmp6).w;
            // 264: dp4
            reg_tmp6 = vec4(dot(mul_safe(reg_tmp7, reg_tmp7), vec4(1.0)));
            // 265: rsq
            reg_tmp6 = vec4(rsq_safe(reg_tmp6.xxxx.x));
            // 266: mul
            reg_tmp0 = mul_safe(reg_tmp7, reg_tmp6);
            // 267: jmpu
            if (uniforms.b[0]) {
                { jmp_to = 306u; break; }
            }
        }
        case 268u: {
            // 268: cmp
            conditional_code = greaterThan(vec2(reg_tmp5.zyyy), vec2(reg_tmp5.yxxx));
            // 269: ifc
            if (conditional_code.x) {
                sub_270_290();
            } else {
                sub_290_303();
            }
            // 303: dp4
            reg_tmp6 = vec4(dot(mul_safe(reg_tmp8, reg_tmp8), vec4(1.0)));
            // 304: rsq
            reg_tmp6 = vec4(rsq_safe(reg_tmp6.xxxx.x));
            // 305: mul
            reg_tmp0 = mul_safe(reg_tmp8, reg_tmp6);
        }
        case 306u: {
            // 306: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_270_290() {
    // 270: ifc
    if (conditional_code.y) {
        sub_271_276();
    } else {
        sub_276_289();
    }
    // 289: mov
    reg_tmp8.w = (-reg_tmp8).w;
    return false;
}
bool sub_271_276() {
    // 271: mul
    reg_tmp8 = mul_safe(reg_tmp13.yyzw, reg_tmp6.xxxy);
    // 272: add
    reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
    // 273: add
    reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
    // 274: add
    reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
    // 275: add
    reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
    return false;
}
bool sub_276_289() {
    // 276: cmp
    conditional_code = greaterThan(vec2(reg_tmp5.zzzz), vec2(reg_tmp5.xxxx));
    // 277: mul
    reg_tmp8 = mul_safe(reg_tmp13.yyzw, reg_tmp6.xxxy);
    // 278: add
    reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
    // 279: ifc
    if (conditional_code.x) {
        sub_280_283();
    } else {
        sub_283_288();
    }
    // 288: nop
    return false;
}
bool sub_280_283() {
    // 280: add
    reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
    // 281: add
    reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
    // 282: add
    reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
    return false;
}
bool sub_283_288() {
    // 283: mul
    reg_tmp8 = mul_safe(reg_tmp13.zwwy, reg_tmp6.xxxy);
    // 284: add
    reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
    // 285: add
    reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
    // 286: add
    reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
    // 287: add
    reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
    return false;
}
bool sub_290_303() {
    // 290: ifc
    if (conditional_code.y) {
        sub_291_296();
    } else {
        sub_296_302();
    }
    // 302: nop
    return false;
}
bool sub_291_296() {
    // 291: mul
    reg_tmp8 = mul_safe(reg_tmp13.yywz, reg_tmp6.xxxy);
    // 292: add
    reg_tmp8.y = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).y;
    // 293: add
    reg_tmp9 = reg_tmp5.yyyy + -reg_tmp5.xxxx;
    // 294: add
    reg_tmp8.xzw = (reg_tmp8 + reg_tmp14.wwyx).xzw;
    // 295: add
    reg_tmp8.y = (reg_tmp9 + reg_tmp8).y;
    return false;
}
bool sub_296_302() {
    // 296: mul
    reg_tmp8 = mul_safe(reg_tmp13.zwwy, reg_tmp6.xxxy);
    // 297: add
    reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
    // 298: add
    reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
    // 299: add
    reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
    // 300: add
    reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
    // 301: mov
    reg_tmp8.w = (-reg_tmp8).w;
    return false;
}
bool sub_307_321() {
    // 307: mov
    reg_tmp8.xy = (uniforms.f[93].xxxx).xy;
    // 308: mov
    reg_tmp0.y = (uniforms.f[7].wwww).y;
    // 309: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.xyyy));
    // 310: mov
    reg_tmp9.xyz = (uniforms.f[93].xxxx).xyz;
    // 311: mov
    reg_tmp9.w = (uniforms.f[21].wwww).w;
    // 312: ifc
    if (conditional_code.y) {
        sub_313_318();
    }
    // 318: callu
    if (uniforms.b[12]) {
        sub_321_339();
    }
    // 319: callu
    if (uniforms.b[5]) {
        sub_339_349();
    }
    // 320: max
    vs_out_attr3 = max(uniforms.f[93].xxxx, reg_tmp9);
    return false;
}
bool sub_313_318() {
    // 313: mul
    reg_tmp0 = mul_safe(uniforms.f[7].wwww, vs_in_reg3);
    // 314: ifu
    if (uniforms.b[7]) {
        sub_315_316();
    }
    // 316: mul
    reg_tmp9.xyz = (mul_safe(uniforms.f[20].wwww, reg_tmp0.xyzz)).xyz;
    // 317: mov
    reg_tmp8.x = (uniforms.f[93].yyyy).x;
    return false;
}
bool sub_315_316() {
    // 315: mul
    reg_tmp9.w = (mul_safe(reg_tmp9.wwww, reg_tmp0.wwww)).w;
    return false;
}
bool sub_321_339() {
    // 321: mov
    reg_tmp1 = uniforms.f[20];
    // 322: mov
    reg_tmp2 = uniforms.f[21];
    // 323: mov
    reg_tmp3 = uniforms.f[93].xxxx;
    // 324: mov
    reg_tmp0 = uniforms.f[93].xxxx;
    // 325: loop
    address_registers.z = int(uniforms.i[0].y);
    for (uint loop325 = 0u; loop325 <= uniforms.i[0].x; address_registers.z += int(uniforms.i[0].z), ++loop325) {
        sub_326_337();
    }
    // 337: mul
    reg_tmp9.xyz = (mul_safe(reg_tmp9.xyzz, reg_tmp0.xyzz)).xyz;
    // 338: mov
    reg_tmp8.x = (uniforms.f[93].yyyy).x;
    return false;
}
bool sub_326_337() {
    // 326: mova
    address_registers.x = (ivec2(reg_tmp3)).x;
    // 327: mov
    reg_tmp4.x = (uniforms.f[81 + address_registers.x].wwww).x;
    // 328: mov
    reg_tmp4.y = (uniforms.f[83 + address_registers.x].wwww).y;
    // 329: dp3
    reg_tmp6.x = dot(vec3(mul_safe(uniforms.f[81 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 330: max
    reg_tmp6.x = (max(uniforms.f[93].xxxx, reg_tmp6.xxxx)).x;
    // 331: mad
    reg_tmp0.xyz = (fma_safe(reg_tmp1.xyzz, uniforms.f[79 + address_registers.x].xyzz, reg_tmp0.xyzz)).xyz;
    // 332: mul
    reg_tmp4 = mul_safe(uniforms.f[80 + address_registers.x], reg_tmp2);
    // 333: mul
    reg_tmp5.xyz = (mul_safe(reg_tmp6.xxxx, reg_tmp4.xyzz)).xyz;
    // 334: add
    reg_tmp0.xyz = (reg_tmp0.xyzz + reg_tmp5.xyzz).xyz;
    // 335: add
    reg_tmp0.w = (reg_tmp0.wwww + reg_tmp4.wwww).w;
    // 336: add
    reg_tmp3 = -uniforms.f[95].wwww + reg_tmp3;
    return false;
}
bool sub_339_349() {
    // 339: dp3
    reg_tmp1 = vec4(dot(vec3(mul_safe(uniforms.f[24], reg_tmp14)), vec3(1.0)));
    // 340: mov
    reg_tmp2 = uniforms.f[24].wwww;
    // 341: mad
    reg_tmp1 = fma_safe(reg_tmp1, reg_tmp2, reg_tmp2);
    // 342: mov
    reg_tmp3 = uniforms.f[22];
    // 343: add
    reg_tmp2 = uniforms.f[23] + -reg_tmp3;
    // 344: mad
    reg_tmp4 = fma_safe(reg_tmp2, reg_tmp1, reg_tmp3);
    // 345: ifu
    if (uniforms.b[6]) {
        sub_346_347();
    }
    // 347: mad
    reg_tmp9.xyz = (fma_safe(reg_tmp4, uniforms.f[21], reg_tmp9)).xyz;
    // 348: mov
    reg_tmp8.x = (uniforms.f[93].yyyy).x;
    return false;
}
bool sub_346_347() {
    // 346: mul
    reg_tmp4 = mul_safe(reg_tmp4, reg_tmp9.wwww);
    return false;
}
bool sub_349_376() {
    // 349: mov
    reg_tmp0.xy = (uniforms.f[10].xxxx).xy;
    // 350: ifu
    if (uniforms.b[9]) {
        sub_351_356();
    } else {
        sub_356_375();
    }
    // 375: nop
    return false;
}
bool sub_351_356() {
    // 351: call
    {
        sub_376_384();
    }
    // 352: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[11].xywz, reg_tmp6), vec4(1.0));
    // 353: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[12].xywz, reg_tmp6), vec4(1.0));
    // 354: mov
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    // 355: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_356_375() {
    // 356: cmp
    conditional_code = equal(vec2(uniforms.f[95].xyyy), vec2(reg_tmp0.xyyy));
    // 357: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 358: ifc
    if (all(not(conditional_code))) {
        sub_359_365();
    } else {
        sub_365_374();
    }
    // 374: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_359_365() {
    // 359: mov
    reg_tmp6 = reg_tmp10;
    // 360: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[11], reg_tmp6), vec4(1.0));
    // 361: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[12], reg_tmp6), vec4(1.0));
    // 362: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[13], reg_tmp6), vec4(1.0));
    // 363: mul
    reg_tmp0.xy = (mul_safe(uniforms.f[19].xyyy, reg_tmp3.zzzz)).xy;
    // 364: add
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_365_374() {
    // 365: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_366_370();
    } else {
        sub_370_373();
    }
    // 373: nop
    return false;
}
bool sub_366_370() {
    // 366: call
    {
        sub_384_391();
    }
    // 367: dp3
    reg_tmp3.x = dot(vec3(mul_safe(uniforms.f[11], reg_tmp6)), vec3(1.0));
    // 368: dp3
    reg_tmp3.y = dot(vec3(mul_safe(uniforms.f[12], reg_tmp6)), vec3(1.0));
    // 369: dp3
    reg_tmp3.z = dot(vec3(mul_safe(uniforms.f[13], reg_tmp6)), vec3(1.0));
    return false;
}
bool sub_370_373() {
    // 370: call
    {
        sub_391_395();
    }
    // 371: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[11], reg_tmp6), vec4(1.0));
    // 372: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[12], reg_tmp6), vec4(1.0));
    return false;
}
bool sub_376_384() {
    // 376: cmp
    conditional_code = equal(vec2(uniforms.f[93].yzzz), vec2(reg_tmp0.xyyy));
    // 377: ifc
    if (all(not(conditional_code))) {
        sub_378_379();
    } else {
        sub_379_383();
    }
    // 383: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_378_379() {
    // 378: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
    return false;
}
bool sub_379_383() {
    // 379: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_380_381();
    } else {
        sub_381_382();
    }
    // 382: nop
    return false;
}
bool sub_380_381() {
    // 380: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
    return false;
}
bool sub_381_382() {
    // 381: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
    return false;
}
bool sub_384_391() {
    // 384: mov
    reg_tmp2 = -reg_tmp15;
    // 385: dp3
    reg_tmp2.w = dot(vec3(mul_safe(reg_tmp2, reg_tmp2)), vec3(1.0));
    // 386: rsq
    reg_tmp2.w = rsq_safe(reg_tmp2.wwww.x);
    // 387: mul
    reg_tmp2 = mul_safe(reg_tmp2, reg_tmp2.wwww);
    // 388: dp3
    reg_tmp1 = vec4(dot(vec3(mul_safe(reg_tmp2, reg_tmp14)), vec3(1.0)));
    // 389: add
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    // 390: mad
    reg_tmp6 = fma_safe(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_391_395() {
    // 391: mov
    reg_tmp1.xy = (uniforms.f[94].zzzz).xy;
    // 392: mov
    reg_tmp1.zw = (uniforms.f[93].xxxx).zw;
    // 393: mad
    reg_tmp6 = fma_safe(reg_tmp14, reg_tmp1, reg_tmp1);
    // 394: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_395_419() {
    // 395: mov
    reg_tmp0.xy = (uniforms.f[10].yyyy).xy;
    // 396: ifu
    if (uniforms.b[10]) {
        sub_397_401();
    } else {
        sub_401_418();
    }
    // 418: nop
    return false;
}
bool sub_397_401() {
    // 397: call
    {
        sub_376_384();
    }
    // 398: dp4
    reg_tmp4.x = dot(mul_safe(uniforms.f[14].xywz, reg_tmp6), vec4(1.0));
    // 399: dp4
    reg_tmp4.y = dot(mul_safe(uniforms.f[15].xywz, reg_tmp6), vec4(1.0));
    // 400: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_401_418() {
    // 401: ifu
    if (uniforms.b[13]) {
        sub_402_416();
    } else {
        sub_416_417();
    }
    // 417: nop
    return false;
}
bool sub_402_416() {
    // 402: cmp
    conditional_code = equal(vec2(uniforms.f[95].xyyy), vec2(reg_tmp0.xyyy));
    // 403: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 404: ifc
    if (all(not(conditional_code))) {
        sub_405_412();
    } else {
        sub_412_415();
    }
    // 415: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_405_412() {
    // 405: mov
    reg_tmp6 = reg_tmp10;
    // 406: dp4
    reg_tmp4.x = dot(mul_safe(uniforms.f[14], reg_tmp6), vec4(1.0));
    // 407: dp4
    reg_tmp4.y = dot(mul_safe(uniforms.f[15], reg_tmp6), vec4(1.0));
    // 408: dp4
    reg_tmp4.z = dot(mul_safe(uniforms.f[16], reg_tmp6), vec4(1.0));
    // 409: rcp
    reg_tmp6.w = rcp_safe(reg_tmp4.zzzz.x);
    // 410: mul
    reg_tmp4.xy = (mul_safe(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    // 411: add
    reg_tmp4.xy = (uniforms.f[19].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_412_415() {
    // 412: call
    {
        sub_391_395();
    }
    // 413: dp4
    reg_tmp4.x = dot(mul_safe(uniforms.f[14], reg_tmp6), vec4(1.0));
    // 414: dp4
    reg_tmp4.y = dot(mul_safe(uniforms.f[15], reg_tmp6), vec4(1.0));
    return false;
}
bool sub_416_417() {
    // 416: mov
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_419_435() {
    // 419: mov
    reg_tmp0.xy = (uniforms.f[10].zzzz).xy;
    // 420: ifu
    if (uniforms.b[11]) {
        sub_421_425();
    } else {
        sub_425_434();
    }
    // 434: nop
    return false;
}
bool sub_421_425() {
    // 421: call
    {
        sub_376_384();
    }
    // 422: dp4
    reg_tmp5.x = dot(mul_safe(uniforms.f[17].xywz, reg_tmp6), vec4(1.0));
    // 423: dp4
    reg_tmp5.y = dot(mul_safe(uniforms.f[18].xywz, reg_tmp6), vec4(1.0));
    // 424: mov
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_425_434() {
    // 425: ifu
    if (uniforms.b[14]) {
        sub_426_432();
    } else {
        sub_432_433();
    }
    // 433: nop
    return false;
}
bool sub_426_432() {
    // 426: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 427: mov
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    // 428: call
    {
        sub_391_395();
    }
    // 429: dp4
    reg_tmp5.x = dot(mul_safe(uniforms.f[17], reg_tmp6), vec4(1.0));
    // 430: dp4
    reg_tmp5.y = dot(mul_safe(uniforms.f[18], reg_tmp6), vec4(1.0));
    // 431: mov
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_432_433() {
    // 432: mov
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
// reference: 8EBCC5D212154409, 5746FEF0B06D455B
// shader: 8B30, CF04D0E47608310B

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (const_color[1].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: ADBCFE8F4B8F999F, CF04D0E47608310B
// program: 5746FEF0B06D455B, AD7922A63ED54CA7, CF04D0E47608310B
// shader: 8B30, 84E276AEB008DB5C

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (const_color[1].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: ADBCFE8FA738729C, 84E276AEB008DB5C
// program: 5746FEF0B06D455B, AD7922A63ED54CA7, 84E276AEB008DB5C
// reference: 5C0085527C9B730E, BAF5CB3693892DB3
// shader: 8B30, EC68C55D9E1FD734

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 6B359CC7317AD80A, EC68C55D9E1FD734
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, EC68C55D9E1FD734
// reference: 6B359CC7C822E880, EC68C55D9E1FD734
// reference: B8CC640E2A17AF89, 7F132D830BF35BC2
// reference: 21991C4FF1AE0ECE, 7F132D830BF35BC2
// reference: 8DB9E8CEBCA0BEDC, EC7233A0BD4CF3D2
// reference: 14EC908F67191F9B, EC7233A0BD4CF3D2
// reference: C555FD13A722D249, BAF5CB3693892DB3
// reference: 557937A3A0122369, CD1237CA557B3805
// reference: CC2C4FE27BAB822E, CD1237CA557B3805
// reference: 1C76F6D72AB30AA3, EC68C55D9E1FD734
// reference: BC80DF2F173FF379, CD1237CA557B3805
// reference: 3712860A85B60B38, FB41A17829976A8A
// reference: DE920D085B57F01B, EC7233A0BD4CF3D2
// shader: 8B30, E6A65EBC7D1F5A7C

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb) * (texcolor0.rgb) + (const_color[0].rgb) * (vec3(1.0) - (texcolor0.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb) * (vec3(1.0) - texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a) * (1.0 - texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (texcolor0.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (texcolor0.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 26F5A2F79265BEE9, E6A65EBC7D1F5A7C
// program: EC7233A0BD4CF3D2, 5D764F9A6220D694, E6A65EBC7D1F5A7C
// reference: 47C7754980EE515C, EC7233A0BD4CF3D2
// shader: 8B30, 2454357F17D6B3CC

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb) * (texcolor0.rgb) + (const_color[0].rgb) * (vec3(1.0) - (texcolor0.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((texcolor0.rgb) * (const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((texcolor0.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((vec3(1.0) - texcolor0.rgb) * (const_color[4].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((1.0 - texcolor0.a) * (const_color[4].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 9A1FA859139AA853, 2454357F17D6B3CC
// program: EC7233A0BD4CF3D2, 5D764F9A6220D694, 2454357F17D6B3CC
// shader: 8B30, F93C56DFAE996873

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb) * (texcolor0.rgb) + (const_color[0].rgb) * (vec3(1.0) - (texcolor0.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb) * (vec3(1.0) - texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a) * (1.0 - texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (texcolor0.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (texcolor0.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: AB48A0E9571FAEFE, F93C56DFAE996873
// program: 0000000000000000, 0000000000000000, F93C56DFAE996873
// reference: 13EDC4B059B4026E, BAF5CB3693892DB3
// reference: 8AB8BCF1820DA329, BAF5CB3693892DB3
// reference: 1549243AEAF1B83F, EC7233A0BD4CF3D2
// reference: 8C1C5C7B31481978, EC7233A0BD4CF3D2
// reference: D836ED827C9B730E, BAF5CB3693892DB3
// reference: 416395C3A722D249, BAF5CB3693892DB3
// shader: 8B30, 2BB9C8FEDE51C537

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 3F41287A32E3E86B, 2BB9C8FEDE51C537
// program: CD1237CA557B3805, 3B3AE026C742C7D5, 2BB9C8FEDE51C537
// shader: 8B30, 73E202FB36B8AAFC

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 3F41287ADE540368, 73E202FB36B8AAFC
// program: CD1237CA557B3805, 3B3AE026C742C7D5, 73E202FB36B8AAFC
// shader: 8B31, C76486EE232535F2

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;
 out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define mul_safe(x, y) mix(x * y, vec4(0.0), isnan(x * y))

float rcp_safe(float x) {
    if (x == 0.0f) return x;
    return 1.0f / x;
}


float rsq_safe(float x) {
    if (x == 0.0f) return x;
    return inversesqrt(x);
}

#define fma_safe(x, y, z) (mul_safe(x, y) + z)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_391_4096();
bool sub_398_403();
bool sub_403_464();
bool sub_425_429();
bool sub_462_463();

bool exec_shader() {
    sub_391_4096();
    return true;
}

bool sub_391_4096() {
    // 391: call
    {
        sub_403_464();
    }
    // 392: mov
    vs_out_attr3 = uniforms.f[93].xxxx;
    // 393: mov
    vs_out_attr4 = uniforms.f[93].xxxx;
    // 394: mov
    vs_out_attr5 = uniforms.f[93].xxxx;
    // 395: mov
    vs_out_attr6 = uniforms.f[93].xxxx;
    // 396: end
    return true;
}
bool sub_398_403() {
    // 398: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 399: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 400: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 401: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 402: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    return false;
}
bool sub_403_464() {
    // 403: mul
    reg_tmp15.xyz = (mul_safe(uniforms.f[7].xxxx, vs_in_reg0)).xyz;
    // 404: mul
    reg_tmp14.xyz = (mul_safe(uniforms.f[7].yyyy, vs_in_reg1)).xyz;
    // 405: mul
    reg_tmp13.xyz = (mul_safe(uniforms.f[7].zzzz, vs_in_reg2)).xyz;
    // 406: add
    reg_tmp15.xyz = (uniforms.f[6] + reg_tmp15).xyz;
    // 407: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 408: mov
    reg_tmp0 = uniforms.f[7];
    // 409: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.yzzz));
    // 410: mov
    reg_tmp7 = uniforms.f[93].xxxx;
    // 411: mov
    reg_tmp12 = uniforms.f[93].xxxx;
    // 412: mov
    reg_tmp11 = uniforms.f[93].xxxx;
    // 413: mul
    reg_tmp2 = mul_safe(uniforms.f[93].wwww, vs_in_reg7);
    // 414: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 415: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 416: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 417: call
    {
        sub_398_403();
    }
    // 418: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 419: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 420: call
    {
        sub_398_403();
    }
    // 421: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 422: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 423: callc
    if (conditional_code.x) {
        sub_398_403();
    }
    // 424: ifu
    if (uniforms.b[8]) {
        sub_425_429();
    }
    // 429: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 430: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 431: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 432: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 433: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 434: add
    reg_tmp6.y = (-uniforms.f[85].wwww + reg_tmp10.yyyy).y;
    // 435: mov
    reg_tmp9.xyz = (uniforms.f[85].xyzz).xyz;
    // 436: dp4
    reg_tmp7.x = dot(mul_safe(reg_tmp9.xyzz, reg_tmp9.xyzz), vec4(1.0));
    // 437: rsq
    reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
    // 438: mul
    reg_tmp7.xyz = (mul_safe(reg_tmp9.xyzz, reg_tmp7.xxxx)).xyz;
    // 439: rcp
    reg_tmp8.y = rcp_safe(-reg_tmp7.yyyy.x);
    // 440: mul
    reg_tmp8.y = (mul_safe(reg_tmp6.yyyy, reg_tmp8.yyyy)).y;
    // 441: mul
    reg_tmp7.xyz = (mul_safe(reg_tmp7.xyzz, reg_tmp8.yyyy)).xyz;
    // 442: add
    reg_tmp10.xyz = (reg_tmp10.xyzz + reg_tmp7.xyzz).xyz;
    // 443: add
    reg_tmp10.y = (uniforms.f[94].zzzz + reg_tmp10.yyyy).y;
    // 444: mov
    reg_tmp7 = reg_tmp10;
    // 445: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[22], reg_tmp7), vec4(1.0));
    // 446: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[23], reg_tmp7), vec4(1.0));
    // 447: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[24], reg_tmp7), vec4(1.0));
    // 448: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 449: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 450: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 451: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 452: mov
    vs_out_attr1 = uniforms.f[93].xxxx;
    // 453: mov
    vs_out_attr2 = -reg_tmp15;
    // 454: dp4
    reg_tmp0.x = dot(mul_safe(uniforms.f[86], reg_tmp15), vec4(1.0));
    // 455: dp4
    reg_tmp0.y = dot(mul_safe(uniforms.f[87], reg_tmp15), vec4(1.0));
    // 456: dp4
    reg_tmp0.z = dot(mul_safe(uniforms.f[88], reg_tmp15), vec4(1.0));
    // 457: dp4
    reg_tmp0.w = dot(mul_safe(uniforms.f[89], reg_tmp15), vec4(1.0));
    // 458: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 459: mul
    reg_tmp1.y = (mul_safe(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
    // 460: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 461: ifc
    if (all(conditional_code)) {
        sub_462_463();
    }
    // 463: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_425_429() {
    // 425: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 426: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 427: callc
    if (conditional_code.y) {
        sub_398_403();
    }
    // 428: nop
    return false;
}
bool sub_462_463() {
    // 462: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
// reference: 2DFD06A2E89D8EB9, C76486EE232535F2
// reference: 5978E236F3DFE103, 24B822D609CE0531
// program: C76486EE232535F2, AD7922A63ED54CA7, 24B822D609CE0531
// shader: 8B31, 46DC307C8C5A54D6

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;
 out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define mul_safe(x, y) mix(x * y, vec4(0.0), isnan(x * y))

float rcp_safe(float x) {
    if (x == 0.0f) return x;
    return 1.0f / x;
}


float rsq_safe(float x) {
    if (x == 0.0f) return x;
    return inversesqrt(x);
}

#define fma_safe(x, y, z) (mul_safe(x, y) + z)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_156_205();
bool sub_181_187();
bool sub_188_195();
bool sub_196_204();
bool sub_205_232();
bool sub_207_212();
bool sub_212_231();
bool sub_215_221();
bool sub_221_230();
bool sub_222_226();
bool sub_226_229();
bool sub_232_240();
bool sub_234_235();
bool sub_235_239();
bool sub_236_237();
bool sub_237_238();
bool sub_240_247();
bool sub_247_254();
bool sub_254_278();
bool sub_256_260();
bool sub_260_277();
bool sub_261_275();
bool sub_264_271();
bool sub_271_274();
bool sub_275_276();
bool sub_278_294();
bool sub_280_284();
bool sub_284_293();
bool sub_285_291();
bool sub_291_292();
bool sub_294_4096();
bool sub_296_298();
bool sub_298_299();
bool sub_304_325();
bool sub_325_339();
bool sub_339_391();
bool sub_363_367();
bool sub_389_390();

bool exec_shader() {
    sub_294_4096();
    return true;
}

bool sub_156_205() {
    // 156: mov
    reg_tmp1.xyz = (uniforms.f[93].xxyx).xyz;
    // 157: dp3
    reg_tmp8.x = dot(vec3(mul_safe(uniforms.f[0], reg_tmp12.xyzz)), vec3(1.0));
    // 158: dp3
    reg_tmp8.y = dot(vec3(mul_safe(uniforms.f[1], reg_tmp12.xyzz)), vec3(1.0));
    // 159: dp3
    reg_tmp8.z = dot(vec3(mul_safe(uniforms.f[2], reg_tmp12.xyzz)), vec3(1.0));
    // 160: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[90], reg_tmp8.xyzz)), vec3(1.0));
    // 161: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[91], reg_tmp8.xyzz)), vec3(1.0));
    // 162: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[92], reg_tmp8.xyzz)), vec3(1.0));
    // 163: mov
    reg_tmp14.w = (uniforms.f[93].xxxx).w;
    // 164: mov
    reg_tmp8 = reg_tmp14;
    // 165: dp4
    reg_tmp14.x = dot(mul_safe(reg_tmp8, reg_tmp8), vec4(1.0));
    // 166: rsq
    reg_tmp14.x = rsq_safe(reg_tmp14.xxxx.x);
    // 167: mul
    reg_tmp14 = mul_safe(reg_tmp8, reg_tmp14.xxxx);
    // 168: mov
    reg_tmp0 = uniforms.f[23];
    // 169: dp3
    reg_tmp8.x = dot(vec3(mul_safe(uniforms.f[0], reg_tmp0.xyzz)), vec3(1.0));
    // 170: dp3
    reg_tmp8.y = dot(vec3(mul_safe(uniforms.f[1], reg_tmp0.xyzz)), vec3(1.0));
    // 171: dp3
    reg_tmp8.z = dot(vec3(mul_safe(uniforms.f[2], reg_tmp0.xyzz)), vec3(1.0));
    // 172: dp3
    reg_tmp6.x = dot(vec3(mul_safe(uniforms.f[90], reg_tmp8.xyzz)), vec3(1.0));
    // 173: dp3
    reg_tmp6.y = dot(vec3(mul_safe(uniforms.f[91], reg_tmp8.xyzz)), vec3(1.0));
    // 174: dp3
    reg_tmp6.z = dot(vec3(mul_safe(uniforms.f[92], reg_tmp8.xyzz)), vec3(1.0));
    // 175: add
    reg_tmp8.xyz = (reg_tmp6.xyzz + reg_tmp1.xyzz).xyz;
    // 176: mov
    reg_tmp8.w = (uniforms.f[93].xxxx).w;
    // 177: dp4
    reg_tmp0.x = dot(mul_safe(reg_tmp8, reg_tmp8), vec4(1.0));
    // 178: rsq
    reg_tmp0.x = rsq_safe(reg_tmp0.xxxx.x);
    // 179: mul
    reg_tmp0 = mul_safe(reg_tmp8, reg_tmp0.xxxx);
    // 180: ifu
    if (uniforms.b[5]) {
        sub_181_187();
    }
    // 187: ifu
    if (uniforms.b[3]) {
        sub_188_195();
    }
    // 195: ifu
    if (uniforms.b[4]) {
        sub_196_204();
    }
    // 204: mov
    vs_out_attr3 = reg_tmp2;
    return false;
}
bool sub_181_187() {
    // 181: dp3
    reg_tmp8.x = dot(vec3(mul_safe(reg_tmp14.xyzz, -reg_tmp6)), vec3(1.0));
    // 182: dp3
    reg_tmp8.y = dot(vec3(mul_safe(reg_tmp1.xyzz, -reg_tmp6)), vec3(1.0));
    // 183: max
    reg_tmp8 = max(uniforms.f[93].xxxx, reg_tmp8);
    // 184: mul
    reg_tmp8.y = (mul_safe(uniforms.f[94].zzzz, reg_tmp8.yyyy)).y;
    // 185: add
    reg_tmp8.y = (uniforms.f[94].zzzz + reg_tmp8.yyyy).y;
    // 186: mul
    reg_tmp2.y = (mul_safe(reg_tmp8.xxxx, reg_tmp8.yyyy)).y;
    return false;
}
bool sub_188_195() {
    // 188: dp3
    reg_tmp9.z = dot(vec3(mul_safe(reg_tmp14.xyzz, reg_tmp0)), vec3(1.0));
    // 189: max
    reg_tmp9.z = (max(uniforms.f[93].xxxx, reg_tmp9.zzzz)).z;
    // 190: min
    reg_tmp9.z = (min(uniforms.f[93].yyyy, reg_tmp9.zzzz)).z;
    // 191: log
    reg_tmp9.z = log2(reg_tmp9.zzzz.x);
    // 192: mul
    reg_tmp9.z = (mul_safe(uniforms.f[22].zzzz, reg_tmp9.zzzz)).z;
    // 193: exp
    reg_tmp9.z = exp2(reg_tmp9.zzzz.x);
    // 194: mul
    reg_tmp2.z = (mul_safe(uniforms.f[22].wwww, reg_tmp9.zzzz)).z;
    return false;
}
bool sub_196_204() {
    // 196: dp3
    reg_tmp9.x = dot(vec3(mul_safe(reg_tmp14, reg_tmp1)), vec3(1.0));
    // 197: max
    reg_tmp9.x = (max(uniforms.f[93].xxxx, reg_tmp9.xxxx)).x;
    // 198: min
    reg_tmp9.x = (min(uniforms.f[93].yyyy, reg_tmp9.xxxx)).x;
    // 199: add
    reg_tmp9.x = (uniforms.f[93].yyyy + -reg_tmp9.xxxx).x;
    // 200: log
    reg_tmp9.x = log2(reg_tmp9.xxxx.x);
    // 201: mul
    reg_tmp9.x = (mul_safe(uniforms.f[22].xxxx, reg_tmp9.xxxx)).x;
    // 202: exp
    reg_tmp9.x = exp2(reg_tmp9.xxxx.x);
    // 203: mul
    reg_tmp2.w = (mul_safe(uniforms.f[22].yyyy, reg_tmp9.xxxx)).w;
    return false;
}
bool sub_205_232() {
    // 205: mov
    reg_tmp0.xy = (uniforms.f[10].xxxx).xy;
    // 206: ifu
    if (uniforms.b[9]) {
        sub_207_212();
    } else {
        sub_212_231();
    }
    // 231: nop
    return false;
}
bool sub_207_212() {
    // 207: call
    {
        sub_232_240();
    }
    // 208: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[11].xywz, reg_tmp6), vec4(1.0));
    // 209: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[12].xywz, reg_tmp6), vec4(1.0));
    // 210: mov
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    // 211: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_212_231() {
    // 212: cmp
    conditional_code = equal(vec2(uniforms.f[95].xyyy), vec2(reg_tmp0.xyyy));
    // 213: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 214: ifc
    if (all(not(conditional_code))) {
        sub_215_221();
    } else {
        sub_221_230();
    }
    // 230: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_215_221() {
    // 215: mov
    reg_tmp6 = reg_tmp10;
    // 216: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[11], reg_tmp6), vec4(1.0));
    // 217: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[12], reg_tmp6), vec4(1.0));
    // 218: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[13], reg_tmp6), vec4(1.0));
    // 219: mul
    reg_tmp0.xy = (mul_safe(uniforms.f[19].xyyy, reg_tmp3.zzzz)).xy;
    // 220: add
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_221_230() {
    // 221: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_222_226();
    } else {
        sub_226_229();
    }
    // 229: nop
    return false;
}
bool sub_222_226() {
    // 222: call
    {
        sub_240_247();
    }
    // 223: dp3
    reg_tmp3.x = dot(vec3(mul_safe(uniforms.f[11], reg_tmp6)), vec3(1.0));
    // 224: dp3
    reg_tmp3.y = dot(vec3(mul_safe(uniforms.f[12], reg_tmp6)), vec3(1.0));
    // 225: dp3
    reg_tmp3.z = dot(vec3(mul_safe(uniforms.f[13], reg_tmp6)), vec3(1.0));
    return false;
}
bool sub_226_229() {
    // 226: call
    {
        sub_247_254();
    }
    // 227: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[11], reg_tmp6), vec4(1.0));
    // 228: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[12], reg_tmp6), vec4(1.0));
    return false;
}
bool sub_232_240() {
    // 232: cmp
    conditional_code = equal(vec2(uniforms.f[93].yzzz), vec2(reg_tmp0.xyyy));
    // 233: ifc
    if (all(not(conditional_code))) {
        sub_234_235();
    } else {
        sub_235_239();
    }
    // 239: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_234_235() {
    // 234: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
    return false;
}
bool sub_235_239() {
    // 235: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_236_237();
    } else {
        sub_237_238();
    }
    // 238: nop
    return false;
}
bool sub_236_237() {
    // 236: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
    return false;
}
bool sub_237_238() {
    // 237: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
    return false;
}
bool sub_240_247() {
    // 240: mov
    reg_tmp2 = -reg_tmp15;
    // 241: dp3
    reg_tmp2.w = dot(vec3(mul_safe(reg_tmp2, reg_tmp2)), vec3(1.0));
    // 242: rsq
    reg_tmp2.w = rsq_safe(reg_tmp2.wwww.x);
    // 243: mul
    reg_tmp2 = mul_safe(reg_tmp2, reg_tmp2.wwww);
    // 244: dp3
    reg_tmp1 = vec4(dot(vec3(mul_safe(reg_tmp2, reg_tmp14)), vec3(1.0)));
    // 245: add
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    // 246: mad
    reg_tmp6 = fma_safe(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_247_254() {
    // 247: mov
    reg_tmp1.xy = (uniforms.f[94].zzzz).xy;
    // 248: mov
    reg_tmp1.zw = (uniforms.f[93].xxxx).zw;
    // 249: dp3
    reg_tmp6.x = dot(vec3(mul_safe(reg_tmp14, reg_tmp14)), vec3(1.0));
    // 250: rsq
    reg_tmp6.x = rsq_safe(reg_tmp6.xxxx.x);
    // 251: mul
    reg_tmp14.xyz = (mul_safe(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
    // 252: mad
    reg_tmp6 = fma_safe(reg_tmp14, reg_tmp1, reg_tmp1);
    // 253: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_254_278() {
    // 254: mov
    reg_tmp0.xy = (uniforms.f[10].yyyy).xy;
    // 255: ifu
    if (uniforms.b[10]) {
        sub_256_260();
    } else {
        sub_260_277();
    }
    // 277: nop
    return false;
}
bool sub_256_260() {
    // 256: call
    {
        sub_232_240();
    }
    // 257: dp4
    reg_tmp4.x = dot(mul_safe(uniforms.f[14].xywz, reg_tmp6), vec4(1.0));
    // 258: dp4
    reg_tmp4.y = dot(mul_safe(uniforms.f[15].xywz, reg_tmp6), vec4(1.0));
    // 259: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_260_277() {
    // 260: ifu
    if (uniforms.b[13]) {
        sub_261_275();
    } else {
        sub_275_276();
    }
    // 276: nop
    return false;
}
bool sub_261_275() {
    // 261: cmp
    conditional_code = equal(vec2(uniforms.f[95].xyyy), vec2(reg_tmp0.xyyy));
    // 262: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 263: ifc
    if (all(not(conditional_code))) {
        sub_264_271();
    } else {
        sub_271_274();
    }
    // 274: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_264_271() {
    // 264: mov
    reg_tmp6 = reg_tmp10;
    // 265: dp4
    reg_tmp4.x = dot(mul_safe(uniforms.f[14], reg_tmp6), vec4(1.0));
    // 266: dp4
    reg_tmp4.y = dot(mul_safe(uniforms.f[15], reg_tmp6), vec4(1.0));
    // 267: dp4
    reg_tmp4.z = dot(mul_safe(uniforms.f[16], reg_tmp6), vec4(1.0));
    // 268: rcp
    reg_tmp6.w = rcp_safe(reg_tmp4.zzzz.x);
    // 269: mul
    reg_tmp4.xy = (mul_safe(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    // 270: add
    reg_tmp4.xy = (uniforms.f[19].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_271_274() {
    // 271: call
    {
        sub_247_254();
    }
    // 272: dp4
    reg_tmp4.x = dot(mul_safe(uniforms.f[14], reg_tmp6), vec4(1.0));
    // 273: dp4
    reg_tmp4.y = dot(mul_safe(uniforms.f[15], reg_tmp6), vec4(1.0));
    return false;
}
bool sub_275_276() {
    // 275: mov
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_278_294() {
    // 278: mov
    reg_tmp0.xy = (uniforms.f[10].zzzz).xy;
    // 279: ifu
    if (uniforms.b[11]) {
        sub_280_284();
    } else {
        sub_284_293();
    }
    // 293: nop
    return false;
}
bool sub_280_284() {
    // 280: call
    {
        sub_232_240();
    }
    // 281: dp4
    reg_tmp5.x = dot(mul_safe(uniforms.f[17].xywz, reg_tmp6), vec4(1.0));
    // 282: dp4
    reg_tmp5.y = dot(mul_safe(uniforms.f[18].xywz, reg_tmp6), vec4(1.0));
    // 283: mov
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_284_293() {
    // 284: ifu
    if (uniforms.b[14]) {
        sub_285_291();
    } else {
        sub_291_292();
    }
    // 292: nop
    return false;
}
bool sub_285_291() {
    // 285: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 286: mov
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    // 287: call
    {
        sub_247_254();
    }
    // 288: dp4
    reg_tmp5.x = dot(mul_safe(uniforms.f[17], reg_tmp6), vec4(1.0));
    // 289: dp4
    reg_tmp5.y = dot(mul_safe(uniforms.f[18], reg_tmp6), vec4(1.0));
    // 290: mov
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_291_292() {
    // 291: mov
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
bool sub_294_4096() {
    // 294: call
    {
        sub_339_391();
    }
    // 295: ifu
    if (uniforms.b[6]) {
        sub_296_298();
    } else {
        sub_298_299();
    }
    // 299: call
    {
        sub_205_232();
    }
    // 300: call
    {
        sub_254_278();
    }
    // 301: call
    {
        sub_278_294();
    }
    // 302: end
    return true;
}
bool sub_296_298() {
    // 296: call
    {
        sub_156_205();
    }
    // 297: nop
    return false;
}
bool sub_298_299() {
    // 298: mov
    vs_out_attr3 = uniforms.f[93].yyyy;
    return false;
}
bool sub_304_325() {
    // 304: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 305: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 306: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 307: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 308: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 309: dp3
    reg_tmp3.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 310: dp3
    reg_tmp3.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 311: dp3
    reg_tmp3.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 312: mad
    reg_tmp12 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp12);
    // 313: dp3
    reg_tmp3.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 314: dp3
    reg_tmp3.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 315: dp3
    reg_tmp3.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 316: mad
    reg_tmp11 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp11);
    // 317: dp3
    reg_tmp3.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp5)), vec3(1.0));
    // 318: dp3
    reg_tmp3.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp5)), vec3(1.0));
    // 319: dp3
    reg_tmp3.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp5)), vec3(1.0));
    // 320: mad
    reg_tmp9 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp9);
    // 321: dp3
    reg_tmp3.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp6)), vec3(1.0));
    // 322: dp3
    reg_tmp3.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp6)), vec3(1.0));
    // 323: dp3
    reg_tmp3.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp6)), vec3(1.0));
    // 324: mad
    reg_tmp8 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp8);
    return false;
}
bool sub_325_339() {
    // 325: mul
    reg_tmp0.xyz = (mul_safe(reg_tmp9.yzxx, reg_tmp8.zxyy)).xyz;
    // 326: mad
    reg_tmp0.xyz = (fma_safe(-reg_tmp8.yzxx, reg_tmp9.zxyy, reg_tmp0)).xyz;
    // 327: mov
    reg_tmp1 = uniforms.f[23];
    // 328: dp4
    reg_tmp2.x = dot(mul_safe(reg_tmp1.xyzz, reg_tmp1.xyzz), vec4(1.0));
    // 329: rsq
    reg_tmp2.x = rsq_safe(reg_tmp2.xxxx.x);
    // 330: mul
    reg_tmp2.xyz = (mul_safe(reg_tmp1.xyzz, reg_tmp2.xxxx)).xyz;
    // 331: dp3
    reg_tmp1.x = dot(vec3(mul_safe(reg_tmp2, reg_tmp8.xyzz)), vec3(1.0));
    // 332: dp3
    reg_tmp1.y = dot(vec3(mul_safe(reg_tmp2, reg_tmp0.xyzz)), vec3(1.0));
    // 333: dp3
    reg_tmp1.z = dot(vec3(mul_safe(reg_tmp2, reg_tmp9.xyzz)), vec3(1.0));
    // 334: dp4
    reg_tmp2.x = dot(mul_safe(reg_tmp1.xyzz, reg_tmp1.xyzz), vec4(1.0));
    // 335: rsq
    reg_tmp2.x = rsq_safe(reg_tmp2.xxxx.x);
    // 336: mul
    reg_tmp2.xyz = (mul_safe(reg_tmp1.xyzz, reg_tmp2.xxxx)).xyz;
    // 337: mov
    reg_tmp2.w = (uniforms.f[93].yyyy).w;
    // 338: mov
    vs_out_attr2 = reg_tmp2;
    return false;
}
bool sub_339_391() {
    // 339: mul
    reg_tmp15.xyz = (mul_safe(uniforms.f[7].xxxx, vs_in_reg0)).xyz;
    // 340: mul
    reg_tmp14.xyz = (mul_safe(uniforms.f[7].yyyy, vs_in_reg1)).xyz;
    // 341: mul
    reg_tmp13.xyz = (mul_safe(uniforms.f[7].zzzz, vs_in_reg2)).xyz;
    // 342: add
    reg_tmp15.xyz = (uniforms.f[6] + reg_tmp15).xyz;
    // 343: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 344: mov
    reg_tmp5 = uniforms.f[93].xxyy;
    // 345: mov
    reg_tmp6 = uniforms.f[93].yxxy;
    // 346: mov
    reg_tmp7 = uniforms.f[93].xxxx;
    // 347: mov
    reg_tmp12 = uniforms.f[93].xxxx;
    // 348: mov
    reg_tmp11 = uniforms.f[93].xxxx;
    // 349: mov
    reg_tmp9 = uniforms.f[93].xxxx;
    // 350: mov
    reg_tmp8 = uniforms.f[93].xxxx;
    // 351: mul
    reg_tmp2 = mul_safe(uniforms.f[93].wwww, vs_in_reg7);
    // 352: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 353: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 354: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 355: call
    {
        sub_304_325();
    }
    // 356: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 357: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 358: call
    {
        sub_304_325();
    }
    // 359: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 360: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 361: callc
    if (conditional_code.x) {
        sub_304_325();
    }
    // 362: ifu
    if (uniforms.b[8]) {
        sub_363_367();
    }
    // 367: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 368: mov
    reg_tmp10 = reg_tmp7;
    // 369: dp3
    reg_tmp13.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp11)), vec3(1.0));
    // 370: dp3
    reg_tmp13.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp11)), vec3(1.0));
    // 371: dp3
    reg_tmp13.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp11)), vec3(1.0));
    // 372: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 373: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 374: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 375: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 376: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 377: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 378: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 379: call
    {
        sub_325_339();
    }
    // 380: mov
    vs_out_attr1 = uniforms.f[93].xxxy;
    // 381: dp4
    reg_tmp0.x = dot(mul_safe(uniforms.f[86], reg_tmp15), vec4(1.0));
    // 382: dp4
    reg_tmp0.y = dot(mul_safe(uniforms.f[87], reg_tmp15), vec4(1.0));
    // 383: dp4
    reg_tmp0.z = dot(mul_safe(uniforms.f[88], reg_tmp15), vec4(1.0));
    // 384: dp4
    reg_tmp0.w = dot(mul_safe(uniforms.f[89], reg_tmp15), vec4(1.0));
    // 385: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 386: mul
    reg_tmp1.y = (mul_safe(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
    // 387: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 388: ifc
    if (all(conditional_code)) {
        sub_389_390();
    }
    // 390: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_363_367() {
    // 363: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 364: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 365: callc
    if (conditional_code.y) {
        sub_304_325();
    }
    // 366: nop
    return false;
}
bool sub_389_390() {
    // 389: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
// reference: 2DFD06A2BF9A1BB7, 46DC307C8C5A54D6
// shader: 8B30, 1C819725D7DBB6AB

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = 2.0 * (texcolor2).rgb - 1.0;
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(normal, normalize(view))));
refl_value.g = (lut_scale_rg * LookupLightingLUTSigned(5, dot(normal, normalize(view))));
refl_value.b = (lut_scale_rb * LookupLightingLUTSigned(4, dot(normal, normalize(view))));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor1.rgb) * (vec3(1.0) - const_color[0].aaa) + (const_color[0].rgb) * (vec3(1.0) - (vec3(1.0) - const_color[0].aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor1.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_1 = byteround(clamp((texcolor0.rgb) + (last_tex_env_out.rgb) - vec3(0.5), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (combiner_buffer.rgb) - vec3(0.5), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((secondary_fragment_color.r) * (1.0 - const_color[2].a) + (secondary_fragment_color.b) * (1.0 - (1.0 - const_color[2].a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((texcolor1.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((secondary_fragment_color.ggg) * (last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: BBF27B69C6ED999F, 1C819725D7DBB6AB
// program: 46DC307C8C5A54D6, AD7922A63ED54CA7, 1C819725D7DBB6AB
// reference: 2DFD06A250A388F6, 46DC307C8C5A54D6
// shader: 8B30, F67CD9340BD8A6A9

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = 2.0 * (texcolor2).rgb - 1.0;
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(normal, normalize(view))));
refl_value.g = (lut_scale_rg * LookupLightingLUTSigned(5, dot(normal, normalize(view))));
refl_value.b = (lut_scale_rb * LookupLightingLUTSigned(4, dot(normal, normalize(view))));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor1.rgb) * (vec3(1.0) - const_color[0].aaa) + (const_color[0].rgb) * (vec3(1.0) - (vec3(1.0) - const_color[0].aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor1.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_1 = byteround(clamp((texcolor0.rgb) + (last_tex_env_out.rgb) - vec3(0.5), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (combiner_buffer.rgb) - vec3(0.5), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((secondary_fragment_color.r) * (1.0 - const_color[2].a) + (secondary_fragment_color.b) * (1.0 - (1.0 - const_color[2].a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((texcolor1.a) * (texcolor2.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((secondary_fragment_color.ggg) * (last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: B09552EDCA6E9A0B, F67CD9340BD8A6A9
// program: 46DC307C8C5A54D6, AD7922A63ED54CA7, F67CD9340BD8A6A9
// reference: 7F396EB58FF0303E, 7F132D830BF35BC2
// reference: E66C16F454499179, 7F132D830BF35BC2
// reference: 5555804D234D43DD, EC7233A0BD4CF3D2
// reference: CC00F80CF8F4E29A, EC7233A0BD4CF3D2
// reference: 982A49F586DAFF4F, BAF5CB3693892DB3
// reference: 017F31B45D635E08, BAF5CB3693892DB3
// reference: 971EC479CD9A5F80, 5746FEF0B06D455B
// reference: 4CDB36087F9D38E0, CD1237CA557B3805
// reference: D58E4E49A42499A7, CD1237CA557B3805
// reference: DCF7FCB878ADC9C0, BAF5CB3693892DB3
// reference: A522DE84C8B0E8F0, CD1237CA557B3805
// reference: 45A284F9A3146887, BAF5CB3693892DB3
// reference: BBF27B69B45D4053, 1C819725D7DBB6AB
// reference: B09552EDB8DE43C7, F67CD9340BD8A6A9
// reference: DC6F24AB7D2C380E, 7F132D830BF35BC2
// reference: 4A4CE2751947216B, EC7233A0BD4CF3D2
// reference: D3199A34C2FE802C, EC7233A0BD4CF3D2
// reference: 460C959C86DAFF4F, BAF5CB3693892DB3
// reference: DF59EDDD5D635E08, BAF5CB3693892DB3
// reference: D58E4E498A65C113, AA5284D8354BC7F4
// reference: A522DE84E6F1B044, AA5284D8354BC7F4
// reference: 5358FED8585742D9, 4D9765BCC73533ED
// reference: 5358FED8B76ED198, 4D9765BCC73533ED
// reference: 87BFD9A41D82E073, 7F132D830BF35BC2
// reference: 1EEAA1E5C63B4134, 7F132D830BF35BC2
// reference: B2CA55648B35F126, EC7233A0BD4CF3D2
// reference: 2B9F2D25508C5061, EC7233A0BD4CF3D2
// reference: BE8A228DCFEAF9A9, BAF5CB3693892DB3
// reference: 27DF5ACC145358EE, BAF5CB3693892DB3
// reference: 00A062E3844BBFCE, 5746FEF0B06D455B
// reference: DB659092180D801A, AA5284D8354BC7F4
// reference: 4230E8D3C3B4215D, AA5284D8354BC7F4
// reference: 4230E8D3EDF579E9, CD1237CA557B3805
// reference: 4B495A22317C298E, BAF5CB3693892DB3
// reference: 329C781E816108BE, CD1237CA557B3805
// reference: 329C781EAF20500A, AA5284D8354BC7F4
// reference: D21C2263EAC588C9, BAF5CB3693892DB3
// reference: DB659092364CD8AE, CD1237CA557B3805
// reference: 508EAA39CD090BDC, EC7233A0BD4CF3D2
// reference: C9DBD27816B0AA9B, EC7233A0BD4CF3D2
// shader: 8B30, 2F92B03EC8DF229E

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb) * (texcolor0.rgb) + (const_color[0].rgb) * (vec3(1.0) - (texcolor0.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((vec3(1.0) - texcolor0.rgb) * (const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((texcolor0.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((texcolor0.rgb) * (const_color[4].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((1.0 - texcolor0.a) * (const_color[4].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: E96D4608139AA853, 2F92B03EC8DF229E
// program: EC7233A0BD4CF3D2, 5D764F9A6220D694, 2F92B03EC8DF229E
// shader: 8B30, B71BBB2F3051D5FF

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb) * (texcolor0.rgb) + (const_color[0].rgb) * (vec3(1.0) - (texcolor0.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((vec3(1.0) - texcolor0.rgb) * (const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((texcolor0.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((texcolor0.rgb) * (const_color[4].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((1.0 - texcolor0.a) * (const_color[4].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 64D04416D6E0B844, B71BBB2F3051D5FF
// program: 0000000000000000, 0000000000000000, B71BBB2F3051D5FF
// reference: 9DF16381CFEAF9A9, BAF5CB3693892DB3
// reference: 04A41BC0145358EE, BAF5CB3693892DB3
// reference: 36D0C33FBC49544E, 7F132D830BF35BC2
// reference: AF85BB7E67F0F509, 7F132D830BF35BC2
// reference: 9B55830B7CAF43F8, EC7233A0BD4CF3D2
// reference: 0200FB4AA716E2BF, EC7233A0BD4CF3D2
// reference: 562A4AB3EAC588C9, BAF5CB3693892DB3
// reference: CF7F32F2317C298E, BAF5CB3693892DB3
// shader: 8B30, CCCAFDE548B6C210

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 3F41287A25B472D1, CCCAFDE548B6C210
// program: CD1237CA557B3805, 3B3AE026C742C7D5, CCCAFDE548B6C210
// shader: 8B30, 3E5CAFDBABD516C0

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = 2.0 * (texcolor2).rgb - 1.0;
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(normal, normalize(view))));
refl_value.g = (lut_scale_rg * LookupLightingLUTSigned(5, dot(normal, normalize(view))));
refl_value.b = (lut_scale_rb * LookupLightingLUTSigned(4, dot(normal, normalize(view))));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((secondary_fragment_color.r) * (texcolor2.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor0.rgb) * (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (1.0 - const_color[1].a) + (secondary_fragment_color.b) * (1.0 - (1.0 - const_color[1].a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor1.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((secondary_fragment_color.ggg) * (const_color[3].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((rounded_primary_color.aaa) * (const_color[4].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 02C13F58928638D8, 3E5CAFDBABD516C0
// program: 46DC307C8C5A54D6, AD7922A63ED54CA7, 3E5CAFDBABD516C0
// shader: 8B30, E14D0525B6AB8EC9

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = 2.0 * (texcolor2).rgb - 1.0;
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(normal, normalize(view))));
refl_value.g = (lut_scale_rg * LookupLightingLUTSigned(5, dot(normal, normalize(view))));
refl_value.b = (lut_scale_rb * LookupLightingLUTSigned(4, dot(normal, normalize(view))));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.ggg) * (const_color[0].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((secondary_fragment_color.r) * (texcolor2.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_1 = byteround(clamp((texcolor0.rgb) * (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (1.0 - const_color[1].a) + (secondary_fragment_color.b) * (1.0 - (1.0 - const_color[1].a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((secondary_fragment_color.ggg) * (last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((rounded_primary_color.a) * (1.0 - combiner_buffer.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((texcolor1.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 692A11A60FB24A3D, E14D0525B6AB8EC9
// program: 46DC307C8C5A54D6, AD7922A63ED54CA7, E14D0525B6AB8EC9
// shader: 8B30, CCB52BD33F912CFA

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = 2.0 * (texcolor2).rgb - 1.0;
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(normal, normalize(view))));
refl_value.g = (lut_scale_rg * LookupLightingLUTSigned(5, dot(normal, normalize(view))));
refl_value.b = (lut_scale_rb * LookupLightingLUTSigned(4, dot(normal, normalize(view))));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((secondary_fragment_color.r) * (1.0 - const_color[0].a) + (secondary_fragment_color.b) * (1.0 - (1.0 - const_color[0].a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((secondary_fragment_color.ggg) * (const_color[2].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((rounded_primary_color.aaa) * (const_color[3].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((texcolor1.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 4509A16E9ACD4F14, CCB52BD33F912CFA
// program: 46DC307C8C5A54D6, AD7922A63ED54CA7, CCB52BD33F912CFA
// shader: 8B30, 615732319A39ACDD

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = 2.0 * (texcolor2).rgb - 1.0;
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(normal, normalize(view))));
refl_value.g = (lut_scale_rg * LookupLightingLUTSigned(5, dot(normal, normalize(view))));
refl_value.b = (lut_scale_rb * LookupLightingLUTSigned(4, dot(normal, normalize(view))));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((secondary_fragment_color.r) * (1.0 - const_color[0].a) + (secondary_fragment_color.b) * (1.0 - (1.0 - const_color[0].a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((secondary_fragment_color.ggg) * (const_color[2].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((texcolor1.a) * (texcolor2.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: B9598B4B2BE4EB18, 615732319A39ACDD
// program: 46DC307C8C5A54D6, AD7922A63ED54CA7, 615732319A39ACDD
// reference: 692A11A67D0293F1, E14D0525B6AB8EC9
// reference: 4509A16EE87D96D8, CCB52BD33F912CFA
// reference: 02C13F58E036E114, 3E5CAFDBABD516C0
// reference: B9598B4B595432D4, 615732319A39ACDD
// reference: 701D7F9A73DC716B, 3DBC6131A77F0199
// reference: 80C2BA710A9FDF99, 93E967909E672D88
// program: 3DBC6131A77F0199, AD7922A63ED54CA7, 93E967909E672D88
// reference: 701D7F9A9CE5E22A, 3DBC6131A77F0199
// reference: A2C074C0D05623C8, 7F132D830BF35BC2
// reference: 3B950C810BEF828F, 7F132D830BF35BC2
// reference: 97B5F80046E1329D, EC7233A0BD4CF3D2
// reference: 0EE080419D5893DA, EC7233A0BD4CF3D2
// reference: 2584B8EB8217231E, D8A369D59E3997EA
// reference: 5555804D10B0347E, EC7233A0BD4CF3D2
// reference: CC00F80CCB099539, EC7233A0BD4CF3D2
// shader: 8B30, B575A1CB562E5A4B

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb) * (texcolor0.rgb) + (rounded_primary_color.rgb) * (vec3(1.0) - (texcolor0.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 3712860AAE587A1F, B575A1CB562E5A4B
// program: 0000000000000000, 0000000000000000, B575A1CB562E5A4B
// shader: 8B30, 1F6F2B60C7AA5C2C

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb) * (texcolor0.rgb) + (rounded_primary_color.rgb) * (vec3(1.0) - (texcolor0.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb) * (vec3(1.0) - texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a) * (1.0 - texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (texcolor0.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (texcolor0.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 26F5A2F7B98BCFCE, 1F6F2B60C7AA5C2C
// program: EC7233A0BD4CF3D2, 5D764F9A6220D694, 1F6F2B60C7AA5C2C
// shader: 8B30, DD9D40A3AD63B59C

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb) * (texcolor0.rgb) + (rounded_primary_color.rgb) * (vec3(1.0) - (texcolor0.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((texcolor0.rgb) * (const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((texcolor0.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((vec3(1.0) - texcolor0.rgb) * (const_color[4].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((1.0 - texcolor0.a) * (const_color[4].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 9A1FA8593874D974, DD9D40A3AD63B59C
// program: EC7233A0BD4CF3D2, 5D764F9A6220D694, DD9D40A3AD63B59C
// shader: 8B30, 111FE465C686BF45

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb) * (vec3(1.0) - texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a) * (1.0 - texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (texcolor0.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (texcolor0.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 34639C1695C496CF, 111FE465C686BF45
// program: EC7233A0BD4CF3D2, 5D764F9A6220D694, 111FE465C686BF45
// shader: 8B30, 706545182ADD045D

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((texcolor0.rgb) * (const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((texcolor0.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((vec3(1.0) - texcolor0.rgb) * (const_color[4].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((1.0 - texcolor0.a) * (const_color[4].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 888996B8143B8075, 706545182ADD045D
// program: EC7233A0BD4CF3D2, 5D764F9A6220D694, 706545182ADD045D
// shader: 8B30, B498EC348B20D31B

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: AABD609E9C26F7CB, B498EC348B20D31B
// program: 7F132D830BF35BC2, AD7922A63ED54CA7, B498EC348B20D31B
// reference: 383B1DE42E211547, 7F132D830BF35BC2
// reference: A16E65A5F598B400, 7F132D830BF35BC2
// reference: 0CEB2591357EA3B6, EC7233A0BD4CF3D2
// reference: 95BE5DD0EEC702F1, EC7233A0BD4CF3D2
// reference: C194EC29A3146887, BAF5CB3693892DB3
// reference: 58C1946878ADC9C0, BAF5CB3693892DB3
// reference: 941BE965632FA555, EC7233A0BD4CF3D2
// reference: 0D4E9124B8960412, EC7233A0BD4CF3D2
// reference: 79A540BF17A8908A, EC68C55D9E1FD734
// program: 7F132D830BF35BC2, AD7922A63ED54CA7, EC68C55D9E1FD734
// reference: 2DFD06A231568D0B, C76486EE232535F2
// reference: 889BC88BD5D5E4CC, 3DBC6131A77F0199
// reference: 27DF5ACCFB6ACBAF, BAF5CB3693892DB3
// reference: 85FDFF1B993935FD, B582B9861A22E219
// reference: D1DDD591C77B6D69, BAF5CB3693892DB3
// reference: 7E9947D606FDD14B, 3DBC6131A77F0199
// reference: 7E9947D6E9C4420A, 3DBC6131A77F0199
// reference: D1DDD5912842FE28, BAF5CB3693892DB3
// reference: AC444C8C4A4E10A9, 7F132D830BF35BC2
// reference: 351134CD91F7B1EE, 7F132D830BF35BC2
// reference: 4888ADD01CC2CC2E, BAF5CB3693892DB3
// reference: 1B593CACC542DB77, 1E6C0649B5CE7F1C
// reference: A53B30DEE44B5208, BAF5CB3693892DB3
// reference: 456E82385EEBB0A5, EC7233A0BD4CF3D2
// reference: DC3BFA79855211E2, EC7233A0BD4CF3D2
// reference: 3C6E489F3FF2F34F, BAF5CB3693892DB3
// reference: 0A7FA29925CDEE2A, 3DBC6131A77F0199
// reference: A53B30DE0B72C149, BAF5CB3693892DB3
// reference: E90B670A993935FD, B582B9861A22E219
// reference: BD2B4D80C77B6D69, BAF5CB3693892DB3
// reference: 126FDFC706FDD14B, 3DBC6131A77F0199
// reference: 126FDFC7E9C4420A, 3DBC6131A77F0199
// reference: BD2B4D802842FE28, BAF5CB3693892DB3
// reference: C0B2D49D4A4E10A9, 7F132D830BF35BC2
// reference: 59E7ACDC91F7B1EE, 7F132D830BF35BC2
// reference: 247E35C11CC2CC2E, BAF5CB3693892DB3
// reference: E90B670A7600A6BC, B582B9861A22E219
// reference: 99F815AFD48D6D2B, 4AD2C97240195A76
// shader: 8B30, FEB1E39313EC6A3F

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: A4AC234A598C7306, FEB1E39313EC6A3F
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, FEB1E39313EC6A3F
// reference: BE081563A63DB4E7, 4AD2C97240195A76
// shader: 8B30, 92F4F0B0E6943599

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += ((light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[2].position + view);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * LookupLightingLUTUnsigned(18,clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[2].specular_0) + (light_src[2].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(18,clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[3].position + view);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * LookupLightingLUTUnsigned(19,clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[3].specular_0) + (light_src[3].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(19,clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_2 = byteround(clamp((texcolor1.rgb) + (secondary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (const_color[2].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (last_tex_env_out.aaa) + (combiner_buffer.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 1DD895623C16DE87, 92F4F0B0E6943599
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, 92F4F0B0E6943599
// reference: C40776ED2B3CAACA, B29EF1BFC4D10886
// reference: 705E1F4B428094BA, B582B9861A22E219
// reference: 27200A163C16DE87, 5AB91AFAAFD32BB6
// shader: 8B30, E6F396A1777C14A1

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += ((light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[2].position + view);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * LookupLightingLUTUnsigned(18,clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[2].specular_0) + (light_src[2].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(18,clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[3].position + view);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * LookupLightingLUTUnsigned(19,clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[3].specular_0) + (light_src[3].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(19,clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: E99905352C03C0B1, E6F396A1777C14A1
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, E6F396A1777C14A1
// shader: 8B30, C47F1A405F8DB749

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb) + (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 0A08775E598C7306, C47F1A405F8DB749
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, C47F1A405F8DB749
// shader: 8B30, E62BC9CCE14A82D5

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((secondary_fragment_color.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((primary_fragment_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: FDA41AD4E0D9DD7E, E62BC9CCE14A82D5
// program: B582B9861A22E219, 3B3AE026C742C7D5, E62BC9CCE14A82D5
// reference: E99905355EB3197D, E6F396A1777C14A1
// reference: 79F3114D88444859, B498EC348B20D31B
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, B498EC348B20D31B
// shader: 8B31, 4EFF2C77DB8F9E73

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define mul_safe(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define rcp_safe(x) (1.0f / x)
#define rsq_safe(x) inversesqrt(x)
#define fma_safe(x, y, z) (mul_safe(x, y) + z)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_4096();
bool sub_7_12();
bool sub_9_10();
bool sub_14_15();
bool sub_18_30();
bool sub_20_21();
bool sub_21_25();
bool sub_22_23();
bool sub_23_24();
bool sub_30_40();
bool sub_44_45();
bool sub_45_49();
bool sub_46_47();
bool sub_47_48();
bool sub_56_61();
bool sub_61_70();
bool sub_70_83();
bool sub_83_251();
bool sub_89_189();
bool sub_96_125();
bool sub_107_111();
bool sub_125_184();
bool sub_126_158();
bool sub_137_141();
bool sub_158_183();
bool sub_169_173();
bool sub_189_250();
bool sub_192_202();
bool sub_202_207();
bool sub_208_220();
bool sub_220_245();
bool sub_221_239();
bool sub_239_244();
bool sub_251_268();
bool sub_268_344();
bool sub_307_327();
bool sub_308_313();
bool sub_313_326();
bool sub_317_320();
bool sub_320_325();
bool sub_327_340();
bool sub_328_333();
bool sub_333_339();

bool exec_shader() {
    sub_0_4096();
    return true;
}

bool sub_0_4096() {
    // 0: call
    {
        sub_83_251();
    }
    // 1: mov
    reg_tmp8.xy = (uniforms.f[93].xxxx).xy;
    // 2: mov
    reg_tmp0.y = (uniforms.f[7].wwww).y;
    // 3: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.xyyy));
    // 4: mov
    reg_tmp9.xyz = (uniforms.f[93].xxxx).xyz;
    // 5: mov
    reg_tmp9.w = (uniforms.f[21].wwww).w;
    // 6: ifc
    if (conditional_code.y) {
        sub_7_12();
    }
    // 12: cmp
    conditional_code = equal(vec2(uniforms.f[93].xxxx), vec2(reg_tmp8.xyyy));
    // 13: ifc
    if (all(conditional_code)) {
        sub_14_15();
    }
    // 15: max
    vs_out_attr3 = max(uniforms.f[93].xxxx, reg_tmp9);
    // 16: mov
    reg_tmp0.xy = (uniforms.f[10].xxxx).xy;
    // 17: ifu
    if (uniforms.b[9]) {
        sub_18_30();
    } else {
        sub_30_40();
    }
    // 40: nop
    // 41: mov
    reg_tmp0.xy = (uniforms.f[10].yyyy).xy;
    // 42: cmp
    conditional_code = equal(vec2(uniforms.f[93].yzzz), vec2(reg_tmp0.xyyy));
    // 43: ifc
    if (all(not(conditional_code))) {
        sub_44_45();
    } else {
        sub_45_49();
    }
    // 49: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 50: dp4
    reg_tmp4.x = dot(mul_safe(uniforms.f[14].xywz, reg_tmp6), vec4(1.0));
    // 51: dp4
    reg_tmp4.y = dot(mul_safe(uniforms.f[15].xywz, reg_tmp6), vec4(1.0));
    // 52: mov
    vs_out_attr5 = reg_tmp4;
    // 53: nop
    // 54: end
    return true;
}
bool sub_7_12() {
    // 7: mul
    reg_tmp0 = mul_safe(uniforms.f[7].wwww, vs_in_reg3);
    // 8: ifu
    if (uniforms.b[7]) {
        sub_9_10();
    }
    // 10: mul
    reg_tmp9.xyz = (mul_safe(uniforms.f[20].wwww, reg_tmp0.xyzz)).xyz;
    // 11: mov
    reg_tmp8.x = (uniforms.f[93].yyyy).x;
    return false;
}
bool sub_9_10() {
    // 9: mul
    reg_tmp9.w = (mul_safe(reg_tmp9.wwww, reg_tmp0.wwww)).w;
    return false;
}
bool sub_14_15() {
    // 14: mov
    reg_tmp9 = uniforms.f[21];
    return false;
}
bool sub_18_30() {
    // 18: cmp
    conditional_code = equal(vec2(uniforms.f[93].yzzz), vec2(reg_tmp0.xyyy));
    // 19: ifc
    if (all(not(conditional_code))) {
        sub_20_21();
    } else {
        sub_21_25();
    }
    // 25: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 26: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[11].xywz, reg_tmp6), vec4(1.0));
    // 27: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[12].xywz, reg_tmp6), vec4(1.0));
    // 28: mov
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    // 29: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_20_21() {
    // 20: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
    return false;
}
bool sub_21_25() {
    // 21: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_22_23();
    } else {
        sub_23_24();
    }
    // 24: nop
    return false;
}
bool sub_22_23() {
    // 22: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
    return false;
}
bool sub_23_24() {
    // 23: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
    return false;
}
bool sub_30_40() {
    // 30: cmp
    conditional_code = equal(vec2(uniforms.f[95].xyyy), vec2(reg_tmp0.xyyy));
    // 31: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 32: mov
    reg_tmp6 = reg_tmp10;
    // 33: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[11], reg_tmp6), vec4(1.0));
    // 34: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[12], reg_tmp6), vec4(1.0));
    // 35: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[13], reg_tmp6), vec4(1.0));
    // 36: mul
    reg_tmp0.xy = (mul_safe(uniforms.f[19].xyyy, reg_tmp3.zzzz)).xy;
    // 37: add
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    // 38: nop
    // 39: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_44_45() {
    // 44: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
    return false;
}
bool sub_45_49() {
    // 45: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_46_47();
    } else {
        sub_47_48();
    }
    // 48: nop
    return false;
}
bool sub_46_47() {
    // 46: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
    return false;
}
bool sub_47_48() {
    // 47: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
    return false;
}
bool sub_56_61() {
    // 56: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 57: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 58: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 59: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 60: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    return false;
}
bool sub_61_70() {
    // 61: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 62: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 63: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 64: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 65: dp3
    reg_tmp4.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 66: dp3
    reg_tmp4.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 67: dp3
    reg_tmp4.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 68: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 69: mad
    reg_tmp12 = fma_safe(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_70_83() {
    // 70: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 71: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 72: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 73: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 74: dp3
    reg_tmp4.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 75: dp3
    reg_tmp4.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 76: dp3
    reg_tmp4.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 77: dp3
    reg_tmp5.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 78: dp3
    reg_tmp5.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 79: dp3
    reg_tmp5.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 80: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 81: mad
    reg_tmp12 = fma_safe(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    // 82: mad
    reg_tmp11 = fma_safe(reg_tmp1.wwww, reg_tmp5, reg_tmp11);
    return false;
}
bool sub_83_251() {
    // 83: mul
    reg_tmp15.xyz = (mul_safe(uniforms.f[7].xxxx, vs_in_reg0)).xyz;
    // 84: mul
    reg_tmp14.xyz = (mul_safe(uniforms.f[7].yyyy, vs_in_reg1)).xyz;
    // 85: mul
    reg_tmp13.xyz = (mul_safe(uniforms.f[7].zzzz, vs_in_reg2)).xyz;
    // 86: add
    reg_tmp15.xyz = (uniforms.f[6] + reg_tmp15).xyz;
    // 87: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 88: ifu
    if (uniforms.b[1]) {
        sub_89_189();
    } else {
        sub_189_250();
    }
    // 250: nop
    return false;
}
bool sub_89_189() {
    // 89: mov
    reg_tmp0 = uniforms.f[7];
    // 90: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.yzzz));
    // 91: mov
    reg_tmp7 = uniforms.f[93].xxxx;
    // 92: mov
    reg_tmp12 = uniforms.f[93].xxxx;
    // 93: mov
    reg_tmp11 = uniforms.f[93].xxxx;
    // 94: mul
    reg_tmp2 = mul_safe(uniforms.f[93].wwww, vs_in_reg7);
    // 95: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_96_125();
    } else {
        sub_125_184();
    }
    // 184: mov
    vs_out_attr2 = -reg_tmp15;
    // 185: dp4
    vs_out_attr0.x = dot(mul_safe(uniforms.f[86], reg_tmp15), vec4(1.0));
    // 186: dp4
    vs_out_attr0.y = dot(mul_safe(uniforms.f[87], reg_tmp15), vec4(1.0));
    // 187: dp4
    vs_out_attr0.z = dot(mul_safe(uniforms.f[88], reg_tmp15), vec4(1.0));
    // 188: dp4
    vs_out_attr0.w = dot(mul_safe(uniforms.f[89], reg_tmp15), vec4(1.0));
    return false;
}
bool sub_96_125() {
    // 96: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 97: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 98: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 99: call
    {
        sub_61_70();
    }
    // 100: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 101: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 102: call
    {
        sub_61_70();
    }
    // 103: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 104: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 105: callc
    if (conditional_code.x) {
        sub_61_70();
    }
    // 106: ifu
    if (uniforms.b[8]) {
        sub_107_111();
    }
    // 111: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 112: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 113: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 114: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 115: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 116: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 117: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 118: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 119: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 120: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 121: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 122: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 123: call
    {
        sub_251_268();
    }
    // 124: nop
    return false;
}
bool sub_107_111() {
    // 107: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 108: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 109: callc
    if (conditional_code.y) {
        sub_61_70();
    }
    // 110: nop
    return false;
}
bool sub_125_184() {
    // 125: ifc
    if (all(conditional_code)) {
        sub_126_158();
    } else {
        sub_158_183();
    }
    // 183: nop
    return false;
}
bool sub_126_158() {
    // 126: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 127: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 128: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 129: call
    {
        sub_70_83();
    }
    // 130: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 131: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 132: call
    {
        sub_70_83();
    }
    // 133: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 134: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 135: callc
    if (conditional_code.x) {
        sub_70_83();
    }
    // 136: ifu
    if (uniforms.b[8]) {
        sub_137_141();
    }
    // 141: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 142: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 143: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 144: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 145: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 146: dp3
    reg_tmp13.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp11)), vec3(1.0));
    // 147: dp3
    reg_tmp13.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp11)), vec3(1.0));
    // 148: dp3
    reg_tmp13.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp11)), vec3(1.0));
    // 149: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 150: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 151: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 152: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 153: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 154: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 155: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 156: call
    {
        sub_268_344();
    }
    // 157: nop
    return false;
}
bool sub_137_141() {
    // 137: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 138: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 139: callc
    if (conditional_code.y) {
        sub_70_83();
    }
    // 140: nop
    return false;
}
bool sub_158_183() {
    // 158: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 159: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 160: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 161: call
    {
        sub_56_61();
    }
    // 162: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 163: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 164: call
    {
        sub_56_61();
    }
    // 165: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 166: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 167: callc
    if (conditional_code.x) {
        sub_56_61();
    }
    // 168: ifu
    if (uniforms.b[8]) {
        sub_169_173();
    }
    // 173: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 174: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 175: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 176: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 177: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 178: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 179: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 180: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 181: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 182: mov
    vs_out_attr1 = uniforms.f[93].xxxx;
    return false;
}
bool sub_169_173() {
    // 169: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 170: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 171: callc
    if (conditional_code.y) {
        sub_56_61();
    }
    // 172: nop
    return false;
}
bool sub_189_250() {
    // 189: mov
    reg_tmp0 = uniforms.f[7];
    // 190: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.yzzz));
    // 191: ifu
    if (uniforms.b[2]) {
        sub_192_202();
    } else {
        sub_202_207();
    }
    // 207: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_208_220();
    } else {
        sub_220_245();
    }
    // 245: mov
    vs_out_attr2 = -reg_tmp15;
    // 246: dp4
    vs_out_attr0.x = dot(mul_safe(uniforms.f[86], reg_tmp15), vec4(1.0));
    // 247: dp4
    vs_out_attr0.y = dot(mul_safe(uniforms.f[87], reg_tmp15), vec4(1.0));
    // 248: dp4
    vs_out_attr0.z = dot(mul_safe(uniforms.f[88], reg_tmp15), vec4(1.0));
    // 249: dp4
    vs_out_attr0.w = dot(mul_safe(uniforms.f[89], reg_tmp15), vec4(1.0));
    return false;
}
bool sub_192_202() {
    // 192: mul
    reg_tmp1.x = (mul_safe(uniforms.f[93].wwww, vs_in_reg7.xxxx)).x;
    // 193: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 194: dp4
    reg_tmp7.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 195: dp4
    reg_tmp7.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 196: dp4
    reg_tmp7.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 197: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 198: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 199: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 200: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 201: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_202_207() {
    // 202: mova
    address_registers.x = (ivec2(uniforms.f[93].xxxx)).x;
    // 203: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[25], reg_tmp15), vec4(1.0));
    // 204: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[26], reg_tmp15), vec4(1.0));
    // 205: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[27], reg_tmp15), vec4(1.0));
    // 206: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_208_220() {
    // 208: dp3
    reg_tmp12.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 209: dp3
    reg_tmp12.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 210: dp3
    reg_tmp12.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 211: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 212: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 213: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 214: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 215: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 216: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 217: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 218: call
    {
        sub_251_268();
    }
    // 219: nop
    return false;
}
bool sub_220_245() {
    // 220: ifc
    if (all(conditional_code)) {
        sub_221_239();
    } else {
        sub_239_244();
    }
    // 244: nop
    return false;
}
bool sub_221_239() {
    // 221: dp3
    reg_tmp12.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 222: dp3
    reg_tmp12.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 223: dp3
    reg_tmp12.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 224: dp3
    reg_tmp11.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 225: dp3
    reg_tmp11.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 226: dp3
    reg_tmp11.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 227: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 228: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 229: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 230: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 231: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 232: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 233: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 234: dp3
    reg_tmp13.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp11)), vec3(1.0));
    // 235: dp3
    reg_tmp13.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp11)), vec3(1.0));
    // 236: dp3
    reg_tmp13.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp11)), vec3(1.0));
    // 237: call
    {
        sub_268_344();
    }
    // 238: nop
    return false;
}
bool sub_239_244() {
    // 239: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 240: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 241: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 242: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 243: mov
    vs_out_attr1 = uniforms.f[93].xxxx;
    return false;
}
bool sub_251_268() {
    uint jmp_to = 251u;
    while (true) {
        switch (jmp_to) {
        case 251u: {
            // 251: dp3
            reg_tmp6.x = dot(vec3(mul_safe(reg_tmp14, reg_tmp14)), vec3(1.0));
            // 252: dp3
            reg_tmp7.x = dot(vec3(mul_safe(reg_tmp12, reg_tmp12)), vec3(1.0));
            // 253: rsq
            reg_tmp6.x = rsq_safe(reg_tmp6.xxxx.x);
            // 254: rsq
            reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
            // 255: mul
            reg_tmp14.xyz = (mul_safe(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 256: mul
            reg_tmp12.xyz = (mul_safe(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 257: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 258: jmpu
            if (!uniforms.b[15]) {
                { jmp_to = 267u; break; }
            }
            // 259: add
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            // 260: mul
            reg_tmp4 = mul_safe(uniforms.f[94].zzzz, reg_tmp4);
            // 261: cmp
            conditional_code = greaterThanEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp4.xxxx));
            // 262: rsq
            reg_tmp4 = vec4(rsq_safe(reg_tmp4.xxxx.x));
            // 263: mul
            reg_tmp5 = mul_safe(uniforms.f[94].zzzz, reg_tmp14);
            // 264: jmpc
            if (conditional_code.x) {
                { jmp_to = 267u; break; }
            }
            // 265: rcp
            reg_tmp0.z = rcp_safe(reg_tmp4.xxxx.x);
            // 266: mul
            reg_tmp0.xy = (mul_safe(reg_tmp5, reg_tmp4)).xy;
        }
        case 267u: {
            // 267: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_268_344() {
    uint jmp_to = 268u;
    while (true) {
        switch (jmp_to) {
        case 268u: {
            // 268: dp3
            reg_tmp6.x = dot(vec3(mul_safe(reg_tmp14, reg_tmp14)), vec3(1.0));
            // 269: dp3
            reg_tmp7.x = dot(vec3(mul_safe(reg_tmp12, reg_tmp12)), vec3(1.0));
            // 270: rsq
            reg_tmp6.x = rsq_safe(reg_tmp6.xxxx.x);
            // 271: rsq
            reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
            // 272: mul
            reg_tmp14.xyz = (mul_safe(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 273: mul
            reg_tmp12.xyz = (mul_safe(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 274: mul
            reg_tmp13.xyz = (mul_safe(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            // 275: mul
            reg_tmp11.xyz = (mul_safe(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            // 276: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 277: jmpu
            if (!uniforms.b[15]) {
                { jmp_to = 343u; break; }
            }
            // 278: mul
            reg_tmp13.xyz = (mul_safe(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            // 279: mul
            reg_tmp11.xyz = (mul_safe(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            // 280: mul
            reg_tmp5 = mul_safe(reg_tmp14.yzxx, reg_tmp13.zxyy);
            // 281: mad
            reg_tmp5 = fma_safe(-reg_tmp13.yzxx, reg_tmp14.zxyy, reg_tmp5);
            // 282: dp3
            reg_tmp5.w = dot(vec3(mul_safe(reg_tmp5, reg_tmp5)), vec3(1.0));
            // 283: rsq
            reg_tmp5.w = rsq_safe(reg_tmp5.wwww.x);
            // 284: mul
            reg_tmp5 = mul_safe(reg_tmp5, reg_tmp5.wwww);
            // 285: add
            reg_tmp6.w = (reg_tmp14.zzzz + reg_tmp5.yyyy).w;
            // 286: mul
            reg_tmp13 = mul_safe(reg_tmp5.yzxx, reg_tmp14.zxyy);
            // 287: mad
            reg_tmp13 = fma_safe(-reg_tmp14.yzxx, reg_tmp5.zxyy, reg_tmp13);
            // 288: add
            reg_tmp6.w = (reg_tmp13.xxxx + reg_tmp6).w;
            // 289: mov
            reg_tmp13.w = (reg_tmp5.zzzz).w;
            // 290: mov
            reg_tmp5.z = (reg_tmp13.xxxx).z;
            // 291: add
            reg_tmp6.w = (uniforms.f[93].yyyy + reg_tmp6).w;
            // 292: mov
            reg_tmp14.w = (reg_tmp5.xxxx).w;
            // 293: mov
            reg_tmp5.x = (reg_tmp14.zzzz).x;
            // 294: cmp
            conditional_code = lessThan(vec2(uniforms.f[94].yyyy), vec2(reg_tmp6.wwww));
            // 295: mov
            reg_tmp6.x = (uniforms.f[93].yyyy).x;
            // 296: mov
            reg_tmp6.y = (-uniforms.f[93].yyyy).y;
            // 297: jmpc
            if (!conditional_code.x) {
                { jmp_to = 305u; break; }
            }
            // 298: add
            reg_tmp7.xz = (reg_tmp13.wwyy + -reg_tmp14.yyww).xz;
            // 299: add
            reg_tmp7.y = (reg_tmp14.xxxx + -reg_tmp13.zzzz).y;
            // 300: mov
            reg_tmp7.w = (reg_tmp6).w;
            // 301: dp4
            reg_tmp6 = vec4(dot(mul_safe(reg_tmp7, reg_tmp7), vec4(1.0)));
            // 302: rsq
            reg_tmp6 = vec4(rsq_safe(reg_tmp6.xxxx.x));
            // 303: mul
            reg_tmp0 = mul_safe(reg_tmp7, reg_tmp6);
            // 304: jmpu
            if (uniforms.b[0]) {
                { jmp_to = 343u; break; }
            }
        }
        case 305u: {
            // 305: cmp
            conditional_code = greaterThan(vec2(reg_tmp5.zyyy), vec2(reg_tmp5.yxxx));
            // 306: ifc
            if (conditional_code.x) {
                sub_307_327();
            } else {
                sub_327_340();
            }
            // 340: dp4
            reg_tmp6 = vec4(dot(mul_safe(reg_tmp8, reg_tmp8), vec4(1.0)));
            // 341: rsq
            reg_tmp6 = vec4(rsq_safe(reg_tmp6.xxxx.x));
            // 342: mul
            reg_tmp0 = mul_safe(reg_tmp8, reg_tmp6);
        }
        case 343u: {
            // 343: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_307_327() {
    // 307: ifc
    if (conditional_code.y) {
        sub_308_313();
    } else {
        sub_313_326();
    }
    // 326: mov
    reg_tmp8.w = (-reg_tmp8).w;
    return false;
}
bool sub_308_313() {
    // 308: mul
    reg_tmp8 = mul_safe(reg_tmp13.yyzw, reg_tmp6.xxxy);
    // 309: add
    reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
    // 310: add
    reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
    // 311: add
    reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
    // 312: add
    reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
    return false;
}
bool sub_313_326() {
    // 313: cmp
    conditional_code = greaterThan(vec2(reg_tmp5.zzzz), vec2(reg_tmp5.xxxx));
    // 314: mul
    reg_tmp8 = mul_safe(reg_tmp13.yyzw, reg_tmp6.xxxy);
    // 315: add
    reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
    // 316: ifc
    if (conditional_code.x) {
        sub_317_320();
    } else {
        sub_320_325();
    }
    // 325: nop
    return false;
}
bool sub_317_320() {
    // 317: add
    reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
    // 318: add
    reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
    // 319: add
    reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
    return false;
}
bool sub_320_325() {
    // 320: mul
    reg_tmp8 = mul_safe(reg_tmp13.zwwy, reg_tmp6.xxxy);
    // 321: add
    reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
    // 322: add
    reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
    // 323: add
    reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
    // 324: add
    reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
    return false;
}
bool sub_327_340() {
    // 327: ifc
    if (conditional_code.y) {
        sub_328_333();
    } else {
        sub_333_339();
    }
    // 339: nop
    return false;
}
bool sub_328_333() {
    // 328: mul
    reg_tmp8 = mul_safe(reg_tmp13.yywz, reg_tmp6.xxxy);
    // 329: add
    reg_tmp8.y = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).y;
    // 330: add
    reg_tmp9 = reg_tmp5.yyyy + -reg_tmp5.xxxx;
    // 331: add
    reg_tmp8.xzw = (reg_tmp8 + reg_tmp14.wwyx).xzw;
    // 332: add
    reg_tmp8.y = (reg_tmp9 + reg_tmp8).y;
    return false;
}
bool sub_333_339() {
    // 333: mul
    reg_tmp8 = mul_safe(reg_tmp13.zwwy, reg_tmp6.xxxy);
    // 334: add
    reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
    // 335: add
    reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
    // 336: add
    reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
    // 337: add
    reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
    // 338: mov
    reg_tmp8.w = (-reg_tmp8).w;
    return false;
}
// reference: DE1D69C006CFC268, 4EFF2C77DB8F9E73
// program: 4EFF2C77DB8F9E73, 3B3AE026C742C7D5, 93E967909E672D88
// reference: 52ACE69806CFC268, 4EFF2C77DB8F9E73
// reference: CBF99ED9DD76632F, 4EFF2C77DB8F9E73
// program: 4EFF2C77DB8F9E73, 3B3AE026C742C7D5, 6775B824F2B62B1B
// program: 4EFF2C77DB8F9E73, 3B3AE026C742C7D5, 30DAB74CA24CBC58
// program: 4EFF2C77DB8F9E73, 3B3AE026C742C7D5, 9F0AC915A32BAB2C
// reference: FEFFE99961847888, 30DAB74CA24CBC58
// shader: 8B30, 019543348F7A91B5

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((secondary_fragment_color.r) * (1.0 - const_color[1].a) + (secondary_fragment_color.g) * (1.0 - (1.0 - const_color[1].a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((combiner_buffer.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((secondary_fragment_color.ggg) * (last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((rounded_primary_color.a) * (const_color[4].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 9447FC938399BF34, 019543348F7A91B5
// program: 0000000000000000, 0000000000000000, 019543348F7A91B5
// shader: 8B31, BF583C1F84D94483

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define mul_safe(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define rcp_safe(x) (1.0f / x)
#define rsq_safe(x) inversesqrt(x)
#define fma_safe(x, y, z) (mul_safe(x, y) + z)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_4096();
bool sub_22_27();
bool sub_33_35();
bool sub_35_46();
bool sub_38_39();
bool sub_40_41();
bool sub_42_43();
bool sub_44_45();
bool sub_48_51();
bool sub_52_55();
bool sub_56_59();
bool sub_60_63();
bool sub_65_99();
bool sub_67_86();
bool sub_70_73();
bool sub_74_77();
bool sub_78_81();
bool sub_82_85();
bool sub_88_98();
bool sub_90_93();
bool sub_94_97();

bool exec_shader() {
    sub_0_4096();
    return true;
}

bool sub_0_4096() {
    // 0: mova
    address_registers.x = (ivec2(vs_in_reg0)).x;
    // 1: mov
    reg_tmp0 = uniforms.f[6 + address_registers.x].wzyx;
    // 2: mov
    reg_tmp1.xy = (vs_in_reg0.zwzw).xy;
    // 3: mov
    reg_tmp1.zw = (uniforms.f[5].xyxy).zw;
    // 4: mova
    address_registers.xy = ivec2(reg_tmp0.xyyy);
    // 5: mov
    reg_tmp2.xw = (uniforms.f[64 + address_registers.y].wwyy).xw;
    // 6: mov
    reg_tmp2.yz = (uniforms.f[5].xxxx).yz;
    // 7: dp4
    reg_tmp4.x = dot(mul_safe(reg_tmp1, reg_tmp2), vec4(1.0));
    // 8: mov
    reg_tmp2.yw = (uniforms.f[64 + address_registers.y].zzxx).yw;
    // 9: mov
    reg_tmp2.xz = (uniforms.f[5].xxxx).xz;
    // 10: dp4
    reg_tmp4.y = dot(mul_safe(reg_tmp1, reg_tmp2), vec4(1.0));
    // 11: mov
    reg_tmp4.zw = (reg_tmp1.zwzw).zw;
    // 12: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[32 + address_registers.x].wzyx, reg_tmp4), vec4(1.0));
    // 13: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[33 + address_registers.x].wzyx, reg_tmp4), vec4(1.0));
    // 14: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[34 + address_registers.x].wzyx, reg_tmp4), vec4(1.0));
    // 15: mov
    reg_tmp3.w = (reg_tmp1.wwww).w;
    // 16: mov
    reg_tmp4.z = (uniforms.f[34 + address_registers.x].xxxx).z;
    // 17: max
    reg_tmp4.z = (max(reg_tmp4.zzzz, -reg_tmp4.zzzz)).z;
    // 18: add
    reg_tmp4.z = (uniforms.f[4].yyyy + reg_tmp4.zzzz).z;
    // 19: mov
    reg_tmp4.x = (uniforms.f[4].wwww).x;
    // 20: cmp
    conditional_code = notEqual(vec2(uniforms.f[5].xxxx), vec2(reg_tmp4.xzzz));
    // 21: ifc
    if (all(conditional_code)) {
        sub_22_27();
    }
    // 27: dp4
    vs_out_attr0.x = dot(mul_safe(uniforms.f[0].wzyx, reg_tmp3), vec4(1.0));
    // 28: dp4
    vs_out_attr0.y = dot(mul_safe(uniforms.f[1].wzyx, reg_tmp3), vec4(1.0));
    // 29: dp4
    vs_out_attr0.z = dot(mul_safe(uniforms.f[2].wzyx, reg_tmp3), vec4(1.0));
    // 30: dp4
    vs_out_attr0.w = dot(mul_safe(uniforms.f[3].wzyx, reg_tmp3), vec4(1.0));
    // 31: cmp
    conditional_code = greaterThanEqual(vec2(uniforms.f[5].yyyy), vec2(reg_tmp0.wwww));
    // 32: ifc
    if (all(conditional_code)) {
        sub_33_35();
    } else {
        sub_35_46();
    }
    // 46: cmp
    conditional_code = notEqual(vec2(uniforms.f[5].xxxx), vec2(reg_tmp1.xyyy));
    // 47: ifc
    if (all(not(conditional_code))) {
        sub_48_51();
    }
    // 51: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_52_55();
    }
    // 55: ifc
    if (all(bvec2(!conditional_code.x, conditional_code.y))) {
        sub_56_59();
    }
    // 59: ifc
    if (all(conditional_code)) {
        sub_60_63();
    }
    // 63: mov
    reg_tmp8 = uniforms.f[5].xxxx;
    // 64: loop
    address_registers.z = int(uniforms.i[0].y);
    for (uint loop64 = 0u; loop64 <= uniforms.i[0].x; address_registers.z += int(uniforms.i[0].z), ++loop64) {
        sub_65_99();
    }
    // 99: mov
    vs_out_attr2 = reg_tmp5;
    // 100: mov
    vs_out_attr3 = reg_tmp6;
    // 101: mov
    vs_out_attr4 = reg_tmp7;
    // 102: end
    return true;
}
bool sub_22_27() {
    // 22: mov
    reg_tmp4.x = (uniforms.f[4].wwww).x;
    // 23: add
    reg_tmp4.y = (-uniforms.f[4].zzzz + reg_tmp4.zzzz).y;
    // 24: rcp
    reg_tmp4.z = rcp_safe(reg_tmp4.zzzz.x);
    // 25: mul
    reg_tmp4.z = (mul_safe(reg_tmp4.yyyy, reg_tmp4.zzzz)).z;
    // 26: mad
    reg_tmp3.x = (fma_safe(reg_tmp4.xxxx, reg_tmp4.zzzz, reg_tmp3.xxxx)).x;
    return false;
}
bool sub_33_35() {
    // 33: mov
    vs_out_attr1.xyz = (uniforms.f[5].yyyy).xyz;
    // 34: mov
    vs_out_attr1.w = (reg_tmp0.wwww).w;
    return false;
}
bool sub_35_46() {
    // 35: mova
    address_registers.y = (ivec2(reg_tmp0.wwww)).y;
    // 36: cmp
    conditional_code = notEqual(vec2(uniforms.f[5].xxxx), vec2(reg_tmp1.xyyy));
    // 37: ifc
    if (all(not(conditional_code))) {
        sub_38_39();
    }
    // 39: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_40_41();
    }
    // 41: ifc
    if (all(bvec2(!conditional_code.x, conditional_code.y))) {
        sub_42_43();
    }
    // 43: ifc
    if (all(conditional_code)) {
        sub_44_45();
    }
    // 45: nop
    return false;
}
bool sub_38_39() {
    // 38: mov
    vs_out_attr1 = uniforms.f[32 + address_registers.y].wzyx;
    return false;
}
bool sub_40_41() {
    // 40: mov
    vs_out_attr1 = uniforms.f[33 + address_registers.y].wzyx;
    return false;
}
bool sub_42_43() {
    // 42: mov
    vs_out_attr1 = uniforms.f[34 + address_registers.y].wzyx;
    return false;
}
bool sub_44_45() {
    // 44: mov
    vs_out_attr1 = uniforms.f[35 + address_registers.y].wzyx;
    return false;
}
bool sub_48_51() {
    // 48: mov
    reg_tmp5 = uniforms.f[5].xyyy;
    // 49: mov
    reg_tmp6 = uniforms.f[5].xyyy;
    // 50: mov
    reg_tmp7 = uniforms.f[5].xyyy;
    return false;
}
bool sub_52_55() {
    // 52: mov
    reg_tmp5 = uniforms.f[5].yyyy;
    // 53: mov
    reg_tmp6 = uniforms.f[5].yyyy;
    // 54: mov
    reg_tmp7 = uniforms.f[5].yyyy;
    return false;
}
bool sub_56_59() {
    // 56: mov
    reg_tmp5 = uniforms.f[5].xxyy;
    // 57: mov
    reg_tmp6 = uniforms.f[5].xxyy;
    // 58: mov
    reg_tmp7 = uniforms.f[5].xxyy;
    return false;
}
bool sub_60_63() {
    // 60: mov
    reg_tmp5 = uniforms.f[5].yxyy;
    // 61: mov
    reg_tmp6 = uniforms.f[5].yxyy;
    // 62: mov
    reg_tmp7 = uniforms.f[5].yxyy;
    return false;
}
bool sub_65_99() {
    // 65: cmp
    conditional_code = equal(vec2(uniforms.f[5].yyyy), vec2(reg_tmp8));
    // 66: ifc
    if (all(conditional_code)) {
        sub_67_86();
    }
    // 86: cmp
    conditional_code = lessThan(vec2(uniforms.f[5].wwww), vec2(reg_tmp8));
    // 87: ifc
    if (all(conditional_code)) {
        sub_88_98();
    }
    // 98: add
    reg_tmp8 = uniforms.f[5].yyyy + reg_tmp8;
    return false;
}
bool sub_67_86() {
    // 67: mova
    address_registers.y = (ivec2(reg_tmp0.zzzz)).y;
    // 68: cmp
    conditional_code = notEqual(vec2(uniforms.f[5].xxxx), vec2(reg_tmp1.xyyy));
    // 69: ifc
    if (all(not(conditional_code))) {
        sub_70_73();
    }
    // 73: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_74_77();
    }
    // 77: ifc
    if (all(bvec2(!conditional_code.x, conditional_code.y))) {
        sub_78_81();
    }
    // 81: ifc
    if (all(conditional_code)) {
        sub_82_85();
    }
    // 85: nop
    return false;
}
bool sub_70_73() {
    // 70: mov
    reg_tmp5.xy = (uniforms.f[64 + address_registers.y].wzzz).xy;
    // 71: mov
    reg_tmp6.xy = (uniforms.f[65 + address_registers.y].wzzz).xy;
    // 72: mov
    reg_tmp7.xy = (uniforms.f[66 + address_registers.y].wzzz).xy;
    return false;
}
bool sub_74_77() {
    // 74: mov
    reg_tmp5.xy = (uniforms.f[64 + address_registers.y].yzzz).xy;
    // 75: mov
    reg_tmp6.xy = (uniforms.f[65 + address_registers.y].yzzz).xy;
    // 76: mov
    reg_tmp7.xy = (uniforms.f[66 + address_registers.y].yzzz).xy;
    return false;
}
bool sub_78_81() {
    // 78: mov
    reg_tmp5.xy = (uniforms.f[64 + address_registers.y].wxxx).xy;
    // 79: mov
    reg_tmp6.xy = (uniforms.f[65 + address_registers.y].wxxx).xy;
    // 80: mov
    reg_tmp7.xy = (uniforms.f[66 + address_registers.y].wxxx).xy;
    return false;
}
bool sub_82_85() {
    // 82: mov
    reg_tmp5.xy = (uniforms.f[64 + address_registers.y].yxxx).xy;
    // 83: mov
    reg_tmp6.xy = (uniforms.f[65 + address_registers.y].yxxx).xy;
    // 84: mov
    reg_tmp7.xy = (uniforms.f[66 + address_registers.y].yxxx).xy;
    return false;
}
bool sub_88_98() {
    // 88: cmp
    conditional_code = notEqual(vec2(uniforms.f[5].xxxx), vec2(reg_tmp1.xyyy));
    // 89: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_90_93();
    }
    // 93: ifc
    if (all(bvec2(!conditional_code.x, conditional_code.y))) {
        sub_94_97();
    }
    // 97: nop
    return false;
}
bool sub_90_93() {
    // 90: mov
    reg_tmp5.xy = (uniforms.f[67 + address_registers.y].yxxx).xy;
    // 91: mov
    reg_tmp6.xy = (uniforms.f[68 + address_registers.y].yxxx).xy;
    // 92: mov
    reg_tmp7.xy = (uniforms.f[69 + address_registers.y].yxxx).xy;
    return false;
}
bool sub_94_97() {
    // 94: mov
    reg_tmp5.xy = (uniforms.f[67 + address_registers.y].wzzz).xy;
    // 95: mov
    reg_tmp6.xy = (uniforms.f[68 + address_registers.y].wzzz).xy;
    // 96: mov
    reg_tmp7.xy = (uniforms.f[69 + address_registers.y].wzzz).xy;
    return false;
}
// reference: A0955C54D9E84639, BF583C1F84D94483
// program: BF583C1F84D94483, 5D764F9A6220D694, 6A138F8AFA46FAFC
// reference: 39C024150251E77E, BF583C1F84D94483
// program: BF583C1F84D94483, 5D764F9A6220D694, BDD69B95D0B1B7E1
// program: BF583C1F84D94483, 5D764F9A6220D694, 870F66C2585EC0BC
// program: 4EFF2C77DB8F9E73, 3B3AE026C742C7D5, 4AD2C97240195A76
// program: 4EFF2C77DB8F9E73, 3B3AE026C742C7D5, 666154B1BFC0A909
// program: 4EFF2C77DB8F9E73, 3B3AE026C742C7D5, C27F787C261C6045
// program: 4EFF2C77DB8F9E73, 3B3AE026C742C7D5, C74CA00DB8E95117
// shader: 8B31, 17716008BB716A8F

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;
 out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define mul_safe(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define rcp_safe(x) (1.0f / x)
#define rsq_safe(x) inversesqrt(x)
#define fma_safe(x, y, z) (mul_safe(x, y) + z)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_56_61();
bool sub_61_70();
bool sub_70_83();
bool sub_83_251();
bool sub_89_189();
bool sub_96_125();
bool sub_107_111();
bool sub_125_184();
bool sub_126_158();
bool sub_137_141();
bool sub_158_183();
bool sub_169_173();
bool sub_189_250();
bool sub_192_202();
bool sub_202_207();
bool sub_208_220();
bool sub_220_245();
bool sub_221_239();
bool sub_239_244();
bool sub_251_268();
bool sub_268_344();
bool sub_307_327();
bool sub_308_313();
bool sub_313_326();
bool sub_317_320();
bool sub_320_325();
bool sub_327_340();
bool sub_328_333();
bool sub_333_339();
bool sub_344_4096();
bool sub_351_356();
bool sub_353_354();
bool sub_358_359();
bool sub_362_374();
bool sub_364_365();
bool sub_365_369();
bool sub_366_367();
bool sub_367_368();
bool sub_374_384();
bool sub_388_389();
bool sub_389_393();
bool sub_390_391();
bool sub_391_392();
bool sub_401_402();
bool sub_402_406();
bool sub_403_404();
bool sub_404_405();

bool exec_shader() {
    sub_344_4096();
    return true;
}

bool sub_56_61() {
    // 56: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 57: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 58: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 59: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 60: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    return false;
}
bool sub_61_70() {
    // 61: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 62: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 63: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 64: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 65: dp3
    reg_tmp4.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 66: dp3
    reg_tmp4.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 67: dp3
    reg_tmp4.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 68: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 69: mad
    reg_tmp12 = fma_safe(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_70_83() {
    // 70: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 71: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 72: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 73: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 74: dp3
    reg_tmp4.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 75: dp3
    reg_tmp4.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 76: dp3
    reg_tmp4.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 77: dp3
    reg_tmp5.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 78: dp3
    reg_tmp5.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 79: dp3
    reg_tmp5.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 80: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 81: mad
    reg_tmp12 = fma_safe(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    // 82: mad
    reg_tmp11 = fma_safe(reg_tmp1.wwww, reg_tmp5, reg_tmp11);
    return false;
}
bool sub_83_251() {
    // 83: mul
    reg_tmp15.xyz = (mul_safe(uniforms.f[7].xxxx, vs_in_reg0)).xyz;
    // 84: mul
    reg_tmp14.xyz = (mul_safe(uniforms.f[7].yyyy, vs_in_reg1)).xyz;
    // 85: mul
    reg_tmp13.xyz = (mul_safe(uniforms.f[7].zzzz, vs_in_reg2)).xyz;
    // 86: add
    reg_tmp15.xyz = (uniforms.f[6] + reg_tmp15).xyz;
    // 87: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 88: ifu
    if (uniforms.b[1]) {
        sub_89_189();
    } else {
        sub_189_250();
    }
    // 250: nop
    return false;
}
bool sub_89_189() {
    // 89: mov
    reg_tmp0 = uniforms.f[7];
    // 90: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.yzzz));
    // 91: mov
    reg_tmp7 = uniforms.f[93].xxxx;
    // 92: mov
    reg_tmp12 = uniforms.f[93].xxxx;
    // 93: mov
    reg_tmp11 = uniforms.f[93].xxxx;
    // 94: mul
    reg_tmp2 = mul_safe(uniforms.f[93].wwww, vs_in_reg7);
    // 95: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_96_125();
    } else {
        sub_125_184();
    }
    // 184: mov
    vs_out_attr2 = -reg_tmp15;
    // 185: dp4
    vs_out_attr0.x = dot(mul_safe(uniforms.f[86], reg_tmp15), vec4(1.0));
    // 186: dp4
    vs_out_attr0.y = dot(mul_safe(uniforms.f[87], reg_tmp15), vec4(1.0));
    // 187: dp4
    vs_out_attr0.z = dot(mul_safe(uniforms.f[88], reg_tmp15), vec4(1.0));
    // 188: dp4
    vs_out_attr0.w = dot(mul_safe(uniforms.f[89], reg_tmp15), vec4(1.0));
    return false;
}
bool sub_96_125() {
    // 96: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 97: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 98: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 99: call
    {
        sub_61_70();
    }
    // 100: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 101: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 102: call
    {
        sub_61_70();
    }
    // 103: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 104: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 105: callc
    if (conditional_code.x) {
        sub_61_70();
    }
    // 106: ifu
    if (uniforms.b[8]) {
        sub_107_111();
    }
    // 111: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 112: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 113: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 114: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 115: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 116: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 117: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 118: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 119: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 120: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 121: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 122: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 123: call
    {
        sub_251_268();
    }
    // 124: nop
    return false;
}
bool sub_107_111() {
    // 107: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 108: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 109: callc
    if (conditional_code.y) {
        sub_61_70();
    }
    // 110: nop
    return false;
}
bool sub_125_184() {
    // 125: ifc
    if (all(conditional_code)) {
        sub_126_158();
    } else {
        sub_158_183();
    }
    // 183: nop
    return false;
}
bool sub_126_158() {
    // 126: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 127: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 128: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 129: call
    {
        sub_70_83();
    }
    // 130: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 131: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 132: call
    {
        sub_70_83();
    }
    // 133: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 134: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 135: callc
    if (conditional_code.x) {
        sub_70_83();
    }
    // 136: ifu
    if (uniforms.b[8]) {
        sub_137_141();
    }
    // 141: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 142: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 143: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 144: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 145: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 146: dp3
    reg_tmp13.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp11)), vec3(1.0));
    // 147: dp3
    reg_tmp13.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp11)), vec3(1.0));
    // 148: dp3
    reg_tmp13.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp11)), vec3(1.0));
    // 149: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 150: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 151: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 152: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 153: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 154: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 155: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 156: call
    {
        sub_268_344();
    }
    // 157: nop
    return false;
}
bool sub_137_141() {
    // 137: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 138: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 139: callc
    if (conditional_code.y) {
        sub_70_83();
    }
    // 140: nop
    return false;
}
bool sub_158_183() {
    // 158: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 159: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 160: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 161: call
    {
        sub_56_61();
    }
    // 162: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 163: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 164: call
    {
        sub_56_61();
    }
    // 165: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 166: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 167: callc
    if (conditional_code.x) {
        sub_56_61();
    }
    // 168: ifu
    if (uniforms.b[8]) {
        sub_169_173();
    }
    // 173: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 174: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 175: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 176: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 177: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 178: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 179: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 180: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 181: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 182: mov
    vs_out_attr1 = uniforms.f[93].xxxx;
    return false;
}
bool sub_169_173() {
    // 169: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 170: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 171: callc
    if (conditional_code.y) {
        sub_56_61();
    }
    // 172: nop
    return false;
}
bool sub_189_250() {
    // 189: mov
    reg_tmp0 = uniforms.f[7];
    // 190: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.yzzz));
    // 191: ifu
    if (uniforms.b[2]) {
        sub_192_202();
    } else {
        sub_202_207();
    }
    // 207: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_208_220();
    } else {
        sub_220_245();
    }
    // 245: mov
    vs_out_attr2 = -reg_tmp15;
    // 246: dp4
    vs_out_attr0.x = dot(mul_safe(uniforms.f[86], reg_tmp15), vec4(1.0));
    // 247: dp4
    vs_out_attr0.y = dot(mul_safe(uniforms.f[87], reg_tmp15), vec4(1.0));
    // 248: dp4
    vs_out_attr0.z = dot(mul_safe(uniforms.f[88], reg_tmp15), vec4(1.0));
    // 249: dp4
    vs_out_attr0.w = dot(mul_safe(uniforms.f[89], reg_tmp15), vec4(1.0));
    return false;
}
bool sub_192_202() {
    // 192: mul
    reg_tmp1.x = (mul_safe(uniforms.f[93].wwww, vs_in_reg7.xxxx)).x;
    // 193: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 194: dp4
    reg_tmp7.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 195: dp4
    reg_tmp7.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 196: dp4
    reg_tmp7.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 197: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 198: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 199: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 200: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 201: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_202_207() {
    // 202: mova
    address_registers.x = (ivec2(uniforms.f[93].xxxx)).x;
    // 203: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[25], reg_tmp15), vec4(1.0));
    // 204: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[26], reg_tmp15), vec4(1.0));
    // 205: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[27], reg_tmp15), vec4(1.0));
    // 206: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_208_220() {
    // 208: dp3
    reg_tmp12.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 209: dp3
    reg_tmp12.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 210: dp3
    reg_tmp12.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 211: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 212: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 213: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 214: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 215: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 216: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 217: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 218: call
    {
        sub_251_268();
    }
    // 219: nop
    return false;
}
bool sub_220_245() {
    // 220: ifc
    if (all(conditional_code)) {
        sub_221_239();
    } else {
        sub_239_244();
    }
    // 244: nop
    return false;
}
bool sub_221_239() {
    // 221: dp3
    reg_tmp12.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 222: dp3
    reg_tmp12.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 223: dp3
    reg_tmp12.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 224: dp3
    reg_tmp11.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 225: dp3
    reg_tmp11.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 226: dp3
    reg_tmp11.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 227: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 228: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 229: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 230: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 231: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 232: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 233: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 234: dp3
    reg_tmp13.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp11)), vec3(1.0));
    // 235: dp3
    reg_tmp13.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp11)), vec3(1.0));
    // 236: dp3
    reg_tmp13.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp11)), vec3(1.0));
    // 237: call
    {
        sub_268_344();
    }
    // 238: nop
    return false;
}
bool sub_239_244() {
    // 239: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 240: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 241: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 242: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 243: mov
    vs_out_attr1 = uniforms.f[93].xxxx;
    return false;
}
bool sub_251_268() {
    uint jmp_to = 251u;
    while (true) {
        switch (jmp_to) {
        case 251u: {
            // 251: dp3
            reg_tmp6.x = dot(vec3(mul_safe(reg_tmp14, reg_tmp14)), vec3(1.0));
            // 252: dp3
            reg_tmp7.x = dot(vec3(mul_safe(reg_tmp12, reg_tmp12)), vec3(1.0));
            // 253: rsq
            reg_tmp6.x = rsq_safe(reg_tmp6.xxxx.x);
            // 254: rsq
            reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
            // 255: mul
            reg_tmp14.xyz = (mul_safe(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 256: mul
            reg_tmp12.xyz = (mul_safe(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 257: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 258: jmpu
            if (!uniforms.b[15]) {
                { jmp_to = 267u; break; }
            }
            // 259: add
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            // 260: mul
            reg_tmp4 = mul_safe(uniforms.f[94].zzzz, reg_tmp4);
            // 261: cmp
            conditional_code = greaterThanEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp4.xxxx));
            // 262: rsq
            reg_tmp4 = vec4(rsq_safe(reg_tmp4.xxxx.x));
            // 263: mul
            reg_tmp5 = mul_safe(uniforms.f[94].zzzz, reg_tmp14);
            // 264: jmpc
            if (conditional_code.x) {
                { jmp_to = 267u; break; }
            }
            // 265: rcp
            reg_tmp0.z = rcp_safe(reg_tmp4.xxxx.x);
            // 266: mul
            reg_tmp0.xy = (mul_safe(reg_tmp5, reg_tmp4)).xy;
        }
        case 267u: {
            // 267: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_268_344() {
    uint jmp_to = 268u;
    while (true) {
        switch (jmp_to) {
        case 268u: {
            // 268: dp3
            reg_tmp6.x = dot(vec3(mul_safe(reg_tmp14, reg_tmp14)), vec3(1.0));
            // 269: dp3
            reg_tmp7.x = dot(vec3(mul_safe(reg_tmp12, reg_tmp12)), vec3(1.0));
            // 270: rsq
            reg_tmp6.x = rsq_safe(reg_tmp6.xxxx.x);
            // 271: rsq
            reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
            // 272: mul
            reg_tmp14.xyz = (mul_safe(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 273: mul
            reg_tmp12.xyz = (mul_safe(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 274: mul
            reg_tmp13.xyz = (mul_safe(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            // 275: mul
            reg_tmp11.xyz = (mul_safe(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            // 276: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 277: jmpu
            if (!uniforms.b[15]) {
                { jmp_to = 343u; break; }
            }
            // 278: mul
            reg_tmp13.xyz = (mul_safe(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            // 279: mul
            reg_tmp11.xyz = (mul_safe(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            // 280: mul
            reg_tmp5 = mul_safe(reg_tmp14.yzxx, reg_tmp13.zxyy);
            // 281: mad
            reg_tmp5 = fma_safe(-reg_tmp13.yzxx, reg_tmp14.zxyy, reg_tmp5);
            // 282: dp3
            reg_tmp5.w = dot(vec3(mul_safe(reg_tmp5, reg_tmp5)), vec3(1.0));
            // 283: rsq
            reg_tmp5.w = rsq_safe(reg_tmp5.wwww.x);
            // 284: mul
            reg_tmp5 = mul_safe(reg_tmp5, reg_tmp5.wwww);
            // 285: add
            reg_tmp6.w = (reg_tmp14.zzzz + reg_tmp5.yyyy).w;
            // 286: mul
            reg_tmp13 = mul_safe(reg_tmp5.yzxx, reg_tmp14.zxyy);
            // 287: mad
            reg_tmp13 = fma_safe(-reg_tmp14.yzxx, reg_tmp5.zxyy, reg_tmp13);
            // 288: add
            reg_tmp6.w = (reg_tmp13.xxxx + reg_tmp6).w;
            // 289: mov
            reg_tmp13.w = (reg_tmp5.zzzz).w;
            // 290: mov
            reg_tmp5.z = (reg_tmp13.xxxx).z;
            // 291: add
            reg_tmp6.w = (uniforms.f[93].yyyy + reg_tmp6).w;
            // 292: mov
            reg_tmp14.w = (reg_tmp5.xxxx).w;
            // 293: mov
            reg_tmp5.x = (reg_tmp14.zzzz).x;
            // 294: cmp
            conditional_code = lessThan(vec2(uniforms.f[94].yyyy), vec2(reg_tmp6.wwww));
            // 295: mov
            reg_tmp6.x = (uniforms.f[93].yyyy).x;
            // 296: mov
            reg_tmp6.y = (-uniforms.f[93].yyyy).y;
            // 297: jmpc
            if (!conditional_code.x) {
                { jmp_to = 305u; break; }
            }
            // 298: add
            reg_tmp7.xz = (reg_tmp13.wwyy + -reg_tmp14.yyww).xz;
            // 299: add
            reg_tmp7.y = (reg_tmp14.xxxx + -reg_tmp13.zzzz).y;
            // 300: mov
            reg_tmp7.w = (reg_tmp6).w;
            // 301: dp4
            reg_tmp6 = vec4(dot(mul_safe(reg_tmp7, reg_tmp7), vec4(1.0)));
            // 302: rsq
            reg_tmp6 = vec4(rsq_safe(reg_tmp6.xxxx.x));
            // 303: mul
            reg_tmp0 = mul_safe(reg_tmp7, reg_tmp6);
            // 304: jmpu
            if (uniforms.b[0]) {
                { jmp_to = 343u; break; }
            }
        }
        case 305u: {
            // 305: cmp
            conditional_code = greaterThan(vec2(reg_tmp5.zyyy), vec2(reg_tmp5.yxxx));
            // 306: ifc
            if (conditional_code.x) {
                sub_307_327();
            } else {
                sub_327_340();
            }
            // 340: dp4
            reg_tmp6 = vec4(dot(mul_safe(reg_tmp8, reg_tmp8), vec4(1.0)));
            // 341: rsq
            reg_tmp6 = vec4(rsq_safe(reg_tmp6.xxxx.x));
            // 342: mul
            reg_tmp0 = mul_safe(reg_tmp8, reg_tmp6);
        }
        case 343u: {
            // 343: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_307_327() {
    // 307: ifc
    if (conditional_code.y) {
        sub_308_313();
    } else {
        sub_313_326();
    }
    // 326: mov
    reg_tmp8.w = (-reg_tmp8).w;
    return false;
}
bool sub_308_313() {
    // 308: mul
    reg_tmp8 = mul_safe(reg_tmp13.yyzw, reg_tmp6.xxxy);
    // 309: add
    reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
    // 310: add
    reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
    // 311: add
    reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
    // 312: add
    reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
    return false;
}
bool sub_313_326() {
    // 313: cmp
    conditional_code = greaterThan(vec2(reg_tmp5.zzzz), vec2(reg_tmp5.xxxx));
    // 314: mul
    reg_tmp8 = mul_safe(reg_tmp13.yyzw, reg_tmp6.xxxy);
    // 315: add
    reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
    // 316: ifc
    if (conditional_code.x) {
        sub_317_320();
    } else {
        sub_320_325();
    }
    // 325: nop
    return false;
}
bool sub_317_320() {
    // 317: add
    reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
    // 318: add
    reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
    // 319: add
    reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
    return false;
}
bool sub_320_325() {
    // 320: mul
    reg_tmp8 = mul_safe(reg_tmp13.zwwy, reg_tmp6.xxxy);
    // 321: add
    reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
    // 322: add
    reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
    // 323: add
    reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
    // 324: add
    reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
    return false;
}
bool sub_327_340() {
    // 327: ifc
    if (conditional_code.y) {
        sub_328_333();
    } else {
        sub_333_339();
    }
    // 339: nop
    return false;
}
bool sub_328_333() {
    // 328: mul
    reg_tmp8 = mul_safe(reg_tmp13.yywz, reg_tmp6.xxxy);
    // 329: add
    reg_tmp8.y = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).y;
    // 330: add
    reg_tmp9 = reg_tmp5.yyyy + -reg_tmp5.xxxx;
    // 331: add
    reg_tmp8.xzw = (reg_tmp8 + reg_tmp14.wwyx).xzw;
    // 332: add
    reg_tmp8.y = (reg_tmp9 + reg_tmp8).y;
    return false;
}
bool sub_333_339() {
    // 333: mul
    reg_tmp8 = mul_safe(reg_tmp13.zwwy, reg_tmp6.xxxy);
    // 334: add
    reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
    // 335: add
    reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
    // 336: add
    reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
    // 337: add
    reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
    // 338: mov
    reg_tmp8.w = (-reg_tmp8).w;
    return false;
}
bool sub_344_4096() {
    // 344: call
    {
        sub_83_251();
    }
    // 345: mov
    reg_tmp8.xy = (uniforms.f[93].xxxx).xy;
    // 346: mov
    reg_tmp0.y = (uniforms.f[7].wwww).y;
    // 347: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.xyyy));
    // 348: mov
    reg_tmp9.xyz = (uniforms.f[93].xxxx).xyz;
    // 349: mov
    reg_tmp9.w = (uniforms.f[21].wwww).w;
    // 350: ifc
    if (conditional_code.y) {
        sub_351_356();
    }
    // 356: cmp
    conditional_code = equal(vec2(uniforms.f[93].xxxx), vec2(reg_tmp8.xyyy));
    // 357: ifc
    if (all(conditional_code)) {
        sub_358_359();
    }
    // 359: max
    vs_out_attr3 = max(uniforms.f[93].xxxx, reg_tmp9);
    // 360: mov
    reg_tmp0.xy = (uniforms.f[10].xxxx).xy;
    // 361: ifu
    if (uniforms.b[9]) {
        sub_362_374();
    } else {
        sub_374_384();
    }
    // 384: nop
    // 385: mov
    reg_tmp0.xy = (uniforms.f[10].yyyy).xy;
    // 386: cmp
    conditional_code = equal(vec2(uniforms.f[93].yzzz), vec2(reg_tmp0.xyyy));
    // 387: ifc
    if (all(not(conditional_code))) {
        sub_388_389();
    } else {
        sub_389_393();
    }
    // 393: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 394: dp4
    reg_tmp4.x = dot(mul_safe(uniforms.f[14].xywz, reg_tmp6), vec4(1.0));
    // 395: dp4
    reg_tmp4.y = dot(mul_safe(uniforms.f[15].xywz, reg_tmp6), vec4(1.0));
    // 396: mov
    vs_out_attr5 = reg_tmp4;
    // 397: nop
    // 398: mov
    reg_tmp0.xy = (uniforms.f[10].zzzz).xy;
    // 399: cmp
    conditional_code = equal(vec2(uniforms.f[93].yzzz), vec2(reg_tmp0.xyyy));
    // 400: ifc
    if (all(not(conditional_code))) {
        sub_401_402();
    } else {
        sub_402_406();
    }
    // 406: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 407: dp4
    reg_tmp5.x = dot(mul_safe(uniforms.f[17].xywz, reg_tmp6), vec4(1.0));
    // 408: dp4
    reg_tmp5.y = dot(mul_safe(uniforms.f[18].xywz, reg_tmp6), vec4(1.0));
    // 409: mov
    vs_out_attr6 = reg_tmp5;
    // 410: nop
    // 411: end
    return true;
}
bool sub_351_356() {
    // 351: mul
    reg_tmp0 = mul_safe(uniforms.f[7].wwww, vs_in_reg3);
    // 352: ifu
    if (uniforms.b[7]) {
        sub_353_354();
    }
    // 354: mul
    reg_tmp9.xyz = (mul_safe(uniforms.f[20].wwww, reg_tmp0.xyzz)).xyz;
    // 355: mov
    reg_tmp8.x = (uniforms.f[93].yyyy).x;
    return false;
}
bool sub_353_354() {
    // 353: mul
    reg_tmp9.w = (mul_safe(reg_tmp9.wwww, reg_tmp0.wwww)).w;
    return false;
}
bool sub_358_359() {
    // 358: mov
    reg_tmp9 = uniforms.f[21];
    return false;
}
bool sub_362_374() {
    // 362: cmp
    conditional_code = equal(vec2(uniforms.f[93].yzzz), vec2(reg_tmp0.xyyy));
    // 363: ifc
    if (all(not(conditional_code))) {
        sub_364_365();
    } else {
        sub_365_369();
    }
    // 369: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 370: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[11].xywz, reg_tmp6), vec4(1.0));
    // 371: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[12].xywz, reg_tmp6), vec4(1.0));
    // 372: mov
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    // 373: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_364_365() {
    // 364: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
    return false;
}
bool sub_365_369() {
    // 365: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_366_367();
    } else {
        sub_367_368();
    }
    // 368: nop
    return false;
}
bool sub_366_367() {
    // 366: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
    return false;
}
bool sub_367_368() {
    // 367: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
    return false;
}
bool sub_374_384() {
    // 374: cmp
    conditional_code = equal(vec2(uniforms.f[95].xyyy), vec2(reg_tmp0.xyyy));
    // 375: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 376: mov
    reg_tmp6 = reg_tmp10;
    // 377: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[11], reg_tmp6), vec4(1.0));
    // 378: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[12], reg_tmp6), vec4(1.0));
    // 379: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[13], reg_tmp6), vec4(1.0));
    // 380: mul
    reg_tmp0.xy = (mul_safe(uniforms.f[19].xyyy, reg_tmp3.zzzz)).xy;
    // 381: add
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    // 382: nop
    // 383: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_388_389() {
    // 388: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
    return false;
}
bool sub_389_393() {
    // 389: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_390_391();
    } else {
        sub_391_392();
    }
    // 392: nop
    return false;
}
bool sub_390_391() {
    // 390: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
    return false;
}
bool sub_391_392() {
    // 391: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
    return false;
}
bool sub_401_402() {
    // 401: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
    return false;
}
bool sub_402_406() {
    // 402: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_403_404();
    } else {
        sub_404_405();
    }
    // 405: nop
    return false;
}
bool sub_403_404() {
    // 403: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
    return false;
}
bool sub_404_405() {
    // 404: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
    return false;
}
// reference: 64BD0C9E1CF0DF0D, 17716008BB716A8F
// program: 17716008BB716A8F, AD7922A63ED54CA7, C74CA00DB8E95117
// shader: 8B31, E661110CC0BF42D1

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define mul_safe(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define rcp_safe(x) (1.0f / x)
#define rsq_safe(x) inversesqrt(x)
#define fma_safe(x, y, z) (mul_safe(x, y) + z)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_4096();
bool sub_7_12();
bool sub_9_10();
bool sub_14_15();
bool sub_18_30();
bool sub_20_21();
bool sub_21_25();
bool sub_22_23();
bool sub_23_24();
bool sub_30_40();
bool sub_44_45();
bool sub_45_49();
bool sub_46_47();
bool sub_47_48();
bool sub_56_61();
bool sub_61_70();
bool sub_70_83();
bool sub_83_293();
bool sub_89_210();
bool sub_96_130();
bool sub_107_111();
bool sub_130_199();
bool sub_131_168();
bool sub_142_146();
bool sub_168_198();
bool sub_179_183();
bool sub_208_209();
bool sub_210_292();
bool sub_211_221();
bool sub_221_226();
bool sub_229_246();
bool sub_246_281();
bool sub_247_270();
bool sub_270_280();
bool sub_290_291();
bool sub_293_310();
bool sub_310_386();
bool sub_349_369();
bool sub_350_355();
bool sub_355_368();
bool sub_359_362();
bool sub_362_367();
bool sub_369_382();
bool sub_370_375();
bool sub_375_381();

bool exec_shader() {
    sub_0_4096();
    return true;
}

bool sub_0_4096() {
    // 0: call
    {
        sub_83_293();
    }
    // 1: mov
    reg_tmp8.xy = (uniforms.f[93].xxxx).xy;
    // 2: mov
    reg_tmp0.y = (uniforms.f[7].wwww).y;
    // 3: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.xyyy));
    // 4: mov
    reg_tmp9.xyz = (uniforms.f[93].xxxx).xyz;
    // 5: mov
    reg_tmp9.w = (uniforms.f[21].wwww).w;
    // 6: ifc
    if (conditional_code.y) {
        sub_7_12();
    }
    // 12: cmp
    conditional_code = equal(vec2(uniforms.f[93].xxxx), vec2(reg_tmp8.xyyy));
    // 13: ifc
    if (all(conditional_code)) {
        sub_14_15();
    }
    // 15: max
    vs_out_attr3 = max(uniforms.f[93].xxxx, reg_tmp9);
    // 16: mov
    reg_tmp0.xy = (uniforms.f[10].xxxx).xy;
    // 17: ifu
    if (uniforms.b[9]) {
        sub_18_30();
    } else {
        sub_30_40();
    }
    // 40: nop
    // 41: mov
    reg_tmp0.xy = (uniforms.f[10].yyyy).xy;
    // 42: cmp
    conditional_code = equal(vec2(uniforms.f[93].yzzz), vec2(reg_tmp0.xyyy));
    // 43: ifc
    if (all(not(conditional_code))) {
        sub_44_45();
    } else {
        sub_45_49();
    }
    // 49: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 50: dp4
    reg_tmp4.x = dot(mul_safe(uniforms.f[14].xywz, reg_tmp6), vec4(1.0));
    // 51: dp4
    reg_tmp4.y = dot(mul_safe(uniforms.f[15].xywz, reg_tmp6), vec4(1.0));
    // 52: mov
    vs_out_attr5 = reg_tmp4;
    // 53: nop
    // 54: end
    return true;
}
bool sub_7_12() {
    // 7: mul
    reg_tmp0 = mul_safe(uniforms.f[7].wwww, vs_in_reg3);
    // 8: ifu
    if (uniforms.b[7]) {
        sub_9_10();
    }
    // 10: mul
    reg_tmp9.xyz = (mul_safe(uniforms.f[20].wwww, reg_tmp0.xyzz)).xyz;
    // 11: mov
    reg_tmp8.x = (uniforms.f[93].yyyy).x;
    return false;
}
bool sub_9_10() {
    // 9: mul
    reg_tmp9.w = (mul_safe(reg_tmp9.wwww, reg_tmp0.wwww)).w;
    return false;
}
bool sub_14_15() {
    // 14: mov
    reg_tmp9 = uniforms.f[21];
    return false;
}
bool sub_18_30() {
    // 18: cmp
    conditional_code = equal(vec2(uniforms.f[93].yzzz), vec2(reg_tmp0.xyyy));
    // 19: ifc
    if (all(not(conditional_code))) {
        sub_20_21();
    } else {
        sub_21_25();
    }
    // 25: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 26: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[11].xywz, reg_tmp6), vec4(1.0));
    // 27: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[12].xywz, reg_tmp6), vec4(1.0));
    // 28: mov
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    // 29: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_20_21() {
    // 20: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
    return false;
}
bool sub_21_25() {
    // 21: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_22_23();
    } else {
        sub_23_24();
    }
    // 24: nop
    return false;
}
bool sub_22_23() {
    // 22: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
    return false;
}
bool sub_23_24() {
    // 23: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
    return false;
}
bool sub_30_40() {
    // 30: cmp
    conditional_code = equal(vec2(uniforms.f[95].xyyy), vec2(reg_tmp0.xyyy));
    // 31: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 32: mov
    reg_tmp6 = reg_tmp10;
    // 33: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[11], reg_tmp6), vec4(1.0));
    // 34: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[12], reg_tmp6), vec4(1.0));
    // 35: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[13], reg_tmp6), vec4(1.0));
    // 36: mul
    reg_tmp0.xy = (mul_safe(uniforms.f[19].xyyy, reg_tmp3.zzzz)).xy;
    // 37: add
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    // 38: nop
    // 39: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_44_45() {
    // 44: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
    return false;
}
bool sub_45_49() {
    // 45: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_46_47();
    } else {
        sub_47_48();
    }
    // 48: nop
    return false;
}
bool sub_46_47() {
    // 46: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
    return false;
}
bool sub_47_48() {
    // 47: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
    return false;
}
bool sub_56_61() {
    // 56: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 57: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 58: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 59: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 60: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    return false;
}
bool sub_61_70() {
    // 61: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 62: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 63: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 64: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 65: dp3
    reg_tmp4.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 66: dp3
    reg_tmp4.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 67: dp3
    reg_tmp4.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 68: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 69: mad
    reg_tmp12 = fma_safe(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_70_83() {
    // 70: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 71: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 72: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 73: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 74: dp3
    reg_tmp4.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 75: dp3
    reg_tmp4.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 76: dp3
    reg_tmp4.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 77: dp3
    reg_tmp5.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 78: dp3
    reg_tmp5.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 79: dp3
    reg_tmp5.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 80: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 81: mad
    reg_tmp12 = fma_safe(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    // 82: mad
    reg_tmp11 = fma_safe(reg_tmp1.wwww, reg_tmp5, reg_tmp11);
    return false;
}
bool sub_83_293() {
    // 83: mul
    reg_tmp15.xyz = (mul_safe(uniforms.f[7].xxxx, vs_in_reg0)).xyz;
    // 84: mul
    reg_tmp14.xyz = (mul_safe(uniforms.f[7].yyyy, vs_in_reg1)).xyz;
    // 85: mul
    reg_tmp13.xyz = (mul_safe(uniforms.f[7].zzzz, vs_in_reg2)).xyz;
    // 86: add
    reg_tmp15.xyz = (uniforms.f[6] + reg_tmp15).xyz;
    // 87: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 88: ifu
    if (uniforms.b[1]) {
        sub_89_210();
    } else {
        sub_210_292();
    }
    // 292: nop
    return false;
}
bool sub_89_210() {
    // 89: mov
    reg_tmp0 = uniforms.f[7];
    // 90: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.yzzz));
    // 91: mov
    reg_tmp7 = uniforms.f[93].xxxx;
    // 92: mov
    reg_tmp12 = uniforms.f[93].xxxx;
    // 93: mov
    reg_tmp11 = uniforms.f[93].xxxx;
    // 94: mul
    reg_tmp2 = mul_safe(uniforms.f[93].wwww, vs_in_reg7);
    // 95: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_96_130();
    } else {
        sub_130_199();
    }
    // 199: mov
    vs_out_attr2 = -reg_tmp15;
    // 200: dp4
    reg_tmp0.x = dot(mul_safe(uniforms.f[86], reg_tmp15), vec4(1.0));
    // 201: dp4
    reg_tmp0.y = dot(mul_safe(uniforms.f[87], reg_tmp15), vec4(1.0));
    // 202: dp4
    reg_tmp0.z = dot(mul_safe(uniforms.f[88], reg_tmp15), vec4(1.0));
    // 203: dp4
    reg_tmp0.w = dot(mul_safe(uniforms.f[89], reg_tmp15), vec4(1.0));
    // 204: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 205: mul
    reg_tmp1.y = (mul_safe(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
    // 206: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 207: ifc
    if (all(conditional_code)) {
        sub_208_209();
    }
    // 209: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_96_130() {
    // 96: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 97: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 98: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 99: call
    {
        sub_61_70();
    }
    // 100: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 101: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 102: call
    {
        sub_61_70();
    }
    // 103: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 104: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 105: callc
    if (conditional_code.x) {
        sub_61_70();
    }
    // 106: ifu
    if (uniforms.b[8]) {
        sub_107_111();
    }
    // 111: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 112: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 113: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 114: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 115: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 116: mov
    reg_tmp7 = reg_tmp10;
    // 117: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[22], reg_tmp7), vec4(1.0));
    // 118: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[23], reg_tmp7), vec4(1.0));
    // 119: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[24], reg_tmp7), vec4(1.0));
    // 120: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 121: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 122: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 123: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 124: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 125: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 126: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 127: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 128: call
    {
        sub_293_310();
    }
    // 129: nop
    return false;
}
bool sub_107_111() {
    // 107: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 108: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 109: callc
    if (conditional_code.y) {
        sub_61_70();
    }
    // 110: nop
    return false;
}
bool sub_130_199() {
    // 130: ifc
    if (all(conditional_code)) {
        sub_131_168();
    } else {
        sub_168_198();
    }
    // 198: nop
    return false;
}
bool sub_131_168() {
    // 131: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 132: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 133: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 134: call
    {
        sub_70_83();
    }
    // 135: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 136: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 137: call
    {
        sub_70_83();
    }
    // 138: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 139: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 140: callc
    if (conditional_code.x) {
        sub_70_83();
    }
    // 141: ifu
    if (uniforms.b[8]) {
        sub_142_146();
    }
    // 146: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 147: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 148: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 149: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 150: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 151: mov
    reg_tmp7 = reg_tmp10;
    // 152: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[22], reg_tmp7), vec4(1.0));
    // 153: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[23], reg_tmp7), vec4(1.0));
    // 154: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[24], reg_tmp7), vec4(1.0));
    // 155: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 156: dp3
    reg_tmp13.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp11)), vec3(1.0));
    // 157: dp3
    reg_tmp13.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp11)), vec3(1.0));
    // 158: dp3
    reg_tmp13.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp11)), vec3(1.0));
    // 159: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 160: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 161: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 162: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 163: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 164: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 165: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 166: call
    {
        sub_310_386();
    }
    // 167: nop
    return false;
}
bool sub_142_146() {
    // 142: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 143: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 144: callc
    if (conditional_code.y) {
        sub_70_83();
    }
    // 145: nop
    return false;
}
bool sub_168_198() {
    // 168: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 169: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 170: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 171: call
    {
        sub_56_61();
    }
    // 172: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 173: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 174: call
    {
        sub_56_61();
    }
    // 175: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 176: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 177: callc
    if (conditional_code.x) {
        sub_56_61();
    }
    // 178: ifu
    if (uniforms.b[8]) {
        sub_179_183();
    }
    // 183: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 184: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 185: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 186: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 187: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 188: mov
    reg_tmp7 = reg_tmp10;
    // 189: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[22], reg_tmp7), vec4(1.0));
    // 190: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[23], reg_tmp7), vec4(1.0));
    // 191: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[24], reg_tmp7), vec4(1.0));
    // 192: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 193: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 194: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 195: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 196: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 197: mov
    vs_out_attr1 = uniforms.f[93].xxxx;
    return false;
}
bool sub_179_183() {
    // 179: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 180: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 181: callc
    if (conditional_code.y) {
        sub_56_61();
    }
    // 182: nop
    return false;
}
bool sub_208_209() {
    // 208: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_210_292() {
    // 210: ifu
    if (uniforms.b[2]) {
        sub_211_221();
    } else {
        sub_221_226();
    }
    // 226: mov
    reg_tmp0 = uniforms.f[7];
    // 227: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.yzzz));
    // 228: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_229_246();
    } else {
        sub_246_281();
    }
    // 281: mov
    vs_out_attr2 = -reg_tmp15;
    // 282: dp4
    reg_tmp0.x = dot(mul_safe(uniforms.f[86], reg_tmp15), vec4(1.0));
    // 283: dp4
    reg_tmp0.y = dot(mul_safe(uniforms.f[87], reg_tmp15), vec4(1.0));
    // 284: dp4
    reg_tmp0.z = dot(mul_safe(uniforms.f[88], reg_tmp15), vec4(1.0));
    // 285: dp4
    reg_tmp0.w = dot(mul_safe(uniforms.f[89], reg_tmp15), vec4(1.0));
    // 286: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 287: mul
    reg_tmp1.y = (mul_safe(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
    // 288: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 289: ifc
    if (all(conditional_code)) {
        sub_290_291();
    }
    // 291: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_211_221() {
    // 211: mul
    reg_tmp1.x = (mul_safe(uniforms.f[93].wwww, vs_in_reg7.xxxx)).x;
    // 212: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 213: dp4
    reg_tmp7.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 214: dp4
    reg_tmp7.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 215: dp4
    reg_tmp7.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 216: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 217: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 218: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 219: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 220: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_221_226() {
    // 221: mova
    address_registers.x = (ivec2(uniforms.f[93].xxxx)).x;
    // 222: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[25], reg_tmp15), vec4(1.0));
    // 223: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[26], reg_tmp15), vec4(1.0));
    // 224: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[27], reg_tmp15), vec4(1.0));
    // 225: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_229_246() {
    // 229: dp3
    reg_tmp12.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 230: dp3
    reg_tmp12.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 231: dp3
    reg_tmp12.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 232: mov
    reg_tmp7 = reg_tmp10;
    // 233: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[22], reg_tmp7), vec4(1.0));
    // 234: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[23], reg_tmp7), vec4(1.0));
    // 235: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[24], reg_tmp7), vec4(1.0));
    // 236: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 237: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 238: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 239: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 240: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 241: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 242: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 243: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 244: call
    {
        sub_293_310();
    }
    // 245: nop
    return false;
}
bool sub_246_281() {
    // 246: ifc
    if (all(conditional_code)) {
        sub_247_270();
    } else {
        sub_270_280();
    }
    // 280: nop
    return false;
}
bool sub_247_270() {
    // 247: dp3
    reg_tmp12.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 248: dp3
    reg_tmp12.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 249: dp3
    reg_tmp12.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 250: dp3
    reg_tmp11.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 251: dp3
    reg_tmp11.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 252: dp3
    reg_tmp11.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 253: mov
    reg_tmp7 = reg_tmp10;
    // 254: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[22], reg_tmp7), vec4(1.0));
    // 255: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[23], reg_tmp7), vec4(1.0));
    // 256: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[24], reg_tmp7), vec4(1.0));
    // 257: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 258: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 259: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 260: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 261: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 262: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 263: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 264: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 265: dp3
    reg_tmp13.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp11)), vec3(1.0));
    // 266: dp3
    reg_tmp13.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp11)), vec3(1.0));
    // 267: dp3
    reg_tmp13.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp11)), vec3(1.0));
    // 268: call
    {
        sub_310_386();
    }
    // 269: nop
    return false;
}
bool sub_270_280() {
    // 270: mov
    reg_tmp7 = reg_tmp10;
    // 271: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[22], reg_tmp7), vec4(1.0));
    // 272: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[23], reg_tmp7), vec4(1.0));
    // 273: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[24], reg_tmp7), vec4(1.0));
    // 274: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 275: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 276: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 277: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 278: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 279: mov
    vs_out_attr1 = uniforms.f[93].xxxx;
    return false;
}
bool sub_290_291() {
    // 290: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_293_310() {
    uint jmp_to = 293u;
    while (true) {
        switch (jmp_to) {
        case 293u: {
            // 293: dp3
            reg_tmp6.x = dot(vec3(mul_safe(reg_tmp14, reg_tmp14)), vec3(1.0));
            // 294: dp3
            reg_tmp7.x = dot(vec3(mul_safe(reg_tmp12, reg_tmp12)), vec3(1.0));
            // 295: rsq
            reg_tmp6.x = rsq_safe(reg_tmp6.xxxx.x);
            // 296: rsq
            reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
            // 297: mul
            reg_tmp14.xyz = (mul_safe(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 298: mul
            reg_tmp12.xyz = (mul_safe(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 299: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 300: jmpu
            if (!uniforms.b[15]) {
                { jmp_to = 309u; break; }
            }
            // 301: add
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            // 302: mul
            reg_tmp4 = mul_safe(uniforms.f[94].zzzz, reg_tmp4);
            // 303: cmp
            conditional_code = greaterThanEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp4.xxxx));
            // 304: rsq
            reg_tmp4 = vec4(rsq_safe(reg_tmp4.xxxx.x));
            // 305: mul
            reg_tmp5 = mul_safe(uniforms.f[94].zzzz, reg_tmp14);
            // 306: jmpc
            if (conditional_code.x) {
                { jmp_to = 309u; break; }
            }
            // 307: rcp
            reg_tmp0.z = rcp_safe(reg_tmp4.xxxx.x);
            // 308: mul
            reg_tmp0.xy = (mul_safe(reg_tmp5, reg_tmp4)).xy;
        }
        case 309u: {
            // 309: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_310_386() {
    uint jmp_to = 310u;
    while (true) {
        switch (jmp_to) {
        case 310u: {
            // 310: dp3
            reg_tmp6.x = dot(vec3(mul_safe(reg_tmp14, reg_tmp14)), vec3(1.0));
            // 311: dp3
            reg_tmp7.x = dot(vec3(mul_safe(reg_tmp12, reg_tmp12)), vec3(1.0));
            // 312: rsq
            reg_tmp6.x = rsq_safe(reg_tmp6.xxxx.x);
            // 313: rsq
            reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
            // 314: mul
            reg_tmp14.xyz = (mul_safe(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 315: mul
            reg_tmp12.xyz = (mul_safe(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 316: mul
            reg_tmp13.xyz = (mul_safe(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            // 317: mul
            reg_tmp11.xyz = (mul_safe(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            // 318: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 319: jmpu
            if (!uniforms.b[15]) {
                { jmp_to = 385u; break; }
            }
            // 320: mul
            reg_tmp13.xyz = (mul_safe(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            // 321: mul
            reg_tmp11.xyz = (mul_safe(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            // 322: mul
            reg_tmp5 = mul_safe(reg_tmp14.yzxx, reg_tmp13.zxyy);
            // 323: mad
            reg_tmp5 = fma_safe(-reg_tmp13.yzxx, reg_tmp14.zxyy, reg_tmp5);
            // 324: dp3
            reg_tmp5.w = dot(vec3(mul_safe(reg_tmp5, reg_tmp5)), vec3(1.0));
            // 325: rsq
            reg_tmp5.w = rsq_safe(reg_tmp5.wwww.x);
            // 326: mul
            reg_tmp5 = mul_safe(reg_tmp5, reg_tmp5.wwww);
            // 327: add
            reg_tmp6.w = (reg_tmp14.zzzz + reg_tmp5.yyyy).w;
            // 328: mul
            reg_tmp13 = mul_safe(reg_tmp5.yzxx, reg_tmp14.zxyy);
            // 329: mad
            reg_tmp13 = fma_safe(-reg_tmp14.yzxx, reg_tmp5.zxyy, reg_tmp13);
            // 330: add
            reg_tmp6.w = (reg_tmp13.xxxx + reg_tmp6).w;
            // 331: mov
            reg_tmp13.w = (reg_tmp5.zzzz).w;
            // 332: mov
            reg_tmp5.z = (reg_tmp13.xxxx).z;
            // 333: add
            reg_tmp6.w = (uniforms.f[93].yyyy + reg_tmp6).w;
            // 334: mov
            reg_tmp14.w = (reg_tmp5.xxxx).w;
            // 335: mov
            reg_tmp5.x = (reg_tmp14.zzzz).x;
            // 336: cmp
            conditional_code = lessThan(vec2(uniforms.f[94].yyyy), vec2(reg_tmp6.wwww));
            // 337: mov
            reg_tmp6.x = (uniforms.f[93].yyyy).x;
            // 338: mov
            reg_tmp6.y = (-uniforms.f[93].yyyy).y;
            // 339: jmpc
            if (!conditional_code.x) {
                { jmp_to = 347u; break; }
            }
            // 340: add
            reg_tmp7.xz = (reg_tmp13.wwyy + -reg_tmp14.yyww).xz;
            // 341: add
            reg_tmp7.y = (reg_tmp14.xxxx + -reg_tmp13.zzzz).y;
            // 342: mov
            reg_tmp7.w = (reg_tmp6).w;
            // 343: dp4
            reg_tmp6 = vec4(dot(mul_safe(reg_tmp7, reg_tmp7), vec4(1.0)));
            // 344: rsq
            reg_tmp6 = vec4(rsq_safe(reg_tmp6.xxxx.x));
            // 345: mul
            reg_tmp0 = mul_safe(reg_tmp7, reg_tmp6);
            // 346: jmpu
            if (uniforms.b[0]) {
                { jmp_to = 385u; break; }
            }
        }
        case 347u: {
            // 347: cmp
            conditional_code = greaterThan(vec2(reg_tmp5.zyyy), vec2(reg_tmp5.yxxx));
            // 348: ifc
            if (conditional_code.x) {
                sub_349_369();
            } else {
                sub_369_382();
            }
            // 382: dp4
            reg_tmp6 = vec4(dot(mul_safe(reg_tmp8, reg_tmp8), vec4(1.0)));
            // 383: rsq
            reg_tmp6 = vec4(rsq_safe(reg_tmp6.xxxx.x));
            // 384: mul
            reg_tmp0 = mul_safe(reg_tmp8, reg_tmp6);
        }
        case 385u: {
            // 385: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_349_369() {
    // 349: ifc
    if (conditional_code.y) {
        sub_350_355();
    } else {
        sub_355_368();
    }
    // 368: mov
    reg_tmp8.w = (-reg_tmp8).w;
    return false;
}
bool sub_350_355() {
    // 350: mul
    reg_tmp8 = mul_safe(reg_tmp13.yyzw, reg_tmp6.xxxy);
    // 351: add
    reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
    // 352: add
    reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
    // 353: add
    reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
    // 354: add
    reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
    return false;
}
bool sub_355_368() {
    // 355: cmp
    conditional_code = greaterThan(vec2(reg_tmp5.zzzz), vec2(reg_tmp5.xxxx));
    // 356: mul
    reg_tmp8 = mul_safe(reg_tmp13.yyzw, reg_tmp6.xxxy);
    // 357: add
    reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
    // 358: ifc
    if (conditional_code.x) {
        sub_359_362();
    } else {
        sub_362_367();
    }
    // 367: nop
    return false;
}
bool sub_359_362() {
    // 359: add
    reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
    // 360: add
    reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
    // 361: add
    reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
    return false;
}
bool sub_362_367() {
    // 362: mul
    reg_tmp8 = mul_safe(reg_tmp13.zwwy, reg_tmp6.xxxy);
    // 363: add
    reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
    // 364: add
    reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
    // 365: add
    reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
    // 366: add
    reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
    return false;
}
bool sub_369_382() {
    // 369: ifc
    if (conditional_code.y) {
        sub_370_375();
    } else {
        sub_375_381();
    }
    // 381: nop
    return false;
}
bool sub_370_375() {
    // 370: mul
    reg_tmp8 = mul_safe(reg_tmp13.yywz, reg_tmp6.xxxy);
    // 371: add
    reg_tmp8.y = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).y;
    // 372: add
    reg_tmp9 = reg_tmp5.yyyy + -reg_tmp5.xxxx;
    // 373: add
    reg_tmp8.xzw = (reg_tmp8 + reg_tmp14.wwyx).xzw;
    // 374: add
    reg_tmp8.y = (reg_tmp9 + reg_tmp8).y;
    return false;
}
bool sub_375_381() {
    // 375: mul
    reg_tmp8 = mul_safe(reg_tmp13.zwwy, reg_tmp6.xxxy);
    // 376: add
    reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
    // 377: add
    reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
    // 378: add
    reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
    // 379: add
    reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
    // 380: mov
    reg_tmp8.w = (-reg_tmp8).w;
    return false;
}
// reference: C36AFE7DDDCC3738, E661110CC0BF42D1
// program: E661110CC0BF42D1, 3B3AE026C742C7D5, 18CD6F34EF819318
// reference: C36AFE7D32F5A479, E661110CC0BF42D1
// reference: 974AD4F76CB7FCED, 4EFF2C77DB8F9E73
// program: 4EFF2C77DB8F9E73, 3B3AE026C742C7D5, B29EF1BFC4D10886
// program: E661110CC0BF42D1, 3B3AE026C742C7D5, 85967F14F07719A7
// program: 4EFF2C77DB8F9E73, 3B3AE026C742C7D5, 98677AC22B9A3E1A
// reference: 380E46B0AD3140CF, 17716008BB716A8F
// reference: 974AD4F7838E6FAC, 4EFF2C77DB8F9E73
// shader: 8B31, 608565C51104A52F

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;
 out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define mul_safe(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define rcp_safe(x) (1.0f / x)
#define rsq_safe(x) inversesqrt(x)
#define fma_safe(x, y, z) (mul_safe(x, y) + z)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_4096();
bool sub_34_73();
bool sub_73_90();
bool sub_166_183();
bool sub_172_177();
bool sub_174_175();
bool sub_181_182();
bool sub_183_229();
bool sub_187_228();
bool sub_192_194();
bool sub_194_218();
bool sub_197_202();
bool sub_208_217();
bool sub_212_213();
bool sub_213_216();
bool sub_220_227();
bool sub_229_239();
bool sub_236_237();
bool sub_239_266();
bool sub_241_246();
bool sub_246_265();
bool sub_249_255();
bool sub_255_264();
bool sub_256_260();
bool sub_260_263();
bool sub_266_274();
bool sub_268_269();
bool sub_269_273();
bool sub_270_271();
bool sub_271_272();
bool sub_274_281();
bool sub_281_285();
bool sub_285_309();
bool sub_287_291();
bool sub_291_308();
bool sub_292_306();
bool sub_295_302();
bool sub_302_305();
bool sub_306_307();
bool sub_309_325();
bool sub_311_315();
bool sub_315_324();
bool sub_316_322();
bool sub_322_323();

bool exec_shader() {
    sub_0_4096();
    return true;
}

bool sub_0_4096() {
    // 0: call
    {
        sub_34_73();
    }
    // 1: call
    {
        sub_166_183();
    }
    // 2: call
    {
        sub_239_266();
    }
    // 3: call
    {
        sub_285_309();
    }
    // 4: call
    {
        sub_309_325();
    }
    // 5: end
    return true;
}
bool sub_34_73() {
    // 34: mul
    reg_tmp15.xyz = (mul_safe(uniforms.f[7].xxxx, vs_in_reg0)).xyz;
    // 35: mul
    reg_tmp14.xyz = (mul_safe(uniforms.f[7].yyyy, vs_in_reg1)).xyz;
    // 36: mul
    reg_tmp13.xyz = (mul_safe(uniforms.f[7].zzzz, vs_in_reg2)).xyz;
    // 37: add
    reg_tmp15.xyz = (uniforms.f[6] + reg_tmp15).xyz;
    // 38: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 39: mov
    reg_tmp0 = uniforms.f[7];
    // 40: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[25], reg_tmp15), vec4(1.0));
    // 41: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[26], reg_tmp15), vec4(1.0));
    // 42: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[27], reg_tmp15), vec4(1.0));
    // 43: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 44: dp3
    reg_tmp12.x = dot(vec3(mul_safe(uniforms.f[25], reg_tmp14)), vec3(1.0));
    // 45: dp3
    reg_tmp12.y = dot(vec3(mul_safe(uniforms.f[26], reg_tmp14)), vec3(1.0));
    // 46: dp3
    reg_tmp12.z = dot(vec3(mul_safe(uniforms.f[27], reg_tmp14)), vec3(1.0));
    // 47: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 48: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 49: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 50: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 51: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 52: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 53: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 54: call
    {
        sub_73_90();
    }
    // 55: nop
    // 56: mov
    vs_out_attr2 = -reg_tmp15;
    // 57: mov
    reg_tmp0.x = (uniforms.f[93].yyyy).x;
    // 58: mova
    address_registers.x = (ivec2(vs_in_reg3.xxxx)).x;
    // 59: mul
    reg_tmp0.x = (mul_safe(uniforms.f[28 + address_registers.x].xxxx, reg_tmp0.xxxx)).x;
    // 60: mova
    address_registers.x = (ivec2(vs_in_reg3.yyyy)).x;
    // 61: mul
    reg_tmp0.x = (mul_safe(uniforms.f[28 + address_registers.x].yyyy, reg_tmp0.xxxx)).x;
    // 62: nop
    // 63: mova
    address_registers.x = (ivec2(vs_in_reg3.zzzz)).x;
    // 64: mul
    reg_tmp0.x = (mul_safe(uniforms.f[28 + address_registers.x].zzzz, reg_tmp0.xxxx)).x;
    // 65: mova
    address_registers.x = (ivec2(vs_in_reg3.wwww)).x;
    // 66: mul
    reg_tmp0.x = (mul_safe(uniforms.f[28 + address_registers.x].wwww, reg_tmp0.xxxx)).x;
    // 67: mul
    reg_tmp15.xyz = (mul_safe(reg_tmp15.xyzz, reg_tmp0.xxxx)).xyz;
    // 68: dp4
    vs_out_attr0.x = dot(mul_safe(uniforms.f[86], reg_tmp15), vec4(1.0));
    // 69: dp4
    vs_out_attr0.y = dot(mul_safe(uniforms.f[87], reg_tmp15), vec4(1.0));
    // 70: dp4
    vs_out_attr0.z = dot(mul_safe(uniforms.f[88], reg_tmp15), vec4(1.0));
    // 71: dp4
    vs_out_attr0.w = dot(mul_safe(uniforms.f[89], reg_tmp15), vec4(1.0));
    // 72: nop
    return false;
}
bool sub_73_90() {
    uint jmp_to = 73u;
    while (true) {
        switch (jmp_to) {
        case 73u: {
            // 73: dp3
            reg_tmp6.x = dot(vec3(mul_safe(reg_tmp14, reg_tmp14)), vec3(1.0));
            // 74: dp3
            reg_tmp7.x = dot(vec3(mul_safe(reg_tmp12, reg_tmp12)), vec3(1.0));
            // 75: rsq
            reg_tmp6.x = rsq_safe(reg_tmp6.xxxx.x);
            // 76: rsq
            reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
            // 77: mul
            reg_tmp14.xyz = (mul_safe(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 78: mul
            reg_tmp12.xyz = (mul_safe(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 79: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 80: jmpu
            if (!uniforms.b[15]) {
                { jmp_to = 89u; break; }
            }
            // 81: add
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            // 82: mul
            reg_tmp4 = mul_safe(uniforms.f[94].zzzz, reg_tmp4);
            // 83: cmp
            conditional_code = greaterThanEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp4.xxxx));
            // 84: rsq
            reg_tmp4 = vec4(rsq_safe(reg_tmp4.xxxx.x));
            // 85: mul
            reg_tmp5 = mul_safe(uniforms.f[94].zzzz, reg_tmp14);
            // 86: jmpc
            if (conditional_code.x) {
                { jmp_to = 89u; break; }
            }
            // 87: rcp
            reg_tmp0.z = rcp_safe(reg_tmp4.xxxx.x);
            // 88: mul
            reg_tmp0.xy = (mul_safe(reg_tmp5, reg_tmp4)).xy;
        }
        case 89u: {
            // 89: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_166_183() {
    // 166: mov
    reg_tmp8.xy = (uniforms.f[93].xxxx).xy;
    // 167: mov
    reg_tmp0.y = (uniforms.f[7].wwww).y;
    // 168: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.xyyy));
    // 169: mov
    reg_tmp9.xyz = (uniforms.f[93].xxxx).xyz;
    // 170: mov
    reg_tmp9.w = (uniforms.f[21].wwww).w;
    // 171: ifc
    if (conditional_code.y) {
        sub_172_177();
    }
    // 177: callu
    if (uniforms.b[12]) {
        sub_183_229();
    }
    // 178: callu
    if (uniforms.b[5]) {
        sub_229_239();
    }
    // 179: cmp
    conditional_code = equal(vec2(uniforms.f[93].xxxx), vec2(reg_tmp8.xyyy));
    // 180: ifc
    if (all(conditional_code)) {
        sub_181_182();
    }
    // 182: max
    vs_out_attr3 = max(uniforms.f[93].xxxx, reg_tmp9);
    return false;
}
bool sub_172_177() {
    // 172: mul
    reg_tmp0 = mul_safe(uniforms.f[7].wwww, vs_in_reg3);
    // 173: ifu
    if (uniforms.b[7]) {
        sub_174_175();
    }
    // 175: mul
    reg_tmp9.xyz = (mul_safe(uniforms.f[20].wwww, reg_tmp0.xyzz)).xyz;
    // 176: mov
    reg_tmp8.x = (uniforms.f[93].yyyy).x;
    return false;
}
bool sub_174_175() {
    // 174: mul
    reg_tmp9.w = (mul_safe(reg_tmp9.wwww, reg_tmp0.wwww)).w;
    return false;
}
bool sub_181_182() {
    // 181: mov
    reg_tmp9 = uniforms.f[21];
    return false;
}
bool sub_183_229() {
    // 183: mov
    reg_tmp1 = uniforms.f[20];
    // 184: mov
    reg_tmp2 = uniforms.f[21];
    // 185: mov
    reg_tmp3 = uniforms.f[93].xxxx;
    // 186: loop
    address_registers.z = int(uniforms.i[0].y);
    for (uint loop186 = 0u; loop186 <= uniforms.i[0].x; address_registers.z += int(uniforms.i[0].z), ++loop186) {
        sub_187_228();
    }
    // 228: mov
    reg_tmp8.x = (uniforms.f[93].yyyy).x;
    return false;
}
bool sub_187_228() {
    // 187: mova
    address_registers.x = (ivec2(reg_tmp3)).x;
    // 188: mov
    reg_tmp4.x = (uniforms.f[49 + address_registers.x].wwww).x;
    // 189: mov
    reg_tmp4.y = (uniforms.f[51 + address_registers.x].wwww).y;
    // 190: cmp
    conditional_code = equal(vec2(uniforms.f[93].xyyy), vec2(reg_tmp4.xyyy));
    // 191: ifc
    if (conditional_code.x) {
        sub_192_194();
    } else {
        sub_194_218();
    }
    // 218: cmp
    conditional_code.x = uniforms.f[93].xxxx.x == reg_tmp6.xyyy.x;
    conditional_code.y = uniforms.f[93].xxxx.y < reg_tmp6.xyyy.y;
    // 219: ifc
    if (conditional_code.y) {
        sub_220_227();
    }
    // 227: add
    reg_tmp3 = -uniforms.f[95].wwww + reg_tmp3;
    return false;
}
bool sub_192_194() {
    // 192: dp3
    reg_tmp6.x = dot(vec3(mul_safe(uniforms.f[49 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 193: mov
    reg_tmp6.y = (uniforms.f[93].yyyy).y;
    return false;
}
bool sub_194_218() {
    // 194: add
    reg_tmp4 = uniforms.f[49 + address_registers.x] + -reg_tmp15;
    // 195: mov
    reg_tmp6.y = (uniforms.f[93].yyyy).y;
    // 196: ifc
    if (conditional_code.y) {
        sub_197_202();
    }
    // 202: mov
    reg_tmp5 = uniforms.f[50 + address_registers.x];
    // 203: cmp
    conditional_code = equal(vec2(uniforms.f[93].yyyy), vec2(reg_tmp5.wwww));
    // 204: dp3
    reg_tmp4.w = dot(vec3(mul_safe(reg_tmp4, reg_tmp4)), vec3(1.0));
    // 205: rsq
    reg_tmp4.w = rsq_safe(reg_tmp4.wwww.x);
    // 206: mul
    reg_tmp4 = mul_safe(reg_tmp4, reg_tmp4.wwww);
    // 207: ifc
    if (conditional_code.x) {
        sub_208_217();
    }
    // 217: dp3
    reg_tmp6.x = dot(vec3(mul_safe(reg_tmp14, reg_tmp4)), vec3(1.0));
    return false;
}
bool sub_197_202() {
    // 197: mov
    reg_tmp5.x = (uniforms.f[93].yyyy).x;
    // 198: dp3
    reg_tmp5.z = dot(vec3(mul_safe(reg_tmp4, reg_tmp4)), vec3(1.0));
    // 199: mul
    reg_tmp5.y = (mul_safe(reg_tmp5.zzzz, reg_tmp5.zzzz)).y;
    // 200: dp3
    reg_tmp6.y = dot(vec3(mul_safe(uniforms.f[51 + address_registers.x], reg_tmp5)), vec3(1.0));
    // 201: rcp
    reg_tmp6.y = rcp_safe(reg_tmp6.yyyy.x);
    return false;
}
bool sub_208_217() {
    // 208: dp3
    reg_tmp5.x = dot(vec3(mul_safe(uniforms.f[50 + address_registers.x], -reg_tmp4)), vec3(1.0));
    // 209: slti
    reg_tmp5.y = (vec4(lessThan(reg_tmp5.xxxx,uniforms.f[52 + address_registers.x].yyyy))).y;
    // 210: cmp
    conditional_code = equal(vec2(uniforms.f[93].yyyy), vec2(reg_tmp5.xyyy));
    // 211: ifc
    if (conditional_code.y) {
        sub_212_213();
    } else {
        sub_213_216();
    }
    // 216: mul
    reg_tmp6.y = (mul_safe(reg_tmp6.yyyy, reg_tmp5.xxxx)).y;
    return false;
}
bool sub_212_213() {
    // 212: mov
    reg_tmp5.x = (uniforms.f[93].xxxx).x;
    return false;
}
bool sub_213_216() {
    // 213: log
    reg_tmp5.y = log2(reg_tmp5.xxxx.x);
    // 214: mul
    reg_tmp5.y = (mul_safe(uniforms.f[52 + address_registers.x].xxxx, reg_tmp5.yyyy)).y;
    // 215: exp
    reg_tmp5.x = exp2(reg_tmp5.yyyy.x);
    return false;
}
bool sub_220_227() {
    // 220: max
    reg_tmp6.x = (max(uniforms.f[93].xxxx, reg_tmp6.xxxx)).x;
    // 221: mad
    reg_tmp9.xyz = (fma_safe(reg_tmp1.xyzz, uniforms.f[47 + address_registers.x].xyzz, reg_tmp9.xyzz)).xyz;
    // 222: mul
    reg_tmp4 = mul_safe(uniforms.f[48 + address_registers.x], reg_tmp2);
    // 223: mul
    reg_tmp5.xyz = (mul_safe(reg_tmp6.xxxx, reg_tmp4.xyzz)).xyz;
    // 224: mul
    reg_tmp5.xyz = (mul_safe(reg_tmp6.yyyy, reg_tmp5.xyzz)).xyz;
    // 225: add
    reg_tmp9.xyz = (reg_tmp9.xyzz + reg_tmp5.xyzz).xyz;
    // 226: add
    reg_tmp9.w = (reg_tmp9.wwww + reg_tmp4.wwww).w;
    return false;
}
bool sub_229_239() {
    // 229: dp3
    reg_tmp1 = vec4(dot(vec3(mul_safe(uniforms.f[24], reg_tmp14)), vec3(1.0)));
    // 230: mov
    reg_tmp2 = uniforms.f[24].wwww;
    // 231: mad
    reg_tmp1 = fma_safe(reg_tmp1, reg_tmp2, reg_tmp2);
    // 232: mov
    reg_tmp3 = uniforms.f[22];
    // 233: add
    reg_tmp2 = uniforms.f[23] + -reg_tmp3;
    // 234: mad
    reg_tmp4 = fma_safe(reg_tmp2, reg_tmp1, reg_tmp3);
    // 235: ifu
    if (uniforms.b[6]) {
        sub_236_237();
    }
    // 237: mad
    reg_tmp9.xyz = (fma_safe(reg_tmp4, uniforms.f[21], reg_tmp9)).xyz;
    // 238: mov
    reg_tmp8.x = (uniforms.f[93].yyyy).x;
    return false;
}
bool sub_236_237() {
    // 236: mul
    reg_tmp4 = mul_safe(reg_tmp4, reg_tmp9.wwww);
    return false;
}
bool sub_239_266() {
    // 239: mov
    reg_tmp0.xy = (uniforms.f[10].xxxx).xy;
    // 240: ifu
    if (uniforms.b[9]) {
        sub_241_246();
    } else {
        sub_246_265();
    }
    // 265: nop
    return false;
}
bool sub_241_246() {
    // 241: call
    {
        sub_266_274();
    }
    // 242: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[11].xywz, reg_tmp6), vec4(1.0));
    // 243: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[12].xywz, reg_tmp6), vec4(1.0));
    // 244: mov
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    // 245: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_246_265() {
    // 246: cmp
    conditional_code = equal(vec2(uniforms.f[95].xyyy), vec2(reg_tmp0.xyyy));
    // 247: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 248: ifc
    if (all(not(conditional_code))) {
        sub_249_255();
    } else {
        sub_255_264();
    }
    // 264: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_249_255() {
    // 249: mov
    reg_tmp6 = reg_tmp10;
    // 250: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[11], reg_tmp6), vec4(1.0));
    // 251: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[12], reg_tmp6), vec4(1.0));
    // 252: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[13], reg_tmp6), vec4(1.0));
    // 253: mul
    reg_tmp0.xy = (mul_safe(uniforms.f[19].xyyy, reg_tmp3.zzzz)).xy;
    // 254: add
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_255_264() {
    // 255: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_256_260();
    } else {
        sub_260_263();
    }
    // 263: nop
    return false;
}
bool sub_256_260() {
    // 256: call
    {
        sub_274_281();
    }
    // 257: dp3
    reg_tmp3.x = dot(vec3(mul_safe(uniforms.f[11], reg_tmp6)), vec3(1.0));
    // 258: dp3
    reg_tmp3.y = dot(vec3(mul_safe(uniforms.f[12], reg_tmp6)), vec3(1.0));
    // 259: dp3
    reg_tmp3.z = dot(vec3(mul_safe(uniforms.f[13], reg_tmp6)), vec3(1.0));
    return false;
}
bool sub_260_263() {
    // 260: call
    {
        sub_281_285();
    }
    // 261: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[11], reg_tmp6), vec4(1.0));
    // 262: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[12], reg_tmp6), vec4(1.0));
    return false;
}
bool sub_266_274() {
    // 266: cmp
    conditional_code = equal(vec2(uniforms.f[93].yzzz), vec2(reg_tmp0.xyyy));
    // 267: ifc
    if (all(not(conditional_code))) {
        sub_268_269();
    } else {
        sub_269_273();
    }
    // 273: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_268_269() {
    // 268: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
    return false;
}
bool sub_269_273() {
    // 269: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_270_271();
    } else {
        sub_271_272();
    }
    // 272: nop
    return false;
}
bool sub_270_271() {
    // 270: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
    return false;
}
bool sub_271_272() {
    // 271: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
    return false;
}
bool sub_274_281() {
    // 274: mov
    reg_tmp2 = -reg_tmp15;
    // 275: dp3
    reg_tmp2.w = dot(vec3(mul_safe(reg_tmp2, reg_tmp2)), vec3(1.0));
    // 276: rsq
    reg_tmp2.w = rsq_safe(reg_tmp2.wwww.x);
    // 277: mul
    reg_tmp2 = mul_safe(reg_tmp2, reg_tmp2.wwww);
    // 278: dp3
    reg_tmp1 = vec4(dot(vec3(mul_safe(reg_tmp2, reg_tmp14)), vec3(1.0)));
    // 279: add
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    // 280: mad
    reg_tmp6 = fma_safe(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_281_285() {
    // 281: mov
    reg_tmp1.xy = (uniforms.f[94].zzzz).xy;
    // 282: mov
    reg_tmp1.zw = (uniforms.f[93].xxxx).zw;
    // 283: mad
    reg_tmp6 = fma_safe(reg_tmp14, reg_tmp1, reg_tmp1);
    // 284: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_285_309() {
    // 285: mov
    reg_tmp0.xy = (uniforms.f[10].yyyy).xy;
    // 286: ifu
    if (uniforms.b[10]) {
        sub_287_291();
    } else {
        sub_291_308();
    }
    // 308: nop
    return false;
}
bool sub_287_291() {
    // 287: call
    {
        sub_266_274();
    }
    // 288: dp4
    reg_tmp4.x = dot(mul_safe(uniforms.f[14].xywz, reg_tmp6), vec4(1.0));
    // 289: dp4
    reg_tmp4.y = dot(mul_safe(uniforms.f[15].xywz, reg_tmp6), vec4(1.0));
    // 290: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_291_308() {
    // 291: ifu
    if (uniforms.b[13]) {
        sub_292_306();
    } else {
        sub_306_307();
    }
    // 307: nop
    return false;
}
bool sub_292_306() {
    // 292: cmp
    conditional_code = equal(vec2(uniforms.f[95].xyyy), vec2(reg_tmp0.xyyy));
    // 293: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 294: ifc
    if (all(not(conditional_code))) {
        sub_295_302();
    } else {
        sub_302_305();
    }
    // 305: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_295_302() {
    // 295: mov
    reg_tmp6 = reg_tmp10;
    // 296: dp4
    reg_tmp4.x = dot(mul_safe(uniforms.f[14], reg_tmp6), vec4(1.0));
    // 297: dp4
    reg_tmp4.y = dot(mul_safe(uniforms.f[15], reg_tmp6), vec4(1.0));
    // 298: dp4
    reg_tmp4.z = dot(mul_safe(uniforms.f[16], reg_tmp6), vec4(1.0));
    // 299: rcp
    reg_tmp6.w = rcp_safe(reg_tmp4.zzzz.x);
    // 300: mul
    reg_tmp4.xy = (mul_safe(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    // 301: add
    reg_tmp4.xy = (uniforms.f[19].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_302_305() {
    // 302: call
    {
        sub_281_285();
    }
    // 303: dp4
    reg_tmp4.x = dot(mul_safe(uniforms.f[14], reg_tmp6), vec4(1.0));
    // 304: dp4
    reg_tmp4.y = dot(mul_safe(uniforms.f[15], reg_tmp6), vec4(1.0));
    return false;
}
bool sub_306_307() {
    // 306: mov
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_309_325() {
    // 309: mov
    reg_tmp0.xy = (uniforms.f[10].zzzz).xy;
    // 310: ifu
    if (uniforms.b[11]) {
        sub_311_315();
    } else {
        sub_315_324();
    }
    // 324: nop
    return false;
}
bool sub_311_315() {
    // 311: call
    {
        sub_266_274();
    }
    // 312: dp4
    reg_tmp5.x = dot(mul_safe(uniforms.f[17].xywz, reg_tmp6), vec4(1.0));
    // 313: dp4
    reg_tmp5.y = dot(mul_safe(uniforms.f[18].xywz, reg_tmp6), vec4(1.0));
    // 314: mov
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_315_324() {
    // 315: ifu
    if (uniforms.b[14]) {
        sub_316_322();
    } else {
        sub_322_323();
    }
    // 323: nop
    return false;
}
bool sub_316_322() {
    // 316: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 317: mov
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    // 318: call
    {
        sub_281_285();
    }
    // 319: dp4
    reg_tmp5.x = dot(mul_safe(uniforms.f[17], reg_tmp6), vec4(1.0));
    // 320: dp4
    reg_tmp5.y = dot(mul_safe(uniforms.f[18], reg_tmp6), vec4(1.0));
    // 321: mov
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_322_323() {
    // 322: mov
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
// reference: 59593DFA2F9842FB, 608565C51104A52F
// program: 608565C51104A52F, AD7922A63ED54CA7, 8C2ECA480D7B7AB5
// reference: 15ACF31C32F5A479, E661110CC0BF42D1
// reference: 418CD9966CB7FCED, 4EFF2C77DB8F9E73
// program: 4EFF2C77DB8F9E73, 3B3AE026C742C7D5, 06A8A4F9432C9B26
// reference: EEC84BD1AD3140CF, 17716008BB716A8F
// program: 17716008BB716A8F, AD7922A63ED54CA7, E2B05A5EEE3BCE11
// reference: EEC84BD14208D38E, 17716008BB716A8F
// reference: 418CD996838E6FAC, 4EFF2C77DB8F9E73
// program: 4EFF2C77DB8F9E73, 3B3AE026C742C7D5, 6508155727F8E389
// program: 17716008BB716A8F, AD7922A63ED54CA7, 23F262D2CA8E6488
// program: 4EFF2C77DB8F9E73, 3B3AE026C742C7D5, 7FF280648EA22926
// program: 4EFF2C77DB8F9E73, 3B3AE026C742C7D5, 8B353D67743458EE
// program: 4EFF2C77DB8F9E73, 3B3AE026C742C7D5, 82B30867377518C0
// program: 4EFF2C77DB8F9E73, 3B3AE026C742C7D5, 48869468E89D649B
// program: 17716008BB716A8F, AD7922A63ED54CA7, 2F84956AB5DBE86B
// program: 17716008BB716A8F, AD7922A63ED54CA7, 45B9B5821FF15384
// program: 17716008BB716A8F, AD7922A63ED54CA7, 39C07F205AF70F59
// program: 4EFF2C77DB8F9E73, 3B3AE026C742C7D5, 2F3A3851E4476855
// program: 4EFF2C77DB8F9E73, 3B3AE026C742C7D5, 9DB6533B8FE11441
// program: 4EFF2C77DB8F9E73, 3B3AE026C742C7D5, 16C4B2DE63D43BF1
// shader: 8B31, 76204850D3D31438

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;
 out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define mul_safe(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define rcp_safe(x) (1.0f / x)
#define rsq_safe(x) inversesqrt(x)
#define fma_safe(x, y, z) (mul_safe(x, y) + z)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_4096();
bool sub_10_28();
bool sub_16_21();
bool sub_18_19();
bool sub_25_26();
bool sub_28_74();
bool sub_32_73();
bool sub_37_39();
bool sub_39_63();
bool sub_42_47();
bool sub_53_62();
bool sub_57_58();
bool sub_58_61();
bool sub_65_72();
bool sub_74_84();
bool sub_81_82();
bool sub_84_111();
bool sub_86_91();
bool sub_91_110();
bool sub_94_100();
bool sub_100_109();
bool sub_101_105();
bool sub_105_108();
bool sub_111_119();
bool sub_113_114();
bool sub_114_118();
bool sub_115_116();
bool sub_116_117();
bool sub_119_126();
bool sub_126_130();
bool sub_130_154();
bool sub_132_136();
bool sub_136_153();
bool sub_137_151();
bool sub_140_147();
bool sub_147_150();
bool sub_151_152();
bool sub_154_170();
bool sub_156_160();
bool sub_160_169();
bool sub_161_167();
bool sub_167_168();

bool exec_shader() {
    sub_0_4096();
    return true;
}

bool sub_0_4096() {
    // 0: mov
    reg_tmp0 = vs_in_reg0;
    // 1: mov
    vs_out_attr0 = reg_tmp0;
    // 2: mov
    vs_out_attr2 = reg_tmp0;
    // 3: mov
    vs_out_attr1 = reg_tmp0;
    // 4: call
    {
        sub_10_28();
    }
    // 5: call
    {
        sub_84_111();
    }
    // 6: call
    {
        sub_130_154();
    }
    // 7: call
    {
        sub_154_170();
    }
    // 8: end
    return true;
}
bool sub_10_28() {
    // 10: mov
    reg_tmp8.xy = (uniforms.f[93].xxxx).xy;
    // 11: mov
    reg_tmp0.y = (uniforms.f[7].wwww).y;
    // 12: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.xyyy));
    // 13: mov
    reg_tmp9.xyz = (uniforms.f[93].xxxx).xyz;
    // 14: mov
    reg_tmp9.w = (uniforms.f[21].wwww).w;
    // 15: ifc
    if (conditional_code.y) {
        sub_16_21();
    }
    // 21: callu
    if (uniforms.b[12]) {
        sub_28_74();
    }
    // 22: callu
    if (uniforms.b[5]) {
        sub_74_84();
    }
    // 23: cmp
    conditional_code = equal(vec2(uniforms.f[93].xxxx), vec2(reg_tmp8.xyyy));
    // 24: ifc
    if (all(conditional_code)) {
        sub_25_26();
    }
    // 26: add
    reg_tmp9 = uniforms.f[74] + reg_tmp9;
    // 27: max
    vs_out_attr3 = max(uniforms.f[93].xxxx, reg_tmp9);
    return false;
}
bool sub_16_21() {
    // 16: mul
    reg_tmp0 = mul_safe(uniforms.f[7].wwww, vs_in_reg3);
    // 17: ifu
    if (uniforms.b[7]) {
        sub_18_19();
    }
    // 19: mul
    reg_tmp9.xyz = (mul_safe(uniforms.f[20].wwww, reg_tmp0.xyzz)).xyz;
    // 20: mov
    reg_tmp8.x = (uniforms.f[93].yyyy).x;
    return false;
}
bool sub_18_19() {
    // 18: mul
    reg_tmp9.w = (mul_safe(reg_tmp9.wwww, reg_tmp0.wwww)).w;
    return false;
}
bool sub_25_26() {
    // 25: mov
    reg_tmp9 = uniforms.f[21];
    return false;
}
bool sub_28_74() {
    // 28: mov
    reg_tmp1 = uniforms.f[20];
    // 29: mov
    reg_tmp2 = uniforms.f[21];
    // 30: mov
    reg_tmp3 = uniforms.f[93].xxxx;
    // 31: loop
    address_registers.z = int(uniforms.i[0].y);
    for (uint loop31 = 0u; loop31 <= uniforms.i[0].x; address_registers.z += int(uniforms.i[0].z), ++loop31) {
        sub_32_73();
    }
    // 73: mov
    reg_tmp8.x = (uniforms.f[93].yyyy).x;
    return false;
}
bool sub_32_73() {
    // 32: mova
    address_registers.x = (ivec2(reg_tmp3)).x;
    // 33: mov
    reg_tmp4.x = (uniforms.f[69 + address_registers.x].wwww).x;
    // 34: mov
    reg_tmp4.y = (uniforms.f[71 + address_registers.x].wwww).y;
    // 35: cmp
    conditional_code = equal(vec2(uniforms.f[93].xyyy), vec2(reg_tmp4.xyyy));
    // 36: ifc
    if (conditional_code.x) {
        sub_37_39();
    } else {
        sub_39_63();
    }
    // 63: cmp
    conditional_code.x = uniforms.f[93].xxxx.x == reg_tmp6.xyyy.x;
    conditional_code.y = uniforms.f[93].xxxx.y < reg_tmp6.xyyy.y;
    // 64: ifc
    if (conditional_code.y) {
        sub_65_72();
    }
    // 72: add
    reg_tmp3 = -uniforms.f[95].wwww + reg_tmp3;
    return false;
}
bool sub_37_39() {
    // 37: dp3
    reg_tmp6.x = dot(vec3(mul_safe(uniforms.f[69 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 38: mov
    reg_tmp6.y = (uniforms.f[93].yyyy).y;
    return false;
}
bool sub_39_63() {
    // 39: add
    reg_tmp4 = uniforms.f[69 + address_registers.x] + -reg_tmp15;
    // 40: mov
    reg_tmp6.y = (uniforms.f[93].yyyy).y;
    // 41: ifc
    if (conditional_code.y) {
        sub_42_47();
    }
    // 47: mov
    reg_tmp5 = uniforms.f[70 + address_registers.x];
    // 48: cmp
    conditional_code = equal(vec2(uniforms.f[93].yyyy), vec2(reg_tmp5.wwww));
    // 49: dp3
    reg_tmp4.w = dot(vec3(mul_safe(reg_tmp4, reg_tmp4)), vec3(1.0));
    // 50: rsq
    reg_tmp4.w = rsq_safe(reg_tmp4.wwww.x);
    // 51: mul
    reg_tmp4 = mul_safe(reg_tmp4, reg_tmp4.wwww);
    // 52: ifc
    if (conditional_code.x) {
        sub_53_62();
    }
    // 62: dp3
    reg_tmp6.x = dot(vec3(mul_safe(reg_tmp14, reg_tmp4)), vec3(1.0));
    return false;
}
bool sub_42_47() {
    // 42: mov
    reg_tmp5.x = (uniforms.f[93].yyyy).x;
    // 43: dp3
    reg_tmp5.z = dot(vec3(mul_safe(reg_tmp4, reg_tmp4)), vec3(1.0));
    // 44: mul
    reg_tmp5.y = (mul_safe(reg_tmp5.zzzz, reg_tmp5.zzzz)).y;
    // 45: dp3
    reg_tmp6.y = dot(vec3(mul_safe(uniforms.f[71 + address_registers.x], reg_tmp5)), vec3(1.0));
    // 46: rcp
    reg_tmp6.y = rcp_safe(reg_tmp6.yyyy.x);
    return false;
}
bool sub_53_62() {
    // 53: dp3
    reg_tmp5.x = dot(vec3(mul_safe(uniforms.f[70 + address_registers.x], -reg_tmp4)), vec3(1.0));
    // 54: slti
    reg_tmp5.y = (vec4(lessThan(reg_tmp5.xxxx,uniforms.f[72 + address_registers.x].yyyy))).y;
    // 55: cmp
    conditional_code = equal(vec2(uniforms.f[93].yyyy), vec2(reg_tmp5.xyyy));
    // 56: ifc
    if (conditional_code.y) {
        sub_57_58();
    } else {
        sub_58_61();
    }
    // 61: mul
    reg_tmp6.y = (mul_safe(reg_tmp6.yyyy, reg_tmp5.xxxx)).y;
    return false;
}
bool sub_57_58() {
    // 57: mov
    reg_tmp5.x = (uniforms.f[93].xxxx).x;
    return false;
}
bool sub_58_61() {
    // 58: log
    reg_tmp5.y = log2(reg_tmp5.xxxx.x);
    // 59: mul
    reg_tmp5.y = (mul_safe(uniforms.f[72 + address_registers.x].xxxx, reg_tmp5.yyyy)).y;
    // 60: exp
    reg_tmp5.x = exp2(reg_tmp5.yyyy.x);
    return false;
}
bool sub_65_72() {
    // 65: max
    reg_tmp6.x = (max(uniforms.f[93].xxxx, reg_tmp6.xxxx)).x;
    // 66: mad
    reg_tmp9.xyz = (fma_safe(reg_tmp1.xyzz, uniforms.f[67 + address_registers.x].xyzz, reg_tmp9.xyzz)).xyz;
    // 67: mul
    reg_tmp4 = mul_safe(uniforms.f[68 + address_registers.x], reg_tmp2);
    // 68: mul
    reg_tmp5.xyz = (mul_safe(reg_tmp6.xxxx, reg_tmp4.xyzz)).xyz;
    // 69: mul
    reg_tmp5.xyz = (mul_safe(reg_tmp6.yyyy, reg_tmp5.xyzz)).xyz;
    // 70: add
    reg_tmp9.xyz = (reg_tmp9.xyzz + reg_tmp5.xyzz).xyz;
    // 71: add
    reg_tmp9.w = (reg_tmp9.wwww + reg_tmp4.wwww).w;
    return false;
}
bool sub_74_84() {
    // 74: dp3
    reg_tmp1 = vec4(dot(vec3(mul_safe(uniforms.f[24], reg_tmp14)), vec3(1.0)));
    // 75: mov
    reg_tmp2 = uniforms.f[24].wwww;
    // 76: mad
    reg_tmp1 = fma_safe(reg_tmp1, reg_tmp2, reg_tmp2);
    // 77: mov
    reg_tmp3 = uniforms.f[22];
    // 78: add
    reg_tmp2 = uniforms.f[23] + -reg_tmp3;
    // 79: mad
    reg_tmp4 = fma_safe(reg_tmp2, reg_tmp1, reg_tmp3);
    // 80: ifu
    if (uniforms.b[6]) {
        sub_81_82();
    }
    // 82: mad
    reg_tmp9.xyz = (fma_safe(reg_tmp4, uniforms.f[21], reg_tmp9)).xyz;
    // 83: mov
    reg_tmp8.x = (uniforms.f[93].yyyy).x;
    return false;
}
bool sub_81_82() {
    // 81: mul
    reg_tmp4 = mul_safe(reg_tmp4, reg_tmp9.wwww);
    return false;
}
bool sub_84_111() {
    // 84: mov
    reg_tmp0.xy = (uniforms.f[10].xxxx).xy;
    // 85: ifu
    if (uniforms.b[9]) {
        sub_86_91();
    } else {
        sub_91_110();
    }
    // 110: nop
    return false;
}
bool sub_86_91() {
    // 86: call
    {
        sub_111_119();
    }
    // 87: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[11].xywz, reg_tmp6), vec4(1.0));
    // 88: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[12].xywz, reg_tmp6), vec4(1.0));
    // 89: mov
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    // 90: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_91_110() {
    // 91: cmp
    conditional_code = equal(vec2(uniforms.f[95].xyyy), vec2(reg_tmp0.xyyy));
    // 92: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 93: ifc
    if (all(not(conditional_code))) {
        sub_94_100();
    } else {
        sub_100_109();
    }
    // 109: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_94_100() {
    // 94: mov
    reg_tmp6 = reg_tmp10;
    // 95: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[11], reg_tmp6), vec4(1.0));
    // 96: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[12], reg_tmp6), vec4(1.0));
    // 97: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[13], reg_tmp6), vec4(1.0));
    // 98: mul
    reg_tmp0.xy = (mul_safe(uniforms.f[19].xyyy, reg_tmp3.zzzz)).xy;
    // 99: add
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_100_109() {
    // 100: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_101_105();
    } else {
        sub_105_108();
    }
    // 108: nop
    return false;
}
bool sub_101_105() {
    // 101: call
    {
        sub_119_126();
    }
    // 102: dp3
    reg_tmp3.x = dot(vec3(mul_safe(uniforms.f[11], reg_tmp6)), vec3(1.0));
    // 103: dp3
    reg_tmp3.y = dot(vec3(mul_safe(uniforms.f[12], reg_tmp6)), vec3(1.0));
    // 104: dp3
    reg_tmp3.z = dot(vec3(mul_safe(uniforms.f[13], reg_tmp6)), vec3(1.0));
    return false;
}
bool sub_105_108() {
    // 105: call
    {
        sub_126_130();
    }
    // 106: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[11], reg_tmp6), vec4(1.0));
    // 107: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[12], reg_tmp6), vec4(1.0));
    return false;
}
bool sub_111_119() {
    // 111: cmp
    conditional_code = equal(vec2(uniforms.f[93].yzzz), vec2(reg_tmp0.xyyy));
    // 112: ifc
    if (all(not(conditional_code))) {
        sub_113_114();
    } else {
        sub_114_118();
    }
    // 118: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_113_114() {
    // 113: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
    return false;
}
bool sub_114_118() {
    // 114: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_115_116();
    } else {
        sub_116_117();
    }
    // 117: nop
    return false;
}
bool sub_115_116() {
    // 115: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
    return false;
}
bool sub_116_117() {
    // 116: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
    return false;
}
bool sub_119_126() {
    // 119: mov
    reg_tmp2 = -reg_tmp15;
    // 120: dp3
    reg_tmp2.w = dot(vec3(mul_safe(reg_tmp2, reg_tmp2)), vec3(1.0));
    // 121: rsq
    reg_tmp2.w = rsq_safe(reg_tmp2.wwww.x);
    // 122: mul
    reg_tmp2 = mul_safe(reg_tmp2, reg_tmp2.wwww);
    // 123: dp3
    reg_tmp1 = vec4(dot(vec3(mul_safe(reg_tmp2, reg_tmp14)), vec3(1.0)));
    // 124: add
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    // 125: mad
    reg_tmp6 = fma_safe(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_126_130() {
    // 126: mov
    reg_tmp1.xy = (uniforms.f[94].zzzz).xy;
    // 127: mov
    reg_tmp1.zw = (uniforms.f[93].xxxx).zw;
    // 128: mad
    reg_tmp6 = fma_safe(reg_tmp14, reg_tmp1, reg_tmp1);
    // 129: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_130_154() {
    // 130: mov
    reg_tmp0.xy = (uniforms.f[10].yyyy).xy;
    // 131: ifu
    if (uniforms.b[10]) {
        sub_132_136();
    } else {
        sub_136_153();
    }
    // 153: nop
    return false;
}
bool sub_132_136() {
    // 132: call
    {
        sub_111_119();
    }
    // 133: dp4
    reg_tmp4.x = dot(mul_safe(uniforms.f[14].xywz, reg_tmp6), vec4(1.0));
    // 134: dp4
    reg_tmp4.y = dot(mul_safe(uniforms.f[15].xywz, reg_tmp6), vec4(1.0));
    // 135: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_136_153() {
    // 136: ifu
    if (uniforms.b[13]) {
        sub_137_151();
    } else {
        sub_151_152();
    }
    // 152: nop
    return false;
}
bool sub_137_151() {
    // 137: cmp
    conditional_code = equal(vec2(uniforms.f[95].xyyy), vec2(reg_tmp0.xyyy));
    // 138: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 139: ifc
    if (all(not(conditional_code))) {
        sub_140_147();
    } else {
        sub_147_150();
    }
    // 150: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_140_147() {
    // 140: mov
    reg_tmp6 = reg_tmp10;
    // 141: dp4
    reg_tmp4.x = dot(mul_safe(uniforms.f[14], reg_tmp6), vec4(1.0));
    // 142: dp4
    reg_tmp4.y = dot(mul_safe(uniforms.f[15], reg_tmp6), vec4(1.0));
    // 143: dp4
    reg_tmp4.z = dot(mul_safe(uniforms.f[16], reg_tmp6), vec4(1.0));
    // 144: rcp
    reg_tmp6.w = rcp_safe(reg_tmp4.zzzz.x);
    // 145: mul
    reg_tmp4.xy = (mul_safe(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    // 146: add
    reg_tmp4.xy = (uniforms.f[19].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_147_150() {
    // 147: call
    {
        sub_126_130();
    }
    // 148: dp4
    reg_tmp4.x = dot(mul_safe(uniforms.f[14], reg_tmp6), vec4(1.0));
    // 149: dp4
    reg_tmp4.y = dot(mul_safe(uniforms.f[15], reg_tmp6), vec4(1.0));
    return false;
}
bool sub_151_152() {
    // 151: mov
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_154_170() {
    // 154: mov
    reg_tmp0.xy = (uniforms.f[10].zzzz).xy;
    // 155: ifu
    if (uniforms.b[11]) {
        sub_156_160();
    } else {
        sub_160_169();
    }
    // 169: nop
    return false;
}
bool sub_156_160() {
    // 156: call
    {
        sub_111_119();
    }
    // 157: dp4
    reg_tmp5.x = dot(mul_safe(uniforms.f[17].xywz, reg_tmp6), vec4(1.0));
    // 158: dp4
    reg_tmp5.y = dot(mul_safe(uniforms.f[18].xywz, reg_tmp6), vec4(1.0));
    // 159: mov
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_160_169() {
    // 160: ifu
    if (uniforms.b[14]) {
        sub_161_167();
    } else {
        sub_167_168();
    }
    // 168: nop
    return false;
}
bool sub_161_167() {
    // 161: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 162: mov
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    // 163: call
    {
        sub_126_130();
    }
    // 164: dp4
    reg_tmp5.x = dot(mul_safe(uniforms.f[17], reg_tmp6), vec4(1.0));
    // 165: dp4
    reg_tmp5.y = dot(mul_safe(uniforms.f[18], reg_tmp6), vec4(1.0));
    // 166: mov
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_167_168() {
    // 167: mov
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
// reference: 3C15408BE182812D, 76204850D3D31438
// program: 76204850D3D31438, AD7922A63ED54CA7, D375021927AD9455
// reference: A54038CA3A3B206A, 76204850D3D31438
// program: 76204850D3D31438, AD7922A63ED54CA7, FB2B5B4178346715
// reference: D8D9A1D7B70E5DAA, 4EFF2C77DB8F9E73
// program: 4EFF2C77DB8F9E73, 3B3AE026C742C7D5, 82DDCA85272BD2AC
// shader: 8B31, 52FC86954A48E51C

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;
 out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define mul_safe(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define rcp_safe(x) (1.0f / x)
#define rsq_safe(x) inversesqrt(x)
#define fma_safe(x, y, z) (mul_safe(x, y) + z)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_4096();
bool sub_7_12();
bool sub_12_21();
bool sub_21_34();
bool sub_34_254();
bool sub_40_176();
bool sub_47_86();
bool sub_58_62();
bool sub_86_165();
bool sub_87_129();
bool sub_98_102();
bool sub_129_164();
bool sub_140_144();
bool sub_174_175();
bool sub_176_253();
bool sub_179_189();
bool sub_189_194();
bool sub_205_217();
bool sub_217_242();
bool sub_218_236();
bool sub_236_241();
bool sub_251_252();
bool sub_254_271();
bool sub_271_347();
bool sub_310_330();
bool sub_311_316();
bool sub_316_329();
bool sub_320_323();
bool sub_323_328();
bool sub_330_343();
bool sub_331_336();
bool sub_336_342();
bool sub_347_369();
bool sub_353_358();
bool sub_355_356();
bool sub_361_362();
bool sub_369_415();
bool sub_373_414();
bool sub_378_380();
bool sub_380_404();
bool sub_383_388();
bool sub_394_403();
bool sub_398_399();
bool sub_399_402();
bool sub_406_413();

bool exec_shader() {
    sub_0_4096();
    return true;
}

bool sub_0_4096() {
    // 0: call
    {
        sub_34_254();
    }
    // 1: call
    {
        sub_347_369();
    }
    // 2: mov
    vs_out_attr4 = uniforms.f[93].xxxx;
    // 3: mov
    vs_out_attr5 = uniforms.f[93].xxxx;
    // 4: mov
    vs_out_attr6 = uniforms.f[93].xxxx;
    // 5: end
    return true;
}
bool sub_7_12() {
    // 7: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 8: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 9: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 10: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 11: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    return false;
}
bool sub_12_21() {
    // 12: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 13: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 14: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 15: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 16: dp3
    reg_tmp4.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 17: dp3
    reg_tmp4.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 18: dp3
    reg_tmp4.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 19: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 20: mad
    reg_tmp12 = fma_safe(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_21_34() {
    // 21: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 22: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 23: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 24: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 25: dp3
    reg_tmp4.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 26: dp3
    reg_tmp4.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 27: dp3
    reg_tmp4.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 28: dp3
    reg_tmp5.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 29: dp3
    reg_tmp5.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 30: dp3
    reg_tmp5.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 31: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 32: mad
    reg_tmp12 = fma_safe(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    // 33: mad
    reg_tmp11 = fma_safe(reg_tmp1.wwww, reg_tmp5, reg_tmp11);
    return false;
}
bool sub_34_254() {
    // 34: mul
    reg_tmp15.xyz = (mul_safe(uniforms.f[7].xxxx, vs_in_reg0)).xyz;
    // 35: mul
    reg_tmp14.xyz = (mul_safe(uniforms.f[7].yyyy, vs_in_reg1)).xyz;
    // 36: mul
    reg_tmp13.xyz = (mul_safe(uniforms.f[7].zzzz, vs_in_reg2)).xyz;
    // 37: add
    reg_tmp15.xyz = (uniforms.f[6] + reg_tmp15).xyz;
    // 38: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 39: ifu
    if (uniforms.b[1]) {
        sub_40_176();
    } else {
        sub_176_253();
    }
    // 253: nop
    return false;
}
bool sub_40_176() {
    // 40: mov
    reg_tmp0 = uniforms.f[7];
    // 41: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.yzzz));
    // 42: mov
    reg_tmp7 = uniforms.f[93].xxxx;
    // 43: mov
    reg_tmp12 = uniforms.f[93].xxxx;
    // 44: mov
    reg_tmp11 = uniforms.f[93].xxxx;
    // 45: mul
    reg_tmp2 = mul_safe(uniforms.f[93].wwww, vs_in_reg7);
    // 46: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_47_86();
    } else {
        sub_86_165();
    }
    // 165: mov
    vs_out_attr2 = -reg_tmp15;
    // 166: dp4
    reg_tmp0.x = dot(mul_safe(uniforms.f[86], reg_tmp15), vec4(1.0));
    // 167: dp4
    reg_tmp0.y = dot(mul_safe(uniforms.f[87], reg_tmp15), vec4(1.0));
    // 168: dp4
    reg_tmp0.z = dot(mul_safe(uniforms.f[88], reg_tmp15), vec4(1.0));
    // 169: dp4
    reg_tmp0.w = dot(mul_safe(uniforms.f[89], reg_tmp15), vec4(1.0));
    // 170: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 171: mul
    reg_tmp1.y = (mul_safe(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
    // 172: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 173: ifc
    if (all(conditional_code)) {
        sub_174_175();
    }
    // 175: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_47_86() {
    // 47: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 48: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 49: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 50: call
    {
        sub_12_21();
    }
    // 51: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 52: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 53: call
    {
        sub_12_21();
    }
    // 54: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 55: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 56: callc
    if (conditional_code.x) {
        sub_12_21();
    }
    // 57: ifu
    if (uniforms.b[8]) {
        sub_58_62();
    }
    // 62: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 63: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 64: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 65: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 66: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 67: add
    reg_tmp6.y = (-uniforms.f[85].wwww + reg_tmp10.yyyy).y;
    // 68: mov
    reg_tmp9.xyz = (uniforms.f[85].xyzz).xyz;
    // 69: dp4
    reg_tmp7.x = dot(mul_safe(reg_tmp9.xyzz, reg_tmp9.xyzz), vec4(1.0));
    // 70: rsq
    reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
    // 71: mul
    reg_tmp7.xyz = (mul_safe(reg_tmp9.xyzz, reg_tmp7.xxxx)).xyz;
    // 72: rcp
    reg_tmp8.y = rcp_safe(-reg_tmp7.yyyy.x);
    // 73: mul
    reg_tmp8.y = (mul_safe(reg_tmp6.yyyy, reg_tmp8.yyyy)).y;
    // 74: mul
    reg_tmp7.xyz = (mul_safe(reg_tmp7.xyzz, reg_tmp8.yyyy)).xyz;
    // 75: add
    reg_tmp10.xyz = (reg_tmp10.xyzz + reg_tmp7.xyzz).xyz;
    // 76: add
    reg_tmp10.y = (uniforms.f[94].zzzz + reg_tmp10.yyyy).y;
    // 77: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 78: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 79: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 80: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 81: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 82: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 83: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 84: call
    {
        sub_254_271();
    }
    // 85: nop
    return false;
}
bool sub_58_62() {
    // 58: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 59: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 60: callc
    if (conditional_code.y) {
        sub_12_21();
    }
    // 61: nop
    return false;
}
bool sub_86_165() {
    // 86: ifc
    if (all(conditional_code)) {
        sub_87_129();
    } else {
        sub_129_164();
    }
    // 164: nop
    return false;
}
bool sub_87_129() {
    // 87: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 88: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 89: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 90: call
    {
        sub_21_34();
    }
    // 91: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 92: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 93: call
    {
        sub_21_34();
    }
    // 94: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 95: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 96: callc
    if (conditional_code.x) {
        sub_21_34();
    }
    // 97: ifu
    if (uniforms.b[8]) {
        sub_98_102();
    }
    // 102: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 103: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 104: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 105: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 106: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 107: dp3
    reg_tmp13.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp11)), vec3(1.0));
    // 108: dp3
    reg_tmp13.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp11)), vec3(1.0));
    // 109: dp3
    reg_tmp13.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp11)), vec3(1.0));
    // 110: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 111: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 112: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 113: add
    reg_tmp6.y = (-uniforms.f[85].wwww + reg_tmp10.yyyy).y;
    // 114: mov
    reg_tmp9.xyz = (uniforms.f[85].xyzz).xyz;
    // 115: dp4
    reg_tmp7.x = dot(mul_safe(reg_tmp9.xyzz, reg_tmp9.xyzz), vec4(1.0));
    // 116: rsq
    reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
    // 117: mul
    reg_tmp7.xyz = (mul_safe(reg_tmp9.xyzz, reg_tmp7.xxxx)).xyz;
    // 118: rcp
    reg_tmp8.y = rcp_safe(-reg_tmp7.yyyy.x);
    // 119: mul
    reg_tmp8.y = (mul_safe(reg_tmp6.yyyy, reg_tmp8.yyyy)).y;
    // 120: mul
    reg_tmp7.xyz = (mul_safe(reg_tmp7.xyzz, reg_tmp8.yyyy)).xyz;
    // 121: add
    reg_tmp10.xyz = (reg_tmp10.xyzz + reg_tmp7.xyzz).xyz;
    // 122: add
    reg_tmp10.y = (uniforms.f[94].zzzz + reg_tmp10.yyyy).y;
    // 123: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 124: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 125: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 126: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 127: call
    {
        sub_271_347();
    }
    // 128: nop
    return false;
}
bool sub_98_102() {
    // 98: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 99: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 100: callc
    if (conditional_code.y) {
        sub_21_34();
    }
    // 101: nop
    return false;
}
bool sub_129_164() {
    // 129: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 130: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 131: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 132: call
    {
        sub_7_12();
    }
    // 133: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 134: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 135: call
    {
        sub_7_12();
    }
    // 136: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 137: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 138: callc
    if (conditional_code.x) {
        sub_7_12();
    }
    // 139: ifu
    if (uniforms.b[8]) {
        sub_140_144();
    }
    // 144: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 145: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 146: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 147: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 148: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 149: add
    reg_tmp6.y = (-uniforms.f[85].wwww + reg_tmp10.yyyy).y;
    // 150: mov
    reg_tmp9.xyz = (uniforms.f[85].xyzz).xyz;
    // 151: dp4
    reg_tmp7.x = dot(mul_safe(reg_tmp9.xyzz, reg_tmp9.xyzz), vec4(1.0));
    // 152: rsq
    reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
    // 153: mul
    reg_tmp7.xyz = (mul_safe(reg_tmp9.xyzz, reg_tmp7.xxxx)).xyz;
    // 154: rcp
    reg_tmp8.y = rcp_safe(-reg_tmp7.yyyy.x);
    // 155: mul
    reg_tmp8.y = (mul_safe(reg_tmp6.yyyy, reg_tmp8.yyyy)).y;
    // 156: mul
    reg_tmp7.xyz = (mul_safe(reg_tmp7.xyzz, reg_tmp8.yyyy)).xyz;
    // 157: add
    reg_tmp10.xyz = (reg_tmp10.xyzz + reg_tmp7.xyzz).xyz;
    // 158: add
    reg_tmp10.y = (uniforms.f[94].zzzz + reg_tmp10.yyyy).y;
    // 159: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 160: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 161: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 162: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 163: mov
    vs_out_attr1 = uniforms.f[93].xxxx;
    return false;
}
bool sub_140_144() {
    // 140: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 141: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 142: callc
    if (conditional_code.y) {
        sub_7_12();
    }
    // 143: nop
    return false;
}
bool sub_174_175() {
    // 174: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_176_253() {
    // 176: mov
    reg_tmp0 = uniforms.f[7];
    // 177: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.yzzz));
    // 178: ifu
    if (uniforms.b[2]) {
        sub_179_189();
    } else {
        sub_189_194();
    }
    // 194: add
    reg_tmp6.y = (-uniforms.f[85].wwww + reg_tmp10.yyyy).y;
    // 195: mov
    reg_tmp9.xyz = (uniforms.f[85].xyzz).xyz;
    // 196: dp4
    reg_tmp7.x = dot(mul_safe(reg_tmp9.xyzz, reg_tmp9.xyzz), vec4(1.0));
    // 197: rsq
    reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
    // 198: mul
    reg_tmp7.xyz = (mul_safe(reg_tmp9.xyzz, reg_tmp7.xxxx)).xyz;
    // 199: rcp
    reg_tmp8.y = rcp_safe(-reg_tmp7.yyyy.x);
    // 200: mul
    reg_tmp8.y = (mul_safe(reg_tmp6.yyyy, reg_tmp8.yyyy)).y;
    // 201: mul
    reg_tmp7.xyz = (mul_safe(reg_tmp7.xyzz, reg_tmp8.yyyy)).xyz;
    // 202: add
    reg_tmp10.xyz = (reg_tmp10.xyzz + reg_tmp7.xyzz).xyz;
    // 203: add
    reg_tmp10.y = (uniforms.f[94].zzzz + reg_tmp10.yyyy).y;
    // 204: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_205_217();
    } else {
        sub_217_242();
    }
    // 242: mov
    vs_out_attr2 = -reg_tmp15;
    // 243: dp4
    reg_tmp0.x = dot(mul_safe(uniforms.f[86], reg_tmp15), vec4(1.0));
    // 244: dp4
    reg_tmp0.y = dot(mul_safe(uniforms.f[87], reg_tmp15), vec4(1.0));
    // 245: dp4
    reg_tmp0.z = dot(mul_safe(uniforms.f[88], reg_tmp15), vec4(1.0));
    // 246: dp4
    reg_tmp0.w = dot(mul_safe(uniforms.f[89], reg_tmp15), vec4(1.0));
    // 247: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 248: mul
    reg_tmp1.y = (mul_safe(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
    // 249: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 250: ifc
    if (all(conditional_code)) {
        sub_251_252();
    }
    // 252: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_179_189() {
    // 179: mul
    reg_tmp1.x = (mul_safe(uniforms.f[93].wwww, vs_in_reg7.xxxx)).x;
    // 180: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 181: dp4
    reg_tmp7.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 182: dp4
    reg_tmp7.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 183: dp4
    reg_tmp7.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 184: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 185: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 186: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 187: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 188: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_189_194() {
    // 189: mova
    address_registers.x = (ivec2(uniforms.f[93].xxxx)).x;
    // 190: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[25], reg_tmp15), vec4(1.0));
    // 191: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[26], reg_tmp15), vec4(1.0));
    // 192: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[27], reg_tmp15), vec4(1.0));
    // 193: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_205_217() {
    // 205: dp3
    reg_tmp12.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 206: dp3
    reg_tmp12.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 207: dp3
    reg_tmp12.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 208: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 209: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 210: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 211: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 212: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 213: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 214: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 215: call
    {
        sub_254_271();
    }
    // 216: nop
    return false;
}
bool sub_217_242() {
    // 217: ifc
    if (all(conditional_code)) {
        sub_218_236();
    } else {
        sub_236_241();
    }
    // 241: nop
    return false;
}
bool sub_218_236() {
    // 218: dp3
    reg_tmp12.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 219: dp3
    reg_tmp12.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 220: dp3
    reg_tmp12.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 221: dp3
    reg_tmp11.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 222: dp3
    reg_tmp11.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 223: dp3
    reg_tmp11.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 224: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 225: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 226: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 227: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 228: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 229: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 230: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 231: dp3
    reg_tmp13.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp11)), vec3(1.0));
    // 232: dp3
    reg_tmp13.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp11)), vec3(1.0));
    // 233: dp3
    reg_tmp13.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp11)), vec3(1.0));
    // 234: call
    {
        sub_271_347();
    }
    // 235: nop
    return false;
}
bool sub_236_241() {
    // 236: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 237: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 238: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 239: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 240: mov
    vs_out_attr1 = uniforms.f[93].xxxx;
    return false;
}
bool sub_251_252() {
    // 251: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_254_271() {
    uint jmp_to = 254u;
    while (true) {
        switch (jmp_to) {
        case 254u: {
            // 254: dp3
            reg_tmp6.x = dot(vec3(mul_safe(reg_tmp14, reg_tmp14)), vec3(1.0));
            // 255: dp3
            reg_tmp7.x = dot(vec3(mul_safe(reg_tmp12, reg_tmp12)), vec3(1.0));
            // 256: rsq
            reg_tmp6.x = rsq_safe(reg_tmp6.xxxx.x);
            // 257: rsq
            reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
            // 258: mul
            reg_tmp14.xyz = (mul_safe(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 259: mul
            reg_tmp12.xyz = (mul_safe(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 260: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 261: jmpu
            if (!uniforms.b[15]) {
                { jmp_to = 270u; break; }
            }
            // 262: add
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            // 263: mul
            reg_tmp4 = mul_safe(uniforms.f[94].zzzz, reg_tmp4);
            // 264: cmp
            conditional_code = greaterThanEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp4.xxxx));
            // 265: rsq
            reg_tmp4 = vec4(rsq_safe(reg_tmp4.xxxx.x));
            // 266: mul
            reg_tmp5 = mul_safe(uniforms.f[94].zzzz, reg_tmp14);
            // 267: jmpc
            if (conditional_code.x) {
                { jmp_to = 270u; break; }
            }
            // 268: rcp
            reg_tmp0.z = rcp_safe(reg_tmp4.xxxx.x);
            // 269: mul
            reg_tmp0.xy = (mul_safe(reg_tmp5, reg_tmp4)).xy;
        }
        case 270u: {
            // 270: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_271_347() {
    uint jmp_to = 271u;
    while (true) {
        switch (jmp_to) {
        case 271u: {
            // 271: dp3
            reg_tmp6.x = dot(vec3(mul_safe(reg_tmp14, reg_tmp14)), vec3(1.0));
            // 272: dp3
            reg_tmp7.x = dot(vec3(mul_safe(reg_tmp12, reg_tmp12)), vec3(1.0));
            // 273: rsq
            reg_tmp6.x = rsq_safe(reg_tmp6.xxxx.x);
            // 274: rsq
            reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
            // 275: mul
            reg_tmp14.xyz = (mul_safe(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 276: mul
            reg_tmp12.xyz = (mul_safe(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 277: mul
            reg_tmp13.xyz = (mul_safe(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            // 278: mul
            reg_tmp11.xyz = (mul_safe(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            // 279: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 280: jmpu
            if (!uniforms.b[15]) {
                { jmp_to = 346u; break; }
            }
            // 281: mul
            reg_tmp13.xyz = (mul_safe(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            // 282: mul
            reg_tmp11.xyz = (mul_safe(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            // 283: mul
            reg_tmp5 = mul_safe(reg_tmp14.yzxx, reg_tmp13.zxyy);
            // 284: mad
            reg_tmp5 = fma_safe(-reg_tmp13.yzxx, reg_tmp14.zxyy, reg_tmp5);
            // 285: dp3
            reg_tmp5.w = dot(vec3(mul_safe(reg_tmp5, reg_tmp5)), vec3(1.0));
            // 286: rsq
            reg_tmp5.w = rsq_safe(reg_tmp5.wwww.x);
            // 287: mul
            reg_tmp5 = mul_safe(reg_tmp5, reg_tmp5.wwww);
            // 288: add
            reg_tmp6.w = (reg_tmp14.zzzz + reg_tmp5.yyyy).w;
            // 289: mul
            reg_tmp13 = mul_safe(reg_tmp5.yzxx, reg_tmp14.zxyy);
            // 290: mad
            reg_tmp13 = fma_safe(-reg_tmp14.yzxx, reg_tmp5.zxyy, reg_tmp13);
            // 291: add
            reg_tmp6.w = (reg_tmp13.xxxx + reg_tmp6).w;
            // 292: mov
            reg_tmp13.w = (reg_tmp5.zzzz).w;
            // 293: mov
            reg_tmp5.z = (reg_tmp13.xxxx).z;
            // 294: add
            reg_tmp6.w = (uniforms.f[93].yyyy + reg_tmp6).w;
            // 295: mov
            reg_tmp14.w = (reg_tmp5.xxxx).w;
            // 296: mov
            reg_tmp5.x = (reg_tmp14.zzzz).x;
            // 297: cmp
            conditional_code = lessThan(vec2(uniforms.f[94].yyyy), vec2(reg_tmp6.wwww));
            // 298: mov
            reg_tmp6.x = (uniforms.f[93].yyyy).x;
            // 299: mov
            reg_tmp6.y = (-uniforms.f[93].yyyy).y;
            // 300: jmpc
            if (!conditional_code.x) {
                { jmp_to = 308u; break; }
            }
            // 301: add
            reg_tmp7.xz = (reg_tmp13.wwyy + -reg_tmp14.yyww).xz;
            // 302: add
            reg_tmp7.y = (reg_tmp14.xxxx + -reg_tmp13.zzzz).y;
            // 303: mov
            reg_tmp7.w = (reg_tmp6).w;
            // 304: dp4
            reg_tmp6 = vec4(dot(mul_safe(reg_tmp7, reg_tmp7), vec4(1.0)));
            // 305: rsq
            reg_tmp6 = vec4(rsq_safe(reg_tmp6.xxxx.x));
            // 306: mul
            reg_tmp0 = mul_safe(reg_tmp7, reg_tmp6);
            // 307: jmpu
            if (uniforms.b[0]) {
                { jmp_to = 346u; break; }
            }
        }
        case 308u: {
            // 308: cmp
            conditional_code = greaterThan(vec2(reg_tmp5.zyyy), vec2(reg_tmp5.yxxx));
            // 309: ifc
            if (conditional_code.x) {
                sub_310_330();
            } else {
                sub_330_343();
            }
            // 343: dp4
            reg_tmp6 = vec4(dot(mul_safe(reg_tmp8, reg_tmp8), vec4(1.0)));
            // 344: rsq
            reg_tmp6 = vec4(rsq_safe(reg_tmp6.xxxx.x));
            // 345: mul
            reg_tmp0 = mul_safe(reg_tmp8, reg_tmp6);
        }
        case 346u: {
            // 346: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_310_330() {
    // 310: ifc
    if (conditional_code.y) {
        sub_311_316();
    } else {
        sub_316_329();
    }
    // 329: mov
    reg_tmp8.w = (-reg_tmp8).w;
    return false;
}
bool sub_311_316() {
    // 311: mul
    reg_tmp8 = mul_safe(reg_tmp13.yyzw, reg_tmp6.xxxy);
    // 312: add
    reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
    // 313: add
    reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
    // 314: add
    reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
    // 315: add
    reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
    return false;
}
bool sub_316_329() {
    // 316: cmp
    conditional_code = greaterThan(vec2(reg_tmp5.zzzz), vec2(reg_tmp5.xxxx));
    // 317: mul
    reg_tmp8 = mul_safe(reg_tmp13.yyzw, reg_tmp6.xxxy);
    // 318: add
    reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
    // 319: ifc
    if (conditional_code.x) {
        sub_320_323();
    } else {
        sub_323_328();
    }
    // 328: nop
    return false;
}
bool sub_320_323() {
    // 320: add
    reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
    // 321: add
    reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
    // 322: add
    reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
    return false;
}
bool sub_323_328() {
    // 323: mul
    reg_tmp8 = mul_safe(reg_tmp13.zwwy, reg_tmp6.xxxy);
    // 324: add
    reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
    // 325: add
    reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
    // 326: add
    reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
    // 327: add
    reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
    return false;
}
bool sub_330_343() {
    // 330: ifc
    if (conditional_code.y) {
        sub_331_336();
    } else {
        sub_336_342();
    }
    // 342: nop
    return false;
}
bool sub_331_336() {
    // 331: mul
    reg_tmp8 = mul_safe(reg_tmp13.yywz, reg_tmp6.xxxy);
    // 332: add
    reg_tmp8.y = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).y;
    // 333: add
    reg_tmp9 = reg_tmp5.yyyy + -reg_tmp5.xxxx;
    // 334: add
    reg_tmp8.xzw = (reg_tmp8 + reg_tmp14.wwyx).xzw;
    // 335: add
    reg_tmp8.y = (reg_tmp9 + reg_tmp8).y;
    return false;
}
bool sub_336_342() {
    // 336: mul
    reg_tmp8 = mul_safe(reg_tmp13.zwwy, reg_tmp6.xxxy);
    // 337: add
    reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
    // 338: add
    reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
    // 339: add
    reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
    // 340: add
    reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
    // 341: mov
    reg_tmp8.w = (-reg_tmp8).w;
    return false;
}
bool sub_347_369() {
    // 347: mov
    reg_tmp8.xy = (uniforms.f[93].xxxx).xy;
    // 348: mov
    reg_tmp0.y = (uniforms.f[7].wwww).y;
    // 349: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.xyyy));
    // 350: mov
    reg_tmp9.xyz = (uniforms.f[93].xxxx).xyz;
    // 351: mov
    reg_tmp9.w = (uniforms.f[21].wwww).w;
    // 352: ifc
    if (conditional_code.y) {
        sub_353_358();
    }
    // 358: callu
    if (uniforms.b[12]) {
        sub_369_415();
    }
    // 359: cmp
    conditional_code = equal(vec2(uniforms.f[93].xxxx), vec2(reg_tmp8.xyyy));
    // 360: ifc
    if (all(conditional_code)) {
        sub_361_362();
    }
    // 362: add
    reg_tmp0.xyz = (uniforms.f[24].xyzz + -reg_tmp10.xyzz).xyz;
    // 363: rcp
    reg_tmp0.w = rcp_safe(uniforms.f[24].wwww.x);
    // 364: dp3
    reg_tmp1.w = dot(vec3(mul_safe(reg_tmp0.xyzz, reg_tmp0.xyzz)), vec3(1.0));
    // 365: mul
    reg_tmp1.w = (mul_safe(reg_tmp0.wwww, reg_tmp1.wwww)).w;
    // 366: min
    reg_tmp1.w = (min(uniforms.f[93].yyyy, reg_tmp1.wwww)).w;
    // 367: add
    reg_tmp9.w = (uniforms.f[93].yyyy + -reg_tmp1.wwww).w;
    // 368: max
    vs_out_attr3 = max(uniforms.f[93].xxxx, reg_tmp9);
    return false;
}
bool sub_353_358() {
    // 353: mul
    reg_tmp0 = mul_safe(uniforms.f[7].wwww, vs_in_reg3);
    // 354: ifu
    if (uniforms.b[7]) {
        sub_355_356();
    }
    // 356: mul
    reg_tmp9.xyz = (mul_safe(uniforms.f[20].wwww, reg_tmp0.xyzz)).xyz;
    // 357: mov
    reg_tmp8.x = (uniforms.f[93].yyyy).x;
    return false;
}
bool sub_355_356() {
    // 355: mul
    reg_tmp9.w = (mul_safe(reg_tmp9.wwww, reg_tmp0.wwww)).w;
    return false;
}
bool sub_361_362() {
    // 361: mov
    reg_tmp9 = uniforms.f[21];
    return false;
}
bool sub_369_415() {
    // 369: mov
    reg_tmp1 = uniforms.f[20];
    // 370: mov
    reg_tmp2 = uniforms.f[21];
    // 371: mov
    reg_tmp3 = uniforms.f[93].xxxx;
    // 372: loop
    address_registers.z = int(uniforms.i[0].y);
    for (uint loop372 = 0u; loop372 <= uniforms.i[0].x; address_registers.z += int(uniforms.i[0].z), ++loop372) {
        sub_373_414();
    }
    // 414: mov
    reg_tmp8.x = (uniforms.f[93].yyyy).x;
    return false;
}
bool sub_373_414() {
    // 373: mova
    address_registers.x = (ivec2(reg_tmp3)).x;
    // 374: mov
    reg_tmp4.x = (uniforms.f[81 + address_registers.x].wwww).x;
    // 375: mov
    reg_tmp4.y = (uniforms.f[83 + address_registers.x].wwww).y;
    // 376: cmp
    conditional_code = equal(vec2(uniforms.f[93].xyyy), vec2(reg_tmp4.xyyy));
    // 377: ifc
    if (conditional_code.x) {
        sub_378_380();
    } else {
        sub_380_404();
    }
    // 404: cmp
    conditional_code.x = uniforms.f[93].xxxx.x == reg_tmp6.xyyy.x;
    conditional_code.y = uniforms.f[93].xxxx.y < reg_tmp6.xyyy.y;
    // 405: ifc
    if (conditional_code.y) {
        sub_406_413();
    }
    // 413: add
    reg_tmp3 = -uniforms.f[95].wwww + reg_tmp3;
    return false;
}
bool sub_378_380() {
    // 378: dp3
    reg_tmp6.x = dot(vec3(mul_safe(uniforms.f[81 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 379: mov
    reg_tmp6.y = (uniforms.f[93].yyyy).y;
    return false;
}
bool sub_380_404() {
    // 380: add
    reg_tmp4 = uniforms.f[81 + address_registers.x] + -reg_tmp15;
    // 381: mov
    reg_tmp6.y = (uniforms.f[93].yyyy).y;
    // 382: ifc
    if (conditional_code.y) {
        sub_383_388();
    }
    // 388: mov
    reg_tmp5 = uniforms.f[82 + address_registers.x];
    // 389: cmp
    conditional_code = equal(vec2(uniforms.f[93].yyyy), vec2(reg_tmp5.wwww));
    // 390: dp3
    reg_tmp4.w = dot(vec3(mul_safe(reg_tmp4, reg_tmp4)), vec3(1.0));
    // 391: rsq
    reg_tmp4.w = rsq_safe(reg_tmp4.wwww.x);
    // 392: mul
    reg_tmp4 = mul_safe(reg_tmp4, reg_tmp4.wwww);
    // 393: ifc
    if (conditional_code.x) {
        sub_394_403();
    }
    // 403: dp3
    reg_tmp6.x = dot(vec3(mul_safe(reg_tmp14, reg_tmp4)), vec3(1.0));
    return false;
}
bool sub_383_388() {
    // 383: mov
    reg_tmp5.x = (uniforms.f[93].yyyy).x;
    // 384: dp3
    reg_tmp5.z = dot(vec3(mul_safe(reg_tmp4, reg_tmp4)), vec3(1.0));
    // 385: mul
    reg_tmp5.y = (mul_safe(reg_tmp5.zzzz, reg_tmp5.zzzz)).y;
    // 386: dp3
    reg_tmp6.y = dot(vec3(mul_safe(uniforms.f[83 + address_registers.x], reg_tmp5)), vec3(1.0));
    // 387: rcp
    reg_tmp6.y = rcp_safe(reg_tmp6.yyyy.x);
    return false;
}
bool sub_394_403() {
    // 394: dp3
    reg_tmp5.x = dot(vec3(mul_safe(uniforms.f[82 + address_registers.x], -reg_tmp4)), vec3(1.0));
    // 395: slti
    reg_tmp5.y = (vec4(lessThan(reg_tmp5.xxxx,uniforms.f[84 + address_registers.x].yyyy))).y;
    // 396: cmp
    conditional_code = equal(vec2(uniforms.f[93].yyyy), vec2(reg_tmp5.xyyy));
    // 397: ifc
    if (conditional_code.y) {
        sub_398_399();
    } else {
        sub_399_402();
    }
    // 402: mul
    reg_tmp6.y = (mul_safe(reg_tmp6.yyyy, reg_tmp5.xxxx)).y;
    return false;
}
bool sub_398_399() {
    // 398: mov
    reg_tmp5.x = (uniforms.f[93].xxxx).x;
    return false;
}
bool sub_399_402() {
    // 399: log
    reg_tmp5.y = log2(reg_tmp5.xxxx.x);
    // 400: mul
    reg_tmp5.y = (mul_safe(uniforms.f[84 + address_registers.x].xxxx, reg_tmp5.yyyy)).y;
    // 401: exp
    reg_tmp5.x = exp2(reg_tmp5.yyyy.x);
    return false;
}
bool sub_406_413() {
    // 406: max
    reg_tmp6.x = (max(uniforms.f[93].xxxx, reg_tmp6.xxxx)).x;
    // 407: mad
    reg_tmp9.xyz = (fma_safe(reg_tmp1.xyzz, uniforms.f[79 + address_registers.x].xyzz, reg_tmp9.xyzz)).xyz;
    // 408: mul
    reg_tmp4 = mul_safe(uniforms.f[80 + address_registers.x], reg_tmp2);
    // 409: mul
    reg_tmp5.xyz = (mul_safe(reg_tmp6.xxxx, reg_tmp4.xyzz)).xyz;
    // 410: mul
    reg_tmp5.xyz = (mul_safe(reg_tmp6.yyyy, reg_tmp5.xyzz)).xyz;
    // 411: add
    reg_tmp9.xyz = (reg_tmp9.xyzz + reg_tmp5.xyzz).xyz;
    // 412: add
    reg_tmp9.w = (reg_tmp9.wwww + reg_tmp4.wwww).w;
    return false;
}
// reference: E93DB1C66E8E4AF3, 52FC86954A48E51C
// program: 52FC86954A48E51C, AD7922A63ED54CA7, AAD077FFD85152AB
// reference: 575FBDB44F87C38C, 4EFF2C77DB8F9E73
// program: 0000000000000000, 0000000000000000, AEA8529257EA252C
// reference: B70A0F52F5272121, BF583C1F84D94483
// program: BF583C1F84D94483, 5D764F9A6220D694, 68475D8B9F916549
// reference: 2E5F77132E9E8066, BF583C1F84D94483
// program: 0000000000000000, 0000000000000000, A8ADD30A63E76265
// reference: CE0AC5F5943E62CB, 4EFF2C77DB8F9E73
// reference: F81B2FF38E017FAE, 17716008BB716A8F
// reference: 1B6FEA60DDCC3738, E661110CC0BF42D1
// reference: 1B6FEA6032F5A479, E661110CC0BF42D1
// reference: 4F4FC0EA6CB7FCED, 4EFF2C77DB8F9E73
// reference: E00B52ADAD3140CF, 17716008BB716A8F
// reference: 4F4FC0EA838E6FAC, 4EFF2C77DB8F9E73
// reference: AC515EDF2F9842FB, 608565C51104A52F
// reference: E0A4903932F5A479, E661110CC0BF42D1
// reference: B484BAB36CB7FCED, 4EFF2C77DB8F9E73
// reference: 1BC028F4AD3140CF, 17716008BB716A8F
// reference: 1BC028F44208D38E, 17716008BB716A8F
// reference: B484BAB3838E6FAC, 4EFF2C77DB8F9E73
// program: 4EFF2C77DB8F9E73, 3B3AE026C742C7D5, 528296AD4921766A
// reference: C91D23AEE182812D, 76204850D3D31438
// reference: 50485BEF3A3B206A, 76204850D3D31438
// reference: 2DD1C2F2B70E5DAA, 4EFF2C77DB8F9E73
// program: BF583C1F84D94483, 5D764F9A6220D694, FA9C11D88771DF9F
// program: BF583C1F84D94483, 5D764F9A6220D694, 09AA976E69641246
// reference: 575FBDB4A0BE50CD, 4EFF2C77DB8F9E73
// reference: 823A9221E94C053E, E661110CC0BF42D1
// program: 4EFF2C77DB8F9E73, 3B3AE026C742C7D5, B1928C77DA82D8DC
// program: 4EFF2C77DB8F9E73, 3B3AE026C742C7D5, BD3EBAD315031A9C
// program: 4EFF2C77DB8F9E73, 3B3AE026C742C7D5, 5AB91AFAAFD32BB6
// reference: 32D659F7E182812D, 76204850D3D31438
// reference: AB8321B63A3B206A, 76204850D3D31438
// reference: D61AB8ABB70E5DAA, 4EFF2C77DB8F9E73
// reference: E00B52AD4208D38E, 17716008BB716A8F
// program: 4EFF2C77DB8F9E73, 3B3AE026C742C7D5, AB9CD65F41BDEFA0
// program: 4EFF2C77DB8F9E73, 3B3AE026C742C7D5, 98125BD9033DAC4C
// program: 4EFF2C77DB8F9E73, 3B3AE026C742C7D5, A4FE917C39832451
// reference: 104E235985E7F91D, 76204850D3D31438
// reference: 891B5B185E5E585A, 76204850D3D31438
// program: 76204850D3D31438, AD7922A63ED54CA7, 8A76329CB25030B1
// reference: 253BAF991350E848, BF583C1F84D94483
// program: BF583C1F84D94483, 5D764F9A6220D694, 0B496AE87480A30D
// reference: BC6ED7D8C8E9490F, BF583C1F84D94483
// program: 0000000000000000, 0000000000000000, 9984ECD2B5F69CEC
// shader: 8B31, 2B10AE6FA2719F48

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define mul_safe(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define rcp_safe(x) (1.0f / x)
#define rsq_safe(x) inversesqrt(x)
#define fma_safe(x, y, z) (mul_safe(x, y) + z)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_6_11();
bool sub_11_20();
bool sub_20_29();
bool sub_37_197();
bool sub_42_139();
bool sub_48_76();
bool sub_59_63();
bool sub_76_129();
bool sub_77_104();
bool sub_88_92();
bool sub_104_128();
bool sub_115_119();
bool sub_137_138();
bool sub_139_194();
bool sub_142_152();
bool sub_152_157();
bool sub_158_168();
bool sub_168_184();
bool sub_169_179();
bool sub_179_183();
bool sub_192_193();
bool sub_197_214();
bool sub_203_208();
bool sub_205_206();
bool sub_212_213();
bool sub_214_260();
bool sub_218_259();
bool sub_223_225();
bool sub_225_249();
bool sub_228_233();
bool sub_239_248();
bool sub_243_244();
bool sub_244_247();
bool sub_251_258();
bool sub_260_270();
bool sub_267_268();
bool sub_279_288();
bool sub_321_329();
bool sub_323_324();
bool sub_324_328();
bool sub_325_326();
bool sub_326_327();
bool sub_329_333();
bool sub_333_4096();
bool sub_339_366();
bool sub_341_346();
bool sub_346_365();
bool sub_349_355();
bool sub_355_364();
bool sub_356_360();
bool sub_360_363();
bool sub_366_373();

bool exec_shader() {
    sub_333_4096();
    return true;
}

bool sub_6_11() {
    // 6: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 7: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 8: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 9: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 10: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    return false;
}
bool sub_11_20() {
    // 11: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 12: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 13: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 14: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 15: dp3
    reg_tmp4.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 16: dp3
    reg_tmp4.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 17: dp3
    reg_tmp4.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 18: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 19: mad
    reg_tmp12 = fma_safe(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_20_29() {
    // 20: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 21: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 22: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 23: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 24: dp3
    reg_tmp4.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 25: dp3
    reg_tmp4.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 26: dp3
    reg_tmp4.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 27: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 28: mad
    reg_tmp12 = fma_safe(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_37_197() {
    // 37: mul
    reg_tmp15.xyz = (mul_safe(uniforms.f[7].xxxx, vs_in_reg0)).xyz;
    // 38: mul
    reg_tmp14.xyz = (mul_safe(uniforms.f[7].yyyy, vs_in_reg1)).xyz;
    // 39: add
    reg_tmp15.xyz = (uniforms.f[6] + reg_tmp15).xyz;
    // 40: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 41: ifu
    if (uniforms.b[1]) {
        sub_42_139();
    } else {
        sub_139_194();
    }
    // 194: nop
    // 195: mov
    vs_out_attr1 = uniforms.f[93].xxxx;
    // 196: mov
    vs_out_attr2 = uniforms.f[93].xxxx;
    return false;
}
bool sub_42_139() {
    // 42: mov
    reg_tmp0 = uniforms.f[7];
    // 43: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.yzzz));
    // 44: mov
    reg_tmp7 = uniforms.f[93].xxxx;
    // 45: mov
    reg_tmp12 = uniforms.f[93].xxxx;
    // 46: mul
    reg_tmp2 = mul_safe(uniforms.f[93].wwww, vs_in_reg7);
    // 47: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_48_76();
    } else {
        sub_76_129();
    }
    // 129: dp4
    reg_tmp0.x = dot(mul_safe(uniforms.f[86], reg_tmp15), vec4(1.0));
    // 130: dp4
    reg_tmp0.y = dot(mul_safe(uniforms.f[87], reg_tmp15), vec4(1.0));
    // 131: dp4
    reg_tmp0.z = dot(mul_safe(uniforms.f[88], reg_tmp15), vec4(1.0));
    // 132: dp4
    reg_tmp0.w = dot(mul_safe(uniforms.f[89], reg_tmp15), vec4(1.0));
    // 133: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 134: mul
    reg_tmp1.y = (mul_safe(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
    // 135: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 136: ifc
    if (all(conditional_code)) {
        sub_137_138();
    }
    // 138: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_48_76() {
    // 48: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 49: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 50: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 51: call
    {
        sub_11_20();
    }
    // 52: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 53: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 54: call
    {
        sub_11_20();
    }
    // 55: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 56: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 57: callc
    if (conditional_code.x) {
        sub_11_20();
    }
    // 58: ifu
    if (uniforms.b[8]) {
        sub_59_63();
    }
    // 63: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 64: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 65: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 66: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 67: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 68: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 69: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 70: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 71: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 72: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 73: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 74: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 75: nop
    return false;
}
bool sub_59_63() {
    // 59: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 60: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 61: callc
    if (conditional_code.y) {
        sub_11_20();
    }
    // 62: nop
    return false;
}
bool sub_76_129() {
    // 76: ifc
    if (all(conditional_code)) {
        sub_77_104();
    } else {
        sub_104_128();
    }
    // 128: nop
    return false;
}
bool sub_77_104() {
    // 77: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 78: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 79: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 80: call
    {
        sub_20_29();
    }
    // 81: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 82: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 83: call
    {
        sub_20_29();
    }
    // 84: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 85: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 86: callc
    if (conditional_code.x) {
        sub_20_29();
    }
    // 87: ifu
    if (uniforms.b[8]) {
        sub_88_92();
    }
    // 92: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 93: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 94: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 95: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 96: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 97: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 98: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 99: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 100: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 101: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 102: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 103: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_88_92() {
    // 88: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 89: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 90: callc
    if (conditional_code.y) {
        sub_20_29();
    }
    // 91: nop
    return false;
}
bool sub_104_128() {
    // 104: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 105: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 106: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 107: call
    {
        sub_6_11();
    }
    // 108: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 109: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 110: call
    {
        sub_6_11();
    }
    // 111: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 112: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 113: callc
    if (conditional_code.x) {
        sub_6_11();
    }
    // 114: ifu
    if (uniforms.b[8]) {
        sub_115_119();
    }
    // 119: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 120: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 121: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 122: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 123: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 124: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 125: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 126: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 127: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_115_119() {
    // 115: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 116: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 117: callc
    if (conditional_code.y) {
        sub_6_11();
    }
    // 118: nop
    return false;
}
bool sub_137_138() {
    // 137: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_139_194() {
    // 139: mov
    reg_tmp0 = uniforms.f[7];
    // 140: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.yzzz));
    // 141: ifu
    if (uniforms.b[2]) {
        sub_142_152();
    } else {
        sub_152_157();
    }
    // 157: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_158_168();
    } else {
        sub_168_184();
    }
    // 184: dp4
    reg_tmp0.x = dot(mul_safe(uniforms.f[86], reg_tmp15), vec4(1.0));
    // 185: dp4
    reg_tmp0.y = dot(mul_safe(uniforms.f[87], reg_tmp15), vec4(1.0));
    // 186: dp4
    reg_tmp0.z = dot(mul_safe(uniforms.f[88], reg_tmp15), vec4(1.0));
    // 187: dp4
    reg_tmp0.w = dot(mul_safe(uniforms.f[89], reg_tmp15), vec4(1.0));
    // 188: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 189: mul
    reg_tmp1.y = (mul_safe(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
    // 190: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 191: ifc
    if (all(conditional_code)) {
        sub_192_193();
    }
    // 193: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_142_152() {
    // 142: mul
    reg_tmp1.x = (mul_safe(uniforms.f[93].wwww, vs_in_reg7.xxxx)).x;
    // 143: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 144: dp4
    reg_tmp7.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 145: dp4
    reg_tmp7.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 146: dp4
    reg_tmp7.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 147: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 148: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 149: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 150: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 151: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_152_157() {
    // 152: mova
    address_registers.x = (ivec2(uniforms.f[93].xxxx)).x;
    // 153: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[25], reg_tmp15), vec4(1.0));
    // 154: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[26], reg_tmp15), vec4(1.0));
    // 155: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[27], reg_tmp15), vec4(1.0));
    // 156: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_158_168() {
    // 158: dp3
    reg_tmp12.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 159: dp3
    reg_tmp12.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 160: dp3
    reg_tmp12.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 161: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 162: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 163: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 164: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 165: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 166: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 167: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_168_184() {
    // 168: ifc
    if (all(conditional_code)) {
        sub_169_179();
    } else {
        sub_179_183();
    }
    // 183: nop
    return false;
}
bool sub_169_179() {
    // 169: dp3
    reg_tmp12.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 170: dp3
    reg_tmp12.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 171: dp3
    reg_tmp12.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 172: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 173: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 174: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 175: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 176: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 177: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 178: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_179_183() {
    // 179: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 180: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 181: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 182: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_192_193() {
    // 192: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_197_214() {
    // 197: mov
    reg_tmp8.xy = (uniforms.f[93].xxxx).xy;
    // 198: mov
    reg_tmp0.y = (uniforms.f[7].wwww).y;
    // 199: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.xyyy));
    // 200: mov
    reg_tmp9.xyz = (uniforms.f[93].xxxx).xyz;
    // 201: mov
    reg_tmp9.w = (uniforms.f[21].wwww).w;
    // 202: ifc
    if (conditional_code.y) {
        sub_203_208();
    }
    // 208: callu
    if (uniforms.b[12]) {
        sub_214_260();
    }
    // 209: callu
    if (uniforms.b[5]) {
        sub_260_270();
    }
    // 210: cmp
    conditional_code = equal(vec2(uniforms.f[93].xxxx), vec2(reg_tmp8.xyyy));
    // 211: ifc
    if (all(conditional_code)) {
        sub_212_213();
    }
    // 213: max
    vs_out_attr3 = max(uniforms.f[93].xxxx, reg_tmp9);
    return false;
}
bool sub_203_208() {
    // 203: mul
    reg_tmp0 = mul_safe(uniforms.f[7].wwww, vs_in_reg3);
    // 204: ifu
    if (uniforms.b[7]) {
        sub_205_206();
    }
    // 206: mul
    reg_tmp9.xyz = (mul_safe(uniforms.f[20].wwww, reg_tmp0.xyzz)).xyz;
    // 207: mov
    reg_tmp8.x = (uniforms.f[93].yyyy).x;
    return false;
}
bool sub_205_206() {
    // 205: mul
    reg_tmp9.w = (mul_safe(reg_tmp9.wwww, reg_tmp0.wwww)).w;
    return false;
}
bool sub_212_213() {
    // 212: mov
    reg_tmp9 = uniforms.f[21];
    return false;
}
bool sub_214_260() {
    // 214: mov
    reg_tmp1 = uniforms.f[20];
    // 215: mov
    reg_tmp2 = uniforms.f[21];
    // 216: mov
    reg_tmp3 = uniforms.f[93].xxxx;
    // 217: loop
    address_registers.z = int(uniforms.i[0].y);
    for (uint loop217 = 0u; loop217 <= uniforms.i[0].x; address_registers.z += int(uniforms.i[0].z), ++loop217) {
        sub_218_259();
    }
    // 259: mov
    reg_tmp8.x = (uniforms.f[93].yyyy).x;
    return false;
}
bool sub_218_259() {
    // 218: mova
    address_registers.x = (ivec2(reg_tmp3)).x;
    // 219: mov
    reg_tmp4.x = (uniforms.f[81 + address_registers.x].wwww).x;
    // 220: mov
    reg_tmp4.y = (uniforms.f[83 + address_registers.x].wwww).y;
    // 221: cmp
    conditional_code = equal(vec2(uniforms.f[93].xyyy), vec2(reg_tmp4.xyyy));
    // 222: ifc
    if (conditional_code.x) {
        sub_223_225();
    } else {
        sub_225_249();
    }
    // 249: cmp
    conditional_code.x = uniforms.f[93].xxxx.x == reg_tmp6.xyyy.x;
    conditional_code.y = uniforms.f[93].xxxx.y < reg_tmp6.xyyy.y;
    // 250: ifc
    if (conditional_code.y) {
        sub_251_258();
    }
    // 258: add
    reg_tmp3 = -uniforms.f[95].wwww + reg_tmp3;
    return false;
}
bool sub_223_225() {
    // 223: dp3
    reg_tmp6.x = dot(vec3(mul_safe(uniforms.f[81 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 224: mov
    reg_tmp6.y = (uniforms.f[93].yyyy).y;
    return false;
}
bool sub_225_249() {
    // 225: add
    reg_tmp4 = uniforms.f[81 + address_registers.x] + -reg_tmp15;
    // 226: mov
    reg_tmp6.y = (uniforms.f[93].yyyy).y;
    // 227: ifc
    if (conditional_code.y) {
        sub_228_233();
    }
    // 233: mov
    reg_tmp5 = uniforms.f[82 + address_registers.x];
    // 234: cmp
    conditional_code = equal(vec2(uniforms.f[93].yyyy), vec2(reg_tmp5.wwww));
    // 235: dp3
    reg_tmp4.w = dot(vec3(mul_safe(reg_tmp4, reg_tmp4)), vec3(1.0));
    // 236: rsq
    reg_tmp4.w = rsq_safe(reg_tmp4.wwww.x);
    // 237: mul
    reg_tmp4 = mul_safe(reg_tmp4, reg_tmp4.wwww);
    // 238: ifc
    if (conditional_code.x) {
        sub_239_248();
    }
    // 248: dp3
    reg_tmp6.x = dot(vec3(mul_safe(reg_tmp14, reg_tmp4)), vec3(1.0));
    return false;
}
bool sub_228_233() {
    // 228: mov
    reg_tmp5.x = (uniforms.f[93].yyyy).x;
    // 229: dp3
    reg_tmp5.z = dot(vec3(mul_safe(reg_tmp4, reg_tmp4)), vec3(1.0));
    // 230: mul
    reg_tmp5.y = (mul_safe(reg_tmp5.zzzz, reg_tmp5.zzzz)).y;
    // 231: dp3
    reg_tmp6.y = dot(vec3(mul_safe(uniforms.f[83 + address_registers.x], reg_tmp5)), vec3(1.0));
    // 232: rcp
    reg_tmp6.y = rcp_safe(reg_tmp6.yyyy.x);
    return false;
}
bool sub_239_248() {
    // 239: dp3
    reg_tmp5.x = dot(vec3(mul_safe(uniforms.f[82 + address_registers.x], -reg_tmp4)), vec3(1.0));
    // 240: slti
    reg_tmp5.y = (vec4(lessThan(reg_tmp5.xxxx,uniforms.f[84 + address_registers.x].yyyy))).y;
    // 241: cmp
    conditional_code = equal(vec2(uniforms.f[93].yyyy), vec2(reg_tmp5.xyyy));
    // 242: ifc
    if (conditional_code.y) {
        sub_243_244();
    } else {
        sub_244_247();
    }
    // 247: mul
    reg_tmp6.y = (mul_safe(reg_tmp6.yyyy, reg_tmp5.xxxx)).y;
    return false;
}
bool sub_243_244() {
    // 243: mov
    reg_tmp5.x = (uniforms.f[93].xxxx).x;
    return false;
}
bool sub_244_247() {
    // 244: log
    reg_tmp5.y = log2(reg_tmp5.xxxx.x);
    // 245: mul
    reg_tmp5.y = (mul_safe(uniforms.f[84 + address_registers.x].xxxx, reg_tmp5.yyyy)).y;
    // 246: exp
    reg_tmp5.x = exp2(reg_tmp5.yyyy.x);
    return false;
}
bool sub_251_258() {
    // 251: max
    reg_tmp6.x = (max(uniforms.f[93].xxxx, reg_tmp6.xxxx)).x;
    // 252: mad
    reg_tmp9.xyz = (fma_safe(reg_tmp1.xyzz, uniforms.f[79 + address_registers.x].xyzz, reg_tmp9.xyzz)).xyz;
    // 253: mul
    reg_tmp4 = mul_safe(uniforms.f[80 + address_registers.x], reg_tmp2);
    // 254: mul
    reg_tmp5.xyz = (mul_safe(reg_tmp6.xxxx, reg_tmp4.xyzz)).xyz;
    // 255: mul
    reg_tmp5.xyz = (mul_safe(reg_tmp6.yyyy, reg_tmp5.xyzz)).xyz;
    // 256: add
    reg_tmp9.xyz = (reg_tmp9.xyzz + reg_tmp5.xyzz).xyz;
    // 257: add
    reg_tmp9.w = (reg_tmp9.wwww + reg_tmp4.wwww).w;
    return false;
}
bool sub_260_270() {
    // 260: dp3
    reg_tmp1 = vec4(dot(vec3(mul_safe(uniforms.f[24], reg_tmp14)), vec3(1.0)));
    // 261: mov
    reg_tmp2 = uniforms.f[24].wwww;
    // 262: mad
    reg_tmp1 = fma_safe(reg_tmp1, reg_tmp2, reg_tmp2);
    // 263: mov
    reg_tmp3 = uniforms.f[22];
    // 264: add
    reg_tmp2 = uniforms.f[23] + -reg_tmp3;
    // 265: mad
    reg_tmp4 = fma_safe(reg_tmp2, reg_tmp1, reg_tmp3);
    // 266: ifu
    if (uniforms.b[6]) {
        sub_267_268();
    }
    // 268: mad
    reg_tmp9.xyz = (fma_safe(reg_tmp4, uniforms.f[21], reg_tmp9)).xyz;
    // 269: mov
    reg_tmp8.x = (uniforms.f[93].yyyy).x;
    return false;
}
bool sub_267_268() {
    // 267: mul
    reg_tmp4 = mul_safe(reg_tmp4, reg_tmp9.wwww);
    return false;
}
bool sub_279_288() {
    // 279: dp3
    reg_tmp5.x = dot(vec3(mul_safe(uniforms.f[90], reg_tmp12.xyzz)), vec3(1.0));
    // 280: dp3
    reg_tmp5.y = dot(vec3(mul_safe(uniforms.f[91], reg_tmp12.xyzz)), vec3(1.0));
    // 281: dp3
    reg_tmp5.z = dot(vec3(mul_safe(uniforms.f[92], reg_tmp12.xyzz)), vec3(1.0));
    // 282: dp4
    reg_tmp4.x = dot(mul_safe(reg_tmp5.xyzz, reg_tmp5.xyzz), vec4(1.0));
    // 283: rsq
    reg_tmp4.x = rsq_safe(reg_tmp4.xxxx.x);
    // 284: mul
    reg_tmp4.xyz = (mul_safe(reg_tmp5.xyzz, reg_tmp4.xxxx)).xyz;
    // 285: mul
    reg_tmp4 = mul_safe(uniforms.f[94].zzzz, reg_tmp4);
    // 286: add
    reg_tmp12 = uniforms.f[94].zzzz + reg_tmp4;
    // 287: mov
    vs_out_attr5 = reg_tmp12;
    return false;
}
bool sub_321_329() {
    // 321: cmp
    conditional_code = equal(vec2(uniforms.f[93].yzzz), vec2(reg_tmp0.xyyy));
    // 322: ifc
    if (all(not(conditional_code))) {
        sub_323_324();
    } else {
        sub_324_328();
    }
    // 328: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_323_324() {
    // 323: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
    return false;
}
bool sub_324_328() {
    // 324: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_325_326();
    } else {
        sub_326_327();
    }
    // 327: nop
    return false;
}
bool sub_325_326() {
    // 325: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
    return false;
}
bool sub_326_327() {
    // 326: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
    return false;
}
bool sub_329_333() {
    // 329: mov
    reg_tmp1.xy = (uniforms.f[94].zzzz).xy;
    // 330: mov
    reg_tmp1.zw = (uniforms.f[93].xxxx).zw;
    // 331: mad
    reg_tmp6 = fma_safe(reg_tmp14, reg_tmp1, reg_tmp1);
    // 332: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_333_4096() {
    // 333: call
    {
        sub_37_197();
    }
    // 334: call
    {
        sub_197_214();
    }
    // 335: call
    {
        sub_339_366();
    }
    // 336: call
    {
        sub_279_288();
    }
    // 337: end
    return true;
}
bool sub_339_366() {
    // 339: mov
    reg_tmp0.xy = (uniforms.f[10].xxxx).xy;
    // 340: ifu
    if (uniforms.b[9]) {
        sub_341_346();
    } else {
        sub_346_365();
    }
    // 365: nop
    return false;
}
bool sub_341_346() {
    // 341: call
    {
        sub_321_329();
    }
    // 342: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[11].xywz, reg_tmp6), vec4(1.0));
    // 343: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[12].xywz, reg_tmp6), vec4(1.0));
    // 344: mov
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    // 345: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_346_365() {
    // 346: cmp
    conditional_code = equal(vec2(uniforms.f[95].xyyy), vec2(reg_tmp0.xyyy));
    // 347: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 348: ifc
    if (all(not(conditional_code))) {
        sub_349_355();
    } else {
        sub_355_364();
    }
    // 364: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_349_355() {
    // 349: mov
    reg_tmp6 = reg_tmp10;
    // 350: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[11], reg_tmp6), vec4(1.0));
    // 351: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[12], reg_tmp6), vec4(1.0));
    // 352: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[13], reg_tmp6), vec4(1.0));
    // 353: mul
    reg_tmp0.xy = (mul_safe(uniforms.f[19].xyyy, reg_tmp3.zzzz)).xy;
    // 354: add
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_355_364() {
    // 355: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_356_360();
    } else {
        sub_360_363();
    }
    // 363: nop
    return false;
}
bool sub_356_360() {
    // 356: call
    {
        sub_366_373();
    }
    // 357: dp3
    reg_tmp3.x = dot(vec3(mul_safe(uniforms.f[11], reg_tmp6)), vec3(1.0));
    // 358: dp3
    reg_tmp3.y = dot(vec3(mul_safe(uniforms.f[12], reg_tmp6)), vec3(1.0));
    // 359: dp3
    reg_tmp3.z = dot(vec3(mul_safe(uniforms.f[13], reg_tmp6)), vec3(1.0));
    return false;
}
bool sub_360_363() {
    // 360: call
    {
        sub_329_333();
    }
    // 361: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[11], reg_tmp6), vec4(1.0));
    // 362: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[12], reg_tmp6), vec4(1.0));
    return false;
}
bool sub_366_373() {
    // 366: mov
    reg_tmp2 = -reg_tmp15;
    // 367: dp3
    reg_tmp2.w = dot(vec3(mul_safe(reg_tmp2, reg_tmp2)), vec3(1.0));
    // 368: rsq
    reg_tmp2.w = rsq_safe(reg_tmp2.wwww.x);
    // 369: mul
    reg_tmp2 = mul_safe(reg_tmp2, reg_tmp2.wwww);
    // 370: dp3
    reg_tmp1 = vec4(dot(vec3(mul_safe(reg_tmp2, reg_tmp14)), vec3(1.0)));
    // 371: add
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    // 372: mad
    reg_tmp6 = fma_safe(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
// reference: CCC00D86422ABEAF, 2B10AE6FA2719F48
// program: 2B10AE6FA2719F48, 3B3AE026C742C7D5, 09998F9B86E3CF69
// reference: 559575C799931FE8, 2B10AE6FA2719F48
// program: 2B10AE6FA2719F48, 3B3AE026C742C7D5, 964E0B11E50F8F6E
// shader: 8B31, EC345D93DF769150

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;
 out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define mul_safe(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define rcp_safe(x) (1.0f / x)
#define rsq_safe(x) inversesqrt(x)
#define fma_safe(x, y, z) (mul_safe(x, y) + z)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_4096();
bool sub_7_12();
bool sub_12_21();
bool sub_21_34();
bool sub_34_214();
bool sub_40_146();
bool sub_47_76();
bool sub_58_62();
bool sub_76_135();
bool sub_77_109();
bool sub_88_92();
bool sub_109_134();
bool sub_120_124();
bool sub_144_145();
bool sub_146_213();
bool sub_149_159();
bool sub_159_164();
bool sub_165_177();
bool sub_177_202();
bool sub_178_196();
bool sub_196_201();
bool sub_211_212();
bool sub_214_231();
bool sub_231_307();
bool sub_270_290();
bool sub_271_276();
bool sub_276_289();
bool sub_280_283();
bool sub_283_288();
bool sub_290_303();
bool sub_291_296();
bool sub_296_302();
bool sub_307_351();
bool sub_351_378();
bool sub_353_358();
bool sub_358_377();
bool sub_361_367();
bool sub_367_376();
bool sub_368_372();
bool sub_372_375();
bool sub_378_386();
bool sub_380_381();
bool sub_381_385();
bool sub_382_383();
bool sub_383_384();
bool sub_386_393();
bool sub_393_397();
bool sub_397_421();
bool sub_399_403();
bool sub_403_420();
bool sub_404_418();
bool sub_407_414();
bool sub_414_417();
bool sub_418_419();
bool sub_421_437();
bool sub_423_427();
bool sub_427_436();
bool sub_428_434();
bool sub_434_435();

bool exec_shader() {
    sub_0_4096();
    return true;
}

bool sub_0_4096() {
    // 0: call
    {
        sub_34_214();
    }
    // 1: call
    {
        sub_307_351();
    }
    // 2: call
    {
        sub_351_378();
    }
    // 3: call
    {
        sub_397_421();
    }
    // 4: call
    {
        sub_421_437();
    }
    // 5: end
    return true;
}
bool sub_7_12() {
    // 7: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 8: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 9: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 10: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 11: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    return false;
}
bool sub_12_21() {
    // 12: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 13: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 14: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 15: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 16: dp3
    reg_tmp4.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 17: dp3
    reg_tmp4.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 18: dp3
    reg_tmp4.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 19: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 20: mad
    reg_tmp12 = fma_safe(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_21_34() {
    // 21: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 22: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 23: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 24: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 25: dp3
    reg_tmp4.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 26: dp3
    reg_tmp4.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 27: dp3
    reg_tmp4.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 28: dp3
    reg_tmp5.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 29: dp3
    reg_tmp5.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 30: dp3
    reg_tmp5.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 31: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 32: mad
    reg_tmp12 = fma_safe(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    // 33: mad
    reg_tmp11 = fma_safe(reg_tmp1.wwww, reg_tmp5, reg_tmp11);
    return false;
}
bool sub_34_214() {
    // 34: mul
    reg_tmp15.xyz = (mul_safe(uniforms.f[7].xxxx, vs_in_reg0)).xyz;
    // 35: mul
    reg_tmp14.xyz = (mul_safe(uniforms.f[7].yyyy, vs_in_reg1)).xyz;
    // 36: mul
    reg_tmp13.xyz = (mul_safe(uniforms.f[7].zzzz, vs_in_reg2)).xyz;
    // 37: add
    reg_tmp15.xyz = (uniforms.f[6] + reg_tmp15).xyz;
    // 38: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 39: ifu
    if (uniforms.b[1]) {
        sub_40_146();
    } else {
        sub_146_213();
    }
    // 213: nop
    return false;
}
bool sub_40_146() {
    // 40: mov
    reg_tmp0 = uniforms.f[7];
    // 41: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.yzzz));
    // 42: mov
    reg_tmp7 = uniforms.f[93].xxxx;
    // 43: mov
    reg_tmp12 = uniforms.f[93].xxxx;
    // 44: mov
    reg_tmp11 = uniforms.f[93].xxxx;
    // 45: mul
    reg_tmp2 = mul_safe(uniforms.f[93].wwww, vs_in_reg7);
    // 46: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_47_76();
    } else {
        sub_76_135();
    }
    // 135: mov
    vs_out_attr2 = -reg_tmp15;
    // 136: dp4
    reg_tmp0.x = dot(mul_safe(uniforms.f[86], reg_tmp15), vec4(1.0));
    // 137: dp4
    reg_tmp0.y = dot(mul_safe(uniforms.f[87], reg_tmp15), vec4(1.0));
    // 138: dp4
    reg_tmp0.z = dot(mul_safe(uniforms.f[88], reg_tmp15), vec4(1.0));
    // 139: dp4
    reg_tmp0.w = dot(mul_safe(uniforms.f[89], reg_tmp15), vec4(1.0));
    // 140: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 141: mul
    reg_tmp1.y = (mul_safe(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
    // 142: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 143: ifc
    if (all(conditional_code)) {
        sub_144_145();
    }
    // 145: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_47_76() {
    // 47: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 48: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 49: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 50: call
    {
        sub_12_21();
    }
    // 51: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 52: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 53: call
    {
        sub_12_21();
    }
    // 54: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 55: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 56: callc
    if (conditional_code.x) {
        sub_12_21();
    }
    // 57: ifu
    if (uniforms.b[8]) {
        sub_58_62();
    }
    // 62: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 63: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 64: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 65: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 66: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 67: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 68: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 69: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 70: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 71: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 72: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 73: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 74: call
    {
        sub_214_231();
    }
    // 75: nop
    return false;
}
bool sub_58_62() {
    // 58: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 59: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 60: callc
    if (conditional_code.y) {
        sub_12_21();
    }
    // 61: nop
    return false;
}
bool sub_76_135() {
    // 76: ifc
    if (all(conditional_code)) {
        sub_77_109();
    } else {
        sub_109_134();
    }
    // 134: nop
    return false;
}
bool sub_77_109() {
    // 77: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 78: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 79: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 80: call
    {
        sub_21_34();
    }
    // 81: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 82: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 83: call
    {
        sub_21_34();
    }
    // 84: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 85: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 86: callc
    if (conditional_code.x) {
        sub_21_34();
    }
    // 87: ifu
    if (uniforms.b[8]) {
        sub_88_92();
    }
    // 92: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 93: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 94: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 95: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 96: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 97: dp3
    reg_tmp13.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp11)), vec3(1.0));
    // 98: dp3
    reg_tmp13.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp11)), vec3(1.0));
    // 99: dp3
    reg_tmp13.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp11)), vec3(1.0));
    // 100: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 101: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 102: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 103: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 104: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 105: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 106: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 107: call
    {
        sub_231_307();
    }
    // 108: nop
    return false;
}
bool sub_88_92() {
    // 88: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 89: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 90: callc
    if (conditional_code.y) {
        sub_21_34();
    }
    // 91: nop
    return false;
}
bool sub_109_134() {
    // 109: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 110: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 111: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 112: call
    {
        sub_7_12();
    }
    // 113: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 114: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 115: call
    {
        sub_7_12();
    }
    // 116: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 117: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 118: callc
    if (conditional_code.x) {
        sub_7_12();
    }
    // 119: ifu
    if (uniforms.b[8]) {
        sub_120_124();
    }
    // 124: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 125: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 126: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 127: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 128: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 129: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 130: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 131: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 132: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 133: mov
    vs_out_attr1 = uniforms.f[93].xxxx;
    return false;
}
bool sub_120_124() {
    // 120: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 121: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 122: callc
    if (conditional_code.y) {
        sub_7_12();
    }
    // 123: nop
    return false;
}
bool sub_144_145() {
    // 144: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_146_213() {
    // 146: mov
    reg_tmp0 = uniforms.f[7];
    // 147: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.yzzz));
    // 148: ifu
    if (uniforms.b[2]) {
        sub_149_159();
    } else {
        sub_159_164();
    }
    // 164: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_165_177();
    } else {
        sub_177_202();
    }
    // 202: mov
    vs_out_attr2 = -reg_tmp15;
    // 203: dp4
    reg_tmp0.x = dot(mul_safe(uniforms.f[86], reg_tmp15), vec4(1.0));
    // 204: dp4
    reg_tmp0.y = dot(mul_safe(uniforms.f[87], reg_tmp15), vec4(1.0));
    // 205: dp4
    reg_tmp0.z = dot(mul_safe(uniforms.f[88], reg_tmp15), vec4(1.0));
    // 206: dp4
    reg_tmp0.w = dot(mul_safe(uniforms.f[89], reg_tmp15), vec4(1.0));
    // 207: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 208: mul
    reg_tmp1.y = (mul_safe(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
    // 209: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 210: ifc
    if (all(conditional_code)) {
        sub_211_212();
    }
    // 212: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_149_159() {
    // 149: mul
    reg_tmp1.x = (mul_safe(uniforms.f[93].wwww, vs_in_reg7.xxxx)).x;
    // 150: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 151: dp4
    reg_tmp7.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 152: dp4
    reg_tmp7.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 153: dp4
    reg_tmp7.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 154: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 155: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 156: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 157: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 158: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_159_164() {
    // 159: mova
    address_registers.x = (ivec2(uniforms.f[93].xxxx)).x;
    // 160: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[25], reg_tmp15), vec4(1.0));
    // 161: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[26], reg_tmp15), vec4(1.0));
    // 162: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[27], reg_tmp15), vec4(1.0));
    // 163: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_165_177() {
    // 165: dp3
    reg_tmp12.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 166: dp3
    reg_tmp12.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 167: dp3
    reg_tmp12.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 168: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 169: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 170: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 171: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 172: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 173: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 174: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 175: call
    {
        sub_214_231();
    }
    // 176: nop
    return false;
}
bool sub_177_202() {
    // 177: ifc
    if (all(conditional_code)) {
        sub_178_196();
    } else {
        sub_196_201();
    }
    // 201: nop
    return false;
}
bool sub_178_196() {
    // 178: dp3
    reg_tmp12.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 179: dp3
    reg_tmp12.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 180: dp3
    reg_tmp12.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 181: dp3
    reg_tmp11.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 182: dp3
    reg_tmp11.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 183: dp3
    reg_tmp11.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 184: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 185: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 186: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 187: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 188: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 189: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 190: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 191: dp3
    reg_tmp13.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp11)), vec3(1.0));
    // 192: dp3
    reg_tmp13.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp11)), vec3(1.0));
    // 193: dp3
    reg_tmp13.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp11)), vec3(1.0));
    // 194: call
    {
        sub_231_307();
    }
    // 195: nop
    return false;
}
bool sub_196_201() {
    // 196: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 197: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 198: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 199: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 200: mov
    vs_out_attr1 = uniforms.f[93].xxxx;
    return false;
}
bool sub_211_212() {
    // 211: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_214_231() {
    uint jmp_to = 214u;
    while (true) {
        switch (jmp_to) {
        case 214u: {
            // 214: dp3
            reg_tmp6.x = dot(vec3(mul_safe(reg_tmp14, reg_tmp14)), vec3(1.0));
            // 215: dp3
            reg_tmp7.x = dot(vec3(mul_safe(reg_tmp12, reg_tmp12)), vec3(1.0));
            // 216: rsq
            reg_tmp6.x = rsq_safe(reg_tmp6.xxxx.x);
            // 217: rsq
            reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
            // 218: mul
            reg_tmp14.xyz = (mul_safe(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 219: mul
            reg_tmp12.xyz = (mul_safe(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 220: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 221: jmpu
            if (!uniforms.b[15]) {
                { jmp_to = 230u; break; }
            }
            // 222: add
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            // 223: mul
            reg_tmp4 = mul_safe(uniforms.f[94].zzzz, reg_tmp4);
            // 224: cmp
            conditional_code = greaterThanEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp4.xxxx));
            // 225: rsq
            reg_tmp4 = vec4(rsq_safe(reg_tmp4.xxxx.x));
            // 226: mul
            reg_tmp5 = mul_safe(uniforms.f[94].zzzz, reg_tmp14);
            // 227: jmpc
            if (conditional_code.x) {
                { jmp_to = 230u; break; }
            }
            // 228: rcp
            reg_tmp0.z = rcp_safe(reg_tmp4.xxxx.x);
            // 229: mul
            reg_tmp0.xy = (mul_safe(reg_tmp5, reg_tmp4)).xy;
        }
        case 230u: {
            // 230: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_231_307() {
    uint jmp_to = 231u;
    while (true) {
        switch (jmp_to) {
        case 231u: {
            // 231: dp3
            reg_tmp6.x = dot(vec3(mul_safe(reg_tmp14, reg_tmp14)), vec3(1.0));
            // 232: dp3
            reg_tmp7.x = dot(vec3(mul_safe(reg_tmp12, reg_tmp12)), vec3(1.0));
            // 233: rsq
            reg_tmp6.x = rsq_safe(reg_tmp6.xxxx.x);
            // 234: rsq
            reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
            // 235: mul
            reg_tmp14.xyz = (mul_safe(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 236: mul
            reg_tmp12.xyz = (mul_safe(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 237: mul
            reg_tmp13.xyz = (mul_safe(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            // 238: mul
            reg_tmp11.xyz = (mul_safe(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            // 239: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 240: jmpu
            if (!uniforms.b[15]) {
                { jmp_to = 306u; break; }
            }
            // 241: mul
            reg_tmp13.xyz = (mul_safe(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            // 242: mul
            reg_tmp11.xyz = (mul_safe(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            // 243: mul
            reg_tmp5 = mul_safe(reg_tmp14.yzxx, reg_tmp13.zxyy);
            // 244: mad
            reg_tmp5 = fma_safe(-reg_tmp13.yzxx, reg_tmp14.zxyy, reg_tmp5);
            // 245: dp3
            reg_tmp5.w = dot(vec3(mul_safe(reg_tmp5, reg_tmp5)), vec3(1.0));
            // 246: rsq
            reg_tmp5.w = rsq_safe(reg_tmp5.wwww.x);
            // 247: mul
            reg_tmp5 = mul_safe(reg_tmp5, reg_tmp5.wwww);
            // 248: add
            reg_tmp6.w = (reg_tmp14.zzzz + reg_tmp5.yyyy).w;
            // 249: mul
            reg_tmp13 = mul_safe(reg_tmp5.yzxx, reg_tmp14.zxyy);
            // 250: mad
            reg_tmp13 = fma_safe(-reg_tmp14.yzxx, reg_tmp5.zxyy, reg_tmp13);
            // 251: add
            reg_tmp6.w = (reg_tmp13.xxxx + reg_tmp6).w;
            // 252: mov
            reg_tmp13.w = (reg_tmp5.zzzz).w;
            // 253: mov
            reg_tmp5.z = (reg_tmp13.xxxx).z;
            // 254: add
            reg_tmp6.w = (uniforms.f[93].yyyy + reg_tmp6).w;
            // 255: mov
            reg_tmp14.w = (reg_tmp5.xxxx).w;
            // 256: mov
            reg_tmp5.x = (reg_tmp14.zzzz).x;
            // 257: cmp
            conditional_code = lessThan(vec2(uniforms.f[94].yyyy), vec2(reg_tmp6.wwww));
            // 258: mov
            reg_tmp6.x = (uniforms.f[93].yyyy).x;
            // 259: mov
            reg_tmp6.y = (-uniforms.f[93].yyyy).y;
            // 260: jmpc
            if (!conditional_code.x) {
                { jmp_to = 268u; break; }
            }
            // 261: add
            reg_tmp7.xz = (reg_tmp13.wwyy + -reg_tmp14.yyww).xz;
            // 262: add
            reg_tmp7.y = (reg_tmp14.xxxx + -reg_tmp13.zzzz).y;
            // 263: mov
            reg_tmp7.w = (reg_tmp6).w;
            // 264: dp4
            reg_tmp6 = vec4(dot(mul_safe(reg_tmp7, reg_tmp7), vec4(1.0)));
            // 265: rsq
            reg_tmp6 = vec4(rsq_safe(reg_tmp6.xxxx.x));
            // 266: mul
            reg_tmp0 = mul_safe(reg_tmp7, reg_tmp6);
            // 267: jmpu
            if (uniforms.b[0]) {
                { jmp_to = 306u; break; }
            }
        }
        case 268u: {
            // 268: cmp
            conditional_code = greaterThan(vec2(reg_tmp5.zyyy), vec2(reg_tmp5.yxxx));
            // 269: ifc
            if (conditional_code.x) {
                sub_270_290();
            } else {
                sub_290_303();
            }
            // 303: dp4
            reg_tmp6 = vec4(dot(mul_safe(reg_tmp8, reg_tmp8), vec4(1.0)));
            // 304: rsq
            reg_tmp6 = vec4(rsq_safe(reg_tmp6.xxxx.x));
            // 305: mul
            reg_tmp0 = mul_safe(reg_tmp8, reg_tmp6);
        }
        case 306u: {
            // 306: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_270_290() {
    // 270: ifc
    if (conditional_code.y) {
        sub_271_276();
    } else {
        sub_276_289();
    }
    // 289: mov
    reg_tmp8.w = (-reg_tmp8).w;
    return false;
}
bool sub_271_276() {
    // 271: mul
    reg_tmp8 = mul_safe(reg_tmp13.yyzw, reg_tmp6.xxxy);
    // 272: add
    reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
    // 273: add
    reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
    // 274: add
    reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
    // 275: add
    reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
    return false;
}
bool sub_276_289() {
    // 276: cmp
    conditional_code = greaterThan(vec2(reg_tmp5.zzzz), vec2(reg_tmp5.xxxx));
    // 277: mul
    reg_tmp8 = mul_safe(reg_tmp13.yyzw, reg_tmp6.xxxy);
    // 278: add
    reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
    // 279: ifc
    if (conditional_code.x) {
        sub_280_283();
    } else {
        sub_283_288();
    }
    // 288: nop
    return false;
}
bool sub_280_283() {
    // 280: add
    reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
    // 281: add
    reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
    // 282: add
    reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
    return false;
}
bool sub_283_288() {
    // 283: mul
    reg_tmp8 = mul_safe(reg_tmp13.zwwy, reg_tmp6.xxxy);
    // 284: add
    reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
    // 285: add
    reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
    // 286: add
    reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
    // 287: add
    reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
    return false;
}
bool sub_290_303() {
    // 290: ifc
    if (conditional_code.y) {
        sub_291_296();
    } else {
        sub_296_302();
    }
    // 302: nop
    return false;
}
bool sub_291_296() {
    // 291: mul
    reg_tmp8 = mul_safe(reg_tmp13.yywz, reg_tmp6.xxxy);
    // 292: add
    reg_tmp8.y = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).y;
    // 293: add
    reg_tmp9 = reg_tmp5.yyyy + -reg_tmp5.xxxx;
    // 294: add
    reg_tmp8.xzw = (reg_tmp8 + reg_tmp14.wwyx).xzw;
    // 295: add
    reg_tmp8.y = (reg_tmp9 + reg_tmp8).y;
    return false;
}
bool sub_296_302() {
    // 296: mul
    reg_tmp8 = mul_safe(reg_tmp13.zwwy, reg_tmp6.xxxy);
    // 297: add
    reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
    // 298: add
    reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
    // 299: add
    reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
    // 300: add
    reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
    // 301: mov
    reg_tmp8.w = (-reg_tmp8).w;
    return false;
}
bool sub_307_351() {
    // 307: mov
    reg_tmp1.xyz = (uniforms.f[93].xxyx).xyz;
    // 308: dp3
    reg_tmp8.x = dot(vec3(mul_safe(uniforms.f[0], reg_tmp12.xyzz)), vec3(1.0));
    // 309: dp3
    reg_tmp8.y = dot(vec3(mul_safe(uniforms.f[1], reg_tmp12.xyzz)), vec3(1.0));
    // 310: dp3
    reg_tmp8.z = dot(vec3(mul_safe(uniforms.f[2], reg_tmp12.xyzz)), vec3(1.0));
    // 311: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[90], reg_tmp8.xyzz)), vec3(1.0));
    // 312: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[91], reg_tmp8.xyzz)), vec3(1.0));
    // 313: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[92], reg_tmp8.xyzz)), vec3(1.0));
    // 314: mov
    reg_tmp14.w = (uniforms.f[93].xxxx).w;
    // 315: mov
    reg_tmp8 = reg_tmp14;
    // 316: dp4
    reg_tmp14.x = dot(mul_safe(reg_tmp8, reg_tmp8), vec4(1.0));
    // 317: rsq
    reg_tmp14.x = rsq_safe(reg_tmp14.xxxx.x);
    // 318: mul
    reg_tmp14 = mul_safe(reg_tmp8, reg_tmp14.xxxx);
    // 319: mov
    reg_tmp0 = uniforms.f[23];
    // 320: dp3
    reg_tmp8.x = dot(vec3(mul_safe(uniforms.f[0], reg_tmp0.xyzz)), vec3(1.0));
    // 321: dp3
    reg_tmp8.y = dot(vec3(mul_safe(uniforms.f[1], reg_tmp0.xyzz)), vec3(1.0));
    // 322: dp3
    reg_tmp8.z = dot(vec3(mul_safe(uniforms.f[2], reg_tmp0.xyzz)), vec3(1.0));
    // 323: dp3
    reg_tmp6.x = dot(vec3(mul_safe(uniforms.f[90], reg_tmp8.xyzz)), vec3(1.0));
    // 324: dp3
    reg_tmp6.y = dot(vec3(mul_safe(uniforms.f[91], reg_tmp8.xyzz)), vec3(1.0));
    // 325: dp3
    reg_tmp6.z = dot(vec3(mul_safe(uniforms.f[92], reg_tmp8.xyzz)), vec3(1.0));
    // 326: add
    reg_tmp8.xyz = (reg_tmp6.xyzz + reg_tmp1.xyzz).xyz;
    // 327: mov
    reg_tmp8.w = (uniforms.f[93].xxxx).w;
    // 328: dp4
    reg_tmp0.x = dot(mul_safe(reg_tmp8, reg_tmp8), vec4(1.0));
    // 329: rsq
    reg_tmp0.x = rsq_safe(reg_tmp0.xxxx.x);
    // 330: mul
    reg_tmp0 = mul_safe(reg_tmp8, reg_tmp0.xxxx);
    // 331: dp3
    reg_tmp8.x = dot(vec3(mul_safe(reg_tmp14.xyzz, -reg_tmp6)), vec3(1.0));
    // 332: dp3
    reg_tmp8.y = dot(vec3(mul_safe(reg_tmp1.xyzz, -reg_tmp6)), vec3(1.0));
    // 333: max
    reg_tmp8 = max(uniforms.f[93].xxxx, reg_tmp8);
    // 334: mul
    reg_tmp2.y = (mul_safe(reg_tmp8.xxxx, reg_tmp8.yyyy)).y;
    // 335: dp3
    reg_tmp9.z = dot(vec3(mul_safe(reg_tmp14.xyzz, reg_tmp0)), vec3(1.0));
    // 336: max
    reg_tmp9.z = (max(uniforms.f[93].xxxx, reg_tmp9.zzzz)).z;
    // 337: min
    reg_tmp9.z = (min(uniforms.f[93].yyyy, reg_tmp9.zzzz)).z;
    // 338: log
    reg_tmp9.z = log2(reg_tmp9.zzzz.x);
    // 339: mul
    reg_tmp9.z = (mul_safe(uniforms.f[22].zzzz, reg_tmp9.zzzz)).z;
    // 340: exp
    reg_tmp9.z = exp2(reg_tmp9.zzzz.x);
    // 341: mul
    reg_tmp2.z = (mul_safe(uniforms.f[22].wwww, reg_tmp9.zzzz)).z;
    // 342: dp3
    reg_tmp9.x = dot(vec3(mul_safe(reg_tmp14, reg_tmp1)), vec3(1.0));
    // 343: max
    reg_tmp9.x = (max(uniforms.f[93].xxxx, reg_tmp9.xxxx)).x;
    // 344: min
    reg_tmp9.x = (min(uniforms.f[93].yyyy, reg_tmp9.xxxx)).x;
    // 345: add
    reg_tmp9.x = (uniforms.f[93].yyyy + -reg_tmp9.xxxx).x;
    // 346: log
    reg_tmp9.x = log2(reg_tmp9.xxxx.x);
    // 347: mul
    reg_tmp9.x = (mul_safe(uniforms.f[22].xxxx, reg_tmp9.xxxx)).x;
    // 348: exp
    reg_tmp9.x = exp2(reg_tmp9.xxxx.x);
    // 349: mul
    reg_tmp2.w = (mul_safe(uniforms.f[22].yyyy, reg_tmp9.xxxx)).w;
    // 350: mov
    vs_out_attr3 = reg_tmp2;
    return false;
}
bool sub_351_378() {
    // 351: mov
    reg_tmp0.xy = (uniforms.f[10].xxxx).xy;
    // 352: ifu
    if (uniforms.b[9]) {
        sub_353_358();
    } else {
        sub_358_377();
    }
    // 377: nop
    return false;
}
bool sub_353_358() {
    // 353: call
    {
        sub_378_386();
    }
    // 354: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[11].xywz, reg_tmp6), vec4(1.0));
    // 355: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[12].xywz, reg_tmp6), vec4(1.0));
    // 356: mov
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    // 357: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_358_377() {
    // 358: cmp
    conditional_code = equal(vec2(uniforms.f[95].xyyy), vec2(reg_tmp0.xyyy));
    // 359: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 360: ifc
    if (all(not(conditional_code))) {
        sub_361_367();
    } else {
        sub_367_376();
    }
    // 376: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_361_367() {
    // 361: mov
    reg_tmp6 = reg_tmp10;
    // 362: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[11], reg_tmp6), vec4(1.0));
    // 363: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[12], reg_tmp6), vec4(1.0));
    // 364: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[13], reg_tmp6), vec4(1.0));
    // 365: mul
    reg_tmp0.xy = (mul_safe(uniforms.f[19].xyyy, reg_tmp3.zzzz)).xy;
    // 366: add
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_367_376() {
    // 367: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_368_372();
    } else {
        sub_372_375();
    }
    // 375: nop
    return false;
}
bool sub_368_372() {
    // 368: call
    {
        sub_386_393();
    }
    // 369: dp3
    reg_tmp3.x = dot(vec3(mul_safe(uniforms.f[11], reg_tmp6)), vec3(1.0));
    // 370: dp3
    reg_tmp3.y = dot(vec3(mul_safe(uniforms.f[12], reg_tmp6)), vec3(1.0));
    // 371: dp3
    reg_tmp3.z = dot(vec3(mul_safe(uniforms.f[13], reg_tmp6)), vec3(1.0));
    return false;
}
bool sub_372_375() {
    // 372: call
    {
        sub_393_397();
    }
    // 373: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[11], reg_tmp6), vec4(1.0));
    // 374: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[12], reg_tmp6), vec4(1.0));
    return false;
}
bool sub_378_386() {
    // 378: cmp
    conditional_code = equal(vec2(uniforms.f[93].yzzz), vec2(reg_tmp0.xyyy));
    // 379: ifc
    if (all(not(conditional_code))) {
        sub_380_381();
    } else {
        sub_381_385();
    }
    // 385: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_380_381() {
    // 380: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
    return false;
}
bool sub_381_385() {
    // 381: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_382_383();
    } else {
        sub_383_384();
    }
    // 384: nop
    return false;
}
bool sub_382_383() {
    // 382: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
    return false;
}
bool sub_383_384() {
    // 383: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
    return false;
}
bool sub_386_393() {
    // 386: mov
    reg_tmp2 = -reg_tmp15;
    // 387: dp3
    reg_tmp2.w = dot(vec3(mul_safe(reg_tmp2, reg_tmp2)), vec3(1.0));
    // 388: rsq
    reg_tmp2.w = rsq_safe(reg_tmp2.wwww.x);
    // 389: mul
    reg_tmp2 = mul_safe(reg_tmp2, reg_tmp2.wwww);
    // 390: dp3
    reg_tmp1 = vec4(dot(vec3(mul_safe(reg_tmp2, reg_tmp14)), vec3(1.0)));
    // 391: add
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    // 392: mad
    reg_tmp6 = fma_safe(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_393_397() {
    // 393: mov
    reg_tmp1.xy = (uniforms.f[94].zzzz).xy;
    // 394: mov
    reg_tmp1.zw = (uniforms.f[93].xxxx).zw;
    // 395: mad
    reg_tmp6 = fma_safe(reg_tmp14, reg_tmp1, reg_tmp1);
    // 396: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_397_421() {
    // 397: mov
    reg_tmp0.xy = (uniforms.f[10].yyyy).xy;
    // 398: ifu
    if (uniforms.b[10]) {
        sub_399_403();
    } else {
        sub_403_420();
    }
    // 420: nop
    return false;
}
bool sub_399_403() {
    // 399: call
    {
        sub_378_386();
    }
    // 400: dp4
    reg_tmp4.x = dot(mul_safe(uniforms.f[14].xywz, reg_tmp6), vec4(1.0));
    // 401: dp4
    reg_tmp4.y = dot(mul_safe(uniforms.f[15].xywz, reg_tmp6), vec4(1.0));
    // 402: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_403_420() {
    // 403: ifu
    if (uniforms.b[13]) {
        sub_404_418();
    } else {
        sub_418_419();
    }
    // 419: nop
    return false;
}
bool sub_404_418() {
    // 404: cmp
    conditional_code = equal(vec2(uniforms.f[95].xyyy), vec2(reg_tmp0.xyyy));
    // 405: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 406: ifc
    if (all(not(conditional_code))) {
        sub_407_414();
    } else {
        sub_414_417();
    }
    // 417: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_407_414() {
    // 407: mov
    reg_tmp6 = reg_tmp10;
    // 408: dp4
    reg_tmp4.x = dot(mul_safe(uniforms.f[14], reg_tmp6), vec4(1.0));
    // 409: dp4
    reg_tmp4.y = dot(mul_safe(uniforms.f[15], reg_tmp6), vec4(1.0));
    // 410: dp4
    reg_tmp4.z = dot(mul_safe(uniforms.f[16], reg_tmp6), vec4(1.0));
    // 411: rcp
    reg_tmp6.w = rcp_safe(reg_tmp4.zzzz.x);
    // 412: mul
    reg_tmp4.xy = (mul_safe(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    // 413: add
    reg_tmp4.xy = (uniforms.f[19].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_414_417() {
    // 414: call
    {
        sub_393_397();
    }
    // 415: dp4
    reg_tmp4.x = dot(mul_safe(uniforms.f[14], reg_tmp6), vec4(1.0));
    // 416: dp4
    reg_tmp4.y = dot(mul_safe(uniforms.f[15], reg_tmp6), vec4(1.0));
    return false;
}
bool sub_418_419() {
    // 418: mov
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_421_437() {
    // 421: mov
    reg_tmp0.xy = (uniforms.f[10].zzzz).xy;
    // 422: ifu
    if (uniforms.b[11]) {
        sub_423_427();
    } else {
        sub_427_436();
    }
    // 436: nop
    return false;
}
bool sub_423_427() {
    // 423: call
    {
        sub_378_386();
    }
    // 424: dp4
    reg_tmp5.x = dot(mul_safe(uniforms.f[17].xywz, reg_tmp6), vec4(1.0));
    // 425: dp4
    reg_tmp5.y = dot(mul_safe(uniforms.f[18].xywz, reg_tmp6), vec4(1.0));
    // 426: mov
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_427_436() {
    // 427: ifu
    if (uniforms.b[14]) {
        sub_428_434();
    } else {
        sub_434_435();
    }
    // 435: nop
    return false;
}
bool sub_428_434() {
    // 428: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 429: mov
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    // 430: call
    {
        sub_393_397();
    }
    // 431: dp4
    reg_tmp5.x = dot(mul_safe(uniforms.f[17], reg_tmp6), vec4(1.0));
    // 432: dp4
    reg_tmp5.y = dot(mul_safe(uniforms.f[18], reg_tmp6), vec4(1.0));
    // 433: mov
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_434_435() {
    // 434: mov
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
// reference: 441121A89E69F0E6, EC345D93DF769150
// program: EC345D93DF769150, AD7922A63ED54CA7, CB541D02F0C32C04
// reference: DD4459E945D051A1, EC345D93DF769150
// reference: 09A37E95EF3C604A, 76204850D3D31438
// reference: 90F606D43485C10D, 76204850D3D31438
// program: 0000000000000000, 0000000000000000, C32574EA415A8ECF
// reference: 3CD6F255798B711F, BF583C1F84D94483
// reference: A5838A14A232D058, BF583C1F84D94483
// reference: 205C35B2688B9CA9, 2B10AE6FA2719F48
// reference: B9094DF3B3323DEE, 2B10AE6FA2719F48
// program: BF583C1F84D94483, 5D764F9A6220D694, E712D1F015FA0270
// program: BF583C1F84D94483, 5D764F9A6220D694, ED7F62B87BCBA8C3
// program: 76204850D3D31438, AD7922A63ED54CA7, 10ADC50FC532FE6E
// program: BF583C1F84D94483, 5D764F9A6220D694, 81D5ADAAF3D0CA91
// program: 0000000000000000, 0000000000000000, CE59663341BA1DD1
// shader: 8B31, B354DE6BBBEF83CA

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define mul_safe(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define rcp_safe(x) (1.0f / x)
#define rsq_safe(x) inversesqrt(x)
#define fma_safe(x, y, z) (mul_safe(x, y) + z)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_4096();
bool sub_6_11();
bool sub_11_20();
bool sub_20_29();
bool sub_37_197();
bool sub_42_139();
bool sub_48_76();
bool sub_59_63();
bool sub_76_129();
bool sub_77_104();
bool sub_88_92();
bool sub_104_128();
bool sub_115_119();
bool sub_137_138();
bool sub_139_194();
bool sub_142_152();
bool sub_152_157();
bool sub_158_168();
bool sub_168_184();
bool sub_169_179();
bool sub_179_183();
bool sub_192_193();
bool sub_197_214();
bool sub_203_208();
bool sub_205_206();
bool sub_212_213();
bool sub_214_260();
bool sub_218_259();
bool sub_223_225();
bool sub_225_249();
bool sub_228_233();
bool sub_239_248();
bool sub_243_244();
bool sub_244_247();
bool sub_251_258();
bool sub_260_270();
bool sub_267_268();
bool sub_270_279();
bool sub_297_321();
bool sub_299_303();
bool sub_303_320();
bool sub_304_318();
bool sub_307_314();
bool sub_314_317();
bool sub_318_319();
bool sub_321_329();
bool sub_323_324();
bool sub_324_328();
bool sub_325_326();
bool sub_326_327();
bool sub_329_333();

bool exec_shader() {
    sub_0_4096();
    return true;
}

bool sub_0_4096() {
    // 0: call
    {
        sub_37_197();
    }
    // 1: call
    {
        sub_197_214();
    }
    // 2: call
    {
        sub_270_279();
    }
    // 3: call
    {
        sub_297_321();
    }
    // 4: end
    return true;
}
bool sub_6_11() {
    // 6: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 7: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 8: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 9: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 10: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    return false;
}
bool sub_11_20() {
    // 11: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 12: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 13: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 14: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 15: dp3
    reg_tmp4.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 16: dp3
    reg_tmp4.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 17: dp3
    reg_tmp4.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 18: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 19: mad
    reg_tmp12 = fma_safe(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_20_29() {
    // 20: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 21: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 22: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 23: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 24: dp3
    reg_tmp4.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 25: dp3
    reg_tmp4.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 26: dp3
    reg_tmp4.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 27: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 28: mad
    reg_tmp12 = fma_safe(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_37_197() {
    // 37: mul
    reg_tmp15.xyz = (mul_safe(uniforms.f[7].xxxx, vs_in_reg0)).xyz;
    // 38: mul
    reg_tmp14.xyz = (mul_safe(uniforms.f[7].yyyy, vs_in_reg1)).xyz;
    // 39: add
    reg_tmp15.xyz = (uniforms.f[6] + reg_tmp15).xyz;
    // 40: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 41: ifu
    if (uniforms.b[1]) {
        sub_42_139();
    } else {
        sub_139_194();
    }
    // 194: nop
    // 195: mov
    vs_out_attr1 = uniforms.f[93].xxxx;
    // 196: mov
    vs_out_attr2 = uniforms.f[93].xxxx;
    return false;
}
bool sub_42_139() {
    // 42: mov
    reg_tmp0 = uniforms.f[7];
    // 43: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.yzzz));
    // 44: mov
    reg_tmp7 = uniforms.f[93].xxxx;
    // 45: mov
    reg_tmp12 = uniforms.f[93].xxxx;
    // 46: mul
    reg_tmp2 = mul_safe(uniforms.f[93].wwww, vs_in_reg7);
    // 47: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_48_76();
    } else {
        sub_76_129();
    }
    // 129: dp4
    reg_tmp0.x = dot(mul_safe(uniforms.f[86], reg_tmp15), vec4(1.0));
    // 130: dp4
    reg_tmp0.y = dot(mul_safe(uniforms.f[87], reg_tmp15), vec4(1.0));
    // 131: dp4
    reg_tmp0.z = dot(mul_safe(uniforms.f[88], reg_tmp15), vec4(1.0));
    // 132: dp4
    reg_tmp0.w = dot(mul_safe(uniforms.f[89], reg_tmp15), vec4(1.0));
    // 133: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 134: mul
    reg_tmp1.y = (mul_safe(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
    // 135: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 136: ifc
    if (all(conditional_code)) {
        sub_137_138();
    }
    // 138: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_48_76() {
    // 48: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 49: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 50: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 51: call
    {
        sub_11_20();
    }
    // 52: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 53: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 54: call
    {
        sub_11_20();
    }
    // 55: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 56: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 57: callc
    if (conditional_code.x) {
        sub_11_20();
    }
    // 58: ifu
    if (uniforms.b[8]) {
        sub_59_63();
    }
    // 63: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 64: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 65: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 66: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 67: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 68: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 69: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 70: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 71: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 72: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 73: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 74: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 75: nop
    return false;
}
bool sub_59_63() {
    // 59: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 60: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 61: callc
    if (conditional_code.y) {
        sub_11_20();
    }
    // 62: nop
    return false;
}
bool sub_76_129() {
    // 76: ifc
    if (all(conditional_code)) {
        sub_77_104();
    } else {
        sub_104_128();
    }
    // 128: nop
    return false;
}
bool sub_77_104() {
    // 77: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 78: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 79: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 80: call
    {
        sub_20_29();
    }
    // 81: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 82: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 83: call
    {
        sub_20_29();
    }
    // 84: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 85: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 86: callc
    if (conditional_code.x) {
        sub_20_29();
    }
    // 87: ifu
    if (uniforms.b[8]) {
        sub_88_92();
    }
    // 92: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 93: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 94: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 95: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 96: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 97: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 98: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 99: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 100: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 101: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 102: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 103: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_88_92() {
    // 88: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 89: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 90: callc
    if (conditional_code.y) {
        sub_20_29();
    }
    // 91: nop
    return false;
}
bool sub_104_128() {
    // 104: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 105: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 106: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 107: call
    {
        sub_6_11();
    }
    // 108: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 109: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 110: call
    {
        sub_6_11();
    }
    // 111: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 112: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 113: callc
    if (conditional_code.x) {
        sub_6_11();
    }
    // 114: ifu
    if (uniforms.b[8]) {
        sub_115_119();
    }
    // 119: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 120: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 121: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 122: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 123: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 124: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 125: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 126: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 127: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_115_119() {
    // 115: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 116: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 117: callc
    if (conditional_code.y) {
        sub_6_11();
    }
    // 118: nop
    return false;
}
bool sub_137_138() {
    // 137: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_139_194() {
    // 139: mov
    reg_tmp0 = uniforms.f[7];
    // 140: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.yzzz));
    // 141: ifu
    if (uniforms.b[2]) {
        sub_142_152();
    } else {
        sub_152_157();
    }
    // 157: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_158_168();
    } else {
        sub_168_184();
    }
    // 184: dp4
    reg_tmp0.x = dot(mul_safe(uniforms.f[86], reg_tmp15), vec4(1.0));
    // 185: dp4
    reg_tmp0.y = dot(mul_safe(uniforms.f[87], reg_tmp15), vec4(1.0));
    // 186: dp4
    reg_tmp0.z = dot(mul_safe(uniforms.f[88], reg_tmp15), vec4(1.0));
    // 187: dp4
    reg_tmp0.w = dot(mul_safe(uniforms.f[89], reg_tmp15), vec4(1.0));
    // 188: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 189: mul
    reg_tmp1.y = (mul_safe(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
    // 190: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 191: ifc
    if (all(conditional_code)) {
        sub_192_193();
    }
    // 193: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_142_152() {
    // 142: mul
    reg_tmp1.x = (mul_safe(uniforms.f[93].wwww, vs_in_reg7.xxxx)).x;
    // 143: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 144: dp4
    reg_tmp7.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 145: dp4
    reg_tmp7.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 146: dp4
    reg_tmp7.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 147: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 148: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 149: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 150: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 151: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_152_157() {
    // 152: mova
    address_registers.x = (ivec2(uniforms.f[93].xxxx)).x;
    // 153: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[25], reg_tmp15), vec4(1.0));
    // 154: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[26], reg_tmp15), vec4(1.0));
    // 155: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[27], reg_tmp15), vec4(1.0));
    // 156: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_158_168() {
    // 158: dp3
    reg_tmp12.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 159: dp3
    reg_tmp12.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 160: dp3
    reg_tmp12.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 161: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 162: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 163: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 164: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 165: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 166: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 167: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_168_184() {
    // 168: ifc
    if (all(conditional_code)) {
        sub_169_179();
    } else {
        sub_179_183();
    }
    // 183: nop
    return false;
}
bool sub_169_179() {
    // 169: dp3
    reg_tmp12.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 170: dp3
    reg_tmp12.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 171: dp3
    reg_tmp12.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 172: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 173: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 174: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 175: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 176: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 177: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 178: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_179_183() {
    // 179: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 180: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 181: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 182: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_192_193() {
    // 192: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_197_214() {
    // 197: mov
    reg_tmp8.xy = (uniforms.f[93].xxxx).xy;
    // 198: mov
    reg_tmp0.y = (uniforms.f[7].wwww).y;
    // 199: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.xyyy));
    // 200: mov
    reg_tmp9.xyz = (uniforms.f[93].xxxx).xyz;
    // 201: mov
    reg_tmp9.w = (uniforms.f[21].wwww).w;
    // 202: ifc
    if (conditional_code.y) {
        sub_203_208();
    }
    // 208: callu
    if (uniforms.b[12]) {
        sub_214_260();
    }
    // 209: callu
    if (uniforms.b[5]) {
        sub_260_270();
    }
    // 210: cmp
    conditional_code = equal(vec2(uniforms.f[93].xxxx), vec2(reg_tmp8.xyyy));
    // 211: ifc
    if (all(conditional_code)) {
        sub_212_213();
    }
    // 213: max
    vs_out_attr3 = max(uniforms.f[93].xxxx, reg_tmp9);
    return false;
}
bool sub_203_208() {
    // 203: mul
    reg_tmp0 = mul_safe(uniforms.f[7].wwww, vs_in_reg3);
    // 204: ifu
    if (uniforms.b[7]) {
        sub_205_206();
    }
    // 206: mul
    reg_tmp9.xyz = (mul_safe(uniforms.f[20].wwww, reg_tmp0.xyzz)).xyz;
    // 207: mov
    reg_tmp8.x = (uniforms.f[93].yyyy).x;
    return false;
}
bool sub_205_206() {
    // 205: mul
    reg_tmp9.w = (mul_safe(reg_tmp9.wwww, reg_tmp0.wwww)).w;
    return false;
}
bool sub_212_213() {
    // 212: mov
    reg_tmp9 = uniforms.f[21];
    return false;
}
bool sub_214_260() {
    // 214: mov
    reg_tmp1 = uniforms.f[20];
    // 215: mov
    reg_tmp2 = uniforms.f[21];
    // 216: mov
    reg_tmp3 = uniforms.f[93].xxxx;
    // 217: loop
    address_registers.z = int(uniforms.i[0].y);
    for (uint loop217 = 0u; loop217 <= uniforms.i[0].x; address_registers.z += int(uniforms.i[0].z), ++loop217) {
        sub_218_259();
    }
    // 259: mov
    reg_tmp8.x = (uniforms.f[93].yyyy).x;
    return false;
}
bool sub_218_259() {
    // 218: mova
    address_registers.x = (ivec2(reg_tmp3)).x;
    // 219: mov
    reg_tmp4.x = (uniforms.f[81 + address_registers.x].wwww).x;
    // 220: mov
    reg_tmp4.y = (uniforms.f[83 + address_registers.x].wwww).y;
    // 221: cmp
    conditional_code = equal(vec2(uniforms.f[93].xyyy), vec2(reg_tmp4.xyyy));
    // 222: ifc
    if (conditional_code.x) {
        sub_223_225();
    } else {
        sub_225_249();
    }
    // 249: cmp
    conditional_code.x = uniforms.f[93].xxxx.x == reg_tmp6.xyyy.x;
    conditional_code.y = uniforms.f[93].xxxx.y < reg_tmp6.xyyy.y;
    // 250: ifc
    if (conditional_code.y) {
        sub_251_258();
    }
    // 258: add
    reg_tmp3 = -uniforms.f[95].wwww + reg_tmp3;
    return false;
}
bool sub_223_225() {
    // 223: dp3
    reg_tmp6.x = dot(vec3(mul_safe(uniforms.f[81 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 224: mov
    reg_tmp6.y = (uniforms.f[93].yyyy).y;
    return false;
}
bool sub_225_249() {
    // 225: add
    reg_tmp4 = uniforms.f[81 + address_registers.x] + -reg_tmp15;
    // 226: mov
    reg_tmp6.y = (uniforms.f[93].yyyy).y;
    // 227: ifc
    if (conditional_code.y) {
        sub_228_233();
    }
    // 233: mov
    reg_tmp5 = uniforms.f[82 + address_registers.x];
    // 234: cmp
    conditional_code = equal(vec2(uniforms.f[93].yyyy), vec2(reg_tmp5.wwww));
    // 235: dp3
    reg_tmp4.w = dot(vec3(mul_safe(reg_tmp4, reg_tmp4)), vec3(1.0));
    // 236: rsq
    reg_tmp4.w = rsq_safe(reg_tmp4.wwww.x);
    // 237: mul
    reg_tmp4 = mul_safe(reg_tmp4, reg_tmp4.wwww);
    // 238: ifc
    if (conditional_code.x) {
        sub_239_248();
    }
    // 248: dp3
    reg_tmp6.x = dot(vec3(mul_safe(reg_tmp14, reg_tmp4)), vec3(1.0));
    return false;
}
bool sub_228_233() {
    // 228: mov
    reg_tmp5.x = (uniforms.f[93].yyyy).x;
    // 229: dp3
    reg_tmp5.z = dot(vec3(mul_safe(reg_tmp4, reg_tmp4)), vec3(1.0));
    // 230: mul
    reg_tmp5.y = (mul_safe(reg_tmp5.zzzz, reg_tmp5.zzzz)).y;
    // 231: dp3
    reg_tmp6.y = dot(vec3(mul_safe(uniforms.f[83 + address_registers.x], reg_tmp5)), vec3(1.0));
    // 232: rcp
    reg_tmp6.y = rcp_safe(reg_tmp6.yyyy.x);
    return false;
}
bool sub_239_248() {
    // 239: dp3
    reg_tmp5.x = dot(vec3(mul_safe(uniforms.f[82 + address_registers.x], -reg_tmp4)), vec3(1.0));
    // 240: slti
    reg_tmp5.y = (vec4(lessThan(reg_tmp5.xxxx,uniforms.f[84 + address_registers.x].yyyy))).y;
    // 241: cmp
    conditional_code = equal(vec2(uniforms.f[93].yyyy), vec2(reg_tmp5.xyyy));
    // 242: ifc
    if (conditional_code.y) {
        sub_243_244();
    } else {
        sub_244_247();
    }
    // 247: mul
    reg_tmp6.y = (mul_safe(reg_tmp6.yyyy, reg_tmp5.xxxx)).y;
    return false;
}
bool sub_243_244() {
    // 243: mov
    reg_tmp5.x = (uniforms.f[93].xxxx).x;
    return false;
}
bool sub_244_247() {
    // 244: log
    reg_tmp5.y = log2(reg_tmp5.xxxx.x);
    // 245: mul
    reg_tmp5.y = (mul_safe(uniforms.f[84 + address_registers.x].xxxx, reg_tmp5.yyyy)).y;
    // 246: exp
    reg_tmp5.x = exp2(reg_tmp5.yyyy.x);
    return false;
}
bool sub_251_258() {
    // 251: max
    reg_tmp6.x = (max(uniforms.f[93].xxxx, reg_tmp6.xxxx)).x;
    // 252: mad
    reg_tmp9.xyz = (fma_safe(reg_tmp1.xyzz, uniforms.f[79 + address_registers.x].xyzz, reg_tmp9.xyzz)).xyz;
    // 253: mul
    reg_tmp4 = mul_safe(uniforms.f[80 + address_registers.x], reg_tmp2);
    // 254: mul
    reg_tmp5.xyz = (mul_safe(reg_tmp6.xxxx, reg_tmp4.xyzz)).xyz;
    // 255: mul
    reg_tmp5.xyz = (mul_safe(reg_tmp6.yyyy, reg_tmp5.xyzz)).xyz;
    // 256: add
    reg_tmp9.xyz = (reg_tmp9.xyzz + reg_tmp5.xyzz).xyz;
    // 257: add
    reg_tmp9.w = (reg_tmp9.wwww + reg_tmp4.wwww).w;
    return false;
}
bool sub_260_270() {
    // 260: dp3
    reg_tmp1 = vec4(dot(vec3(mul_safe(uniforms.f[24], reg_tmp14)), vec3(1.0)));
    // 261: mov
    reg_tmp2 = uniforms.f[24].wwww;
    // 262: mad
    reg_tmp1 = fma_safe(reg_tmp1, reg_tmp2, reg_tmp2);
    // 263: mov
    reg_tmp3 = uniforms.f[22];
    // 264: add
    reg_tmp2 = uniforms.f[23] + -reg_tmp3;
    // 265: mad
    reg_tmp4 = fma_safe(reg_tmp2, reg_tmp1, reg_tmp3);
    // 266: ifu
    if (uniforms.b[6]) {
        sub_267_268();
    }
    // 268: mad
    reg_tmp9.xyz = (fma_safe(reg_tmp4, uniforms.f[21], reg_tmp9)).xyz;
    // 269: mov
    reg_tmp8.x = (uniforms.f[93].yyyy).x;
    return false;
}
bool sub_267_268() {
    // 267: mul
    reg_tmp4 = mul_safe(reg_tmp4, reg_tmp9.wwww);
    return false;
}
bool sub_270_279() {
    // 270: dp3
    reg_tmp5.x = dot(vec3(mul_safe(uniforms.f[90], reg_tmp12.xyzz)), vec3(1.0));
    // 271: dp3
    reg_tmp5.y = dot(vec3(mul_safe(uniforms.f[91], reg_tmp12.xyzz)), vec3(1.0));
    // 272: dp3
    reg_tmp5.z = dot(vec3(mul_safe(uniforms.f[92], reg_tmp12.xyzz)), vec3(1.0));
    // 273: dp4
    reg_tmp4.x = dot(mul_safe(reg_tmp5.xyzz, reg_tmp5.xyzz), vec4(1.0));
    // 274: rsq
    reg_tmp4.x = rsq_safe(reg_tmp4.xxxx.x);
    // 275: mul
    reg_tmp4.xyz = (mul_safe(reg_tmp5.xyzz, reg_tmp4.xxxx)).xyz;
    // 276: mul
    reg_tmp4 = mul_safe(uniforms.f[94].zzzz, reg_tmp4);
    // 277: add
    reg_tmp12 = uniforms.f[94].zzzz + reg_tmp4;
    // 278: mov
    vs_out_attr4 = reg_tmp12;
    return false;
}
bool sub_297_321() {
    // 297: mov
    reg_tmp0.xy = (uniforms.f[10].yyyy).xy;
    // 298: ifu
    if (uniforms.b[10]) {
        sub_299_303();
    } else {
        sub_303_320();
    }
    // 320: nop
    return false;
}
bool sub_299_303() {
    // 299: call
    {
        sub_321_329();
    }
    // 300: dp4
    reg_tmp4.x = dot(mul_safe(uniforms.f[14].xywz, reg_tmp6), vec4(1.0));
    // 301: dp4
    reg_tmp4.y = dot(mul_safe(uniforms.f[15].xywz, reg_tmp6), vec4(1.0));
    // 302: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_303_320() {
    // 303: ifu
    if (uniforms.b[13]) {
        sub_304_318();
    } else {
        sub_318_319();
    }
    // 319: nop
    return false;
}
bool sub_304_318() {
    // 304: cmp
    conditional_code = equal(vec2(uniforms.f[95].xyyy), vec2(reg_tmp0.xyyy));
    // 305: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 306: ifc
    if (all(not(conditional_code))) {
        sub_307_314();
    } else {
        sub_314_317();
    }
    // 317: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_307_314() {
    // 307: mov
    reg_tmp6 = reg_tmp10;
    // 308: dp4
    reg_tmp4.x = dot(mul_safe(uniforms.f[14], reg_tmp6), vec4(1.0));
    // 309: dp4
    reg_tmp4.y = dot(mul_safe(uniforms.f[15], reg_tmp6), vec4(1.0));
    // 310: dp4
    reg_tmp4.z = dot(mul_safe(uniforms.f[16], reg_tmp6), vec4(1.0));
    // 311: rcp
    reg_tmp6.w = rcp_safe(reg_tmp4.zzzz.x);
    // 312: mul
    reg_tmp4.xy = (mul_safe(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    // 313: add
    reg_tmp4.xy = (uniforms.f[19].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_314_317() {
    // 314: call
    {
        sub_329_333();
    }
    // 315: dp4
    reg_tmp4.x = dot(mul_safe(uniforms.f[14], reg_tmp6), vec4(1.0));
    // 316: dp4
    reg_tmp4.y = dot(mul_safe(uniforms.f[15], reg_tmp6), vec4(1.0));
    return false;
}
bool sub_318_319() {
    // 318: mov
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_321_329() {
    // 321: cmp
    conditional_code = equal(vec2(uniforms.f[93].yzzz), vec2(reg_tmp0.xyyy));
    // 322: ifc
    if (all(not(conditional_code))) {
        sub_323_324();
    } else {
        sub_324_328();
    }
    // 328: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_323_324() {
    // 323: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
    return false;
}
bool sub_324_328() {
    // 324: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_325_326();
    } else {
        sub_326_327();
    }
    // 327: nop
    return false;
}
bool sub_325_326() {
    // 325: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
    return false;
}
bool sub_326_327() {
    // 326: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
    return false;
}
bool sub_329_333() {
    // 329: mov
    reg_tmp1.xy = (uniforms.f[94].zzzz).xy;
    // 330: mov
    reg_tmp1.zw = (uniforms.f[93].xxxx).zw;
    // 331: mad
    reg_tmp6 = fma_safe(reg_tmp14, reg_tmp1, reg_tmp1);
    // 332: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
// reference: 205C35B246CAC41D, B354DE6BBBEF83CA
// program: B354DE6BBBEF83CA, 3B3AE026C742C7D5, 24B822D609CE0531
// reference: B9094DF39D73655A, B354DE6BBBEF83CA
// program: EC345D93DF769150, AD7922A63ED54CA7, 6320E09DD2EF8330
// reference: 309685BC3D547990, 4EFF2C77DB8F9E73
// reference: A9C3FDFDE6EDD8D7, 4EFF2C77DB8F9E73
// shader: 8B31, 81D584DEE3289DE7

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;
 out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define mul_safe(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define rcp_safe(x) (1.0f / x)
#define rsq_safe(x) inversesqrt(x)
#define fma_safe(x, y, z) (mul_safe(x, y) + z)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_4096();
bool sub_7_12();
bool sub_12_21();
bool sub_21_34();
bool sub_34_214();
bool sub_40_146();
bool sub_47_76();
bool sub_58_62();
bool sub_76_135();
bool sub_77_109();
bool sub_88_92();
bool sub_109_134();
bool sub_120_124();
bool sub_144_145();
bool sub_146_213();
bool sub_149_159();
bool sub_159_164();
bool sub_165_177();
bool sub_177_202();
bool sub_178_196();
bool sub_196_201();
bool sub_211_212();
bool sub_214_231();
bool sub_231_307();
bool sub_270_290();
bool sub_271_276();
bool sub_276_289();
bool sub_280_283();
bool sub_283_288();
bool sub_290_303();
bool sub_291_296();
bool sub_296_302();
bool sub_307_321();
bool sub_313_318();
bool sub_315_316();
bool sub_321_339();
bool sub_326_337();
bool sub_339_349();
bool sub_346_347();
bool sub_349_376();
bool sub_351_356();
bool sub_356_375();
bool sub_359_365();
bool sub_365_374();
bool sub_366_370();
bool sub_370_373();
bool sub_376_384();
bool sub_378_379();
bool sub_379_383();
bool sub_380_381();
bool sub_381_382();
bool sub_384_391();
bool sub_391_395();
bool sub_395_419();
bool sub_397_401();
bool sub_401_418();
bool sub_402_416();
bool sub_405_412();
bool sub_412_415();
bool sub_416_417();
bool sub_419_435();
bool sub_421_425();
bool sub_425_434();
bool sub_426_432();
bool sub_432_433();

bool exec_shader() {
    sub_0_4096();
    return true;
}

bool sub_0_4096() {
    // 0: call
    {
        sub_34_214();
    }
    // 1: call
    {
        sub_307_321();
    }
    // 2: call
    {
        sub_349_376();
    }
    // 3: call
    {
        sub_395_419();
    }
    // 4: call
    {
        sub_419_435();
    }
    // 5: end
    return true;
}
bool sub_7_12() {
    // 7: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 8: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 9: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 10: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 11: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    return false;
}
bool sub_12_21() {
    // 12: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 13: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 14: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 15: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 16: dp3
    reg_tmp4.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 17: dp3
    reg_tmp4.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 18: dp3
    reg_tmp4.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 19: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 20: mad
    reg_tmp12 = fma_safe(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_21_34() {
    // 21: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 22: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 23: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 24: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 25: dp3
    reg_tmp4.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 26: dp3
    reg_tmp4.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 27: dp3
    reg_tmp4.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 28: dp3
    reg_tmp5.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 29: dp3
    reg_tmp5.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 30: dp3
    reg_tmp5.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 31: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 32: mad
    reg_tmp12 = fma_safe(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    // 33: mad
    reg_tmp11 = fma_safe(reg_tmp1.wwww, reg_tmp5, reg_tmp11);
    return false;
}
bool sub_34_214() {
    // 34: mul
    reg_tmp15.xyz = (mul_safe(uniforms.f[7].xxxx, vs_in_reg0)).xyz;
    // 35: mul
    reg_tmp14.xyz = (mul_safe(uniforms.f[7].yyyy, vs_in_reg1)).xyz;
    // 36: mul
    reg_tmp13.xyz = (mul_safe(uniforms.f[7].zzzz, vs_in_reg2)).xyz;
    // 37: add
    reg_tmp15.xyz = (uniforms.f[6] + reg_tmp15).xyz;
    // 38: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 39: ifu
    if (uniforms.b[1]) {
        sub_40_146();
    } else {
        sub_146_213();
    }
    // 213: nop
    return false;
}
bool sub_40_146() {
    // 40: mov
    reg_tmp0 = uniforms.f[7];
    // 41: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.yzzz));
    // 42: mov
    reg_tmp7 = uniforms.f[93].xxxx;
    // 43: mov
    reg_tmp12 = uniforms.f[93].xxxx;
    // 44: mov
    reg_tmp11 = uniforms.f[93].xxxx;
    // 45: mul
    reg_tmp2 = mul_safe(uniforms.f[93].wwww, vs_in_reg7);
    // 46: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_47_76();
    } else {
        sub_76_135();
    }
    // 135: mov
    vs_out_attr2 = -reg_tmp15;
    // 136: dp4
    reg_tmp0.x = dot(mul_safe(uniforms.f[86], reg_tmp15), vec4(1.0));
    // 137: dp4
    reg_tmp0.y = dot(mul_safe(uniforms.f[87], reg_tmp15), vec4(1.0));
    // 138: dp4
    reg_tmp0.z = dot(mul_safe(uniforms.f[88], reg_tmp15), vec4(1.0));
    // 139: dp4
    reg_tmp0.w = dot(mul_safe(uniforms.f[89], reg_tmp15), vec4(1.0));
    // 140: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 141: mul
    reg_tmp1.y = (mul_safe(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
    // 142: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 143: ifc
    if (all(conditional_code)) {
        sub_144_145();
    }
    // 145: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_47_76() {
    // 47: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 48: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 49: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 50: call
    {
        sub_12_21();
    }
    // 51: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 52: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 53: call
    {
        sub_12_21();
    }
    // 54: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 55: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 56: callc
    if (conditional_code.x) {
        sub_12_21();
    }
    // 57: ifu
    if (uniforms.b[8]) {
        sub_58_62();
    }
    // 62: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 63: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 64: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 65: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 66: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 67: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 68: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 69: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 70: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 71: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 72: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 73: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 74: call
    {
        sub_214_231();
    }
    // 75: nop
    return false;
}
bool sub_58_62() {
    // 58: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 59: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 60: callc
    if (conditional_code.y) {
        sub_12_21();
    }
    // 61: nop
    return false;
}
bool sub_76_135() {
    // 76: ifc
    if (all(conditional_code)) {
        sub_77_109();
    } else {
        sub_109_134();
    }
    // 134: nop
    return false;
}
bool sub_77_109() {
    // 77: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 78: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 79: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 80: call
    {
        sub_21_34();
    }
    // 81: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 82: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 83: call
    {
        sub_21_34();
    }
    // 84: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 85: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 86: callc
    if (conditional_code.x) {
        sub_21_34();
    }
    // 87: ifu
    if (uniforms.b[8]) {
        sub_88_92();
    }
    // 92: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 93: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 94: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 95: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 96: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 97: dp3
    reg_tmp13.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp11)), vec3(1.0));
    // 98: dp3
    reg_tmp13.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp11)), vec3(1.0));
    // 99: dp3
    reg_tmp13.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp11)), vec3(1.0));
    // 100: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 101: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 102: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 103: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 104: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 105: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 106: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 107: call
    {
        sub_231_307();
    }
    // 108: nop
    return false;
}
bool sub_88_92() {
    // 88: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 89: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 90: callc
    if (conditional_code.y) {
        sub_21_34();
    }
    // 91: nop
    return false;
}
bool sub_109_134() {
    // 109: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 110: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 111: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 112: call
    {
        sub_7_12();
    }
    // 113: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 114: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 115: call
    {
        sub_7_12();
    }
    // 116: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 117: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 118: callc
    if (conditional_code.x) {
        sub_7_12();
    }
    // 119: ifu
    if (uniforms.b[8]) {
        sub_120_124();
    }
    // 124: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 125: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 126: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 127: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 128: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 129: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 130: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 131: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 132: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 133: mov
    vs_out_attr1 = uniforms.f[93].xxxx;
    return false;
}
bool sub_120_124() {
    // 120: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 121: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 122: callc
    if (conditional_code.y) {
        sub_7_12();
    }
    // 123: nop
    return false;
}
bool sub_144_145() {
    // 144: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_146_213() {
    // 146: mov
    reg_tmp0 = uniforms.f[7];
    // 147: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.yzzz));
    // 148: ifu
    if (uniforms.b[2]) {
        sub_149_159();
    } else {
        sub_159_164();
    }
    // 164: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_165_177();
    } else {
        sub_177_202();
    }
    // 202: mov
    vs_out_attr2 = -reg_tmp15;
    // 203: dp4
    reg_tmp0.x = dot(mul_safe(uniforms.f[86], reg_tmp15), vec4(1.0));
    // 204: dp4
    reg_tmp0.y = dot(mul_safe(uniforms.f[87], reg_tmp15), vec4(1.0));
    // 205: dp4
    reg_tmp0.z = dot(mul_safe(uniforms.f[88], reg_tmp15), vec4(1.0));
    // 206: dp4
    reg_tmp0.w = dot(mul_safe(uniforms.f[89], reg_tmp15), vec4(1.0));
    // 207: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 208: mul
    reg_tmp1.y = (mul_safe(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
    // 209: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 210: ifc
    if (all(conditional_code)) {
        sub_211_212();
    }
    // 212: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_149_159() {
    // 149: mul
    reg_tmp1.x = (mul_safe(uniforms.f[93].wwww, vs_in_reg7.xxxx)).x;
    // 150: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 151: dp4
    reg_tmp7.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 152: dp4
    reg_tmp7.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 153: dp4
    reg_tmp7.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 154: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 155: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 156: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 157: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 158: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_159_164() {
    // 159: mova
    address_registers.x = (ivec2(uniforms.f[93].xxxx)).x;
    // 160: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[25], reg_tmp15), vec4(1.0));
    // 161: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[26], reg_tmp15), vec4(1.0));
    // 162: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[27], reg_tmp15), vec4(1.0));
    // 163: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_165_177() {
    // 165: dp3
    reg_tmp12.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 166: dp3
    reg_tmp12.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 167: dp3
    reg_tmp12.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 168: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 169: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 170: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 171: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 172: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 173: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 174: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 175: call
    {
        sub_214_231();
    }
    // 176: nop
    return false;
}
bool sub_177_202() {
    // 177: ifc
    if (all(conditional_code)) {
        sub_178_196();
    } else {
        sub_196_201();
    }
    // 201: nop
    return false;
}
bool sub_178_196() {
    // 178: dp3
    reg_tmp12.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 179: dp3
    reg_tmp12.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 180: dp3
    reg_tmp12.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 181: dp3
    reg_tmp11.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 182: dp3
    reg_tmp11.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 183: dp3
    reg_tmp11.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 184: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 185: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 186: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 187: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 188: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 189: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 190: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 191: dp3
    reg_tmp13.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp11)), vec3(1.0));
    // 192: dp3
    reg_tmp13.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp11)), vec3(1.0));
    // 193: dp3
    reg_tmp13.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp11)), vec3(1.0));
    // 194: call
    {
        sub_231_307();
    }
    // 195: nop
    return false;
}
bool sub_196_201() {
    // 196: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 197: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 198: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 199: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 200: mov
    vs_out_attr1 = uniforms.f[93].xxxx;
    return false;
}
bool sub_211_212() {
    // 211: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_214_231() {
    uint jmp_to = 214u;
    while (true) {
        switch (jmp_to) {
        case 214u: {
            // 214: dp3
            reg_tmp6.x = dot(vec3(mul_safe(reg_tmp14, reg_tmp14)), vec3(1.0));
            // 215: dp3
            reg_tmp7.x = dot(vec3(mul_safe(reg_tmp12, reg_tmp12)), vec3(1.0));
            // 216: rsq
            reg_tmp6.x = rsq_safe(reg_tmp6.xxxx.x);
            // 217: rsq
            reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
            // 218: mul
            reg_tmp14.xyz = (mul_safe(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 219: mul
            reg_tmp12.xyz = (mul_safe(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 220: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 221: jmpu
            if (!uniforms.b[15]) {
                { jmp_to = 230u; break; }
            }
            // 222: add
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            // 223: mul
            reg_tmp4 = mul_safe(uniforms.f[94].zzzz, reg_tmp4);
            // 224: cmp
            conditional_code = greaterThanEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp4.xxxx));
            // 225: rsq
            reg_tmp4 = vec4(rsq_safe(reg_tmp4.xxxx.x));
            // 226: mul
            reg_tmp5 = mul_safe(uniforms.f[94].zzzz, reg_tmp14);
            // 227: jmpc
            if (conditional_code.x) {
                { jmp_to = 230u; break; }
            }
            // 228: rcp
            reg_tmp0.z = rcp_safe(reg_tmp4.xxxx.x);
            // 229: mul
            reg_tmp0.xy = (mul_safe(reg_tmp5, reg_tmp4)).xy;
        }
        case 230u: {
            // 230: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_231_307() {
    uint jmp_to = 231u;
    while (true) {
        switch (jmp_to) {
        case 231u: {
            // 231: dp3
            reg_tmp6.x = dot(vec3(mul_safe(reg_tmp14, reg_tmp14)), vec3(1.0));
            // 232: dp3
            reg_tmp7.x = dot(vec3(mul_safe(reg_tmp12, reg_tmp12)), vec3(1.0));
            // 233: rsq
            reg_tmp6.x = rsq_safe(reg_tmp6.xxxx.x);
            // 234: rsq
            reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
            // 235: mul
            reg_tmp14.xyz = (mul_safe(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 236: mul
            reg_tmp12.xyz = (mul_safe(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 237: mul
            reg_tmp13.xyz = (mul_safe(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            // 238: mul
            reg_tmp11.xyz = (mul_safe(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            // 239: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 240: jmpu
            if (!uniforms.b[15]) {
                { jmp_to = 306u; break; }
            }
            // 241: mul
            reg_tmp13.xyz = (mul_safe(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            // 242: mul
            reg_tmp11.xyz = (mul_safe(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            // 243: mul
            reg_tmp5 = mul_safe(reg_tmp14.yzxx, reg_tmp13.zxyy);
            // 244: mad
            reg_tmp5 = fma_safe(-reg_tmp13.yzxx, reg_tmp14.zxyy, reg_tmp5);
            // 245: dp3
            reg_tmp5.w = dot(vec3(mul_safe(reg_tmp5, reg_tmp5)), vec3(1.0));
            // 246: rsq
            reg_tmp5.w = rsq_safe(reg_tmp5.wwww.x);
            // 247: mul
            reg_tmp5 = mul_safe(reg_tmp5, reg_tmp5.wwww);
            // 248: add
            reg_tmp6.w = (reg_tmp14.zzzz + reg_tmp5.yyyy).w;
            // 249: mul
            reg_tmp13 = mul_safe(reg_tmp5.yzxx, reg_tmp14.zxyy);
            // 250: mad
            reg_tmp13 = fma_safe(-reg_tmp14.yzxx, reg_tmp5.zxyy, reg_tmp13);
            // 251: add
            reg_tmp6.w = (reg_tmp13.xxxx + reg_tmp6).w;
            // 252: mov
            reg_tmp13.w = (reg_tmp5.zzzz).w;
            // 253: mov
            reg_tmp5.z = (reg_tmp13.xxxx).z;
            // 254: add
            reg_tmp6.w = (uniforms.f[93].yyyy + reg_tmp6).w;
            // 255: mov
            reg_tmp14.w = (reg_tmp5.xxxx).w;
            // 256: mov
            reg_tmp5.x = (reg_tmp14.zzzz).x;
            // 257: cmp
            conditional_code = lessThan(vec2(uniforms.f[94].yyyy), vec2(reg_tmp6.wwww));
            // 258: mov
            reg_tmp6.x = (uniforms.f[93].yyyy).x;
            // 259: mov
            reg_tmp6.y = (-uniforms.f[93].yyyy).y;
            // 260: jmpc
            if (!conditional_code.x) {
                { jmp_to = 268u; break; }
            }
            // 261: add
            reg_tmp7.xz = (reg_tmp13.wwyy + -reg_tmp14.yyww).xz;
            // 262: add
            reg_tmp7.y = (reg_tmp14.xxxx + -reg_tmp13.zzzz).y;
            // 263: mov
            reg_tmp7.w = (reg_tmp6).w;
            // 264: dp4
            reg_tmp6 = vec4(dot(mul_safe(reg_tmp7, reg_tmp7), vec4(1.0)));
            // 265: rsq
            reg_tmp6 = vec4(rsq_safe(reg_tmp6.xxxx.x));
            // 266: mul
            reg_tmp0 = mul_safe(reg_tmp7, reg_tmp6);
            // 267: jmpu
            if (uniforms.b[0]) {
                { jmp_to = 306u; break; }
            }
        }
        case 268u: {
            // 268: cmp
            conditional_code = greaterThan(vec2(reg_tmp5.zyyy), vec2(reg_tmp5.yxxx));
            // 269: ifc
            if (conditional_code.x) {
                sub_270_290();
            } else {
                sub_290_303();
            }
            // 303: dp4
            reg_tmp6 = vec4(dot(mul_safe(reg_tmp8, reg_tmp8), vec4(1.0)));
            // 304: rsq
            reg_tmp6 = vec4(rsq_safe(reg_tmp6.xxxx.x));
            // 305: mul
            reg_tmp0 = mul_safe(reg_tmp8, reg_tmp6);
        }
        case 306u: {
            // 306: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_270_290() {
    // 270: ifc
    if (conditional_code.y) {
        sub_271_276();
    } else {
        sub_276_289();
    }
    // 289: mov
    reg_tmp8.w = (-reg_tmp8).w;
    return false;
}
bool sub_271_276() {
    // 271: mul
    reg_tmp8 = mul_safe(reg_tmp13.yyzw, reg_tmp6.xxxy);
    // 272: add
    reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
    // 273: add
    reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
    // 274: add
    reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
    // 275: add
    reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
    return false;
}
bool sub_276_289() {
    // 276: cmp
    conditional_code = greaterThan(vec2(reg_tmp5.zzzz), vec2(reg_tmp5.xxxx));
    // 277: mul
    reg_tmp8 = mul_safe(reg_tmp13.yyzw, reg_tmp6.xxxy);
    // 278: add
    reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
    // 279: ifc
    if (conditional_code.x) {
        sub_280_283();
    } else {
        sub_283_288();
    }
    // 288: nop
    return false;
}
bool sub_280_283() {
    // 280: add
    reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
    // 281: add
    reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
    // 282: add
    reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
    return false;
}
bool sub_283_288() {
    // 283: mul
    reg_tmp8 = mul_safe(reg_tmp13.zwwy, reg_tmp6.xxxy);
    // 284: add
    reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
    // 285: add
    reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
    // 286: add
    reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
    // 287: add
    reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
    return false;
}
bool sub_290_303() {
    // 290: ifc
    if (conditional_code.y) {
        sub_291_296();
    } else {
        sub_296_302();
    }
    // 302: nop
    return false;
}
bool sub_291_296() {
    // 291: mul
    reg_tmp8 = mul_safe(reg_tmp13.yywz, reg_tmp6.xxxy);
    // 292: add
    reg_tmp8.y = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).y;
    // 293: add
    reg_tmp9 = reg_tmp5.yyyy + -reg_tmp5.xxxx;
    // 294: add
    reg_tmp8.xzw = (reg_tmp8 + reg_tmp14.wwyx).xzw;
    // 295: add
    reg_tmp8.y = (reg_tmp9 + reg_tmp8).y;
    return false;
}
bool sub_296_302() {
    // 296: mul
    reg_tmp8 = mul_safe(reg_tmp13.zwwy, reg_tmp6.xxxy);
    // 297: add
    reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
    // 298: add
    reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
    // 299: add
    reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
    // 300: add
    reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
    // 301: mov
    reg_tmp8.w = (-reg_tmp8).w;
    return false;
}
bool sub_307_321() {
    // 307: mov
    reg_tmp8.xy = (uniforms.f[93].xxxx).xy;
    // 308: mov
    reg_tmp0.y = (uniforms.f[7].wwww).y;
    // 309: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.xyyy));
    // 310: mov
    reg_tmp9.xyz = (uniforms.f[93].xxxx).xyz;
    // 311: mov
    reg_tmp9.w = (uniforms.f[21].wwww).w;
    // 312: ifc
    if (conditional_code.y) {
        sub_313_318();
    }
    // 318: callu
    if (uniforms.b[12]) {
        sub_321_339();
    }
    // 319: callu
    if (uniforms.b[5]) {
        sub_339_349();
    }
    // 320: max
    vs_out_attr3 = max(uniforms.f[93].xxxx, reg_tmp9);
    return false;
}
bool sub_313_318() {
    // 313: mul
    reg_tmp0 = mul_safe(uniforms.f[7].wwww, vs_in_reg3);
    // 314: ifu
    if (uniforms.b[7]) {
        sub_315_316();
    }
    // 316: mul
    reg_tmp9.xyz = (mul_safe(uniforms.f[20].wwww, reg_tmp0.xyzz)).xyz;
    // 317: mov
    reg_tmp8.x = (uniforms.f[93].yyyy).x;
    return false;
}
bool sub_315_316() {
    // 315: mul
    reg_tmp9.w = (mul_safe(reg_tmp9.wwww, reg_tmp0.wwww)).w;
    return false;
}
bool sub_321_339() {
    // 321: mov
    reg_tmp1 = uniforms.f[20];
    // 322: mov
    reg_tmp2 = uniforms.f[21];
    // 323: mov
    reg_tmp3 = uniforms.f[93].xxxx;
    // 324: mov
    reg_tmp0 = uniforms.f[93].xxxx;
    // 325: loop
    address_registers.z = int(uniforms.i[0].y);
    for (uint loop325 = 0u; loop325 <= uniforms.i[0].x; address_registers.z += int(uniforms.i[0].z), ++loop325) {
        sub_326_337();
    }
    // 337: mul
    reg_tmp9.xyz = (mul_safe(reg_tmp9.xyzz, reg_tmp0.xyzz)).xyz;
    // 338: mov
    reg_tmp8.x = (uniforms.f[93].yyyy).x;
    return false;
}
bool sub_326_337() {
    // 326: mova
    address_registers.x = (ivec2(reg_tmp3)).x;
    // 327: mov
    reg_tmp4.x = (uniforms.f[81 + address_registers.x].wwww).x;
    // 328: mov
    reg_tmp4.y = (uniforms.f[83 + address_registers.x].wwww).y;
    // 329: dp3
    reg_tmp6.x = dot(vec3(mul_safe(uniforms.f[81 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 330: max
    reg_tmp6.x = (max(uniforms.f[93].xxxx, reg_tmp6.xxxx)).x;
    // 331: mad
    reg_tmp0.xyz = (fma_safe(reg_tmp1.xyzz, uniforms.f[79 + address_registers.x].xyzz, reg_tmp0.xyzz)).xyz;
    // 332: mul
    reg_tmp4 = mul_safe(uniforms.f[80 + address_registers.x], reg_tmp2);
    // 333: mul
    reg_tmp5.xyz = (mul_safe(reg_tmp6.xxxx, reg_tmp4.xyzz)).xyz;
    // 334: add
    reg_tmp0.xyz = (reg_tmp0.xyzz + reg_tmp5.xyzz).xyz;
    // 335: add
    reg_tmp0.w = (reg_tmp0.wwww + reg_tmp4.wwww).w;
    // 336: add
    reg_tmp3 = -uniforms.f[95].wwww + reg_tmp3;
    return false;
}
bool sub_339_349() {
    // 339: dp3
    reg_tmp1 = vec4(dot(vec3(mul_safe(uniforms.f[24], reg_tmp14)), vec3(1.0)));
    // 340: mov
    reg_tmp2 = uniforms.f[24].wwww;
    // 341: mad
    reg_tmp1 = fma_safe(reg_tmp1, reg_tmp2, reg_tmp2);
    // 342: mov
    reg_tmp3 = uniforms.f[22];
    // 343: add
    reg_tmp2 = uniforms.f[23] + -reg_tmp3;
    // 344: mad
    reg_tmp4 = fma_safe(reg_tmp2, reg_tmp1, reg_tmp3);
    // 345: ifu
    if (uniforms.b[6]) {
        sub_346_347();
    }
    // 347: mad
    reg_tmp9.xyz = (fma_safe(reg_tmp4, uniforms.f[21], reg_tmp9)).xyz;
    // 348: mov
    reg_tmp8.x = (uniforms.f[93].yyyy).x;
    return false;
}
bool sub_346_347() {
    // 346: mul
    reg_tmp4 = mul_safe(reg_tmp4, reg_tmp9.wwww);
    return false;
}
bool sub_349_376() {
    // 349: mov
    reg_tmp0.xy = (uniforms.f[10].xxxx).xy;
    // 350: ifu
    if (uniforms.b[9]) {
        sub_351_356();
    } else {
        sub_356_375();
    }
    // 375: nop
    return false;
}
bool sub_351_356() {
    // 351: call
    {
        sub_376_384();
    }
    // 352: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[11].xywz, reg_tmp6), vec4(1.0));
    // 353: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[12].xywz, reg_tmp6), vec4(1.0));
    // 354: mov
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    // 355: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_356_375() {
    // 356: cmp
    conditional_code = equal(vec2(uniforms.f[95].xyyy), vec2(reg_tmp0.xyyy));
    // 357: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 358: ifc
    if (all(not(conditional_code))) {
        sub_359_365();
    } else {
        sub_365_374();
    }
    // 374: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_359_365() {
    // 359: mov
    reg_tmp6 = reg_tmp10;
    // 360: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[11], reg_tmp6), vec4(1.0));
    // 361: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[12], reg_tmp6), vec4(1.0));
    // 362: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[13], reg_tmp6), vec4(1.0));
    // 363: mul
    reg_tmp0.xy = (mul_safe(uniforms.f[19].xyyy, reg_tmp3.zzzz)).xy;
    // 364: add
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_365_374() {
    // 365: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_366_370();
    } else {
        sub_370_373();
    }
    // 373: nop
    return false;
}
bool sub_366_370() {
    // 366: call
    {
        sub_384_391();
    }
    // 367: dp3
    reg_tmp3.x = dot(vec3(mul_safe(uniforms.f[11], reg_tmp6)), vec3(1.0));
    // 368: dp3
    reg_tmp3.y = dot(vec3(mul_safe(uniforms.f[12], reg_tmp6)), vec3(1.0));
    // 369: dp3
    reg_tmp3.z = dot(vec3(mul_safe(uniforms.f[13], reg_tmp6)), vec3(1.0));
    return false;
}
bool sub_370_373() {
    // 370: call
    {
        sub_391_395();
    }
    // 371: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[11], reg_tmp6), vec4(1.0));
    // 372: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[12], reg_tmp6), vec4(1.0));
    return false;
}
bool sub_376_384() {
    // 376: cmp
    conditional_code = equal(vec2(uniforms.f[93].yzzz), vec2(reg_tmp0.xyyy));
    // 377: ifc
    if (all(not(conditional_code))) {
        sub_378_379();
    } else {
        sub_379_383();
    }
    // 383: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_378_379() {
    // 378: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
    return false;
}
bool sub_379_383() {
    // 379: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_380_381();
    } else {
        sub_381_382();
    }
    // 382: nop
    return false;
}
bool sub_380_381() {
    // 380: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
    return false;
}
bool sub_381_382() {
    // 381: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
    return false;
}
bool sub_384_391() {
    // 384: mov
    reg_tmp2 = -reg_tmp15;
    // 385: dp3
    reg_tmp2.w = dot(vec3(mul_safe(reg_tmp2, reg_tmp2)), vec3(1.0));
    // 386: rsq
    reg_tmp2.w = rsq_safe(reg_tmp2.wwww.x);
    // 387: mul
    reg_tmp2 = mul_safe(reg_tmp2, reg_tmp2.wwww);
    // 388: dp3
    reg_tmp1 = vec4(dot(vec3(mul_safe(reg_tmp2, reg_tmp14)), vec3(1.0)));
    // 389: add
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    // 390: mad
    reg_tmp6 = fma_safe(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_391_395() {
    // 391: mov
    reg_tmp1.xy = (uniforms.f[94].zzzz).xy;
    // 392: mov
    reg_tmp1.zw = (uniforms.f[93].xxxx).zw;
    // 393: mad
    reg_tmp6 = fma_safe(reg_tmp14, reg_tmp1, reg_tmp1);
    // 394: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_395_419() {
    // 395: mov
    reg_tmp0.xy = (uniforms.f[10].yyyy).xy;
    // 396: ifu
    if (uniforms.b[10]) {
        sub_397_401();
    } else {
        sub_401_418();
    }
    // 418: nop
    return false;
}
bool sub_397_401() {
    // 397: call
    {
        sub_376_384();
    }
    // 398: dp4
    reg_tmp4.x = dot(mul_safe(uniforms.f[14].xywz, reg_tmp6), vec4(1.0));
    // 399: dp4
    reg_tmp4.y = dot(mul_safe(uniforms.f[15].xywz, reg_tmp6), vec4(1.0));
    // 400: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_401_418() {
    // 401: ifu
    if (uniforms.b[13]) {
        sub_402_416();
    } else {
        sub_416_417();
    }
    // 417: nop
    return false;
}
bool sub_402_416() {
    // 402: cmp
    conditional_code = equal(vec2(uniforms.f[95].xyyy), vec2(reg_tmp0.xyyy));
    // 403: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 404: ifc
    if (all(not(conditional_code))) {
        sub_405_412();
    } else {
        sub_412_415();
    }
    // 415: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_405_412() {
    // 405: mov
    reg_tmp6 = reg_tmp10;
    // 406: dp4
    reg_tmp4.x = dot(mul_safe(uniforms.f[14], reg_tmp6), vec4(1.0));
    // 407: dp4
    reg_tmp4.y = dot(mul_safe(uniforms.f[15], reg_tmp6), vec4(1.0));
    // 408: dp4
    reg_tmp4.z = dot(mul_safe(uniforms.f[16], reg_tmp6), vec4(1.0));
    // 409: rcp
    reg_tmp6.w = rcp_safe(reg_tmp4.zzzz.x);
    // 410: mul
    reg_tmp4.xy = (mul_safe(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    // 411: add
    reg_tmp4.xy = (uniforms.f[19].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_412_415() {
    // 412: call
    {
        sub_391_395();
    }
    // 413: dp4
    reg_tmp4.x = dot(mul_safe(uniforms.f[14], reg_tmp6), vec4(1.0));
    // 414: dp4
    reg_tmp4.y = dot(mul_safe(uniforms.f[15], reg_tmp6), vec4(1.0));
    return false;
}
bool sub_416_417() {
    // 416: mov
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_419_435() {
    // 419: mov
    reg_tmp0.xy = (uniforms.f[10].zzzz).xy;
    // 420: ifu
    if (uniforms.b[11]) {
        sub_421_425();
    } else {
        sub_425_434();
    }
    // 434: nop
    return false;
}
bool sub_421_425() {
    // 421: call
    {
        sub_376_384();
    }
    // 422: dp4
    reg_tmp5.x = dot(mul_safe(uniforms.f[17].xywz, reg_tmp6), vec4(1.0));
    // 423: dp4
    reg_tmp5.y = dot(mul_safe(uniforms.f[18].xywz, reg_tmp6), vec4(1.0));
    // 424: mov
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_425_434() {
    // 425: ifu
    if (uniforms.b[14]) {
        sub_426_432();
    } else {
        sub_432_433();
    }
    // 433: nop
    return false;
}
bool sub_426_432() {
    // 426: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 427: mov
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    // 428: call
    {
        sub_391_395();
    }
    // 429: dp4
    reg_tmp5.x = dot(mul_safe(uniforms.f[17], reg_tmp6), vec4(1.0));
    // 430: dp4
    reg_tmp5.y = dot(mul_safe(uniforms.f[18], reg_tmp6), vec4(1.0));
    // 431: mov
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_432_433() {
    // 432: mov
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
// reference: 8EBCC5D276F53FF7, 81D584DEE3289DE7
// program: 81D584DEE3289DE7, AD7922A63ED54CA7, CF04D0E47608310B
// program: 81D584DEE3289DE7, AD7922A63ED54CA7, 84E276AEB008DB5C
// reference: 5C008552187B08F0, 4EFF2C77DB8F9E73
// program: 4EFF2C77DB8F9E73, 3B3AE026C742C7D5, EC68C55D9E1FD734
// reference: B8CC640E4EF7D477, 76204850D3D31438
// reference: 21991C4F954E7530, 76204850D3D31438
// reference: 8DB9E8CED840C522, BF583C1F84D94483
// reference: 14EC908F03F96465, BF583C1F84D94483
// reference: C555FD13C3C2A9B7, 4EFF2C77DB8F9E73
// reference: 557937A3C4F25897, B354DE6BBBEF83CA
// reference: CC2C4FE21F4BF9D0, B354DE6BBBEF83CA
// reference: BC80DF2F73DF8887, B354DE6BBBEF83CA
// reference: DE920D083FB78BE5, BF583C1F84D94483
// program: BF583C1F84D94483, 5D764F9A6220D694, E6A65EBC7D1F5A7C
// reference: 47C77549E40E2AA2, BF583C1F84D94483
// program: BF583C1F84D94483, 5D764F9A6220D694, 2454357F17D6B3CC
// program: 0000000000000000, 0000000000000000, F93C56DFAE996873
// reference: 13EDC4B03D547990, 4EFF2C77DB8F9E73
// reference: 8AB8BCF1E6EDD8D7, 4EFF2C77DB8F9E73
// reference: 1549243A8E11C3C1, BF583C1F84D94483
// reference: 8C1C5C7B55A86286, BF583C1F84D94483
// reference: D836ED82187B08F0, 4EFF2C77DB8F9E73
// reference: 416395C3C3C2A9B7, 4EFF2C77DB8F9E73
// program: B354DE6BBBEF83CA, 3B3AE026C742C7D5, 2BB9C8FEDE51C537
// program: B354DE6BBBEF83CA, 3B3AE026C742C7D5, 73E202FB36B8AAFC
// shader: 8B31, 94BC5B2C4075B858

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;
 out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define mul_safe(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define rcp_safe(x) (1.0f / x)
#define rsq_safe(x) inversesqrt(x)
#define fma_safe(x, y, z) (mul_safe(x, y) + z)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_391_4096();
bool sub_398_403();
bool sub_403_464();
bool sub_425_429();
bool sub_462_463();

bool exec_shader() {
    sub_391_4096();
    return true;
}

bool sub_391_4096() {
    // 391: call
    {
        sub_403_464();
    }
    // 392: mov
    vs_out_attr3 = uniforms.f[93].xxxx;
    // 393: mov
    vs_out_attr4 = uniforms.f[93].xxxx;
    // 394: mov
    vs_out_attr5 = uniforms.f[93].xxxx;
    // 395: mov
    vs_out_attr6 = uniforms.f[93].xxxx;
    // 396: end
    return true;
}
bool sub_398_403() {
    // 398: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 399: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 400: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 401: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 402: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    return false;
}
bool sub_403_464() {
    // 403: mul
    reg_tmp15.xyz = (mul_safe(uniforms.f[7].xxxx, vs_in_reg0)).xyz;
    // 404: mul
    reg_tmp14.xyz = (mul_safe(uniforms.f[7].yyyy, vs_in_reg1)).xyz;
    // 405: mul
    reg_tmp13.xyz = (mul_safe(uniforms.f[7].zzzz, vs_in_reg2)).xyz;
    // 406: add
    reg_tmp15.xyz = (uniforms.f[6] + reg_tmp15).xyz;
    // 407: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 408: mov
    reg_tmp0 = uniforms.f[7];
    // 409: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.yzzz));
    // 410: mov
    reg_tmp7 = uniforms.f[93].xxxx;
    // 411: mov
    reg_tmp12 = uniforms.f[93].xxxx;
    // 412: mov
    reg_tmp11 = uniforms.f[93].xxxx;
    // 413: mul
    reg_tmp2 = mul_safe(uniforms.f[93].wwww, vs_in_reg7);
    // 414: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 415: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 416: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 417: call
    {
        sub_398_403();
    }
    // 418: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 419: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 420: call
    {
        sub_398_403();
    }
    // 421: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 422: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 423: callc
    if (conditional_code.x) {
        sub_398_403();
    }
    // 424: ifu
    if (uniforms.b[8]) {
        sub_425_429();
    }
    // 429: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 430: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 431: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 432: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 433: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 434: add
    reg_tmp6.y = (-uniforms.f[85].wwww + reg_tmp10.yyyy).y;
    // 435: mov
    reg_tmp9.xyz = (uniforms.f[85].xyzz).xyz;
    // 436: dp4
    reg_tmp7.x = dot(mul_safe(reg_tmp9.xyzz, reg_tmp9.xyzz), vec4(1.0));
    // 437: rsq
    reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
    // 438: mul
    reg_tmp7.xyz = (mul_safe(reg_tmp9.xyzz, reg_tmp7.xxxx)).xyz;
    // 439: rcp
    reg_tmp8.y = rcp_safe(-reg_tmp7.yyyy.x);
    // 440: mul
    reg_tmp8.y = (mul_safe(reg_tmp6.yyyy, reg_tmp8.yyyy)).y;
    // 441: mul
    reg_tmp7.xyz = (mul_safe(reg_tmp7.xyzz, reg_tmp8.yyyy)).xyz;
    // 442: add
    reg_tmp10.xyz = (reg_tmp10.xyzz + reg_tmp7.xyzz).xyz;
    // 443: add
    reg_tmp10.y = (uniforms.f[94].zzzz + reg_tmp10.yyyy).y;
    // 444: mov
    reg_tmp7 = reg_tmp10;
    // 445: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[22], reg_tmp7), vec4(1.0));
    // 446: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[23], reg_tmp7), vec4(1.0));
    // 447: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[24], reg_tmp7), vec4(1.0));
    // 448: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 449: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 450: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 451: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 452: mov
    vs_out_attr1 = uniforms.f[93].xxxx;
    // 453: mov
    vs_out_attr2 = -reg_tmp15;
    // 454: dp4
    reg_tmp0.x = dot(mul_safe(uniforms.f[86], reg_tmp15), vec4(1.0));
    // 455: dp4
    reg_tmp0.y = dot(mul_safe(uniforms.f[87], reg_tmp15), vec4(1.0));
    // 456: dp4
    reg_tmp0.z = dot(mul_safe(uniforms.f[88], reg_tmp15), vec4(1.0));
    // 457: dp4
    reg_tmp0.w = dot(mul_safe(uniforms.f[89], reg_tmp15), vec4(1.0));
    // 458: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 459: mul
    reg_tmp1.y = (mul_safe(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
    // 460: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 461: ifc
    if (all(conditional_code)) {
        sub_462_463();
    }
    // 463: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_425_429() {
    // 425: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 426: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 427: callc
    if (conditional_code.y) {
        sub_398_403();
    }
    // 428: nop
    return false;
}
bool sub_462_463() {
    // 462: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
// reference: 2DFD06A28C7DF547, 94BC5B2C4075B858
// program: 94BC5B2C4075B858, AD7922A63ED54CA7, 24B822D609CE0531
// shader: 8B31, BEF53C1FB1E1CFF4

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;
 out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define mul_safe(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define rcp_safe(x) (1.0f / x)
#define rsq_safe(x) inversesqrt(x)
#define fma_safe(x, y, z) (mul_safe(x, y) + z)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_156_205();
bool sub_181_187();
bool sub_188_195();
bool sub_196_204();
bool sub_205_232();
bool sub_207_212();
bool sub_212_231();
bool sub_215_221();
bool sub_221_230();
bool sub_222_226();
bool sub_226_229();
bool sub_232_240();
bool sub_234_235();
bool sub_235_239();
bool sub_236_237();
bool sub_237_238();
bool sub_240_247();
bool sub_247_254();
bool sub_254_278();
bool sub_256_260();
bool sub_260_277();
bool sub_261_275();
bool sub_264_271();
bool sub_271_274();
bool sub_275_276();
bool sub_278_294();
bool sub_280_284();
bool sub_284_293();
bool sub_285_291();
bool sub_291_292();
bool sub_294_4096();
bool sub_296_298();
bool sub_298_299();
bool sub_304_325();
bool sub_325_339();
bool sub_339_391();
bool sub_363_367();
bool sub_389_390();

bool exec_shader() {
    sub_294_4096();
    return true;
}

bool sub_156_205() {
    // 156: mov
    reg_tmp1.xyz = (uniforms.f[93].xxyx).xyz;
    // 157: dp3
    reg_tmp8.x = dot(vec3(mul_safe(uniforms.f[0], reg_tmp12.xyzz)), vec3(1.0));
    // 158: dp3
    reg_tmp8.y = dot(vec3(mul_safe(uniforms.f[1], reg_tmp12.xyzz)), vec3(1.0));
    // 159: dp3
    reg_tmp8.z = dot(vec3(mul_safe(uniforms.f[2], reg_tmp12.xyzz)), vec3(1.0));
    // 160: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[90], reg_tmp8.xyzz)), vec3(1.0));
    // 161: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[91], reg_tmp8.xyzz)), vec3(1.0));
    // 162: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[92], reg_tmp8.xyzz)), vec3(1.0));
    // 163: mov
    reg_tmp14.w = (uniforms.f[93].xxxx).w;
    // 164: mov
    reg_tmp8 = reg_tmp14;
    // 165: dp4
    reg_tmp14.x = dot(mul_safe(reg_tmp8, reg_tmp8), vec4(1.0));
    // 166: rsq
    reg_tmp14.x = rsq_safe(reg_tmp14.xxxx.x);
    // 167: mul
    reg_tmp14 = mul_safe(reg_tmp8, reg_tmp14.xxxx);
    // 168: mov
    reg_tmp0 = uniforms.f[23];
    // 169: dp3
    reg_tmp8.x = dot(vec3(mul_safe(uniforms.f[0], reg_tmp0.xyzz)), vec3(1.0));
    // 170: dp3
    reg_tmp8.y = dot(vec3(mul_safe(uniforms.f[1], reg_tmp0.xyzz)), vec3(1.0));
    // 171: dp3
    reg_tmp8.z = dot(vec3(mul_safe(uniforms.f[2], reg_tmp0.xyzz)), vec3(1.0));
    // 172: dp3
    reg_tmp6.x = dot(vec3(mul_safe(uniforms.f[90], reg_tmp8.xyzz)), vec3(1.0));
    // 173: dp3
    reg_tmp6.y = dot(vec3(mul_safe(uniforms.f[91], reg_tmp8.xyzz)), vec3(1.0));
    // 174: dp3
    reg_tmp6.z = dot(vec3(mul_safe(uniforms.f[92], reg_tmp8.xyzz)), vec3(1.0));
    // 175: add
    reg_tmp8.xyz = (reg_tmp6.xyzz + reg_tmp1.xyzz).xyz;
    // 176: mov
    reg_tmp8.w = (uniforms.f[93].xxxx).w;
    // 177: dp4
    reg_tmp0.x = dot(mul_safe(reg_tmp8, reg_tmp8), vec4(1.0));
    // 178: rsq
    reg_tmp0.x = rsq_safe(reg_tmp0.xxxx.x);
    // 179: mul
    reg_tmp0 = mul_safe(reg_tmp8, reg_tmp0.xxxx);
    // 180: ifu
    if (uniforms.b[5]) {
        sub_181_187();
    }
    // 187: ifu
    if (uniforms.b[3]) {
        sub_188_195();
    }
    // 195: ifu
    if (uniforms.b[4]) {
        sub_196_204();
    }
    // 204: mov
    vs_out_attr3 = reg_tmp2;
    return false;
}
bool sub_181_187() {
    // 181: dp3
    reg_tmp8.x = dot(vec3(mul_safe(reg_tmp14.xyzz, -reg_tmp6)), vec3(1.0));
    // 182: dp3
    reg_tmp8.y = dot(vec3(mul_safe(reg_tmp1.xyzz, -reg_tmp6)), vec3(1.0));
    // 183: max
    reg_tmp8 = max(uniforms.f[93].xxxx, reg_tmp8);
    // 184: mul
    reg_tmp8.y = (mul_safe(uniforms.f[94].zzzz, reg_tmp8.yyyy)).y;
    // 185: add
    reg_tmp8.y = (uniforms.f[94].zzzz + reg_tmp8.yyyy).y;
    // 186: mul
    reg_tmp2.y = (mul_safe(reg_tmp8.xxxx, reg_tmp8.yyyy)).y;
    return false;
}
bool sub_188_195() {
    // 188: dp3
    reg_tmp9.z = dot(vec3(mul_safe(reg_tmp14.xyzz, reg_tmp0)), vec3(1.0));
    // 189: max
    reg_tmp9.z = (max(uniforms.f[93].xxxx, reg_tmp9.zzzz)).z;
    // 190: min
    reg_tmp9.z = (min(uniforms.f[93].yyyy, reg_tmp9.zzzz)).z;
    // 191: log
    reg_tmp9.z = log2(reg_tmp9.zzzz.x);
    // 192: mul
    reg_tmp9.z = (mul_safe(uniforms.f[22].zzzz, reg_tmp9.zzzz)).z;
    // 193: exp
    reg_tmp9.z = exp2(reg_tmp9.zzzz.x);
    // 194: mul
    reg_tmp2.z = (mul_safe(uniforms.f[22].wwww, reg_tmp9.zzzz)).z;
    return false;
}
bool sub_196_204() {
    // 196: dp3
    reg_tmp9.x = dot(vec3(mul_safe(reg_tmp14, reg_tmp1)), vec3(1.0));
    // 197: max
    reg_tmp9.x = (max(uniforms.f[93].xxxx, reg_tmp9.xxxx)).x;
    // 198: min
    reg_tmp9.x = (min(uniforms.f[93].yyyy, reg_tmp9.xxxx)).x;
    // 199: add
    reg_tmp9.x = (uniforms.f[93].yyyy + -reg_tmp9.xxxx).x;
    // 200: log
    reg_tmp9.x = log2(reg_tmp9.xxxx.x);
    // 201: mul
    reg_tmp9.x = (mul_safe(uniforms.f[22].xxxx, reg_tmp9.xxxx)).x;
    // 202: exp
    reg_tmp9.x = exp2(reg_tmp9.xxxx.x);
    // 203: mul
    reg_tmp2.w = (mul_safe(uniforms.f[22].yyyy, reg_tmp9.xxxx)).w;
    return false;
}
bool sub_205_232() {
    // 205: mov
    reg_tmp0.xy = (uniforms.f[10].xxxx).xy;
    // 206: ifu
    if (uniforms.b[9]) {
        sub_207_212();
    } else {
        sub_212_231();
    }
    // 231: nop
    return false;
}
bool sub_207_212() {
    // 207: call
    {
        sub_232_240();
    }
    // 208: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[11].xywz, reg_tmp6), vec4(1.0));
    // 209: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[12].xywz, reg_tmp6), vec4(1.0));
    // 210: mov
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    // 211: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_212_231() {
    // 212: cmp
    conditional_code = equal(vec2(uniforms.f[95].xyyy), vec2(reg_tmp0.xyyy));
    // 213: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 214: ifc
    if (all(not(conditional_code))) {
        sub_215_221();
    } else {
        sub_221_230();
    }
    // 230: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_215_221() {
    // 215: mov
    reg_tmp6 = reg_tmp10;
    // 216: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[11], reg_tmp6), vec4(1.0));
    // 217: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[12], reg_tmp6), vec4(1.0));
    // 218: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[13], reg_tmp6), vec4(1.0));
    // 219: mul
    reg_tmp0.xy = (mul_safe(uniforms.f[19].xyyy, reg_tmp3.zzzz)).xy;
    // 220: add
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_221_230() {
    // 221: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_222_226();
    } else {
        sub_226_229();
    }
    // 229: nop
    return false;
}
bool sub_222_226() {
    // 222: call
    {
        sub_240_247();
    }
    // 223: dp3
    reg_tmp3.x = dot(vec3(mul_safe(uniforms.f[11], reg_tmp6)), vec3(1.0));
    // 224: dp3
    reg_tmp3.y = dot(vec3(mul_safe(uniforms.f[12], reg_tmp6)), vec3(1.0));
    // 225: dp3
    reg_tmp3.z = dot(vec3(mul_safe(uniforms.f[13], reg_tmp6)), vec3(1.0));
    return false;
}
bool sub_226_229() {
    // 226: call
    {
        sub_247_254();
    }
    // 227: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[11], reg_tmp6), vec4(1.0));
    // 228: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[12], reg_tmp6), vec4(1.0));
    return false;
}
bool sub_232_240() {
    // 232: cmp
    conditional_code = equal(vec2(uniforms.f[93].yzzz), vec2(reg_tmp0.xyyy));
    // 233: ifc
    if (all(not(conditional_code))) {
        sub_234_235();
    } else {
        sub_235_239();
    }
    // 239: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_234_235() {
    // 234: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
    return false;
}
bool sub_235_239() {
    // 235: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_236_237();
    } else {
        sub_237_238();
    }
    // 238: nop
    return false;
}
bool sub_236_237() {
    // 236: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
    return false;
}
bool sub_237_238() {
    // 237: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
    return false;
}
bool sub_240_247() {
    // 240: mov
    reg_tmp2 = -reg_tmp15;
    // 241: dp3
    reg_tmp2.w = dot(vec3(mul_safe(reg_tmp2, reg_tmp2)), vec3(1.0));
    // 242: rsq
    reg_tmp2.w = rsq_safe(reg_tmp2.wwww.x);
    // 243: mul
    reg_tmp2 = mul_safe(reg_tmp2, reg_tmp2.wwww);
    // 244: dp3
    reg_tmp1 = vec4(dot(vec3(mul_safe(reg_tmp2, reg_tmp14)), vec3(1.0)));
    // 245: add
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    // 246: mad
    reg_tmp6 = fma_safe(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_247_254() {
    // 247: mov
    reg_tmp1.xy = (uniforms.f[94].zzzz).xy;
    // 248: mov
    reg_tmp1.zw = (uniforms.f[93].xxxx).zw;
    // 249: dp3
    reg_tmp6.x = dot(vec3(mul_safe(reg_tmp14, reg_tmp14)), vec3(1.0));
    // 250: rsq
    reg_tmp6.x = rsq_safe(reg_tmp6.xxxx.x);
    // 251: mul
    reg_tmp14.xyz = (mul_safe(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
    // 252: mad
    reg_tmp6 = fma_safe(reg_tmp14, reg_tmp1, reg_tmp1);
    // 253: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_254_278() {
    // 254: mov
    reg_tmp0.xy = (uniforms.f[10].yyyy).xy;
    // 255: ifu
    if (uniforms.b[10]) {
        sub_256_260();
    } else {
        sub_260_277();
    }
    // 277: nop
    return false;
}
bool sub_256_260() {
    // 256: call
    {
        sub_232_240();
    }
    // 257: dp4
    reg_tmp4.x = dot(mul_safe(uniforms.f[14].xywz, reg_tmp6), vec4(1.0));
    // 258: dp4
    reg_tmp4.y = dot(mul_safe(uniforms.f[15].xywz, reg_tmp6), vec4(1.0));
    // 259: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_260_277() {
    // 260: ifu
    if (uniforms.b[13]) {
        sub_261_275();
    } else {
        sub_275_276();
    }
    // 276: nop
    return false;
}
bool sub_261_275() {
    // 261: cmp
    conditional_code = equal(vec2(uniforms.f[95].xyyy), vec2(reg_tmp0.xyyy));
    // 262: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 263: ifc
    if (all(not(conditional_code))) {
        sub_264_271();
    } else {
        sub_271_274();
    }
    // 274: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_264_271() {
    // 264: mov
    reg_tmp6 = reg_tmp10;
    // 265: dp4
    reg_tmp4.x = dot(mul_safe(uniforms.f[14], reg_tmp6), vec4(1.0));
    // 266: dp4
    reg_tmp4.y = dot(mul_safe(uniforms.f[15], reg_tmp6), vec4(1.0));
    // 267: dp4
    reg_tmp4.z = dot(mul_safe(uniforms.f[16], reg_tmp6), vec4(1.0));
    // 268: rcp
    reg_tmp6.w = rcp_safe(reg_tmp4.zzzz.x);
    // 269: mul
    reg_tmp4.xy = (mul_safe(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    // 270: add
    reg_tmp4.xy = (uniforms.f[19].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_271_274() {
    // 271: call
    {
        sub_247_254();
    }
    // 272: dp4
    reg_tmp4.x = dot(mul_safe(uniforms.f[14], reg_tmp6), vec4(1.0));
    // 273: dp4
    reg_tmp4.y = dot(mul_safe(uniforms.f[15], reg_tmp6), vec4(1.0));
    return false;
}
bool sub_275_276() {
    // 275: mov
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_278_294() {
    // 278: mov
    reg_tmp0.xy = (uniforms.f[10].zzzz).xy;
    // 279: ifu
    if (uniforms.b[11]) {
        sub_280_284();
    } else {
        sub_284_293();
    }
    // 293: nop
    return false;
}
bool sub_280_284() {
    // 280: call
    {
        sub_232_240();
    }
    // 281: dp4
    reg_tmp5.x = dot(mul_safe(uniforms.f[17].xywz, reg_tmp6), vec4(1.0));
    // 282: dp4
    reg_tmp5.y = dot(mul_safe(uniforms.f[18].xywz, reg_tmp6), vec4(1.0));
    // 283: mov
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_284_293() {
    // 284: ifu
    if (uniforms.b[14]) {
        sub_285_291();
    } else {
        sub_291_292();
    }
    // 292: nop
    return false;
}
bool sub_285_291() {
    // 285: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 286: mov
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    // 287: call
    {
        sub_247_254();
    }
    // 288: dp4
    reg_tmp5.x = dot(mul_safe(uniforms.f[17], reg_tmp6), vec4(1.0));
    // 289: dp4
    reg_tmp5.y = dot(mul_safe(uniforms.f[18], reg_tmp6), vec4(1.0));
    // 290: mov
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_291_292() {
    // 291: mov
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
bool sub_294_4096() {
    // 294: call
    {
        sub_339_391();
    }
    // 295: ifu
    if (uniforms.b[6]) {
        sub_296_298();
    } else {
        sub_298_299();
    }
    // 299: call
    {
        sub_205_232();
    }
    // 300: call
    {
        sub_254_278();
    }
    // 301: call
    {
        sub_278_294();
    }
    // 302: end
    return true;
}
bool sub_296_298() {
    // 296: call
    {
        sub_156_205();
    }
    // 297: nop
    return false;
}
bool sub_298_299() {
    // 298: mov
    vs_out_attr3 = uniforms.f[93].yyyy;
    return false;
}
bool sub_304_325() {
    // 304: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 305: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 306: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 307: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 308: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 309: dp3
    reg_tmp3.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 310: dp3
    reg_tmp3.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 311: dp3
    reg_tmp3.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 312: mad
    reg_tmp12 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp12);
    // 313: dp3
    reg_tmp3.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 314: dp3
    reg_tmp3.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 315: dp3
    reg_tmp3.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 316: mad
    reg_tmp11 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp11);
    // 317: dp3
    reg_tmp3.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp5)), vec3(1.0));
    // 318: dp3
    reg_tmp3.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp5)), vec3(1.0));
    // 319: dp3
    reg_tmp3.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp5)), vec3(1.0));
    // 320: mad
    reg_tmp9 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp9);
    // 321: dp3
    reg_tmp3.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp6)), vec3(1.0));
    // 322: dp3
    reg_tmp3.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp6)), vec3(1.0));
    // 323: dp3
    reg_tmp3.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp6)), vec3(1.0));
    // 324: mad
    reg_tmp8 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp8);
    return false;
}
bool sub_325_339() {
    // 325: mul
    reg_tmp0.xyz = (mul_safe(reg_tmp9.yzxx, reg_tmp8.zxyy)).xyz;
    // 326: mad
    reg_tmp0.xyz = (fma_safe(-reg_tmp8.yzxx, reg_tmp9.zxyy, reg_tmp0)).xyz;
    // 327: mov
    reg_tmp1 = uniforms.f[23];
    // 328: dp4
    reg_tmp2.x = dot(mul_safe(reg_tmp1.xyzz, reg_tmp1.xyzz), vec4(1.0));
    // 329: rsq
    reg_tmp2.x = rsq_safe(reg_tmp2.xxxx.x);
    // 330: mul
    reg_tmp2.xyz = (mul_safe(reg_tmp1.xyzz, reg_tmp2.xxxx)).xyz;
    // 331: dp3
    reg_tmp1.x = dot(vec3(mul_safe(reg_tmp2, reg_tmp8.xyzz)), vec3(1.0));
    // 332: dp3
    reg_tmp1.y = dot(vec3(mul_safe(reg_tmp2, reg_tmp0.xyzz)), vec3(1.0));
    // 333: dp3
    reg_tmp1.z = dot(vec3(mul_safe(reg_tmp2, reg_tmp9.xyzz)), vec3(1.0));
    // 334: dp4
    reg_tmp2.x = dot(mul_safe(reg_tmp1.xyzz, reg_tmp1.xyzz), vec4(1.0));
    // 335: rsq
    reg_tmp2.x = rsq_safe(reg_tmp2.xxxx.x);
    // 336: mul
    reg_tmp2.xyz = (mul_safe(reg_tmp1.xyzz, reg_tmp2.xxxx)).xyz;
    // 337: mov
    reg_tmp2.w = (uniforms.f[93].yyyy).w;
    // 338: mov
    vs_out_attr2 = reg_tmp2;
    return false;
}
bool sub_339_391() {
    // 339: mul
    reg_tmp15.xyz = (mul_safe(uniforms.f[7].xxxx, vs_in_reg0)).xyz;
    // 340: mul
    reg_tmp14.xyz = (mul_safe(uniforms.f[7].yyyy, vs_in_reg1)).xyz;
    // 341: mul
    reg_tmp13.xyz = (mul_safe(uniforms.f[7].zzzz, vs_in_reg2)).xyz;
    // 342: add
    reg_tmp15.xyz = (uniforms.f[6] + reg_tmp15).xyz;
    // 343: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 344: mov
    reg_tmp5 = uniforms.f[93].xxyy;
    // 345: mov
    reg_tmp6 = uniforms.f[93].yxxy;
    // 346: mov
    reg_tmp7 = uniforms.f[93].xxxx;
    // 347: mov
    reg_tmp12 = uniforms.f[93].xxxx;
    // 348: mov
    reg_tmp11 = uniforms.f[93].xxxx;
    // 349: mov
    reg_tmp9 = uniforms.f[93].xxxx;
    // 350: mov
    reg_tmp8 = uniforms.f[93].xxxx;
    // 351: mul
    reg_tmp2 = mul_safe(uniforms.f[93].wwww, vs_in_reg7);
    // 352: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 353: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 354: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 355: call
    {
        sub_304_325();
    }
    // 356: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 357: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 358: call
    {
        sub_304_325();
    }
    // 359: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 360: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 361: callc
    if (conditional_code.x) {
        sub_304_325();
    }
    // 362: ifu
    if (uniforms.b[8]) {
        sub_363_367();
    }
    // 367: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 368: mov
    reg_tmp10 = reg_tmp7;
    // 369: dp3
    reg_tmp13.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp11)), vec3(1.0));
    // 370: dp3
    reg_tmp13.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp11)), vec3(1.0));
    // 371: dp3
    reg_tmp13.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp11)), vec3(1.0));
    // 372: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 373: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 374: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 375: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 376: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 377: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 378: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 379: call
    {
        sub_325_339();
    }
    // 380: mov
    vs_out_attr1 = uniforms.f[93].xxxy;
    // 381: dp4
    reg_tmp0.x = dot(mul_safe(uniforms.f[86], reg_tmp15), vec4(1.0));
    // 382: dp4
    reg_tmp0.y = dot(mul_safe(uniforms.f[87], reg_tmp15), vec4(1.0));
    // 383: dp4
    reg_tmp0.z = dot(mul_safe(uniforms.f[88], reg_tmp15), vec4(1.0));
    // 384: dp4
    reg_tmp0.w = dot(mul_safe(uniforms.f[89], reg_tmp15), vec4(1.0));
    // 385: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 386: mul
    reg_tmp1.y = (mul_safe(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
    // 387: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 388: ifc
    if (all(conditional_code)) {
        sub_389_390();
    }
    // 390: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_363_367() {
    // 363: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 364: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 365: callc
    if (conditional_code.y) {
        sub_304_325();
    }
    // 366: nop
    return false;
}
bool sub_389_390() {
    // 389: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
// reference: 2DFD06A2DB7A6049, BEF53C1FB1E1CFF4
// program: BEF53C1FB1E1CFF4, AD7922A63ED54CA7, 1C819725D7DBB6AB
// reference: 2DFD06A23443F308, BEF53C1FB1E1CFF4
// program: BEF53C1FB1E1CFF4, AD7922A63ED54CA7, F67CD9340BD8A6A9
// reference: 7F396EB5EB104BC0, 76204850D3D31438
// reference: E66C16F430A9EA87, 76204850D3D31438
// reference: 5555804D47AD3823, BF583C1F84D94483
// reference: CC00F80C9C149964, BF583C1F84D94483
// reference: 982A49F5E23A84B1, 4EFF2C77DB8F9E73
// reference: 017F31B4398325F6, 4EFF2C77DB8F9E73
// reference: 971EC479A97A247E, 81D584DEE3289DE7
// reference: 4CDB36081B7D431E, B354DE6BBBEF83CA
// reference: D58E4E49C0C4E259, B354DE6BBBEF83CA
// reference: DCF7FCB81C4DB23E, 4EFF2C77DB8F9E73
// reference: A522DE84AC50930E, B354DE6BBBEF83CA
// reference: 45A284F9C7F41379, 4EFF2C77DB8F9E73
// reference: DC6F24AB19CC43F0, 76204850D3D31438
// reference: 4A4CE2757DA75A95, BF583C1F84D94483
// reference: D3199A34A61EFBD2, BF583C1F84D94483
// reference: 460C959CE23A84B1, 4EFF2C77DB8F9E73
// reference: DF59EDDD398325F6, 4EFF2C77DB8F9E73
// reference: D58E4E49EE85BAED, 2B10AE6FA2719F48
// reference: A522DE848211CBBA, 2B10AE6FA2719F48
// reference: 5358FED83CB73927, EC345D93DF769150
// reference: 5358FED8D38EAA66, EC345D93DF769150
// reference: 87BFD9A479629B8D, 76204850D3D31438
// reference: 1EEAA1E5A2DB3ACA, 76204850D3D31438
// reference: B2CA5564EFD58AD8, BF583C1F84D94483
// reference: 2B9F2D25346C2B9F, BF583C1F84D94483
// reference: BE8A228DAB0A8257, 4EFF2C77DB8F9E73
// reference: 27DF5ACC70B32310, 4EFF2C77DB8F9E73
// reference: 00A062E3E0ABC430, 81D584DEE3289DE7
// reference: DB6590927CEDFBE4, 2B10AE6FA2719F48
// reference: 4230E8D3A7545AA3, 2B10AE6FA2719F48
// reference: 4230E8D389150217, B354DE6BBBEF83CA
// reference: 4B495A22559C5270, 4EFF2C77DB8F9E73
// reference: 329C781EE5817340, B354DE6BBBEF83CA
// reference: 329C781ECBC02BF4, 2B10AE6FA2719F48
// reference: D21C22638E25F337, 4EFF2C77DB8F9E73
// reference: DB65909252ACA350, B354DE6BBBEF83CA
// reference: 508EAA39A9E97022, BF583C1F84D94483
// reference: C9DBD2787250D165, BF583C1F84D94483
// program: BF583C1F84D94483, 5D764F9A6220D694, 2F92B03EC8DF229E
// program: 0000000000000000, 0000000000000000, B71BBB2F3051D5FF
// reference: 9DF16381AB0A8257, 4EFF2C77DB8F9E73
// reference: 04A41BC070B32310, 4EFF2C77DB8F9E73
// reference: 36D0C33FD8A92FB0, 76204850D3D31438
// reference: AF85BB7E03108EF7, 76204850D3D31438
// reference: 9B55830B184F3806, BF583C1F84D94483
// reference: 0200FB4AC3F69941, BF583C1F84D94483
// reference: 562A4AB38E25F337, 4EFF2C77DB8F9E73
// reference: CF7F32F2559C5270, 4EFF2C77DB8F9E73
// program: B354DE6BBBEF83CA, 3B3AE026C742C7D5, CCCAFDE548B6C210
// program: BEF53C1FB1E1CFF4, AD7922A63ED54CA7, 3E5CAFDBABD516C0
// program: BEF53C1FB1E1CFF4, AD7922A63ED54CA7, E14D0525B6AB8EC9
// program: BEF53C1FB1E1CFF4, AD7922A63ED54CA7, CCB52BD33F912CFA
// program: BEF53C1FB1E1CFF4, AD7922A63ED54CA7, 615732319A39ACDD
// reference: 383B1DE44AC16EB9, 76204850D3D31438
// program: 76204850D3D31438, AD7922A63ED54CA7, EC68C55D9E1FD734
// reference: 2DFD06A255B6F6F5, 94BC5B2C4075B858
// program: BF583C1F84D94483, 5D764F9A6220D694, 111FE465C686BF45
// program: BF583C1F84D94483, 5D764F9A6220D694, 706545182ADD045D
// program: 0000000000000000, 0000000000000000, B575A1CB562E5A4B
// program: BF583C1F84D94483, 5D764F9A6220D694, 1F6F2B60C7AA5C2C
// program: BF583C1F84D94483, 5D764F9A6220D694, DD9D40A3AD63B59C
// program: 76204850D3D31438, AD7922A63ED54CA7, B498EC348B20D31B
// reference: A16E65A59178CFFE, 76204850D3D31438
// reference: 0CEB2591519ED848, BF583C1F84D94483
// reference: 95BE5DD08A27790F, BF583C1F84D94483
// reference: C194EC29C7F41379, 4EFF2C77DB8F9E73
// reference: 58C194681C4DB23E, 4EFF2C77DB8F9E73
// reference: 941BE96507CFDEAB, BF583C1F84D94483
// reference: 0D4E9124DC767FEC, BF583C1F84D94483
// reference: 889BC88BB1359F32, 17716008BB716A8F
// reference: 27DF5ACC9F8AB051, 4EFF2C77DB8F9E73
// reference: 85FDFF1BFDD94E03, E661110CC0BF42D1
// reference: D1DDD591A39B1697, 4EFF2C77DB8F9E73
// reference: 7E9947D6621DAAB5, 17716008BB716A8F
// reference: 7E9947D68D2439F4, 17716008BB716A8F
// reference: D1DDD5914CA285D6, 4EFF2C77DB8F9E73
// reference: AC444C8C2EAE6B57, 76204850D3D31438
// reference: 351134CDF517CA10, 76204850D3D31438
// reference: 4888ADD07822B7D0, 4EFF2C77DB8F9E73
// reference: 1B593CACA1A2A089, 52FC86954A48E51C
// reference: A53B30DE80AB29F6, 4EFF2C77DB8F9E73
// reference: 456E82383A0BCB5B, BF583C1F84D94483
// reference: DC3BFA79E1B26A1C, BF583C1F84D94483
// reference: 3C6E489F5B1288B1, 4EFF2C77DB8F9E73
// reference: 0A7FA299412D95D4, 17716008BB716A8F
// reference: A53B30DE6F92BAB7, 4EFF2C77DB8F9E73
// reference: E90B670AFDD94E03, E661110CC0BF42D1
// reference: BD2B4D80A39B1697, 4EFF2C77DB8F9E73
// reference: 126FDFC7621DAAB5, 17716008BB716A8F
// reference: 126FDFC78D2439F4, 17716008BB716A8F
// reference: BD2B4D804CA285D6, 4EFF2C77DB8F9E73
// reference: C0B2D49D2EAE6B57, 76204850D3D31438
// reference: 59E7ACDCF517CA10, 76204850D3D31438
// reference: 247E35C17822B7D0, 4EFF2C77DB8F9E73
// reference: E90B670A12E0DD42, E661110CC0BF42D1
// program: 4EFF2C77DB8F9E73, 3B3AE026C742C7D5, FEB1E39313EC6A3F
// program: 4EFF2C77DB8F9E73, 3B3AE026C742C7D5, 92F4F0B0E6943599
// reference: 705E1F4B2660EF44, E661110CC0BF42D1
// program: 4EFF2C77DB8F9E73, 3B3AE026C742C7D5, E6F396A1777C14A1
// program: 4EFF2C77DB8F9E73, 3B3AE026C742C7D5, C47F1A405F8DB749
// program: E661110CC0BF42D1, 3B3AE026C742C7D5, E62BC9CCE14A82D5
// program: 4EFF2C77DB8F9E73, 3B3AE026C742C7D5, B498EC348B20D31B
// reference: F0811ECACF44BF82, 4AD2C97240195A76
// reference: D7711E06BDF4664E, 4AD2C97240195A76
// reference: EEBB7FBFBDF4664E, 4AD2C97240195A76
// reference: D7711E06ED470C92, 4AD2C97240195A76
// reference: A0327416F68EDE3B, 4AD2C97240195A76
// shader: 8B30, DF833937D545E7DC

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((vec3(1.0) - rounded_primary_color.aaa) + (const_color[0].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) + (vec3(1.0) - const_color[1].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((vec3(1.0) - texcolor0.rgb) * (const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((texcolor0.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((texcolor0.rgb) * (const_color[4].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((1.0 - texcolor0.a) * (const_color[4].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: B5DB6A0A39D568B0, DF833937D545E7DC
// program: 0000000000000000, 0000000000000000, DF833937D545E7DC
// shader: 8B30, 9B71DB3DC792D45B

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((vec3(1.0) - rounded_primary_color.aaa) + (const_color[0].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) + (vec3(1.0) - const_color[1].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((vec3(1.0) - texcolor0.rgb) * (const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((texcolor0.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((texcolor0.rgb) * (const_color[4].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((1.0 - texcolor0.a) * (const_color[4].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (const_color[5].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 38666814B257F1BD, 9B71DB3DC792D45B
// program: BF583C1F84D94483, 5D764F9A6220D694, 9B71DB3DC792D45B
// reference: EEBB7FBFA63DB4E7, 4AD2C97240195A76
// reference: B908DBC8295E06BE, 93E967909E672D88
// shader: 8B30, 746CC72500CDC6E7

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((secondary_fragment_color.r) * (1.0 - const_color[0].a) + (secondary_fragment_color.b) * (1.0 - (1.0 - const_color[0].a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((secondary_fragment_color.ggg) * (last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((rounded_primary_color.a) * (const_color[4].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 9EF8DB042D2993F8, 746CC72500CDC6E7
// program: 0000000000000000, 0000000000000000, 746CC72500CDC6E7
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, 82B30867377518C0
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, FEB1E39313EC6A3F
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, AB9CD65F41BDEFA0
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, B29EF1BFC4D10886
// program: B582B9861A22E219, 3B3AE026C742C7D5, 85967F14F07719A7
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, 98677AC22B9A3E1A
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, 92F4F0B0E6943599
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, 8B353D67743458EE
// program: B582B9861A22E219, 3B3AE026C742C7D5, 18CD6F34EF819318
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, 06A8A4F9432C9B26
// program: 3DBC6131A77F0199, AD7922A63ED54CA7, E2B05A5EEE3BCE11
// reference: 380E46B026E8A870, 3DBC6131A77F0199
// program: 3DBC6131A77F0199, AD7922A63ED54CA7, 23F262D2CA8E6488
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, 7FF280648EA22926
// program: 3DBC6131A77F0199, AD7922A63ED54CA7, C74CA00DB8E95117
// program: 3DBC6131A77F0199, AD7922A63ED54CA7, 45B9B5821FF15384
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, 2F3A3851E4476855
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, 9DB6533B8FE11441
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, 98125BD9033DAC4C
// reference: EAD34DEA8562FAD3, 7F132D830BF35BC2
// program: 7F132D830BF35BC2, AD7922A63ED54CA7, D375021927AD9455
// reference: 738635AB5EDB5B94, 7F132D830BF35BC2
// program: 7F132D830BF35BC2, AD7922A63ED54CA7, FB2B5B4178346715
// reference: 0E1FACB6D3EE2654, BAF5CB3693892DB3
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, 82DDCA85272BD2AC
// program: 1E6C0649B5CE7F1C, AD7922A63ED54CA7, AAD077FFD85152AB
// program: 0000000000000000, 0000000000000000, AEA8529257EA252C
// program: EC7233A0BD4CF3D2, 5D764F9A6220D694, 68475D8B9F916549
// program: 0000000000000000, 0000000000000000, A8ADD30A63E76265
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, 528296AD4921766A
// program: EC7233A0BD4CF3D2, 5D764F9A6220D694, FA9C11D88771DF9F
// program: EC7233A0BD4CF3D2, 5D764F9A6220D694, 09AA976E69641246
// program: 7F132D830BF35BC2, AD7922A63ED54CA7, 10ADC50FC532FE6E
// shader: 8B30, 3C242A97096557B2

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp(min((texcolor0.rrr) + (texcolor0.ggg), vec3(1.0)) * (const_color[0].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor0.bbb) * (const_color[1].aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (vec3(1.0) - const_color[2].aaa) + (const_color[2].rgb) * (vec3(1.0) - (vec3(1.0) - const_color[2].aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((texcolor0.rgb) * (vec3(1.0) - const_color[4].aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (vec3(1.0) - const_color[4].aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: C628C19AFB3D45EF, 3C242A97096557B2
// program: 0000000000000000, 0000000000000000, 3C242A97096557B2
// reference: CCC00D86088B9DE5, CD1237CA557B3805
// program: CD1237CA557B3805, 3B3AE026C742C7D5, 2BB9C8FEDE51C537
// reference: 559575C7D3323CA2, CD1237CA557B3805
// program: CD1237CA557B3805, 3B3AE026C742C7D5, CCCAFDE548B6C210
// program: CD1237CA557B3805, 3B3AE026C742C7D5, 73E202FB36B8AAFC
// reference: DA005FD06B88D00F, EC7233A0BD4CF3D2
// shader: 8B30, 42CD599C5A3A4B1B

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb) * (vec3(1.0) - texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a) * (1.0 - texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (texcolor0.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (texcolor0.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 2EA60C8725305DBA, 42CD599C5A3A4B1B
// program: EC7233A0BD4CF3D2, 5D764F9A6220D694, 42CD599C5A3A4B1B
// reference: 43552791B0317148, EC7233A0BD4CF3D2
// shader: 8B30, A279FC7E01349071

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((vec3(1.0) - texcolor0.rgb) * (const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((texcolor0.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((texcolor0.rgb) * (const_color[4].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((1.0 - texcolor0.a) * (const_color[4].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: E13EE878A4CF4B00, A279FC7E01349071
// program: EC7233A0BD4CF3D2, 5D764F9A6220D694, A279FC7E01349071
// shader: 8B30, 1C4E7E439FA571F8

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb) * (vec3(1.0) - texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a) * (1.0 - texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (texcolor0.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (texcolor0.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: A31B0E99E04A4DAD, 1C4E7E439FA571F8
// program: 0000000000000000, 0000000000000000, 1C4E7E439FA571F8
// shader: 8B31, 8DC7CF5FC18DE470

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;
 out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define mul_safe(x, y) mix(x * y, vec4(0.0), isnan(x * y))

float rcp_safe(float x) {
    if (x == 0.0f) return x;
    return 1.0f / x;
}


float rsq_safe(float x) {
    if (x == 0.0f) return x;
    return inversesqrt(x);
}

#define fma_safe(x, y, z) (mul_safe(x, y) + z)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_4096();
bool sub_7_12();
bool sub_12_21();
bool sub_21_34();
bool sub_34_202();
bool sub_40_140();
bool sub_47_76();
bool sub_58_62();
bool sub_76_135();
bool sub_77_109();
bool sub_88_92();
bool sub_109_134();
bool sub_120_124();
bool sub_140_201();
bool sub_143_153();
bool sub_153_158();
bool sub_159_171();
bool sub_171_196();
bool sub_172_190();
bool sub_190_195();
bool sub_202_219();
bool sub_219_295();
bool sub_258_278();
bool sub_259_264();
bool sub_264_277();
bool sub_268_271();
bool sub_271_276();
bool sub_278_291();
bool sub_279_284();
bool sub_284_290();
bool sub_295_312();
bool sub_301_306();
bool sub_303_304();
bool sub_310_311();
bool sub_312_358();
bool sub_316_357();
bool sub_321_323();
bool sub_323_347();
bool sub_326_331();
bool sub_337_346();
bool sub_341_342();
bool sub_342_345();
bool sub_349_356();
bool sub_358_368();
bool sub_365_366();
bool sub_368_395();
bool sub_370_375();
bool sub_375_394();
bool sub_378_384();
bool sub_384_393();
bool sub_385_389();
bool sub_389_392();
bool sub_395_403();
bool sub_397_398();
bool sub_398_402();
bool sub_399_400();
bool sub_400_401();
bool sub_403_410();
bool sub_410_414();
bool sub_414_438();
bool sub_416_420();
bool sub_420_437();
bool sub_421_435();
bool sub_424_431();
bool sub_431_434();
bool sub_435_436();
bool sub_438_454();
bool sub_440_444();
bool sub_444_453();
bool sub_445_451();
bool sub_451_452();

bool exec_shader() {
    sub_0_4096();
    return true;
}

bool sub_0_4096() {
    // 0: call
    {
        sub_34_202();
    }
    // 1: call
    {
        sub_295_312();
    }
    // 2: call
    {
        sub_368_395();
    }
    // 3: call
    {
        sub_414_438();
    }
    // 4: call
    {
        sub_438_454();
    }
    // 5: end
    return true;
}
bool sub_7_12() {
    // 7: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 8: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 9: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 10: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 11: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    return false;
}
bool sub_12_21() {
    // 12: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 13: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 14: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 15: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 16: dp3
    reg_tmp4.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 17: dp3
    reg_tmp4.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 18: dp3
    reg_tmp4.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 19: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 20: mad
    reg_tmp12 = fma_safe(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_21_34() {
    // 21: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 22: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 23: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 24: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 25: dp3
    reg_tmp4.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 26: dp3
    reg_tmp4.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 27: dp3
    reg_tmp4.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 28: dp3
    reg_tmp5.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 29: dp3
    reg_tmp5.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 30: dp3
    reg_tmp5.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 31: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 32: mad
    reg_tmp12 = fma_safe(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    // 33: mad
    reg_tmp11 = fma_safe(reg_tmp1.wwww, reg_tmp5, reg_tmp11);
    return false;
}
bool sub_34_202() {
    // 34: mul
    reg_tmp15.xyz = (mul_safe(uniforms.f[7].xxxx, vs_in_reg0)).xyz;
    // 35: mul
    reg_tmp14.xyz = (mul_safe(uniforms.f[7].yyyy, vs_in_reg1)).xyz;
    // 36: mul
    reg_tmp13.xyz = (mul_safe(uniforms.f[7].zzzz, vs_in_reg2)).xyz;
    // 37: add
    reg_tmp15.xyz = (uniforms.f[6] + reg_tmp15).xyz;
    // 38: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 39: ifu
    if (uniforms.b[1]) {
        sub_40_140();
    } else {
        sub_140_201();
    }
    // 201: nop
    return false;
}
bool sub_40_140() {
    // 40: mov
    reg_tmp0 = uniforms.f[7];
    // 41: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.yzzz));
    // 42: mov
    reg_tmp7 = uniforms.f[93].xxxx;
    // 43: mov
    reg_tmp12 = uniforms.f[93].xxxx;
    // 44: mov
    reg_tmp11 = uniforms.f[93].xxxx;
    // 45: mul
    reg_tmp2 = mul_safe(uniforms.f[93].wwww, vs_in_reg7);
    // 46: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_47_76();
    } else {
        sub_76_135();
    }
    // 135: mov
    vs_out_attr2 = -reg_tmp15;
    // 136: dp4
    vs_out_attr0.x = dot(mul_safe(uniforms.f[86], reg_tmp15), vec4(1.0));
    // 137: dp4
    vs_out_attr0.y = dot(mul_safe(uniforms.f[87], reg_tmp15), vec4(1.0));
    // 138: dp4
    vs_out_attr0.z = dot(mul_safe(uniforms.f[88], reg_tmp15), vec4(1.0));
    // 139: dp4
    vs_out_attr0.w = dot(mul_safe(uniforms.f[89], reg_tmp15), vec4(1.0));
    return false;
}
bool sub_47_76() {
    // 47: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 48: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 49: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 50: call
    {
        sub_12_21();
    }
    // 51: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 52: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 53: call
    {
        sub_12_21();
    }
    // 54: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 55: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 56: callc
    if (conditional_code.x) {
        sub_12_21();
    }
    // 57: ifu
    if (uniforms.b[8]) {
        sub_58_62();
    }
    // 62: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 63: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 64: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 65: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 66: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 67: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 68: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 69: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 70: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 71: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 72: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 73: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 74: call
    {
        sub_202_219();
    }
    // 75: nop
    return false;
}
bool sub_58_62() {
    // 58: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 59: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 60: callc
    if (conditional_code.y) {
        sub_12_21();
    }
    // 61: nop
    return false;
}
bool sub_76_135() {
    // 76: ifc
    if (all(conditional_code)) {
        sub_77_109();
    } else {
        sub_109_134();
    }
    // 134: nop
    return false;
}
bool sub_77_109() {
    // 77: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 78: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 79: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 80: call
    {
        sub_21_34();
    }
    // 81: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 82: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 83: call
    {
        sub_21_34();
    }
    // 84: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 85: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 86: callc
    if (conditional_code.x) {
        sub_21_34();
    }
    // 87: ifu
    if (uniforms.b[8]) {
        sub_88_92();
    }
    // 92: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 93: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 94: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 95: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 96: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 97: dp3
    reg_tmp13.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp11)), vec3(1.0));
    // 98: dp3
    reg_tmp13.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp11)), vec3(1.0));
    // 99: dp3
    reg_tmp13.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp11)), vec3(1.0));
    // 100: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 101: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 102: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 103: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 104: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 105: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 106: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 107: call
    {
        sub_219_295();
    }
    // 108: nop
    return false;
}
bool sub_88_92() {
    // 88: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 89: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 90: callc
    if (conditional_code.y) {
        sub_21_34();
    }
    // 91: nop
    return false;
}
bool sub_109_134() {
    // 109: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 110: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 111: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 112: call
    {
        sub_7_12();
    }
    // 113: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 114: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 115: call
    {
        sub_7_12();
    }
    // 116: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 117: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 118: callc
    if (conditional_code.x) {
        sub_7_12();
    }
    // 119: ifu
    if (uniforms.b[8]) {
        sub_120_124();
    }
    // 124: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 125: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 126: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 127: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 128: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 129: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 130: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 131: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 132: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 133: mov
    vs_out_attr1 = uniforms.f[93].xxxx;
    return false;
}
bool sub_120_124() {
    // 120: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 121: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 122: callc
    if (conditional_code.y) {
        sub_7_12();
    }
    // 123: nop
    return false;
}
bool sub_140_201() {
    // 140: mov
    reg_tmp0 = uniforms.f[7];
    // 141: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.yzzz));
    // 142: ifu
    if (uniforms.b[2]) {
        sub_143_153();
    } else {
        sub_153_158();
    }
    // 158: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_159_171();
    } else {
        sub_171_196();
    }
    // 196: mov
    vs_out_attr2 = -reg_tmp15;
    // 197: dp4
    vs_out_attr0.x = dot(mul_safe(uniforms.f[86], reg_tmp15), vec4(1.0));
    // 198: dp4
    vs_out_attr0.y = dot(mul_safe(uniforms.f[87], reg_tmp15), vec4(1.0));
    // 199: dp4
    vs_out_attr0.z = dot(mul_safe(uniforms.f[88], reg_tmp15), vec4(1.0));
    // 200: dp4
    vs_out_attr0.w = dot(mul_safe(uniforms.f[89], reg_tmp15), vec4(1.0));
    return false;
}
bool sub_143_153() {
    // 143: mul
    reg_tmp1.x = (mul_safe(uniforms.f[93].wwww, vs_in_reg7.xxxx)).x;
    // 144: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 145: dp4
    reg_tmp7.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 146: dp4
    reg_tmp7.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 147: dp4
    reg_tmp7.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 148: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 149: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 150: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 151: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 152: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_153_158() {
    // 153: mova
    address_registers.x = (ivec2(uniforms.f[93].xxxx)).x;
    // 154: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[25], reg_tmp15), vec4(1.0));
    // 155: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[26], reg_tmp15), vec4(1.0));
    // 156: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[27], reg_tmp15), vec4(1.0));
    // 157: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_159_171() {
    // 159: dp3
    reg_tmp12.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 160: dp3
    reg_tmp12.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 161: dp3
    reg_tmp12.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 162: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 163: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 164: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 165: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 166: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 167: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 168: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 169: call
    {
        sub_202_219();
    }
    // 170: nop
    return false;
}
bool sub_171_196() {
    // 171: ifc
    if (all(conditional_code)) {
        sub_172_190();
    } else {
        sub_190_195();
    }
    // 195: nop
    return false;
}
bool sub_172_190() {
    // 172: dp3
    reg_tmp12.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 173: dp3
    reg_tmp12.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 174: dp3
    reg_tmp12.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 175: dp3
    reg_tmp11.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 176: dp3
    reg_tmp11.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 177: dp3
    reg_tmp11.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 178: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 179: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 180: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 181: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 182: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 183: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 184: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 185: dp3
    reg_tmp13.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp11)), vec3(1.0));
    // 186: dp3
    reg_tmp13.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp11)), vec3(1.0));
    // 187: dp3
    reg_tmp13.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp11)), vec3(1.0));
    // 188: call
    {
        sub_219_295();
    }
    // 189: nop
    return false;
}
bool sub_190_195() {
    // 190: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 191: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 192: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 193: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 194: mov
    vs_out_attr1 = uniforms.f[93].xxxx;
    return false;
}
bool sub_202_219() {
    uint jmp_to = 202u;
    while (true) {
        switch (jmp_to) {
        case 202u: {
            // 202: dp3
            reg_tmp6.x = dot(vec3(mul_safe(reg_tmp14, reg_tmp14)), vec3(1.0));
            // 203: dp3
            reg_tmp7.x = dot(vec3(mul_safe(reg_tmp12, reg_tmp12)), vec3(1.0));
            // 204: rsq
            reg_tmp6.x = rsq_safe(reg_tmp6.xxxx.x);
            // 205: rsq
            reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
            // 206: mul
            reg_tmp14.xyz = (mul_safe(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 207: mul
            reg_tmp12.xyz = (mul_safe(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 208: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 209: jmpu
            if (!uniforms.b[15]) {
                { jmp_to = 218u; break; }
            }
            // 210: add
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            // 211: mul
            reg_tmp4 = mul_safe(uniforms.f[94].zzzz, reg_tmp4);
            // 212: cmp
            conditional_code = greaterThanEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp4.xxxx));
            // 213: rsq
            reg_tmp4 = vec4(rsq_safe(reg_tmp4.xxxx.x));
            // 214: mul
            reg_tmp5 = mul_safe(uniforms.f[94].zzzz, reg_tmp14);
            // 215: jmpc
            if (conditional_code.x) {
                { jmp_to = 218u; break; }
            }
            // 216: rcp
            reg_tmp0.z = rcp_safe(reg_tmp4.xxxx.x);
            // 217: mul
            reg_tmp0.xy = (mul_safe(reg_tmp5, reg_tmp4)).xy;
        }
        case 218u: {
            // 218: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_219_295() {
    uint jmp_to = 219u;
    while (true) {
        switch (jmp_to) {
        case 219u: {
            // 219: dp3
            reg_tmp6.x = dot(vec3(mul_safe(reg_tmp14, reg_tmp14)), vec3(1.0));
            // 220: dp3
            reg_tmp7.x = dot(vec3(mul_safe(reg_tmp12, reg_tmp12)), vec3(1.0));
            // 221: rsq
            reg_tmp6.x = rsq_safe(reg_tmp6.xxxx.x);
            // 222: rsq
            reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
            // 223: mul
            reg_tmp14.xyz = (mul_safe(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 224: mul
            reg_tmp12.xyz = (mul_safe(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 225: mul
            reg_tmp13.xyz = (mul_safe(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            // 226: mul
            reg_tmp11.xyz = (mul_safe(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            // 227: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 228: jmpu
            if (!uniforms.b[15]) {
                { jmp_to = 294u; break; }
            }
            // 229: mul
            reg_tmp13.xyz = (mul_safe(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            // 230: mul
            reg_tmp11.xyz = (mul_safe(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            // 231: mul
            reg_tmp5 = mul_safe(reg_tmp14.yzxx, reg_tmp13.zxyy);
            // 232: mad
            reg_tmp5 = fma_safe(-reg_tmp13.yzxx, reg_tmp14.zxyy, reg_tmp5);
            // 233: dp3
            reg_tmp5.w = dot(vec3(mul_safe(reg_tmp5, reg_tmp5)), vec3(1.0));
            // 234: rsq
            reg_tmp5.w = rsq_safe(reg_tmp5.wwww.x);
            // 235: mul
            reg_tmp5 = mul_safe(reg_tmp5, reg_tmp5.wwww);
            // 236: add
            reg_tmp6.w = (reg_tmp14.zzzz + reg_tmp5.yyyy).w;
            // 237: mul
            reg_tmp13 = mul_safe(reg_tmp5.yzxx, reg_tmp14.zxyy);
            // 238: mad
            reg_tmp13 = fma_safe(-reg_tmp14.yzxx, reg_tmp5.zxyy, reg_tmp13);
            // 239: add
            reg_tmp6.w = (reg_tmp13.xxxx + reg_tmp6).w;
            // 240: mov
            reg_tmp13.w = (reg_tmp5.zzzz).w;
            // 241: mov
            reg_tmp5.z = (reg_tmp13.xxxx).z;
            // 242: add
            reg_tmp6.w = (uniforms.f[93].yyyy + reg_tmp6).w;
            // 243: mov
            reg_tmp14.w = (reg_tmp5.xxxx).w;
            // 244: mov
            reg_tmp5.x = (reg_tmp14.zzzz).x;
            // 245: cmp
            conditional_code = lessThan(vec2(uniforms.f[94].yyyy), vec2(reg_tmp6.wwww));
            // 246: mov
            reg_tmp6.x = (uniforms.f[93].yyyy).x;
            // 247: mov
            reg_tmp6.y = (-uniforms.f[93].yyyy).y;
            // 248: jmpc
            if (!conditional_code.x) {
                { jmp_to = 256u; break; }
            }
            // 249: add
            reg_tmp7.xz = (reg_tmp13.wwyy + -reg_tmp14.yyww).xz;
            // 250: add
            reg_tmp7.y = (reg_tmp14.xxxx + -reg_tmp13.zzzz).y;
            // 251: mov
            reg_tmp7.w = (reg_tmp6).w;
            // 252: dp4
            reg_tmp6 = vec4(dot(mul_safe(reg_tmp7, reg_tmp7), vec4(1.0)));
            // 253: rsq
            reg_tmp6 = vec4(rsq_safe(reg_tmp6.xxxx.x));
            // 254: mul
            reg_tmp0 = mul_safe(reg_tmp7, reg_tmp6);
            // 255: jmpu
            if (uniforms.b[0]) {
                { jmp_to = 294u; break; }
            }
        }
        case 256u: {
            // 256: cmp
            conditional_code = greaterThan(vec2(reg_tmp5.zyyy), vec2(reg_tmp5.yxxx));
            // 257: ifc
            if (conditional_code.x) {
                sub_258_278();
            } else {
                sub_278_291();
            }
            // 291: dp4
            reg_tmp6 = vec4(dot(mul_safe(reg_tmp8, reg_tmp8), vec4(1.0)));
            // 292: rsq
            reg_tmp6 = vec4(rsq_safe(reg_tmp6.xxxx.x));
            // 293: mul
            reg_tmp0 = mul_safe(reg_tmp8, reg_tmp6);
        }
        case 294u: {
            // 294: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_258_278() {
    // 258: ifc
    if (conditional_code.y) {
        sub_259_264();
    } else {
        sub_264_277();
    }
    // 277: mov
    reg_tmp8.w = (-reg_tmp8).w;
    return false;
}
bool sub_259_264() {
    // 259: mul
    reg_tmp8 = mul_safe(reg_tmp13.yyzw, reg_tmp6.xxxy);
    // 260: add
    reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
    // 261: add
    reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
    // 262: add
    reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
    // 263: add
    reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
    return false;
}
bool sub_264_277() {
    // 264: cmp
    conditional_code = greaterThan(vec2(reg_tmp5.zzzz), vec2(reg_tmp5.xxxx));
    // 265: mul
    reg_tmp8 = mul_safe(reg_tmp13.yyzw, reg_tmp6.xxxy);
    // 266: add
    reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
    // 267: ifc
    if (conditional_code.x) {
        sub_268_271();
    } else {
        sub_271_276();
    }
    // 276: nop
    return false;
}
bool sub_268_271() {
    // 268: add
    reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
    // 269: add
    reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
    // 270: add
    reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
    return false;
}
bool sub_271_276() {
    // 271: mul
    reg_tmp8 = mul_safe(reg_tmp13.zwwy, reg_tmp6.xxxy);
    // 272: add
    reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
    // 273: add
    reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
    // 274: add
    reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
    // 275: add
    reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
    return false;
}
bool sub_278_291() {
    // 278: ifc
    if (conditional_code.y) {
        sub_279_284();
    } else {
        sub_284_290();
    }
    // 290: nop
    return false;
}
bool sub_279_284() {
    // 279: mul
    reg_tmp8 = mul_safe(reg_tmp13.yywz, reg_tmp6.xxxy);
    // 280: add
    reg_tmp8.y = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).y;
    // 281: add
    reg_tmp9 = reg_tmp5.yyyy + -reg_tmp5.xxxx;
    // 282: add
    reg_tmp8.xzw = (reg_tmp8 + reg_tmp14.wwyx).xzw;
    // 283: add
    reg_tmp8.y = (reg_tmp9 + reg_tmp8).y;
    return false;
}
bool sub_284_290() {
    // 284: mul
    reg_tmp8 = mul_safe(reg_tmp13.zwwy, reg_tmp6.xxxy);
    // 285: add
    reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
    // 286: add
    reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
    // 287: add
    reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
    // 288: add
    reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
    // 289: mov
    reg_tmp8.w = (-reg_tmp8).w;
    return false;
}
bool sub_295_312() {
    // 295: mov
    reg_tmp8.xy = (uniforms.f[93].xxxx).xy;
    // 296: mov
    reg_tmp0.y = (uniforms.f[7].wwww).y;
    // 297: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.xyyy));
    // 298: mov
    reg_tmp9.xyz = (uniforms.f[93].xxxx).xyz;
    // 299: mov
    reg_tmp9.w = (uniforms.f[21].wwww).w;
    // 300: ifc
    if (conditional_code.y) {
        sub_301_306();
    }
    // 306: callu
    if (uniforms.b[12]) {
        sub_312_358();
    }
    // 307: callu
    if (uniforms.b[5]) {
        sub_358_368();
    }
    // 308: cmp
    conditional_code = equal(vec2(uniforms.f[93].xxxx), vec2(reg_tmp8.xyyy));
    // 309: ifc
    if (all(conditional_code)) {
        sub_310_311();
    }
    // 311: max
    vs_out_attr3 = max(uniforms.f[93].xxxx, reg_tmp9);
    return false;
}
bool sub_301_306() {
    // 301: mul
    reg_tmp0 = mul_safe(uniforms.f[7].wwww, vs_in_reg3);
    // 302: ifu
    if (uniforms.b[7]) {
        sub_303_304();
    }
    // 304: mul
    reg_tmp9.xyz = (mul_safe(uniforms.f[20].wwww, reg_tmp0.xyzz)).xyz;
    // 305: mov
    reg_tmp8.x = (uniforms.f[93].yyyy).x;
    return false;
}
bool sub_303_304() {
    // 303: mul
    reg_tmp9.w = (mul_safe(reg_tmp9.wwww, reg_tmp0.wwww)).w;
    return false;
}
bool sub_310_311() {
    // 310: mov
    reg_tmp9 = uniforms.f[21];
    return false;
}
bool sub_312_358() {
    // 312: mov
    reg_tmp1 = uniforms.f[20];
    // 313: mov
    reg_tmp2 = uniforms.f[21];
    // 314: mov
    reg_tmp3 = uniforms.f[93].xxxx;
    // 315: loop
    address_registers.z = int(uniforms.i[0].y);
    for (uint loop315 = 0u; loop315 <= uniforms.i[0].x; address_registers.z += int(uniforms.i[0].z), ++loop315) {
        sub_316_357();
    }
    // 357: mov
    reg_tmp8.x = (uniforms.f[93].yyyy).x;
    return false;
}
bool sub_316_357() {
    // 316: mova
    address_registers.x = (ivec2(reg_tmp3)).x;
    // 317: mov
    reg_tmp4.x = (uniforms.f[81 + address_registers.x].wwww).x;
    // 318: mov
    reg_tmp4.y = (uniforms.f[83 + address_registers.x].wwww).y;
    // 319: cmp
    conditional_code = equal(vec2(uniforms.f[93].xyyy), vec2(reg_tmp4.xyyy));
    // 320: ifc
    if (conditional_code.x) {
        sub_321_323();
    } else {
        sub_323_347();
    }
    // 347: cmp
    conditional_code.x = uniforms.f[93].xxxx.x == reg_tmp6.xyyy.x;
    conditional_code.y = uniforms.f[93].xxxx.y < reg_tmp6.xyyy.y;
    // 348: ifc
    if (conditional_code.y) {
        sub_349_356();
    }
    // 356: add
    reg_tmp3 = -uniforms.f[95].wwww + reg_tmp3;
    return false;
}
bool sub_321_323() {
    // 321: dp3
    reg_tmp6.x = dot(vec3(mul_safe(uniforms.f[81 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 322: mov
    reg_tmp6.y = (uniforms.f[93].yyyy).y;
    return false;
}
bool sub_323_347() {
    // 323: add
    reg_tmp4 = uniforms.f[81 + address_registers.x] + -reg_tmp15;
    // 324: mov
    reg_tmp6.y = (uniforms.f[93].yyyy).y;
    // 325: ifc
    if (conditional_code.y) {
        sub_326_331();
    }
    // 331: mov
    reg_tmp5 = uniforms.f[82 + address_registers.x];
    // 332: cmp
    conditional_code = equal(vec2(uniforms.f[93].yyyy), vec2(reg_tmp5.wwww));
    // 333: dp3
    reg_tmp4.w = dot(vec3(mul_safe(reg_tmp4, reg_tmp4)), vec3(1.0));
    // 334: rsq
    reg_tmp4.w = rsq_safe(reg_tmp4.wwww.x);
    // 335: mul
    reg_tmp4 = mul_safe(reg_tmp4, reg_tmp4.wwww);
    // 336: ifc
    if (conditional_code.x) {
        sub_337_346();
    }
    // 346: dp3
    reg_tmp6.x = dot(vec3(mul_safe(reg_tmp14, reg_tmp4)), vec3(1.0));
    return false;
}
bool sub_326_331() {
    // 326: mov
    reg_tmp5.x = (uniforms.f[93].yyyy).x;
    // 327: dp3
    reg_tmp5.z = dot(vec3(mul_safe(reg_tmp4, reg_tmp4)), vec3(1.0));
    // 328: mul
    reg_tmp5.y = (mul_safe(reg_tmp5.zzzz, reg_tmp5.zzzz)).y;
    // 329: dp3
    reg_tmp6.y = dot(vec3(mul_safe(uniforms.f[83 + address_registers.x], reg_tmp5)), vec3(1.0));
    // 330: rcp
    reg_tmp6.y = rcp_safe(reg_tmp6.yyyy.x);
    return false;
}
bool sub_337_346() {
    // 337: dp3
    reg_tmp5.x = dot(vec3(mul_safe(uniforms.f[82 + address_registers.x], -reg_tmp4)), vec3(1.0));
    // 338: slti
    reg_tmp5.y = (vec4(lessThan(reg_tmp5.xxxx,uniforms.f[84 + address_registers.x].yyyy))).y;
    // 339: cmp
    conditional_code = equal(vec2(uniforms.f[93].yyyy), vec2(reg_tmp5.xyyy));
    // 340: ifc
    if (conditional_code.y) {
        sub_341_342();
    } else {
        sub_342_345();
    }
    // 345: mul
    reg_tmp6.y = (mul_safe(reg_tmp6.yyyy, reg_tmp5.xxxx)).y;
    return false;
}
bool sub_341_342() {
    // 341: mov
    reg_tmp5.x = (uniforms.f[93].xxxx).x;
    return false;
}
bool sub_342_345() {
    // 342: log
    reg_tmp5.y = log2(reg_tmp5.xxxx.x);
    // 343: mul
    reg_tmp5.y = (mul_safe(uniforms.f[84 + address_registers.x].xxxx, reg_tmp5.yyyy)).y;
    // 344: exp
    reg_tmp5.x = exp2(reg_tmp5.yyyy.x);
    return false;
}
bool sub_349_356() {
    // 349: max
    reg_tmp6.x = (max(uniforms.f[93].xxxx, reg_tmp6.xxxx)).x;
    // 350: mad
    reg_tmp9.xyz = (fma_safe(reg_tmp1.xyzz, uniforms.f[79 + address_registers.x].xyzz, reg_tmp9.xyzz)).xyz;
    // 351: mul
    reg_tmp4 = mul_safe(uniforms.f[80 + address_registers.x], reg_tmp2);
    // 352: mul
    reg_tmp5.xyz = (mul_safe(reg_tmp6.xxxx, reg_tmp4.xyzz)).xyz;
    // 353: mul
    reg_tmp5.xyz = (mul_safe(reg_tmp6.yyyy, reg_tmp5.xyzz)).xyz;
    // 354: add
    reg_tmp9.xyz = (reg_tmp9.xyzz + reg_tmp5.xyzz).xyz;
    // 355: add
    reg_tmp9.w = (reg_tmp9.wwww + reg_tmp4.wwww).w;
    return false;
}
bool sub_358_368() {
    // 358: dp3
    reg_tmp1 = vec4(dot(vec3(mul_safe(uniforms.f[24], reg_tmp14)), vec3(1.0)));
    // 359: mov
    reg_tmp2 = uniforms.f[24].wwww;
    // 360: mad
    reg_tmp1 = fma_safe(reg_tmp1, reg_tmp2, reg_tmp2);
    // 361: mov
    reg_tmp3 = uniforms.f[22];
    // 362: add
    reg_tmp2 = uniforms.f[23] + -reg_tmp3;
    // 363: mad
    reg_tmp4 = fma_safe(reg_tmp2, reg_tmp1, reg_tmp3);
    // 364: ifu
    if (uniforms.b[6]) {
        sub_365_366();
    }
    // 366: mad
    reg_tmp9.xyz = (fma_safe(reg_tmp4, uniforms.f[21], reg_tmp9)).xyz;
    // 367: mov
    reg_tmp8.x = (uniforms.f[93].yyyy).x;
    return false;
}
bool sub_365_366() {
    // 365: mul
    reg_tmp4 = mul_safe(reg_tmp4, reg_tmp9.wwww);
    return false;
}
bool sub_368_395() {
    // 368: mov
    reg_tmp0.xy = (uniforms.f[10].xxxx).xy;
    // 369: ifu
    if (uniforms.b[9]) {
        sub_370_375();
    } else {
        sub_375_394();
    }
    // 394: nop
    return false;
}
bool sub_370_375() {
    // 370: call
    {
        sub_395_403();
    }
    // 371: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[11].xywz, reg_tmp6), vec4(1.0));
    // 372: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[12].xywz, reg_tmp6), vec4(1.0));
    // 373: mov
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    // 374: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_375_394() {
    // 375: cmp
    conditional_code = equal(vec2(uniforms.f[95].xyyy), vec2(reg_tmp0.xyyy));
    // 376: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 377: ifc
    if (all(not(conditional_code))) {
        sub_378_384();
    } else {
        sub_384_393();
    }
    // 393: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_378_384() {
    // 378: mov
    reg_tmp6 = reg_tmp10;
    // 379: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[11], reg_tmp6), vec4(1.0));
    // 380: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[12], reg_tmp6), vec4(1.0));
    // 381: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[13], reg_tmp6), vec4(1.0));
    // 382: mul
    reg_tmp0.xy = (mul_safe(uniforms.f[19].xyyy, reg_tmp3.zzzz)).xy;
    // 383: add
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_384_393() {
    // 384: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_385_389();
    } else {
        sub_389_392();
    }
    // 392: nop
    return false;
}
bool sub_385_389() {
    // 385: call
    {
        sub_403_410();
    }
    // 386: dp3
    reg_tmp3.x = dot(vec3(mul_safe(uniforms.f[11], reg_tmp6)), vec3(1.0));
    // 387: dp3
    reg_tmp3.y = dot(vec3(mul_safe(uniforms.f[12], reg_tmp6)), vec3(1.0));
    // 388: dp3
    reg_tmp3.z = dot(vec3(mul_safe(uniforms.f[13], reg_tmp6)), vec3(1.0));
    return false;
}
bool sub_389_392() {
    // 389: call
    {
        sub_410_414();
    }
    // 390: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[11], reg_tmp6), vec4(1.0));
    // 391: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[12], reg_tmp6), vec4(1.0));
    return false;
}
bool sub_395_403() {
    // 395: cmp
    conditional_code = equal(vec2(uniforms.f[93].yzzz), vec2(reg_tmp0.xyyy));
    // 396: ifc
    if (all(not(conditional_code))) {
        sub_397_398();
    } else {
        sub_398_402();
    }
    // 402: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_397_398() {
    // 397: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
    return false;
}
bool sub_398_402() {
    // 398: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_399_400();
    } else {
        sub_400_401();
    }
    // 401: nop
    return false;
}
bool sub_399_400() {
    // 399: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
    return false;
}
bool sub_400_401() {
    // 400: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
    return false;
}
bool sub_403_410() {
    // 403: mov
    reg_tmp2 = -reg_tmp15;
    // 404: dp3
    reg_tmp2.w = dot(vec3(mul_safe(reg_tmp2, reg_tmp2)), vec3(1.0));
    // 405: rsq
    reg_tmp2.w = rsq_safe(reg_tmp2.wwww.x);
    // 406: mul
    reg_tmp2 = mul_safe(reg_tmp2, reg_tmp2.wwww);
    // 407: dp3
    reg_tmp1 = vec4(dot(vec3(mul_safe(reg_tmp2, reg_tmp14)), vec3(1.0)));
    // 408: add
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    // 409: mad
    reg_tmp6 = fma_safe(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_410_414() {
    // 410: mov
    reg_tmp1.xy = (uniforms.f[94].zzzz).xy;
    // 411: mov
    reg_tmp1.zw = (uniforms.f[93].xxxx).zw;
    // 412: mad
    reg_tmp6 = fma_safe(reg_tmp14, reg_tmp1, reg_tmp1);
    // 413: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_414_438() {
    // 414: mov
    reg_tmp0.xy = (uniforms.f[10].yyyy).xy;
    // 415: ifu
    if (uniforms.b[10]) {
        sub_416_420();
    } else {
        sub_420_437();
    }
    // 437: nop
    return false;
}
bool sub_416_420() {
    // 416: call
    {
        sub_395_403();
    }
    // 417: dp4
    reg_tmp4.x = dot(mul_safe(uniforms.f[14].xywz, reg_tmp6), vec4(1.0));
    // 418: dp4
    reg_tmp4.y = dot(mul_safe(uniforms.f[15].xywz, reg_tmp6), vec4(1.0));
    // 419: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_420_437() {
    // 420: ifu
    if (uniforms.b[13]) {
        sub_421_435();
    } else {
        sub_435_436();
    }
    // 436: nop
    return false;
}
bool sub_421_435() {
    // 421: cmp
    conditional_code = equal(vec2(uniforms.f[95].xyyy), vec2(reg_tmp0.xyyy));
    // 422: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 423: ifc
    if (all(not(conditional_code))) {
        sub_424_431();
    } else {
        sub_431_434();
    }
    // 434: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_424_431() {
    // 424: mov
    reg_tmp6 = reg_tmp10;
    // 425: dp4
    reg_tmp4.x = dot(mul_safe(uniforms.f[14], reg_tmp6), vec4(1.0));
    // 426: dp4
    reg_tmp4.y = dot(mul_safe(uniforms.f[15], reg_tmp6), vec4(1.0));
    // 427: dp4
    reg_tmp4.z = dot(mul_safe(uniforms.f[16], reg_tmp6), vec4(1.0));
    // 428: rcp
    reg_tmp6.w = rcp_safe(reg_tmp4.zzzz.x);
    // 429: mul
    reg_tmp4.xy = (mul_safe(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    // 430: add
    reg_tmp4.xy = (uniforms.f[19].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_431_434() {
    // 431: call
    {
        sub_410_414();
    }
    // 432: dp4
    reg_tmp4.x = dot(mul_safe(uniforms.f[14], reg_tmp6), vec4(1.0));
    // 433: dp4
    reg_tmp4.y = dot(mul_safe(uniforms.f[15], reg_tmp6), vec4(1.0));
    return false;
}
bool sub_435_436() {
    // 435: mov
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_438_454() {
    // 438: mov
    reg_tmp0.xy = (uniforms.f[10].zzzz).xy;
    // 439: ifu
    if (uniforms.b[11]) {
        sub_440_444();
    } else {
        sub_444_453();
    }
    // 453: nop
    return false;
}
bool sub_440_444() {
    // 440: call
    {
        sub_395_403();
    }
    // 441: dp4
    reg_tmp5.x = dot(mul_safe(uniforms.f[17].xywz, reg_tmp6), vec4(1.0));
    // 442: dp4
    reg_tmp5.y = dot(mul_safe(uniforms.f[18].xywz, reg_tmp6), vec4(1.0));
    // 443: mov
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_444_453() {
    // 444: ifu
    if (uniforms.b[14]) {
        sub_445_451();
    } else {
        sub_451_452();
    }
    // 452: nop
    return false;
}
bool sub_445_451() {
    // 445: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 446: mov
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    // 447: call
    {
        sub_410_414();
    }
    // 448: dp4
    reg_tmp5.x = dot(mul_safe(uniforms.f[17], reg_tmp6), vec4(1.0));
    // 449: dp4
    reg_tmp5.y = dot(mul_safe(uniforms.f[18], reg_tmp6), vec4(1.0));
    // 450: mov
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_451_452() {
    // 451: mov
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
// reference: 441707DFC332A59E, 8DC7CF5FC18DE470
// reference: 92755120598C7306, 30DAB74CA24CBC58
// program: 8DC7CF5FC18DE470, AD7922A63ED54CA7, 30DAB74CA24CBC58
// reference: DD427F9E188B04D9, 8DC7CF5FC18DE470
// shader: 8B30, 21647988483E7BCD

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 92755120B53B9805, 21647988483E7BCD
// program: 8DC7CF5FC18DE470, AD7922A63ED54CA7, 21647988483E7BCD
// reference: B4A87EE35DDC3512, 46DC307C8C5A54D6
// program: 46DC307C8C5A54D6, AD7922A63ED54CA7, 3E5CAFDBABD516C0
// reference: 2DFD06A2695C0714, 46DC307C8C5A54D6
// program: 46DC307C8C5A54D6, AD7922A63ED54CA7, E14D0525B6AB8EC9
// program: 46DC307C8C5A54D6, AD7922A63ED54CA7, CCB52BD33F912CFA
// shader: 8B30, 57B333648195A2F8

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = 2.0 * (texcolor2).rgb - 1.0;
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(normal, normalize(view))));
refl_value.g = (lut_scale_rg * LookupLightingLUTSigned(5, dot(normal, normalize(view))));
refl_value.b = (lut_scale_rb * LookupLightingLUTSigned(4, dot(normal, normalize(view))));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((secondary_fragment_color.r) * (1.0 - const_color[0].a) + (secondary_fragment_color.b) * (1.0 - (1.0 - const_color[0].a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((secondary_fragment_color.ggg) * (const_color[2].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((rounded_primary_color.aaa) * (const_color[3].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((texcolor1.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 4509A16E04CA7DDB, 57B333648195A2F8
// program: 46DC307C8C5A54D6, AD7922A63ED54CA7, 57B333648195A2F8
// reference: 7F396EB5B60FBFDC, 7F132D830BF35BC2
// reference: E66C16F46DB61E9B, 7F132D830BF35BC2
// program: 7F132D830BF35BC2, AD7922A63ED54CA7, 8A76329CB25030B1
// reference: 56C62592A966B540, CD1237CA557B3805
// reference: CF935DD372DF1407, CD1237CA557B3805
// reference: 33EDD037C332A59E, 8DC7CF5FC18DE470
// reference: AAB8A876188B04D9, 8DC7CF5FC18DE470
// reference: 4509A16E767AA417, 57B333648195A2F8
// reference: D3199A34FB010FCE, EC7233A0BD4CF3D2
// program: EC7233A0BD4CF3D2, 5D764F9A6220D694, 0B496AE87480A30D
// program: EC7233A0BD4CF3D2, 5D764F9A6220D694, ED7F62B87BCBA8C3
// reference: 0A91483BA966B540, CD1237CA557B3805
// reference: 93C4307A72DF1407, CD1237CA557B3805
// reference: CC00F80CC10B6D78, EC7233A0BD4CF3D2
// program: EC7233A0BD4CF3D2, 5D764F9A6220D694, 111FE465C686BF45
// shader: 8B30, 1E54EFAB20B0B715

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((vec3(1.0) - texcolor0.rgb) * (const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((texcolor0.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((texcolor0.rgb) * (const_color[4].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((1.0 - texcolor0.a) * (const_color[4].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: FBFB78E9143B8075, 1E54EFAB20B0B715
// program: EC7233A0BD4CF3D2, 5D764F9A6220D694, 1E54EFAB20B0B715
// program: 0000000000000000, 0000000000000000, C32574EA415A8ECF
// program: 0000000000000000, 0000000000000000, 9984ECD2B5F69CEC
// shader: 8B30, 706EAA05B819222D

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 2584B8EB9162CF31, 706EAA05B819222D
// program: 0000000000000000, 0000000000000000, 706EAA05B819222D
// shader: 8B30, 3EE0A9C0C99022B5

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = 2.0 * (texcolor2).rgb - 1.0;
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(normal, normalize(view))));
refl_value.g = (lut_scale_rg * LookupLightingLUTSigned(5, dot(normal, normalize(view))));
refl_value.b = (lut_scale_rb * LookupLightingLUTSigned(4, dot(normal, normalize(view))));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((secondary_fragment_color.r) * (texcolor2.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor0.rgb) * (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (1.0 - const_color[1].a) + (secondary_fragment_color.b) * (1.0 - (1.0 - const_color[1].a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor1.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((secondary_fragment_color.ggg) * (const_color[3].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((rounded_primary_color.aaa) * (const_color[4].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 6F193B8158D517F8, 3EE0A9C0C99022B5
// program: 46DC307C8C5A54D6, AD7922A63ED54CA7, 3EE0A9C0C99022B5
// shader: 8B30, EC9FE318D844A6A2

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = 2.0 * (texcolor2).rgb - 1.0;
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(normal, normalize(view))));
refl_value.g = (lut_scale_rg * LookupLightingLUTSigned(5, dot(normal, normalize(view))));
refl_value.b = (lut_scale_rb * LookupLightingLUTSigned(4, dot(normal, normalize(view))));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.ggg) * (const_color[0].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((secondary_fragment_color.r) * (texcolor2.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_1 = byteround(clamp((texcolor0.rgb) * (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (1.0 - const_color[1].a) + (secondary_fragment_color.b) * (1.0 - (1.0 - const_color[1].a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((secondary_fragment_color.ggg) * (last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((rounded_primary_color.a) * (1.0 - combiner_buffer.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((texcolor1.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 04F2157F29568E1E, EC9FE318D844A6A2
// program: 46DC307C8C5A54D6, AD7922A63ED54CA7, EC9FE318D844A6A2
// shader: 8B30, 08EDF1F3379D61F4

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = 2.0 * (texcolor2).rgb - 1.0;
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(normal, normalize(view))));
refl_value.g = (lut_scale_rg * LookupLightingLUTSigned(5, dot(normal, normalize(view))));
refl_value.b = (lut_scale_rb * LookupLightingLUTSigned(4, dot(normal, normalize(view))));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((secondary_fragment_color.r) * (1.0 - const_color[0].a) + (secondary_fragment_color.b) * (1.0 - (1.0 - const_color[0].a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((secondary_fragment_color.ggg) * (const_color[2].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((rounded_primary_color.aaa) * (const_color[3].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((texcolor1.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 28D1A5B7509E6034, 08EDF1F3379D61F4
// program: 46DC307C8C5A54D6, AD7922A63ED54CA7, 08EDF1F3379D61F4
// reference: AAB8A876F7B29798, 8DC7CF5FC18DE470
// shader: 8B30, 16123FB0C9519B51

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb) * (vec3(1.0) - texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a) * (1.0 - texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (texcolor0.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (texcolor0.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: B9DE9E0850BE86D8, 16123FB0C9519B51
// program: 0000000000000000, 0000000000000000, 16123FB0C9519B51
// reference: 04F2157F5BE657D2, EC9FE318D844A6A2
// reference: 28D1A5B7222EB9F8, 08EDF1F3379D61F4
// reference: 6F193B812A65CE34, 3EE0A9C0C99022B5
// reference: 6F193B8108667D24, 3EE0A9C0C99022B5
// reference: 3FAA515D58D517F8, 3EE0A9C0C99022B5
// reference: AF1D62B44E8D30C5, 30DAB74CA24CBC58
// reference: AF1D62B4A23ADBC6, 21647988483E7BCD
// shader: 8B31, E3ED63C44CC0E9D6

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;
 out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define mul_safe(x, y) mix(x * y, vec4(0.0), isnan(x * y))

float rcp_safe(float x) {
    if (x == 0.0f) return x;
    return 1.0f / x;
}


float rsq_safe(float x) {
    if (x == 0.0f) return x;
    return inversesqrt(x);
}

#define fma_safe(x, y, z) (mul_safe(x, y) + z)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_4096();
bool sub_7_12();
bool sub_12_21();
bool sub_21_34();
bool sub_34_214();
bool sub_40_146();
bool sub_47_76();
bool sub_58_62();
bool sub_76_135();
bool sub_77_109();
bool sub_88_92();
bool sub_109_134();
bool sub_120_124();
bool sub_144_145();
bool sub_146_213();
bool sub_149_159();
bool sub_159_164();
bool sub_165_177();
bool sub_177_202();
bool sub_178_196();
bool sub_196_201();
bool sub_211_212();
bool sub_214_231();
bool sub_231_307();
bool sub_270_290();
bool sub_271_276();
bool sub_276_289();
bool sub_280_283();
bool sub_283_288();
bool sub_290_303();
bool sub_291_296();
bool sub_296_302();
bool sub_307_330();
bool sub_330_357();
bool sub_332_337();
bool sub_337_356();
bool sub_340_346();
bool sub_346_355();
bool sub_347_351();
bool sub_351_354();
bool sub_357_365();
bool sub_359_360();
bool sub_360_364();
bool sub_361_362();
bool sub_362_363();
bool sub_365_372();
bool sub_372_376();
bool sub_376_400();
bool sub_378_382();
bool sub_382_399();
bool sub_383_397();
bool sub_386_393();
bool sub_393_396();
bool sub_397_398();
bool sub_400_416();
bool sub_402_406();
bool sub_406_415();
bool sub_407_413();
bool sub_413_414();

bool exec_shader() {
    sub_0_4096();
    return true;
}

bool sub_0_4096() {
    // 0: call
    {
        sub_34_214();
    }
    // 1: call
    {
        sub_307_330();
    }
    // 2: call
    {
        sub_330_357();
    }
    // 3: call
    {
        sub_376_400();
    }
    // 4: call
    {
        sub_400_416();
    }
    // 5: end
    return true;
}
bool sub_7_12() {
    // 7: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 8: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 9: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 10: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 11: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    return false;
}
bool sub_12_21() {
    // 12: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 13: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 14: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 15: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 16: dp3
    reg_tmp4.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 17: dp3
    reg_tmp4.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 18: dp3
    reg_tmp4.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 19: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 20: mad
    reg_tmp12 = fma_safe(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_21_34() {
    // 21: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 22: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 23: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 24: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 25: dp3
    reg_tmp4.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 26: dp3
    reg_tmp4.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 27: dp3
    reg_tmp4.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 28: dp3
    reg_tmp5.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 29: dp3
    reg_tmp5.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 30: dp3
    reg_tmp5.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 31: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 32: mad
    reg_tmp12 = fma_safe(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    // 33: mad
    reg_tmp11 = fma_safe(reg_tmp1.wwww, reg_tmp5, reg_tmp11);
    return false;
}
bool sub_34_214() {
    // 34: mul
    reg_tmp15.xyz = (mul_safe(uniforms.f[7].xxxx, vs_in_reg0)).xyz;
    // 35: mul
    reg_tmp14.xyz = (mul_safe(uniforms.f[7].yyyy, vs_in_reg1)).xyz;
    // 36: mul
    reg_tmp13.xyz = (mul_safe(uniforms.f[7].zzzz, vs_in_reg2)).xyz;
    // 37: add
    reg_tmp15.xyz = (uniforms.f[6] + reg_tmp15).xyz;
    // 38: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 39: ifu
    if (uniforms.b[1]) {
        sub_40_146();
    } else {
        sub_146_213();
    }
    // 213: nop
    return false;
}
bool sub_40_146() {
    // 40: mov
    reg_tmp0 = uniforms.f[7];
    // 41: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.yzzz));
    // 42: mov
    reg_tmp7 = uniforms.f[93].xxxx;
    // 43: mov
    reg_tmp12 = uniforms.f[93].xxxx;
    // 44: mov
    reg_tmp11 = uniforms.f[93].xxxx;
    // 45: mul
    reg_tmp2 = mul_safe(uniforms.f[93].wwww, vs_in_reg7);
    // 46: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_47_76();
    } else {
        sub_76_135();
    }
    // 135: mov
    vs_out_attr2 = -reg_tmp15;
    // 136: dp4
    reg_tmp0.x = dot(mul_safe(uniforms.f[86], reg_tmp15), vec4(1.0));
    // 137: dp4
    reg_tmp0.y = dot(mul_safe(uniforms.f[87], reg_tmp15), vec4(1.0));
    // 138: dp4
    reg_tmp0.z = dot(mul_safe(uniforms.f[88], reg_tmp15), vec4(1.0));
    // 139: dp4
    reg_tmp0.w = dot(mul_safe(uniforms.f[89], reg_tmp15), vec4(1.0));
    // 140: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 141: mul
    reg_tmp1.y = (mul_safe(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
    // 142: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 143: ifc
    if (all(conditional_code)) {
        sub_144_145();
    }
    // 145: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_47_76() {
    // 47: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 48: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 49: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 50: call
    {
        sub_12_21();
    }
    // 51: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 52: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 53: call
    {
        sub_12_21();
    }
    // 54: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 55: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 56: callc
    if (conditional_code.x) {
        sub_12_21();
    }
    // 57: ifu
    if (uniforms.b[8]) {
        sub_58_62();
    }
    // 62: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 63: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 64: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 65: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 66: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 67: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 68: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 69: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 70: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 71: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 72: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 73: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 74: call
    {
        sub_214_231();
    }
    // 75: nop
    return false;
}
bool sub_58_62() {
    // 58: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 59: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 60: callc
    if (conditional_code.y) {
        sub_12_21();
    }
    // 61: nop
    return false;
}
bool sub_76_135() {
    // 76: ifc
    if (all(conditional_code)) {
        sub_77_109();
    } else {
        sub_109_134();
    }
    // 134: nop
    return false;
}
bool sub_77_109() {
    // 77: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 78: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 79: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 80: call
    {
        sub_21_34();
    }
    // 81: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 82: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 83: call
    {
        sub_21_34();
    }
    // 84: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 85: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 86: callc
    if (conditional_code.x) {
        sub_21_34();
    }
    // 87: ifu
    if (uniforms.b[8]) {
        sub_88_92();
    }
    // 92: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 93: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 94: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 95: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 96: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 97: dp3
    reg_tmp13.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp11)), vec3(1.0));
    // 98: dp3
    reg_tmp13.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp11)), vec3(1.0));
    // 99: dp3
    reg_tmp13.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp11)), vec3(1.0));
    // 100: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 101: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 102: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 103: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 104: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 105: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 106: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 107: call
    {
        sub_231_307();
    }
    // 108: nop
    return false;
}
bool sub_88_92() {
    // 88: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 89: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 90: callc
    if (conditional_code.y) {
        sub_21_34();
    }
    // 91: nop
    return false;
}
bool sub_109_134() {
    // 109: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 110: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 111: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 112: call
    {
        sub_7_12();
    }
    // 113: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 114: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 115: call
    {
        sub_7_12();
    }
    // 116: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 117: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 118: callc
    if (conditional_code.x) {
        sub_7_12();
    }
    // 119: ifu
    if (uniforms.b[8]) {
        sub_120_124();
    }
    // 124: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 125: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 126: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 127: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 128: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 129: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 130: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 131: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 132: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 133: mov
    vs_out_attr1 = uniforms.f[93].xxxx;
    return false;
}
bool sub_120_124() {
    // 120: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 121: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 122: callc
    if (conditional_code.y) {
        sub_7_12();
    }
    // 123: nop
    return false;
}
bool sub_144_145() {
    // 144: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_146_213() {
    // 146: mov
    reg_tmp0 = uniforms.f[7];
    // 147: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.yzzz));
    // 148: ifu
    if (uniforms.b[2]) {
        sub_149_159();
    } else {
        sub_159_164();
    }
    // 164: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_165_177();
    } else {
        sub_177_202();
    }
    // 202: mov
    vs_out_attr2 = -reg_tmp15;
    // 203: dp4
    reg_tmp0.x = dot(mul_safe(uniforms.f[86], reg_tmp15), vec4(1.0));
    // 204: dp4
    reg_tmp0.y = dot(mul_safe(uniforms.f[87], reg_tmp15), vec4(1.0));
    // 205: dp4
    reg_tmp0.z = dot(mul_safe(uniforms.f[88], reg_tmp15), vec4(1.0));
    // 206: dp4
    reg_tmp0.w = dot(mul_safe(uniforms.f[89], reg_tmp15), vec4(1.0));
    // 207: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 208: mul
    reg_tmp1.y = (mul_safe(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
    // 209: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 210: ifc
    if (all(conditional_code)) {
        sub_211_212();
    }
    // 212: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_149_159() {
    // 149: mul
    reg_tmp1.x = (mul_safe(uniforms.f[93].wwww, vs_in_reg7.xxxx)).x;
    // 150: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 151: dp4
    reg_tmp7.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 152: dp4
    reg_tmp7.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 153: dp4
    reg_tmp7.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 154: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 155: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 156: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 157: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 158: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_159_164() {
    // 159: mova
    address_registers.x = (ivec2(uniforms.f[93].xxxx)).x;
    // 160: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[25], reg_tmp15), vec4(1.0));
    // 161: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[26], reg_tmp15), vec4(1.0));
    // 162: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[27], reg_tmp15), vec4(1.0));
    // 163: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_165_177() {
    // 165: dp3
    reg_tmp12.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 166: dp3
    reg_tmp12.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 167: dp3
    reg_tmp12.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 168: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 169: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 170: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 171: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 172: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 173: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 174: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 175: call
    {
        sub_214_231();
    }
    // 176: nop
    return false;
}
bool sub_177_202() {
    // 177: ifc
    if (all(conditional_code)) {
        sub_178_196();
    } else {
        sub_196_201();
    }
    // 201: nop
    return false;
}
bool sub_178_196() {
    // 178: dp3
    reg_tmp12.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 179: dp3
    reg_tmp12.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 180: dp3
    reg_tmp12.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 181: dp3
    reg_tmp11.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 182: dp3
    reg_tmp11.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 183: dp3
    reg_tmp11.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 184: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 185: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 186: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 187: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 188: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 189: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 190: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 191: dp3
    reg_tmp13.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp11)), vec3(1.0));
    // 192: dp3
    reg_tmp13.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp11)), vec3(1.0));
    // 193: dp3
    reg_tmp13.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp11)), vec3(1.0));
    // 194: call
    {
        sub_231_307();
    }
    // 195: nop
    return false;
}
bool sub_196_201() {
    // 196: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 197: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 198: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 199: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 200: mov
    vs_out_attr1 = uniforms.f[93].xxxx;
    return false;
}
bool sub_211_212() {
    // 211: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_214_231() {
    uint jmp_to = 214u;
    while (true) {
        switch (jmp_to) {
        case 214u: {
            // 214: dp3
            reg_tmp6.x = dot(vec3(mul_safe(reg_tmp14, reg_tmp14)), vec3(1.0));
            // 215: dp3
            reg_tmp7.x = dot(vec3(mul_safe(reg_tmp12, reg_tmp12)), vec3(1.0));
            // 216: rsq
            reg_tmp6.x = rsq_safe(reg_tmp6.xxxx.x);
            // 217: rsq
            reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
            // 218: mul
            reg_tmp14.xyz = (mul_safe(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 219: mul
            reg_tmp12.xyz = (mul_safe(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 220: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 221: jmpu
            if (!uniforms.b[15]) {
                { jmp_to = 230u; break; }
            }
            // 222: add
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            // 223: mul
            reg_tmp4 = mul_safe(uniforms.f[94].zzzz, reg_tmp4);
            // 224: cmp
            conditional_code = greaterThanEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp4.xxxx));
            // 225: rsq
            reg_tmp4 = vec4(rsq_safe(reg_tmp4.xxxx.x));
            // 226: mul
            reg_tmp5 = mul_safe(uniforms.f[94].zzzz, reg_tmp14);
            // 227: jmpc
            if (conditional_code.x) {
                { jmp_to = 230u; break; }
            }
            // 228: rcp
            reg_tmp0.z = rcp_safe(reg_tmp4.xxxx.x);
            // 229: mul
            reg_tmp0.xy = (mul_safe(reg_tmp5, reg_tmp4)).xy;
        }
        case 230u: {
            // 230: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_231_307() {
    uint jmp_to = 231u;
    while (true) {
        switch (jmp_to) {
        case 231u: {
            // 231: dp3
            reg_tmp6.x = dot(vec3(mul_safe(reg_tmp14, reg_tmp14)), vec3(1.0));
            // 232: dp3
            reg_tmp7.x = dot(vec3(mul_safe(reg_tmp12, reg_tmp12)), vec3(1.0));
            // 233: rsq
            reg_tmp6.x = rsq_safe(reg_tmp6.xxxx.x);
            // 234: rsq
            reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
            // 235: mul
            reg_tmp14.xyz = (mul_safe(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 236: mul
            reg_tmp12.xyz = (mul_safe(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 237: mul
            reg_tmp13.xyz = (mul_safe(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            // 238: mul
            reg_tmp11.xyz = (mul_safe(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            // 239: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 240: jmpu
            if (!uniforms.b[15]) {
                { jmp_to = 306u; break; }
            }
            // 241: mul
            reg_tmp13.xyz = (mul_safe(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            // 242: mul
            reg_tmp11.xyz = (mul_safe(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            // 243: mul
            reg_tmp5 = mul_safe(reg_tmp14.yzxx, reg_tmp13.zxyy);
            // 244: mad
            reg_tmp5 = fma_safe(-reg_tmp13.yzxx, reg_tmp14.zxyy, reg_tmp5);
            // 245: dp3
            reg_tmp5.w = dot(vec3(mul_safe(reg_tmp5, reg_tmp5)), vec3(1.0));
            // 246: rsq
            reg_tmp5.w = rsq_safe(reg_tmp5.wwww.x);
            // 247: mul
            reg_tmp5 = mul_safe(reg_tmp5, reg_tmp5.wwww);
            // 248: add
            reg_tmp6.w = (reg_tmp14.zzzz + reg_tmp5.yyyy).w;
            // 249: mul
            reg_tmp13 = mul_safe(reg_tmp5.yzxx, reg_tmp14.zxyy);
            // 250: mad
            reg_tmp13 = fma_safe(-reg_tmp14.yzxx, reg_tmp5.zxyy, reg_tmp13);
            // 251: add
            reg_tmp6.w = (reg_tmp13.xxxx + reg_tmp6).w;
            // 252: mov
            reg_tmp13.w = (reg_tmp5.zzzz).w;
            // 253: mov
            reg_tmp5.z = (reg_tmp13.xxxx).z;
            // 254: add
            reg_tmp6.w = (uniforms.f[93].yyyy + reg_tmp6).w;
            // 255: mov
            reg_tmp14.w = (reg_tmp5.xxxx).w;
            // 256: mov
            reg_tmp5.x = (reg_tmp14.zzzz).x;
            // 257: cmp
            conditional_code = lessThan(vec2(uniforms.f[94].yyyy), vec2(reg_tmp6.wwww));
            // 258: mov
            reg_tmp6.x = (uniforms.f[93].yyyy).x;
            // 259: mov
            reg_tmp6.y = (-uniforms.f[93].yyyy).y;
            // 260: jmpc
            if (!conditional_code.x) {
                { jmp_to = 268u; break; }
            }
            // 261: add
            reg_tmp7.xz = (reg_tmp13.wwyy + -reg_tmp14.yyww).xz;
            // 262: add
            reg_tmp7.y = (reg_tmp14.xxxx + -reg_tmp13.zzzz).y;
            // 263: mov
            reg_tmp7.w = (reg_tmp6).w;
            // 264: dp4
            reg_tmp6 = vec4(dot(mul_safe(reg_tmp7, reg_tmp7), vec4(1.0)));
            // 265: rsq
            reg_tmp6 = vec4(rsq_safe(reg_tmp6.xxxx.x));
            // 266: mul
            reg_tmp0 = mul_safe(reg_tmp7, reg_tmp6);
            // 267: jmpu
            if (uniforms.b[0]) {
                { jmp_to = 306u; break; }
            }
        }
        case 268u: {
            // 268: cmp
            conditional_code = greaterThan(vec2(reg_tmp5.zyyy), vec2(reg_tmp5.yxxx));
            // 269: ifc
            if (conditional_code.x) {
                sub_270_290();
            } else {
                sub_290_303();
            }
            // 303: dp4
            reg_tmp6 = vec4(dot(mul_safe(reg_tmp8, reg_tmp8), vec4(1.0)));
            // 304: rsq
            reg_tmp6 = vec4(rsq_safe(reg_tmp6.xxxx.x));
            // 305: mul
            reg_tmp0 = mul_safe(reg_tmp8, reg_tmp6);
        }
        case 306u: {
            // 306: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_270_290() {
    // 270: ifc
    if (conditional_code.y) {
        sub_271_276();
    } else {
        sub_276_289();
    }
    // 289: mov
    reg_tmp8.w = (-reg_tmp8).w;
    return false;
}
bool sub_271_276() {
    // 271: mul
    reg_tmp8 = mul_safe(reg_tmp13.yyzw, reg_tmp6.xxxy);
    // 272: add
    reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
    // 273: add
    reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
    // 274: add
    reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
    // 275: add
    reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
    return false;
}
bool sub_276_289() {
    // 276: cmp
    conditional_code = greaterThan(vec2(reg_tmp5.zzzz), vec2(reg_tmp5.xxxx));
    // 277: mul
    reg_tmp8 = mul_safe(reg_tmp13.yyzw, reg_tmp6.xxxy);
    // 278: add
    reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
    // 279: ifc
    if (conditional_code.x) {
        sub_280_283();
    } else {
        sub_283_288();
    }
    // 288: nop
    return false;
}
bool sub_280_283() {
    // 280: add
    reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
    // 281: add
    reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
    // 282: add
    reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
    return false;
}
bool sub_283_288() {
    // 283: mul
    reg_tmp8 = mul_safe(reg_tmp13.zwwy, reg_tmp6.xxxy);
    // 284: add
    reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
    // 285: add
    reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
    // 286: add
    reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
    // 287: add
    reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
    return false;
}
bool sub_290_303() {
    // 290: ifc
    if (conditional_code.y) {
        sub_291_296();
    } else {
        sub_296_302();
    }
    // 302: nop
    return false;
}
bool sub_291_296() {
    // 291: mul
    reg_tmp8 = mul_safe(reg_tmp13.yywz, reg_tmp6.xxxy);
    // 292: add
    reg_tmp8.y = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).y;
    // 293: add
    reg_tmp9 = reg_tmp5.yyyy + -reg_tmp5.xxxx;
    // 294: add
    reg_tmp8.xzw = (reg_tmp8 + reg_tmp14.wwyx).xzw;
    // 295: add
    reg_tmp8.y = (reg_tmp9 + reg_tmp8).y;
    return false;
}
bool sub_296_302() {
    // 296: mul
    reg_tmp8 = mul_safe(reg_tmp13.zwwy, reg_tmp6.xxxy);
    // 297: add
    reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
    // 298: add
    reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
    // 299: add
    reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
    // 300: add
    reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
    // 301: mov
    reg_tmp8.w = (-reg_tmp8).w;
    return false;
}
bool sub_307_330() {
    // 307: mov
    reg_tmp1.xyz = (uniforms.f[93].xxyx).xyz;
    // 308: dp3
    reg_tmp8.x = dot(vec3(mul_safe(uniforms.f[0], reg_tmp12.xyzz)), vec3(1.0));
    // 309: dp3
    reg_tmp8.y = dot(vec3(mul_safe(uniforms.f[1], reg_tmp12.xyzz)), vec3(1.0));
    // 310: dp3
    reg_tmp8.z = dot(vec3(mul_safe(uniforms.f[2], reg_tmp12.xyzz)), vec3(1.0));
    // 311: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[90], reg_tmp8.xyzz)), vec3(1.0));
    // 312: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[91], reg_tmp8.xyzz)), vec3(1.0));
    // 313: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[92], reg_tmp8.xyzz)), vec3(1.0));
    // 314: mov
    reg_tmp14.w = (uniforms.f[93].xxxx).w;
    // 315: mov
    reg_tmp8 = reg_tmp14;
    // 316: dp4
    reg_tmp14.x = dot(mul_safe(reg_tmp8, reg_tmp8), vec4(1.0));
    // 317: rsq
    reg_tmp14.x = rsq_safe(reg_tmp14.xxxx.x);
    // 318: mul
    reg_tmp14 = mul_safe(reg_tmp8, reg_tmp14.xxxx);
    // 319: dp3
    reg_tmp9.x = dot(vec3(mul_safe(reg_tmp14, reg_tmp1)), vec3(1.0));
    // 320: max
    reg_tmp9.x = (max(uniforms.f[93].xxxx, reg_tmp9.xxxx)).x;
    // 321: min
    reg_tmp9.x = (min(uniforms.f[93].yyyy, reg_tmp9.xxxx)).x;
    // 322: add
    reg_tmp9.x = (uniforms.f[93].yyyy + -reg_tmp9.xxxx).x;
    // 323: log
    reg_tmp9.x = log2(reg_tmp9.xxxx.x);
    // 324: mul
    reg_tmp9.x = (mul_safe(uniforms.f[85].xxxx, reg_tmp9.xxxx)).x;
    // 325: exp
    reg_tmp9.x = exp2(reg_tmp9.xxxx.x);
    // 326: mul
    reg_tmp2.w = (mul_safe(uniforms.f[85].yyyy, reg_tmp9.xxxx)).w;
    // 327: mul
    reg_tmp0 = mul_safe(uniforms.f[7].wwww, vs_in_reg3);
    // 328: mul
    reg_tmp2.xyz = (mul_safe(uniforms.f[20].wwww, reg_tmp0.xyzz)).xyz;
    // 329: mov
    vs_out_attr3 = reg_tmp2;
    return false;
}
bool sub_330_357() {
    // 330: mov
    reg_tmp0.xy = (uniforms.f[10].xxxx).xy;
    // 331: ifu
    if (uniforms.b[9]) {
        sub_332_337();
    } else {
        sub_337_356();
    }
    // 356: nop
    return false;
}
bool sub_332_337() {
    // 332: call
    {
        sub_357_365();
    }
    // 333: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[11].xywz, reg_tmp6), vec4(1.0));
    // 334: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[12].xywz, reg_tmp6), vec4(1.0));
    // 335: mov
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    // 336: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_337_356() {
    // 337: cmp
    conditional_code = equal(vec2(uniforms.f[95].xyyy), vec2(reg_tmp0.xyyy));
    // 338: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 339: ifc
    if (all(not(conditional_code))) {
        sub_340_346();
    } else {
        sub_346_355();
    }
    // 355: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_340_346() {
    // 340: mov
    reg_tmp6 = reg_tmp10;
    // 341: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[11], reg_tmp6), vec4(1.0));
    // 342: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[12], reg_tmp6), vec4(1.0));
    // 343: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[13], reg_tmp6), vec4(1.0));
    // 344: mul
    reg_tmp0.xy = (mul_safe(uniforms.f[19].xyyy, reg_tmp3.zzzz)).xy;
    // 345: add
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_346_355() {
    // 346: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_347_351();
    } else {
        sub_351_354();
    }
    // 354: nop
    return false;
}
bool sub_347_351() {
    // 347: call
    {
        sub_365_372();
    }
    // 348: dp3
    reg_tmp3.x = dot(vec3(mul_safe(uniforms.f[11], reg_tmp6)), vec3(1.0));
    // 349: dp3
    reg_tmp3.y = dot(vec3(mul_safe(uniforms.f[12], reg_tmp6)), vec3(1.0));
    // 350: dp3
    reg_tmp3.z = dot(vec3(mul_safe(uniforms.f[13], reg_tmp6)), vec3(1.0));
    return false;
}
bool sub_351_354() {
    // 351: call
    {
        sub_372_376();
    }
    // 352: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[11], reg_tmp6), vec4(1.0));
    // 353: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[12], reg_tmp6), vec4(1.0));
    return false;
}
bool sub_357_365() {
    // 357: cmp
    conditional_code = equal(vec2(uniforms.f[93].yzzz), vec2(reg_tmp0.xyyy));
    // 358: ifc
    if (all(not(conditional_code))) {
        sub_359_360();
    } else {
        sub_360_364();
    }
    // 364: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_359_360() {
    // 359: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
    return false;
}
bool sub_360_364() {
    // 360: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_361_362();
    } else {
        sub_362_363();
    }
    // 363: nop
    return false;
}
bool sub_361_362() {
    // 361: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
    return false;
}
bool sub_362_363() {
    // 362: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
    return false;
}
bool sub_365_372() {
    // 365: mov
    reg_tmp2 = -reg_tmp15;
    // 366: dp3
    reg_tmp2.w = dot(vec3(mul_safe(reg_tmp2, reg_tmp2)), vec3(1.0));
    // 367: rsq
    reg_tmp2.w = rsq_safe(reg_tmp2.wwww.x);
    // 368: mul
    reg_tmp2 = mul_safe(reg_tmp2, reg_tmp2.wwww);
    // 369: dp3
    reg_tmp1 = vec4(dot(vec3(mul_safe(reg_tmp2, reg_tmp14)), vec3(1.0)));
    // 370: add
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    // 371: mad
    reg_tmp6 = fma_safe(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_372_376() {
    // 372: mov
    reg_tmp1.xy = (uniforms.f[94].zzzz).xy;
    // 373: mov
    reg_tmp1.zw = (uniforms.f[93].xxxx).zw;
    // 374: mad
    reg_tmp6 = fma_safe(reg_tmp14, reg_tmp1, reg_tmp1);
    // 375: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_376_400() {
    // 376: mov
    reg_tmp0.xy = (uniforms.f[10].yyyy).xy;
    // 377: ifu
    if (uniforms.b[10]) {
        sub_378_382();
    } else {
        sub_382_399();
    }
    // 399: nop
    return false;
}
bool sub_378_382() {
    // 378: call
    {
        sub_357_365();
    }
    // 379: dp4
    reg_tmp4.x = dot(mul_safe(uniforms.f[14].xywz, reg_tmp6), vec4(1.0));
    // 380: dp4
    reg_tmp4.y = dot(mul_safe(uniforms.f[15].xywz, reg_tmp6), vec4(1.0));
    // 381: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_382_399() {
    // 382: ifu
    if (uniforms.b[13]) {
        sub_383_397();
    } else {
        sub_397_398();
    }
    // 398: nop
    return false;
}
bool sub_383_397() {
    // 383: cmp
    conditional_code = equal(vec2(uniforms.f[95].xyyy), vec2(reg_tmp0.xyyy));
    // 384: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 385: ifc
    if (all(not(conditional_code))) {
        sub_386_393();
    } else {
        sub_393_396();
    }
    // 396: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_386_393() {
    // 386: mov
    reg_tmp6 = reg_tmp10;
    // 387: dp4
    reg_tmp4.x = dot(mul_safe(uniforms.f[14], reg_tmp6), vec4(1.0));
    // 388: dp4
    reg_tmp4.y = dot(mul_safe(uniforms.f[15], reg_tmp6), vec4(1.0));
    // 389: dp4
    reg_tmp4.z = dot(mul_safe(uniforms.f[16], reg_tmp6), vec4(1.0));
    // 390: rcp
    reg_tmp6.w = rcp_safe(reg_tmp4.zzzz.x);
    // 391: mul
    reg_tmp4.xy = (mul_safe(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    // 392: add
    reg_tmp4.xy = (uniforms.f[19].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_393_396() {
    // 393: call
    {
        sub_372_376();
    }
    // 394: dp4
    reg_tmp4.x = dot(mul_safe(uniforms.f[14], reg_tmp6), vec4(1.0));
    // 395: dp4
    reg_tmp4.y = dot(mul_safe(uniforms.f[15], reg_tmp6), vec4(1.0));
    return false;
}
bool sub_397_398() {
    // 397: mov
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_400_416() {
    // 400: mov
    reg_tmp0.xy = (uniforms.f[10].zzzz).xy;
    // 401: ifu
    if (uniforms.b[11]) {
        sub_402_406();
    } else {
        sub_406_415();
    }
    // 415: nop
    return false;
}
bool sub_402_406() {
    // 402: call
    {
        sub_357_365();
    }
    // 403: dp4
    reg_tmp5.x = dot(mul_safe(uniforms.f[17].xywz, reg_tmp6), vec4(1.0));
    // 404: dp4
    reg_tmp5.y = dot(mul_safe(uniforms.f[18].xywz, reg_tmp6), vec4(1.0));
    // 405: mov
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_406_415() {
    // 406: ifu
    if (uniforms.b[14]) {
        sub_407_413();
    } else {
        sub_413_414();
    }
    // 414: nop
    return false;
}
bool sub_407_413() {
    // 407: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 408: mov
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    // 409: call
    {
        sub_372_376();
    }
    // 410: dp4
    reg_tmp5.x = dot(mul_safe(uniforms.f[17], reg_tmp6), vec4(1.0));
    // 411: dp4
    reg_tmp5.y = dot(mul_safe(uniforms.f[18], reg_tmp6), vec4(1.0));
    // 412: mov
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_413_414() {
    // 413: mov
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
// reference: 919F47DF7B328E3E, E3ED63C44CC0E9D6
// shader: 8B30, 159CC93A09C7B2EA

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((secondary_fragment_color.r) * (1.0 - const_color[0].a) + (secondary_fragment_color.b) * (1.0 - (1.0 - const_color[0].a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((secondary_fragment_color.ggg) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) - (texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: CD6AB9D74CF4C0E6, 159CC93A09C7B2EA
// program: E3ED63C44CC0E9D6, AD7922A63ED54CA7, 159CC93A09C7B2EA
// reference: 6442016CF4BA8BE8, 7F132D830BF35BC2
// reference: 51378DAC620D9ABD, EC7233A0BD4CF3D2
// reference: FD17792D2F032AAF, 7F132D830BF35BC2
// reference: C862F5EDB9B43BFA, EC7233A0BD4CF3D2
// reference: 93AF4DE751FE34FF, BAF5CB3693892DB3
// reference: 0AFA35A68A4795B8, BAF5CB3693892DB3
// reference: 6939A9C93F60645E, B582B9861A22E219
// reference: 3D19834361223CCA, BAF5CB3693892DB3
// reference: 925D1104A0A480E8, 3DBC6131A77F0199
// reference: 925D11044F9D13A9, 3DBC6131A77F0199
// reference: 3D1983438E1BAF8B, BAF5CB3693892DB3
// reference: 40801A5EEC17410A, 7F132D830BF35BC2
// reference: D9D5621F37AEE04D, 7F132D830BF35BC2
// reference: A44CFB02BA9B9D8D, BAF5CB3693892DB3
// reference: 8866A198631B8AD4, 1E6C0649B5CE7F1C
// reference: 3604ADEA421203AB, BAF5CB3693892DB3
// reference: D6511F0CF8B2E106, EC7233A0BD4CF3D2
// reference: 4F04674D230B4041, EC7233A0BD4CF3D2
// reference: AF51D5AB99ABA2EC, BAF5CB3693892DB3
// reference: 7A34FA3E3F60645E, B582B9861A22E219
// reference: 2E14D0B461223CCA, BAF5CB3693892DB3
// reference: 815042F3A0A480E8, 3DBC6131A77F0199
// reference: 815042F34F9D13A9, 3DBC6131A77F0199
// reference: 2E14D0B48E1BAF8B, BAF5CB3693892DB3
// reference: 538D49A9EC17410A, 7F132D830BF35BC2
// reference: CAD831E837AEE04D, 7F132D830BF35BC2
// reference: B741A8F5BA9B9D8D, BAF5CB3693892DB3
// reference: E8404B4653CB987D, 7F132D830BF35BC2
// reference: 4460BFC71EC5286F, EC7233A0BD4CF3D2
// reference: DD35C786C57C8928, EC7233A0BD4CF3D2
// shader: 8B30, 7AD3F373FABCFCCC

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((vec3(1.0) - texcolor0.rrr) - (vec3(1.0) - texcolor1.rrr), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((1.0 - texcolor0.r) - (1.0 - texcolor2.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0 * 4.0, alpha_output_0 * 4.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) + (last_tex_env_out.aaa), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1 * 4.0, alpha_output_1 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2 * 4.0, alpha_output_2 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb) * (vec3(1.0) - texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a) * (1.0 - texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (texcolor0.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (texcolor0.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (const_color[5].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: DF03A27A8EF68BCD, 7AD3F373FABCFCCC
// program: EC7233A0BD4CF3D2, 5D764F9A6220D694, 7AD3F373FABCFCCC
// reference: AD9B1DD84FBF7E88, AA5284D8354BC7F4
// program: AA5284D8354BC7F4, 3B3AE026C742C7D5, 964E0B11E50F8F6E
// reference: 34CE65999406DFCF, AA5284D8354BC7F4
// program: AA5284D8354BC7F4, 3B3AE026C742C7D5, 09998F9B86E3CF69
// reference: 34CE6599BA47877B, CD1237CA557B3805
// reference: 22266F0D001D2106, E3ED63C44CC0E9D6
// reference: 09490F95CF5CE496, CB541D02F0C32C04
// program: E3ED63C44CC0E9D6, AD7922A63ED54CA7, CB541D02F0C32C04
// reference: BB73174CDBA48041, E3ED63C44CC0E9D6
// reference: D7FB29BE8F9524D0, 7F132D830BF35BC2
// reference: 4EAE51FF542C8597, 7F132D830BF35BC2
// reference: 7BDBDD3FC29B94C2, EC7233A0BD4CF3D2
// reference: E28EA57E19223585, EC7233A0BD4CF3D2
// reference: DE73E8BC83C3598D, AA5284D8354BC7F4
// reference: 472690FD587AF8CA, AA5284D8354BC7F4
// reference: 472690FD763BA07E, CD1237CA557B3805
// program: 0000000000000000, 0000000000000000, CE59663341BA1DD1
// reference: B9431D74F1683A80, BAF5CB3693892DB3
// reference: 201665352AD19BC7, BAF5CB3693892DB3
// reference: 43D5F95A3F60645E, B582B9861A22E219
// reference: 17F5D3D061223CCA, BAF5CB3693892DB3
// reference: B8B14197A0A480E8, 3DBC6131A77F0199
// reference: B8B141974F9D13A9, 3DBC6131A77F0199
// reference: 17F5D3D08E1BAF8B, BAF5CB3693892DB3
// reference: 6A6C4ACDEC17410A, 7F132D830BF35BC2
// reference: F339328C37AEE04D, 7F132D830BF35BC2
// reference: 8EA0AB91BA9B9D8D, BAF5CB3693892DB3
// shader: 8B30, DF978ABC1D359C32

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((vec3(1.0) - rounded_primary_color.aaa) + (const_color[0].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) + (vec3(1.0) - const_color[1].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((texcolor0.rgb) * (const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((texcolor0.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((vec3(1.0) - texcolor0.rgb) * (const_color[4].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((1.0 - texcolor0.a) * (const_color[4].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 4B148645FCAF78A7, DF978ABC1D359C32
// program: EC7233A0BD4CF3D2, 5D764F9A6220D694, DF978ABC1D359C32
// program: 0000000000000000, 0000000000000000, DF833937D545E7DC
// shader: 8B30, F90F36F349A28A5E

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) + (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: C1704DED6E8A1DC4, F90F36F349A28A5E
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, F90F36F349A28A5E
// shader: 8B30, 1AC956BC78CD8544

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: F578F6D19604B05E, 1AC956BC78CD8544
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, 1AC956BC78CD8544
// reference: CD5EDB40C2B4E87E, 5746FEF0B06D455B
// program: 5746FEF0B06D455B, AD7922A63ED54CA7, 84E276AEB008DB5C
// reference: 540BA301190D4939, 5746FEF0B06D455B
// reference: 851BBB8A62EF942B, 7F132D830BF35BC2
// reference: 1C4EC3CBB956356C, 7F132D830BF35BC2
// reference: B06E374AF458857E, EC7233A0BD4CF3D2
// reference: 293B4F0B2FE12439, EC7233A0BD4CF3D2
// reference: 86B7E38177837E3E, BAF5CB3693892DB3
// reference: 1FE29BC0AC3ADF79, BAF5CB3693892DB3
// reference: 77AFC262A7A2BD8D, EC7233A0BD4CF3D2
// shader: 8B30, 58DB914D1940631D

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (const_color[1].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb) * (vec3(1.0) - texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a) * (1.0 - texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (texcolor0.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (texcolor0.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: BC5BDA720F0C5DC1, 58DB914D1940631D
// program: EC7233A0BD4CF3D2, 5D764F9A6220D694, 58DB914D1940631D
// reference: EEFABA237C1B1CCA, EC7233A0BD4CF3D2
// shader: 8B30, 722CDC50CE857702

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (const_color[1].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((vec3(1.0) - texcolor0.rgb) * (const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((texcolor0.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((texcolor0.rgb) * (const_color[4].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((1.0 - texcolor0.a) * (const_color[4].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 73C33E8D8EF34B7B, 722CDC50CE857702
// program: EC7233A0BD4CF3D2, 5D764F9A6220D694, 722CDC50CE857702
// shader: 8B30, DF14E6A17A7479BD

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (const_color[1].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb) * (vec3(1.0) - texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a) * (1.0 - texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (texcolor0.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (texcolor0.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 31E6D86CCA764DD6, DF14E6A17A7479BD
// program: 0000000000000000, 0000000000000000, DF14E6A17A7479BD
// program: EC7233A0BD4CF3D2, 5D764F9A6220D694, 81D5ADAAF3D0CA91
// reference: 8FCE5170AB0A2E59, CD1237CA557B3805
// reference: 169B293170B38F1E, CD1237CA557B3805
// program: 46DC307C8C5A54D6, AD7922A63ED54CA7, 1C819725D7DBB6AB
// program: 46DC307C8C5A54D6, AD7922A63ED54CA7, F67CD9340BD8A6A9
// reference: 4A4CE27520B8AE89, EC7233A0BD4CF3D2
// program: 46DC307C8C5A54D6, AD7922A63ED54CA7, 615732319A39ACDD
// reference: D3199A349FE17430, BF583C1F84D94483
// program: BF583C1F84D94483, 5D764F9A6220D694, 0B496AE87480A30D
// program: BF583C1F84D94483, 5D764F9A6220D694, ED7F62B87BCBA8C3
// reference: 4A4CE2754458D577, BF583C1F84D94483
// program: BF583C1F84D94483, 5D764F9A6220D694, 7AD3F373FABCFCCC
// reference: 56C62592CD86CEBE, B354DE6BBBEF83CA
// program: B354DE6BBBEF83CA, 3B3AE026C742C7D5, 2BB9C8FEDE51C537
// reference: CF935DD3163F6FF9, B354DE6BBBEF83CA
// program: B354DE6BBBEF83CA, 3B3AE026C742C7D5, CCCAFDE548B6C210
// program: B354DE6BBBEF83CA, 3B3AE026C742C7D5, 73E202FB36B8AAFC
// reference: B4A87EE3393C4EEC, BEF53C1FB1E1CFF4
// program: BEF53C1FB1E1CFF4, AD7922A63ED54CA7, 3E5CAFDBABD516C0
// reference: 2DFD06A20DBC7CEA, BEF53C1FB1E1CFF4
// program: BEF53C1FB1E1CFF4, AD7922A63ED54CA7, E14D0525B6AB8EC9
// program: BEF53C1FB1E1CFF4, AD7922A63ED54CA7, CCB52BD33F912CFA
// program: BEF53C1FB1E1CFF4, AD7922A63ED54CA7, 615732319A39ACDD
// reference: 7F396EB5D2EFC422, 76204850D3D31438
// program: 76204850D3D31438, AD7922A63ED54CA7, D375021927AD9455
// reference: E66C16F409566565, 76204850D3D31438
// program: 76204850D3D31438, AD7922A63ED54CA7, 8A76329CB25030B1
// program: 76204850D3D31438, AD7922A63ED54CA7, FB2B5B4178346715
// reference: 460C959CDBC50B53, 4EFF2C77DB8F9E73
// program: 4EFF2C77DB8F9E73, 3B3AE026C742C7D5, 4AD2C97240195A76
// reference: DF59EDDD007CAA14, 4EFF2C77DB8F9E73
// program: 4EFF2C77DB8F9E73, 3B3AE026C742C7D5, 666154B1BFC0A909
// program: 4EFF2C77DB8F9E73, 3B3AE026C742C7D5, C27F787C261C6045
// program: 4EFF2C77DB8F9E73, 3B3AE026C742C7D5, 82B30867377518C0
// program: 4EFF2C77DB8F9E73, 3B3AE026C742C7D5, C74CA00DB8E95117
// reference: 7D7B480AC426C1E1, E661110CC0BF42D1
// program: E661110CC0BF42D1, 3B3AE026C742C7D5, 85967F14F07719A7
// reference: 295B62809A649975, 4EFF2C77DB8F9E73
// program: 4EFF2C77DB8F9E73, 3B3AE026C742C7D5, FEB1E39313EC6A3F
// program: 4EFF2C77DB8F9E73, 3B3AE026C742C7D5, AB9CD65F41BDEFA0
// program: 4EFF2C77DB8F9E73, 3B3AE026C742C7D5, B29EF1BFC4D10886
// program: 4EFF2C77DB8F9E73, 3B3AE026C742C7D5, 98677AC22B9A3E1A
// program: 4EFF2C77DB8F9E73, 3B3AE026C742C7D5, 92F4F0B0E6943599
// program: E661110CC0BF42D1, 3B3AE026C742C7D5, 18CD6F34EF819318
// program: 4EFF2C77DB8F9E73, 3B3AE026C742C7D5, 06A8A4F9432C9B26
// reference: 861FF0C75BE22557, 17716008BB716A8F
// program: 17716008BB716A8F, AD7922A63ED54CA7, E2B05A5EEE3BCE11
// reference: 861FF0C7B4DBB616, 17716008BB716A8F
// reference: 295B6280755D0A34, 4EFF2C77DB8F9E73
// program: 17716008BB716A8F, AD7922A63ED54CA7, 23F262D2CA8E6488
// program: 4EFF2C77DB8F9E73, 3B3AE026C742C7D5, 7FF280648EA22926
// program: 4EFF2C77DB8F9E73, 3B3AE026C742C7D5, 8B353D67743458EE
// program: 17716008BB716A8F, AD7922A63ED54CA7, C74CA00DB8E95117
// program: 17716008BB716A8F, AD7922A63ED54CA7, 45B9B5821FF15384
// program: 4EFF2C77DB8F9E73, 3B3AE026C742C7D5, 2F3A3851E4476855
// program: 4EFF2C77DB8F9E73, 3B3AE026C742C7D5, 9DB6533B8FE11441
// program: 4EFF2C77DB8F9E73, 3B3AE026C742C7D5, 98125BD9033DAC4C
// reference: 54C2FB9D1751E4B5, 76204850D3D31438
// reference: CD9783DCCCE845F2, 76204850D3D31438
// reference: B00E1AC141DD3832, 4EFF2C77DB8F9E73
// program: 4EFF2C77DB8F9E73, 3B3AE026C742C7D5, 82DDCA85272BD2AC
// reference: 8866A198985D2F6B, 52FC86954A48E51C
// program: 52FC86954A48E51C, AD7922A63ED54CA7, AAD077FFD85152AB
// reference: 3604ADEAB954A614, 4EFF2C77DB8F9E73
// reference: D6511F0C03F444B9, BF583C1F84D94483
// program: BF583C1F84D94483, 5D764F9A6220D694, 68475D8B9F916549
// reference: 4F04674DD84DE5FE, BF583C1F84D94483
// reference: AF51D5AB62ED0753, 4EFF2C77DB8F9E73
// reference: 7A34FA3EC426C1E1, E661110CC0BF42D1
// reference: 2E14D0B49A649975, 4EFF2C77DB8F9E73
// reference: 815042F35BE22557, 17716008BB716A8F
// reference: 815042F3B4DBB616, 17716008BB716A8F
// reference: 2E14D0B4755D0A34, 4EFF2C77DB8F9E73
// reference: 538D49A91751E4B5, 76204850D3D31438
// reference: CAD831E8CCE845F2, 76204850D3D31438
// reference: B741A8F541DD3832, 4EFF2C77DB8F9E73
// program: BF583C1F84D94483, 5D764F9A6220D694, 09AA976E69641246
// program: BF583C1F84D94483, 5D764F9A6220D694, FA9C11D88771DF9F
// reference: 7115330773349C85, 76204850D3D31438
// program: 76204850D3D31438, AD7922A63ED54CA7, 10ADC50FC532FE6E
// reference: AD9B1DD89AB88383, B354DE6BBBEF83CA
// reference: 34CE6599410122C4, B354DE6BBBEF83CA
// reference: BB5B4F8EF9BBCE69, BF583C1F84D94483
// program: BF583C1F84D94483, 5D764F9A6220D694, 42CD599C5A3A4B1B
// reference: 220E37CF22026F2E, BF583C1F84D94483
// program: BF583C1F84D94483, 5D764F9A6220D694, A279FC7E01349071
// shader: 8B31, BC32E2F0D24E005D

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;
 out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define mul_safe(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define rcp_safe(x) (1.0f / x)
#define rsq_safe(x) inversesqrt(x)
#define fma_safe(x, y, z) (mul_safe(x, y) + z)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_4096();
bool sub_7_12();
bool sub_12_21();
bool sub_21_34();
bool sub_34_202();
bool sub_40_140();
bool sub_47_76();
bool sub_58_62();
bool sub_76_135();
bool sub_77_109();
bool sub_88_92();
bool sub_109_134();
bool sub_120_124();
bool sub_140_201();
bool sub_143_153();
bool sub_153_158();
bool sub_159_171();
bool sub_171_196();
bool sub_172_190();
bool sub_190_195();
bool sub_202_219();
bool sub_219_295();
bool sub_258_278();
bool sub_259_264();
bool sub_264_277();
bool sub_268_271();
bool sub_271_276();
bool sub_278_291();
bool sub_279_284();
bool sub_284_290();
bool sub_295_312();
bool sub_301_306();
bool sub_303_304();
bool sub_310_311();
bool sub_312_358();
bool sub_316_357();
bool sub_321_323();
bool sub_323_347();
bool sub_326_331();
bool sub_337_346();
bool sub_341_342();
bool sub_342_345();
bool sub_349_356();
bool sub_358_368();
bool sub_365_366();
bool sub_368_395();
bool sub_370_375();
bool sub_375_394();
bool sub_378_384();
bool sub_384_393();
bool sub_385_389();
bool sub_389_392();
bool sub_395_403();
bool sub_397_398();
bool sub_398_402();
bool sub_399_400();
bool sub_400_401();
bool sub_403_410();
bool sub_410_414();
bool sub_414_438();
bool sub_416_420();
bool sub_420_437();
bool sub_421_435();
bool sub_424_431();
bool sub_431_434();
bool sub_435_436();
bool sub_438_454();
bool sub_440_444();
bool sub_444_453();
bool sub_445_451();
bool sub_451_452();

bool exec_shader() {
    sub_0_4096();
    return true;
}

bool sub_0_4096() {
    // 0: call
    {
        sub_34_202();
    }
    // 1: call
    {
        sub_295_312();
    }
    // 2: call
    {
        sub_368_395();
    }
    // 3: call
    {
        sub_414_438();
    }
    // 4: call
    {
        sub_438_454();
    }
    // 5: end
    return true;
}
bool sub_7_12() {
    // 7: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 8: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 9: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 10: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 11: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    return false;
}
bool sub_12_21() {
    // 12: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 13: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 14: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 15: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 16: dp3
    reg_tmp4.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 17: dp3
    reg_tmp4.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 18: dp3
    reg_tmp4.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 19: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 20: mad
    reg_tmp12 = fma_safe(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_21_34() {
    // 21: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 22: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 23: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 24: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 25: dp3
    reg_tmp4.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 26: dp3
    reg_tmp4.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 27: dp3
    reg_tmp4.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 28: dp3
    reg_tmp5.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 29: dp3
    reg_tmp5.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 30: dp3
    reg_tmp5.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 31: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 32: mad
    reg_tmp12 = fma_safe(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    // 33: mad
    reg_tmp11 = fma_safe(reg_tmp1.wwww, reg_tmp5, reg_tmp11);
    return false;
}
bool sub_34_202() {
    // 34: mul
    reg_tmp15.xyz = (mul_safe(uniforms.f[7].xxxx, vs_in_reg0)).xyz;
    // 35: mul
    reg_tmp14.xyz = (mul_safe(uniforms.f[7].yyyy, vs_in_reg1)).xyz;
    // 36: mul
    reg_tmp13.xyz = (mul_safe(uniforms.f[7].zzzz, vs_in_reg2)).xyz;
    // 37: add
    reg_tmp15.xyz = (uniforms.f[6] + reg_tmp15).xyz;
    // 38: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 39: ifu
    if (uniforms.b[1]) {
        sub_40_140();
    } else {
        sub_140_201();
    }
    // 201: nop
    return false;
}
bool sub_40_140() {
    // 40: mov
    reg_tmp0 = uniforms.f[7];
    // 41: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.yzzz));
    // 42: mov
    reg_tmp7 = uniforms.f[93].xxxx;
    // 43: mov
    reg_tmp12 = uniforms.f[93].xxxx;
    // 44: mov
    reg_tmp11 = uniforms.f[93].xxxx;
    // 45: mul
    reg_tmp2 = mul_safe(uniforms.f[93].wwww, vs_in_reg7);
    // 46: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_47_76();
    } else {
        sub_76_135();
    }
    // 135: mov
    vs_out_attr2 = -reg_tmp15;
    // 136: dp4
    vs_out_attr0.x = dot(mul_safe(uniforms.f[86], reg_tmp15), vec4(1.0));
    // 137: dp4
    vs_out_attr0.y = dot(mul_safe(uniforms.f[87], reg_tmp15), vec4(1.0));
    // 138: dp4
    vs_out_attr0.z = dot(mul_safe(uniforms.f[88], reg_tmp15), vec4(1.0));
    // 139: dp4
    vs_out_attr0.w = dot(mul_safe(uniforms.f[89], reg_tmp15), vec4(1.0));
    return false;
}
bool sub_47_76() {
    // 47: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 48: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 49: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 50: call
    {
        sub_12_21();
    }
    // 51: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 52: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 53: call
    {
        sub_12_21();
    }
    // 54: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 55: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 56: callc
    if (conditional_code.x) {
        sub_12_21();
    }
    // 57: ifu
    if (uniforms.b[8]) {
        sub_58_62();
    }
    // 62: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 63: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 64: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 65: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 66: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 67: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 68: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 69: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 70: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 71: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 72: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 73: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 74: call
    {
        sub_202_219();
    }
    // 75: nop
    return false;
}
bool sub_58_62() {
    // 58: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 59: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 60: callc
    if (conditional_code.y) {
        sub_12_21();
    }
    // 61: nop
    return false;
}
bool sub_76_135() {
    // 76: ifc
    if (all(conditional_code)) {
        sub_77_109();
    } else {
        sub_109_134();
    }
    // 134: nop
    return false;
}
bool sub_77_109() {
    // 77: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 78: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 79: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 80: call
    {
        sub_21_34();
    }
    // 81: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 82: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 83: call
    {
        sub_21_34();
    }
    // 84: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 85: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 86: callc
    if (conditional_code.x) {
        sub_21_34();
    }
    // 87: ifu
    if (uniforms.b[8]) {
        sub_88_92();
    }
    // 92: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 93: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 94: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 95: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 96: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 97: dp3
    reg_tmp13.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp11)), vec3(1.0));
    // 98: dp3
    reg_tmp13.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp11)), vec3(1.0));
    // 99: dp3
    reg_tmp13.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp11)), vec3(1.0));
    // 100: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 101: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 102: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 103: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 104: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 105: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 106: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 107: call
    {
        sub_219_295();
    }
    // 108: nop
    return false;
}
bool sub_88_92() {
    // 88: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 89: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 90: callc
    if (conditional_code.y) {
        sub_21_34();
    }
    // 91: nop
    return false;
}
bool sub_109_134() {
    // 109: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 110: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 111: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 112: call
    {
        sub_7_12();
    }
    // 113: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 114: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 115: call
    {
        sub_7_12();
    }
    // 116: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 117: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 118: callc
    if (conditional_code.x) {
        sub_7_12();
    }
    // 119: ifu
    if (uniforms.b[8]) {
        sub_120_124();
    }
    // 124: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 125: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 126: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 127: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 128: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 129: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 130: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 131: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 132: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 133: mov
    vs_out_attr1 = uniforms.f[93].xxxx;
    return false;
}
bool sub_120_124() {
    // 120: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 121: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 122: callc
    if (conditional_code.y) {
        sub_7_12();
    }
    // 123: nop
    return false;
}
bool sub_140_201() {
    // 140: mov
    reg_tmp0 = uniforms.f[7];
    // 141: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.yzzz));
    // 142: ifu
    if (uniforms.b[2]) {
        sub_143_153();
    } else {
        sub_153_158();
    }
    // 158: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_159_171();
    } else {
        sub_171_196();
    }
    // 196: mov
    vs_out_attr2 = -reg_tmp15;
    // 197: dp4
    vs_out_attr0.x = dot(mul_safe(uniforms.f[86], reg_tmp15), vec4(1.0));
    // 198: dp4
    vs_out_attr0.y = dot(mul_safe(uniforms.f[87], reg_tmp15), vec4(1.0));
    // 199: dp4
    vs_out_attr0.z = dot(mul_safe(uniforms.f[88], reg_tmp15), vec4(1.0));
    // 200: dp4
    vs_out_attr0.w = dot(mul_safe(uniforms.f[89], reg_tmp15), vec4(1.0));
    return false;
}
bool sub_143_153() {
    // 143: mul
    reg_tmp1.x = (mul_safe(uniforms.f[93].wwww, vs_in_reg7.xxxx)).x;
    // 144: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 145: dp4
    reg_tmp7.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 146: dp4
    reg_tmp7.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 147: dp4
    reg_tmp7.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 148: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 149: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 150: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 151: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 152: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_153_158() {
    // 153: mova
    address_registers.x = (ivec2(uniforms.f[93].xxxx)).x;
    // 154: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[25], reg_tmp15), vec4(1.0));
    // 155: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[26], reg_tmp15), vec4(1.0));
    // 156: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[27], reg_tmp15), vec4(1.0));
    // 157: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_159_171() {
    // 159: dp3
    reg_tmp12.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 160: dp3
    reg_tmp12.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 161: dp3
    reg_tmp12.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 162: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 163: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 164: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 165: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 166: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 167: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 168: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 169: call
    {
        sub_202_219();
    }
    // 170: nop
    return false;
}
bool sub_171_196() {
    // 171: ifc
    if (all(conditional_code)) {
        sub_172_190();
    } else {
        sub_190_195();
    }
    // 195: nop
    return false;
}
bool sub_172_190() {
    // 172: dp3
    reg_tmp12.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 173: dp3
    reg_tmp12.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 174: dp3
    reg_tmp12.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 175: dp3
    reg_tmp11.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 176: dp3
    reg_tmp11.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 177: dp3
    reg_tmp11.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 178: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 179: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 180: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 181: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 182: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 183: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 184: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 185: dp3
    reg_tmp13.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp11)), vec3(1.0));
    // 186: dp3
    reg_tmp13.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp11)), vec3(1.0));
    // 187: dp3
    reg_tmp13.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp11)), vec3(1.0));
    // 188: call
    {
        sub_219_295();
    }
    // 189: nop
    return false;
}
bool sub_190_195() {
    // 190: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 191: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 192: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 193: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 194: mov
    vs_out_attr1 = uniforms.f[93].xxxx;
    return false;
}
bool sub_202_219() {
    uint jmp_to = 202u;
    while (true) {
        switch (jmp_to) {
        case 202u: {
            // 202: dp3
            reg_tmp6.x = dot(vec3(mul_safe(reg_tmp14, reg_tmp14)), vec3(1.0));
            // 203: dp3
            reg_tmp7.x = dot(vec3(mul_safe(reg_tmp12, reg_tmp12)), vec3(1.0));
            // 204: rsq
            reg_tmp6.x = rsq_safe(reg_tmp6.xxxx.x);
            // 205: rsq
            reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
            // 206: mul
            reg_tmp14.xyz = (mul_safe(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 207: mul
            reg_tmp12.xyz = (mul_safe(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 208: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 209: jmpu
            if (!uniforms.b[15]) {
                { jmp_to = 218u; break; }
            }
            // 210: add
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            // 211: mul
            reg_tmp4 = mul_safe(uniforms.f[94].zzzz, reg_tmp4);
            // 212: cmp
            conditional_code = greaterThanEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp4.xxxx));
            // 213: rsq
            reg_tmp4 = vec4(rsq_safe(reg_tmp4.xxxx.x));
            // 214: mul
            reg_tmp5 = mul_safe(uniforms.f[94].zzzz, reg_tmp14);
            // 215: jmpc
            if (conditional_code.x) {
                { jmp_to = 218u; break; }
            }
            // 216: rcp
            reg_tmp0.z = rcp_safe(reg_tmp4.xxxx.x);
            // 217: mul
            reg_tmp0.xy = (mul_safe(reg_tmp5, reg_tmp4)).xy;
        }
        case 218u: {
            // 218: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_219_295() {
    uint jmp_to = 219u;
    while (true) {
        switch (jmp_to) {
        case 219u: {
            // 219: dp3
            reg_tmp6.x = dot(vec3(mul_safe(reg_tmp14, reg_tmp14)), vec3(1.0));
            // 220: dp3
            reg_tmp7.x = dot(vec3(mul_safe(reg_tmp12, reg_tmp12)), vec3(1.0));
            // 221: rsq
            reg_tmp6.x = rsq_safe(reg_tmp6.xxxx.x);
            // 222: rsq
            reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
            // 223: mul
            reg_tmp14.xyz = (mul_safe(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 224: mul
            reg_tmp12.xyz = (mul_safe(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 225: mul
            reg_tmp13.xyz = (mul_safe(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            // 226: mul
            reg_tmp11.xyz = (mul_safe(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            // 227: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 228: jmpu
            if (!uniforms.b[15]) {
                { jmp_to = 294u; break; }
            }
            // 229: mul
            reg_tmp13.xyz = (mul_safe(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            // 230: mul
            reg_tmp11.xyz = (mul_safe(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            // 231: mul
            reg_tmp5 = mul_safe(reg_tmp14.yzxx, reg_tmp13.zxyy);
            // 232: mad
            reg_tmp5 = fma_safe(-reg_tmp13.yzxx, reg_tmp14.zxyy, reg_tmp5);
            // 233: dp3
            reg_tmp5.w = dot(vec3(mul_safe(reg_tmp5, reg_tmp5)), vec3(1.0));
            // 234: rsq
            reg_tmp5.w = rsq_safe(reg_tmp5.wwww.x);
            // 235: mul
            reg_tmp5 = mul_safe(reg_tmp5, reg_tmp5.wwww);
            // 236: add
            reg_tmp6.w = (reg_tmp14.zzzz + reg_tmp5.yyyy).w;
            // 237: mul
            reg_tmp13 = mul_safe(reg_tmp5.yzxx, reg_tmp14.zxyy);
            // 238: mad
            reg_tmp13 = fma_safe(-reg_tmp14.yzxx, reg_tmp5.zxyy, reg_tmp13);
            // 239: add
            reg_tmp6.w = (reg_tmp13.xxxx + reg_tmp6).w;
            // 240: mov
            reg_tmp13.w = (reg_tmp5.zzzz).w;
            // 241: mov
            reg_tmp5.z = (reg_tmp13.xxxx).z;
            // 242: add
            reg_tmp6.w = (uniforms.f[93].yyyy + reg_tmp6).w;
            // 243: mov
            reg_tmp14.w = (reg_tmp5.xxxx).w;
            // 244: mov
            reg_tmp5.x = (reg_tmp14.zzzz).x;
            // 245: cmp
            conditional_code = lessThan(vec2(uniforms.f[94].yyyy), vec2(reg_tmp6.wwww));
            // 246: mov
            reg_tmp6.x = (uniforms.f[93].yyyy).x;
            // 247: mov
            reg_tmp6.y = (-uniforms.f[93].yyyy).y;
            // 248: jmpc
            if (!conditional_code.x) {
                { jmp_to = 256u; break; }
            }
            // 249: add
            reg_tmp7.xz = (reg_tmp13.wwyy + -reg_tmp14.yyww).xz;
            // 250: add
            reg_tmp7.y = (reg_tmp14.xxxx + -reg_tmp13.zzzz).y;
            // 251: mov
            reg_tmp7.w = (reg_tmp6).w;
            // 252: dp4
            reg_tmp6 = vec4(dot(mul_safe(reg_tmp7, reg_tmp7), vec4(1.0)));
            // 253: rsq
            reg_tmp6 = vec4(rsq_safe(reg_tmp6.xxxx.x));
            // 254: mul
            reg_tmp0 = mul_safe(reg_tmp7, reg_tmp6);
            // 255: jmpu
            if (uniforms.b[0]) {
                { jmp_to = 294u; break; }
            }
        }
        case 256u: {
            // 256: cmp
            conditional_code = greaterThan(vec2(reg_tmp5.zyyy), vec2(reg_tmp5.yxxx));
            // 257: ifc
            if (conditional_code.x) {
                sub_258_278();
            } else {
                sub_278_291();
            }
            // 291: dp4
            reg_tmp6 = vec4(dot(mul_safe(reg_tmp8, reg_tmp8), vec4(1.0)));
            // 292: rsq
            reg_tmp6 = vec4(rsq_safe(reg_tmp6.xxxx.x));
            // 293: mul
            reg_tmp0 = mul_safe(reg_tmp8, reg_tmp6);
        }
        case 294u: {
            // 294: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_258_278() {
    // 258: ifc
    if (conditional_code.y) {
        sub_259_264();
    } else {
        sub_264_277();
    }
    // 277: mov
    reg_tmp8.w = (-reg_tmp8).w;
    return false;
}
bool sub_259_264() {
    // 259: mul
    reg_tmp8 = mul_safe(reg_tmp13.yyzw, reg_tmp6.xxxy);
    // 260: add
    reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
    // 261: add
    reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
    // 262: add
    reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
    // 263: add
    reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
    return false;
}
bool sub_264_277() {
    // 264: cmp
    conditional_code = greaterThan(vec2(reg_tmp5.zzzz), vec2(reg_tmp5.xxxx));
    // 265: mul
    reg_tmp8 = mul_safe(reg_tmp13.yyzw, reg_tmp6.xxxy);
    // 266: add
    reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
    // 267: ifc
    if (conditional_code.x) {
        sub_268_271();
    } else {
        sub_271_276();
    }
    // 276: nop
    return false;
}
bool sub_268_271() {
    // 268: add
    reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
    // 269: add
    reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
    // 270: add
    reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
    return false;
}
bool sub_271_276() {
    // 271: mul
    reg_tmp8 = mul_safe(reg_tmp13.zwwy, reg_tmp6.xxxy);
    // 272: add
    reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
    // 273: add
    reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
    // 274: add
    reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
    // 275: add
    reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
    return false;
}
bool sub_278_291() {
    // 278: ifc
    if (conditional_code.y) {
        sub_279_284();
    } else {
        sub_284_290();
    }
    // 290: nop
    return false;
}
bool sub_279_284() {
    // 279: mul
    reg_tmp8 = mul_safe(reg_tmp13.yywz, reg_tmp6.xxxy);
    // 280: add
    reg_tmp8.y = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).y;
    // 281: add
    reg_tmp9 = reg_tmp5.yyyy + -reg_tmp5.xxxx;
    // 282: add
    reg_tmp8.xzw = (reg_tmp8 + reg_tmp14.wwyx).xzw;
    // 283: add
    reg_tmp8.y = (reg_tmp9 + reg_tmp8).y;
    return false;
}
bool sub_284_290() {
    // 284: mul
    reg_tmp8 = mul_safe(reg_tmp13.zwwy, reg_tmp6.xxxy);
    // 285: add
    reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
    // 286: add
    reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
    // 287: add
    reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
    // 288: add
    reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
    // 289: mov
    reg_tmp8.w = (-reg_tmp8).w;
    return false;
}
bool sub_295_312() {
    // 295: mov
    reg_tmp8.xy = (uniforms.f[93].xxxx).xy;
    // 296: mov
    reg_tmp0.y = (uniforms.f[7].wwww).y;
    // 297: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.xyyy));
    // 298: mov
    reg_tmp9.xyz = (uniforms.f[93].xxxx).xyz;
    // 299: mov
    reg_tmp9.w = (uniforms.f[21].wwww).w;
    // 300: ifc
    if (conditional_code.y) {
        sub_301_306();
    }
    // 306: callu
    if (uniforms.b[12]) {
        sub_312_358();
    }
    // 307: callu
    if (uniforms.b[5]) {
        sub_358_368();
    }
    // 308: cmp
    conditional_code = equal(vec2(uniforms.f[93].xxxx), vec2(reg_tmp8.xyyy));
    // 309: ifc
    if (all(conditional_code)) {
        sub_310_311();
    }
    // 311: max
    vs_out_attr3 = max(uniforms.f[93].xxxx, reg_tmp9);
    return false;
}
bool sub_301_306() {
    // 301: mul
    reg_tmp0 = mul_safe(uniforms.f[7].wwww, vs_in_reg3);
    // 302: ifu
    if (uniforms.b[7]) {
        sub_303_304();
    }
    // 304: mul
    reg_tmp9.xyz = (mul_safe(uniforms.f[20].wwww, reg_tmp0.xyzz)).xyz;
    // 305: mov
    reg_tmp8.x = (uniforms.f[93].yyyy).x;
    return false;
}
bool sub_303_304() {
    // 303: mul
    reg_tmp9.w = (mul_safe(reg_tmp9.wwww, reg_tmp0.wwww)).w;
    return false;
}
bool sub_310_311() {
    // 310: mov
    reg_tmp9 = uniforms.f[21];
    return false;
}
bool sub_312_358() {
    // 312: mov
    reg_tmp1 = uniforms.f[20];
    // 313: mov
    reg_tmp2 = uniforms.f[21];
    // 314: mov
    reg_tmp3 = uniforms.f[93].xxxx;
    // 315: loop
    address_registers.z = int(uniforms.i[0].y);
    for (uint loop315 = 0u; loop315 <= uniforms.i[0].x; address_registers.z += int(uniforms.i[0].z), ++loop315) {
        sub_316_357();
    }
    // 357: mov
    reg_tmp8.x = (uniforms.f[93].yyyy).x;
    return false;
}
bool sub_316_357() {
    // 316: mova
    address_registers.x = (ivec2(reg_tmp3)).x;
    // 317: mov
    reg_tmp4.x = (uniforms.f[81 + address_registers.x].wwww).x;
    // 318: mov
    reg_tmp4.y = (uniforms.f[83 + address_registers.x].wwww).y;
    // 319: cmp
    conditional_code = equal(vec2(uniforms.f[93].xyyy), vec2(reg_tmp4.xyyy));
    // 320: ifc
    if (conditional_code.x) {
        sub_321_323();
    } else {
        sub_323_347();
    }
    // 347: cmp
    conditional_code.x = uniforms.f[93].xxxx.x == reg_tmp6.xyyy.x;
    conditional_code.y = uniforms.f[93].xxxx.y < reg_tmp6.xyyy.y;
    // 348: ifc
    if (conditional_code.y) {
        sub_349_356();
    }
    // 356: add
    reg_tmp3 = -uniforms.f[95].wwww + reg_tmp3;
    return false;
}
bool sub_321_323() {
    // 321: dp3
    reg_tmp6.x = dot(vec3(mul_safe(uniforms.f[81 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 322: mov
    reg_tmp6.y = (uniforms.f[93].yyyy).y;
    return false;
}
bool sub_323_347() {
    // 323: add
    reg_tmp4 = uniforms.f[81 + address_registers.x] + -reg_tmp15;
    // 324: mov
    reg_tmp6.y = (uniforms.f[93].yyyy).y;
    // 325: ifc
    if (conditional_code.y) {
        sub_326_331();
    }
    // 331: mov
    reg_tmp5 = uniforms.f[82 + address_registers.x];
    // 332: cmp
    conditional_code = equal(vec2(uniforms.f[93].yyyy), vec2(reg_tmp5.wwww));
    // 333: dp3
    reg_tmp4.w = dot(vec3(mul_safe(reg_tmp4, reg_tmp4)), vec3(1.0));
    // 334: rsq
    reg_tmp4.w = rsq_safe(reg_tmp4.wwww.x);
    // 335: mul
    reg_tmp4 = mul_safe(reg_tmp4, reg_tmp4.wwww);
    // 336: ifc
    if (conditional_code.x) {
        sub_337_346();
    }
    // 346: dp3
    reg_tmp6.x = dot(vec3(mul_safe(reg_tmp14, reg_tmp4)), vec3(1.0));
    return false;
}
bool sub_326_331() {
    // 326: mov
    reg_tmp5.x = (uniforms.f[93].yyyy).x;
    // 327: dp3
    reg_tmp5.z = dot(vec3(mul_safe(reg_tmp4, reg_tmp4)), vec3(1.0));
    // 328: mul
    reg_tmp5.y = (mul_safe(reg_tmp5.zzzz, reg_tmp5.zzzz)).y;
    // 329: dp3
    reg_tmp6.y = dot(vec3(mul_safe(uniforms.f[83 + address_registers.x], reg_tmp5)), vec3(1.0));
    // 330: rcp
    reg_tmp6.y = rcp_safe(reg_tmp6.yyyy.x);
    return false;
}
bool sub_337_346() {
    // 337: dp3
    reg_tmp5.x = dot(vec3(mul_safe(uniforms.f[82 + address_registers.x], -reg_tmp4)), vec3(1.0));
    // 338: slti
    reg_tmp5.y = (vec4(lessThan(reg_tmp5.xxxx,uniforms.f[84 + address_registers.x].yyyy))).y;
    // 339: cmp
    conditional_code = equal(vec2(uniforms.f[93].yyyy), vec2(reg_tmp5.xyyy));
    // 340: ifc
    if (conditional_code.y) {
        sub_341_342();
    } else {
        sub_342_345();
    }
    // 345: mul
    reg_tmp6.y = (mul_safe(reg_tmp6.yyyy, reg_tmp5.xxxx)).y;
    return false;
}
bool sub_341_342() {
    // 341: mov
    reg_tmp5.x = (uniforms.f[93].xxxx).x;
    return false;
}
bool sub_342_345() {
    // 342: log
    reg_tmp5.y = log2(reg_tmp5.xxxx.x);
    // 343: mul
    reg_tmp5.y = (mul_safe(uniforms.f[84 + address_registers.x].xxxx, reg_tmp5.yyyy)).y;
    // 344: exp
    reg_tmp5.x = exp2(reg_tmp5.yyyy.x);
    return false;
}
bool sub_349_356() {
    // 349: max
    reg_tmp6.x = (max(uniforms.f[93].xxxx, reg_tmp6.xxxx)).x;
    // 350: mad
    reg_tmp9.xyz = (fma_safe(reg_tmp1.xyzz, uniforms.f[79 + address_registers.x].xyzz, reg_tmp9.xyzz)).xyz;
    // 351: mul
    reg_tmp4 = mul_safe(uniforms.f[80 + address_registers.x], reg_tmp2);
    // 352: mul
    reg_tmp5.xyz = (mul_safe(reg_tmp6.xxxx, reg_tmp4.xyzz)).xyz;
    // 353: mul
    reg_tmp5.xyz = (mul_safe(reg_tmp6.yyyy, reg_tmp5.xyzz)).xyz;
    // 354: add
    reg_tmp9.xyz = (reg_tmp9.xyzz + reg_tmp5.xyzz).xyz;
    // 355: add
    reg_tmp9.w = (reg_tmp9.wwww + reg_tmp4.wwww).w;
    return false;
}
bool sub_358_368() {
    // 358: dp3
    reg_tmp1 = vec4(dot(vec3(mul_safe(uniforms.f[24], reg_tmp14)), vec3(1.0)));
    // 359: mov
    reg_tmp2 = uniforms.f[24].wwww;
    // 360: mad
    reg_tmp1 = fma_safe(reg_tmp1, reg_tmp2, reg_tmp2);
    // 361: mov
    reg_tmp3 = uniforms.f[22];
    // 362: add
    reg_tmp2 = uniforms.f[23] + -reg_tmp3;
    // 363: mad
    reg_tmp4 = fma_safe(reg_tmp2, reg_tmp1, reg_tmp3);
    // 364: ifu
    if (uniforms.b[6]) {
        sub_365_366();
    }
    // 366: mad
    reg_tmp9.xyz = (fma_safe(reg_tmp4, uniforms.f[21], reg_tmp9)).xyz;
    // 367: mov
    reg_tmp8.x = (uniforms.f[93].yyyy).x;
    return false;
}
bool sub_365_366() {
    // 365: mul
    reg_tmp4 = mul_safe(reg_tmp4, reg_tmp9.wwww);
    return false;
}
bool sub_368_395() {
    // 368: mov
    reg_tmp0.xy = (uniforms.f[10].xxxx).xy;
    // 369: ifu
    if (uniforms.b[9]) {
        sub_370_375();
    } else {
        sub_375_394();
    }
    // 394: nop
    return false;
}
bool sub_370_375() {
    // 370: call
    {
        sub_395_403();
    }
    // 371: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[11].xywz, reg_tmp6), vec4(1.0));
    // 372: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[12].xywz, reg_tmp6), vec4(1.0));
    // 373: mov
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    // 374: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_375_394() {
    // 375: cmp
    conditional_code = equal(vec2(uniforms.f[95].xyyy), vec2(reg_tmp0.xyyy));
    // 376: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 377: ifc
    if (all(not(conditional_code))) {
        sub_378_384();
    } else {
        sub_384_393();
    }
    // 393: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_378_384() {
    // 378: mov
    reg_tmp6 = reg_tmp10;
    // 379: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[11], reg_tmp6), vec4(1.0));
    // 380: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[12], reg_tmp6), vec4(1.0));
    // 381: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[13], reg_tmp6), vec4(1.0));
    // 382: mul
    reg_tmp0.xy = (mul_safe(uniforms.f[19].xyyy, reg_tmp3.zzzz)).xy;
    // 383: add
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_384_393() {
    // 384: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_385_389();
    } else {
        sub_389_392();
    }
    // 392: nop
    return false;
}
bool sub_385_389() {
    // 385: call
    {
        sub_403_410();
    }
    // 386: dp3
    reg_tmp3.x = dot(vec3(mul_safe(uniforms.f[11], reg_tmp6)), vec3(1.0));
    // 387: dp3
    reg_tmp3.y = dot(vec3(mul_safe(uniforms.f[12], reg_tmp6)), vec3(1.0));
    // 388: dp3
    reg_tmp3.z = dot(vec3(mul_safe(uniforms.f[13], reg_tmp6)), vec3(1.0));
    return false;
}
bool sub_389_392() {
    // 389: call
    {
        sub_410_414();
    }
    // 390: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[11], reg_tmp6), vec4(1.0));
    // 391: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[12], reg_tmp6), vec4(1.0));
    return false;
}
bool sub_395_403() {
    // 395: cmp
    conditional_code = equal(vec2(uniforms.f[93].yzzz), vec2(reg_tmp0.xyyy));
    // 396: ifc
    if (all(not(conditional_code))) {
        sub_397_398();
    } else {
        sub_398_402();
    }
    // 402: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_397_398() {
    // 397: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
    return false;
}
bool sub_398_402() {
    // 398: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_399_400();
    } else {
        sub_400_401();
    }
    // 401: nop
    return false;
}
bool sub_399_400() {
    // 399: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
    return false;
}
bool sub_400_401() {
    // 400: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
    return false;
}
bool sub_403_410() {
    // 403: mov
    reg_tmp2 = -reg_tmp15;
    // 404: dp3
    reg_tmp2.w = dot(vec3(mul_safe(reg_tmp2, reg_tmp2)), vec3(1.0));
    // 405: rsq
    reg_tmp2.w = rsq_safe(reg_tmp2.wwww.x);
    // 406: mul
    reg_tmp2 = mul_safe(reg_tmp2, reg_tmp2.wwww);
    // 407: dp3
    reg_tmp1 = vec4(dot(vec3(mul_safe(reg_tmp2, reg_tmp14)), vec3(1.0)));
    // 408: add
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    // 409: mad
    reg_tmp6 = fma_safe(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_410_414() {
    // 410: mov
    reg_tmp1.xy = (uniforms.f[94].zzzz).xy;
    // 411: mov
    reg_tmp1.zw = (uniforms.f[93].xxxx).zw;
    // 412: mad
    reg_tmp6 = fma_safe(reg_tmp14, reg_tmp1, reg_tmp1);
    // 413: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_414_438() {
    // 414: mov
    reg_tmp0.xy = (uniforms.f[10].yyyy).xy;
    // 415: ifu
    if (uniforms.b[10]) {
        sub_416_420();
    } else {
        sub_420_437();
    }
    // 437: nop
    return false;
}
bool sub_416_420() {
    // 416: call
    {
        sub_395_403();
    }
    // 417: dp4
    reg_tmp4.x = dot(mul_safe(uniforms.f[14].xywz, reg_tmp6), vec4(1.0));
    // 418: dp4
    reg_tmp4.y = dot(mul_safe(uniforms.f[15].xywz, reg_tmp6), vec4(1.0));
    // 419: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_420_437() {
    // 420: ifu
    if (uniforms.b[13]) {
        sub_421_435();
    } else {
        sub_435_436();
    }
    // 436: nop
    return false;
}
bool sub_421_435() {
    // 421: cmp
    conditional_code = equal(vec2(uniforms.f[95].xyyy), vec2(reg_tmp0.xyyy));
    // 422: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 423: ifc
    if (all(not(conditional_code))) {
        sub_424_431();
    } else {
        sub_431_434();
    }
    // 434: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_424_431() {
    // 424: mov
    reg_tmp6 = reg_tmp10;
    // 425: dp4
    reg_tmp4.x = dot(mul_safe(uniforms.f[14], reg_tmp6), vec4(1.0));
    // 426: dp4
    reg_tmp4.y = dot(mul_safe(uniforms.f[15], reg_tmp6), vec4(1.0));
    // 427: dp4
    reg_tmp4.z = dot(mul_safe(uniforms.f[16], reg_tmp6), vec4(1.0));
    // 428: rcp
    reg_tmp6.w = rcp_safe(reg_tmp4.zzzz.x);
    // 429: mul
    reg_tmp4.xy = (mul_safe(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    // 430: add
    reg_tmp4.xy = (uniforms.f[19].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_431_434() {
    // 431: call
    {
        sub_410_414();
    }
    // 432: dp4
    reg_tmp4.x = dot(mul_safe(uniforms.f[14], reg_tmp6), vec4(1.0));
    // 433: dp4
    reg_tmp4.y = dot(mul_safe(uniforms.f[15], reg_tmp6), vec4(1.0));
    return false;
}
bool sub_435_436() {
    // 435: mov
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_438_454() {
    // 438: mov
    reg_tmp0.xy = (uniforms.f[10].zzzz).xy;
    // 439: ifu
    if (uniforms.b[11]) {
        sub_440_444();
    } else {
        sub_444_453();
    }
    // 453: nop
    return false;
}
bool sub_440_444() {
    // 440: call
    {
        sub_395_403();
    }
    // 441: dp4
    reg_tmp5.x = dot(mul_safe(uniforms.f[17].xywz, reg_tmp6), vec4(1.0));
    // 442: dp4
    reg_tmp5.y = dot(mul_safe(uniforms.f[18].xywz, reg_tmp6), vec4(1.0));
    // 443: mov
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_444_453() {
    // 444: ifu
    if (uniforms.b[14]) {
        sub_445_451();
    } else {
        sub_451_452();
    }
    // 452: nop
    return false;
}
bool sub_445_451() {
    // 445: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 446: mov
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    // 447: call
    {
        sub_410_414();
    }
    // 448: dp4
    reg_tmp5.x = dot(mul_safe(uniforms.f[17], reg_tmp6), vec4(1.0));
    // 449: dp4
    reg_tmp5.y = dot(mul_safe(uniforms.f[18], reg_tmp6), vec4(1.0));
    // 450: mov
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_451_452() {
    // 451: mov
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
// reference: 254C1781A7D2DE60, BC32E2F0D24E005D
// program: BC32E2F0D24E005D, AD7922A63ED54CA7, 30DAB74CA24CBC58
// reference: BC196FC07C6B7F27, BC32E2F0D24E005D
// program: BC32E2F0D24E005D, AD7922A63ED54CA7, 21647988483E7BCD
// program: BEF53C1FB1E1CFF4, AD7922A63ED54CA7, 57B333648195A2F8
// reference: 33EDD037A7D2DE60, BC32E2F0D24E005D
// reference: AAB8A8767C6B7F27, BC32E2F0D24E005D
// shader: 8B31, AE0AE260B2F14D0F

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define mul_safe(x, y) (x * y)
#define rcp_safe(x) (1.0f / x)
#define rsq_safe(x) inversesqrt(x)
#define fma_safe(x, y, z) fma(x, y, z)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_4096();
bool sub_22_27();
bool sub_33_35();
bool sub_35_46();
bool sub_38_39();
bool sub_40_41();
bool sub_42_43();
bool sub_44_45();
bool sub_48_51();
bool sub_52_55();
bool sub_56_59();
bool sub_60_63();
bool sub_65_99();
bool sub_67_86();
bool sub_70_73();
bool sub_74_77();
bool sub_78_81();
bool sub_82_85();
bool sub_88_98();
bool sub_90_93();
bool sub_94_97();

bool exec_shader() {
    sub_0_4096();
    return true;
}

bool sub_0_4096() {
    // 0: mova
    address_registers.x = (ivec2(vs_in_reg0)).x;
    // 1: mov
    reg_tmp0 = uniforms.f[6 + address_registers.x].wzyx;
    // 2: mov
    reg_tmp1.xy = (vs_in_reg0.zwzw).xy;
    // 3: mov
    reg_tmp1.zw = (uniforms.f[5].xyxy).zw;
    // 4: mova
    address_registers.xy = ivec2(reg_tmp0.xyyy);
    // 5: mov
    reg_tmp2.xw = (uniforms.f[64 + address_registers.y].wwyy).xw;
    // 6: mov
    reg_tmp2.yz = (uniforms.f[5].xxxx).yz;
    // 7: dp4
    reg_tmp4.x = dot(reg_tmp1, reg_tmp2);
    // 8: mov
    reg_tmp2.yw = (uniforms.f[64 + address_registers.y].zzxx).yw;
    // 9: mov
    reg_tmp2.xz = (uniforms.f[5].xxxx).xz;
    // 10: dp4
    reg_tmp4.y = dot(reg_tmp1, reg_tmp2);
    // 11: mov
    reg_tmp4.zw = (reg_tmp1.zwzw).zw;
    // 12: dp4
    reg_tmp3.x = dot(uniforms.f[32 + address_registers.x].wzyx, reg_tmp4);
    // 13: dp4
    reg_tmp3.y = dot(uniforms.f[33 + address_registers.x].wzyx, reg_tmp4);
    // 14: dp4
    reg_tmp3.z = dot(uniforms.f[34 + address_registers.x].wzyx, reg_tmp4);
    // 15: mov
    reg_tmp3.w = (reg_tmp1.wwww).w;
    // 16: mov
    reg_tmp4.z = (uniforms.f[34 + address_registers.x].xxxx).z;
    // 17: max
    reg_tmp4.z = (max(reg_tmp4.zzzz, -reg_tmp4.zzzz)).z;
    // 18: add
    reg_tmp4.z = (uniforms.f[4].yyyy + reg_tmp4.zzzz).z;
    // 19: mov
    reg_tmp4.x = (uniforms.f[4].wwww).x;
    // 20: cmp
    conditional_code = notEqual(vec2(uniforms.f[5].xxxx), vec2(reg_tmp4.xzzz));
    // 21: ifc
    if (all(conditional_code)) {
        sub_22_27();
    }
    // 27: dp4
    vs_out_attr0.x = dot(uniforms.f[0].wzyx, reg_tmp3);
    // 28: dp4
    vs_out_attr0.y = dot(uniforms.f[1].wzyx, reg_tmp3);
    // 29: dp4
    vs_out_attr0.z = dot(uniforms.f[2].wzyx, reg_tmp3);
    // 30: dp4
    vs_out_attr0.w = dot(uniforms.f[3].wzyx, reg_tmp3);
    // 31: cmp
    conditional_code = greaterThanEqual(vec2(uniforms.f[5].yyyy), vec2(reg_tmp0.wwww));
    // 32: ifc
    if (all(conditional_code)) {
        sub_33_35();
    } else {
        sub_35_46();
    }
    // 46: cmp
    conditional_code = notEqual(vec2(uniforms.f[5].xxxx), vec2(reg_tmp1.xyyy));
    // 47: ifc
    if (all(not(conditional_code))) {
        sub_48_51();
    }
    // 51: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_52_55();
    }
    // 55: ifc
    if (all(bvec2(!conditional_code.x, conditional_code.y))) {
        sub_56_59();
    }
    // 59: ifc
    if (all(conditional_code)) {
        sub_60_63();
    }
    // 63: mov
    reg_tmp8 = uniforms.f[5].xxxx;
    // 64: loop
    address_registers.z = int(uniforms.i[0].y);
    for (uint loop64 = 0u; loop64 <= uniforms.i[0].x; address_registers.z += int(uniforms.i[0].z), ++loop64) {
        sub_65_99();
    }
    // 99: mov
    vs_out_attr2 = reg_tmp5;
    // 100: mov
    vs_out_attr3 = reg_tmp6;
    // 101: mov
    vs_out_attr4 = reg_tmp7;
    // 102: end
    return true;
}
bool sub_22_27() {
    // 22: mov
    reg_tmp4.x = (uniforms.f[4].wwww).x;
    // 23: add
    reg_tmp4.y = (-uniforms.f[4].zzzz + reg_tmp4.zzzz).y;
    // 24: rcp
    reg_tmp4.z = rcp_safe(reg_tmp4.zzzz.x);
    // 25: mul
    reg_tmp4.z = (mul_safe(reg_tmp4.yyyy, reg_tmp4.zzzz)).z;
    // 26: mad
    reg_tmp3.x = (fma_safe(reg_tmp4.xxxx, reg_tmp4.zzzz, reg_tmp3.xxxx)).x;
    return false;
}
bool sub_33_35() {
    // 33: mov
    vs_out_attr1.xyz = (uniforms.f[5].yyyy).xyz;
    // 34: mov
    vs_out_attr1.w = (reg_tmp0.wwww).w;
    return false;
}
bool sub_35_46() {
    // 35: mova
    address_registers.y = (ivec2(reg_tmp0.wwww)).y;
    // 36: cmp
    conditional_code = notEqual(vec2(uniforms.f[5].xxxx), vec2(reg_tmp1.xyyy));
    // 37: ifc
    if (all(not(conditional_code))) {
        sub_38_39();
    }
    // 39: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_40_41();
    }
    // 41: ifc
    if (all(bvec2(!conditional_code.x, conditional_code.y))) {
        sub_42_43();
    }
    // 43: ifc
    if (all(conditional_code)) {
        sub_44_45();
    }
    // 45: nop
    return false;
}
bool sub_38_39() {
    // 38: mov
    vs_out_attr1 = uniforms.f[32 + address_registers.y].wzyx;
    return false;
}
bool sub_40_41() {
    // 40: mov
    vs_out_attr1 = uniforms.f[33 + address_registers.y].wzyx;
    return false;
}
bool sub_42_43() {
    // 42: mov
    vs_out_attr1 = uniforms.f[34 + address_registers.y].wzyx;
    return false;
}
bool sub_44_45() {
    // 44: mov
    vs_out_attr1 = uniforms.f[35 + address_registers.y].wzyx;
    return false;
}
bool sub_48_51() {
    // 48: mov
    reg_tmp5 = uniforms.f[5].xyyy;
    // 49: mov
    reg_tmp6 = uniforms.f[5].xyyy;
    // 50: mov
    reg_tmp7 = uniforms.f[5].xyyy;
    return false;
}
bool sub_52_55() {
    // 52: mov
    reg_tmp5 = uniforms.f[5].yyyy;
    // 53: mov
    reg_tmp6 = uniforms.f[5].yyyy;
    // 54: mov
    reg_tmp7 = uniforms.f[5].yyyy;
    return false;
}
bool sub_56_59() {
    // 56: mov
    reg_tmp5 = uniforms.f[5].xxyy;
    // 57: mov
    reg_tmp6 = uniforms.f[5].xxyy;
    // 58: mov
    reg_tmp7 = uniforms.f[5].xxyy;
    return false;
}
bool sub_60_63() {
    // 60: mov
    reg_tmp5 = uniforms.f[5].yxyy;
    // 61: mov
    reg_tmp6 = uniforms.f[5].yxyy;
    // 62: mov
    reg_tmp7 = uniforms.f[5].yxyy;
    return false;
}
bool sub_65_99() {
    // 65: cmp
    conditional_code = equal(vec2(uniforms.f[5].yyyy), vec2(reg_tmp8));
    // 66: ifc
    if (all(conditional_code)) {
        sub_67_86();
    }
    // 86: cmp
    conditional_code = lessThan(vec2(uniforms.f[5].wwww), vec2(reg_tmp8));
    // 87: ifc
    if (all(conditional_code)) {
        sub_88_98();
    }
    // 98: add
    reg_tmp8 = uniforms.f[5].yyyy + reg_tmp8;
    return false;
}
bool sub_67_86() {
    // 67: mova
    address_registers.y = (ivec2(reg_tmp0.zzzz)).y;
    // 68: cmp
    conditional_code = notEqual(vec2(uniforms.f[5].xxxx), vec2(reg_tmp1.xyyy));
    // 69: ifc
    if (all(not(conditional_code))) {
        sub_70_73();
    }
    // 73: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_74_77();
    }
    // 77: ifc
    if (all(bvec2(!conditional_code.x, conditional_code.y))) {
        sub_78_81();
    }
    // 81: ifc
    if (all(conditional_code)) {
        sub_82_85();
    }
    // 85: nop
    return false;
}
bool sub_70_73() {
    // 70: mov
    reg_tmp5.xy = (uniforms.f[64 + address_registers.y].wzzz).xy;
    // 71: mov
    reg_tmp6.xy = (uniforms.f[65 + address_registers.y].wzzz).xy;
    // 72: mov
    reg_tmp7.xy = (uniforms.f[66 + address_registers.y].wzzz).xy;
    return false;
}
bool sub_74_77() {
    // 74: mov
    reg_tmp5.xy = (uniforms.f[64 + address_registers.y].yzzz).xy;
    // 75: mov
    reg_tmp6.xy = (uniforms.f[65 + address_registers.y].yzzz).xy;
    // 76: mov
    reg_tmp7.xy = (uniforms.f[66 + address_registers.y].yzzz).xy;
    return false;
}
bool sub_78_81() {
    // 78: mov
    reg_tmp5.xy = (uniforms.f[64 + address_registers.y].wxxx).xy;
    // 79: mov
    reg_tmp6.xy = (uniforms.f[65 + address_registers.y].wxxx).xy;
    // 80: mov
    reg_tmp7.xy = (uniforms.f[66 + address_registers.y].wxxx).xy;
    return false;
}
bool sub_82_85() {
    // 82: mov
    reg_tmp5.xy = (uniforms.f[64 + address_registers.y].yxxx).xy;
    // 83: mov
    reg_tmp6.xy = (uniforms.f[65 + address_registers.y].yxxx).xy;
    // 84: mov
    reg_tmp7.xy = (uniforms.f[66 + address_registers.y].yxxx).xy;
    return false;
}
bool sub_88_98() {
    // 88: cmp
    conditional_code = notEqual(vec2(uniforms.f[5].xxxx), vec2(reg_tmp1.xyyy));
    // 89: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_90_93();
    }
    // 93: ifc
    if (all(bvec2(!conditional_code.x, conditional_code.y))) {
        sub_94_97();
    }
    // 97: nop
    return false;
}
bool sub_90_93() {
    // 90: mov
    reg_tmp5.xy = (uniforms.f[67 + address_registers.y].yxxx).xy;
    // 91: mov
    reg_tmp6.xy = (uniforms.f[68 + address_registers.y].yxxx).xy;
    // 92: mov
    reg_tmp7.xy = (uniforms.f[69 + address_registers.y].yxxx).xy;
    return false;
}
bool sub_94_97() {
    // 94: mov
    reg_tmp5.xy = (uniforms.f[67 + address_registers.y].wzzz).xy;
    // 95: mov
    reg_tmp6.xy = (uniforms.f[68 + address_registers.y].wzzz).xy;
    // 96: mov
    reg_tmp7.xy = (uniforms.f[69 + address_registers.y].wzzz).xy;
    return false;
}
// reference: D3199A340A91A0A5, AE0AE260B2F14D0F
// program: AE0AE260B2F14D0F, 5D764F9A6220D694, ED7F62B87BCBA8C3
// program: AE0AE260B2F14D0F, 5D764F9A6220D694, 0B496AE87480A30D
// shader: 8B31, 7CF7B3710EA67233

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define mul_safe(x, y) (x * y)
#define rcp_safe(x) (1.0f / x)
#define rsq_safe(x) inversesqrt(x)
#define fma_safe(x, y, z) fma(x, y, z)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_4096();
bool sub_6_11();
bool sub_11_20();
bool sub_20_29();
bool sub_37_197();
bool sub_42_139();
bool sub_48_76();
bool sub_59_63();
bool sub_76_129();
bool sub_77_104();
bool sub_88_92();
bool sub_104_128();
bool sub_115_119();
bool sub_137_138();
bool sub_139_194();
bool sub_142_152();
bool sub_152_157();
bool sub_158_168();
bool sub_168_184();
bool sub_169_179();
bool sub_179_183();
bool sub_192_193();
bool sub_197_214();
bool sub_203_208();
bool sub_205_206();
bool sub_212_213();
bool sub_214_260();
bool sub_218_259();
bool sub_223_225();
bool sub_225_249();
bool sub_228_233();
bool sub_239_248();
bool sub_243_244();
bool sub_244_247();
bool sub_251_258();
bool sub_260_270();
bool sub_267_268();
bool sub_270_279();
bool sub_297_321();
bool sub_299_303();
bool sub_303_320();
bool sub_304_318();
bool sub_307_314();
bool sub_314_317();
bool sub_318_319();
bool sub_321_329();
bool sub_323_324();
bool sub_324_328();
bool sub_325_326();
bool sub_326_327();
bool sub_329_333();

bool exec_shader() {
    sub_0_4096();
    return true;
}

bool sub_0_4096() {
    // 0: call
    {
        sub_37_197();
    }
    // 1: call
    {
        sub_197_214();
    }
    // 2: call
    {
        sub_270_279();
    }
    // 3: call
    {
        sub_297_321();
    }
    // 4: end
    return true;
}
bool sub_6_11() {
    // 6: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 7: dp4
    reg_tmp3.x = dot(uniforms.f[25 + address_registers.x], reg_tmp15);
    // 8: dp4
    reg_tmp3.y = dot(uniforms.f[26 + address_registers.x], reg_tmp15);
    // 9: dp4
    reg_tmp3.z = dot(uniforms.f[27 + address_registers.x], reg_tmp15);
    // 10: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    return false;
}
bool sub_11_20() {
    // 11: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 12: dp4
    reg_tmp3.x = dot(uniforms.f[25 + address_registers.x], reg_tmp15);
    // 13: dp4
    reg_tmp3.y = dot(uniforms.f[26 + address_registers.x], reg_tmp15);
    // 14: dp4
    reg_tmp3.z = dot(uniforms.f[27 + address_registers.x], reg_tmp15);
    // 15: dp3
    reg_tmp4.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp14));
    // 16: dp3
    reg_tmp4.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp14));
    // 17: dp3
    reg_tmp4.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp14));
    // 18: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 19: mad
    reg_tmp12 = fma_safe(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_20_29() {
    // 20: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 21: dp4
    reg_tmp3.x = dot(uniforms.f[25 + address_registers.x], reg_tmp15);
    // 22: dp4
    reg_tmp3.y = dot(uniforms.f[26 + address_registers.x], reg_tmp15);
    // 23: dp4
    reg_tmp3.z = dot(uniforms.f[27 + address_registers.x], reg_tmp15);
    // 24: dp3
    reg_tmp4.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp14));
    // 25: dp3
    reg_tmp4.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp14));
    // 26: dp3
    reg_tmp4.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp14));
    // 27: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 28: mad
    reg_tmp12 = fma_safe(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_37_197() {
    // 37: mul
    reg_tmp15.xyz = (mul_safe(uniforms.f[7].xxxx, vs_in_reg0)).xyz;
    // 38: mul
    reg_tmp14.xyz = (mul_safe(uniforms.f[7].yyyy, vs_in_reg1)).xyz;
    // 39: add
    reg_tmp15.xyz = (uniforms.f[6] + reg_tmp15).xyz;
    // 40: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 41: ifu
    if (uniforms.b[1]) {
        sub_42_139();
    } else {
        sub_139_194();
    }
    // 194: nop
    // 195: mov
    vs_out_attr1 = uniforms.f[93].xxxx;
    // 196: mov
    vs_out_attr2 = uniforms.f[93].xxxx;
    return false;
}
bool sub_42_139() {
    // 42: mov
    reg_tmp0 = uniforms.f[7];
    // 43: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.yzzz));
    // 44: mov
    reg_tmp7 = uniforms.f[93].xxxx;
    // 45: mov
    reg_tmp12 = uniforms.f[93].xxxx;
    // 46: mul
    reg_tmp2 = mul_safe(uniforms.f[93].wwww, vs_in_reg7);
    // 47: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_48_76();
    } else {
        sub_76_129();
    }
    // 129: dp4
    reg_tmp0.x = dot(uniforms.f[86], reg_tmp15);
    // 130: dp4
    reg_tmp0.y = dot(uniforms.f[87], reg_tmp15);
    // 131: dp4
    reg_tmp0.z = dot(uniforms.f[88], reg_tmp15);
    // 132: dp4
    reg_tmp0.w = dot(uniforms.f[89], reg_tmp15);
    // 133: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 134: mul
    reg_tmp1.y = (mul_safe(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
    // 135: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 136: ifc
    if (all(conditional_code)) {
        sub_137_138();
    }
    // 138: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_48_76() {
    // 48: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 49: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 50: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 51: call
    {
        sub_11_20();
    }
    // 52: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 53: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 54: call
    {
        sub_11_20();
    }
    // 55: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 56: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 57: callc
    if (conditional_code.x) {
        sub_11_20();
    }
    // 58: ifu
    if (uniforms.b[8]) {
        sub_59_63();
    }
    // 63: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 64: dp4
    reg_tmp10.x = dot(uniforms.f[0], reg_tmp7);
    // 65: dp4
    reg_tmp10.y = dot(uniforms.f[1], reg_tmp7);
    // 66: dp4
    reg_tmp10.z = dot(uniforms.f[2], reg_tmp7);
    // 67: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 68: dp3
    reg_tmp14.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp12));
    // 69: dp3
    reg_tmp14.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp12));
    // 70: dp3
    reg_tmp14.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp12));
    // 71: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 72: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 73: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 74: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 75: nop
    return false;
}
bool sub_59_63() {
    // 59: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 60: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 61: callc
    if (conditional_code.y) {
        sub_11_20();
    }
    // 62: nop
    return false;
}
bool sub_76_129() {
    // 76: ifc
    if (all(conditional_code)) {
        sub_77_104();
    } else {
        sub_104_128();
    }
    // 128: nop
    return false;
}
bool sub_77_104() {
    // 77: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 78: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 79: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 80: call
    {
        sub_20_29();
    }
    // 81: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 82: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 83: call
    {
        sub_20_29();
    }
    // 84: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 85: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 86: callc
    if (conditional_code.x) {
        sub_20_29();
    }
    // 87: ifu
    if (uniforms.b[8]) {
        sub_88_92();
    }
    // 92: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 93: dp4
    reg_tmp10.x = dot(uniforms.f[0], reg_tmp7);
    // 94: dp4
    reg_tmp10.y = dot(uniforms.f[1], reg_tmp7);
    // 95: dp4
    reg_tmp10.z = dot(uniforms.f[2], reg_tmp7);
    // 96: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 97: dp3
    reg_tmp14.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp12));
    // 98: dp3
    reg_tmp14.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp12));
    // 99: dp3
    reg_tmp14.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp12));
    // 100: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 101: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 102: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 103: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_88_92() {
    // 88: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 89: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 90: callc
    if (conditional_code.y) {
        sub_20_29();
    }
    // 91: nop
    return false;
}
bool sub_104_128() {
    // 104: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 105: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 106: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 107: call
    {
        sub_6_11();
    }
    // 108: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 109: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 110: call
    {
        sub_6_11();
    }
    // 111: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 112: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 113: callc
    if (conditional_code.x) {
        sub_6_11();
    }
    // 114: ifu
    if (uniforms.b[8]) {
        sub_115_119();
    }
    // 119: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 120: dp4
    reg_tmp10.x = dot(uniforms.f[0], reg_tmp7);
    // 121: dp4
    reg_tmp10.y = dot(uniforms.f[1], reg_tmp7);
    // 122: dp4
    reg_tmp10.z = dot(uniforms.f[2], reg_tmp7);
    // 123: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 124: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 125: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 126: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 127: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_115_119() {
    // 115: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 116: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 117: callc
    if (conditional_code.y) {
        sub_6_11();
    }
    // 118: nop
    return false;
}
bool sub_137_138() {
    // 137: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_139_194() {
    // 139: mov
    reg_tmp0 = uniforms.f[7];
    // 140: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.yzzz));
    // 141: ifu
    if (uniforms.b[2]) {
        sub_142_152();
    } else {
        sub_152_157();
    }
    // 157: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_158_168();
    } else {
        sub_168_184();
    }
    // 184: dp4
    reg_tmp0.x = dot(uniforms.f[86], reg_tmp15);
    // 185: dp4
    reg_tmp0.y = dot(uniforms.f[87], reg_tmp15);
    // 186: dp4
    reg_tmp0.z = dot(uniforms.f[88], reg_tmp15);
    // 187: dp4
    reg_tmp0.w = dot(uniforms.f[89], reg_tmp15);
    // 188: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 189: mul
    reg_tmp1.y = (mul_safe(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
    // 190: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 191: ifc
    if (all(conditional_code)) {
        sub_192_193();
    }
    // 193: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_142_152() {
    // 142: mul
    reg_tmp1.x = (mul_safe(uniforms.f[93].wwww, vs_in_reg7.xxxx)).x;
    // 143: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 144: dp4
    reg_tmp7.x = dot(uniforms.f[25 + address_registers.x], reg_tmp15);
    // 145: dp4
    reg_tmp7.y = dot(uniforms.f[26 + address_registers.x], reg_tmp15);
    // 146: dp4
    reg_tmp7.z = dot(uniforms.f[27 + address_registers.x], reg_tmp15);
    // 147: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 148: dp4
    reg_tmp10.x = dot(uniforms.f[0], reg_tmp7);
    // 149: dp4
    reg_tmp10.y = dot(uniforms.f[1], reg_tmp7);
    // 150: dp4
    reg_tmp10.z = dot(uniforms.f[2], reg_tmp7);
    // 151: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_152_157() {
    // 152: mova
    address_registers.x = (ivec2(uniforms.f[93].xxxx)).x;
    // 153: dp4
    reg_tmp10.x = dot(uniforms.f[25], reg_tmp15);
    // 154: dp4
    reg_tmp10.y = dot(uniforms.f[26], reg_tmp15);
    // 155: dp4
    reg_tmp10.z = dot(uniforms.f[27], reg_tmp15);
    // 156: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_158_168() {
    // 158: dp3
    reg_tmp12.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp14));
    // 159: dp3
    reg_tmp12.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp14));
    // 160: dp3
    reg_tmp12.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp14));
    // 161: dp3
    reg_tmp14.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp12));
    // 162: dp3
    reg_tmp14.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp12));
    // 163: dp3
    reg_tmp14.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp12));
    // 164: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 165: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 166: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 167: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_168_184() {
    // 168: ifc
    if (all(conditional_code)) {
        sub_169_179();
    } else {
        sub_179_183();
    }
    // 183: nop
    return false;
}
bool sub_169_179() {
    // 169: dp3
    reg_tmp12.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp14));
    // 170: dp3
    reg_tmp12.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp14));
    // 171: dp3
    reg_tmp12.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp14));
    // 172: dp3
    reg_tmp14.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp12));
    // 173: dp3
    reg_tmp14.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp12));
    // 174: dp3
    reg_tmp14.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp12));
    // 175: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 176: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 177: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 178: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_179_183() {
    // 179: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 180: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 181: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 182: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_192_193() {
    // 192: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_197_214() {
    // 197: mov
    reg_tmp8.xy = (uniforms.f[93].xxxx).xy;
    // 198: mov
    reg_tmp0.y = (uniforms.f[7].wwww).y;
    // 199: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.xyyy));
    // 200: mov
    reg_tmp9.xyz = (uniforms.f[93].xxxx).xyz;
    // 201: mov
    reg_tmp9.w = (uniforms.f[21].wwww).w;
    // 202: ifc
    if (conditional_code.y) {
        sub_203_208();
    }
    // 208: callu
    if (uniforms.b[12]) {
        sub_214_260();
    }
    // 209: callu
    if (uniforms.b[5]) {
        sub_260_270();
    }
    // 210: cmp
    conditional_code = equal(vec2(uniforms.f[93].xxxx), vec2(reg_tmp8.xyyy));
    // 211: ifc
    if (all(conditional_code)) {
        sub_212_213();
    }
    // 213: max
    vs_out_attr3 = max(uniforms.f[93].xxxx, reg_tmp9);
    return false;
}
bool sub_203_208() {
    // 203: mul
    reg_tmp0 = mul_safe(uniforms.f[7].wwww, vs_in_reg3);
    // 204: ifu
    if (uniforms.b[7]) {
        sub_205_206();
    }
    // 206: mul
    reg_tmp9.xyz = (mul_safe(uniforms.f[20].wwww, reg_tmp0.xyzz)).xyz;
    // 207: mov
    reg_tmp8.x = (uniforms.f[93].yyyy).x;
    return false;
}
bool sub_205_206() {
    // 205: mul
    reg_tmp9.w = (mul_safe(reg_tmp9.wwww, reg_tmp0.wwww)).w;
    return false;
}
bool sub_212_213() {
    // 212: mov
    reg_tmp9 = uniforms.f[21];
    return false;
}
bool sub_214_260() {
    // 214: mov
    reg_tmp1 = uniforms.f[20];
    // 215: mov
    reg_tmp2 = uniforms.f[21];
    // 216: mov
    reg_tmp3 = uniforms.f[93].xxxx;
    // 217: loop
    address_registers.z = int(uniforms.i[0].y);
    for (uint loop217 = 0u; loop217 <= uniforms.i[0].x; address_registers.z += int(uniforms.i[0].z), ++loop217) {
        sub_218_259();
    }
    // 259: mov
    reg_tmp8.x = (uniforms.f[93].yyyy).x;
    return false;
}
bool sub_218_259() {
    // 218: mova
    address_registers.x = (ivec2(reg_tmp3)).x;
    // 219: mov
    reg_tmp4.x = (uniforms.f[81 + address_registers.x].wwww).x;
    // 220: mov
    reg_tmp4.y = (uniforms.f[83 + address_registers.x].wwww).y;
    // 221: cmp
    conditional_code = equal(vec2(uniforms.f[93].xyyy), vec2(reg_tmp4.xyyy));
    // 222: ifc
    if (conditional_code.x) {
        sub_223_225();
    } else {
        sub_225_249();
    }
    // 249: cmp
    conditional_code.x = uniforms.f[93].xxxx.x == reg_tmp6.xyyy.x;
    conditional_code.y = uniforms.f[93].xxxx.y < reg_tmp6.xyyy.y;
    // 250: ifc
    if (conditional_code.y) {
        sub_251_258();
    }
    // 258: add
    reg_tmp3 = -uniforms.f[95].wwww + reg_tmp3;
    return false;
}
bool sub_223_225() {
    // 223: dp3
    reg_tmp6.x = dot(vec3(uniforms.f[81 + address_registers.x]), vec3(reg_tmp14));
    // 224: mov
    reg_tmp6.y = (uniforms.f[93].yyyy).y;
    return false;
}
bool sub_225_249() {
    // 225: add
    reg_tmp4 = uniforms.f[81 + address_registers.x] + -reg_tmp15;
    // 226: mov
    reg_tmp6.y = (uniforms.f[93].yyyy).y;
    // 227: ifc
    if (conditional_code.y) {
        sub_228_233();
    }
    // 233: mov
    reg_tmp5 = uniforms.f[82 + address_registers.x];
    // 234: cmp
    conditional_code = equal(vec2(uniforms.f[93].yyyy), vec2(reg_tmp5.wwww));
    // 235: dp3
    reg_tmp4.w = dot(vec3(reg_tmp4), vec3(reg_tmp4));
    // 236: rsq
    reg_tmp4.w = rsq_safe(reg_tmp4.wwww.x);
    // 237: mul
    reg_tmp4 = mul_safe(reg_tmp4, reg_tmp4.wwww);
    // 238: ifc
    if (conditional_code.x) {
        sub_239_248();
    }
    // 248: dp3
    reg_tmp6.x = dot(vec3(reg_tmp14), vec3(reg_tmp4));
    return false;
}
bool sub_228_233() {
    // 228: mov
    reg_tmp5.x = (uniforms.f[93].yyyy).x;
    // 229: dp3
    reg_tmp5.z = dot(vec3(reg_tmp4), vec3(reg_tmp4));
    // 230: mul
    reg_tmp5.y = (mul_safe(reg_tmp5.zzzz, reg_tmp5.zzzz)).y;
    // 231: dp3
    reg_tmp6.y = dot(vec3(uniforms.f[83 + address_registers.x]), vec3(reg_tmp5));
    // 232: rcp
    reg_tmp6.y = rcp_safe(reg_tmp6.yyyy.x);
    return false;
}
bool sub_239_248() {
    // 239: dp3
    reg_tmp5.x = dot(vec3(uniforms.f[82 + address_registers.x]), vec3(-reg_tmp4));
    // 240: slti
    reg_tmp5.y = (vec4(lessThan(reg_tmp5.xxxx,uniforms.f[84 + address_registers.x].yyyy))).y;
    // 241: cmp
    conditional_code = equal(vec2(uniforms.f[93].yyyy), vec2(reg_tmp5.xyyy));
    // 242: ifc
    if (conditional_code.y) {
        sub_243_244();
    } else {
        sub_244_247();
    }
    // 247: mul
    reg_tmp6.y = (mul_safe(reg_tmp6.yyyy, reg_tmp5.xxxx)).y;
    return false;
}
bool sub_243_244() {
    // 243: mov
    reg_tmp5.x = (uniforms.f[93].xxxx).x;
    return false;
}
bool sub_244_247() {
    // 244: log
    reg_tmp5.y = log2(reg_tmp5.xxxx.x);
    // 245: mul
    reg_tmp5.y = (mul_safe(uniforms.f[84 + address_registers.x].xxxx, reg_tmp5.yyyy)).y;
    // 246: exp
    reg_tmp5.x = exp2(reg_tmp5.yyyy.x);
    return false;
}
bool sub_251_258() {
    // 251: max
    reg_tmp6.x = (max(uniforms.f[93].xxxx, reg_tmp6.xxxx)).x;
    // 252: mad
    reg_tmp9.xyz = (fma_safe(reg_tmp1.xyzz, uniforms.f[79 + address_registers.x].xyzz, reg_tmp9.xyzz)).xyz;
    // 253: mul
    reg_tmp4 = mul_safe(uniforms.f[80 + address_registers.x], reg_tmp2);
    // 254: mul
    reg_tmp5.xyz = (mul_safe(reg_tmp6.xxxx, reg_tmp4.xyzz)).xyz;
    // 255: mul
    reg_tmp5.xyz = (mul_safe(reg_tmp6.yyyy, reg_tmp5.xyzz)).xyz;
    // 256: add
    reg_tmp9.xyz = (reg_tmp9.xyzz + reg_tmp5.xyzz).xyz;
    // 257: add
    reg_tmp9.w = (reg_tmp9.wwww + reg_tmp4.wwww).w;
    return false;
}
bool sub_260_270() {
    // 260: dp3
    reg_tmp1 = vec4(dot(vec3(uniforms.f[24]), vec3(reg_tmp14)));
    // 261: mov
    reg_tmp2 = uniforms.f[24].wwww;
    // 262: mad
    reg_tmp1 = fma_safe(reg_tmp1, reg_tmp2, reg_tmp2);
    // 263: mov
    reg_tmp3 = uniforms.f[22];
    // 264: add
    reg_tmp2 = uniforms.f[23] + -reg_tmp3;
    // 265: mad
    reg_tmp4 = fma_safe(reg_tmp2, reg_tmp1, reg_tmp3);
    // 266: ifu
    if (uniforms.b[6]) {
        sub_267_268();
    }
    // 268: mad
    reg_tmp9.xyz = (fma_safe(reg_tmp4, uniforms.f[21], reg_tmp9)).xyz;
    // 269: mov
    reg_tmp8.x = (uniforms.f[93].yyyy).x;
    return false;
}
bool sub_267_268() {
    // 267: mul
    reg_tmp4 = mul_safe(reg_tmp4, reg_tmp9.wwww);
    return false;
}
bool sub_270_279() {
    // 270: dp3
    reg_tmp5.x = dot(vec3(uniforms.f[90]), vec3(reg_tmp12.xyzz));
    // 271: dp3
    reg_tmp5.y = dot(vec3(uniforms.f[91]), vec3(reg_tmp12.xyzz));
    // 272: dp3
    reg_tmp5.z = dot(vec3(uniforms.f[92]), vec3(reg_tmp12.xyzz));
    // 273: dp4
    reg_tmp4.x = dot(reg_tmp5.xyzz, reg_tmp5.xyzz);
    // 274: rsq
    reg_tmp4.x = rsq_safe(reg_tmp4.xxxx.x);
    // 275: mul
    reg_tmp4.xyz = (mul_safe(reg_tmp5.xyzz, reg_tmp4.xxxx)).xyz;
    // 276: mul
    reg_tmp4 = mul_safe(uniforms.f[94].zzzz, reg_tmp4);
    // 277: add
    reg_tmp12 = uniforms.f[94].zzzz + reg_tmp4;
    // 278: mov
    vs_out_attr4 = reg_tmp12;
    return false;
}
bool sub_297_321() {
    // 297: mov
    reg_tmp0.xy = (uniforms.f[10].yyyy).xy;
    // 298: ifu
    if (uniforms.b[10]) {
        sub_299_303();
    } else {
        sub_303_320();
    }
    // 320: nop
    return false;
}
bool sub_299_303() {
    // 299: call
    {
        sub_321_329();
    }
    // 300: dp4
    reg_tmp4.x = dot(uniforms.f[14].xywz, reg_tmp6);
    // 301: dp4
    reg_tmp4.y = dot(uniforms.f[15].xywz, reg_tmp6);
    // 302: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_303_320() {
    // 303: ifu
    if (uniforms.b[13]) {
        sub_304_318();
    } else {
        sub_318_319();
    }
    // 319: nop
    return false;
}
bool sub_304_318() {
    // 304: cmp
    conditional_code = equal(vec2(uniforms.f[95].xyyy), vec2(reg_tmp0.xyyy));
    // 305: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 306: ifc
    if (all(not(conditional_code))) {
        sub_307_314();
    } else {
        sub_314_317();
    }
    // 317: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_307_314() {
    // 307: mov
    reg_tmp6 = reg_tmp10;
    // 308: dp4
    reg_tmp4.x = dot(uniforms.f[14], reg_tmp6);
    // 309: dp4
    reg_tmp4.y = dot(uniforms.f[15], reg_tmp6);
    // 310: dp4
    reg_tmp4.z = dot(uniforms.f[16], reg_tmp6);
    // 311: rcp
    reg_tmp6.w = rcp_safe(reg_tmp4.zzzz.x);
    // 312: mul
    reg_tmp4.xy = (mul_safe(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    // 313: add
    reg_tmp4.xy = (uniforms.f[19].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_314_317() {
    // 314: call
    {
        sub_329_333();
    }
    // 315: dp4
    reg_tmp4.x = dot(uniforms.f[14], reg_tmp6);
    // 316: dp4
    reg_tmp4.y = dot(uniforms.f[15], reg_tmp6);
    return false;
}
bool sub_318_319() {
    // 318: mov
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_321_329() {
    // 321: cmp
    conditional_code = equal(vec2(uniforms.f[93].yzzz), vec2(reg_tmp0.xyyy));
    // 322: ifc
    if (all(not(conditional_code))) {
        sub_323_324();
    } else {
        sub_324_328();
    }
    // 328: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_323_324() {
    // 323: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
    return false;
}
bool sub_324_328() {
    // 324: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_325_326();
    } else {
        sub_326_327();
    }
    // 327: nop
    return false;
}
bool sub_325_326() {
    // 325: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
    return false;
}
bool sub_326_327() {
    // 326: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
    return false;
}
bool sub_329_333() {
    // 329: mov
    reg_tmp1.xy = (uniforms.f[94].zzzz).xy;
    // 330: mov
    reg_tmp1.zw = (uniforms.f[93].xxxx).zw;
    // 331: mad
    reg_tmp6 = fma_safe(reg_tmp14, reg_tmp1, reg_tmp1);
    // 332: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
// reference: 56C6259258F61A2B, 7CF7B3710EA67233
// program: 7CF7B3710EA67233, 3B3AE026C742C7D5, 2BB9C8FEDE51C537
// reference: CF935DD3834FBB6C, 7CF7B3710EA67233
// program: 7CF7B3710EA67233, 3B3AE026C742C7D5, CCCAFDE548B6C210
// program: 7CF7B3710EA67233, 3B3AE026C742C7D5, 73E202FB36B8AAFC
// shader: 8B31, C7F67128DB0FBE60

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;
 out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define mul_safe(x, y) (x * y)
#define rcp_safe(x) (1.0f / x)
#define rsq_safe(x) inversesqrt(x)
#define fma_safe(x, y, z) fma(x, y, z)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_4096();
bool sub_7_12();
bool sub_12_21();
bool sub_21_34();
bool sub_34_202();
bool sub_40_140();
bool sub_47_76();
bool sub_58_62();
bool sub_76_135();
bool sub_77_109();
bool sub_88_92();
bool sub_109_134();
bool sub_120_124();
bool sub_140_201();
bool sub_143_153();
bool sub_153_158();
bool sub_159_171();
bool sub_171_196();
bool sub_172_190();
bool sub_190_195();
bool sub_202_219();
bool sub_219_295();
bool sub_258_278();
bool sub_259_264();
bool sub_264_277();
bool sub_268_271();
bool sub_271_276();
bool sub_278_291();
bool sub_279_284();
bool sub_284_290();
bool sub_295_312();
bool sub_301_306();
bool sub_303_304();
bool sub_310_311();
bool sub_312_358();
bool sub_316_357();
bool sub_321_323();
bool sub_323_347();
bool sub_326_331();
bool sub_337_346();
bool sub_341_342();
bool sub_342_345();
bool sub_349_356();
bool sub_358_368();
bool sub_365_366();
bool sub_368_395();
bool sub_370_375();
bool sub_375_394();
bool sub_378_384();
bool sub_384_393();
bool sub_385_389();
bool sub_389_392();
bool sub_395_403();
bool sub_397_398();
bool sub_398_402();
bool sub_399_400();
bool sub_400_401();
bool sub_403_410();
bool sub_410_414();
bool sub_414_438();
bool sub_416_420();
bool sub_420_437();
bool sub_421_435();
bool sub_424_431();
bool sub_431_434();
bool sub_435_436();
bool sub_438_454();
bool sub_440_444();
bool sub_444_453();
bool sub_445_451();
bool sub_451_452();

bool exec_shader() {
    sub_0_4096();
    return true;
}

bool sub_0_4096() {
    // 0: call
    {
        sub_34_202();
    }
    // 1: call
    {
        sub_295_312();
    }
    // 2: call
    {
        sub_368_395();
    }
    // 3: call
    {
        sub_414_438();
    }
    // 4: call
    {
        sub_438_454();
    }
    // 5: end
    return true;
}
bool sub_7_12() {
    // 7: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 8: dp4
    reg_tmp3.x = dot(uniforms.f[25 + address_registers.x], reg_tmp15);
    // 9: dp4
    reg_tmp3.y = dot(uniforms.f[26 + address_registers.x], reg_tmp15);
    // 10: dp4
    reg_tmp3.z = dot(uniforms.f[27 + address_registers.x], reg_tmp15);
    // 11: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    return false;
}
bool sub_12_21() {
    // 12: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 13: dp4
    reg_tmp3.x = dot(uniforms.f[25 + address_registers.x], reg_tmp15);
    // 14: dp4
    reg_tmp3.y = dot(uniforms.f[26 + address_registers.x], reg_tmp15);
    // 15: dp4
    reg_tmp3.z = dot(uniforms.f[27 + address_registers.x], reg_tmp15);
    // 16: dp3
    reg_tmp4.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp14));
    // 17: dp3
    reg_tmp4.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp14));
    // 18: dp3
    reg_tmp4.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp14));
    // 19: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 20: mad
    reg_tmp12 = fma_safe(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_21_34() {
    // 21: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 22: dp4
    reg_tmp3.x = dot(uniforms.f[25 + address_registers.x], reg_tmp15);
    // 23: dp4
    reg_tmp3.y = dot(uniforms.f[26 + address_registers.x], reg_tmp15);
    // 24: dp4
    reg_tmp3.z = dot(uniforms.f[27 + address_registers.x], reg_tmp15);
    // 25: dp3
    reg_tmp4.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp14));
    // 26: dp3
    reg_tmp4.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp14));
    // 27: dp3
    reg_tmp4.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp14));
    // 28: dp3
    reg_tmp5.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp13));
    // 29: dp3
    reg_tmp5.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp13));
    // 30: dp3
    reg_tmp5.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp13));
    // 31: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 32: mad
    reg_tmp12 = fma_safe(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    // 33: mad
    reg_tmp11 = fma_safe(reg_tmp1.wwww, reg_tmp5, reg_tmp11);
    return false;
}
bool sub_34_202() {
    // 34: mul
    reg_tmp15.xyz = (mul_safe(uniforms.f[7].xxxx, vs_in_reg0)).xyz;
    // 35: mul
    reg_tmp14.xyz = (mul_safe(uniforms.f[7].yyyy, vs_in_reg1)).xyz;
    // 36: mul
    reg_tmp13.xyz = (mul_safe(uniforms.f[7].zzzz, vs_in_reg2)).xyz;
    // 37: add
    reg_tmp15.xyz = (uniforms.f[6] + reg_tmp15).xyz;
    // 38: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 39: ifu
    if (uniforms.b[1]) {
        sub_40_140();
    } else {
        sub_140_201();
    }
    // 201: nop
    return false;
}
bool sub_40_140() {
    // 40: mov
    reg_tmp0 = uniforms.f[7];
    // 41: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.yzzz));
    // 42: mov
    reg_tmp7 = uniforms.f[93].xxxx;
    // 43: mov
    reg_tmp12 = uniforms.f[93].xxxx;
    // 44: mov
    reg_tmp11 = uniforms.f[93].xxxx;
    // 45: mul
    reg_tmp2 = mul_safe(uniforms.f[93].wwww, vs_in_reg7);
    // 46: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_47_76();
    } else {
        sub_76_135();
    }
    // 135: mov
    vs_out_attr2 = -reg_tmp15;
    // 136: dp4
    vs_out_attr0.x = dot(uniforms.f[86], reg_tmp15);
    // 137: dp4
    vs_out_attr0.y = dot(uniforms.f[87], reg_tmp15);
    // 138: dp4
    vs_out_attr0.z = dot(uniforms.f[88], reg_tmp15);
    // 139: dp4
    vs_out_attr0.w = dot(uniforms.f[89], reg_tmp15);
    return false;
}
bool sub_47_76() {
    // 47: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 48: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 49: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 50: call
    {
        sub_12_21();
    }
    // 51: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 52: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 53: call
    {
        sub_12_21();
    }
    // 54: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 55: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 56: callc
    if (conditional_code.x) {
        sub_12_21();
    }
    // 57: ifu
    if (uniforms.b[8]) {
        sub_58_62();
    }
    // 62: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 63: dp4
    reg_tmp10.x = dot(uniforms.f[0], reg_tmp7);
    // 64: dp4
    reg_tmp10.y = dot(uniforms.f[1], reg_tmp7);
    // 65: dp4
    reg_tmp10.z = dot(uniforms.f[2], reg_tmp7);
    // 66: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 67: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 68: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 69: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 70: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 71: dp3
    reg_tmp14.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp12));
    // 72: dp3
    reg_tmp14.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp12));
    // 73: dp3
    reg_tmp14.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp12));
    // 74: call
    {
        sub_202_219();
    }
    // 75: nop
    return false;
}
bool sub_58_62() {
    // 58: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 59: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 60: callc
    if (conditional_code.y) {
        sub_12_21();
    }
    // 61: nop
    return false;
}
bool sub_76_135() {
    // 76: ifc
    if (all(conditional_code)) {
        sub_77_109();
    } else {
        sub_109_134();
    }
    // 134: nop
    return false;
}
bool sub_77_109() {
    // 77: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 78: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 79: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 80: call
    {
        sub_21_34();
    }
    // 81: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 82: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 83: call
    {
        sub_21_34();
    }
    // 84: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 85: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 86: callc
    if (conditional_code.x) {
        sub_21_34();
    }
    // 87: ifu
    if (uniforms.b[8]) {
        sub_88_92();
    }
    // 92: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 93: dp4
    reg_tmp10.x = dot(uniforms.f[0], reg_tmp7);
    // 94: dp4
    reg_tmp10.y = dot(uniforms.f[1], reg_tmp7);
    // 95: dp4
    reg_tmp10.z = dot(uniforms.f[2], reg_tmp7);
    // 96: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 97: dp3
    reg_tmp13.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp11));
    // 98: dp3
    reg_tmp13.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp11));
    // 99: dp3
    reg_tmp13.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp11));
    // 100: dp3
    reg_tmp14.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp12));
    // 101: dp3
    reg_tmp14.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp12));
    // 102: dp3
    reg_tmp14.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp12));
    // 103: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 104: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 105: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 106: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 107: call
    {
        sub_219_295();
    }
    // 108: nop
    return false;
}
bool sub_88_92() {
    // 88: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 89: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 90: callc
    if (conditional_code.y) {
        sub_21_34();
    }
    // 91: nop
    return false;
}
bool sub_109_134() {
    // 109: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 110: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 111: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 112: call
    {
        sub_7_12();
    }
    // 113: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 114: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 115: call
    {
        sub_7_12();
    }
    // 116: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 117: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 118: callc
    if (conditional_code.x) {
        sub_7_12();
    }
    // 119: ifu
    if (uniforms.b[8]) {
        sub_120_124();
    }
    // 124: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 125: dp4
    reg_tmp10.x = dot(uniforms.f[0], reg_tmp7);
    // 126: dp4
    reg_tmp10.y = dot(uniforms.f[1], reg_tmp7);
    // 127: dp4
    reg_tmp10.z = dot(uniforms.f[2], reg_tmp7);
    // 128: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 129: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 130: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 131: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 132: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 133: mov
    vs_out_attr1 = uniforms.f[93].xxxx;
    return false;
}
bool sub_120_124() {
    // 120: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 121: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 122: callc
    if (conditional_code.y) {
        sub_7_12();
    }
    // 123: nop
    return false;
}
bool sub_140_201() {
    // 140: mov
    reg_tmp0 = uniforms.f[7];
    // 141: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.yzzz));
    // 142: ifu
    if (uniforms.b[2]) {
        sub_143_153();
    } else {
        sub_153_158();
    }
    // 158: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_159_171();
    } else {
        sub_171_196();
    }
    // 196: mov
    vs_out_attr2 = -reg_tmp15;
    // 197: dp4
    vs_out_attr0.x = dot(uniforms.f[86], reg_tmp15);
    // 198: dp4
    vs_out_attr0.y = dot(uniforms.f[87], reg_tmp15);
    // 199: dp4
    vs_out_attr0.z = dot(uniforms.f[88], reg_tmp15);
    // 200: dp4
    vs_out_attr0.w = dot(uniforms.f[89], reg_tmp15);
    return false;
}
bool sub_143_153() {
    // 143: mul
    reg_tmp1.x = (mul_safe(uniforms.f[93].wwww, vs_in_reg7.xxxx)).x;
    // 144: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 145: dp4
    reg_tmp7.x = dot(uniforms.f[25 + address_registers.x], reg_tmp15);
    // 146: dp4
    reg_tmp7.y = dot(uniforms.f[26 + address_registers.x], reg_tmp15);
    // 147: dp4
    reg_tmp7.z = dot(uniforms.f[27 + address_registers.x], reg_tmp15);
    // 148: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 149: dp4
    reg_tmp10.x = dot(uniforms.f[0], reg_tmp7);
    // 150: dp4
    reg_tmp10.y = dot(uniforms.f[1], reg_tmp7);
    // 151: dp4
    reg_tmp10.z = dot(uniforms.f[2], reg_tmp7);
    // 152: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_153_158() {
    // 153: mova
    address_registers.x = (ivec2(uniforms.f[93].xxxx)).x;
    // 154: dp4
    reg_tmp10.x = dot(uniforms.f[25], reg_tmp15);
    // 155: dp4
    reg_tmp10.y = dot(uniforms.f[26], reg_tmp15);
    // 156: dp4
    reg_tmp10.z = dot(uniforms.f[27], reg_tmp15);
    // 157: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_159_171() {
    // 159: dp3
    reg_tmp12.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp14));
    // 160: dp3
    reg_tmp12.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp14));
    // 161: dp3
    reg_tmp12.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp14));
    // 162: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 163: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 164: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 165: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 166: dp3
    reg_tmp14.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp12));
    // 167: dp3
    reg_tmp14.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp12));
    // 168: dp3
    reg_tmp14.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp12));
    // 169: call
    {
        sub_202_219();
    }
    // 170: nop
    return false;
}
bool sub_171_196() {
    // 171: ifc
    if (all(conditional_code)) {
        sub_172_190();
    } else {
        sub_190_195();
    }
    // 195: nop
    return false;
}
bool sub_172_190() {
    // 172: dp3
    reg_tmp12.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp14));
    // 173: dp3
    reg_tmp12.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp14));
    // 174: dp3
    reg_tmp12.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp14));
    // 175: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp13));
    // 176: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp13));
    // 177: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp13));
    // 178: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 179: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 180: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 181: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 182: dp3
    reg_tmp14.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp12));
    // 183: dp3
    reg_tmp14.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp12));
    // 184: dp3
    reg_tmp14.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp12));
    // 185: dp3
    reg_tmp13.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp11));
    // 186: dp3
    reg_tmp13.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp11));
    // 187: dp3
    reg_tmp13.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp11));
    // 188: call
    {
        sub_219_295();
    }
    // 189: nop
    return false;
}
bool sub_190_195() {
    // 190: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 191: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 192: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 193: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 194: mov
    vs_out_attr1 = uniforms.f[93].xxxx;
    return false;
}
bool sub_202_219() {
    uint jmp_to = 202u;
    while (true) {
        switch (jmp_to) {
        case 202u: {
            // 202: dp3
            reg_tmp6.x = dot(vec3(reg_tmp14), vec3(reg_tmp14));
            // 203: dp3
            reg_tmp7.x = dot(vec3(reg_tmp12), vec3(reg_tmp12));
            // 204: rsq
            reg_tmp6.x = rsq_safe(reg_tmp6.xxxx.x);
            // 205: rsq
            reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
            // 206: mul
            reg_tmp14.xyz = (mul_safe(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 207: mul
            reg_tmp12.xyz = (mul_safe(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 208: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 209: jmpu
            if (!uniforms.b[15]) {
                { jmp_to = 218u; break; }
            }
            // 210: add
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            // 211: mul
            reg_tmp4 = mul_safe(uniforms.f[94].zzzz, reg_tmp4);
            // 212: cmp
            conditional_code = greaterThanEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp4.xxxx));
            // 213: rsq
            reg_tmp4 = vec4(rsq_safe(reg_tmp4.xxxx.x));
            // 214: mul
            reg_tmp5 = mul_safe(uniforms.f[94].zzzz, reg_tmp14);
            // 215: jmpc
            if (conditional_code.x) {
                { jmp_to = 218u; break; }
            }
            // 216: rcp
            reg_tmp0.z = rcp_safe(reg_tmp4.xxxx.x);
            // 217: mul
            reg_tmp0.xy = (mul_safe(reg_tmp5, reg_tmp4)).xy;
        }
        case 218u: {
            // 218: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_219_295() {
    uint jmp_to = 219u;
    while (true) {
        switch (jmp_to) {
        case 219u: {
            // 219: dp3
            reg_tmp6.x = dot(vec3(reg_tmp14), vec3(reg_tmp14));
            // 220: dp3
            reg_tmp7.x = dot(vec3(reg_tmp12), vec3(reg_tmp12));
            // 221: rsq
            reg_tmp6.x = rsq_safe(reg_tmp6.xxxx.x);
            // 222: rsq
            reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
            // 223: mul
            reg_tmp14.xyz = (mul_safe(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 224: mul
            reg_tmp12.xyz = (mul_safe(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 225: mul
            reg_tmp13.xyz = (mul_safe(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            // 226: mul
            reg_tmp11.xyz = (mul_safe(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            // 227: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 228: jmpu
            if (!uniforms.b[15]) {
                { jmp_to = 294u; break; }
            }
            // 229: mul
            reg_tmp13.xyz = (mul_safe(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            // 230: mul
            reg_tmp11.xyz = (mul_safe(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            // 231: mul
            reg_tmp5 = mul_safe(reg_tmp14.yzxx, reg_tmp13.zxyy);
            // 232: mad
            reg_tmp5 = fma_safe(-reg_tmp13.yzxx, reg_tmp14.zxyy, reg_tmp5);
            // 233: dp3
            reg_tmp5.w = dot(vec3(reg_tmp5), vec3(reg_tmp5));
            // 234: rsq
            reg_tmp5.w = rsq_safe(reg_tmp5.wwww.x);
            // 235: mul
            reg_tmp5 = mul_safe(reg_tmp5, reg_tmp5.wwww);
            // 236: add
            reg_tmp6.w = (reg_tmp14.zzzz + reg_tmp5.yyyy).w;
            // 237: mul
            reg_tmp13 = mul_safe(reg_tmp5.yzxx, reg_tmp14.zxyy);
            // 238: mad
            reg_tmp13 = fma_safe(-reg_tmp14.yzxx, reg_tmp5.zxyy, reg_tmp13);
            // 239: add
            reg_tmp6.w = (reg_tmp13.xxxx + reg_tmp6).w;
            // 240: mov
            reg_tmp13.w = (reg_tmp5.zzzz).w;
            // 241: mov
            reg_tmp5.z = (reg_tmp13.xxxx).z;
            // 242: add
            reg_tmp6.w = (uniforms.f[93].yyyy + reg_tmp6).w;
            // 243: mov
            reg_tmp14.w = (reg_tmp5.xxxx).w;
            // 244: mov
            reg_tmp5.x = (reg_tmp14.zzzz).x;
            // 245: cmp
            conditional_code = lessThan(vec2(uniforms.f[94].yyyy), vec2(reg_tmp6.wwww));
            // 246: mov
            reg_tmp6.x = (uniforms.f[93].yyyy).x;
            // 247: mov
            reg_tmp6.y = (-uniforms.f[93].yyyy).y;
            // 248: jmpc
            if (!conditional_code.x) {
                { jmp_to = 256u; break; }
            }
            // 249: add
            reg_tmp7.xz = (reg_tmp13.wwyy + -reg_tmp14.yyww).xz;
            // 250: add
            reg_tmp7.y = (reg_tmp14.xxxx + -reg_tmp13.zzzz).y;
            // 251: mov
            reg_tmp7.w = (reg_tmp6).w;
            // 252: dp4
            reg_tmp6 = vec4(dot(reg_tmp7, reg_tmp7));
            // 253: rsq
            reg_tmp6 = vec4(rsq_safe(reg_tmp6.xxxx.x));
            // 254: mul
            reg_tmp0 = mul_safe(reg_tmp7, reg_tmp6);
            // 255: jmpu
            if (uniforms.b[0]) {
                { jmp_to = 294u; break; }
            }
        }
        case 256u: {
            // 256: cmp
            conditional_code = greaterThan(vec2(reg_tmp5.zyyy), vec2(reg_tmp5.yxxx));
            // 257: ifc
            if (conditional_code.x) {
                sub_258_278();
            } else {
                sub_278_291();
            }
            // 291: dp4
            reg_tmp6 = vec4(dot(reg_tmp8, reg_tmp8));
            // 292: rsq
            reg_tmp6 = vec4(rsq_safe(reg_tmp6.xxxx.x));
            // 293: mul
            reg_tmp0 = mul_safe(reg_tmp8, reg_tmp6);
        }
        case 294u: {
            // 294: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_258_278() {
    // 258: ifc
    if (conditional_code.y) {
        sub_259_264();
    } else {
        sub_264_277();
    }
    // 277: mov
    reg_tmp8.w = (-reg_tmp8).w;
    return false;
}
bool sub_259_264() {
    // 259: mul
    reg_tmp8 = mul_safe(reg_tmp13.yyzw, reg_tmp6.xxxy);
    // 260: add
    reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
    // 261: add
    reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
    // 262: add
    reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
    // 263: add
    reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
    return false;
}
bool sub_264_277() {
    // 264: cmp
    conditional_code = greaterThan(vec2(reg_tmp5.zzzz), vec2(reg_tmp5.xxxx));
    // 265: mul
    reg_tmp8 = mul_safe(reg_tmp13.yyzw, reg_tmp6.xxxy);
    // 266: add
    reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
    // 267: ifc
    if (conditional_code.x) {
        sub_268_271();
    } else {
        sub_271_276();
    }
    // 276: nop
    return false;
}
bool sub_268_271() {
    // 268: add
    reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
    // 269: add
    reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
    // 270: add
    reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
    return false;
}
bool sub_271_276() {
    // 271: mul
    reg_tmp8 = mul_safe(reg_tmp13.zwwy, reg_tmp6.xxxy);
    // 272: add
    reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
    // 273: add
    reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
    // 274: add
    reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
    // 275: add
    reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
    return false;
}
bool sub_278_291() {
    // 278: ifc
    if (conditional_code.y) {
        sub_279_284();
    } else {
        sub_284_290();
    }
    // 290: nop
    return false;
}
bool sub_279_284() {
    // 279: mul
    reg_tmp8 = mul_safe(reg_tmp13.yywz, reg_tmp6.xxxy);
    // 280: add
    reg_tmp8.y = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).y;
    // 281: add
    reg_tmp9 = reg_tmp5.yyyy + -reg_tmp5.xxxx;
    // 282: add
    reg_tmp8.xzw = (reg_tmp8 + reg_tmp14.wwyx).xzw;
    // 283: add
    reg_tmp8.y = (reg_tmp9 + reg_tmp8).y;
    return false;
}
bool sub_284_290() {
    // 284: mul
    reg_tmp8 = mul_safe(reg_tmp13.zwwy, reg_tmp6.xxxy);
    // 285: add
    reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
    // 286: add
    reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
    // 287: add
    reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
    // 288: add
    reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
    // 289: mov
    reg_tmp8.w = (-reg_tmp8).w;
    return false;
}
bool sub_295_312() {
    // 295: mov
    reg_tmp8.xy = (uniforms.f[93].xxxx).xy;
    // 296: mov
    reg_tmp0.y = (uniforms.f[7].wwww).y;
    // 297: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.xyyy));
    // 298: mov
    reg_tmp9.xyz = (uniforms.f[93].xxxx).xyz;
    // 299: mov
    reg_tmp9.w = (uniforms.f[21].wwww).w;
    // 300: ifc
    if (conditional_code.y) {
        sub_301_306();
    }
    // 306: callu
    if (uniforms.b[12]) {
        sub_312_358();
    }
    // 307: callu
    if (uniforms.b[5]) {
        sub_358_368();
    }
    // 308: cmp
    conditional_code = equal(vec2(uniforms.f[93].xxxx), vec2(reg_tmp8.xyyy));
    // 309: ifc
    if (all(conditional_code)) {
        sub_310_311();
    }
    // 311: max
    vs_out_attr3 = max(uniforms.f[93].xxxx, reg_tmp9);
    return false;
}
bool sub_301_306() {
    // 301: mul
    reg_tmp0 = mul_safe(uniforms.f[7].wwww, vs_in_reg3);
    // 302: ifu
    if (uniforms.b[7]) {
        sub_303_304();
    }
    // 304: mul
    reg_tmp9.xyz = (mul_safe(uniforms.f[20].wwww, reg_tmp0.xyzz)).xyz;
    // 305: mov
    reg_tmp8.x = (uniforms.f[93].yyyy).x;
    return false;
}
bool sub_303_304() {
    // 303: mul
    reg_tmp9.w = (mul_safe(reg_tmp9.wwww, reg_tmp0.wwww)).w;
    return false;
}
bool sub_310_311() {
    // 310: mov
    reg_tmp9 = uniforms.f[21];
    return false;
}
bool sub_312_358() {
    // 312: mov
    reg_tmp1 = uniforms.f[20];
    // 313: mov
    reg_tmp2 = uniforms.f[21];
    // 314: mov
    reg_tmp3 = uniforms.f[93].xxxx;
    // 315: loop
    address_registers.z = int(uniforms.i[0].y);
    for (uint loop315 = 0u; loop315 <= uniforms.i[0].x; address_registers.z += int(uniforms.i[0].z), ++loop315) {
        sub_316_357();
    }
    // 357: mov
    reg_tmp8.x = (uniforms.f[93].yyyy).x;
    return false;
}
bool sub_316_357() {
    // 316: mova
    address_registers.x = (ivec2(reg_tmp3)).x;
    // 317: mov
    reg_tmp4.x = (uniforms.f[81 + address_registers.x].wwww).x;
    // 318: mov
    reg_tmp4.y = (uniforms.f[83 + address_registers.x].wwww).y;
    // 319: cmp
    conditional_code = equal(vec2(uniforms.f[93].xyyy), vec2(reg_tmp4.xyyy));
    // 320: ifc
    if (conditional_code.x) {
        sub_321_323();
    } else {
        sub_323_347();
    }
    // 347: cmp
    conditional_code.x = uniforms.f[93].xxxx.x == reg_tmp6.xyyy.x;
    conditional_code.y = uniforms.f[93].xxxx.y < reg_tmp6.xyyy.y;
    // 348: ifc
    if (conditional_code.y) {
        sub_349_356();
    }
    // 356: add
    reg_tmp3 = -uniforms.f[95].wwww + reg_tmp3;
    return false;
}
bool sub_321_323() {
    // 321: dp3
    reg_tmp6.x = dot(vec3(uniforms.f[81 + address_registers.x]), vec3(reg_tmp14));
    // 322: mov
    reg_tmp6.y = (uniforms.f[93].yyyy).y;
    return false;
}
bool sub_323_347() {
    // 323: add
    reg_tmp4 = uniforms.f[81 + address_registers.x] + -reg_tmp15;
    // 324: mov
    reg_tmp6.y = (uniforms.f[93].yyyy).y;
    // 325: ifc
    if (conditional_code.y) {
        sub_326_331();
    }
    // 331: mov
    reg_tmp5 = uniforms.f[82 + address_registers.x];
    // 332: cmp
    conditional_code = equal(vec2(uniforms.f[93].yyyy), vec2(reg_tmp5.wwww));
    // 333: dp3
    reg_tmp4.w = dot(vec3(reg_tmp4), vec3(reg_tmp4));
    // 334: rsq
    reg_tmp4.w = rsq_safe(reg_tmp4.wwww.x);
    // 335: mul
    reg_tmp4 = mul_safe(reg_tmp4, reg_tmp4.wwww);
    // 336: ifc
    if (conditional_code.x) {
        sub_337_346();
    }
    // 346: dp3
    reg_tmp6.x = dot(vec3(reg_tmp14), vec3(reg_tmp4));
    return false;
}
bool sub_326_331() {
    // 326: mov
    reg_tmp5.x = (uniforms.f[93].yyyy).x;
    // 327: dp3
    reg_tmp5.z = dot(vec3(reg_tmp4), vec3(reg_tmp4));
    // 328: mul
    reg_tmp5.y = (mul_safe(reg_tmp5.zzzz, reg_tmp5.zzzz)).y;
    // 329: dp3
    reg_tmp6.y = dot(vec3(uniforms.f[83 + address_registers.x]), vec3(reg_tmp5));
    // 330: rcp
    reg_tmp6.y = rcp_safe(reg_tmp6.yyyy.x);
    return false;
}
bool sub_337_346() {
    // 337: dp3
    reg_tmp5.x = dot(vec3(uniforms.f[82 + address_registers.x]), vec3(-reg_tmp4));
    // 338: slti
    reg_tmp5.y = (vec4(lessThan(reg_tmp5.xxxx,uniforms.f[84 + address_registers.x].yyyy))).y;
    // 339: cmp
    conditional_code = equal(vec2(uniforms.f[93].yyyy), vec2(reg_tmp5.xyyy));
    // 340: ifc
    if (conditional_code.y) {
        sub_341_342();
    } else {
        sub_342_345();
    }
    // 345: mul
    reg_tmp6.y = (mul_safe(reg_tmp6.yyyy, reg_tmp5.xxxx)).y;
    return false;
}
bool sub_341_342() {
    // 341: mov
    reg_tmp5.x = (uniforms.f[93].xxxx).x;
    return false;
}
bool sub_342_345() {
    // 342: log
    reg_tmp5.y = log2(reg_tmp5.xxxx.x);
    // 343: mul
    reg_tmp5.y = (mul_safe(uniforms.f[84 + address_registers.x].xxxx, reg_tmp5.yyyy)).y;
    // 344: exp
    reg_tmp5.x = exp2(reg_tmp5.yyyy.x);
    return false;
}
bool sub_349_356() {
    // 349: max
    reg_tmp6.x = (max(uniforms.f[93].xxxx, reg_tmp6.xxxx)).x;
    // 350: mad
    reg_tmp9.xyz = (fma_safe(reg_tmp1.xyzz, uniforms.f[79 + address_registers.x].xyzz, reg_tmp9.xyzz)).xyz;
    // 351: mul
    reg_tmp4 = mul_safe(uniforms.f[80 + address_registers.x], reg_tmp2);
    // 352: mul
    reg_tmp5.xyz = (mul_safe(reg_tmp6.xxxx, reg_tmp4.xyzz)).xyz;
    // 353: mul
    reg_tmp5.xyz = (mul_safe(reg_tmp6.yyyy, reg_tmp5.xyzz)).xyz;
    // 354: add
    reg_tmp9.xyz = (reg_tmp9.xyzz + reg_tmp5.xyzz).xyz;
    // 355: add
    reg_tmp9.w = (reg_tmp9.wwww + reg_tmp4.wwww).w;
    return false;
}
bool sub_358_368() {
    // 358: dp3
    reg_tmp1 = vec4(dot(vec3(uniforms.f[24]), vec3(reg_tmp14)));
    // 359: mov
    reg_tmp2 = uniforms.f[24].wwww;
    // 360: mad
    reg_tmp1 = fma_safe(reg_tmp1, reg_tmp2, reg_tmp2);
    // 361: mov
    reg_tmp3 = uniforms.f[22];
    // 362: add
    reg_tmp2 = uniforms.f[23] + -reg_tmp3;
    // 363: mad
    reg_tmp4 = fma_safe(reg_tmp2, reg_tmp1, reg_tmp3);
    // 364: ifu
    if (uniforms.b[6]) {
        sub_365_366();
    }
    // 366: mad
    reg_tmp9.xyz = (fma_safe(reg_tmp4, uniforms.f[21], reg_tmp9)).xyz;
    // 367: mov
    reg_tmp8.x = (uniforms.f[93].yyyy).x;
    return false;
}
bool sub_365_366() {
    // 365: mul
    reg_tmp4 = mul_safe(reg_tmp4, reg_tmp9.wwww);
    return false;
}
bool sub_368_395() {
    // 368: mov
    reg_tmp0.xy = (uniforms.f[10].xxxx).xy;
    // 369: ifu
    if (uniforms.b[9]) {
        sub_370_375();
    } else {
        sub_375_394();
    }
    // 394: nop
    return false;
}
bool sub_370_375() {
    // 370: call
    {
        sub_395_403();
    }
    // 371: dp4
    reg_tmp3.x = dot(uniforms.f[11].xywz, reg_tmp6);
    // 372: dp4
    reg_tmp3.y = dot(uniforms.f[12].xywz, reg_tmp6);
    // 373: mov
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    // 374: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_375_394() {
    // 375: cmp
    conditional_code = equal(vec2(uniforms.f[95].xyyy), vec2(reg_tmp0.xyyy));
    // 376: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 377: ifc
    if (all(not(conditional_code))) {
        sub_378_384();
    } else {
        sub_384_393();
    }
    // 393: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_378_384() {
    // 378: mov
    reg_tmp6 = reg_tmp10;
    // 379: dp4
    reg_tmp3.x = dot(uniforms.f[11], reg_tmp6);
    // 380: dp4
    reg_tmp3.y = dot(uniforms.f[12], reg_tmp6);
    // 381: dp4
    reg_tmp3.z = dot(uniforms.f[13], reg_tmp6);
    // 382: mul
    reg_tmp0.xy = (mul_safe(uniforms.f[19].xyyy, reg_tmp3.zzzz)).xy;
    // 383: add
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_384_393() {
    // 384: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_385_389();
    } else {
        sub_389_392();
    }
    // 392: nop
    return false;
}
bool sub_385_389() {
    // 385: call
    {
        sub_403_410();
    }
    // 386: dp3
    reg_tmp3.x = dot(vec3(uniforms.f[11]), vec3(reg_tmp6));
    // 387: dp3
    reg_tmp3.y = dot(vec3(uniforms.f[12]), vec3(reg_tmp6));
    // 388: dp3
    reg_tmp3.z = dot(vec3(uniforms.f[13]), vec3(reg_tmp6));
    return false;
}
bool sub_389_392() {
    // 389: call
    {
        sub_410_414();
    }
    // 390: dp4
    reg_tmp3.x = dot(uniforms.f[11], reg_tmp6);
    // 391: dp4
    reg_tmp3.y = dot(uniforms.f[12], reg_tmp6);
    return false;
}
bool sub_395_403() {
    // 395: cmp
    conditional_code = equal(vec2(uniforms.f[93].yzzz), vec2(reg_tmp0.xyyy));
    // 396: ifc
    if (all(not(conditional_code))) {
        sub_397_398();
    } else {
        sub_398_402();
    }
    // 402: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_397_398() {
    // 397: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
    return false;
}
bool sub_398_402() {
    // 398: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_399_400();
    } else {
        sub_400_401();
    }
    // 401: nop
    return false;
}
bool sub_399_400() {
    // 399: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
    return false;
}
bool sub_400_401() {
    // 400: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
    return false;
}
bool sub_403_410() {
    // 403: mov
    reg_tmp2 = -reg_tmp15;
    // 404: dp3
    reg_tmp2.w = dot(vec3(reg_tmp2), vec3(reg_tmp2));
    // 405: rsq
    reg_tmp2.w = rsq_safe(reg_tmp2.wwww.x);
    // 406: mul
    reg_tmp2 = mul_safe(reg_tmp2, reg_tmp2.wwww);
    // 407: dp3
    reg_tmp1 = vec4(dot(vec3(reg_tmp2), vec3(reg_tmp14)));
    // 408: add
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    // 409: mad
    reg_tmp6 = fma_safe(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_410_414() {
    // 410: mov
    reg_tmp1.xy = (uniforms.f[94].zzzz).xy;
    // 411: mov
    reg_tmp1.zw = (uniforms.f[93].xxxx).zw;
    // 412: mad
    reg_tmp6 = fma_safe(reg_tmp14, reg_tmp1, reg_tmp1);
    // 413: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_414_438() {
    // 414: mov
    reg_tmp0.xy = (uniforms.f[10].yyyy).xy;
    // 415: ifu
    if (uniforms.b[10]) {
        sub_416_420();
    } else {
        sub_420_437();
    }
    // 437: nop
    return false;
}
bool sub_416_420() {
    // 416: call
    {
        sub_395_403();
    }
    // 417: dp4
    reg_tmp4.x = dot(uniforms.f[14].xywz, reg_tmp6);
    // 418: dp4
    reg_tmp4.y = dot(uniforms.f[15].xywz, reg_tmp6);
    // 419: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_420_437() {
    // 420: ifu
    if (uniforms.b[13]) {
        sub_421_435();
    } else {
        sub_435_436();
    }
    // 436: nop
    return false;
}
bool sub_421_435() {
    // 421: cmp
    conditional_code = equal(vec2(uniforms.f[95].xyyy), vec2(reg_tmp0.xyyy));
    // 422: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 423: ifc
    if (all(not(conditional_code))) {
        sub_424_431();
    } else {
        sub_431_434();
    }
    // 434: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_424_431() {
    // 424: mov
    reg_tmp6 = reg_tmp10;
    // 425: dp4
    reg_tmp4.x = dot(uniforms.f[14], reg_tmp6);
    // 426: dp4
    reg_tmp4.y = dot(uniforms.f[15], reg_tmp6);
    // 427: dp4
    reg_tmp4.z = dot(uniforms.f[16], reg_tmp6);
    // 428: rcp
    reg_tmp6.w = rcp_safe(reg_tmp4.zzzz.x);
    // 429: mul
    reg_tmp4.xy = (mul_safe(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    // 430: add
    reg_tmp4.xy = (uniforms.f[19].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_431_434() {
    // 431: call
    {
        sub_410_414();
    }
    // 432: dp4
    reg_tmp4.x = dot(uniforms.f[14], reg_tmp6);
    // 433: dp4
    reg_tmp4.y = dot(uniforms.f[15], reg_tmp6);
    return false;
}
bool sub_435_436() {
    // 435: mov
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_438_454() {
    // 438: mov
    reg_tmp0.xy = (uniforms.f[10].zzzz).xy;
    // 439: ifu
    if (uniforms.b[11]) {
        sub_440_444();
    } else {
        sub_444_453();
    }
    // 453: nop
    return false;
}
bool sub_440_444() {
    // 440: call
    {
        sub_395_403();
    }
    // 441: dp4
    reg_tmp5.x = dot(uniforms.f[17].xywz, reg_tmp6);
    // 442: dp4
    reg_tmp5.y = dot(uniforms.f[18].xywz, reg_tmp6);
    // 443: mov
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_444_453() {
    // 444: ifu
    if (uniforms.b[14]) {
        sub_445_451();
    } else {
        sub_451_452();
    }
    // 452: nop
    return false;
}
bool sub_445_451() {
    // 445: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 446: mov
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    // 447: call
    {
        sub_410_414();
    }
    // 448: dp4
    reg_tmp5.x = dot(uniforms.f[17], reg_tmp6);
    // 449: dp4
    reg_tmp5.y = dot(uniforms.f[18], reg_tmp6);
    // 450: mov
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_451_452() {
    // 451: mov
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
// reference: 33EDD03732A20AF5, C7F67128DB0FBE60
// program: C7F67128DB0FBE60, AD7922A63ED54CA7, 30DAB74CA24CBC58
// reference: AAB8A876E91BABB2, C7F67128DB0FBE60
// program: C7F67128DB0FBE60, AD7922A63ED54CA7, 21647988483E7BCD
// shader: 8B31, C537530F796D8F5E

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;
 out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define mul_safe(x, y) (x * y)
#define rcp_safe(x) (1.0f / x)
#define rsq_safe(x) inversesqrt(x)
#define fma_safe(x, y, z) fma(x, y, z)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_156_205();
bool sub_181_187();
bool sub_188_195();
bool sub_196_204();
bool sub_205_232();
bool sub_207_212();
bool sub_212_231();
bool sub_215_221();
bool sub_221_230();
bool sub_222_226();
bool sub_226_229();
bool sub_232_240();
bool sub_234_235();
bool sub_235_239();
bool sub_236_237();
bool sub_237_238();
bool sub_240_247();
bool sub_247_254();
bool sub_254_278();
bool sub_256_260();
bool sub_260_277();
bool sub_261_275();
bool sub_264_271();
bool sub_271_274();
bool sub_275_276();
bool sub_278_294();
bool sub_280_284();
bool sub_284_293();
bool sub_285_291();
bool sub_291_292();
bool sub_294_4096();
bool sub_296_298();
bool sub_298_299();
bool sub_304_325();
bool sub_325_339();
bool sub_339_391();
bool sub_363_367();
bool sub_389_390();

bool exec_shader() {
    sub_294_4096();
    return true;
}

bool sub_156_205() {
    // 156: mov
    reg_tmp1.xyz = (uniforms.f[93].xxyx).xyz;
    // 157: dp3
    reg_tmp8.x = dot(vec3(uniforms.f[0]), vec3(reg_tmp12.xyzz));
    // 158: dp3
    reg_tmp8.y = dot(vec3(uniforms.f[1]), vec3(reg_tmp12.xyzz));
    // 159: dp3
    reg_tmp8.z = dot(vec3(uniforms.f[2]), vec3(reg_tmp12.xyzz));
    // 160: dp3
    reg_tmp14.x = dot(vec3(uniforms.f[90]), vec3(reg_tmp8.xyzz));
    // 161: dp3
    reg_tmp14.y = dot(vec3(uniforms.f[91]), vec3(reg_tmp8.xyzz));
    // 162: dp3
    reg_tmp14.z = dot(vec3(uniforms.f[92]), vec3(reg_tmp8.xyzz));
    // 163: mov
    reg_tmp14.w = (uniforms.f[93].xxxx).w;
    // 164: mov
    reg_tmp8 = reg_tmp14;
    // 165: dp4
    reg_tmp14.x = dot(reg_tmp8, reg_tmp8);
    // 166: rsq
    reg_tmp14.x = rsq_safe(reg_tmp14.xxxx.x);
    // 167: mul
    reg_tmp14 = mul_safe(reg_tmp8, reg_tmp14.xxxx);
    // 168: mov
    reg_tmp0 = uniforms.f[23];
    // 169: dp3
    reg_tmp8.x = dot(vec3(uniforms.f[0]), vec3(reg_tmp0.xyzz));
    // 170: dp3
    reg_tmp8.y = dot(vec3(uniforms.f[1]), vec3(reg_tmp0.xyzz));
    // 171: dp3
    reg_tmp8.z = dot(vec3(uniforms.f[2]), vec3(reg_tmp0.xyzz));
    // 172: dp3
    reg_tmp6.x = dot(vec3(uniforms.f[90]), vec3(reg_tmp8.xyzz));
    // 173: dp3
    reg_tmp6.y = dot(vec3(uniforms.f[91]), vec3(reg_tmp8.xyzz));
    // 174: dp3
    reg_tmp6.z = dot(vec3(uniforms.f[92]), vec3(reg_tmp8.xyzz));
    // 175: add
    reg_tmp8.xyz = (reg_tmp6.xyzz + reg_tmp1.xyzz).xyz;
    // 176: mov
    reg_tmp8.w = (uniforms.f[93].xxxx).w;
    // 177: dp4
    reg_tmp0.x = dot(reg_tmp8, reg_tmp8);
    // 178: rsq
    reg_tmp0.x = rsq_safe(reg_tmp0.xxxx.x);
    // 179: mul
    reg_tmp0 = mul_safe(reg_tmp8, reg_tmp0.xxxx);
    // 180: ifu
    if (uniforms.b[5]) {
        sub_181_187();
    }
    // 187: ifu
    if (uniforms.b[3]) {
        sub_188_195();
    }
    // 195: ifu
    if (uniforms.b[4]) {
        sub_196_204();
    }
    // 204: mov
    vs_out_attr3 = reg_tmp2;
    return false;
}
bool sub_181_187() {
    // 181: dp3
    reg_tmp8.x = dot(vec3(reg_tmp14.xyzz), vec3(-reg_tmp6));
    // 182: dp3
    reg_tmp8.y = dot(vec3(reg_tmp1.xyzz), vec3(-reg_tmp6));
    // 183: max
    reg_tmp8 = max(uniforms.f[93].xxxx, reg_tmp8);
    // 184: mul
    reg_tmp8.y = (mul_safe(uniforms.f[94].zzzz, reg_tmp8.yyyy)).y;
    // 185: add
    reg_tmp8.y = (uniforms.f[94].zzzz + reg_tmp8.yyyy).y;
    // 186: mul
    reg_tmp2.y = (mul_safe(reg_tmp8.xxxx, reg_tmp8.yyyy)).y;
    return false;
}
bool sub_188_195() {
    // 188: dp3
    reg_tmp9.z = dot(vec3(reg_tmp14.xyzz), vec3(reg_tmp0));
    // 189: max
    reg_tmp9.z = (max(uniforms.f[93].xxxx, reg_tmp9.zzzz)).z;
    // 190: min
    reg_tmp9.z = (min(uniforms.f[93].yyyy, reg_tmp9.zzzz)).z;
    // 191: log
    reg_tmp9.z = log2(reg_tmp9.zzzz.x);
    // 192: mul
    reg_tmp9.z = (mul_safe(uniforms.f[22].zzzz, reg_tmp9.zzzz)).z;
    // 193: exp
    reg_tmp9.z = exp2(reg_tmp9.zzzz.x);
    // 194: mul
    reg_tmp2.z = (mul_safe(uniforms.f[22].wwww, reg_tmp9.zzzz)).z;
    return false;
}
bool sub_196_204() {
    // 196: dp3
    reg_tmp9.x = dot(vec3(reg_tmp14), vec3(reg_tmp1));
    // 197: max
    reg_tmp9.x = (max(uniforms.f[93].xxxx, reg_tmp9.xxxx)).x;
    // 198: min
    reg_tmp9.x = (min(uniforms.f[93].yyyy, reg_tmp9.xxxx)).x;
    // 199: add
    reg_tmp9.x = (uniforms.f[93].yyyy + -reg_tmp9.xxxx).x;
    // 200: log
    reg_tmp9.x = log2(reg_tmp9.xxxx.x);
    // 201: mul
    reg_tmp9.x = (mul_safe(uniforms.f[22].xxxx, reg_tmp9.xxxx)).x;
    // 202: exp
    reg_tmp9.x = exp2(reg_tmp9.xxxx.x);
    // 203: mul
    reg_tmp2.w = (mul_safe(uniforms.f[22].yyyy, reg_tmp9.xxxx)).w;
    return false;
}
bool sub_205_232() {
    // 205: mov
    reg_tmp0.xy = (uniforms.f[10].xxxx).xy;
    // 206: ifu
    if (uniforms.b[9]) {
        sub_207_212();
    } else {
        sub_212_231();
    }
    // 231: nop
    return false;
}
bool sub_207_212() {
    // 207: call
    {
        sub_232_240();
    }
    // 208: dp4
    reg_tmp3.x = dot(uniforms.f[11].xywz, reg_tmp6);
    // 209: dp4
    reg_tmp3.y = dot(uniforms.f[12].xywz, reg_tmp6);
    // 210: mov
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    // 211: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_212_231() {
    // 212: cmp
    conditional_code = equal(vec2(uniforms.f[95].xyyy), vec2(reg_tmp0.xyyy));
    // 213: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 214: ifc
    if (all(not(conditional_code))) {
        sub_215_221();
    } else {
        sub_221_230();
    }
    // 230: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_215_221() {
    // 215: mov
    reg_tmp6 = reg_tmp10;
    // 216: dp4
    reg_tmp3.x = dot(uniforms.f[11], reg_tmp6);
    // 217: dp4
    reg_tmp3.y = dot(uniforms.f[12], reg_tmp6);
    // 218: dp4
    reg_tmp3.z = dot(uniforms.f[13], reg_tmp6);
    // 219: mul
    reg_tmp0.xy = (mul_safe(uniforms.f[19].xyyy, reg_tmp3.zzzz)).xy;
    // 220: add
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_221_230() {
    // 221: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_222_226();
    } else {
        sub_226_229();
    }
    // 229: nop
    return false;
}
bool sub_222_226() {
    // 222: call
    {
        sub_240_247();
    }
    // 223: dp3
    reg_tmp3.x = dot(vec3(uniforms.f[11]), vec3(reg_tmp6));
    // 224: dp3
    reg_tmp3.y = dot(vec3(uniforms.f[12]), vec3(reg_tmp6));
    // 225: dp3
    reg_tmp3.z = dot(vec3(uniforms.f[13]), vec3(reg_tmp6));
    return false;
}
bool sub_226_229() {
    // 226: call
    {
        sub_247_254();
    }
    // 227: dp4
    reg_tmp3.x = dot(uniforms.f[11], reg_tmp6);
    // 228: dp4
    reg_tmp3.y = dot(uniforms.f[12], reg_tmp6);
    return false;
}
bool sub_232_240() {
    // 232: cmp
    conditional_code = equal(vec2(uniforms.f[93].yzzz), vec2(reg_tmp0.xyyy));
    // 233: ifc
    if (all(not(conditional_code))) {
        sub_234_235();
    } else {
        sub_235_239();
    }
    // 239: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_234_235() {
    // 234: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
    return false;
}
bool sub_235_239() {
    // 235: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_236_237();
    } else {
        sub_237_238();
    }
    // 238: nop
    return false;
}
bool sub_236_237() {
    // 236: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
    return false;
}
bool sub_237_238() {
    // 237: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
    return false;
}
bool sub_240_247() {
    // 240: mov
    reg_tmp2 = -reg_tmp15;
    // 241: dp3
    reg_tmp2.w = dot(vec3(reg_tmp2), vec3(reg_tmp2));
    // 242: rsq
    reg_tmp2.w = rsq_safe(reg_tmp2.wwww.x);
    // 243: mul
    reg_tmp2 = mul_safe(reg_tmp2, reg_tmp2.wwww);
    // 244: dp3
    reg_tmp1 = vec4(dot(vec3(reg_tmp2), vec3(reg_tmp14)));
    // 245: add
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    // 246: mad
    reg_tmp6 = fma_safe(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_247_254() {
    // 247: mov
    reg_tmp1.xy = (uniforms.f[94].zzzz).xy;
    // 248: mov
    reg_tmp1.zw = (uniforms.f[93].xxxx).zw;
    // 249: dp3
    reg_tmp6.x = dot(vec3(reg_tmp14), vec3(reg_tmp14));
    // 250: rsq
    reg_tmp6.x = rsq_safe(reg_tmp6.xxxx.x);
    // 251: mul
    reg_tmp14.xyz = (mul_safe(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
    // 252: mad
    reg_tmp6 = fma_safe(reg_tmp14, reg_tmp1, reg_tmp1);
    // 253: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_254_278() {
    // 254: mov
    reg_tmp0.xy = (uniforms.f[10].yyyy).xy;
    // 255: ifu
    if (uniforms.b[10]) {
        sub_256_260();
    } else {
        sub_260_277();
    }
    // 277: nop
    return false;
}
bool sub_256_260() {
    // 256: call
    {
        sub_232_240();
    }
    // 257: dp4
    reg_tmp4.x = dot(uniforms.f[14].xywz, reg_tmp6);
    // 258: dp4
    reg_tmp4.y = dot(uniforms.f[15].xywz, reg_tmp6);
    // 259: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_260_277() {
    // 260: ifu
    if (uniforms.b[13]) {
        sub_261_275();
    } else {
        sub_275_276();
    }
    // 276: nop
    return false;
}
bool sub_261_275() {
    // 261: cmp
    conditional_code = equal(vec2(uniforms.f[95].xyyy), vec2(reg_tmp0.xyyy));
    // 262: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 263: ifc
    if (all(not(conditional_code))) {
        sub_264_271();
    } else {
        sub_271_274();
    }
    // 274: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_264_271() {
    // 264: mov
    reg_tmp6 = reg_tmp10;
    // 265: dp4
    reg_tmp4.x = dot(uniforms.f[14], reg_tmp6);
    // 266: dp4
    reg_tmp4.y = dot(uniforms.f[15], reg_tmp6);
    // 267: dp4
    reg_tmp4.z = dot(uniforms.f[16], reg_tmp6);
    // 268: rcp
    reg_tmp6.w = rcp_safe(reg_tmp4.zzzz.x);
    // 269: mul
    reg_tmp4.xy = (mul_safe(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    // 270: add
    reg_tmp4.xy = (uniforms.f[19].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_271_274() {
    // 271: call
    {
        sub_247_254();
    }
    // 272: dp4
    reg_tmp4.x = dot(uniforms.f[14], reg_tmp6);
    // 273: dp4
    reg_tmp4.y = dot(uniforms.f[15], reg_tmp6);
    return false;
}
bool sub_275_276() {
    // 275: mov
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_278_294() {
    // 278: mov
    reg_tmp0.xy = (uniforms.f[10].zzzz).xy;
    // 279: ifu
    if (uniforms.b[11]) {
        sub_280_284();
    } else {
        sub_284_293();
    }
    // 293: nop
    return false;
}
bool sub_280_284() {
    // 280: call
    {
        sub_232_240();
    }
    // 281: dp4
    reg_tmp5.x = dot(uniforms.f[17].xywz, reg_tmp6);
    // 282: dp4
    reg_tmp5.y = dot(uniforms.f[18].xywz, reg_tmp6);
    // 283: mov
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_284_293() {
    // 284: ifu
    if (uniforms.b[14]) {
        sub_285_291();
    } else {
        sub_291_292();
    }
    // 292: nop
    return false;
}
bool sub_285_291() {
    // 285: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 286: mov
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    // 287: call
    {
        sub_247_254();
    }
    // 288: dp4
    reg_tmp5.x = dot(uniforms.f[17], reg_tmp6);
    // 289: dp4
    reg_tmp5.y = dot(uniforms.f[18], reg_tmp6);
    // 290: mov
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_291_292() {
    // 291: mov
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
bool sub_294_4096() {
    // 294: call
    {
        sub_339_391();
    }
    // 295: ifu
    if (uniforms.b[6]) {
        sub_296_298();
    } else {
        sub_298_299();
    }
    // 299: call
    {
        sub_205_232();
    }
    // 300: call
    {
        sub_254_278();
    }
    // 301: call
    {
        sub_278_294();
    }
    // 302: end
    return true;
}
bool sub_296_298() {
    // 296: call
    {
        sub_156_205();
    }
    // 297: nop
    return false;
}
bool sub_298_299() {
    // 298: mov
    vs_out_attr3 = uniforms.f[93].yyyy;
    return false;
}
bool sub_304_325() {
    // 304: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 305: dp4
    reg_tmp3.x = dot(uniforms.f[25 + address_registers.x], reg_tmp15);
    // 306: dp4
    reg_tmp3.y = dot(uniforms.f[26 + address_registers.x], reg_tmp15);
    // 307: dp4
    reg_tmp3.z = dot(uniforms.f[27 + address_registers.x], reg_tmp15);
    // 308: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 309: dp3
    reg_tmp3.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp14));
    // 310: dp3
    reg_tmp3.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp14));
    // 311: dp3
    reg_tmp3.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp14));
    // 312: mad
    reg_tmp12 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp12);
    // 313: dp3
    reg_tmp3.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp13));
    // 314: dp3
    reg_tmp3.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp13));
    // 315: dp3
    reg_tmp3.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp13));
    // 316: mad
    reg_tmp11 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp11);
    // 317: dp3
    reg_tmp3.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp5));
    // 318: dp3
    reg_tmp3.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp5));
    // 319: dp3
    reg_tmp3.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp5));
    // 320: mad
    reg_tmp9 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp9);
    // 321: dp3
    reg_tmp3.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp6));
    // 322: dp3
    reg_tmp3.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp6));
    // 323: dp3
    reg_tmp3.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp6));
    // 324: mad
    reg_tmp8 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp8);
    return false;
}
bool sub_325_339() {
    // 325: mul
    reg_tmp0.xyz = (mul_safe(reg_tmp9.yzxx, reg_tmp8.zxyy)).xyz;
    // 326: mad
    reg_tmp0.xyz = (fma_safe(-reg_tmp8.yzxx, reg_tmp9.zxyy, reg_tmp0)).xyz;
    // 327: mov
    reg_tmp1 = uniforms.f[23];
    // 328: dp4
    reg_tmp2.x = dot(reg_tmp1.xyzz, reg_tmp1.xyzz);
    // 329: rsq
    reg_tmp2.x = rsq_safe(reg_tmp2.xxxx.x);
    // 330: mul
    reg_tmp2.xyz = (mul_safe(reg_tmp1.xyzz, reg_tmp2.xxxx)).xyz;
    // 331: dp3
    reg_tmp1.x = dot(vec3(reg_tmp2), vec3(reg_tmp8.xyzz));
    // 332: dp3
    reg_tmp1.y = dot(vec3(reg_tmp2), vec3(reg_tmp0.xyzz));
    // 333: dp3
    reg_tmp1.z = dot(vec3(reg_tmp2), vec3(reg_tmp9.xyzz));
    // 334: dp4
    reg_tmp2.x = dot(reg_tmp1.xyzz, reg_tmp1.xyzz);
    // 335: rsq
    reg_tmp2.x = rsq_safe(reg_tmp2.xxxx.x);
    // 336: mul
    reg_tmp2.xyz = (mul_safe(reg_tmp1.xyzz, reg_tmp2.xxxx)).xyz;
    // 337: mov
    reg_tmp2.w = (uniforms.f[93].yyyy).w;
    // 338: mov
    vs_out_attr2 = reg_tmp2;
    return false;
}
bool sub_339_391() {
    // 339: mul
    reg_tmp15.xyz = (mul_safe(uniforms.f[7].xxxx, vs_in_reg0)).xyz;
    // 340: mul
    reg_tmp14.xyz = (mul_safe(uniforms.f[7].yyyy, vs_in_reg1)).xyz;
    // 341: mul
    reg_tmp13.xyz = (mul_safe(uniforms.f[7].zzzz, vs_in_reg2)).xyz;
    // 342: add
    reg_tmp15.xyz = (uniforms.f[6] + reg_tmp15).xyz;
    // 343: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 344: mov
    reg_tmp5 = uniforms.f[93].xxyy;
    // 345: mov
    reg_tmp6 = uniforms.f[93].yxxy;
    // 346: mov
    reg_tmp7 = uniforms.f[93].xxxx;
    // 347: mov
    reg_tmp12 = uniforms.f[93].xxxx;
    // 348: mov
    reg_tmp11 = uniforms.f[93].xxxx;
    // 349: mov
    reg_tmp9 = uniforms.f[93].xxxx;
    // 350: mov
    reg_tmp8 = uniforms.f[93].xxxx;
    // 351: mul
    reg_tmp2 = mul_safe(uniforms.f[93].wwww, vs_in_reg7);
    // 352: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 353: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 354: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 355: call
    {
        sub_304_325();
    }
    // 356: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 357: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 358: call
    {
        sub_304_325();
    }
    // 359: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 360: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 361: callc
    if (conditional_code.x) {
        sub_304_325();
    }
    // 362: ifu
    if (uniforms.b[8]) {
        sub_363_367();
    }
    // 367: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 368: mov
    reg_tmp10 = reg_tmp7;
    // 369: dp3
    reg_tmp13.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp11));
    // 370: dp3
    reg_tmp13.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp11));
    // 371: dp3
    reg_tmp13.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp11));
    // 372: dp3
    reg_tmp14.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp12));
    // 373: dp3
    reg_tmp14.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp12));
    // 374: dp3
    reg_tmp14.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp12));
    // 375: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 376: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 377: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 378: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 379: call
    {
        sub_325_339();
    }
    // 380: mov
    vs_out_attr1 = uniforms.f[93].xxxy;
    // 381: dp4
    reg_tmp0.x = dot(uniforms.f[86], reg_tmp15);
    // 382: dp4
    reg_tmp0.y = dot(uniforms.f[87], reg_tmp15);
    // 383: dp4
    reg_tmp0.z = dot(uniforms.f[88], reg_tmp15);
    // 384: dp4
    reg_tmp0.w = dot(uniforms.f[89], reg_tmp15);
    // 385: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 386: mul
    reg_tmp1.y = (mul_safe(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
    // 387: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 388: ifc
    if (all(conditional_code)) {
        sub_389_390();
    }
    // 390: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_363_367() {
    // 363: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 364: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 365: callc
    if (conditional_code.y) {
        sub_304_325();
    }
    // 366: nop
    return false;
}
bool sub_389_390() {
    // 389: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
// reference: B4A87EE3AC4C9A79, C537530F796D8F5E
// program: C537530F796D8F5E, AD7922A63ED54CA7, 3E5CAFDBABD516C0
// reference: 2DFD06A298CCA87F, C537530F796D8F5E
// program: C537530F796D8F5E, AD7922A63ED54CA7, E14D0525B6AB8EC9
// program: C537530F796D8F5E, AD7922A63ED54CA7, CCB52BD33F912CFA
// program: C537530F796D8F5E, AD7922A63ED54CA7, 57B333648195A2F8
// shader: 8B31, 35F6C85AC819B073

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;
 out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define mul_safe(x, y) (x * y)
#define rcp_safe(x) (1.0f / x)
#define rsq_safe(x) inversesqrt(x)
#define fma_safe(x, y, z) fma(x, y, z)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_4096();
bool sub_10_28();
bool sub_16_21();
bool sub_18_19();
bool sub_25_26();
bool sub_28_74();
bool sub_32_73();
bool sub_37_39();
bool sub_39_63();
bool sub_42_47();
bool sub_53_62();
bool sub_57_58();
bool sub_58_61();
bool sub_65_72();
bool sub_74_84();
bool sub_81_82();
bool sub_84_111();
bool sub_86_91();
bool sub_91_110();
bool sub_94_100();
bool sub_100_109();
bool sub_101_105();
bool sub_105_108();
bool sub_111_119();
bool sub_113_114();
bool sub_114_118();
bool sub_115_116();
bool sub_116_117();
bool sub_119_126();
bool sub_126_130();
bool sub_130_154();
bool sub_132_136();
bool sub_136_153();
bool sub_137_151();
bool sub_140_147();
bool sub_147_150();
bool sub_151_152();
bool sub_154_170();
bool sub_156_160();
bool sub_160_169();
bool sub_161_167();
bool sub_167_168();

bool exec_shader() {
    sub_0_4096();
    return true;
}

bool sub_0_4096() {
    // 0: mov
    reg_tmp0 = vs_in_reg0;
    // 1: mov
    vs_out_attr0 = reg_tmp0;
    // 2: mov
    vs_out_attr2 = reg_tmp0;
    // 3: mov
    vs_out_attr1 = reg_tmp0;
    // 4: call
    {
        sub_10_28();
    }
    // 5: call
    {
        sub_84_111();
    }
    // 6: call
    {
        sub_130_154();
    }
    // 7: call
    {
        sub_154_170();
    }
    // 8: end
    return true;
}
bool sub_10_28() {
    // 10: mov
    reg_tmp8.xy = (uniforms.f[93].xxxx).xy;
    // 11: mov
    reg_tmp0.y = (uniforms.f[7].wwww).y;
    // 12: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.xyyy));
    // 13: mov
    reg_tmp9.xyz = (uniforms.f[93].xxxx).xyz;
    // 14: mov
    reg_tmp9.w = (uniforms.f[21].wwww).w;
    // 15: ifc
    if (conditional_code.y) {
        sub_16_21();
    }
    // 21: callu
    if (uniforms.b[12]) {
        sub_28_74();
    }
    // 22: callu
    if (uniforms.b[5]) {
        sub_74_84();
    }
    // 23: cmp
    conditional_code = equal(vec2(uniforms.f[93].xxxx), vec2(reg_tmp8.xyyy));
    // 24: ifc
    if (all(conditional_code)) {
        sub_25_26();
    }
    // 26: add
    reg_tmp9 = uniforms.f[74] + reg_tmp9;
    // 27: max
    vs_out_attr3 = max(uniforms.f[93].xxxx, reg_tmp9);
    return false;
}
bool sub_16_21() {
    // 16: mul
    reg_tmp0 = mul_safe(uniforms.f[7].wwww, vs_in_reg3);
    // 17: ifu
    if (uniforms.b[7]) {
        sub_18_19();
    }
    // 19: mul
    reg_tmp9.xyz = (mul_safe(uniforms.f[20].wwww, reg_tmp0.xyzz)).xyz;
    // 20: mov
    reg_tmp8.x = (uniforms.f[93].yyyy).x;
    return false;
}
bool sub_18_19() {
    // 18: mul
    reg_tmp9.w = (mul_safe(reg_tmp9.wwww, reg_tmp0.wwww)).w;
    return false;
}
bool sub_25_26() {
    // 25: mov
    reg_tmp9 = uniforms.f[21];
    return false;
}
bool sub_28_74() {
    // 28: mov
    reg_tmp1 = uniforms.f[20];
    // 29: mov
    reg_tmp2 = uniforms.f[21];
    // 30: mov
    reg_tmp3 = uniforms.f[93].xxxx;
    // 31: loop
    address_registers.z = int(uniforms.i[0].y);
    for (uint loop31 = 0u; loop31 <= uniforms.i[0].x; address_registers.z += int(uniforms.i[0].z), ++loop31) {
        sub_32_73();
    }
    // 73: mov
    reg_tmp8.x = (uniforms.f[93].yyyy).x;
    return false;
}
bool sub_32_73() {
    // 32: mova
    address_registers.x = (ivec2(reg_tmp3)).x;
    // 33: mov
    reg_tmp4.x = (uniforms.f[69 + address_registers.x].wwww).x;
    // 34: mov
    reg_tmp4.y = (uniforms.f[71 + address_registers.x].wwww).y;
    // 35: cmp
    conditional_code = equal(vec2(uniforms.f[93].xyyy), vec2(reg_tmp4.xyyy));
    // 36: ifc
    if (conditional_code.x) {
        sub_37_39();
    } else {
        sub_39_63();
    }
    // 63: cmp
    conditional_code.x = uniforms.f[93].xxxx.x == reg_tmp6.xyyy.x;
    conditional_code.y = uniforms.f[93].xxxx.y < reg_tmp6.xyyy.y;
    // 64: ifc
    if (conditional_code.y) {
        sub_65_72();
    }
    // 72: add
    reg_tmp3 = -uniforms.f[95].wwww + reg_tmp3;
    return false;
}
bool sub_37_39() {
    // 37: dp3
    reg_tmp6.x = dot(vec3(uniforms.f[69 + address_registers.x]), vec3(reg_tmp14));
    // 38: mov
    reg_tmp6.y = (uniforms.f[93].yyyy).y;
    return false;
}
bool sub_39_63() {
    // 39: add
    reg_tmp4 = uniforms.f[69 + address_registers.x] + -reg_tmp15;
    // 40: mov
    reg_tmp6.y = (uniforms.f[93].yyyy).y;
    // 41: ifc
    if (conditional_code.y) {
        sub_42_47();
    }
    // 47: mov
    reg_tmp5 = uniforms.f[70 + address_registers.x];
    // 48: cmp
    conditional_code = equal(vec2(uniforms.f[93].yyyy), vec2(reg_tmp5.wwww));
    // 49: dp3
    reg_tmp4.w = dot(vec3(reg_tmp4), vec3(reg_tmp4));
    // 50: rsq
    reg_tmp4.w = rsq_safe(reg_tmp4.wwww.x);
    // 51: mul
    reg_tmp4 = mul_safe(reg_tmp4, reg_tmp4.wwww);
    // 52: ifc
    if (conditional_code.x) {
        sub_53_62();
    }
    // 62: dp3
    reg_tmp6.x = dot(vec3(reg_tmp14), vec3(reg_tmp4));
    return false;
}
bool sub_42_47() {
    // 42: mov
    reg_tmp5.x = (uniforms.f[93].yyyy).x;
    // 43: dp3
    reg_tmp5.z = dot(vec3(reg_tmp4), vec3(reg_tmp4));
    // 44: mul
    reg_tmp5.y = (mul_safe(reg_tmp5.zzzz, reg_tmp5.zzzz)).y;
    // 45: dp3
    reg_tmp6.y = dot(vec3(uniforms.f[71 + address_registers.x]), vec3(reg_tmp5));
    // 46: rcp
    reg_tmp6.y = rcp_safe(reg_tmp6.yyyy.x);
    return false;
}
bool sub_53_62() {
    // 53: dp3
    reg_tmp5.x = dot(vec3(uniforms.f[70 + address_registers.x]), vec3(-reg_tmp4));
    // 54: slti
    reg_tmp5.y = (vec4(lessThan(reg_tmp5.xxxx,uniforms.f[72 + address_registers.x].yyyy))).y;
    // 55: cmp
    conditional_code = equal(vec2(uniforms.f[93].yyyy), vec2(reg_tmp5.xyyy));
    // 56: ifc
    if (conditional_code.y) {
        sub_57_58();
    } else {
        sub_58_61();
    }
    // 61: mul
    reg_tmp6.y = (mul_safe(reg_tmp6.yyyy, reg_tmp5.xxxx)).y;
    return false;
}
bool sub_57_58() {
    // 57: mov
    reg_tmp5.x = (uniforms.f[93].xxxx).x;
    return false;
}
bool sub_58_61() {
    // 58: log
    reg_tmp5.y = log2(reg_tmp5.xxxx.x);
    // 59: mul
    reg_tmp5.y = (mul_safe(uniforms.f[72 + address_registers.x].xxxx, reg_tmp5.yyyy)).y;
    // 60: exp
    reg_tmp5.x = exp2(reg_tmp5.yyyy.x);
    return false;
}
bool sub_65_72() {
    // 65: max
    reg_tmp6.x = (max(uniforms.f[93].xxxx, reg_tmp6.xxxx)).x;
    // 66: mad
    reg_tmp9.xyz = (fma_safe(reg_tmp1.xyzz, uniforms.f[67 + address_registers.x].xyzz, reg_tmp9.xyzz)).xyz;
    // 67: mul
    reg_tmp4 = mul_safe(uniforms.f[68 + address_registers.x], reg_tmp2);
    // 68: mul
    reg_tmp5.xyz = (mul_safe(reg_tmp6.xxxx, reg_tmp4.xyzz)).xyz;
    // 69: mul
    reg_tmp5.xyz = (mul_safe(reg_tmp6.yyyy, reg_tmp5.xyzz)).xyz;
    // 70: add
    reg_tmp9.xyz = (reg_tmp9.xyzz + reg_tmp5.xyzz).xyz;
    // 71: add
    reg_tmp9.w = (reg_tmp9.wwww + reg_tmp4.wwww).w;
    return false;
}
bool sub_74_84() {
    // 74: dp3
    reg_tmp1 = vec4(dot(vec3(uniforms.f[24]), vec3(reg_tmp14)));
    // 75: mov
    reg_tmp2 = uniforms.f[24].wwww;
    // 76: mad
    reg_tmp1 = fma_safe(reg_tmp1, reg_tmp2, reg_tmp2);
    // 77: mov
    reg_tmp3 = uniforms.f[22];
    // 78: add
    reg_tmp2 = uniforms.f[23] + -reg_tmp3;
    // 79: mad
    reg_tmp4 = fma_safe(reg_tmp2, reg_tmp1, reg_tmp3);
    // 80: ifu
    if (uniforms.b[6]) {
        sub_81_82();
    }
    // 82: mad
    reg_tmp9.xyz = (fma_safe(reg_tmp4, uniforms.f[21], reg_tmp9)).xyz;
    // 83: mov
    reg_tmp8.x = (uniforms.f[93].yyyy).x;
    return false;
}
bool sub_81_82() {
    // 81: mul
    reg_tmp4 = mul_safe(reg_tmp4, reg_tmp9.wwww);
    return false;
}
bool sub_84_111() {
    // 84: mov
    reg_tmp0.xy = (uniforms.f[10].xxxx).xy;
    // 85: ifu
    if (uniforms.b[9]) {
        sub_86_91();
    } else {
        sub_91_110();
    }
    // 110: nop
    return false;
}
bool sub_86_91() {
    // 86: call
    {
        sub_111_119();
    }
    // 87: dp4
    reg_tmp3.x = dot(uniforms.f[11].xywz, reg_tmp6);
    // 88: dp4
    reg_tmp3.y = dot(uniforms.f[12].xywz, reg_tmp6);
    // 89: mov
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    // 90: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_91_110() {
    // 91: cmp
    conditional_code = equal(vec2(uniforms.f[95].xyyy), vec2(reg_tmp0.xyyy));
    // 92: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 93: ifc
    if (all(not(conditional_code))) {
        sub_94_100();
    } else {
        sub_100_109();
    }
    // 109: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_94_100() {
    // 94: mov
    reg_tmp6 = reg_tmp10;
    // 95: dp4
    reg_tmp3.x = dot(uniforms.f[11], reg_tmp6);
    // 96: dp4
    reg_tmp3.y = dot(uniforms.f[12], reg_tmp6);
    // 97: dp4
    reg_tmp3.z = dot(uniforms.f[13], reg_tmp6);
    // 98: mul
    reg_tmp0.xy = (mul_safe(uniforms.f[19].xyyy, reg_tmp3.zzzz)).xy;
    // 99: add
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_100_109() {
    // 100: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_101_105();
    } else {
        sub_105_108();
    }
    // 108: nop
    return false;
}
bool sub_101_105() {
    // 101: call
    {
        sub_119_126();
    }
    // 102: dp3
    reg_tmp3.x = dot(vec3(uniforms.f[11]), vec3(reg_tmp6));
    // 103: dp3
    reg_tmp3.y = dot(vec3(uniforms.f[12]), vec3(reg_tmp6));
    // 104: dp3
    reg_tmp3.z = dot(vec3(uniforms.f[13]), vec3(reg_tmp6));
    return false;
}
bool sub_105_108() {
    // 105: call
    {
        sub_126_130();
    }
    // 106: dp4
    reg_tmp3.x = dot(uniforms.f[11], reg_tmp6);
    // 107: dp4
    reg_tmp3.y = dot(uniforms.f[12], reg_tmp6);
    return false;
}
bool sub_111_119() {
    // 111: cmp
    conditional_code = equal(vec2(uniforms.f[93].yzzz), vec2(reg_tmp0.xyyy));
    // 112: ifc
    if (all(not(conditional_code))) {
        sub_113_114();
    } else {
        sub_114_118();
    }
    // 118: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_113_114() {
    // 113: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
    return false;
}
bool sub_114_118() {
    // 114: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_115_116();
    } else {
        sub_116_117();
    }
    // 117: nop
    return false;
}
bool sub_115_116() {
    // 115: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
    return false;
}
bool sub_116_117() {
    // 116: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
    return false;
}
bool sub_119_126() {
    // 119: mov
    reg_tmp2 = -reg_tmp15;
    // 120: dp3
    reg_tmp2.w = dot(vec3(reg_tmp2), vec3(reg_tmp2));
    // 121: rsq
    reg_tmp2.w = rsq_safe(reg_tmp2.wwww.x);
    // 122: mul
    reg_tmp2 = mul_safe(reg_tmp2, reg_tmp2.wwww);
    // 123: dp3
    reg_tmp1 = vec4(dot(vec3(reg_tmp2), vec3(reg_tmp14)));
    // 124: add
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    // 125: mad
    reg_tmp6 = fma_safe(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_126_130() {
    // 126: mov
    reg_tmp1.xy = (uniforms.f[94].zzzz).xy;
    // 127: mov
    reg_tmp1.zw = (uniforms.f[93].xxxx).zw;
    // 128: mad
    reg_tmp6 = fma_safe(reg_tmp14, reg_tmp1, reg_tmp1);
    // 129: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_130_154() {
    // 130: mov
    reg_tmp0.xy = (uniforms.f[10].yyyy).xy;
    // 131: ifu
    if (uniforms.b[10]) {
        sub_132_136();
    } else {
        sub_136_153();
    }
    // 153: nop
    return false;
}
bool sub_132_136() {
    // 132: call
    {
        sub_111_119();
    }
    // 133: dp4
    reg_tmp4.x = dot(uniforms.f[14].xywz, reg_tmp6);
    // 134: dp4
    reg_tmp4.y = dot(uniforms.f[15].xywz, reg_tmp6);
    // 135: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_136_153() {
    // 136: ifu
    if (uniforms.b[13]) {
        sub_137_151();
    } else {
        sub_151_152();
    }
    // 152: nop
    return false;
}
bool sub_137_151() {
    // 137: cmp
    conditional_code = equal(vec2(uniforms.f[95].xyyy), vec2(reg_tmp0.xyyy));
    // 138: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 139: ifc
    if (all(not(conditional_code))) {
        sub_140_147();
    } else {
        sub_147_150();
    }
    // 150: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_140_147() {
    // 140: mov
    reg_tmp6 = reg_tmp10;
    // 141: dp4
    reg_tmp4.x = dot(uniforms.f[14], reg_tmp6);
    // 142: dp4
    reg_tmp4.y = dot(uniforms.f[15], reg_tmp6);
    // 143: dp4
    reg_tmp4.z = dot(uniforms.f[16], reg_tmp6);
    // 144: rcp
    reg_tmp6.w = rcp_safe(reg_tmp4.zzzz.x);
    // 145: mul
    reg_tmp4.xy = (mul_safe(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    // 146: add
    reg_tmp4.xy = (uniforms.f[19].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_147_150() {
    // 147: call
    {
        sub_126_130();
    }
    // 148: dp4
    reg_tmp4.x = dot(uniforms.f[14], reg_tmp6);
    // 149: dp4
    reg_tmp4.y = dot(uniforms.f[15], reg_tmp6);
    return false;
}
bool sub_151_152() {
    // 151: mov
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_154_170() {
    // 154: mov
    reg_tmp0.xy = (uniforms.f[10].zzzz).xy;
    // 155: ifu
    if (uniforms.b[11]) {
        sub_156_160();
    } else {
        sub_160_169();
    }
    // 169: nop
    return false;
}
bool sub_156_160() {
    // 156: call
    {
        sub_111_119();
    }
    // 157: dp4
    reg_tmp5.x = dot(uniforms.f[17].xywz, reg_tmp6);
    // 158: dp4
    reg_tmp5.y = dot(uniforms.f[18].xywz, reg_tmp6);
    // 159: mov
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_160_169() {
    // 160: ifu
    if (uniforms.b[14]) {
        sub_161_167();
    } else {
        sub_167_168();
    }
    // 168: nop
    return false;
}
bool sub_161_167() {
    // 161: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 162: mov
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    // 163: call
    {
        sub_126_130();
    }
    // 164: dp4
    reg_tmp5.x = dot(uniforms.f[17], reg_tmp6);
    // 165: dp4
    reg_tmp5.y = dot(uniforms.f[18], reg_tmp6);
    // 166: mov
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_167_168() {
    // 167: mov
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
// reference: 7F396EB5479F10B7, 35F6C85AC819B073
// program: 35F6C85AC819B073, AD7922A63ED54CA7, D375021927AD9455
// reference: E66C16F49C26B1F0, 35F6C85AC819B073
// program: 35F6C85AC819B073, AD7922A63ED54CA7, 8A76329CB25030B1
// program: 35F6C85AC819B073, AD7922A63ED54CA7, FB2B5B4178346715
// reference: 0A91483B58F61A2B, 7CF7B3710EA67233
// reference: 93C4307A834FBB6C, 7CF7B3710EA67233
// reference: CC00F80C309BC213, AE0AE260B2F14D0F
// program: AE0AE260B2F14D0F, 5D764F9A6220D694, 111FE465C686BF45
// program: AE0AE260B2F14D0F, 5D764F9A6220D694, 1E54EFAB20B0B715
// program: C537530F796D8F5E, AD7922A63ED54CA7, 3EE0A9C0C99022B5
// program: C537530F796D8F5E, AD7922A63ED54CA7, EC9FE318D844A6A2
// program: C537530F796D8F5E, AD7922A63ED54CA7, 08EDF1F3379D61F4
// reference: AAB8A876062238F3, C7F67128DB0FBE60
// program: 35F6C85AC819B073, AD7922A63ED54CA7, 10ADC50FC532FE6E
// shader: 8B31, DFFAEC9E8E4C8459

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;
 out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define mul_safe(x, y) (x * y)
#define rcp_safe(x) (1.0f / x)
#define rsq_safe(x) inversesqrt(x)
#define fma_safe(x, y, z) fma(x, y, z)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_4096();
bool sub_7_12();
bool sub_12_21();
bool sub_21_34();
bool sub_34_214();
bool sub_40_146();
bool sub_47_76();
bool sub_58_62();
bool sub_76_135();
bool sub_77_109();
bool sub_88_92();
bool sub_109_134();
bool sub_120_124();
bool sub_144_145();
bool sub_146_213();
bool sub_149_159();
bool sub_159_164();
bool sub_165_177();
bool sub_177_202();
bool sub_178_196();
bool sub_196_201();
bool sub_211_212();
bool sub_214_231();
bool sub_231_307();
bool sub_270_290();
bool sub_271_276();
bool sub_276_289();
bool sub_280_283();
bool sub_283_288();
bool sub_290_303();
bool sub_291_296();
bool sub_296_302();
bool sub_307_330();
bool sub_330_357();
bool sub_332_337();
bool sub_337_356();
bool sub_340_346();
bool sub_346_355();
bool sub_347_351();
bool sub_351_354();
bool sub_357_365();
bool sub_359_360();
bool sub_360_364();
bool sub_361_362();
bool sub_362_363();
bool sub_365_372();
bool sub_372_376();
bool sub_376_400();
bool sub_378_382();
bool sub_382_399();
bool sub_383_397();
bool sub_386_393();
bool sub_393_396();
bool sub_397_398();
bool sub_400_416();
bool sub_402_406();
bool sub_406_415();
bool sub_407_413();
bool sub_413_414();

bool exec_shader() {
    sub_0_4096();
    return true;
}

bool sub_0_4096() {
    // 0: call
    {
        sub_34_214();
    }
    // 1: call
    {
        sub_307_330();
    }
    // 2: call
    {
        sub_330_357();
    }
    // 3: call
    {
        sub_376_400();
    }
    // 4: call
    {
        sub_400_416();
    }
    // 5: end
    return true;
}
bool sub_7_12() {
    // 7: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 8: dp4
    reg_tmp3.x = dot(uniforms.f[25 + address_registers.x], reg_tmp15);
    // 9: dp4
    reg_tmp3.y = dot(uniforms.f[26 + address_registers.x], reg_tmp15);
    // 10: dp4
    reg_tmp3.z = dot(uniforms.f[27 + address_registers.x], reg_tmp15);
    // 11: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    return false;
}
bool sub_12_21() {
    // 12: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 13: dp4
    reg_tmp3.x = dot(uniforms.f[25 + address_registers.x], reg_tmp15);
    // 14: dp4
    reg_tmp3.y = dot(uniforms.f[26 + address_registers.x], reg_tmp15);
    // 15: dp4
    reg_tmp3.z = dot(uniforms.f[27 + address_registers.x], reg_tmp15);
    // 16: dp3
    reg_tmp4.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp14));
    // 17: dp3
    reg_tmp4.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp14));
    // 18: dp3
    reg_tmp4.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp14));
    // 19: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 20: mad
    reg_tmp12 = fma_safe(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_21_34() {
    // 21: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 22: dp4
    reg_tmp3.x = dot(uniforms.f[25 + address_registers.x], reg_tmp15);
    // 23: dp4
    reg_tmp3.y = dot(uniforms.f[26 + address_registers.x], reg_tmp15);
    // 24: dp4
    reg_tmp3.z = dot(uniforms.f[27 + address_registers.x], reg_tmp15);
    // 25: dp3
    reg_tmp4.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp14));
    // 26: dp3
    reg_tmp4.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp14));
    // 27: dp3
    reg_tmp4.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp14));
    // 28: dp3
    reg_tmp5.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp13));
    // 29: dp3
    reg_tmp5.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp13));
    // 30: dp3
    reg_tmp5.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp13));
    // 31: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 32: mad
    reg_tmp12 = fma_safe(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    // 33: mad
    reg_tmp11 = fma_safe(reg_tmp1.wwww, reg_tmp5, reg_tmp11);
    return false;
}
bool sub_34_214() {
    // 34: mul
    reg_tmp15.xyz = (mul_safe(uniforms.f[7].xxxx, vs_in_reg0)).xyz;
    // 35: mul
    reg_tmp14.xyz = (mul_safe(uniforms.f[7].yyyy, vs_in_reg1)).xyz;
    // 36: mul
    reg_tmp13.xyz = (mul_safe(uniforms.f[7].zzzz, vs_in_reg2)).xyz;
    // 37: add
    reg_tmp15.xyz = (uniforms.f[6] + reg_tmp15).xyz;
    // 38: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 39: ifu
    if (uniforms.b[1]) {
        sub_40_146();
    } else {
        sub_146_213();
    }
    // 213: nop
    return false;
}
bool sub_40_146() {
    // 40: mov
    reg_tmp0 = uniforms.f[7];
    // 41: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.yzzz));
    // 42: mov
    reg_tmp7 = uniforms.f[93].xxxx;
    // 43: mov
    reg_tmp12 = uniforms.f[93].xxxx;
    // 44: mov
    reg_tmp11 = uniforms.f[93].xxxx;
    // 45: mul
    reg_tmp2 = mul_safe(uniforms.f[93].wwww, vs_in_reg7);
    // 46: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_47_76();
    } else {
        sub_76_135();
    }
    // 135: mov
    vs_out_attr2 = -reg_tmp15;
    // 136: dp4
    reg_tmp0.x = dot(uniforms.f[86], reg_tmp15);
    // 137: dp4
    reg_tmp0.y = dot(uniforms.f[87], reg_tmp15);
    // 138: dp4
    reg_tmp0.z = dot(uniforms.f[88], reg_tmp15);
    // 139: dp4
    reg_tmp0.w = dot(uniforms.f[89], reg_tmp15);
    // 140: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 141: mul
    reg_tmp1.y = (mul_safe(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
    // 142: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 143: ifc
    if (all(conditional_code)) {
        sub_144_145();
    }
    // 145: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_47_76() {
    // 47: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 48: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 49: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 50: call
    {
        sub_12_21();
    }
    // 51: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 52: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 53: call
    {
        sub_12_21();
    }
    // 54: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 55: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 56: callc
    if (conditional_code.x) {
        sub_12_21();
    }
    // 57: ifu
    if (uniforms.b[8]) {
        sub_58_62();
    }
    // 62: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 63: dp4
    reg_tmp10.x = dot(uniforms.f[0], reg_tmp7);
    // 64: dp4
    reg_tmp10.y = dot(uniforms.f[1], reg_tmp7);
    // 65: dp4
    reg_tmp10.z = dot(uniforms.f[2], reg_tmp7);
    // 66: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 67: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 68: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 69: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 70: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 71: dp3
    reg_tmp14.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp12));
    // 72: dp3
    reg_tmp14.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp12));
    // 73: dp3
    reg_tmp14.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp12));
    // 74: call
    {
        sub_214_231();
    }
    // 75: nop
    return false;
}
bool sub_58_62() {
    // 58: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 59: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 60: callc
    if (conditional_code.y) {
        sub_12_21();
    }
    // 61: nop
    return false;
}
bool sub_76_135() {
    // 76: ifc
    if (all(conditional_code)) {
        sub_77_109();
    } else {
        sub_109_134();
    }
    // 134: nop
    return false;
}
bool sub_77_109() {
    // 77: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 78: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 79: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 80: call
    {
        sub_21_34();
    }
    // 81: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 82: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 83: call
    {
        sub_21_34();
    }
    // 84: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 85: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 86: callc
    if (conditional_code.x) {
        sub_21_34();
    }
    // 87: ifu
    if (uniforms.b[8]) {
        sub_88_92();
    }
    // 92: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 93: dp4
    reg_tmp10.x = dot(uniforms.f[0], reg_tmp7);
    // 94: dp4
    reg_tmp10.y = dot(uniforms.f[1], reg_tmp7);
    // 95: dp4
    reg_tmp10.z = dot(uniforms.f[2], reg_tmp7);
    // 96: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 97: dp3
    reg_tmp13.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp11));
    // 98: dp3
    reg_tmp13.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp11));
    // 99: dp3
    reg_tmp13.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp11));
    // 100: dp3
    reg_tmp14.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp12));
    // 101: dp3
    reg_tmp14.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp12));
    // 102: dp3
    reg_tmp14.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp12));
    // 103: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 104: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 105: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 106: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 107: call
    {
        sub_231_307();
    }
    // 108: nop
    return false;
}
bool sub_88_92() {
    // 88: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 89: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 90: callc
    if (conditional_code.y) {
        sub_21_34();
    }
    // 91: nop
    return false;
}
bool sub_109_134() {
    // 109: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 110: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 111: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 112: call
    {
        sub_7_12();
    }
    // 113: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 114: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 115: call
    {
        sub_7_12();
    }
    // 116: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 117: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 118: callc
    if (conditional_code.x) {
        sub_7_12();
    }
    // 119: ifu
    if (uniforms.b[8]) {
        sub_120_124();
    }
    // 124: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 125: dp4
    reg_tmp10.x = dot(uniforms.f[0], reg_tmp7);
    // 126: dp4
    reg_tmp10.y = dot(uniforms.f[1], reg_tmp7);
    // 127: dp4
    reg_tmp10.z = dot(uniforms.f[2], reg_tmp7);
    // 128: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 129: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 130: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 131: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 132: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 133: mov
    vs_out_attr1 = uniforms.f[93].xxxx;
    return false;
}
bool sub_120_124() {
    // 120: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 121: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 122: callc
    if (conditional_code.y) {
        sub_7_12();
    }
    // 123: nop
    return false;
}
bool sub_144_145() {
    // 144: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_146_213() {
    // 146: mov
    reg_tmp0 = uniforms.f[7];
    // 147: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.yzzz));
    // 148: ifu
    if (uniforms.b[2]) {
        sub_149_159();
    } else {
        sub_159_164();
    }
    // 164: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_165_177();
    } else {
        sub_177_202();
    }
    // 202: mov
    vs_out_attr2 = -reg_tmp15;
    // 203: dp4
    reg_tmp0.x = dot(uniforms.f[86], reg_tmp15);
    // 204: dp4
    reg_tmp0.y = dot(uniforms.f[87], reg_tmp15);
    // 205: dp4
    reg_tmp0.z = dot(uniforms.f[88], reg_tmp15);
    // 206: dp4
    reg_tmp0.w = dot(uniforms.f[89], reg_tmp15);
    // 207: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 208: mul
    reg_tmp1.y = (mul_safe(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
    // 209: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 210: ifc
    if (all(conditional_code)) {
        sub_211_212();
    }
    // 212: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_149_159() {
    // 149: mul
    reg_tmp1.x = (mul_safe(uniforms.f[93].wwww, vs_in_reg7.xxxx)).x;
    // 150: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 151: dp4
    reg_tmp7.x = dot(uniforms.f[25 + address_registers.x], reg_tmp15);
    // 152: dp4
    reg_tmp7.y = dot(uniforms.f[26 + address_registers.x], reg_tmp15);
    // 153: dp4
    reg_tmp7.z = dot(uniforms.f[27 + address_registers.x], reg_tmp15);
    // 154: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 155: dp4
    reg_tmp10.x = dot(uniforms.f[0], reg_tmp7);
    // 156: dp4
    reg_tmp10.y = dot(uniforms.f[1], reg_tmp7);
    // 157: dp4
    reg_tmp10.z = dot(uniforms.f[2], reg_tmp7);
    // 158: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_159_164() {
    // 159: mova
    address_registers.x = (ivec2(uniforms.f[93].xxxx)).x;
    // 160: dp4
    reg_tmp10.x = dot(uniforms.f[25], reg_tmp15);
    // 161: dp4
    reg_tmp10.y = dot(uniforms.f[26], reg_tmp15);
    // 162: dp4
    reg_tmp10.z = dot(uniforms.f[27], reg_tmp15);
    // 163: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_165_177() {
    // 165: dp3
    reg_tmp12.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp14));
    // 166: dp3
    reg_tmp12.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp14));
    // 167: dp3
    reg_tmp12.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp14));
    // 168: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 169: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 170: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 171: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 172: dp3
    reg_tmp14.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp12));
    // 173: dp3
    reg_tmp14.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp12));
    // 174: dp3
    reg_tmp14.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp12));
    // 175: call
    {
        sub_214_231();
    }
    // 176: nop
    return false;
}
bool sub_177_202() {
    // 177: ifc
    if (all(conditional_code)) {
        sub_178_196();
    } else {
        sub_196_201();
    }
    // 201: nop
    return false;
}
bool sub_178_196() {
    // 178: dp3
    reg_tmp12.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp14));
    // 179: dp3
    reg_tmp12.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp14));
    // 180: dp3
    reg_tmp12.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp14));
    // 181: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp13));
    // 182: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp13));
    // 183: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp13));
    // 184: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 185: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 186: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 187: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 188: dp3
    reg_tmp14.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp12));
    // 189: dp3
    reg_tmp14.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp12));
    // 190: dp3
    reg_tmp14.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp12));
    // 191: dp3
    reg_tmp13.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp11));
    // 192: dp3
    reg_tmp13.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp11));
    // 193: dp3
    reg_tmp13.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp11));
    // 194: call
    {
        sub_231_307();
    }
    // 195: nop
    return false;
}
bool sub_196_201() {
    // 196: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 197: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 198: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 199: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 200: mov
    vs_out_attr1 = uniforms.f[93].xxxx;
    return false;
}
bool sub_211_212() {
    // 211: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_214_231() {
    uint jmp_to = 214u;
    while (true) {
        switch (jmp_to) {
        case 214u: {
            // 214: dp3
            reg_tmp6.x = dot(vec3(reg_tmp14), vec3(reg_tmp14));
            // 215: dp3
            reg_tmp7.x = dot(vec3(reg_tmp12), vec3(reg_tmp12));
            // 216: rsq
            reg_tmp6.x = rsq_safe(reg_tmp6.xxxx.x);
            // 217: rsq
            reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
            // 218: mul
            reg_tmp14.xyz = (mul_safe(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 219: mul
            reg_tmp12.xyz = (mul_safe(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 220: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 221: jmpu
            if (!uniforms.b[15]) {
                { jmp_to = 230u; break; }
            }
            // 222: add
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            // 223: mul
            reg_tmp4 = mul_safe(uniforms.f[94].zzzz, reg_tmp4);
            // 224: cmp
            conditional_code = greaterThanEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp4.xxxx));
            // 225: rsq
            reg_tmp4 = vec4(rsq_safe(reg_tmp4.xxxx.x));
            // 226: mul
            reg_tmp5 = mul_safe(uniforms.f[94].zzzz, reg_tmp14);
            // 227: jmpc
            if (conditional_code.x) {
                { jmp_to = 230u; break; }
            }
            // 228: rcp
            reg_tmp0.z = rcp_safe(reg_tmp4.xxxx.x);
            // 229: mul
            reg_tmp0.xy = (mul_safe(reg_tmp5, reg_tmp4)).xy;
        }
        case 230u: {
            // 230: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_231_307() {
    uint jmp_to = 231u;
    while (true) {
        switch (jmp_to) {
        case 231u: {
            // 231: dp3
            reg_tmp6.x = dot(vec3(reg_tmp14), vec3(reg_tmp14));
            // 232: dp3
            reg_tmp7.x = dot(vec3(reg_tmp12), vec3(reg_tmp12));
            // 233: rsq
            reg_tmp6.x = rsq_safe(reg_tmp6.xxxx.x);
            // 234: rsq
            reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
            // 235: mul
            reg_tmp14.xyz = (mul_safe(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 236: mul
            reg_tmp12.xyz = (mul_safe(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 237: mul
            reg_tmp13.xyz = (mul_safe(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            // 238: mul
            reg_tmp11.xyz = (mul_safe(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            // 239: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 240: jmpu
            if (!uniforms.b[15]) {
                { jmp_to = 306u; break; }
            }
            // 241: mul
            reg_tmp13.xyz = (mul_safe(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            // 242: mul
            reg_tmp11.xyz = (mul_safe(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            // 243: mul
            reg_tmp5 = mul_safe(reg_tmp14.yzxx, reg_tmp13.zxyy);
            // 244: mad
            reg_tmp5 = fma_safe(-reg_tmp13.yzxx, reg_tmp14.zxyy, reg_tmp5);
            // 245: dp3
            reg_tmp5.w = dot(vec3(reg_tmp5), vec3(reg_tmp5));
            // 246: rsq
            reg_tmp5.w = rsq_safe(reg_tmp5.wwww.x);
            // 247: mul
            reg_tmp5 = mul_safe(reg_tmp5, reg_tmp5.wwww);
            // 248: add
            reg_tmp6.w = (reg_tmp14.zzzz + reg_tmp5.yyyy).w;
            // 249: mul
            reg_tmp13 = mul_safe(reg_tmp5.yzxx, reg_tmp14.zxyy);
            // 250: mad
            reg_tmp13 = fma_safe(-reg_tmp14.yzxx, reg_tmp5.zxyy, reg_tmp13);
            // 251: add
            reg_tmp6.w = (reg_tmp13.xxxx + reg_tmp6).w;
            // 252: mov
            reg_tmp13.w = (reg_tmp5.zzzz).w;
            // 253: mov
            reg_tmp5.z = (reg_tmp13.xxxx).z;
            // 254: add
            reg_tmp6.w = (uniforms.f[93].yyyy + reg_tmp6).w;
            // 255: mov
            reg_tmp14.w = (reg_tmp5.xxxx).w;
            // 256: mov
            reg_tmp5.x = (reg_tmp14.zzzz).x;
            // 257: cmp
            conditional_code = lessThan(vec2(uniforms.f[94].yyyy), vec2(reg_tmp6.wwww));
            // 258: mov
            reg_tmp6.x = (uniforms.f[93].yyyy).x;
            // 259: mov
            reg_tmp6.y = (-uniforms.f[93].yyyy).y;
            // 260: jmpc
            if (!conditional_code.x) {
                { jmp_to = 268u; break; }
            }
            // 261: add
            reg_tmp7.xz = (reg_tmp13.wwyy + -reg_tmp14.yyww).xz;
            // 262: add
            reg_tmp7.y = (reg_tmp14.xxxx + -reg_tmp13.zzzz).y;
            // 263: mov
            reg_tmp7.w = (reg_tmp6).w;
            // 264: dp4
            reg_tmp6 = vec4(dot(reg_tmp7, reg_tmp7));
            // 265: rsq
            reg_tmp6 = vec4(rsq_safe(reg_tmp6.xxxx.x));
            // 266: mul
            reg_tmp0 = mul_safe(reg_tmp7, reg_tmp6);
            // 267: jmpu
            if (uniforms.b[0]) {
                { jmp_to = 306u; break; }
            }
        }
        case 268u: {
            // 268: cmp
            conditional_code = greaterThan(vec2(reg_tmp5.zyyy), vec2(reg_tmp5.yxxx));
            // 269: ifc
            if (conditional_code.x) {
                sub_270_290();
            } else {
                sub_290_303();
            }
            // 303: dp4
            reg_tmp6 = vec4(dot(reg_tmp8, reg_tmp8));
            // 304: rsq
            reg_tmp6 = vec4(rsq_safe(reg_tmp6.xxxx.x));
            // 305: mul
            reg_tmp0 = mul_safe(reg_tmp8, reg_tmp6);
        }
        case 306u: {
            // 306: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_270_290() {
    // 270: ifc
    if (conditional_code.y) {
        sub_271_276();
    } else {
        sub_276_289();
    }
    // 289: mov
    reg_tmp8.w = (-reg_tmp8).w;
    return false;
}
bool sub_271_276() {
    // 271: mul
    reg_tmp8 = mul_safe(reg_tmp13.yyzw, reg_tmp6.xxxy);
    // 272: add
    reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
    // 273: add
    reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
    // 274: add
    reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
    // 275: add
    reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
    return false;
}
bool sub_276_289() {
    // 276: cmp
    conditional_code = greaterThan(vec2(reg_tmp5.zzzz), vec2(reg_tmp5.xxxx));
    // 277: mul
    reg_tmp8 = mul_safe(reg_tmp13.yyzw, reg_tmp6.xxxy);
    // 278: add
    reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
    // 279: ifc
    if (conditional_code.x) {
        sub_280_283();
    } else {
        sub_283_288();
    }
    // 288: nop
    return false;
}
bool sub_280_283() {
    // 280: add
    reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
    // 281: add
    reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
    // 282: add
    reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
    return false;
}
bool sub_283_288() {
    // 283: mul
    reg_tmp8 = mul_safe(reg_tmp13.zwwy, reg_tmp6.xxxy);
    // 284: add
    reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
    // 285: add
    reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
    // 286: add
    reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
    // 287: add
    reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
    return false;
}
bool sub_290_303() {
    // 290: ifc
    if (conditional_code.y) {
        sub_291_296();
    } else {
        sub_296_302();
    }
    // 302: nop
    return false;
}
bool sub_291_296() {
    // 291: mul
    reg_tmp8 = mul_safe(reg_tmp13.yywz, reg_tmp6.xxxy);
    // 292: add
    reg_tmp8.y = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).y;
    // 293: add
    reg_tmp9 = reg_tmp5.yyyy + -reg_tmp5.xxxx;
    // 294: add
    reg_tmp8.xzw = (reg_tmp8 + reg_tmp14.wwyx).xzw;
    // 295: add
    reg_tmp8.y = (reg_tmp9 + reg_tmp8).y;
    return false;
}
bool sub_296_302() {
    // 296: mul
    reg_tmp8 = mul_safe(reg_tmp13.zwwy, reg_tmp6.xxxy);
    // 297: add
    reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
    // 298: add
    reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
    // 299: add
    reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
    // 300: add
    reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
    // 301: mov
    reg_tmp8.w = (-reg_tmp8).w;
    return false;
}
bool sub_307_330() {
    // 307: mov
    reg_tmp1.xyz = (uniforms.f[93].xxyx).xyz;
    // 308: dp3
    reg_tmp8.x = dot(vec3(uniforms.f[0]), vec3(reg_tmp12.xyzz));
    // 309: dp3
    reg_tmp8.y = dot(vec3(uniforms.f[1]), vec3(reg_tmp12.xyzz));
    // 310: dp3
    reg_tmp8.z = dot(vec3(uniforms.f[2]), vec3(reg_tmp12.xyzz));
    // 311: dp3
    reg_tmp14.x = dot(vec3(uniforms.f[90]), vec3(reg_tmp8.xyzz));
    // 312: dp3
    reg_tmp14.y = dot(vec3(uniforms.f[91]), vec3(reg_tmp8.xyzz));
    // 313: dp3
    reg_tmp14.z = dot(vec3(uniforms.f[92]), vec3(reg_tmp8.xyzz));
    // 314: mov
    reg_tmp14.w = (uniforms.f[93].xxxx).w;
    // 315: mov
    reg_tmp8 = reg_tmp14;
    // 316: dp4
    reg_tmp14.x = dot(reg_tmp8, reg_tmp8);
    // 317: rsq
    reg_tmp14.x = rsq_safe(reg_tmp14.xxxx.x);
    // 318: mul
    reg_tmp14 = mul_safe(reg_tmp8, reg_tmp14.xxxx);
    // 319: dp3
    reg_tmp9.x = dot(vec3(reg_tmp14), vec3(reg_tmp1));
    // 320: max
    reg_tmp9.x = (max(uniforms.f[93].xxxx, reg_tmp9.xxxx)).x;
    // 321: min
    reg_tmp9.x = (min(uniforms.f[93].yyyy, reg_tmp9.xxxx)).x;
    // 322: add
    reg_tmp9.x = (uniforms.f[93].yyyy + -reg_tmp9.xxxx).x;
    // 323: log
    reg_tmp9.x = log2(reg_tmp9.xxxx.x);
    // 324: mul
    reg_tmp9.x = (mul_safe(uniforms.f[85].xxxx, reg_tmp9.xxxx)).x;
    // 325: exp
    reg_tmp9.x = exp2(reg_tmp9.xxxx.x);
    // 326: mul
    reg_tmp2.w = (mul_safe(uniforms.f[85].yyyy, reg_tmp9.xxxx)).w;
    // 327: mul
    reg_tmp0 = mul_safe(uniforms.f[7].wwww, vs_in_reg3);
    // 328: mul
    reg_tmp2.xyz = (mul_safe(uniforms.f[20].wwww, reg_tmp0.xyzz)).xyz;
    // 329: mov
    vs_out_attr3 = reg_tmp2;
    return false;
}
bool sub_330_357() {
    // 330: mov
    reg_tmp0.xy = (uniforms.f[10].xxxx).xy;
    // 331: ifu
    if (uniforms.b[9]) {
        sub_332_337();
    } else {
        sub_337_356();
    }
    // 356: nop
    return false;
}
bool sub_332_337() {
    // 332: call
    {
        sub_357_365();
    }
    // 333: dp4
    reg_tmp3.x = dot(uniforms.f[11].xywz, reg_tmp6);
    // 334: dp4
    reg_tmp3.y = dot(uniforms.f[12].xywz, reg_tmp6);
    // 335: mov
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    // 336: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_337_356() {
    // 337: cmp
    conditional_code = equal(vec2(uniforms.f[95].xyyy), vec2(reg_tmp0.xyyy));
    // 338: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 339: ifc
    if (all(not(conditional_code))) {
        sub_340_346();
    } else {
        sub_346_355();
    }
    // 355: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_340_346() {
    // 340: mov
    reg_tmp6 = reg_tmp10;
    // 341: dp4
    reg_tmp3.x = dot(uniforms.f[11], reg_tmp6);
    // 342: dp4
    reg_tmp3.y = dot(uniforms.f[12], reg_tmp6);
    // 343: dp4
    reg_tmp3.z = dot(uniforms.f[13], reg_tmp6);
    // 344: mul
    reg_tmp0.xy = (mul_safe(uniforms.f[19].xyyy, reg_tmp3.zzzz)).xy;
    // 345: add
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_346_355() {
    // 346: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_347_351();
    } else {
        sub_351_354();
    }
    // 354: nop
    return false;
}
bool sub_347_351() {
    // 347: call
    {
        sub_365_372();
    }
    // 348: dp3
    reg_tmp3.x = dot(vec3(uniforms.f[11]), vec3(reg_tmp6));
    // 349: dp3
    reg_tmp3.y = dot(vec3(uniforms.f[12]), vec3(reg_tmp6));
    // 350: dp3
    reg_tmp3.z = dot(vec3(uniforms.f[13]), vec3(reg_tmp6));
    return false;
}
bool sub_351_354() {
    // 351: call
    {
        sub_372_376();
    }
    // 352: dp4
    reg_tmp3.x = dot(uniforms.f[11], reg_tmp6);
    // 353: dp4
    reg_tmp3.y = dot(uniforms.f[12], reg_tmp6);
    return false;
}
bool sub_357_365() {
    // 357: cmp
    conditional_code = equal(vec2(uniforms.f[93].yzzz), vec2(reg_tmp0.xyyy));
    // 358: ifc
    if (all(not(conditional_code))) {
        sub_359_360();
    } else {
        sub_360_364();
    }
    // 364: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_359_360() {
    // 359: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
    return false;
}
bool sub_360_364() {
    // 360: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_361_362();
    } else {
        sub_362_363();
    }
    // 363: nop
    return false;
}
bool sub_361_362() {
    // 361: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
    return false;
}
bool sub_362_363() {
    // 362: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
    return false;
}
bool sub_365_372() {
    // 365: mov
    reg_tmp2 = -reg_tmp15;
    // 366: dp3
    reg_tmp2.w = dot(vec3(reg_tmp2), vec3(reg_tmp2));
    // 367: rsq
    reg_tmp2.w = rsq_safe(reg_tmp2.wwww.x);
    // 368: mul
    reg_tmp2 = mul_safe(reg_tmp2, reg_tmp2.wwww);
    // 369: dp3
    reg_tmp1 = vec4(dot(vec3(reg_tmp2), vec3(reg_tmp14)));
    // 370: add
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    // 371: mad
    reg_tmp6 = fma_safe(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_372_376() {
    // 372: mov
    reg_tmp1.xy = (uniforms.f[94].zzzz).xy;
    // 373: mov
    reg_tmp1.zw = (uniforms.f[93].xxxx).zw;
    // 374: mad
    reg_tmp6 = fma_safe(reg_tmp14, reg_tmp1, reg_tmp1);
    // 375: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_376_400() {
    // 376: mov
    reg_tmp0.xy = (uniforms.f[10].yyyy).xy;
    // 377: ifu
    if (uniforms.b[10]) {
        sub_378_382();
    } else {
        sub_382_399();
    }
    // 399: nop
    return false;
}
bool sub_378_382() {
    // 378: call
    {
        sub_357_365();
    }
    // 379: dp4
    reg_tmp4.x = dot(uniforms.f[14].xywz, reg_tmp6);
    // 380: dp4
    reg_tmp4.y = dot(uniforms.f[15].xywz, reg_tmp6);
    // 381: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_382_399() {
    // 382: ifu
    if (uniforms.b[13]) {
        sub_383_397();
    } else {
        sub_397_398();
    }
    // 398: nop
    return false;
}
bool sub_383_397() {
    // 383: cmp
    conditional_code = equal(vec2(uniforms.f[95].xyyy), vec2(reg_tmp0.xyyy));
    // 384: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 385: ifc
    if (all(not(conditional_code))) {
        sub_386_393();
    } else {
        sub_393_396();
    }
    // 396: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_386_393() {
    // 386: mov
    reg_tmp6 = reg_tmp10;
    // 387: dp4
    reg_tmp4.x = dot(uniforms.f[14], reg_tmp6);
    // 388: dp4
    reg_tmp4.y = dot(uniforms.f[15], reg_tmp6);
    // 389: dp4
    reg_tmp4.z = dot(uniforms.f[16], reg_tmp6);
    // 390: rcp
    reg_tmp6.w = rcp_safe(reg_tmp4.zzzz.x);
    // 391: mul
    reg_tmp4.xy = (mul_safe(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    // 392: add
    reg_tmp4.xy = (uniforms.f[19].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_393_396() {
    // 393: call
    {
        sub_372_376();
    }
    // 394: dp4
    reg_tmp4.x = dot(uniforms.f[14], reg_tmp6);
    // 395: dp4
    reg_tmp4.y = dot(uniforms.f[15], reg_tmp6);
    return false;
}
bool sub_397_398() {
    // 397: mov
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_400_416() {
    // 400: mov
    reg_tmp0.xy = (uniforms.f[10].zzzz).xy;
    // 401: ifu
    if (uniforms.b[11]) {
        sub_402_406();
    } else {
        sub_406_415();
    }
    // 415: nop
    return false;
}
bool sub_402_406() {
    // 402: call
    {
        sub_357_365();
    }
    // 403: dp4
    reg_tmp5.x = dot(uniforms.f[17].xywz, reg_tmp6);
    // 404: dp4
    reg_tmp5.y = dot(uniforms.f[18].xywz, reg_tmp6);
    // 405: mov
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_406_415() {
    // 406: ifu
    if (uniforms.b[14]) {
        sub_407_413();
    } else {
        sub_413_414();
    }
    // 414: nop
    return false;
}
bool sub_407_413() {
    // 407: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 408: mov
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    // 409: call
    {
        sub_372_376();
    }
    // 410: dp4
    reg_tmp5.x = dot(uniforms.f[17], reg_tmp6);
    // 411: dp4
    reg_tmp5.y = dot(uniforms.f[18], reg_tmp6);
    // 412: mov
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_413_414() {
    // 413: mov
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
// reference: 919F47DF8AA22155, DFFAEC9E8E4C8459
// program: DFFAEC9E8E4C8459, AD7922A63ED54CA7, 159CC93A09C7B2EA
// reference: 6442016C052A2483, 35F6C85AC819B073
// reference: 51378DAC939D35D6, AE0AE260B2F14D0F
// reference: FD17792DDE9385C4, 35F6C85AC819B073
// reference: 919F47DF659BB214, DFFAEC9E8E4C8459
// reference: 6442016CEA13B7C2, 35F6C85AC819B073
// reference: C862F5ED48249491, AE0AE260B2F14D0F
// shader: 8B31, 5C7DAF9CBE61E818

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define mul_safe(x, y) (x * y)
#define rcp_safe(x) (1.0f / x)
#define rsq_safe(x) inversesqrt(x)
#define fma_safe(x, y, z) fma(x, y, z)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_4096();
bool sub_7_12();
bool sub_9_10();
bool sub_14_15();
bool sub_18_30();
bool sub_20_21();
bool sub_21_25();
bool sub_22_23();
bool sub_23_24();
bool sub_30_40();
bool sub_44_45();
bool sub_45_49();
bool sub_46_47();
bool sub_47_48();
bool sub_56_61();
bool sub_61_70();
bool sub_70_83();
bool sub_83_251();
bool sub_89_189();
bool sub_96_125();
bool sub_107_111();
bool sub_125_184();
bool sub_126_158();
bool sub_137_141();
bool sub_158_183();
bool sub_169_173();
bool sub_189_250();
bool sub_192_202();
bool sub_202_207();
bool sub_208_220();
bool sub_220_245();
bool sub_221_239();
bool sub_239_244();
bool sub_251_268();
bool sub_268_344();
bool sub_307_327();
bool sub_308_313();
bool sub_313_326();
bool sub_317_320();
bool sub_320_325();
bool sub_327_340();
bool sub_328_333();
bool sub_333_339();

bool exec_shader() {
    sub_0_4096();
    return true;
}

bool sub_0_4096() {
    // 0: call
    {
        sub_83_251();
    }
    // 1: mov
    reg_tmp8.xy = (uniforms.f[93].xxxx).xy;
    // 2: mov
    reg_tmp0.y = (uniforms.f[7].wwww).y;
    // 3: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.xyyy));
    // 4: mov
    reg_tmp9.xyz = (uniforms.f[93].xxxx).xyz;
    // 5: mov
    reg_tmp9.w = (uniforms.f[21].wwww).w;
    // 6: ifc
    if (conditional_code.y) {
        sub_7_12();
    }
    // 12: cmp
    conditional_code = equal(vec2(uniforms.f[93].xxxx), vec2(reg_tmp8.xyyy));
    // 13: ifc
    if (all(conditional_code)) {
        sub_14_15();
    }
    // 15: max
    vs_out_attr3 = max(uniforms.f[93].xxxx, reg_tmp9);
    // 16: mov
    reg_tmp0.xy = (uniforms.f[10].xxxx).xy;
    // 17: ifu
    if (uniforms.b[9]) {
        sub_18_30();
    } else {
        sub_30_40();
    }
    // 40: nop
    // 41: mov
    reg_tmp0.xy = (uniforms.f[10].yyyy).xy;
    // 42: cmp
    conditional_code = equal(vec2(uniforms.f[93].yzzz), vec2(reg_tmp0.xyyy));
    // 43: ifc
    if (all(not(conditional_code))) {
        sub_44_45();
    } else {
        sub_45_49();
    }
    // 49: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 50: dp4
    reg_tmp4.x = dot(uniforms.f[14].xywz, reg_tmp6);
    // 51: dp4
    reg_tmp4.y = dot(uniforms.f[15].xywz, reg_tmp6);
    // 52: mov
    vs_out_attr5 = reg_tmp4;
    // 53: nop
    // 54: end
    return true;
}
bool sub_7_12() {
    // 7: mul
    reg_tmp0 = mul_safe(uniforms.f[7].wwww, vs_in_reg3);
    // 8: ifu
    if (uniforms.b[7]) {
        sub_9_10();
    }
    // 10: mul
    reg_tmp9.xyz = (mul_safe(uniforms.f[20].wwww, reg_tmp0.xyzz)).xyz;
    // 11: mov
    reg_tmp8.x = (uniforms.f[93].yyyy).x;
    return false;
}
bool sub_9_10() {
    // 9: mul
    reg_tmp9.w = (mul_safe(reg_tmp9.wwww, reg_tmp0.wwww)).w;
    return false;
}
bool sub_14_15() {
    // 14: mov
    reg_tmp9 = uniforms.f[21];
    return false;
}
bool sub_18_30() {
    // 18: cmp
    conditional_code = equal(vec2(uniforms.f[93].yzzz), vec2(reg_tmp0.xyyy));
    // 19: ifc
    if (all(not(conditional_code))) {
        sub_20_21();
    } else {
        sub_21_25();
    }
    // 25: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 26: dp4
    reg_tmp3.x = dot(uniforms.f[11].xywz, reg_tmp6);
    // 27: dp4
    reg_tmp3.y = dot(uniforms.f[12].xywz, reg_tmp6);
    // 28: mov
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    // 29: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_20_21() {
    // 20: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
    return false;
}
bool sub_21_25() {
    // 21: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_22_23();
    } else {
        sub_23_24();
    }
    // 24: nop
    return false;
}
bool sub_22_23() {
    // 22: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
    return false;
}
bool sub_23_24() {
    // 23: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
    return false;
}
bool sub_30_40() {
    // 30: cmp
    conditional_code = equal(vec2(uniforms.f[95].xyyy), vec2(reg_tmp0.xyyy));
    // 31: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 32: mov
    reg_tmp6 = reg_tmp10;
    // 33: dp4
    reg_tmp3.x = dot(uniforms.f[11], reg_tmp6);
    // 34: dp4
    reg_tmp3.y = dot(uniforms.f[12], reg_tmp6);
    // 35: dp4
    reg_tmp3.z = dot(uniforms.f[13], reg_tmp6);
    // 36: mul
    reg_tmp0.xy = (mul_safe(uniforms.f[19].xyyy, reg_tmp3.zzzz)).xy;
    // 37: add
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    // 38: nop
    // 39: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_44_45() {
    // 44: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
    return false;
}
bool sub_45_49() {
    // 45: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_46_47();
    } else {
        sub_47_48();
    }
    // 48: nop
    return false;
}
bool sub_46_47() {
    // 46: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
    return false;
}
bool sub_47_48() {
    // 47: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
    return false;
}
bool sub_56_61() {
    // 56: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 57: dp4
    reg_tmp3.x = dot(uniforms.f[25 + address_registers.x], reg_tmp15);
    // 58: dp4
    reg_tmp3.y = dot(uniforms.f[26 + address_registers.x], reg_tmp15);
    // 59: dp4
    reg_tmp3.z = dot(uniforms.f[27 + address_registers.x], reg_tmp15);
    // 60: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    return false;
}
bool sub_61_70() {
    // 61: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 62: dp4
    reg_tmp3.x = dot(uniforms.f[25 + address_registers.x], reg_tmp15);
    // 63: dp4
    reg_tmp3.y = dot(uniforms.f[26 + address_registers.x], reg_tmp15);
    // 64: dp4
    reg_tmp3.z = dot(uniforms.f[27 + address_registers.x], reg_tmp15);
    // 65: dp3
    reg_tmp4.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp14));
    // 66: dp3
    reg_tmp4.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp14));
    // 67: dp3
    reg_tmp4.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp14));
    // 68: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 69: mad
    reg_tmp12 = fma_safe(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_70_83() {
    // 70: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 71: dp4
    reg_tmp3.x = dot(uniforms.f[25 + address_registers.x], reg_tmp15);
    // 72: dp4
    reg_tmp3.y = dot(uniforms.f[26 + address_registers.x], reg_tmp15);
    // 73: dp4
    reg_tmp3.z = dot(uniforms.f[27 + address_registers.x], reg_tmp15);
    // 74: dp3
    reg_tmp4.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp14));
    // 75: dp3
    reg_tmp4.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp14));
    // 76: dp3
    reg_tmp4.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp14));
    // 77: dp3
    reg_tmp5.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp13));
    // 78: dp3
    reg_tmp5.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp13));
    // 79: dp3
    reg_tmp5.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp13));
    // 80: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 81: mad
    reg_tmp12 = fma_safe(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    // 82: mad
    reg_tmp11 = fma_safe(reg_tmp1.wwww, reg_tmp5, reg_tmp11);
    return false;
}
bool sub_83_251() {
    // 83: mul
    reg_tmp15.xyz = (mul_safe(uniforms.f[7].xxxx, vs_in_reg0)).xyz;
    // 84: mul
    reg_tmp14.xyz = (mul_safe(uniforms.f[7].yyyy, vs_in_reg1)).xyz;
    // 85: mul
    reg_tmp13.xyz = (mul_safe(uniforms.f[7].zzzz, vs_in_reg2)).xyz;
    // 86: add
    reg_tmp15.xyz = (uniforms.f[6] + reg_tmp15).xyz;
    // 87: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 88: ifu
    if (uniforms.b[1]) {
        sub_89_189();
    } else {
        sub_189_250();
    }
    // 250: nop
    return false;
}
bool sub_89_189() {
    // 89: mov
    reg_tmp0 = uniforms.f[7];
    // 90: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.yzzz));
    // 91: mov
    reg_tmp7 = uniforms.f[93].xxxx;
    // 92: mov
    reg_tmp12 = uniforms.f[93].xxxx;
    // 93: mov
    reg_tmp11 = uniforms.f[93].xxxx;
    // 94: mul
    reg_tmp2 = mul_safe(uniforms.f[93].wwww, vs_in_reg7);
    // 95: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_96_125();
    } else {
        sub_125_184();
    }
    // 184: mov
    vs_out_attr2 = -reg_tmp15;
    // 185: dp4
    vs_out_attr0.x = dot(uniforms.f[86], reg_tmp15);
    // 186: dp4
    vs_out_attr0.y = dot(uniforms.f[87], reg_tmp15);
    // 187: dp4
    vs_out_attr0.z = dot(uniforms.f[88], reg_tmp15);
    // 188: dp4
    vs_out_attr0.w = dot(uniforms.f[89], reg_tmp15);
    return false;
}
bool sub_96_125() {
    // 96: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 97: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 98: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 99: call
    {
        sub_61_70();
    }
    // 100: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 101: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 102: call
    {
        sub_61_70();
    }
    // 103: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 104: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 105: callc
    if (conditional_code.x) {
        sub_61_70();
    }
    // 106: ifu
    if (uniforms.b[8]) {
        sub_107_111();
    }
    // 111: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 112: dp4
    reg_tmp10.x = dot(uniforms.f[0], reg_tmp7);
    // 113: dp4
    reg_tmp10.y = dot(uniforms.f[1], reg_tmp7);
    // 114: dp4
    reg_tmp10.z = dot(uniforms.f[2], reg_tmp7);
    // 115: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 116: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 117: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 118: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 119: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 120: dp3
    reg_tmp14.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp12));
    // 121: dp3
    reg_tmp14.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp12));
    // 122: dp3
    reg_tmp14.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp12));
    // 123: call
    {
        sub_251_268();
    }
    // 124: nop
    return false;
}
bool sub_107_111() {
    // 107: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 108: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 109: callc
    if (conditional_code.y) {
        sub_61_70();
    }
    // 110: nop
    return false;
}
bool sub_125_184() {
    // 125: ifc
    if (all(conditional_code)) {
        sub_126_158();
    } else {
        sub_158_183();
    }
    // 183: nop
    return false;
}
bool sub_126_158() {
    // 126: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 127: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 128: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 129: call
    {
        sub_70_83();
    }
    // 130: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 131: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 132: call
    {
        sub_70_83();
    }
    // 133: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 134: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 135: callc
    if (conditional_code.x) {
        sub_70_83();
    }
    // 136: ifu
    if (uniforms.b[8]) {
        sub_137_141();
    }
    // 141: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 142: dp4
    reg_tmp10.x = dot(uniforms.f[0], reg_tmp7);
    // 143: dp4
    reg_tmp10.y = dot(uniforms.f[1], reg_tmp7);
    // 144: dp4
    reg_tmp10.z = dot(uniforms.f[2], reg_tmp7);
    // 145: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 146: dp3
    reg_tmp13.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp11));
    // 147: dp3
    reg_tmp13.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp11));
    // 148: dp3
    reg_tmp13.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp11));
    // 149: dp3
    reg_tmp14.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp12));
    // 150: dp3
    reg_tmp14.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp12));
    // 151: dp3
    reg_tmp14.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp12));
    // 152: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 153: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 154: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 155: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 156: call
    {
        sub_268_344();
    }
    // 157: nop
    return false;
}
bool sub_137_141() {
    // 137: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 138: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 139: callc
    if (conditional_code.y) {
        sub_70_83();
    }
    // 140: nop
    return false;
}
bool sub_158_183() {
    // 158: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 159: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 160: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 161: call
    {
        sub_56_61();
    }
    // 162: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 163: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 164: call
    {
        sub_56_61();
    }
    // 165: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 166: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 167: callc
    if (conditional_code.x) {
        sub_56_61();
    }
    // 168: ifu
    if (uniforms.b[8]) {
        sub_169_173();
    }
    // 173: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 174: dp4
    reg_tmp10.x = dot(uniforms.f[0], reg_tmp7);
    // 175: dp4
    reg_tmp10.y = dot(uniforms.f[1], reg_tmp7);
    // 176: dp4
    reg_tmp10.z = dot(uniforms.f[2], reg_tmp7);
    // 177: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 178: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 179: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 180: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 181: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 182: mov
    vs_out_attr1 = uniforms.f[93].xxxx;
    return false;
}
bool sub_169_173() {
    // 169: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 170: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 171: callc
    if (conditional_code.y) {
        sub_56_61();
    }
    // 172: nop
    return false;
}
bool sub_189_250() {
    // 189: mov
    reg_tmp0 = uniforms.f[7];
    // 190: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.yzzz));
    // 191: ifu
    if (uniforms.b[2]) {
        sub_192_202();
    } else {
        sub_202_207();
    }
    // 207: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_208_220();
    } else {
        sub_220_245();
    }
    // 245: mov
    vs_out_attr2 = -reg_tmp15;
    // 246: dp4
    vs_out_attr0.x = dot(uniforms.f[86], reg_tmp15);
    // 247: dp4
    vs_out_attr0.y = dot(uniforms.f[87], reg_tmp15);
    // 248: dp4
    vs_out_attr0.z = dot(uniforms.f[88], reg_tmp15);
    // 249: dp4
    vs_out_attr0.w = dot(uniforms.f[89], reg_tmp15);
    return false;
}
bool sub_192_202() {
    // 192: mul
    reg_tmp1.x = (mul_safe(uniforms.f[93].wwww, vs_in_reg7.xxxx)).x;
    // 193: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 194: dp4
    reg_tmp7.x = dot(uniforms.f[25 + address_registers.x], reg_tmp15);
    // 195: dp4
    reg_tmp7.y = dot(uniforms.f[26 + address_registers.x], reg_tmp15);
    // 196: dp4
    reg_tmp7.z = dot(uniforms.f[27 + address_registers.x], reg_tmp15);
    // 197: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 198: dp4
    reg_tmp10.x = dot(uniforms.f[0], reg_tmp7);
    // 199: dp4
    reg_tmp10.y = dot(uniforms.f[1], reg_tmp7);
    // 200: dp4
    reg_tmp10.z = dot(uniforms.f[2], reg_tmp7);
    // 201: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_202_207() {
    // 202: mova
    address_registers.x = (ivec2(uniforms.f[93].xxxx)).x;
    // 203: dp4
    reg_tmp10.x = dot(uniforms.f[25], reg_tmp15);
    // 204: dp4
    reg_tmp10.y = dot(uniforms.f[26], reg_tmp15);
    // 205: dp4
    reg_tmp10.z = dot(uniforms.f[27], reg_tmp15);
    // 206: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_208_220() {
    // 208: dp3
    reg_tmp12.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp14));
    // 209: dp3
    reg_tmp12.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp14));
    // 210: dp3
    reg_tmp12.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp14));
    // 211: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 212: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 213: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 214: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 215: dp3
    reg_tmp14.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp12));
    // 216: dp3
    reg_tmp14.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp12));
    // 217: dp3
    reg_tmp14.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp12));
    // 218: call
    {
        sub_251_268();
    }
    // 219: nop
    return false;
}
bool sub_220_245() {
    // 220: ifc
    if (all(conditional_code)) {
        sub_221_239();
    } else {
        sub_239_244();
    }
    // 244: nop
    return false;
}
bool sub_221_239() {
    // 221: dp3
    reg_tmp12.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp14));
    // 222: dp3
    reg_tmp12.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp14));
    // 223: dp3
    reg_tmp12.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp14));
    // 224: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp13));
    // 225: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp13));
    // 226: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp13));
    // 227: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 228: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 229: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 230: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 231: dp3
    reg_tmp14.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp12));
    // 232: dp3
    reg_tmp14.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp12));
    // 233: dp3
    reg_tmp14.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp12));
    // 234: dp3
    reg_tmp13.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp11));
    // 235: dp3
    reg_tmp13.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp11));
    // 236: dp3
    reg_tmp13.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp11));
    // 237: call
    {
        sub_268_344();
    }
    // 238: nop
    return false;
}
bool sub_239_244() {
    // 239: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 240: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 241: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 242: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 243: mov
    vs_out_attr1 = uniforms.f[93].xxxx;
    return false;
}
bool sub_251_268() {
    uint jmp_to = 251u;
    while (true) {
        switch (jmp_to) {
        case 251u: {
            // 251: dp3
            reg_tmp6.x = dot(vec3(reg_tmp14), vec3(reg_tmp14));
            // 252: dp3
            reg_tmp7.x = dot(vec3(reg_tmp12), vec3(reg_tmp12));
            // 253: rsq
            reg_tmp6.x = rsq_safe(reg_tmp6.xxxx.x);
            // 254: rsq
            reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
            // 255: mul
            reg_tmp14.xyz = (mul_safe(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 256: mul
            reg_tmp12.xyz = (mul_safe(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 257: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 258: jmpu
            if (!uniforms.b[15]) {
                { jmp_to = 267u; break; }
            }
            // 259: add
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            // 260: mul
            reg_tmp4 = mul_safe(uniforms.f[94].zzzz, reg_tmp4);
            // 261: cmp
            conditional_code = greaterThanEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp4.xxxx));
            // 262: rsq
            reg_tmp4 = vec4(rsq_safe(reg_tmp4.xxxx.x));
            // 263: mul
            reg_tmp5 = mul_safe(uniforms.f[94].zzzz, reg_tmp14);
            // 264: jmpc
            if (conditional_code.x) {
                { jmp_to = 267u; break; }
            }
            // 265: rcp
            reg_tmp0.z = rcp_safe(reg_tmp4.xxxx.x);
            // 266: mul
            reg_tmp0.xy = (mul_safe(reg_tmp5, reg_tmp4)).xy;
        }
        case 267u: {
            // 267: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_268_344() {
    uint jmp_to = 268u;
    while (true) {
        switch (jmp_to) {
        case 268u: {
            // 268: dp3
            reg_tmp6.x = dot(vec3(reg_tmp14), vec3(reg_tmp14));
            // 269: dp3
            reg_tmp7.x = dot(vec3(reg_tmp12), vec3(reg_tmp12));
            // 270: rsq
            reg_tmp6.x = rsq_safe(reg_tmp6.xxxx.x);
            // 271: rsq
            reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
            // 272: mul
            reg_tmp14.xyz = (mul_safe(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 273: mul
            reg_tmp12.xyz = (mul_safe(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 274: mul
            reg_tmp13.xyz = (mul_safe(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            // 275: mul
            reg_tmp11.xyz = (mul_safe(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            // 276: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 277: jmpu
            if (!uniforms.b[15]) {
                { jmp_to = 343u; break; }
            }
            // 278: mul
            reg_tmp13.xyz = (mul_safe(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            // 279: mul
            reg_tmp11.xyz = (mul_safe(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            // 280: mul
            reg_tmp5 = mul_safe(reg_tmp14.yzxx, reg_tmp13.zxyy);
            // 281: mad
            reg_tmp5 = fma_safe(-reg_tmp13.yzxx, reg_tmp14.zxyy, reg_tmp5);
            // 282: dp3
            reg_tmp5.w = dot(vec3(reg_tmp5), vec3(reg_tmp5));
            // 283: rsq
            reg_tmp5.w = rsq_safe(reg_tmp5.wwww.x);
            // 284: mul
            reg_tmp5 = mul_safe(reg_tmp5, reg_tmp5.wwww);
            // 285: add
            reg_tmp6.w = (reg_tmp14.zzzz + reg_tmp5.yyyy).w;
            // 286: mul
            reg_tmp13 = mul_safe(reg_tmp5.yzxx, reg_tmp14.zxyy);
            // 287: mad
            reg_tmp13 = fma_safe(-reg_tmp14.yzxx, reg_tmp5.zxyy, reg_tmp13);
            // 288: add
            reg_tmp6.w = (reg_tmp13.xxxx + reg_tmp6).w;
            // 289: mov
            reg_tmp13.w = (reg_tmp5.zzzz).w;
            // 290: mov
            reg_tmp5.z = (reg_tmp13.xxxx).z;
            // 291: add
            reg_tmp6.w = (uniforms.f[93].yyyy + reg_tmp6).w;
            // 292: mov
            reg_tmp14.w = (reg_tmp5.xxxx).w;
            // 293: mov
            reg_tmp5.x = (reg_tmp14.zzzz).x;
            // 294: cmp
            conditional_code = lessThan(vec2(uniforms.f[94].yyyy), vec2(reg_tmp6.wwww));
            // 295: mov
            reg_tmp6.x = (uniforms.f[93].yyyy).x;
            // 296: mov
            reg_tmp6.y = (-uniforms.f[93].yyyy).y;
            // 297: jmpc
            if (!conditional_code.x) {
                { jmp_to = 305u; break; }
            }
            // 298: add
            reg_tmp7.xz = (reg_tmp13.wwyy + -reg_tmp14.yyww).xz;
            // 299: add
            reg_tmp7.y = (reg_tmp14.xxxx + -reg_tmp13.zzzz).y;
            // 300: mov
            reg_tmp7.w = (reg_tmp6).w;
            // 301: dp4
            reg_tmp6 = vec4(dot(reg_tmp7, reg_tmp7));
            // 302: rsq
            reg_tmp6 = vec4(rsq_safe(reg_tmp6.xxxx.x));
            // 303: mul
            reg_tmp0 = mul_safe(reg_tmp7, reg_tmp6);
            // 304: jmpu
            if (uniforms.b[0]) {
                { jmp_to = 343u; break; }
            }
        }
        case 305u: {
            // 305: cmp
            conditional_code = greaterThan(vec2(reg_tmp5.zyyy), vec2(reg_tmp5.yxxx));
            // 306: ifc
            if (conditional_code.x) {
                sub_307_327();
            } else {
                sub_327_340();
            }
            // 340: dp4
            reg_tmp6 = vec4(dot(reg_tmp8, reg_tmp8));
            // 341: rsq
            reg_tmp6 = vec4(rsq_safe(reg_tmp6.xxxx.x));
            // 342: mul
            reg_tmp0 = mul_safe(reg_tmp8, reg_tmp6);
        }
        case 343u: {
            // 343: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_307_327() {
    // 307: ifc
    if (conditional_code.y) {
        sub_308_313();
    } else {
        sub_313_326();
    }
    // 326: mov
    reg_tmp8.w = (-reg_tmp8).w;
    return false;
}
bool sub_308_313() {
    // 308: mul
    reg_tmp8 = mul_safe(reg_tmp13.yyzw, reg_tmp6.xxxy);
    // 309: add
    reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
    // 310: add
    reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
    // 311: add
    reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
    // 312: add
    reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
    return false;
}
bool sub_313_326() {
    // 313: cmp
    conditional_code = greaterThan(vec2(reg_tmp5.zzzz), vec2(reg_tmp5.xxxx));
    // 314: mul
    reg_tmp8 = mul_safe(reg_tmp13.yyzw, reg_tmp6.xxxy);
    // 315: add
    reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
    // 316: ifc
    if (conditional_code.x) {
        sub_317_320();
    } else {
        sub_320_325();
    }
    // 325: nop
    return false;
}
bool sub_317_320() {
    // 317: add
    reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
    // 318: add
    reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
    // 319: add
    reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
    return false;
}
bool sub_320_325() {
    // 320: mul
    reg_tmp8 = mul_safe(reg_tmp13.zwwy, reg_tmp6.xxxy);
    // 321: add
    reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
    // 322: add
    reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
    // 323: add
    reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
    // 324: add
    reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
    return false;
}
bool sub_327_340() {
    // 327: ifc
    if (conditional_code.y) {
        sub_328_333();
    } else {
        sub_333_339();
    }
    // 339: nop
    return false;
}
bool sub_328_333() {
    // 328: mul
    reg_tmp8 = mul_safe(reg_tmp13.yywz, reg_tmp6.xxxy);
    // 329: add
    reg_tmp8.y = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).y;
    // 330: add
    reg_tmp9 = reg_tmp5.yyyy + -reg_tmp5.xxxx;
    // 331: add
    reg_tmp8.xzw = (reg_tmp8 + reg_tmp14.wwyx).xzw;
    // 332: add
    reg_tmp8.y = (reg_tmp9 + reg_tmp8).y;
    return false;
}
bool sub_333_339() {
    // 333: mul
    reg_tmp8 = mul_safe(reg_tmp13.zwwy, reg_tmp6.xxxy);
    // 334: add
    reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
    // 335: add
    reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
    // 336: add
    reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
    // 337: add
    reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
    // 338: mov
    reg_tmp8.w = (-reg_tmp8).w;
    return false;
}
// reference: 93AF4DE7A06E9B94, 5C7DAF9CBE61E818
// program: 5C7DAF9CBE61E818, 3B3AE026C742C7D5, 4AD2C97240195A76
// reference: 0AFA35A67BD73AD3, 5C7DAF9CBE61E818
// program: 5C7DAF9CBE61E818, 3B3AE026C742C7D5, 666154B1BFC0A909
// program: 5C7DAF9CBE61E818, 3B3AE026C742C7D5, C27F787C261C6045
// program: 5C7DAF9CBE61E818, 3B3AE026C742C7D5, 82B30867377518C0
// program: 5C7DAF9CBE61E818, 3B3AE026C742C7D5, C74CA00DB8E95117
// shader: 8B31, 87F539836ED26483

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define mul_safe(x, y) (x * y)
#define rcp_safe(x) (1.0f / x)
#define rsq_safe(x) inversesqrt(x)
#define fma_safe(x, y, z) fma(x, y, z)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_4096();
bool sub_7_12();
bool sub_9_10();
bool sub_14_15();
bool sub_18_30();
bool sub_20_21();
bool sub_21_25();
bool sub_22_23();
bool sub_23_24();
bool sub_30_40();
bool sub_44_45();
bool sub_45_49();
bool sub_46_47();
bool sub_47_48();
bool sub_56_61();
bool sub_61_70();
bool sub_70_83();
bool sub_83_293();
bool sub_89_210();
bool sub_96_130();
bool sub_107_111();
bool sub_130_199();
bool sub_131_168();
bool sub_142_146();
bool sub_168_198();
bool sub_179_183();
bool sub_208_209();
bool sub_210_292();
bool sub_211_221();
bool sub_221_226();
bool sub_229_246();
bool sub_246_281();
bool sub_247_270();
bool sub_270_280();
bool sub_290_291();
bool sub_293_310();
bool sub_310_386();
bool sub_349_369();
bool sub_350_355();
bool sub_355_368();
bool sub_359_362();
bool sub_362_367();
bool sub_369_382();
bool sub_370_375();
bool sub_375_381();

bool exec_shader() {
    sub_0_4096();
    return true;
}

bool sub_0_4096() {
    // 0: call
    {
        sub_83_293();
    }
    // 1: mov
    reg_tmp8.xy = (uniforms.f[93].xxxx).xy;
    // 2: mov
    reg_tmp0.y = (uniforms.f[7].wwww).y;
    // 3: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.xyyy));
    // 4: mov
    reg_tmp9.xyz = (uniforms.f[93].xxxx).xyz;
    // 5: mov
    reg_tmp9.w = (uniforms.f[21].wwww).w;
    // 6: ifc
    if (conditional_code.y) {
        sub_7_12();
    }
    // 12: cmp
    conditional_code = equal(vec2(uniforms.f[93].xxxx), vec2(reg_tmp8.xyyy));
    // 13: ifc
    if (all(conditional_code)) {
        sub_14_15();
    }
    // 15: max
    vs_out_attr3 = max(uniforms.f[93].xxxx, reg_tmp9);
    // 16: mov
    reg_tmp0.xy = (uniforms.f[10].xxxx).xy;
    // 17: ifu
    if (uniforms.b[9]) {
        sub_18_30();
    } else {
        sub_30_40();
    }
    // 40: nop
    // 41: mov
    reg_tmp0.xy = (uniforms.f[10].yyyy).xy;
    // 42: cmp
    conditional_code = equal(vec2(uniforms.f[93].yzzz), vec2(reg_tmp0.xyyy));
    // 43: ifc
    if (all(not(conditional_code))) {
        sub_44_45();
    } else {
        sub_45_49();
    }
    // 49: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 50: dp4
    reg_tmp4.x = dot(uniforms.f[14].xywz, reg_tmp6);
    // 51: dp4
    reg_tmp4.y = dot(uniforms.f[15].xywz, reg_tmp6);
    // 52: mov
    vs_out_attr5 = reg_tmp4;
    // 53: nop
    // 54: end
    return true;
}
bool sub_7_12() {
    // 7: mul
    reg_tmp0 = mul_safe(uniforms.f[7].wwww, vs_in_reg3);
    // 8: ifu
    if (uniforms.b[7]) {
        sub_9_10();
    }
    // 10: mul
    reg_tmp9.xyz = (mul_safe(uniforms.f[20].wwww, reg_tmp0.xyzz)).xyz;
    // 11: mov
    reg_tmp8.x = (uniforms.f[93].yyyy).x;
    return false;
}
bool sub_9_10() {
    // 9: mul
    reg_tmp9.w = (mul_safe(reg_tmp9.wwww, reg_tmp0.wwww)).w;
    return false;
}
bool sub_14_15() {
    // 14: mov
    reg_tmp9 = uniforms.f[21];
    return false;
}
bool sub_18_30() {
    // 18: cmp
    conditional_code = equal(vec2(uniforms.f[93].yzzz), vec2(reg_tmp0.xyyy));
    // 19: ifc
    if (all(not(conditional_code))) {
        sub_20_21();
    } else {
        sub_21_25();
    }
    // 25: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 26: dp4
    reg_tmp3.x = dot(uniforms.f[11].xywz, reg_tmp6);
    // 27: dp4
    reg_tmp3.y = dot(uniforms.f[12].xywz, reg_tmp6);
    // 28: mov
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    // 29: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_20_21() {
    // 20: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
    return false;
}
bool sub_21_25() {
    // 21: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_22_23();
    } else {
        sub_23_24();
    }
    // 24: nop
    return false;
}
bool sub_22_23() {
    // 22: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
    return false;
}
bool sub_23_24() {
    // 23: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
    return false;
}
bool sub_30_40() {
    // 30: cmp
    conditional_code = equal(vec2(uniforms.f[95].xyyy), vec2(reg_tmp0.xyyy));
    // 31: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 32: mov
    reg_tmp6 = reg_tmp10;
    // 33: dp4
    reg_tmp3.x = dot(uniforms.f[11], reg_tmp6);
    // 34: dp4
    reg_tmp3.y = dot(uniforms.f[12], reg_tmp6);
    // 35: dp4
    reg_tmp3.z = dot(uniforms.f[13], reg_tmp6);
    // 36: mul
    reg_tmp0.xy = (mul_safe(uniforms.f[19].xyyy, reg_tmp3.zzzz)).xy;
    // 37: add
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    // 38: nop
    // 39: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_44_45() {
    // 44: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
    return false;
}
bool sub_45_49() {
    // 45: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_46_47();
    } else {
        sub_47_48();
    }
    // 48: nop
    return false;
}
bool sub_46_47() {
    // 46: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
    return false;
}
bool sub_47_48() {
    // 47: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
    return false;
}
bool sub_56_61() {
    // 56: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 57: dp4
    reg_tmp3.x = dot(uniforms.f[25 + address_registers.x], reg_tmp15);
    // 58: dp4
    reg_tmp3.y = dot(uniforms.f[26 + address_registers.x], reg_tmp15);
    // 59: dp4
    reg_tmp3.z = dot(uniforms.f[27 + address_registers.x], reg_tmp15);
    // 60: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    return false;
}
bool sub_61_70() {
    // 61: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 62: dp4
    reg_tmp3.x = dot(uniforms.f[25 + address_registers.x], reg_tmp15);
    // 63: dp4
    reg_tmp3.y = dot(uniforms.f[26 + address_registers.x], reg_tmp15);
    // 64: dp4
    reg_tmp3.z = dot(uniforms.f[27 + address_registers.x], reg_tmp15);
    // 65: dp3
    reg_tmp4.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp14));
    // 66: dp3
    reg_tmp4.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp14));
    // 67: dp3
    reg_tmp4.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp14));
    // 68: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 69: mad
    reg_tmp12 = fma_safe(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_70_83() {
    // 70: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 71: dp4
    reg_tmp3.x = dot(uniforms.f[25 + address_registers.x], reg_tmp15);
    // 72: dp4
    reg_tmp3.y = dot(uniforms.f[26 + address_registers.x], reg_tmp15);
    // 73: dp4
    reg_tmp3.z = dot(uniforms.f[27 + address_registers.x], reg_tmp15);
    // 74: dp3
    reg_tmp4.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp14));
    // 75: dp3
    reg_tmp4.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp14));
    // 76: dp3
    reg_tmp4.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp14));
    // 77: dp3
    reg_tmp5.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp13));
    // 78: dp3
    reg_tmp5.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp13));
    // 79: dp3
    reg_tmp5.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp13));
    // 80: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 81: mad
    reg_tmp12 = fma_safe(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    // 82: mad
    reg_tmp11 = fma_safe(reg_tmp1.wwww, reg_tmp5, reg_tmp11);
    return false;
}
bool sub_83_293() {
    // 83: mul
    reg_tmp15.xyz = (mul_safe(uniforms.f[7].xxxx, vs_in_reg0)).xyz;
    // 84: mul
    reg_tmp14.xyz = (mul_safe(uniforms.f[7].yyyy, vs_in_reg1)).xyz;
    // 85: mul
    reg_tmp13.xyz = (mul_safe(uniforms.f[7].zzzz, vs_in_reg2)).xyz;
    // 86: add
    reg_tmp15.xyz = (uniforms.f[6] + reg_tmp15).xyz;
    // 87: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 88: ifu
    if (uniforms.b[1]) {
        sub_89_210();
    } else {
        sub_210_292();
    }
    // 292: nop
    return false;
}
bool sub_89_210() {
    // 89: mov
    reg_tmp0 = uniforms.f[7];
    // 90: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.yzzz));
    // 91: mov
    reg_tmp7 = uniforms.f[93].xxxx;
    // 92: mov
    reg_tmp12 = uniforms.f[93].xxxx;
    // 93: mov
    reg_tmp11 = uniforms.f[93].xxxx;
    // 94: mul
    reg_tmp2 = mul_safe(uniforms.f[93].wwww, vs_in_reg7);
    // 95: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_96_130();
    } else {
        sub_130_199();
    }
    // 199: mov
    vs_out_attr2 = -reg_tmp15;
    // 200: dp4
    reg_tmp0.x = dot(uniforms.f[86], reg_tmp15);
    // 201: dp4
    reg_tmp0.y = dot(uniforms.f[87], reg_tmp15);
    // 202: dp4
    reg_tmp0.z = dot(uniforms.f[88], reg_tmp15);
    // 203: dp4
    reg_tmp0.w = dot(uniforms.f[89], reg_tmp15);
    // 204: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 205: mul
    reg_tmp1.y = (mul_safe(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
    // 206: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 207: ifc
    if (all(conditional_code)) {
        sub_208_209();
    }
    // 209: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_96_130() {
    // 96: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 97: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 98: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 99: call
    {
        sub_61_70();
    }
    // 100: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 101: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 102: call
    {
        sub_61_70();
    }
    // 103: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 104: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 105: callc
    if (conditional_code.x) {
        sub_61_70();
    }
    // 106: ifu
    if (uniforms.b[8]) {
        sub_107_111();
    }
    // 111: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 112: dp4
    reg_tmp10.x = dot(uniforms.f[0], reg_tmp7);
    // 113: dp4
    reg_tmp10.y = dot(uniforms.f[1], reg_tmp7);
    // 114: dp4
    reg_tmp10.z = dot(uniforms.f[2], reg_tmp7);
    // 115: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 116: mov
    reg_tmp7 = reg_tmp10;
    // 117: dp4
    reg_tmp10.x = dot(uniforms.f[22], reg_tmp7);
    // 118: dp4
    reg_tmp10.y = dot(uniforms.f[23], reg_tmp7);
    // 119: dp4
    reg_tmp10.z = dot(uniforms.f[24], reg_tmp7);
    // 120: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 121: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 122: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 123: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 124: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 125: dp3
    reg_tmp14.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp12));
    // 126: dp3
    reg_tmp14.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp12));
    // 127: dp3
    reg_tmp14.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp12));
    // 128: call
    {
        sub_293_310();
    }
    // 129: nop
    return false;
}
bool sub_107_111() {
    // 107: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 108: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 109: callc
    if (conditional_code.y) {
        sub_61_70();
    }
    // 110: nop
    return false;
}
bool sub_130_199() {
    // 130: ifc
    if (all(conditional_code)) {
        sub_131_168();
    } else {
        sub_168_198();
    }
    // 198: nop
    return false;
}
bool sub_131_168() {
    // 131: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 132: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 133: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 134: call
    {
        sub_70_83();
    }
    // 135: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 136: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 137: call
    {
        sub_70_83();
    }
    // 138: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 139: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 140: callc
    if (conditional_code.x) {
        sub_70_83();
    }
    // 141: ifu
    if (uniforms.b[8]) {
        sub_142_146();
    }
    // 146: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 147: dp4
    reg_tmp10.x = dot(uniforms.f[0], reg_tmp7);
    // 148: dp4
    reg_tmp10.y = dot(uniforms.f[1], reg_tmp7);
    // 149: dp4
    reg_tmp10.z = dot(uniforms.f[2], reg_tmp7);
    // 150: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 151: mov
    reg_tmp7 = reg_tmp10;
    // 152: dp4
    reg_tmp10.x = dot(uniforms.f[22], reg_tmp7);
    // 153: dp4
    reg_tmp10.y = dot(uniforms.f[23], reg_tmp7);
    // 154: dp4
    reg_tmp10.z = dot(uniforms.f[24], reg_tmp7);
    // 155: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 156: dp3
    reg_tmp13.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp11));
    // 157: dp3
    reg_tmp13.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp11));
    // 158: dp3
    reg_tmp13.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp11));
    // 159: dp3
    reg_tmp14.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp12));
    // 160: dp3
    reg_tmp14.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp12));
    // 161: dp3
    reg_tmp14.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp12));
    // 162: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 163: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 164: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 165: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 166: call
    {
        sub_310_386();
    }
    // 167: nop
    return false;
}
bool sub_142_146() {
    // 142: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 143: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 144: callc
    if (conditional_code.y) {
        sub_70_83();
    }
    // 145: nop
    return false;
}
bool sub_168_198() {
    // 168: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 169: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 170: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 171: call
    {
        sub_56_61();
    }
    // 172: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 173: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 174: call
    {
        sub_56_61();
    }
    // 175: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 176: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 177: callc
    if (conditional_code.x) {
        sub_56_61();
    }
    // 178: ifu
    if (uniforms.b[8]) {
        sub_179_183();
    }
    // 183: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 184: dp4
    reg_tmp10.x = dot(uniforms.f[0], reg_tmp7);
    // 185: dp4
    reg_tmp10.y = dot(uniforms.f[1], reg_tmp7);
    // 186: dp4
    reg_tmp10.z = dot(uniforms.f[2], reg_tmp7);
    // 187: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 188: mov
    reg_tmp7 = reg_tmp10;
    // 189: dp4
    reg_tmp10.x = dot(uniforms.f[22], reg_tmp7);
    // 190: dp4
    reg_tmp10.y = dot(uniforms.f[23], reg_tmp7);
    // 191: dp4
    reg_tmp10.z = dot(uniforms.f[24], reg_tmp7);
    // 192: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 193: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 194: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 195: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 196: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 197: mov
    vs_out_attr1 = uniforms.f[93].xxxx;
    return false;
}
bool sub_179_183() {
    // 179: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 180: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 181: callc
    if (conditional_code.y) {
        sub_56_61();
    }
    // 182: nop
    return false;
}
bool sub_208_209() {
    // 208: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_210_292() {
    // 210: ifu
    if (uniforms.b[2]) {
        sub_211_221();
    } else {
        sub_221_226();
    }
    // 226: mov
    reg_tmp0 = uniforms.f[7];
    // 227: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.yzzz));
    // 228: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_229_246();
    } else {
        sub_246_281();
    }
    // 281: mov
    vs_out_attr2 = -reg_tmp15;
    // 282: dp4
    reg_tmp0.x = dot(uniforms.f[86], reg_tmp15);
    // 283: dp4
    reg_tmp0.y = dot(uniforms.f[87], reg_tmp15);
    // 284: dp4
    reg_tmp0.z = dot(uniforms.f[88], reg_tmp15);
    // 285: dp4
    reg_tmp0.w = dot(uniforms.f[89], reg_tmp15);
    // 286: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 287: mul
    reg_tmp1.y = (mul_safe(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
    // 288: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 289: ifc
    if (all(conditional_code)) {
        sub_290_291();
    }
    // 291: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_211_221() {
    // 211: mul
    reg_tmp1.x = (mul_safe(uniforms.f[93].wwww, vs_in_reg7.xxxx)).x;
    // 212: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 213: dp4
    reg_tmp7.x = dot(uniforms.f[25 + address_registers.x], reg_tmp15);
    // 214: dp4
    reg_tmp7.y = dot(uniforms.f[26 + address_registers.x], reg_tmp15);
    // 215: dp4
    reg_tmp7.z = dot(uniforms.f[27 + address_registers.x], reg_tmp15);
    // 216: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 217: dp4
    reg_tmp10.x = dot(uniforms.f[0], reg_tmp7);
    // 218: dp4
    reg_tmp10.y = dot(uniforms.f[1], reg_tmp7);
    // 219: dp4
    reg_tmp10.z = dot(uniforms.f[2], reg_tmp7);
    // 220: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_221_226() {
    // 221: mova
    address_registers.x = (ivec2(uniforms.f[93].xxxx)).x;
    // 222: dp4
    reg_tmp10.x = dot(uniforms.f[25], reg_tmp15);
    // 223: dp4
    reg_tmp10.y = dot(uniforms.f[26], reg_tmp15);
    // 224: dp4
    reg_tmp10.z = dot(uniforms.f[27], reg_tmp15);
    // 225: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_229_246() {
    // 229: dp3
    reg_tmp12.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp14));
    // 230: dp3
    reg_tmp12.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp14));
    // 231: dp3
    reg_tmp12.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp14));
    // 232: mov
    reg_tmp7 = reg_tmp10;
    // 233: dp4
    reg_tmp10.x = dot(uniforms.f[22], reg_tmp7);
    // 234: dp4
    reg_tmp10.y = dot(uniforms.f[23], reg_tmp7);
    // 235: dp4
    reg_tmp10.z = dot(uniforms.f[24], reg_tmp7);
    // 236: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 237: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 238: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 239: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 240: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 241: dp3
    reg_tmp14.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp12));
    // 242: dp3
    reg_tmp14.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp12));
    // 243: dp3
    reg_tmp14.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp12));
    // 244: call
    {
        sub_293_310();
    }
    // 245: nop
    return false;
}
bool sub_246_281() {
    // 246: ifc
    if (all(conditional_code)) {
        sub_247_270();
    } else {
        sub_270_280();
    }
    // 280: nop
    return false;
}
bool sub_247_270() {
    // 247: dp3
    reg_tmp12.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp14));
    // 248: dp3
    reg_tmp12.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp14));
    // 249: dp3
    reg_tmp12.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp14));
    // 250: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp13));
    // 251: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp13));
    // 252: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp13));
    // 253: mov
    reg_tmp7 = reg_tmp10;
    // 254: dp4
    reg_tmp10.x = dot(uniforms.f[22], reg_tmp7);
    // 255: dp4
    reg_tmp10.y = dot(uniforms.f[23], reg_tmp7);
    // 256: dp4
    reg_tmp10.z = dot(uniforms.f[24], reg_tmp7);
    // 257: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 258: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 259: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 260: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 261: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 262: dp3
    reg_tmp14.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp12));
    // 263: dp3
    reg_tmp14.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp12));
    // 264: dp3
    reg_tmp14.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp12));
    // 265: dp3
    reg_tmp13.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp11));
    // 266: dp3
    reg_tmp13.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp11));
    // 267: dp3
    reg_tmp13.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp11));
    // 268: call
    {
        sub_310_386();
    }
    // 269: nop
    return false;
}
bool sub_270_280() {
    // 270: mov
    reg_tmp7 = reg_tmp10;
    // 271: dp4
    reg_tmp10.x = dot(uniforms.f[22], reg_tmp7);
    // 272: dp4
    reg_tmp10.y = dot(uniforms.f[23], reg_tmp7);
    // 273: dp4
    reg_tmp10.z = dot(uniforms.f[24], reg_tmp7);
    // 274: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 275: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 276: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 277: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 278: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 279: mov
    vs_out_attr1 = uniforms.f[93].xxxx;
    return false;
}
bool sub_290_291() {
    // 290: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_293_310() {
    uint jmp_to = 293u;
    while (true) {
        switch (jmp_to) {
        case 293u: {
            // 293: dp3
            reg_tmp6.x = dot(vec3(reg_tmp14), vec3(reg_tmp14));
            // 294: dp3
            reg_tmp7.x = dot(vec3(reg_tmp12), vec3(reg_tmp12));
            // 295: rsq
            reg_tmp6.x = rsq_safe(reg_tmp6.xxxx.x);
            // 296: rsq
            reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
            // 297: mul
            reg_tmp14.xyz = (mul_safe(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 298: mul
            reg_tmp12.xyz = (mul_safe(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 299: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 300: jmpu
            if (!uniforms.b[15]) {
                { jmp_to = 309u; break; }
            }
            // 301: add
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            // 302: mul
            reg_tmp4 = mul_safe(uniforms.f[94].zzzz, reg_tmp4);
            // 303: cmp
            conditional_code = greaterThanEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp4.xxxx));
            // 304: rsq
            reg_tmp4 = vec4(rsq_safe(reg_tmp4.xxxx.x));
            // 305: mul
            reg_tmp5 = mul_safe(uniforms.f[94].zzzz, reg_tmp14);
            // 306: jmpc
            if (conditional_code.x) {
                { jmp_to = 309u; break; }
            }
            // 307: rcp
            reg_tmp0.z = rcp_safe(reg_tmp4.xxxx.x);
            // 308: mul
            reg_tmp0.xy = (mul_safe(reg_tmp5, reg_tmp4)).xy;
        }
        case 309u: {
            // 309: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_310_386() {
    uint jmp_to = 310u;
    while (true) {
        switch (jmp_to) {
        case 310u: {
            // 310: dp3
            reg_tmp6.x = dot(vec3(reg_tmp14), vec3(reg_tmp14));
            // 311: dp3
            reg_tmp7.x = dot(vec3(reg_tmp12), vec3(reg_tmp12));
            // 312: rsq
            reg_tmp6.x = rsq_safe(reg_tmp6.xxxx.x);
            // 313: rsq
            reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
            // 314: mul
            reg_tmp14.xyz = (mul_safe(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 315: mul
            reg_tmp12.xyz = (mul_safe(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 316: mul
            reg_tmp13.xyz = (mul_safe(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            // 317: mul
            reg_tmp11.xyz = (mul_safe(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            // 318: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 319: jmpu
            if (!uniforms.b[15]) {
                { jmp_to = 385u; break; }
            }
            // 320: mul
            reg_tmp13.xyz = (mul_safe(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            // 321: mul
            reg_tmp11.xyz = (mul_safe(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            // 322: mul
            reg_tmp5 = mul_safe(reg_tmp14.yzxx, reg_tmp13.zxyy);
            // 323: mad
            reg_tmp5 = fma_safe(-reg_tmp13.yzxx, reg_tmp14.zxyy, reg_tmp5);
            // 324: dp3
            reg_tmp5.w = dot(vec3(reg_tmp5), vec3(reg_tmp5));
            // 325: rsq
            reg_tmp5.w = rsq_safe(reg_tmp5.wwww.x);
            // 326: mul
            reg_tmp5 = mul_safe(reg_tmp5, reg_tmp5.wwww);
            // 327: add
            reg_tmp6.w = (reg_tmp14.zzzz + reg_tmp5.yyyy).w;
            // 328: mul
            reg_tmp13 = mul_safe(reg_tmp5.yzxx, reg_tmp14.zxyy);
            // 329: mad
            reg_tmp13 = fma_safe(-reg_tmp14.yzxx, reg_tmp5.zxyy, reg_tmp13);
            // 330: add
            reg_tmp6.w = (reg_tmp13.xxxx + reg_tmp6).w;
            // 331: mov
            reg_tmp13.w = (reg_tmp5.zzzz).w;
            // 332: mov
            reg_tmp5.z = (reg_tmp13.xxxx).z;
            // 333: add
            reg_tmp6.w = (uniforms.f[93].yyyy + reg_tmp6).w;
            // 334: mov
            reg_tmp14.w = (reg_tmp5.xxxx).w;
            // 335: mov
            reg_tmp5.x = (reg_tmp14.zzzz).x;
            // 336: cmp
            conditional_code = lessThan(vec2(uniforms.f[94].yyyy), vec2(reg_tmp6.wwww));
            // 337: mov
            reg_tmp6.x = (uniforms.f[93].yyyy).x;
            // 338: mov
            reg_tmp6.y = (-uniforms.f[93].yyyy).y;
            // 339: jmpc
            if (!conditional_code.x) {
                { jmp_to = 347u; break; }
            }
            // 340: add
            reg_tmp7.xz = (reg_tmp13.wwyy + -reg_tmp14.yyww).xz;
            // 341: add
            reg_tmp7.y = (reg_tmp14.xxxx + -reg_tmp13.zzzz).y;
            // 342: mov
            reg_tmp7.w = (reg_tmp6).w;
            // 343: dp4
            reg_tmp6 = vec4(dot(reg_tmp7, reg_tmp7));
            // 344: rsq
            reg_tmp6 = vec4(rsq_safe(reg_tmp6.xxxx.x));
            // 345: mul
            reg_tmp0 = mul_safe(reg_tmp7, reg_tmp6);
            // 346: jmpu
            if (uniforms.b[0]) {
                { jmp_to = 385u; break; }
            }
        }
        case 347u: {
            // 347: cmp
            conditional_code = greaterThan(vec2(reg_tmp5.zyyy), vec2(reg_tmp5.yxxx));
            // 348: ifc
            if (conditional_code.x) {
                sub_349_369();
            } else {
                sub_369_382();
            }
            // 382: dp4
            reg_tmp6 = vec4(dot(reg_tmp8, reg_tmp8));
            // 383: rsq
            reg_tmp6 = vec4(rsq_safe(reg_tmp6.xxxx.x));
            // 384: mul
            reg_tmp0 = mul_safe(reg_tmp8, reg_tmp6);
        }
        case 385u: {
            // 385: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_349_369() {
    // 349: ifc
    if (conditional_code.y) {
        sub_350_355();
    } else {
        sub_355_368();
    }
    // 368: mov
    reg_tmp8.w = (-reg_tmp8).w;
    return false;
}
bool sub_350_355() {
    // 350: mul
    reg_tmp8 = mul_safe(reg_tmp13.yyzw, reg_tmp6.xxxy);
    // 351: add
    reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
    // 352: add
    reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
    // 353: add
    reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
    // 354: add
    reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
    return false;
}
bool sub_355_368() {
    // 355: cmp
    conditional_code = greaterThan(vec2(reg_tmp5.zzzz), vec2(reg_tmp5.xxxx));
    // 356: mul
    reg_tmp8 = mul_safe(reg_tmp13.yyzw, reg_tmp6.xxxy);
    // 357: add
    reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
    // 358: ifc
    if (conditional_code.x) {
        sub_359_362();
    } else {
        sub_362_367();
    }
    // 367: nop
    return false;
}
bool sub_359_362() {
    // 359: add
    reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
    // 360: add
    reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
    // 361: add
    reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
    return false;
}
bool sub_362_367() {
    // 362: mul
    reg_tmp8 = mul_safe(reg_tmp13.zwwy, reg_tmp6.xxxy);
    // 363: add
    reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
    // 364: add
    reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
    // 365: add
    reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
    // 366: add
    reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
    return false;
}
bool sub_369_382() {
    // 369: ifc
    if (conditional_code.y) {
        sub_370_375();
    } else {
        sub_375_381();
    }
    // 381: nop
    return false;
}
bool sub_370_375() {
    // 370: mul
    reg_tmp8 = mul_safe(reg_tmp13.yywz, reg_tmp6.xxxy);
    // 371: add
    reg_tmp8.y = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).y;
    // 372: add
    reg_tmp9 = reg_tmp5.yyyy + -reg_tmp5.xxxx;
    // 373: add
    reg_tmp8.xzw = (reg_tmp8 + reg_tmp14.wwyx).xzw;
    // 374: add
    reg_tmp8.y = (reg_tmp9 + reg_tmp8).y;
    return false;
}
bool sub_375_381() {
    // 375: mul
    reg_tmp8 = mul_safe(reg_tmp13.zwwy, reg_tmp6.xxxy);
    // 376: add
    reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
    // 377: add
    reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
    // 378: add
    reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
    // 379: add
    reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
    // 380: mov
    reg_tmp8.w = (-reg_tmp8).w;
    return false;
}
// reference: 6939A9C9CEF0CB35, 87F539836ED26483
// program: 87F539836ED26483, 3B3AE026C742C7D5, 85967F14F07719A7
// reference: 3D19834390B293A1, 5C7DAF9CBE61E818
// program: 5C7DAF9CBE61E818, 3B3AE026C742C7D5, FEB1E39313EC6A3F
// program: 5C7DAF9CBE61E818, 3B3AE026C742C7D5, AB9CD65F41BDEFA0
// program: 5C7DAF9CBE61E818, 3B3AE026C742C7D5, B29EF1BFC4D10886
// program: 5C7DAF9CBE61E818, 3B3AE026C742C7D5, 98677AC22B9A3E1A
// program: 5C7DAF9CBE61E818, 3B3AE026C742C7D5, 92F4F0B0E6943599
// program: 87F539836ED26483, 3B3AE026C742C7D5, 18CD6F34EF819318
// program: 5C7DAF9CBE61E818, 3B3AE026C742C7D5, 06A8A4F9432C9B26
// shader: 8B31, 2C5B088B7FE4BF56

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;
 out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define mul_safe(x, y) (x * y)
#define rcp_safe(x) (1.0f / x)
#define rsq_safe(x) inversesqrt(x)
#define fma_safe(x, y, z) fma(x, y, z)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_56_61();
bool sub_61_70();
bool sub_70_83();
bool sub_83_251();
bool sub_89_189();
bool sub_96_125();
bool sub_107_111();
bool sub_125_184();
bool sub_126_158();
bool sub_137_141();
bool sub_158_183();
bool sub_169_173();
bool sub_189_250();
bool sub_192_202();
bool sub_202_207();
bool sub_208_220();
bool sub_220_245();
bool sub_221_239();
bool sub_239_244();
bool sub_251_268();
bool sub_268_344();
bool sub_307_327();
bool sub_308_313();
bool sub_313_326();
bool sub_317_320();
bool sub_320_325();
bool sub_327_340();
bool sub_328_333();
bool sub_333_339();
bool sub_344_4096();
bool sub_351_356();
bool sub_353_354();
bool sub_358_359();
bool sub_362_374();
bool sub_364_365();
bool sub_365_369();
bool sub_366_367();
bool sub_367_368();
bool sub_374_384();
bool sub_388_389();
bool sub_389_393();
bool sub_390_391();
bool sub_391_392();
bool sub_401_402();
bool sub_402_406();
bool sub_403_404();
bool sub_404_405();

bool exec_shader() {
    sub_344_4096();
    return true;
}

bool sub_56_61() {
    // 56: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 57: dp4
    reg_tmp3.x = dot(uniforms.f[25 + address_registers.x], reg_tmp15);
    // 58: dp4
    reg_tmp3.y = dot(uniforms.f[26 + address_registers.x], reg_tmp15);
    // 59: dp4
    reg_tmp3.z = dot(uniforms.f[27 + address_registers.x], reg_tmp15);
    // 60: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    return false;
}
bool sub_61_70() {
    // 61: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 62: dp4
    reg_tmp3.x = dot(uniforms.f[25 + address_registers.x], reg_tmp15);
    // 63: dp4
    reg_tmp3.y = dot(uniforms.f[26 + address_registers.x], reg_tmp15);
    // 64: dp4
    reg_tmp3.z = dot(uniforms.f[27 + address_registers.x], reg_tmp15);
    // 65: dp3
    reg_tmp4.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp14));
    // 66: dp3
    reg_tmp4.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp14));
    // 67: dp3
    reg_tmp4.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp14));
    // 68: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 69: mad
    reg_tmp12 = fma_safe(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_70_83() {
    // 70: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 71: dp4
    reg_tmp3.x = dot(uniforms.f[25 + address_registers.x], reg_tmp15);
    // 72: dp4
    reg_tmp3.y = dot(uniforms.f[26 + address_registers.x], reg_tmp15);
    // 73: dp4
    reg_tmp3.z = dot(uniforms.f[27 + address_registers.x], reg_tmp15);
    // 74: dp3
    reg_tmp4.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp14));
    // 75: dp3
    reg_tmp4.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp14));
    // 76: dp3
    reg_tmp4.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp14));
    // 77: dp3
    reg_tmp5.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp13));
    // 78: dp3
    reg_tmp5.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp13));
    // 79: dp3
    reg_tmp5.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp13));
    // 80: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 81: mad
    reg_tmp12 = fma_safe(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    // 82: mad
    reg_tmp11 = fma_safe(reg_tmp1.wwww, reg_tmp5, reg_tmp11);
    return false;
}
bool sub_83_251() {
    // 83: mul
    reg_tmp15.xyz = (mul_safe(uniforms.f[7].xxxx, vs_in_reg0)).xyz;
    // 84: mul
    reg_tmp14.xyz = (mul_safe(uniforms.f[7].yyyy, vs_in_reg1)).xyz;
    // 85: mul
    reg_tmp13.xyz = (mul_safe(uniforms.f[7].zzzz, vs_in_reg2)).xyz;
    // 86: add
    reg_tmp15.xyz = (uniforms.f[6] + reg_tmp15).xyz;
    // 87: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 88: ifu
    if (uniforms.b[1]) {
        sub_89_189();
    } else {
        sub_189_250();
    }
    // 250: nop
    return false;
}
bool sub_89_189() {
    // 89: mov
    reg_tmp0 = uniforms.f[7];
    // 90: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.yzzz));
    // 91: mov
    reg_tmp7 = uniforms.f[93].xxxx;
    // 92: mov
    reg_tmp12 = uniforms.f[93].xxxx;
    // 93: mov
    reg_tmp11 = uniforms.f[93].xxxx;
    // 94: mul
    reg_tmp2 = mul_safe(uniforms.f[93].wwww, vs_in_reg7);
    // 95: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_96_125();
    } else {
        sub_125_184();
    }
    // 184: mov
    vs_out_attr2 = -reg_tmp15;
    // 185: dp4
    vs_out_attr0.x = dot(uniforms.f[86], reg_tmp15);
    // 186: dp4
    vs_out_attr0.y = dot(uniforms.f[87], reg_tmp15);
    // 187: dp4
    vs_out_attr0.z = dot(uniforms.f[88], reg_tmp15);
    // 188: dp4
    vs_out_attr0.w = dot(uniforms.f[89], reg_tmp15);
    return false;
}
bool sub_96_125() {
    // 96: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 97: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 98: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 99: call
    {
        sub_61_70();
    }
    // 100: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 101: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 102: call
    {
        sub_61_70();
    }
    // 103: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 104: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 105: callc
    if (conditional_code.x) {
        sub_61_70();
    }
    // 106: ifu
    if (uniforms.b[8]) {
        sub_107_111();
    }
    // 111: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 112: dp4
    reg_tmp10.x = dot(uniforms.f[0], reg_tmp7);
    // 113: dp4
    reg_tmp10.y = dot(uniforms.f[1], reg_tmp7);
    // 114: dp4
    reg_tmp10.z = dot(uniforms.f[2], reg_tmp7);
    // 115: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 116: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 117: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 118: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 119: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 120: dp3
    reg_tmp14.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp12));
    // 121: dp3
    reg_tmp14.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp12));
    // 122: dp3
    reg_tmp14.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp12));
    // 123: call
    {
        sub_251_268();
    }
    // 124: nop
    return false;
}
bool sub_107_111() {
    // 107: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 108: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 109: callc
    if (conditional_code.y) {
        sub_61_70();
    }
    // 110: nop
    return false;
}
bool sub_125_184() {
    // 125: ifc
    if (all(conditional_code)) {
        sub_126_158();
    } else {
        sub_158_183();
    }
    // 183: nop
    return false;
}
bool sub_126_158() {
    // 126: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 127: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 128: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 129: call
    {
        sub_70_83();
    }
    // 130: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 131: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 132: call
    {
        sub_70_83();
    }
    // 133: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 134: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 135: callc
    if (conditional_code.x) {
        sub_70_83();
    }
    // 136: ifu
    if (uniforms.b[8]) {
        sub_137_141();
    }
    // 141: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 142: dp4
    reg_tmp10.x = dot(uniforms.f[0], reg_tmp7);
    // 143: dp4
    reg_tmp10.y = dot(uniforms.f[1], reg_tmp7);
    // 144: dp4
    reg_tmp10.z = dot(uniforms.f[2], reg_tmp7);
    // 145: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 146: dp3
    reg_tmp13.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp11));
    // 147: dp3
    reg_tmp13.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp11));
    // 148: dp3
    reg_tmp13.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp11));
    // 149: dp3
    reg_tmp14.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp12));
    // 150: dp3
    reg_tmp14.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp12));
    // 151: dp3
    reg_tmp14.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp12));
    // 152: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 153: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 154: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 155: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 156: call
    {
        sub_268_344();
    }
    // 157: nop
    return false;
}
bool sub_137_141() {
    // 137: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 138: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 139: callc
    if (conditional_code.y) {
        sub_70_83();
    }
    // 140: nop
    return false;
}
bool sub_158_183() {
    // 158: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 159: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 160: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 161: call
    {
        sub_56_61();
    }
    // 162: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 163: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 164: call
    {
        sub_56_61();
    }
    // 165: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 166: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 167: callc
    if (conditional_code.x) {
        sub_56_61();
    }
    // 168: ifu
    if (uniforms.b[8]) {
        sub_169_173();
    }
    // 173: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 174: dp4
    reg_tmp10.x = dot(uniforms.f[0], reg_tmp7);
    // 175: dp4
    reg_tmp10.y = dot(uniforms.f[1], reg_tmp7);
    // 176: dp4
    reg_tmp10.z = dot(uniforms.f[2], reg_tmp7);
    // 177: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 178: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 179: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 180: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 181: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 182: mov
    vs_out_attr1 = uniforms.f[93].xxxx;
    return false;
}
bool sub_169_173() {
    // 169: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 170: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 171: callc
    if (conditional_code.y) {
        sub_56_61();
    }
    // 172: nop
    return false;
}
bool sub_189_250() {
    // 189: mov
    reg_tmp0 = uniforms.f[7];
    // 190: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.yzzz));
    // 191: ifu
    if (uniforms.b[2]) {
        sub_192_202();
    } else {
        sub_202_207();
    }
    // 207: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_208_220();
    } else {
        sub_220_245();
    }
    // 245: mov
    vs_out_attr2 = -reg_tmp15;
    // 246: dp4
    vs_out_attr0.x = dot(uniforms.f[86], reg_tmp15);
    // 247: dp4
    vs_out_attr0.y = dot(uniforms.f[87], reg_tmp15);
    // 248: dp4
    vs_out_attr0.z = dot(uniforms.f[88], reg_tmp15);
    // 249: dp4
    vs_out_attr0.w = dot(uniforms.f[89], reg_tmp15);
    return false;
}
bool sub_192_202() {
    // 192: mul
    reg_tmp1.x = (mul_safe(uniforms.f[93].wwww, vs_in_reg7.xxxx)).x;
    // 193: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 194: dp4
    reg_tmp7.x = dot(uniforms.f[25 + address_registers.x], reg_tmp15);
    // 195: dp4
    reg_tmp7.y = dot(uniforms.f[26 + address_registers.x], reg_tmp15);
    // 196: dp4
    reg_tmp7.z = dot(uniforms.f[27 + address_registers.x], reg_tmp15);
    // 197: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 198: dp4
    reg_tmp10.x = dot(uniforms.f[0], reg_tmp7);
    // 199: dp4
    reg_tmp10.y = dot(uniforms.f[1], reg_tmp7);
    // 200: dp4
    reg_tmp10.z = dot(uniforms.f[2], reg_tmp7);
    // 201: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_202_207() {
    // 202: mova
    address_registers.x = (ivec2(uniforms.f[93].xxxx)).x;
    // 203: dp4
    reg_tmp10.x = dot(uniforms.f[25], reg_tmp15);
    // 204: dp4
    reg_tmp10.y = dot(uniforms.f[26], reg_tmp15);
    // 205: dp4
    reg_tmp10.z = dot(uniforms.f[27], reg_tmp15);
    // 206: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_208_220() {
    // 208: dp3
    reg_tmp12.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp14));
    // 209: dp3
    reg_tmp12.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp14));
    // 210: dp3
    reg_tmp12.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp14));
    // 211: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 212: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 213: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 214: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 215: dp3
    reg_tmp14.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp12));
    // 216: dp3
    reg_tmp14.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp12));
    // 217: dp3
    reg_tmp14.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp12));
    // 218: call
    {
        sub_251_268();
    }
    // 219: nop
    return false;
}
bool sub_220_245() {
    // 220: ifc
    if (all(conditional_code)) {
        sub_221_239();
    } else {
        sub_239_244();
    }
    // 244: nop
    return false;
}
bool sub_221_239() {
    // 221: dp3
    reg_tmp12.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp14));
    // 222: dp3
    reg_tmp12.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp14));
    // 223: dp3
    reg_tmp12.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp14));
    // 224: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp13));
    // 225: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp13));
    // 226: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp13));
    // 227: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 228: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 229: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 230: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 231: dp3
    reg_tmp14.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp12));
    // 232: dp3
    reg_tmp14.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp12));
    // 233: dp3
    reg_tmp14.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp12));
    // 234: dp3
    reg_tmp13.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp11));
    // 235: dp3
    reg_tmp13.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp11));
    // 236: dp3
    reg_tmp13.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp11));
    // 237: call
    {
        sub_268_344();
    }
    // 238: nop
    return false;
}
bool sub_239_244() {
    // 239: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 240: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 241: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 242: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 243: mov
    vs_out_attr1 = uniforms.f[93].xxxx;
    return false;
}
bool sub_251_268() {
    uint jmp_to = 251u;
    while (true) {
        switch (jmp_to) {
        case 251u: {
            // 251: dp3
            reg_tmp6.x = dot(vec3(reg_tmp14), vec3(reg_tmp14));
            // 252: dp3
            reg_tmp7.x = dot(vec3(reg_tmp12), vec3(reg_tmp12));
            // 253: rsq
            reg_tmp6.x = rsq_safe(reg_tmp6.xxxx.x);
            // 254: rsq
            reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
            // 255: mul
            reg_tmp14.xyz = (mul_safe(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 256: mul
            reg_tmp12.xyz = (mul_safe(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 257: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 258: jmpu
            if (!uniforms.b[15]) {
                { jmp_to = 267u; break; }
            }
            // 259: add
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            // 260: mul
            reg_tmp4 = mul_safe(uniforms.f[94].zzzz, reg_tmp4);
            // 261: cmp
            conditional_code = greaterThanEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp4.xxxx));
            // 262: rsq
            reg_tmp4 = vec4(rsq_safe(reg_tmp4.xxxx.x));
            // 263: mul
            reg_tmp5 = mul_safe(uniforms.f[94].zzzz, reg_tmp14);
            // 264: jmpc
            if (conditional_code.x) {
                { jmp_to = 267u; break; }
            }
            // 265: rcp
            reg_tmp0.z = rcp_safe(reg_tmp4.xxxx.x);
            // 266: mul
            reg_tmp0.xy = (mul_safe(reg_tmp5, reg_tmp4)).xy;
        }
        case 267u: {
            // 267: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_268_344() {
    uint jmp_to = 268u;
    while (true) {
        switch (jmp_to) {
        case 268u: {
            // 268: dp3
            reg_tmp6.x = dot(vec3(reg_tmp14), vec3(reg_tmp14));
            // 269: dp3
            reg_tmp7.x = dot(vec3(reg_tmp12), vec3(reg_tmp12));
            // 270: rsq
            reg_tmp6.x = rsq_safe(reg_tmp6.xxxx.x);
            // 271: rsq
            reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
            // 272: mul
            reg_tmp14.xyz = (mul_safe(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 273: mul
            reg_tmp12.xyz = (mul_safe(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 274: mul
            reg_tmp13.xyz = (mul_safe(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            // 275: mul
            reg_tmp11.xyz = (mul_safe(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            // 276: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 277: jmpu
            if (!uniforms.b[15]) {
                { jmp_to = 343u; break; }
            }
            // 278: mul
            reg_tmp13.xyz = (mul_safe(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            // 279: mul
            reg_tmp11.xyz = (mul_safe(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            // 280: mul
            reg_tmp5 = mul_safe(reg_tmp14.yzxx, reg_tmp13.zxyy);
            // 281: mad
            reg_tmp5 = fma_safe(-reg_tmp13.yzxx, reg_tmp14.zxyy, reg_tmp5);
            // 282: dp3
            reg_tmp5.w = dot(vec3(reg_tmp5), vec3(reg_tmp5));
            // 283: rsq
            reg_tmp5.w = rsq_safe(reg_tmp5.wwww.x);
            // 284: mul
            reg_tmp5 = mul_safe(reg_tmp5, reg_tmp5.wwww);
            // 285: add
            reg_tmp6.w = (reg_tmp14.zzzz + reg_tmp5.yyyy).w;
            // 286: mul
            reg_tmp13 = mul_safe(reg_tmp5.yzxx, reg_tmp14.zxyy);
            // 287: mad
            reg_tmp13 = fma_safe(-reg_tmp14.yzxx, reg_tmp5.zxyy, reg_tmp13);
            // 288: add
            reg_tmp6.w = (reg_tmp13.xxxx + reg_tmp6).w;
            // 289: mov
            reg_tmp13.w = (reg_tmp5.zzzz).w;
            // 290: mov
            reg_tmp5.z = (reg_tmp13.xxxx).z;
            // 291: add
            reg_tmp6.w = (uniforms.f[93].yyyy + reg_tmp6).w;
            // 292: mov
            reg_tmp14.w = (reg_tmp5.xxxx).w;
            // 293: mov
            reg_tmp5.x = (reg_tmp14.zzzz).x;
            // 294: cmp
            conditional_code = lessThan(vec2(uniforms.f[94].yyyy), vec2(reg_tmp6.wwww));
            // 295: mov
            reg_tmp6.x = (uniforms.f[93].yyyy).x;
            // 296: mov
            reg_tmp6.y = (-uniforms.f[93].yyyy).y;
            // 297: jmpc
            if (!conditional_code.x) {
                { jmp_to = 305u; break; }
            }
            // 298: add
            reg_tmp7.xz = (reg_tmp13.wwyy + -reg_tmp14.yyww).xz;
            // 299: add
            reg_tmp7.y = (reg_tmp14.xxxx + -reg_tmp13.zzzz).y;
            // 300: mov
            reg_tmp7.w = (reg_tmp6).w;
            // 301: dp4
            reg_tmp6 = vec4(dot(reg_tmp7, reg_tmp7));
            // 302: rsq
            reg_tmp6 = vec4(rsq_safe(reg_tmp6.xxxx.x));
            // 303: mul
            reg_tmp0 = mul_safe(reg_tmp7, reg_tmp6);
            // 304: jmpu
            if (uniforms.b[0]) {
                { jmp_to = 343u; break; }
            }
        }
        case 305u: {
            // 305: cmp
            conditional_code = greaterThan(vec2(reg_tmp5.zyyy), vec2(reg_tmp5.yxxx));
            // 306: ifc
            if (conditional_code.x) {
                sub_307_327();
            } else {
                sub_327_340();
            }
            // 340: dp4
            reg_tmp6 = vec4(dot(reg_tmp8, reg_tmp8));
            // 341: rsq
            reg_tmp6 = vec4(rsq_safe(reg_tmp6.xxxx.x));
            // 342: mul
            reg_tmp0 = mul_safe(reg_tmp8, reg_tmp6);
        }
        case 343u: {
            // 343: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_307_327() {
    // 307: ifc
    if (conditional_code.y) {
        sub_308_313();
    } else {
        sub_313_326();
    }
    // 326: mov
    reg_tmp8.w = (-reg_tmp8).w;
    return false;
}
bool sub_308_313() {
    // 308: mul
    reg_tmp8 = mul_safe(reg_tmp13.yyzw, reg_tmp6.xxxy);
    // 309: add
    reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
    // 310: add
    reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
    // 311: add
    reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
    // 312: add
    reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
    return false;
}
bool sub_313_326() {
    // 313: cmp
    conditional_code = greaterThan(vec2(reg_tmp5.zzzz), vec2(reg_tmp5.xxxx));
    // 314: mul
    reg_tmp8 = mul_safe(reg_tmp13.yyzw, reg_tmp6.xxxy);
    // 315: add
    reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
    // 316: ifc
    if (conditional_code.x) {
        sub_317_320();
    } else {
        sub_320_325();
    }
    // 325: nop
    return false;
}
bool sub_317_320() {
    // 317: add
    reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
    // 318: add
    reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
    // 319: add
    reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
    return false;
}
bool sub_320_325() {
    // 320: mul
    reg_tmp8 = mul_safe(reg_tmp13.zwwy, reg_tmp6.xxxy);
    // 321: add
    reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
    // 322: add
    reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
    // 323: add
    reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
    // 324: add
    reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
    return false;
}
bool sub_327_340() {
    // 327: ifc
    if (conditional_code.y) {
        sub_328_333();
    } else {
        sub_333_339();
    }
    // 339: nop
    return false;
}
bool sub_328_333() {
    // 328: mul
    reg_tmp8 = mul_safe(reg_tmp13.yywz, reg_tmp6.xxxy);
    // 329: add
    reg_tmp8.y = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).y;
    // 330: add
    reg_tmp9 = reg_tmp5.yyyy + -reg_tmp5.xxxx;
    // 331: add
    reg_tmp8.xzw = (reg_tmp8 + reg_tmp14.wwyx).xzw;
    // 332: add
    reg_tmp8.y = (reg_tmp9 + reg_tmp8).y;
    return false;
}
bool sub_333_339() {
    // 333: mul
    reg_tmp8 = mul_safe(reg_tmp13.zwwy, reg_tmp6.xxxy);
    // 334: add
    reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
    // 335: add
    reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
    // 336: add
    reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
    // 337: add
    reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
    // 338: mov
    reg_tmp8.w = (-reg_tmp8).w;
    return false;
}
bool sub_344_4096() {
    // 344: call
    {
        sub_83_251();
    }
    // 345: mov
    reg_tmp8.xy = (uniforms.f[93].xxxx).xy;
    // 346: mov
    reg_tmp0.y = (uniforms.f[7].wwww).y;
    // 347: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.xyyy));
    // 348: mov
    reg_tmp9.xyz = (uniforms.f[93].xxxx).xyz;
    // 349: mov
    reg_tmp9.w = (uniforms.f[21].wwww).w;
    // 350: ifc
    if (conditional_code.y) {
        sub_351_356();
    }
    // 356: cmp
    conditional_code = equal(vec2(uniforms.f[93].xxxx), vec2(reg_tmp8.xyyy));
    // 357: ifc
    if (all(conditional_code)) {
        sub_358_359();
    }
    // 359: max
    vs_out_attr3 = max(uniforms.f[93].xxxx, reg_tmp9);
    // 360: mov
    reg_tmp0.xy = (uniforms.f[10].xxxx).xy;
    // 361: ifu
    if (uniforms.b[9]) {
        sub_362_374();
    } else {
        sub_374_384();
    }
    // 384: nop
    // 385: mov
    reg_tmp0.xy = (uniforms.f[10].yyyy).xy;
    // 386: cmp
    conditional_code = equal(vec2(uniforms.f[93].yzzz), vec2(reg_tmp0.xyyy));
    // 387: ifc
    if (all(not(conditional_code))) {
        sub_388_389();
    } else {
        sub_389_393();
    }
    // 393: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 394: dp4
    reg_tmp4.x = dot(uniforms.f[14].xywz, reg_tmp6);
    // 395: dp4
    reg_tmp4.y = dot(uniforms.f[15].xywz, reg_tmp6);
    // 396: mov
    vs_out_attr5 = reg_tmp4;
    // 397: nop
    // 398: mov
    reg_tmp0.xy = (uniforms.f[10].zzzz).xy;
    // 399: cmp
    conditional_code = equal(vec2(uniforms.f[93].yzzz), vec2(reg_tmp0.xyyy));
    // 400: ifc
    if (all(not(conditional_code))) {
        sub_401_402();
    } else {
        sub_402_406();
    }
    // 406: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 407: dp4
    reg_tmp5.x = dot(uniforms.f[17].xywz, reg_tmp6);
    // 408: dp4
    reg_tmp5.y = dot(uniforms.f[18].xywz, reg_tmp6);
    // 409: mov
    vs_out_attr6 = reg_tmp5;
    // 410: nop
    // 411: end
    return true;
}
bool sub_351_356() {
    // 351: mul
    reg_tmp0 = mul_safe(uniforms.f[7].wwww, vs_in_reg3);
    // 352: ifu
    if (uniforms.b[7]) {
        sub_353_354();
    }
    // 354: mul
    reg_tmp9.xyz = (mul_safe(uniforms.f[20].wwww, reg_tmp0.xyzz)).xyz;
    // 355: mov
    reg_tmp8.x = (uniforms.f[93].yyyy).x;
    return false;
}
bool sub_353_354() {
    // 353: mul
    reg_tmp9.w = (mul_safe(reg_tmp9.wwww, reg_tmp0.wwww)).w;
    return false;
}
bool sub_358_359() {
    // 358: mov
    reg_tmp9 = uniforms.f[21];
    return false;
}
bool sub_362_374() {
    // 362: cmp
    conditional_code = equal(vec2(uniforms.f[93].yzzz), vec2(reg_tmp0.xyyy));
    // 363: ifc
    if (all(not(conditional_code))) {
        sub_364_365();
    } else {
        sub_365_369();
    }
    // 369: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 370: dp4
    reg_tmp3.x = dot(uniforms.f[11].xywz, reg_tmp6);
    // 371: dp4
    reg_tmp3.y = dot(uniforms.f[12].xywz, reg_tmp6);
    // 372: mov
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    // 373: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_364_365() {
    // 364: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
    return false;
}
bool sub_365_369() {
    // 365: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_366_367();
    } else {
        sub_367_368();
    }
    // 368: nop
    return false;
}
bool sub_366_367() {
    // 366: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
    return false;
}
bool sub_367_368() {
    // 367: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
    return false;
}
bool sub_374_384() {
    // 374: cmp
    conditional_code = equal(vec2(uniforms.f[95].xyyy), vec2(reg_tmp0.xyyy));
    // 375: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 376: mov
    reg_tmp6 = reg_tmp10;
    // 377: dp4
    reg_tmp3.x = dot(uniforms.f[11], reg_tmp6);
    // 378: dp4
    reg_tmp3.y = dot(uniforms.f[12], reg_tmp6);
    // 379: dp4
    reg_tmp3.z = dot(uniforms.f[13], reg_tmp6);
    // 380: mul
    reg_tmp0.xy = (mul_safe(uniforms.f[19].xyyy, reg_tmp3.zzzz)).xy;
    // 381: add
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    // 382: nop
    // 383: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_388_389() {
    // 388: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
    return false;
}
bool sub_389_393() {
    // 389: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_390_391();
    } else {
        sub_391_392();
    }
    // 392: nop
    return false;
}
bool sub_390_391() {
    // 390: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
    return false;
}
bool sub_391_392() {
    // 391: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
    return false;
}
bool sub_401_402() {
    // 401: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
    return false;
}
bool sub_402_406() {
    // 402: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_403_404();
    } else {
        sub_404_405();
    }
    // 405: nop
    return false;
}
bool sub_403_404() {
    // 403: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
    return false;
}
bool sub_404_405() {
    // 404: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
    return false;
}
// reference: 925D110451342F83, 2C5B088B7FE4BF56
// program: 2C5B088B7FE4BF56, AD7922A63ED54CA7, E2B05A5EEE3BCE11
// reference: 925D1104BE0DBCC2, 2C5B088B7FE4BF56
// reference: 3D1983437F8B00E0, 5C7DAF9CBE61E818
// program: 2C5B088B7FE4BF56, AD7922A63ED54CA7, 23F262D2CA8E6488
// program: 5C7DAF9CBE61E818, 3B3AE026C742C7D5, 7FF280648EA22926
// program: 5C7DAF9CBE61E818, 3B3AE026C742C7D5, 8B353D67743458EE
// program: 2C5B088B7FE4BF56, AD7922A63ED54CA7, C74CA00DB8E95117
// program: 2C5B088B7FE4BF56, AD7922A63ED54CA7, 45B9B5821FF15384
// program: 5C7DAF9CBE61E818, 3B3AE026C742C7D5, 2F3A3851E4476855
// program: 5C7DAF9CBE61E818, 3B3AE026C742C7D5, 9DB6533B8FE11441
// program: 5C7DAF9CBE61E818, 3B3AE026C742C7D5, 98125BD9033DAC4C
// reference: 40801A5E1D87EE61, 35F6C85AC819B073
// reference: D9D5621FC63E4F26, 35F6C85AC819B073
// reference: A44CFB024B0B32E6, 5C7DAF9CBE61E818
// program: 5C7DAF9CBE61E818, 3B3AE026C742C7D5, 82DDCA85272BD2AC
// shader: 8B31, 2D697ABB0BA42310

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;
 out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define mul_safe(x, y) (x * y)
#define rcp_safe(x) (1.0f / x)
#define rsq_safe(x) inversesqrt(x)
#define fma_safe(x, y, z) fma(x, y, z)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_4096();
bool sub_7_12();
bool sub_12_21();
bool sub_21_34();
bool sub_34_254();
bool sub_40_176();
bool sub_47_86();
bool sub_58_62();
bool sub_86_165();
bool sub_87_129();
bool sub_98_102();
bool sub_129_164();
bool sub_140_144();
bool sub_174_175();
bool sub_176_253();
bool sub_179_189();
bool sub_189_194();
bool sub_205_217();
bool sub_217_242();
bool sub_218_236();
bool sub_236_241();
bool sub_251_252();
bool sub_254_271();
bool sub_271_347();
bool sub_310_330();
bool sub_311_316();
bool sub_316_329();
bool sub_320_323();
bool sub_323_328();
bool sub_330_343();
bool sub_331_336();
bool sub_336_342();
bool sub_347_369();
bool sub_353_358();
bool sub_355_356();
bool sub_361_362();
bool sub_369_415();
bool sub_373_414();
bool sub_378_380();
bool sub_380_404();
bool sub_383_388();
bool sub_394_403();
bool sub_398_399();
bool sub_399_402();
bool sub_406_413();

bool exec_shader() {
    sub_0_4096();
    return true;
}

bool sub_0_4096() {
    // 0: call
    {
        sub_34_254();
    }
    // 1: call
    {
        sub_347_369();
    }
    // 2: mov
    vs_out_attr4 = uniforms.f[93].xxxx;
    // 3: mov
    vs_out_attr5 = uniforms.f[93].xxxx;
    // 4: mov
    vs_out_attr6 = uniforms.f[93].xxxx;
    // 5: end
    return true;
}
bool sub_7_12() {
    // 7: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 8: dp4
    reg_tmp3.x = dot(uniforms.f[25 + address_registers.x], reg_tmp15);
    // 9: dp4
    reg_tmp3.y = dot(uniforms.f[26 + address_registers.x], reg_tmp15);
    // 10: dp4
    reg_tmp3.z = dot(uniforms.f[27 + address_registers.x], reg_tmp15);
    // 11: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    return false;
}
bool sub_12_21() {
    // 12: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 13: dp4
    reg_tmp3.x = dot(uniforms.f[25 + address_registers.x], reg_tmp15);
    // 14: dp4
    reg_tmp3.y = dot(uniforms.f[26 + address_registers.x], reg_tmp15);
    // 15: dp4
    reg_tmp3.z = dot(uniforms.f[27 + address_registers.x], reg_tmp15);
    // 16: dp3
    reg_tmp4.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp14));
    // 17: dp3
    reg_tmp4.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp14));
    // 18: dp3
    reg_tmp4.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp14));
    // 19: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 20: mad
    reg_tmp12 = fma_safe(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_21_34() {
    // 21: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 22: dp4
    reg_tmp3.x = dot(uniforms.f[25 + address_registers.x], reg_tmp15);
    // 23: dp4
    reg_tmp3.y = dot(uniforms.f[26 + address_registers.x], reg_tmp15);
    // 24: dp4
    reg_tmp3.z = dot(uniforms.f[27 + address_registers.x], reg_tmp15);
    // 25: dp3
    reg_tmp4.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp14));
    // 26: dp3
    reg_tmp4.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp14));
    // 27: dp3
    reg_tmp4.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp14));
    // 28: dp3
    reg_tmp5.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp13));
    // 29: dp3
    reg_tmp5.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp13));
    // 30: dp3
    reg_tmp5.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp13));
    // 31: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 32: mad
    reg_tmp12 = fma_safe(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    // 33: mad
    reg_tmp11 = fma_safe(reg_tmp1.wwww, reg_tmp5, reg_tmp11);
    return false;
}
bool sub_34_254() {
    // 34: mul
    reg_tmp15.xyz = (mul_safe(uniforms.f[7].xxxx, vs_in_reg0)).xyz;
    // 35: mul
    reg_tmp14.xyz = (mul_safe(uniforms.f[7].yyyy, vs_in_reg1)).xyz;
    // 36: mul
    reg_tmp13.xyz = (mul_safe(uniforms.f[7].zzzz, vs_in_reg2)).xyz;
    // 37: add
    reg_tmp15.xyz = (uniforms.f[6] + reg_tmp15).xyz;
    // 38: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 39: ifu
    if (uniforms.b[1]) {
        sub_40_176();
    } else {
        sub_176_253();
    }
    // 253: nop
    return false;
}
bool sub_40_176() {
    // 40: mov
    reg_tmp0 = uniforms.f[7];
    // 41: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.yzzz));
    // 42: mov
    reg_tmp7 = uniforms.f[93].xxxx;
    // 43: mov
    reg_tmp12 = uniforms.f[93].xxxx;
    // 44: mov
    reg_tmp11 = uniforms.f[93].xxxx;
    // 45: mul
    reg_tmp2 = mul_safe(uniforms.f[93].wwww, vs_in_reg7);
    // 46: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_47_86();
    } else {
        sub_86_165();
    }
    // 165: mov
    vs_out_attr2 = -reg_tmp15;
    // 166: dp4
    reg_tmp0.x = dot(uniforms.f[86], reg_tmp15);
    // 167: dp4
    reg_tmp0.y = dot(uniforms.f[87], reg_tmp15);
    // 168: dp4
    reg_tmp0.z = dot(uniforms.f[88], reg_tmp15);
    // 169: dp4
    reg_tmp0.w = dot(uniforms.f[89], reg_tmp15);
    // 170: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 171: mul
    reg_tmp1.y = (mul_safe(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
    // 172: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 173: ifc
    if (all(conditional_code)) {
        sub_174_175();
    }
    // 175: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_47_86() {
    // 47: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 48: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 49: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 50: call
    {
        sub_12_21();
    }
    // 51: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 52: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 53: call
    {
        sub_12_21();
    }
    // 54: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 55: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 56: callc
    if (conditional_code.x) {
        sub_12_21();
    }
    // 57: ifu
    if (uniforms.b[8]) {
        sub_58_62();
    }
    // 62: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 63: dp4
    reg_tmp10.x = dot(uniforms.f[0], reg_tmp7);
    // 64: dp4
    reg_tmp10.y = dot(uniforms.f[1], reg_tmp7);
    // 65: dp4
    reg_tmp10.z = dot(uniforms.f[2], reg_tmp7);
    // 66: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 67: add
    reg_tmp6.y = (-uniforms.f[85].wwww + reg_tmp10.yyyy).y;
    // 68: mov
    reg_tmp9.xyz = (uniforms.f[85].xyzz).xyz;
    // 69: dp4
    reg_tmp7.x = dot(reg_tmp9.xyzz, reg_tmp9.xyzz);
    // 70: rsq
    reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
    // 71: mul
    reg_tmp7.xyz = (mul_safe(reg_tmp9.xyzz, reg_tmp7.xxxx)).xyz;
    // 72: rcp
    reg_tmp8.y = rcp_safe(-reg_tmp7.yyyy.x);
    // 73: mul
    reg_tmp8.y = (mul_safe(reg_tmp6.yyyy, reg_tmp8.yyyy)).y;
    // 74: mul
    reg_tmp7.xyz = (mul_safe(reg_tmp7.xyzz, reg_tmp8.yyyy)).xyz;
    // 75: add
    reg_tmp10.xyz = (reg_tmp10.xyzz + reg_tmp7.xyzz).xyz;
    // 76: add
    reg_tmp10.y = (uniforms.f[94].zzzz + reg_tmp10.yyyy).y;
    // 77: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 78: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 79: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 80: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 81: dp3
    reg_tmp14.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp12));
    // 82: dp3
    reg_tmp14.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp12));
    // 83: dp3
    reg_tmp14.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp12));
    // 84: call
    {
        sub_254_271();
    }
    // 85: nop
    return false;
}
bool sub_58_62() {
    // 58: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 59: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 60: callc
    if (conditional_code.y) {
        sub_12_21();
    }
    // 61: nop
    return false;
}
bool sub_86_165() {
    // 86: ifc
    if (all(conditional_code)) {
        sub_87_129();
    } else {
        sub_129_164();
    }
    // 164: nop
    return false;
}
bool sub_87_129() {
    // 87: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 88: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 89: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 90: call
    {
        sub_21_34();
    }
    // 91: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 92: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 93: call
    {
        sub_21_34();
    }
    // 94: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 95: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 96: callc
    if (conditional_code.x) {
        sub_21_34();
    }
    // 97: ifu
    if (uniforms.b[8]) {
        sub_98_102();
    }
    // 102: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 103: dp4
    reg_tmp10.x = dot(uniforms.f[0], reg_tmp7);
    // 104: dp4
    reg_tmp10.y = dot(uniforms.f[1], reg_tmp7);
    // 105: dp4
    reg_tmp10.z = dot(uniforms.f[2], reg_tmp7);
    // 106: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 107: dp3
    reg_tmp13.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp11));
    // 108: dp3
    reg_tmp13.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp11));
    // 109: dp3
    reg_tmp13.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp11));
    // 110: dp3
    reg_tmp14.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp12));
    // 111: dp3
    reg_tmp14.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp12));
    // 112: dp3
    reg_tmp14.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp12));
    // 113: add
    reg_tmp6.y = (-uniforms.f[85].wwww + reg_tmp10.yyyy).y;
    // 114: mov
    reg_tmp9.xyz = (uniforms.f[85].xyzz).xyz;
    // 115: dp4
    reg_tmp7.x = dot(reg_tmp9.xyzz, reg_tmp9.xyzz);
    // 116: rsq
    reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
    // 117: mul
    reg_tmp7.xyz = (mul_safe(reg_tmp9.xyzz, reg_tmp7.xxxx)).xyz;
    // 118: rcp
    reg_tmp8.y = rcp_safe(-reg_tmp7.yyyy.x);
    // 119: mul
    reg_tmp8.y = (mul_safe(reg_tmp6.yyyy, reg_tmp8.yyyy)).y;
    // 120: mul
    reg_tmp7.xyz = (mul_safe(reg_tmp7.xyzz, reg_tmp8.yyyy)).xyz;
    // 121: add
    reg_tmp10.xyz = (reg_tmp10.xyzz + reg_tmp7.xyzz).xyz;
    // 122: add
    reg_tmp10.y = (uniforms.f[94].zzzz + reg_tmp10.yyyy).y;
    // 123: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 124: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 125: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 126: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 127: call
    {
        sub_271_347();
    }
    // 128: nop
    return false;
}
bool sub_98_102() {
    // 98: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 99: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 100: callc
    if (conditional_code.y) {
        sub_21_34();
    }
    // 101: nop
    return false;
}
bool sub_129_164() {
    // 129: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 130: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 131: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 132: call
    {
        sub_7_12();
    }
    // 133: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 134: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 135: call
    {
        sub_7_12();
    }
    // 136: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 137: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 138: callc
    if (conditional_code.x) {
        sub_7_12();
    }
    // 139: ifu
    if (uniforms.b[8]) {
        sub_140_144();
    }
    // 144: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 145: dp4
    reg_tmp10.x = dot(uniforms.f[0], reg_tmp7);
    // 146: dp4
    reg_tmp10.y = dot(uniforms.f[1], reg_tmp7);
    // 147: dp4
    reg_tmp10.z = dot(uniforms.f[2], reg_tmp7);
    // 148: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 149: add
    reg_tmp6.y = (-uniforms.f[85].wwww + reg_tmp10.yyyy).y;
    // 150: mov
    reg_tmp9.xyz = (uniforms.f[85].xyzz).xyz;
    // 151: dp4
    reg_tmp7.x = dot(reg_tmp9.xyzz, reg_tmp9.xyzz);
    // 152: rsq
    reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
    // 153: mul
    reg_tmp7.xyz = (mul_safe(reg_tmp9.xyzz, reg_tmp7.xxxx)).xyz;
    // 154: rcp
    reg_tmp8.y = rcp_safe(-reg_tmp7.yyyy.x);
    // 155: mul
    reg_tmp8.y = (mul_safe(reg_tmp6.yyyy, reg_tmp8.yyyy)).y;
    // 156: mul
    reg_tmp7.xyz = (mul_safe(reg_tmp7.xyzz, reg_tmp8.yyyy)).xyz;
    // 157: add
    reg_tmp10.xyz = (reg_tmp10.xyzz + reg_tmp7.xyzz).xyz;
    // 158: add
    reg_tmp10.y = (uniforms.f[94].zzzz + reg_tmp10.yyyy).y;
    // 159: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 160: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 161: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 162: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 163: mov
    vs_out_attr1 = uniforms.f[93].xxxx;
    return false;
}
bool sub_140_144() {
    // 140: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 141: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 142: callc
    if (conditional_code.y) {
        sub_7_12();
    }
    // 143: nop
    return false;
}
bool sub_174_175() {
    // 174: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_176_253() {
    // 176: mov
    reg_tmp0 = uniforms.f[7];
    // 177: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.yzzz));
    // 178: ifu
    if (uniforms.b[2]) {
        sub_179_189();
    } else {
        sub_189_194();
    }
    // 194: add
    reg_tmp6.y = (-uniforms.f[85].wwww + reg_tmp10.yyyy).y;
    // 195: mov
    reg_tmp9.xyz = (uniforms.f[85].xyzz).xyz;
    // 196: dp4
    reg_tmp7.x = dot(reg_tmp9.xyzz, reg_tmp9.xyzz);
    // 197: rsq
    reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
    // 198: mul
    reg_tmp7.xyz = (mul_safe(reg_tmp9.xyzz, reg_tmp7.xxxx)).xyz;
    // 199: rcp
    reg_tmp8.y = rcp_safe(-reg_tmp7.yyyy.x);
    // 200: mul
    reg_tmp8.y = (mul_safe(reg_tmp6.yyyy, reg_tmp8.yyyy)).y;
    // 201: mul
    reg_tmp7.xyz = (mul_safe(reg_tmp7.xyzz, reg_tmp8.yyyy)).xyz;
    // 202: add
    reg_tmp10.xyz = (reg_tmp10.xyzz + reg_tmp7.xyzz).xyz;
    // 203: add
    reg_tmp10.y = (uniforms.f[94].zzzz + reg_tmp10.yyyy).y;
    // 204: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_205_217();
    } else {
        sub_217_242();
    }
    // 242: mov
    vs_out_attr2 = -reg_tmp15;
    // 243: dp4
    reg_tmp0.x = dot(uniforms.f[86], reg_tmp15);
    // 244: dp4
    reg_tmp0.y = dot(uniforms.f[87], reg_tmp15);
    // 245: dp4
    reg_tmp0.z = dot(uniforms.f[88], reg_tmp15);
    // 246: dp4
    reg_tmp0.w = dot(uniforms.f[89], reg_tmp15);
    // 247: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 248: mul
    reg_tmp1.y = (mul_safe(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
    // 249: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 250: ifc
    if (all(conditional_code)) {
        sub_251_252();
    }
    // 252: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_179_189() {
    // 179: mul
    reg_tmp1.x = (mul_safe(uniforms.f[93].wwww, vs_in_reg7.xxxx)).x;
    // 180: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 181: dp4
    reg_tmp7.x = dot(uniforms.f[25 + address_registers.x], reg_tmp15);
    // 182: dp4
    reg_tmp7.y = dot(uniforms.f[26 + address_registers.x], reg_tmp15);
    // 183: dp4
    reg_tmp7.z = dot(uniforms.f[27 + address_registers.x], reg_tmp15);
    // 184: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 185: dp4
    reg_tmp10.x = dot(uniforms.f[0], reg_tmp7);
    // 186: dp4
    reg_tmp10.y = dot(uniforms.f[1], reg_tmp7);
    // 187: dp4
    reg_tmp10.z = dot(uniforms.f[2], reg_tmp7);
    // 188: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_189_194() {
    // 189: mova
    address_registers.x = (ivec2(uniforms.f[93].xxxx)).x;
    // 190: dp4
    reg_tmp10.x = dot(uniforms.f[25], reg_tmp15);
    // 191: dp4
    reg_tmp10.y = dot(uniforms.f[26], reg_tmp15);
    // 192: dp4
    reg_tmp10.z = dot(uniforms.f[27], reg_tmp15);
    // 193: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_205_217() {
    // 205: dp3
    reg_tmp12.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp14));
    // 206: dp3
    reg_tmp12.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp14));
    // 207: dp3
    reg_tmp12.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp14));
    // 208: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 209: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 210: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 211: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 212: dp3
    reg_tmp14.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp12));
    // 213: dp3
    reg_tmp14.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp12));
    // 214: dp3
    reg_tmp14.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp12));
    // 215: call
    {
        sub_254_271();
    }
    // 216: nop
    return false;
}
bool sub_217_242() {
    // 217: ifc
    if (all(conditional_code)) {
        sub_218_236();
    } else {
        sub_236_241();
    }
    // 241: nop
    return false;
}
bool sub_218_236() {
    // 218: dp3
    reg_tmp12.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp14));
    // 219: dp3
    reg_tmp12.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp14));
    // 220: dp3
    reg_tmp12.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp14));
    // 221: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp13));
    // 222: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp13));
    // 223: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp13));
    // 224: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 225: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 226: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 227: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 228: dp3
    reg_tmp14.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp12));
    // 229: dp3
    reg_tmp14.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp12));
    // 230: dp3
    reg_tmp14.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp12));
    // 231: dp3
    reg_tmp13.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp11));
    // 232: dp3
    reg_tmp13.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp11));
    // 233: dp3
    reg_tmp13.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp11));
    // 234: call
    {
        sub_271_347();
    }
    // 235: nop
    return false;
}
bool sub_236_241() {
    // 236: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 237: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 238: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 239: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 240: mov
    vs_out_attr1 = uniforms.f[93].xxxx;
    return false;
}
bool sub_251_252() {
    // 251: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_254_271() {
    uint jmp_to = 254u;
    while (true) {
        switch (jmp_to) {
        case 254u: {
            // 254: dp3
            reg_tmp6.x = dot(vec3(reg_tmp14), vec3(reg_tmp14));
            // 255: dp3
            reg_tmp7.x = dot(vec3(reg_tmp12), vec3(reg_tmp12));
            // 256: rsq
            reg_tmp6.x = rsq_safe(reg_tmp6.xxxx.x);
            // 257: rsq
            reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
            // 258: mul
            reg_tmp14.xyz = (mul_safe(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 259: mul
            reg_tmp12.xyz = (mul_safe(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 260: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 261: jmpu
            if (!uniforms.b[15]) {
                { jmp_to = 270u; break; }
            }
            // 262: add
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            // 263: mul
            reg_tmp4 = mul_safe(uniforms.f[94].zzzz, reg_tmp4);
            // 264: cmp
            conditional_code = greaterThanEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp4.xxxx));
            // 265: rsq
            reg_tmp4 = vec4(rsq_safe(reg_tmp4.xxxx.x));
            // 266: mul
            reg_tmp5 = mul_safe(uniforms.f[94].zzzz, reg_tmp14);
            // 267: jmpc
            if (conditional_code.x) {
                { jmp_to = 270u; break; }
            }
            // 268: rcp
            reg_tmp0.z = rcp_safe(reg_tmp4.xxxx.x);
            // 269: mul
            reg_tmp0.xy = (mul_safe(reg_tmp5, reg_tmp4)).xy;
        }
        case 270u: {
            // 270: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_271_347() {
    uint jmp_to = 271u;
    while (true) {
        switch (jmp_to) {
        case 271u: {
            // 271: dp3
            reg_tmp6.x = dot(vec3(reg_tmp14), vec3(reg_tmp14));
            // 272: dp3
            reg_tmp7.x = dot(vec3(reg_tmp12), vec3(reg_tmp12));
            // 273: rsq
            reg_tmp6.x = rsq_safe(reg_tmp6.xxxx.x);
            // 274: rsq
            reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
            // 275: mul
            reg_tmp14.xyz = (mul_safe(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 276: mul
            reg_tmp12.xyz = (mul_safe(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 277: mul
            reg_tmp13.xyz = (mul_safe(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            // 278: mul
            reg_tmp11.xyz = (mul_safe(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            // 279: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 280: jmpu
            if (!uniforms.b[15]) {
                { jmp_to = 346u; break; }
            }
            // 281: mul
            reg_tmp13.xyz = (mul_safe(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            // 282: mul
            reg_tmp11.xyz = (mul_safe(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            // 283: mul
            reg_tmp5 = mul_safe(reg_tmp14.yzxx, reg_tmp13.zxyy);
            // 284: mad
            reg_tmp5 = fma_safe(-reg_tmp13.yzxx, reg_tmp14.zxyy, reg_tmp5);
            // 285: dp3
            reg_tmp5.w = dot(vec3(reg_tmp5), vec3(reg_tmp5));
            // 286: rsq
            reg_tmp5.w = rsq_safe(reg_tmp5.wwww.x);
            // 287: mul
            reg_tmp5 = mul_safe(reg_tmp5, reg_tmp5.wwww);
            // 288: add
            reg_tmp6.w = (reg_tmp14.zzzz + reg_tmp5.yyyy).w;
            // 289: mul
            reg_tmp13 = mul_safe(reg_tmp5.yzxx, reg_tmp14.zxyy);
            // 290: mad
            reg_tmp13 = fma_safe(-reg_tmp14.yzxx, reg_tmp5.zxyy, reg_tmp13);
            // 291: add
            reg_tmp6.w = (reg_tmp13.xxxx + reg_tmp6).w;
            // 292: mov
            reg_tmp13.w = (reg_tmp5.zzzz).w;
            // 293: mov
            reg_tmp5.z = (reg_tmp13.xxxx).z;
            // 294: add
            reg_tmp6.w = (uniforms.f[93].yyyy + reg_tmp6).w;
            // 295: mov
            reg_tmp14.w = (reg_tmp5.xxxx).w;
            // 296: mov
            reg_tmp5.x = (reg_tmp14.zzzz).x;
            // 297: cmp
            conditional_code = lessThan(vec2(uniforms.f[94].yyyy), vec2(reg_tmp6.wwww));
            // 298: mov
            reg_tmp6.x = (uniforms.f[93].yyyy).x;
            // 299: mov
            reg_tmp6.y = (-uniforms.f[93].yyyy).y;
            // 300: jmpc
            if (!conditional_code.x) {
                { jmp_to = 308u; break; }
            }
            // 301: add
            reg_tmp7.xz = (reg_tmp13.wwyy + -reg_tmp14.yyww).xz;
            // 302: add
            reg_tmp7.y = (reg_tmp14.xxxx + -reg_tmp13.zzzz).y;
            // 303: mov
            reg_tmp7.w = (reg_tmp6).w;
            // 304: dp4
            reg_tmp6 = vec4(dot(reg_tmp7, reg_tmp7));
            // 305: rsq
            reg_tmp6 = vec4(rsq_safe(reg_tmp6.xxxx.x));
            // 306: mul
            reg_tmp0 = mul_safe(reg_tmp7, reg_tmp6);
            // 307: jmpu
            if (uniforms.b[0]) {
                { jmp_to = 346u; break; }
            }
        }
        case 308u: {
            // 308: cmp
            conditional_code = greaterThan(vec2(reg_tmp5.zyyy), vec2(reg_tmp5.yxxx));
            // 309: ifc
            if (conditional_code.x) {
                sub_310_330();
            } else {
                sub_330_343();
            }
            // 343: dp4
            reg_tmp6 = vec4(dot(reg_tmp8, reg_tmp8));
            // 344: rsq
            reg_tmp6 = vec4(rsq_safe(reg_tmp6.xxxx.x));
            // 345: mul
            reg_tmp0 = mul_safe(reg_tmp8, reg_tmp6);
        }
        case 346u: {
            // 346: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_310_330() {
    // 310: ifc
    if (conditional_code.y) {
        sub_311_316();
    } else {
        sub_316_329();
    }
    // 329: mov
    reg_tmp8.w = (-reg_tmp8).w;
    return false;
}
bool sub_311_316() {
    // 311: mul
    reg_tmp8 = mul_safe(reg_tmp13.yyzw, reg_tmp6.xxxy);
    // 312: add
    reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
    // 313: add
    reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
    // 314: add
    reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
    // 315: add
    reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
    return false;
}
bool sub_316_329() {
    // 316: cmp
    conditional_code = greaterThan(vec2(reg_tmp5.zzzz), vec2(reg_tmp5.xxxx));
    // 317: mul
    reg_tmp8 = mul_safe(reg_tmp13.yyzw, reg_tmp6.xxxy);
    // 318: add
    reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
    // 319: ifc
    if (conditional_code.x) {
        sub_320_323();
    } else {
        sub_323_328();
    }
    // 328: nop
    return false;
}
bool sub_320_323() {
    // 320: add
    reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
    // 321: add
    reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
    // 322: add
    reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
    return false;
}
bool sub_323_328() {
    // 323: mul
    reg_tmp8 = mul_safe(reg_tmp13.zwwy, reg_tmp6.xxxy);
    // 324: add
    reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
    // 325: add
    reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
    // 326: add
    reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
    // 327: add
    reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
    return false;
}
bool sub_330_343() {
    // 330: ifc
    if (conditional_code.y) {
        sub_331_336();
    } else {
        sub_336_342();
    }
    // 342: nop
    return false;
}
bool sub_331_336() {
    // 331: mul
    reg_tmp8 = mul_safe(reg_tmp13.yywz, reg_tmp6.xxxy);
    // 332: add
    reg_tmp8.y = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).y;
    // 333: add
    reg_tmp9 = reg_tmp5.yyyy + -reg_tmp5.xxxx;
    // 334: add
    reg_tmp8.xzw = (reg_tmp8 + reg_tmp14.wwyx).xzw;
    // 335: add
    reg_tmp8.y = (reg_tmp9 + reg_tmp8).y;
    return false;
}
bool sub_336_342() {
    // 336: mul
    reg_tmp8 = mul_safe(reg_tmp13.zwwy, reg_tmp6.xxxy);
    // 337: add
    reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
    // 338: add
    reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
    // 339: add
    reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
    // 340: add
    reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
    // 341: mov
    reg_tmp8.w = (-reg_tmp8).w;
    return false;
}
bool sub_347_369() {
    // 347: mov
    reg_tmp8.xy = (uniforms.f[93].xxxx).xy;
    // 348: mov
    reg_tmp0.y = (uniforms.f[7].wwww).y;
    // 349: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.xyyy));
    // 350: mov
    reg_tmp9.xyz = (uniforms.f[93].xxxx).xyz;
    // 351: mov
    reg_tmp9.w = (uniforms.f[21].wwww).w;
    // 352: ifc
    if (conditional_code.y) {
        sub_353_358();
    }
    // 358: callu
    if (uniforms.b[12]) {
        sub_369_415();
    }
    // 359: cmp
    conditional_code = equal(vec2(uniforms.f[93].xxxx), vec2(reg_tmp8.xyyy));
    // 360: ifc
    if (all(conditional_code)) {
        sub_361_362();
    }
    // 362: add
    reg_tmp0.xyz = (uniforms.f[24].xyzz + -reg_tmp10.xyzz).xyz;
    // 363: rcp
    reg_tmp0.w = rcp_safe(uniforms.f[24].wwww.x);
    // 364: dp3
    reg_tmp1.w = dot(vec3(reg_tmp0.xyzz), vec3(reg_tmp0.xyzz));
    // 365: mul
    reg_tmp1.w = (mul_safe(reg_tmp0.wwww, reg_tmp1.wwww)).w;
    // 366: min
    reg_tmp1.w = (min(uniforms.f[93].yyyy, reg_tmp1.wwww)).w;
    // 367: add
    reg_tmp9.w = (uniforms.f[93].yyyy + -reg_tmp1.wwww).w;
    // 368: max
    vs_out_attr3 = max(uniforms.f[93].xxxx, reg_tmp9);
    return false;
}
bool sub_353_358() {
    // 353: mul
    reg_tmp0 = mul_safe(uniforms.f[7].wwww, vs_in_reg3);
    // 354: ifu
    if (uniforms.b[7]) {
        sub_355_356();
    }
    // 356: mul
    reg_tmp9.xyz = (mul_safe(uniforms.f[20].wwww, reg_tmp0.xyzz)).xyz;
    // 357: mov
    reg_tmp8.x = (uniforms.f[93].yyyy).x;
    return false;
}
bool sub_355_356() {
    // 355: mul
    reg_tmp9.w = (mul_safe(reg_tmp9.wwww, reg_tmp0.wwww)).w;
    return false;
}
bool sub_361_362() {
    // 361: mov
    reg_tmp9 = uniforms.f[21];
    return false;
}
bool sub_369_415() {
    // 369: mov
    reg_tmp1 = uniforms.f[20];
    // 370: mov
    reg_tmp2 = uniforms.f[21];
    // 371: mov
    reg_tmp3 = uniforms.f[93].xxxx;
    // 372: loop
    address_registers.z = int(uniforms.i[0].y);
    for (uint loop372 = 0u; loop372 <= uniforms.i[0].x; address_registers.z += int(uniforms.i[0].z), ++loop372) {
        sub_373_414();
    }
    // 414: mov
    reg_tmp8.x = (uniforms.f[93].yyyy).x;
    return false;
}
bool sub_373_414() {
    // 373: mova
    address_registers.x = (ivec2(reg_tmp3)).x;
    // 374: mov
    reg_tmp4.x = (uniforms.f[81 + address_registers.x].wwww).x;
    // 375: mov
    reg_tmp4.y = (uniforms.f[83 + address_registers.x].wwww).y;
    // 376: cmp
    conditional_code = equal(vec2(uniforms.f[93].xyyy), vec2(reg_tmp4.xyyy));
    // 377: ifc
    if (conditional_code.x) {
        sub_378_380();
    } else {
        sub_380_404();
    }
    // 404: cmp
    conditional_code.x = uniforms.f[93].xxxx.x == reg_tmp6.xyyy.x;
    conditional_code.y = uniforms.f[93].xxxx.y < reg_tmp6.xyyy.y;
    // 405: ifc
    if (conditional_code.y) {
        sub_406_413();
    }
    // 413: add
    reg_tmp3 = -uniforms.f[95].wwww + reg_tmp3;
    return false;
}
bool sub_378_380() {
    // 378: dp3
    reg_tmp6.x = dot(vec3(uniforms.f[81 + address_registers.x]), vec3(reg_tmp14));
    // 379: mov
    reg_tmp6.y = (uniforms.f[93].yyyy).y;
    return false;
}
bool sub_380_404() {
    // 380: add
    reg_tmp4 = uniforms.f[81 + address_registers.x] + -reg_tmp15;
    // 381: mov
    reg_tmp6.y = (uniforms.f[93].yyyy).y;
    // 382: ifc
    if (conditional_code.y) {
        sub_383_388();
    }
    // 388: mov
    reg_tmp5 = uniforms.f[82 + address_registers.x];
    // 389: cmp
    conditional_code = equal(vec2(uniforms.f[93].yyyy), vec2(reg_tmp5.wwww));
    // 390: dp3
    reg_tmp4.w = dot(vec3(reg_tmp4), vec3(reg_tmp4));
    // 391: rsq
    reg_tmp4.w = rsq_safe(reg_tmp4.wwww.x);
    // 392: mul
    reg_tmp4 = mul_safe(reg_tmp4, reg_tmp4.wwww);
    // 393: ifc
    if (conditional_code.x) {
        sub_394_403();
    }
    // 403: dp3
    reg_tmp6.x = dot(vec3(reg_tmp14), vec3(reg_tmp4));
    return false;
}
bool sub_383_388() {
    // 383: mov
    reg_tmp5.x = (uniforms.f[93].yyyy).x;
    // 384: dp3
    reg_tmp5.z = dot(vec3(reg_tmp4), vec3(reg_tmp4));
    // 385: mul
    reg_tmp5.y = (mul_safe(reg_tmp5.zzzz, reg_tmp5.zzzz)).y;
    // 386: dp3
    reg_tmp6.y = dot(vec3(uniforms.f[83 + address_registers.x]), vec3(reg_tmp5));
    // 387: rcp
    reg_tmp6.y = rcp_safe(reg_tmp6.yyyy.x);
    return false;
}
bool sub_394_403() {
    // 394: dp3
    reg_tmp5.x = dot(vec3(uniforms.f[82 + address_registers.x]), vec3(-reg_tmp4));
    // 395: slti
    reg_tmp5.y = (vec4(lessThan(reg_tmp5.xxxx,uniforms.f[84 + address_registers.x].yyyy))).y;
    // 396: cmp
    conditional_code = equal(vec2(uniforms.f[93].yyyy), vec2(reg_tmp5.xyyy));
    // 397: ifc
    if (conditional_code.y) {
        sub_398_399();
    } else {
        sub_399_402();
    }
    // 402: mul
    reg_tmp6.y = (mul_safe(reg_tmp6.yyyy, reg_tmp5.xxxx)).y;
    return false;
}
bool sub_398_399() {
    // 398: mov
    reg_tmp5.x = (uniforms.f[93].xxxx).x;
    return false;
}
bool sub_399_402() {
    // 399: log
    reg_tmp5.y = log2(reg_tmp5.xxxx.x);
    // 400: mul
    reg_tmp5.y = (mul_safe(uniforms.f[84 + address_registers.x].xxxx, reg_tmp5.yyyy)).y;
    // 401: exp
    reg_tmp5.x = exp2(reg_tmp5.yyyy.x);
    return false;
}
bool sub_406_413() {
    // 406: max
    reg_tmp6.x = (max(uniforms.f[93].xxxx, reg_tmp6.xxxx)).x;
    // 407: mad
    reg_tmp9.xyz = (fma_safe(reg_tmp1.xyzz, uniforms.f[79 + address_registers.x].xyzz, reg_tmp9.xyzz)).xyz;
    // 408: mul
    reg_tmp4 = mul_safe(uniforms.f[80 + address_registers.x], reg_tmp2);
    // 409: mul
    reg_tmp5.xyz = (mul_safe(reg_tmp6.xxxx, reg_tmp4.xyzz)).xyz;
    // 410: mul
    reg_tmp5.xyz = (mul_safe(reg_tmp6.yyyy, reg_tmp5.xyzz)).xyz;
    // 411: add
    reg_tmp9.xyz = (reg_tmp9.xyzz + reg_tmp5.xyzz).xyz;
    // 412: add
    reg_tmp9.w = (reg_tmp9.wwww + reg_tmp4.wwww).w;
    return false;
}
// reference: 8866A198928B25BF, 2D697ABB0BA42310
// program: 2D697ABB0BA42310, AD7922A63ED54CA7, AAD077FFD85152AB
// reference: 3604ADEAB382ACC0, 5C7DAF9CBE61E818
// reference: D6511F0C09224E6D, AE0AE260B2F14D0F
// program: AE0AE260B2F14D0F, 5D764F9A6220D694, 68475D8B9F916549
// reference: 4F04674DD29BEF2A, AE0AE260B2F14D0F
// reference: AF51D5AB683B0D87, 5C7DAF9CBE61E818
// reference: 7A34FA3ECEF0CB35, 87F539836ED26483
// reference: 2E14D0B490B293A1, 5C7DAF9CBE61E818
// reference: 815042F351342F83, 2C5B088B7FE4BF56
// reference: 815042F3BE0DBCC2, 2C5B088B7FE4BF56
// reference: 2E14D0B47F8B00E0, 5C7DAF9CBE61E818
// reference: 538D49A91D87EE61, 35F6C85AC819B073
// reference: CAD831E8C63E4F26, 35F6C85AC819B073
// reference: B741A8F54B0B32E6, 5C7DAF9CBE61E818
// reference: AF51D5ABFD4BD912, 4EFF2C77DB8F9E73
// reference: 3604ADEA26F27855, 4EFF2C77DB8F9E73
// reference: 7A34FA3E5B801FA0, E661110CC0BF42D1
// reference: 2E14D0B405C24734, 4EFF2C77DB8F9E73
// reference: 815042F3C444FB16, 17716008BB716A8F
// reference: 815042F32B7D6857, 17716008BB716A8F
// reference: 2E14D0B4EAFBD475, 4EFF2C77DB8F9E73
// reference: 538D49A988F73AF4, 76204850D3D31438
// reference: CAD831E8534E9BB3, 76204850D3D31438
// reference: B741A8F5DE7BE673, 4EFF2C77DB8F9E73
// reference: 8866A19807FBF12A, 52FC86954A48E51C
// reference: D6511F0C9C529AF8, BF583C1F84D94483
// reference: 4F04674D47EB3BBF, BF583C1F84D94483
// program: 0000000000000000, 0000000000000000, 019543348F7A91B5
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, 82B30867377518C0
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, FEB1E39313EC6A3F
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, AB9CD65F41BDEFA0
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, B29EF1BFC4D10886
// program: B582B9861A22E219, 3B3AE026C742C7D5, 85967F14F07719A7
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, 98677AC22B9A3E1A
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, 92F4F0B0E6943599
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, 8B353D67743458EE
// program: B582B9861A22E219, 3B3AE026C742C7D5, 18CD6F34EF819318
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, 06A8A4F9432C9B26
// program: 3DBC6131A77F0199, AD7922A63ED54CA7, E2B05A5EEE3BCE11
// program: 3DBC6131A77F0199, AD7922A63ED54CA7, 23F262D2CA8E6488
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, 7FF280648EA22926
// program: 3DBC6131A77F0199, AD7922A63ED54CA7, C74CA00DB8E95117
// program: 3DBC6131A77F0199, AD7922A63ED54CA7, 45B9B5821FF15384
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, 2F3A3851E4476855
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, 9DB6533B8FE11441
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, 98125BD9033DAC4C
// program: 7F132D830BF35BC2, AD7922A63ED54CA7, D375021927AD9455
// program: 7F132D830BF35BC2, AD7922A63ED54CA7, FB2B5B4178346715
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, 82DDCA85272BD2AC
// program: 1E6C0649B5CE7F1C, AD7922A63ED54CA7, AAD077FFD85152AB
// program: 0000000000000000, 0000000000000000, AEA8529257EA252C
// program: EC7233A0BD4CF3D2, 5D764F9A6220D694, 68475D8B9F916549
// program: 0000000000000000, 0000000000000000, A8ADD30A63E76265
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, 528296AD4921766A
// program: EC7233A0BD4CF3D2, 5D764F9A6220D694, FA9C11D88771DF9F
// program: EC7233A0BD4CF3D2, 5D764F9A6220D694, 09AA976E69641246
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, 16C4B2DE63D43BF1
// program: 7F132D830BF35BC2, AD7922A63ED54CA7, 10ADC50FC532FE6E
// program: 0000000000000000, 0000000000000000, 3C242A97096557B2
// program: CD1237CA557B3805, 3B3AE026C742C7D5, 2BB9C8FEDE51C537
// program: CD1237CA557B3805, 3B3AE026C742C7D5, CCCAFDE548B6C210
// program: CD1237CA557B3805, 3B3AE026C742C7D5, 73E202FB36B8AAFC
// program: EC7233A0BD4CF3D2, 5D764F9A6220D694, 42CD599C5A3A4B1B
// program: EC7233A0BD4CF3D2, 5D764F9A6220D694, A279FC7E01349071
// program: 0000000000000000, 0000000000000000, 1C4E7E439FA571F8
// program: 8DC7CF5FC18DE470, AD7922A63ED54CA7, 30DAB74CA24CBC58
// program: 8DC7CF5FC18DE470, AD7922A63ED54CA7, 21647988483E7BCD
// program: 46DC307C8C5A54D6, AD7922A63ED54CA7, 3E5CAFDBABD516C0
// program: 46DC307C8C5A54D6, AD7922A63ED54CA7, E14D0525B6AB8EC9
// program: 46DC307C8C5A54D6, AD7922A63ED54CA7, CCB52BD33F912CFA
// program: 46DC307C8C5A54D6, AD7922A63ED54CA7, 57B333648195A2F8
// program: 7F132D830BF35BC2, AD7922A63ED54CA7, 8A76329CB25030B1
// program: EC7233A0BD4CF3D2, 5D764F9A6220D694, 0B496AE87480A30D
// program: EC7233A0BD4CF3D2, 5D764F9A6220D694, ED7F62B87BCBA8C3
// program: EC7233A0BD4CF3D2, 5D764F9A6220D694, 111FE465C686BF45
// program: EC7233A0BD4CF3D2, 5D764F9A6220D694, 1E54EFAB20B0B715
// program: 0000000000000000, 0000000000000000, C32574EA415A8ECF
// program: 0000000000000000, 0000000000000000, 9984ECD2B5F69CEC
// program: 0000000000000000, 0000000000000000, 706EAA05B819222D
// program: 46DC307C8C5A54D6, AD7922A63ED54CA7, 3EE0A9C0C99022B5
// program: 46DC307C8C5A54D6, AD7922A63ED54CA7, EC9FE318D844A6A2
// program: 46DC307C8C5A54D6, AD7922A63ED54CA7, 08EDF1F3379D61F4
// program: 0000000000000000, 0000000000000000, 16123FB0C9519B51
// program: E3ED63C44CC0E9D6, AD7922A63ED54CA7, 159CC93A09C7B2EA
// reference: E361827FE4D9C519, B582B9861A22E219
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, C47F1A405F8DB749
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, 5AB91AFAAFD32BB6
// reference: 1DD895624EA6074B, 92F4F0B0E6943599
// reference: 99403FAD8394BF89, 3DBC6131A77F0199
// reference: 3604ADEAAD2B90EA, BAF5CB3693892DB3
// reference: 87C274DAED470C92, 4AD2C97240195A76
// program: EC7233A0BD4CF3D2, 5D764F9A6220D694, 9B71DB3DC792D45B
// reference: 7A34FA3ED059F71F, B582B9861A22E219
// reference: CD0A4E81220D82DC, 7BB64A39FB1F4E77
// program: 7BB64A39FB1F4E77, AD7922A63ED54CA7, 8C2ECA480D7B7AB5
// reference: 81FF80673F60645E, B582B9861A22E219
// reference: D5DFAAED61223CCA, BAF5CB3693892DB3
// reference: 7A9B38AAA0A480E8, 3DBC6131A77F0199
// reference: 7A9B38AA4F9D13A9, 3DBC6131A77F0199
// reference: D5DFAAED8E1BAF8B, BAF5CB3693892DB3
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, 6508155727F8E389
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, 48869468E89D649B
// program: 3DBC6131A77F0199, AD7922A63ED54CA7, 39C07F205AF70F59
// program: 3DBC6131A77F0199, AD7922A63ED54CA7, 2F84956AB5DBE86B
// reference: A84633F0EC17410A, 7F132D830BF35BC2
// reference: 31134BB137AEE04D, 7F132D830BF35BC2
// reference: 4C8AD2ACBA9B9D8D, BAF5CB3693892DB3
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, A4FE917C39832451
// shader: 8B30, DBD533122F75CBAA

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 01F0BA744F8650CB, DBD533122F75CBAA
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, DBD533122F75CBAA
// reference: 99403FAD6CAD2CC8, 3DBC6131A77F0199
// reference: 81FF8067D059F71F, B582B9861A22E219
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, E2B05A5EEE3BCE11
// reference: D7711E06D48D6D2B, 4AD2C97240195A76
// shader: 8B30, 52CA8D6220F7096A

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += ((light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[2].position + view);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * LookupLightingLUTUnsigned(18,clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[2].specular_0) + (light_src[2].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(18,clamp(light_src[2].dist_atten_scale * length(-view - light_src[2].position) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[3].position + view);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * LookupLightingLUTUnsigned(19,clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[3].specular_0) + (light_src[3].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(19,clamp(light_src[3].dist_atten_scale * length(-view - light_src[3].position) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor1.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((secondary_fragment_color.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_1 = byteround(clamp((texcolor2.rgb) * (last_tex_env_out.aaa), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((combiner_buffer.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_4 = byteround(clamp((vec3(1.0) - textureProj(tex0, vec3(texcoord0, texcoord0_w)).rgb) * (const_color[4].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((combiner_buffer.rgb) * (vec3(1.0) - last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 5512E865F615DC73, 52CA8D6220F7096A
// program: 3DBC6131A77F0199, AD7922A63ED54CA7, 52CA8D6220F7096A
// reference: 2251827584A505BF, 52CA8D6220F7096A
// reference: 711533078872393A, 7F132D830BF35BC2
// program: EC7233A0BD4CF3D2, 5D764F9A6220D694, E712D1F015FA0270
// program: 5746FEF0B06D455B, AD7922A63ED54CA7, 84E276AEB008DB5C
// shader: 8B30, 315EA8EB5C41C833

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_2 = byteround(clamp((texcolor1.rgb) + (secondary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (const_color[2].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (last_tex_env_out.aaa) + (combiner_buffer.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 53DF4DD0BEE7549A, 315EA8EB5C41C833
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, 315EA8EB5C41C833
// shader: 8B30, EBBB74BA3C410F00

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_2 = byteround(clamp((texcolor1.rgb) + (secondary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (const_color[2].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (last_tex_env_out.aaa) + (combiner_buffer.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 53DF4DD05250BF99, EBBB74BA3C410F00
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, EBBB74BA3C410F00
// shader: 8B31, 6433CFAAB43ABCE5

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;
 out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define mul_safe(x, y) mix(x * y, vec4(0.0), isnan(x * y))

float rcp_safe(float x) {
    if (x == 0.0f) return x;
    return 1.0f / x;
}


float rsq_safe(float x) {
    if (x == 0.0f) return x;
    return inversesqrt(x);
}

#define fma_safe(x, y, z) (mul_safe(x, y) + z)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_4096();
bool sub_33_83();
bool sub_83_191();
bool sub_91_101();
bool sub_101_106();
bool sub_148_160();
bool sub_160_185();
bool sub_161_179();
bool sub_179_184();
bool sub_191_208();
bool sub_208_284();
bool sub_247_267();
bool sub_248_253();
bool sub_253_266();
bool sub_257_260();
bool sub_260_265();
bool sub_267_280();
bool sub_268_273();
bool sub_273_279();
bool sub_284_311();
bool sub_286_291();
bool sub_291_310();
bool sub_294_300();
bool sub_300_309();
bool sub_301_305();
bool sub_305_308();
bool sub_311_319();
bool sub_313_314();
bool sub_314_318();
bool sub_315_316();
bool sub_316_317();
bool sub_319_326();
bool sub_326_330();
bool sub_330_354();
bool sub_332_336();
bool sub_336_353();
bool sub_337_351();
bool sub_340_347();
bool sub_347_350();
bool sub_351_352();
bool sub_354_370();
bool sub_356_360();
bool sub_360_369();
bool sub_361_367();
bool sub_367_368();

bool exec_shader() {
    sub_0_4096();
    return true;
}

bool sub_0_4096() {
    // 0: call
    {
        sub_83_191();
    }
    // 1: call
    {
        sub_284_311();
    }
    // 2: call
    {
        sub_330_354();
    }
    // 3: call
    {
        sub_354_370();
    }
    // 4: end
    return true;
}
bool sub_33_83() {
    // 33: add
    reg_tmp0.xyz = (reg_tmp6.xyzz + -reg_tmp1.xyzz).xyz;
    // 34: mov
    reg_tmp0.w = (uniforms.f[93].yyyy).w;
    // 35: dp4
    reg_tmp3.x = dot(mul_safe(reg_tmp0, reg_tmp0), vec4(1.0));
    // 36: rsq
    reg_tmp3.x = rsq_safe(reg_tmp3.xxxx.x);
    // 37: mul
    reg_tmp3 = mul_safe(reg_tmp0, reg_tmp3.xxxx);
    // 38: mov
    reg_tmp2.x = (-reg_tmp3.zzzz).x;
    // 39: mov
    reg_tmp2.y = (reg_tmp3.yyyy).y;
    // 40: mov
    reg_tmp2.z = (reg_tmp3.xxxx).z;
    // 41: add
    reg_tmp4.xyz = (reg_tmp6.xyzz + -reg_tmp10.xyzz).xyz;
    // 42: dp3
    reg_tmp0 = vec4(dot(vec3(mul_safe(-reg_tmp4, reg_tmp2)), vec3(1.0)));
    // 43: sgei
    reg_tmp0 = vec4(greaterThanEqual(reg_tmp0,uniforms.f[93].xxxx));
    // 44: mul
    reg_tmp3 = mul_safe(reg_tmp2, reg_tmp0);
    // 45: add
    reg_tmp0 = uniforms.f[93].yyyy + -reg_tmp0;
    // 46: mad
    reg_tmp3 = fma_safe(-reg_tmp2, reg_tmp0, reg_tmp3);
    // 47: mul
    reg_tmp3 = mul_safe(reg_tmp3, reg_tmp7.zzzz);
    // 48: add
    reg_tmp9 = reg_tmp6 + -reg_tmp1;
    // 49: mad
    reg_tmp9 = fma_safe(reg_tmp9, reg_tmp5.zzzz, reg_tmp1);
    // 50: add
    reg_tmp9 = reg_tmp9 + reg_tmp3;
    // 51: add
    reg_tmp9 = reg_tmp9 + -reg_tmp10;
    // 52: mad
    reg_tmp9 = fma_safe(reg_tmp9, reg_tmp7.wwww, reg_tmp10);
    // 53: add
    reg_tmp3.xyz = (reg_tmp9.xyzz + -reg_tmp10.xyzz).xyz;
    // 54: add
    reg_tmp0.xyz = (reg_tmp6.xyzz + -reg_tmp1.xyzz).xyz;
    // 55: mov
    reg_tmp0.w = (uniforms.f[93].yyyy).w;
    // 56: dp4
    reg_tmp2.x = dot(mul_safe(reg_tmp0, reg_tmp0), vec4(1.0));
    // 57: rsq
    reg_tmp2.x = rsq_safe(reg_tmp2.xxxx.x);
    // 58: mul
    reg_tmp2 = mul_safe(reg_tmp0, reg_tmp2.xxxx);
    // 59: add
    reg_tmp0.xyz = (reg_tmp10.xyzz + -reg_tmp1.xyzz).xyz;
    // 60: mov
    reg_tmp0.w = (uniforms.f[93].yyyy).w;
    // 61: dp4
    reg_tmp9.x = dot(mul_safe(reg_tmp0, reg_tmp0), vec4(1.0));
    // 62: rsq
    reg_tmp9.x = rsq_safe(reg_tmp9.xxxx.x);
    // 63: mul
    reg_tmp9 = mul_safe(reg_tmp0, reg_tmp9.xxxx);
    // 64: dp3
    reg_tmp8.x = dot(vec3(mul_safe(reg_tmp9, reg_tmp2)), vec3(1.0));
    // 65: min
    reg_tmp8.x = (min(uniforms.f[93].yyyy, reg_tmp8.xxxx)).x;
    // 66: max
    reg_tmp8.x = (max(uniforms.f[93].xxxx, reg_tmp8.xxxx)).x;
    // 67: add
    reg_tmp5.x = (reg_tmp8.xxxx + -reg_tmp8.zzzz).x;
    // 68: max
    reg_tmp5.x = (max(uniforms.f[93].xxxx, reg_tmp5.xxxx)).x;
    // 69: mov
    reg_tmp0.w = (reg_tmp8.wwww).w;
    // 70: add
    reg_tmp0.w = (reg_tmp0.wwww + -reg_tmp8.zzzz).w;
    // 71: rcp
    reg_tmp0.w = rcp_safe(reg_tmp0.wwww.x);
    // 72: mul
    reg_tmp5.x = (mul_safe(reg_tmp5.xxxx, reg_tmp0.wwww)).x;
    // 73: min
    reg_tmp5.x = (min(uniforms.f[93].yyyy, reg_tmp5.xxxx)).x;
    // 74: log
    reg_tmp5.x = log2(reg_tmp5.xxxx.x);
    // 75: mul
    reg_tmp5.x = (mul_safe(reg_tmp5.xxxx, reg_tmp7.xxxx)).x;
    // 76: exp
    reg_tmp5.x = exp2(reg_tmp5.xxxx.x);
    // 77: mul
    reg_tmp0 = mul_safe(uniforms.f[7].wwww, vs_in_reg3);
    // 78: mul
    reg_tmp5.x = (mul_safe(reg_tmp5.xxxx, reg_tmp0.wwww)).x;
    // 79: mul
    reg_tmp3 = mul_safe(reg_tmp3, reg_tmp5.xxxx);
    // 80: add
    reg_tmp10.xyz = (reg_tmp10.xyzz + reg_tmp3.xyzz).xyz;
    // 81: sge
    reg_tmp0.w = (vec4(greaterThanEqual(reg_tmp8.xxxx,reg_tmp8.yyyy))).w;
    // 82: add
    reg_tmp5.y = (reg_tmp5.yyyy + reg_tmp0.wwww).y;
    return false;
}
bool sub_83_191() {
    // 83: mul
    reg_tmp15.xyz = (mul_safe(uniforms.f[7].xxxx, vs_in_reg0)).xyz;
    // 84: mul
    reg_tmp14.xyz = (mul_safe(uniforms.f[7].yyyy, vs_in_reg1)).xyz;
    // 85: mul
    reg_tmp13.xyz = (mul_safe(uniforms.f[7].zzzz, vs_in_reg2)).xyz;
    // 86: add
    reg_tmp15.xyz = (uniforms.f[6] + reg_tmp15).xyz;
    // 87: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 88: mov
    reg_tmp0 = uniforms.f[7];
    // 89: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.yzzz));
    // 90: ifu
    if (uniforms.b[2]) {
        sub_91_101();
    } else {
        sub_101_106();
    }
    // 106: mov
    reg_tmp1 = uniforms.f[80];
    // 107: mov
    reg_tmp1.y = (reg_tmp10.yyyy).y;
    // 108: mov
    reg_tmp1.w = (uniforms.f[79].xxxx).w;
    // 109: mov
    reg_tmp6 = uniforms.f[81];
    // 110: mov
    reg_tmp6.y = (reg_tmp1.yyyy).y;
    // 111: add
    reg_tmp0 = reg_tmp6 + -reg_tmp1;
    // 112: mad
    reg_tmp6.xyz = (fma_safe(reg_tmp0.xyzz, uniforms.f[79].wwww, reg_tmp1)).xyz;
    // 113: mov
    reg_tmp7 = uniforms.f[82];
    // 114: mov
    reg_tmp8.z = (uniforms.f[85].xxxx).z;
    // 115: mov
    reg_tmp8.w = (uniforms.f[85].yyyy).w;
    // 116: mov
    reg_tmp8.y = (uniforms.f[81].wwww).y;
    // 117: mov
    reg_tmp5.y = (uniforms.f[93].xxxx).y;
    // 118: add
    reg_tmp0 = reg_tmp6 + -reg_tmp1;
    // 119: dp3
    reg_tmp0.x = dot(vec3(mul_safe(reg_tmp0.xyzz, reg_tmp0.xyzz)), vec3(1.0));
    // 120: rsq
    reg_tmp0.x = rsq_safe(reg_tmp0.xxxx.x);
    // 121: rcp
    reg_tmp0.w = rcp_safe(reg_tmp0.xxxx.x);
    // 122: add
    reg_tmp0.y = (uniforms.f[79].yyyy + reg_tmp1.wwww).y;
    // 123: add
    reg_tmp0.y = (reg_tmp0.wwww + -reg_tmp0.yyyy).y;
    // 124: mad
    reg_tmp0.z = (fma_safe(reg_tmp0.yyyy, uniforms.f[94].zzzz, reg_tmp1.wwww)).z;
    // 125: mul
    reg_tmp5.z = (mul_safe(reg_tmp0.zzzz, reg_tmp0.xxxx)).z;
    // 126: call
    {
        sub_33_83();
    }
    // 127: mov
    reg_tmp6 = uniforms.f[83];
    // 128: mov
    reg_tmp6.y = (reg_tmp1.yyyy).y;
    // 129: add
    reg_tmp0 = reg_tmp6 + -reg_tmp1;
    // 130: mad
    reg_tmp6.xyz = (fma_safe(reg_tmp0.xyzz, uniforms.f[79].wwww, reg_tmp1)).xyz;
    // 131: mov
    reg_tmp7 = uniforms.f[84];
    // 132: mov
    reg_tmp8.z = (uniforms.f[85].zzzz).z;
    // 133: mov
    reg_tmp8.w = (uniforms.f[85].wwww).w;
    // 134: mov
    reg_tmp8.y = (uniforms.f[83].wwww).y;
    // 135: add
    reg_tmp0 = reg_tmp6 + -reg_tmp1;
    // 136: dp3
    reg_tmp0.x = dot(vec3(mul_safe(reg_tmp0.xyzz, reg_tmp0.xyzz)), vec3(1.0));
    // 137: rsq
    reg_tmp0.x = rsq_safe(reg_tmp0.xxxx.x);
    // 138: rcp
    reg_tmp0.w = rcp_safe(reg_tmp0.xxxx.x);
    // 139: add
    reg_tmp0.y = (uniforms.f[79].yyyy + reg_tmp1.wwww).y;
    // 140: add
    reg_tmp0.y = (reg_tmp0.wwww + -reg_tmp0.yyyy).y;
    // 141: mad
    reg_tmp0.z = (fma_safe(reg_tmp0.yyyy, uniforms.f[94].zzzz, reg_tmp1.wwww)).z;
    // 142: mul
    reg_tmp5.z = (mul_safe(reg_tmp0.zzzz, reg_tmp0.xxxx)).z;
    // 143: call
    {
        sub_33_83();
    }
    // 144: mul
    reg_tmp0.xyz = (mul_safe(uniforms.f[7].wwww, vs_in_reg3.xyzz)).xyz;
    // 145: add
    reg_tmp0.w = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).w;
    // 146: mov
    vs_out_attr3 = reg_tmp0;
    // 147: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_148_160();
    } else {
        sub_160_185();
    }
    // 185: mov
    vs_out_attr2 = -reg_tmp15;
    // 186: dp4
    vs_out_attr0.x = dot(mul_safe(uniforms.f[86], reg_tmp15), vec4(1.0));
    // 187: dp4
    vs_out_attr0.y = dot(mul_safe(uniforms.f[87], reg_tmp15), vec4(1.0));
    // 188: dp4
    vs_out_attr0.z = dot(mul_safe(uniforms.f[88], reg_tmp15), vec4(1.0));
    // 189: dp4
    vs_out_attr0.w = dot(mul_safe(uniforms.f[89], reg_tmp15), vec4(1.0));
    // 190: nop
    return false;
}
bool sub_91_101() {
    // 91: mul
    reg_tmp1.x = (mul_safe(uniforms.f[93].wwww, vs_in_reg7.xxxx)).x;
    // 92: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 93: dp4
    reg_tmp7.x = dot(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp15), vec4(1.0));
    // 94: dp4
    reg_tmp7.y = dot(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp15), vec4(1.0));
    // 95: dp4
    reg_tmp7.z = dot(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp15), vec4(1.0));
    // 96: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 97: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[0], reg_tmp7), vec4(1.0));
    // 98: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[1], reg_tmp7), vec4(1.0));
    // 99: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[2], reg_tmp7), vec4(1.0));
    // 100: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_101_106() {
    // 101: mova
    address_registers.x = (ivec2(uniforms.f[93].xxxx)).x;
    // 102: dp4
    reg_tmp10.x = dot(mul_safe(uniforms.f[25], reg_tmp15), vec4(1.0));
    // 103: dp4
    reg_tmp10.y = dot(mul_safe(uniforms.f[26], reg_tmp15), vec4(1.0));
    // 104: dp4
    reg_tmp10.z = dot(mul_safe(uniforms.f[27], reg_tmp15), vec4(1.0));
    // 105: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_148_160() {
    // 148: dp3
    reg_tmp12.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 149: dp3
    reg_tmp12.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 150: dp3
    reg_tmp12.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 151: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 152: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 153: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 154: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 155: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 156: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 157: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 158: call
    {
        sub_191_208();
    }
    // 159: nop
    return false;
}
bool sub_160_185() {
    // 160: ifc
    if (all(conditional_code)) {
        sub_161_179();
    } else {
        sub_179_184();
    }
    // 184: nop
    return false;
}
bool sub_161_179() {
    // 161: dp3
    reg_tmp12.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 162: dp3
    reg_tmp12.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 163: dp3
    reg_tmp12.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp14)), vec3(1.0));
    // 164: dp3
    reg_tmp11.x = dot(vec3(mul_safe(uniforms.f[25 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 165: dp3
    reg_tmp11.y = dot(vec3(mul_safe(uniforms.f[26 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 166: dp3
    reg_tmp11.z = dot(vec3(mul_safe(uniforms.f[27 + address_registers.x], reg_tmp13)), vec3(1.0));
    // 167: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 168: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 169: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 170: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 171: dp3
    reg_tmp14.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp12)), vec3(1.0));
    // 172: dp3
    reg_tmp14.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp12)), vec3(1.0));
    // 173: dp3
    reg_tmp14.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp12)), vec3(1.0));
    // 174: dp3
    reg_tmp13.x = dot(vec3(mul_safe(uniforms.f[3], reg_tmp11)), vec3(1.0));
    // 175: dp3
    reg_tmp13.y = dot(vec3(mul_safe(uniforms.f[4], reg_tmp11)), vec3(1.0));
    // 176: dp3
    reg_tmp13.z = dot(vec3(mul_safe(uniforms.f[5], reg_tmp11)), vec3(1.0));
    // 177: call
    {
        sub_208_284();
    }
    // 178: nop
    return false;
}
bool sub_179_184() {
    // 179: dp4
    reg_tmp15.x = dot(mul_safe(uniforms.f[90], reg_tmp10), vec4(1.0));
    // 180: dp4
    reg_tmp15.y = dot(mul_safe(uniforms.f[91], reg_tmp10), vec4(1.0));
    // 181: dp4
    reg_tmp15.z = dot(mul_safe(uniforms.f[92], reg_tmp10), vec4(1.0));
    // 182: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 183: mov
    vs_out_attr1 = uniforms.f[93].xxxx;
    return false;
}
bool sub_191_208() {
    uint jmp_to = 191u;
    while (true) {
        switch (jmp_to) {
        case 191u: {
            // 191: dp3
            reg_tmp6.x = dot(vec3(mul_safe(reg_tmp14, reg_tmp14)), vec3(1.0));
            // 192: dp3
            reg_tmp7.x = dot(vec3(mul_safe(reg_tmp12, reg_tmp12)), vec3(1.0));
            // 193: rsq
            reg_tmp6.x = rsq_safe(reg_tmp6.xxxx.x);
            // 194: rsq
            reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
            // 195: mul
            reg_tmp14.xyz = (mul_safe(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 196: mul
            reg_tmp12.xyz = (mul_safe(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 197: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 198: jmpu
            if (!uniforms.b[15]) {
                { jmp_to = 207u; break; }
            }
            // 199: add
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            // 200: mul
            reg_tmp4 = mul_safe(uniforms.f[94].zzzz, reg_tmp4);
            // 201: cmp
            conditional_code = greaterThanEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp4.xxxx));
            // 202: rsq
            reg_tmp4 = vec4(rsq_safe(reg_tmp4.xxxx.x));
            // 203: mul
            reg_tmp5 = mul_safe(uniforms.f[94].zzzz, reg_tmp14);
            // 204: jmpc
            if (conditional_code.x) {
                { jmp_to = 207u; break; }
            }
            // 205: rcp
            reg_tmp0.z = rcp_safe(reg_tmp4.xxxx.x);
            // 206: mul
            reg_tmp0.xy = (mul_safe(reg_tmp5, reg_tmp4)).xy;
        }
        case 207u: {
            // 207: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_208_284() {
    uint jmp_to = 208u;
    while (true) {
        switch (jmp_to) {
        case 208u: {
            // 208: dp3
            reg_tmp6.x = dot(vec3(mul_safe(reg_tmp14, reg_tmp14)), vec3(1.0));
            // 209: dp3
            reg_tmp7.x = dot(vec3(mul_safe(reg_tmp12, reg_tmp12)), vec3(1.0));
            // 210: rsq
            reg_tmp6.x = rsq_safe(reg_tmp6.xxxx.x);
            // 211: rsq
            reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
            // 212: mul
            reg_tmp14.xyz = (mul_safe(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 213: mul
            reg_tmp12.xyz = (mul_safe(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 214: mul
            reg_tmp13.xyz = (mul_safe(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            // 215: mul
            reg_tmp11.xyz = (mul_safe(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            // 216: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 217: jmpu
            if (!uniforms.b[15]) {
                { jmp_to = 283u; break; }
            }
            // 218: mul
            reg_tmp13.xyz = (mul_safe(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            // 219: mul
            reg_tmp11.xyz = (mul_safe(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            // 220: mul
            reg_tmp5 = mul_safe(reg_tmp14.yzxx, reg_tmp13.zxyy);
            // 221: mad
            reg_tmp5 = fma_safe(-reg_tmp13.yzxx, reg_tmp14.zxyy, reg_tmp5);
            // 222: dp3
            reg_tmp5.w = dot(vec3(mul_safe(reg_tmp5, reg_tmp5)), vec3(1.0));
            // 223: rsq
            reg_tmp5.w = rsq_safe(reg_tmp5.wwww.x);
            // 224: mul
            reg_tmp5 = mul_safe(reg_tmp5, reg_tmp5.wwww);
            // 225: add
            reg_tmp6.w = (reg_tmp14.zzzz + reg_tmp5.yyyy).w;
            // 226: mul
            reg_tmp13 = mul_safe(reg_tmp5.yzxx, reg_tmp14.zxyy);
            // 227: mad
            reg_tmp13 = fma_safe(-reg_tmp14.yzxx, reg_tmp5.zxyy, reg_tmp13);
            // 228: add
            reg_tmp6.w = (reg_tmp13.xxxx + reg_tmp6).w;
            // 229: mov
            reg_tmp13.w = (reg_tmp5.zzzz).w;
            // 230: mov
            reg_tmp5.z = (reg_tmp13.xxxx).z;
            // 231: add
            reg_tmp6.w = (uniforms.f[93].yyyy + reg_tmp6).w;
            // 232: mov
            reg_tmp14.w = (reg_tmp5.xxxx).w;
            // 233: mov
            reg_tmp5.x = (reg_tmp14.zzzz).x;
            // 234: cmp
            conditional_code = lessThan(vec2(uniforms.f[94].yyyy), vec2(reg_tmp6.wwww));
            // 235: mov
            reg_tmp6.x = (uniforms.f[93].yyyy).x;
            // 236: mov
            reg_tmp6.y = (-uniforms.f[93].yyyy).y;
            // 237: jmpc
            if (!conditional_code.x) {
                { jmp_to = 245u; break; }
            }
            // 238: add
            reg_tmp7.xz = (reg_tmp13.wwyy + -reg_tmp14.yyww).xz;
            // 239: add
            reg_tmp7.y = (reg_tmp14.xxxx + -reg_tmp13.zzzz).y;
            // 240: mov
            reg_tmp7.w = (reg_tmp6).w;
            // 241: dp4
            reg_tmp6 = vec4(dot(mul_safe(reg_tmp7, reg_tmp7), vec4(1.0)));
            // 242: rsq
            reg_tmp6 = vec4(rsq_safe(reg_tmp6.xxxx.x));
            // 243: mul
            reg_tmp0 = mul_safe(reg_tmp7, reg_tmp6);
            // 244: jmpu
            if (uniforms.b[0]) {
                { jmp_to = 283u; break; }
            }
        }
        case 245u: {
            // 245: cmp
            conditional_code = greaterThan(vec2(reg_tmp5.zyyy), vec2(reg_tmp5.yxxx));
            // 246: ifc
            if (conditional_code.x) {
                sub_247_267();
            } else {
                sub_267_280();
            }
            // 280: dp4
            reg_tmp6 = vec4(dot(mul_safe(reg_tmp8, reg_tmp8), vec4(1.0)));
            // 281: rsq
            reg_tmp6 = vec4(rsq_safe(reg_tmp6.xxxx.x));
            // 282: mul
            reg_tmp0 = mul_safe(reg_tmp8, reg_tmp6);
        }
        case 283u: {
            // 283: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_247_267() {
    // 247: ifc
    if (conditional_code.y) {
        sub_248_253();
    } else {
        sub_253_266();
    }
    // 266: mov
    reg_tmp8.w = (-reg_tmp8).w;
    return false;
}
bool sub_248_253() {
    // 248: mul
    reg_tmp8 = mul_safe(reg_tmp13.yyzw, reg_tmp6.xxxy);
    // 249: add
    reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
    // 250: add
    reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
    // 251: add
    reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
    // 252: add
    reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
    return false;
}
bool sub_253_266() {
    // 253: cmp
    conditional_code = greaterThan(vec2(reg_tmp5.zzzz), vec2(reg_tmp5.xxxx));
    // 254: mul
    reg_tmp8 = mul_safe(reg_tmp13.yyzw, reg_tmp6.xxxy);
    // 255: add
    reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
    // 256: ifc
    if (conditional_code.x) {
        sub_257_260();
    } else {
        sub_260_265();
    }
    // 265: nop
    return false;
}
bool sub_257_260() {
    // 257: add
    reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
    // 258: add
    reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
    // 259: add
    reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
    return false;
}
bool sub_260_265() {
    // 260: mul
    reg_tmp8 = mul_safe(reg_tmp13.zwwy, reg_tmp6.xxxy);
    // 261: add
    reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
    // 262: add
    reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
    // 263: add
    reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
    // 264: add
    reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
    return false;
}
bool sub_267_280() {
    // 267: ifc
    if (conditional_code.y) {
        sub_268_273();
    } else {
        sub_273_279();
    }
    // 279: nop
    return false;
}
bool sub_268_273() {
    // 268: mul
    reg_tmp8 = mul_safe(reg_tmp13.yywz, reg_tmp6.xxxy);
    // 269: add
    reg_tmp8.y = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).y;
    // 270: add
    reg_tmp9 = reg_tmp5.yyyy + -reg_tmp5.xxxx;
    // 271: add
    reg_tmp8.xzw = (reg_tmp8 + reg_tmp14.wwyx).xzw;
    // 272: add
    reg_tmp8.y = (reg_tmp9 + reg_tmp8).y;
    return false;
}
bool sub_273_279() {
    // 273: mul
    reg_tmp8 = mul_safe(reg_tmp13.zwwy, reg_tmp6.xxxy);
    // 274: add
    reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
    // 275: add
    reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
    // 276: add
    reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
    // 277: add
    reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
    // 278: mov
    reg_tmp8.w = (-reg_tmp8).w;
    return false;
}
bool sub_284_311() {
    // 284: mov
    reg_tmp0.xy = (uniforms.f[10].xxxx).xy;
    // 285: ifu
    if (uniforms.b[9]) {
        sub_286_291();
    } else {
        sub_291_310();
    }
    // 310: nop
    return false;
}
bool sub_286_291() {
    // 286: call
    {
        sub_311_319();
    }
    // 287: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[11].xywz, reg_tmp6), vec4(1.0));
    // 288: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[12].xywz, reg_tmp6), vec4(1.0));
    // 289: mov
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    // 290: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_291_310() {
    // 291: cmp
    conditional_code = equal(vec2(uniforms.f[95].xyyy), vec2(reg_tmp0.xyyy));
    // 292: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 293: ifc
    if (all(not(conditional_code))) {
        sub_294_300();
    } else {
        sub_300_309();
    }
    // 309: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_294_300() {
    // 294: mov
    reg_tmp6 = reg_tmp10;
    // 295: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[11], reg_tmp6), vec4(1.0));
    // 296: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[12], reg_tmp6), vec4(1.0));
    // 297: dp4
    reg_tmp3.z = dot(mul_safe(uniforms.f[13], reg_tmp6), vec4(1.0));
    // 298: mul
    reg_tmp0.xy = (mul_safe(uniforms.f[19].xyyy, reg_tmp3.zzzz)).xy;
    // 299: add
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_300_309() {
    // 300: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_301_305();
    } else {
        sub_305_308();
    }
    // 308: nop
    return false;
}
bool sub_301_305() {
    // 301: call
    {
        sub_319_326();
    }
    // 302: dp3
    reg_tmp3.x = dot(vec3(mul_safe(uniforms.f[11], reg_tmp6)), vec3(1.0));
    // 303: dp3
    reg_tmp3.y = dot(vec3(mul_safe(uniforms.f[12], reg_tmp6)), vec3(1.0));
    // 304: dp3
    reg_tmp3.z = dot(vec3(mul_safe(uniforms.f[13], reg_tmp6)), vec3(1.0));
    return false;
}
bool sub_305_308() {
    // 305: call
    {
        sub_326_330();
    }
    // 306: dp4
    reg_tmp3.x = dot(mul_safe(uniforms.f[11], reg_tmp6), vec4(1.0));
    // 307: dp4
    reg_tmp3.y = dot(mul_safe(uniforms.f[12], reg_tmp6), vec4(1.0));
    return false;
}
bool sub_311_319() {
    // 311: cmp
    conditional_code = equal(vec2(uniforms.f[93].yzzz), vec2(reg_tmp0.xyyy));
    // 312: ifc
    if (all(not(conditional_code))) {
        sub_313_314();
    } else {
        sub_314_318();
    }
    // 318: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_313_314() {
    // 313: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
    return false;
}
bool sub_314_318() {
    // 314: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_315_316();
    } else {
        sub_316_317();
    }
    // 317: nop
    return false;
}
bool sub_315_316() {
    // 315: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
    return false;
}
bool sub_316_317() {
    // 316: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
    return false;
}
bool sub_319_326() {
    // 319: mov
    reg_tmp2 = -reg_tmp15;
    // 320: dp3
    reg_tmp2.w = dot(vec3(mul_safe(reg_tmp2, reg_tmp2)), vec3(1.0));
    // 321: rsq
    reg_tmp2.w = rsq_safe(reg_tmp2.wwww.x);
    // 322: mul
    reg_tmp2 = mul_safe(reg_tmp2, reg_tmp2.wwww);
    // 323: dp3
    reg_tmp1 = vec4(dot(vec3(mul_safe(reg_tmp2, reg_tmp14)), vec3(1.0)));
    // 324: add
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    // 325: mad
    reg_tmp6 = fma_safe(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_326_330() {
    // 326: mov
    reg_tmp1.xy = (uniforms.f[94].zzzz).xy;
    // 327: mov
    reg_tmp1.zw = (uniforms.f[93].xxxx).zw;
    // 328: mad
    reg_tmp6 = fma_safe(reg_tmp14, reg_tmp1, reg_tmp1);
    // 329: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_330_354() {
    // 330: mov
    reg_tmp0.xy = (uniforms.f[10].yyyy).xy;
    // 331: ifu
    if (uniforms.b[10]) {
        sub_332_336();
    } else {
        sub_336_353();
    }
    // 353: nop
    return false;
}
bool sub_332_336() {
    // 332: call
    {
        sub_311_319();
    }
    // 333: dp4
    reg_tmp4.x = dot(mul_safe(uniforms.f[14].xywz, reg_tmp6), vec4(1.0));
    // 334: dp4
    reg_tmp4.y = dot(mul_safe(uniforms.f[15].xywz, reg_tmp6), vec4(1.0));
    // 335: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_336_353() {
    // 336: ifu
    if (uniforms.b[13]) {
        sub_337_351();
    } else {
        sub_351_352();
    }
    // 352: nop
    return false;
}
bool sub_337_351() {
    // 337: cmp
    conditional_code = equal(vec2(uniforms.f[95].xyyy), vec2(reg_tmp0.xyyy));
    // 338: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 339: ifc
    if (all(not(conditional_code))) {
        sub_340_347();
    } else {
        sub_347_350();
    }
    // 350: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_340_347() {
    // 340: mov
    reg_tmp6 = reg_tmp10;
    // 341: dp4
    reg_tmp4.x = dot(mul_safe(uniforms.f[14], reg_tmp6), vec4(1.0));
    // 342: dp4
    reg_tmp4.y = dot(mul_safe(uniforms.f[15], reg_tmp6), vec4(1.0));
    // 343: dp4
    reg_tmp4.z = dot(mul_safe(uniforms.f[16], reg_tmp6), vec4(1.0));
    // 344: rcp
    reg_tmp6.w = rcp_safe(reg_tmp4.zzzz.x);
    // 345: mul
    reg_tmp4.xy = (mul_safe(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    // 346: add
    reg_tmp4.xy = (uniforms.f[19].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_347_350() {
    // 347: call
    {
        sub_326_330();
    }
    // 348: dp4
    reg_tmp4.x = dot(mul_safe(uniforms.f[14], reg_tmp6), vec4(1.0));
    // 349: dp4
    reg_tmp4.y = dot(mul_safe(uniforms.f[15], reg_tmp6), vec4(1.0));
    return false;
}
bool sub_351_352() {
    // 351: mov
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_354_370() {
    // 354: mov
    reg_tmp0.xy = (uniforms.f[10].zzzz).xy;
    // 355: ifu
    if (uniforms.b[11]) {
        sub_356_360();
    } else {
        sub_360_369();
    }
    // 369: nop
    return false;
}
bool sub_356_360() {
    // 356: call
    {
        sub_311_319();
    }
    // 357: dp4
    reg_tmp5.x = dot(mul_safe(uniforms.f[17].xywz, reg_tmp6), vec4(1.0));
    // 358: dp4
    reg_tmp5.y = dot(mul_safe(uniforms.f[18].xywz, reg_tmp6), vec4(1.0));
    // 359: mov
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_360_369() {
    // 360: ifu
    if (uniforms.b[14]) {
        sub_361_367();
    } else {
        sub_367_368();
    }
    // 368: nop
    return false;
}
bool sub_361_367() {
    // 361: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 362: mov
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    // 363: call
    {
        sub_326_330();
    }
    // 364: dp4
    reg_tmp5.x = dot(mul_safe(uniforms.f[17], reg_tmp6), vec4(1.0));
    // 365: dp4
    reg_tmp5.y = dot(mul_safe(uniforms.f[18], reg_tmp6), vec4(1.0));
    // 366: mov
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_367_368() {
    // 367: mov
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
// reference: EEC11DF1E3521BD4, 6433CFAAB43ABCE5
// shader: 8B30, 29F9C9D1D8063EF7

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 23275838ECE33F11, 29F9C9D1D8063EF7
// program: 6433CFAAB43ABCE5, AD7922A63ED54CA7, 29F9C9D1D8063EF7
// reference: 77AEF003C79E5F0E, CD1237CA557B3805
// reference: EEFB88421C27FE49, CD1237CA557B3805
// reference: C79F33DAAC3ADF79, BAF5CB3693892DB3
// program: BAF5CB3693892DB3, 3B3AE026C742C7D5, EC68C55D9E1FD734
// reference: BE4A11E61C27FE49, CD1237CA557B3805
// reference: 5ECA4B9B77837E3E, BAF5CB3693892DB3
// reference: 2DFD06A2D162015B, C76486EE232535F2
// program: C76486EE232535F2, AD7922A63ED54CA7, 24B822D609CE0531
// reference: 2DFD06A286659455, 46DC307C8C5A54D6
// shader: 8B30, CDA1D6F70BB061E5

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = 2.0 * (texcolor2).rgb - 1.0;
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(normal, normalize(view))));
refl_value.g = (lut_scale_rg * LookupLightingLUTSigned(5, dot(normal, normalize(view))));
refl_value.b = (lut_scale_rb * LookupLightingLUTSigned(4, dot(normal, normalize(view))));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor1.rgb) * (vec3(1.0) - const_color[0].aaa) + (const_color[0].rgb) * (vec3(1.0) - (vec3(1.0) - const_color[0].aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor1.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_1 = byteround(clamp((texcolor0.rgb) + (last_tex_env_out.rgb) - vec3(0.5), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((secondary_fragment_color.r) * (texcolor2.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (combiner_buffer.rgb) - vec3(0.5), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (1.0 - const_color[2].a) + (secondary_fragment_color.b) * (1.0 - (1.0 - const_color[2].a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((texcolor1.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((secondary_fragment_color.ggg) * (last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 86DB56A8DCB445BE, CDA1D6F70BB061E5
// program: 46DC307C8C5A54D6, AD7922A63ED54CA7, CDA1D6F70BB061E5
// reference: 460C959CBF2570AD, BAF5CB3693892DB3
// reference: DF59EDDD649CD1EA, BAF5CB3693892DB3
// reference: 971EC479F465D062, 5746FEF0B06D455B
// reference: DCF7FCB841524622, BAF5CB3693892DB3
// reference: 249C27C0A52E8633, 315EA8EB5C41C833
// reference: 249C27C049996D30, EBBB74BA3C410F00
// reference: F0F853ED0E3A828F, 6433CFAAB43ABCE5
// reference: 54643228F72AEDB8, 29F9C9D1D8063EF7
// reference: 6997BE1F2AF6C655, CD1237CA557B3805
// reference: F0C2C65EF14F6712, CD1237CA557B3805
// reference: D9A67DC641524622, BAF5CB3693892DB3
// reference: A0735FFAF14F6712, CD1237CA557B3805
// reference: 40F305879AEBE765, BAF5CB3693892DB3
// reference: 86DB56A8AE049C72, CDA1D6F70BB061E5
// reference: 249C27C0F59DECEF, 315EA8EB5C41C833
// reference: F0C2C65EDF0E3FA6, AA5284D8354BC7F4
// program: AA5284D8354BC7F4, 3B3AE026C742C7D5, 964E0B11E50F8F6E
// program: CD1237CA557B3805, 3B3AE026C742C7D5, 24B822D609CE0531
// reference: A0735FFADF0E3FA6, AA5284D8354BC7F4
// program: AA5284D8354BC7F4, 3B3AE026C742C7D5, 09998F9B86E3CF69
// reference: 5358FED861A8CD3B, 4D9765BCC73533ED
// program: 4D9765BCC73533ED, AD7922A63ED54CA7, CB541D02F0C32C04
// reference: 5358FED88E915E7A, 4D9765BCC73533ED
// program: 4D9765BCC73533ED, AD7922A63ED54CA7, 6320E09DD2EF8330
// reference: 87BFD9A4247D6F91, 7F132D830BF35BC2
// reference: 1EEAA1E5FFC4CED6, 7F132D830BF35BC2
// reference: B2CA5564B2CA7EC4, EC7233A0BD4CF3D2
// reference: 2B9F2D256973DF83, EC7233A0BD4CF3D2
// reference: BE8A228DF615764B, BAF5CB3693892DB3
// reference: 27DF5ACC2DACD70C, BAF5CB3693892DB3
// reference: 00A062E3BDB4302C, 5746FEF0B06D455B
// reference: 4B495A220883A66C, BAF5CB3693892DB3
// reference: 33F5969047EB62C1, 6433CFAAB43ABCE5
// reference: AA9A7B624D667EAF, AA5284D8354BC7F4
// reference: 33CF032396DFDFE8, AA5284D8354BC7F4
// reference: 33CF0323B89E875C, CD1237CA557B3805
// reference: 1AABB8BB0883A66C, BAF5CB3693892DB3
// reference: 637E9A87B89E875C, CD1237CA557B3805
// reference: 637E9A8796DFDFE8, AA5284D8354BC7F4
// reference: 83FEC0FAD33A072B, BAF5CB3693892DB3
// reference: AA9A7B626327261B, CD1237CA557B3805
// program: 0000000000000000, 0000000000000000, CE59663341BA1DD1
// reference: 508EAA39F4F6843E, EC7233A0BD4CF3D2
// program: EC7233A0BD4CF3D2, 5D764F9A6220D694, E6A65EBC7D1F5A7C
// reference: C9DBD2782F4F2579, EC7233A0BD4CF3D2
// program: EC7233A0BD4CF3D2, 5D764F9A6220D694, 2F92B03EC8DF229E
// program: 0000000000000000, 0000000000000000, B71BBB2F3051D5FF
// reference: 9DF16381F615764B, BAF5CB3693892DB3
// reference: 04A41BC02DACD70C, BAF5CB3693892DB3
// reference: 673221A685B6DBAC, 7F132D830BF35BC2
// reference: FE6759E75E0F7AEB, 7F132D830BF35BC2
// reference: C4C67A364550CC1A, EC7233A0BD4CF3D2
// reference: 5D9302779EE96D5D, EC7233A0BD4CF3D2
// program: 0000000000000000, 0000000000000000, F93C56DFAE996873
// reference: 09B9B38ED33A072B, BAF5CB3693892DB3
// reference: 90ECCBCF0883A66C, BAF5CB3693892DB3
// reference: 8F7A00CCBDB4302C, 5746FEF0B06D455B
// reference: C493380D0883A66C, BAF5CB3693892DB3
// program: 46DC307C8C5A54D6, AD7922A63ED54CA7, 615732319A39ACDD
// reference: 5555804D1AB2CC3F, EC7233A0BD4CF3D2
// reference: 982A49F5BF2570AD, BAF5CB3693892DB3
// reference: 017F31B4649CD1EA, BAF5CB3693892DB3
// reference: DC6F24AB44D3B7EC, 7F132D830BF35BC2
// reference: 701D7F9AA51A6DC8, 3DBC6131A77F0199
// reference: 701D7F9A4A23FE89, 3DBC6131A77F0199
// reference: 7D7B480A4FFF295E, B582B9861A22E219
// reference: 7D7B480AA0C6BA1F, B582B9861A22E219
// reference: 295B6280FE84E28B, BAF5CB3693892DB3
// reference: 861FF0C73F025EA9, 3DBC6131A77F0199
// reference: 295B628011BD71CA, BAF5CB3693892DB3
// reference: 01BA1E79BDAB5C9D, 7BB64A39FB1F4E77
// reference: 4D4FD09FA0C6BA1F, B582B9861A22E219
// reference: B62B68523F025EA9, 3DBC6131A77F0199
// reference: B62B6852D03BCDE8, 3DBC6131A77F0199
// reference: 196FFA1511BD71CA, BAF5CB3693892DB3
// reference: 196FFA15FE84E28B, BAF5CB3693892DB3
// reference: 4D4FD09F4FFF295E, B582B9861A22E219
// reference: 64F6630873B19F4B, 7F132D830BF35BC2
// reference: FDA31B49A8083E0C, 7F132D830BF35BC2
// reference: 803A8254253D43CC, BAF5CB3693892DB3
// reference: 8866A198FCBD5495, 1E6C0649B5CE7F1C
// reference: 3604ADEADDB4DDEA, BAF5CB3693892DB3
// reference: D6511F0C67143F47, EC7233A0BD4CF3D2
// reference: 4F04674DBCAD9E00, EC7233A0BD4CF3D2
// reference: AF51D5AB060D7CAD, BAF5CB3693892DB3
// reference: 99403FAD1C3261C8, 3DBC6131A77F0199
// reference: 3604ADEA328D4EAB, BAF5CB3693892DB3
// reference: 99403FADF30BF289, 3DBC6131A77F0199
// reference: 7A34FA3E4FFF295E, B582B9861A22E219
// reference: 7A34FA3EA0C6BA1F, B582B9861A22E219
// reference: 2E14D0B4FE84E28B, BAF5CB3693892DB3
// reference: 815042F33F025EA9, 3DBC6131A77F0199
// reference: 2E14D0B411BD71CA, BAF5CB3693892DB3
// reference: CD0A4E81BDAB5C9D, 7BB64A39FB1F4E77
// reference: 81FF8067A0C6BA1F, B582B9861A22E219
// reference: 7A9B38AA3F025EA9, 3DBC6131A77F0199
// reference: 7A9B38AAD03BCDE8, 3DBC6131A77F0199
// reference: D5DFAAED11BD71CA, BAF5CB3693892DB3
// reference: D5DFAAEDFE84E28B, BAF5CB3693892DB3
// reference: 81FF80674FFF295E, B582B9861A22E219
// reference: A84633F073B19F4B, 7F132D830BF35BC2
// reference: 31134BB1A8083E0C, 7F132D830BF35BC2
// reference: 4C8AD2AC253D43CC, BAF5CB3693892DB3
