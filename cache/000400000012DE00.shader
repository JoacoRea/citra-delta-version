// shader: 8B31, D82E12A9D19ACD63

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define fma_safe(x, y, z) fma(x, y, z)
#define mul_safe(x, y) (x * y)
#define rcp_safe(x) (1.0f / x)
#define rsq_safe(x) inversesqrt(x)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_4096();

bool exec_shader() {
    sub_0_4096();
    return true;
}

bool sub_0_4096() {
    // 0: dp4
    reg_tmp0.x = dot(uniforms.f[0], vs_in_reg0);
    // 1: dp4
    reg_tmp0.y = dot(uniforms.f[1], vs_in_reg0);
    // 2: dp4
    reg_tmp0.z = dot(uniforms.f[2], vs_in_reg0);
    // 3: mov
    reg_tmp0.w = (uniforms.f[77].wwww).w;
    // 4: dp4
    reg_tmp2.x = dot(uniforms.f[8], vs_in_reg2);
    // 5: dp4
    reg_tmp2.y = dot(uniforms.f[9], vs_in_reg2);
    // 6: dp4
    reg_tmp2.z = dot(uniforms.f[10], vs_in_reg2);
    // 7: mov
    reg_tmp2.w = (uniforms.f[78].wwww).w;
    // 8: dp4
    vs_out_attr0.x = dot(uniforms.f[3], reg_tmp0);
    // 9: dp4
    vs_out_attr0.y = dot(uniforms.f[4], reg_tmp0);
    // 10: dp4
    vs_out_attr0.z = dot(uniforms.f[5], reg_tmp0);
    // 11: dp4
    vs_out_attr0.w = dot(uniforms.f[6], reg_tmp0);
    // 12: mov
    vs_out_attr2 = reg_tmp2;
    // 13: mov
    vs_out_attr3 = reg_tmp2;
    // 14: mov
    vs_out_attr4 = reg_tmp2;
    // 15: mul
    vs_out_attr1 = mul_safe(uniforms.f[7], vs_in_reg1);
    // 16: end
    return true;
}
// reference: 8056C4AF36440EEB, D82E12A9D19ACD63
// shader: 8DD9, 5D764F9A6220D694

layout(triangles) in;
layout(triangle_strip, max_vertices = 3) out;

out vec4 primary_color;
out vec2 texcoord0;
out vec2 texcoord1;
out vec2 texcoord2;
out float texcoord0_w;
out vec4 normquat;
out vec3 view;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

 in vec4 vs_out_attr0[];
 in vec4 vs_out_attr1[];
 in vec4 vs_out_attr2[];
 in vec4 vs_out_attr3[];
 in vec4 vs_out_attr4[];

struct Vertex {
    vec4 attributes[5];
};

vec4 GetVertexQuaternion(Vertex vtx) {
    return vec4(0.0, 0.0, 0.0, 0.0);
}

void EmitVtx(Vertex vtx, bool quats_opposite) {
    vec4 vtx_pos = vec4(vtx.attributes[0].x, vtx.attributes[0].y, vtx.attributes[0].z, vtx.attributes[0].w);
    gl_Position = vtx_pos;
#if !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)
    gl_ClipDistance[0] = -vtx_pos.z;
    gl_ClipDistance[1] = dot(clip_coef, vtx_pos);
#endif // !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)

    vec4 vtx_quat = GetVertexQuaternion(vtx);
    normquat = mix(vtx_quat, -vtx_quat, bvec4(quats_opposite));

    vec4 vtx_color = vec4(vtx.attributes[1].x, vtx.attributes[1].y, vtx.attributes[1].z, vtx.attributes[1].w);
    primary_color = min(abs(vtx_color), vec4(1.0));

    texcoord0 = vec2(vtx.attributes[2].x, vtx.attributes[2].y);
    texcoord1 = vec2(vtx.attributes[3].x, vtx.attributes[3].y);

    texcoord0_w = 0.0;
    view = vec3(0.0, 0.0, 0.0);

    texcoord2 = vec2(vtx.attributes[4].x, vtx.attributes[4].y);

    EmitVertex();
}

bool AreQuaternionsOpposite(vec4 qa, vec4 qb) {
    return (dot(qa, qb) < 0.0);
}

void EmitPrim(Vertex vtx0, Vertex vtx1, Vertex vtx2) {
    EmitVtx(vtx0, false);
    EmitVtx(vtx1, AreQuaternionsOpposite(GetVertexQuaternion(vtx0), GetVertexQuaternion(vtx1)));
    EmitVtx(vtx2, AreQuaternionsOpposite(GetVertexQuaternion(vtx0), GetVertexQuaternion(vtx2)));
    EndPrimitive();
}

void main() {
    Vertex prim_buffer[3];
    prim_buffer[0].attributes = vec4[5](vs_out_attr0[0], vs_out_attr1[0], vs_out_attr2[0], vs_out_attr3[0], vs_out_attr4[0]);
    prim_buffer[1].attributes = vec4[5](vs_out_attr0[1], vs_out_attr1[1], vs_out_attr2[1], vs_out_attr3[1], vs_out_attr4[1]);
    prim_buffer[2].attributes = vec4[5](vs_out_attr0[2], vs_out_attr1[2], vs_out_attr2[2], vs_out_attr3[2], vs_out_attr4[2]);
    EmitPrim(prim_buffer[0], prim_buffer[1], prim_buffer[2]);
}
// reference: 5DAD5699F59B3586, 5D764F9A6220D694
// shader: 8B30, 3F3EC97B868B23C2

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D4F4BEF951C47A28, 3F3EC97B868B23C2
// program: D82E12A9D19ACD63, 5D764F9A6220D694, 3F3EC97B868B23C2
// reference: 0BB6130036440EEB, D82E12A9D19ACD63
// shader: 8B30, 2C50C50E156E44E0

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: CE312E6851C47A28, 2C50C50E156E44E0
// program: D82E12A9D19ACD63, 5D764F9A6220D694, 2C50C50E156E44E0
// shader: 8B30, 34D6219C2B988F6F

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 1080747751C47A28, 34D6219C2B988F6F
// program: D82E12A9D19ACD63, 5D764F9A6220D694, 34D6219C2B988F6F
// shader: 8B31, 70D24D55BDEC0B06

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 7) in vec4 vs_in_reg7;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define fma_safe(x, y, z) fma(x, y, z)
#define mul_safe(x, y) (x * y)
#define rcp_safe(x) (1.0f / x)
#define rsq_safe(x) inversesqrt(x)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_7_83();
bool sub_15_25();
bool sub_25_34();
bool sub_35_47();
bool sub_47_72();
bool sub_48_66();
bool sub_66_71();
bool sub_81_82();
bool sub_83_100();
bool sub_100_176();
bool sub_139_159();
bool sub_140_145();
bool sub_145_158();
bool sub_149_152();
bool sub_152_157();
bool sub_159_172();
bool sub_160_165();
bool sub_165_171();
bool sub_176_188();
bool sub_181_186();
bool sub_183_184();
bool sub_188_198();
bool sub_195_196();
bool sub_198_226();
bool sub_200_206();
bool sub_206_225();
bool sub_209_215();
bool sub_215_224();
bool sub_216_220();
bool sub_220_223();
bool sub_226_233();
bool sub_233_237();
bool sub_284_4096();

bool exec_shader() {
    sub_284_4096();
    return true;
}

bool sub_7_83() {
    // 7: mul
    reg_tmp15.xyz = (mul_safe(uniforms.f[7].xxxx, vs_in_reg0)).xyz;
    // 8: mul
    reg_tmp14.xyz = (mul_safe(uniforms.f[7].yyyy, vs_in_reg1)).xyz;
    // 9: mul
    reg_tmp13.xyz = (mul_safe(uniforms.f[7].zzzz, vs_in_reg2)).xyz;
    // 10: add
    reg_tmp15.xyz = (uniforms.f[6] + reg_tmp15).xyz;
    // 11: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 12: mov
    reg_tmp0 = uniforms.f[7];
    // 13: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.yzzz));
    // 14: ifu
    if (uniforms.b[2]) {
        sub_15_25();
    } else {
        sub_25_34();
    }
    // 34: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_35_47();
    } else {
        sub_47_72();
    }
    // 72: mov
    vs_out_attr2 = -reg_tmp15;
    // 73: dp4
    reg_tmp0.x = dot(uniforms.f[86], reg_tmp15);
    // 74: dp4
    reg_tmp0.y = dot(uniforms.f[87], reg_tmp15);
    // 75: dp4
    reg_tmp0.z = dot(uniforms.f[88], reg_tmp15);
    // 76: dp4
    reg_tmp0.w = dot(uniforms.f[89], reg_tmp15);
    // 77: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 78: mul
    reg_tmp1.y = (mul_safe(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
    // 79: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 80: ifc
    if (all(conditional_code)) {
        sub_81_82();
    }
    // 82: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_15_25() {
    // 15: mul
    reg_tmp1.x = (mul_safe(uniforms.f[93].wwww, vs_in_reg7.xxxx)).x;
    // 16: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 17: dp4
    reg_tmp7.x = dot(uniforms.f[25 + address_registers.x], reg_tmp15);
    // 18: dp4
    reg_tmp7.y = dot(uniforms.f[26 + address_registers.x], reg_tmp15);
    // 19: dp4
    reg_tmp7.z = dot(uniforms.f[27 + address_registers.x], reg_tmp15);
    // 20: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 21: dp4
    reg_tmp10.x = dot(uniforms.f[0], reg_tmp7);
    // 22: dp4
    reg_tmp10.y = dot(uniforms.f[1], reg_tmp7);
    // 23: dp4
    reg_tmp10.z = dot(uniforms.f[2], reg_tmp7);
    // 24: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_25_34() {
    // 25: mova
    address_registers.x = (ivec2(uniforms.f[93].xxxx)).x;
    // 26: dp4
    reg_tmp7.x = dot(uniforms.f[25], reg_tmp15);
    // 27: dp4
    reg_tmp7.y = dot(uniforms.f[26], reg_tmp15);
    // 28: dp4
    reg_tmp7.z = dot(uniforms.f[27], reg_tmp15);
    // 29: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 30: dp4
    reg_tmp10.x = dot(uniforms.f[0], reg_tmp7);
    // 31: dp4
    reg_tmp10.y = dot(uniforms.f[1], reg_tmp7);
    // 32: dp4
    reg_tmp10.z = dot(uniforms.f[2], reg_tmp7);
    // 33: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_35_47() {
    // 35: dp3
    reg_tmp12.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp14));
    // 36: dp3
    reg_tmp12.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp14));
    // 37: dp3
    reg_tmp12.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp14));
    // 38: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 39: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 40: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 41: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 42: dp3
    reg_tmp14.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp12));
    // 43: dp3
    reg_tmp14.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp12));
    // 44: dp3
    reg_tmp14.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp12));
    // 45: call
    {
        sub_83_100();
    }
    // 46: nop
    return false;
}
bool sub_47_72() {
    // 47: ifc
    if (all(conditional_code)) {
        sub_48_66();
    } else {
        sub_66_71();
    }
    // 71: nop
    return false;
}
bool sub_48_66() {
    // 48: dp3
    reg_tmp12.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp14));
    // 49: dp3
    reg_tmp12.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp14));
    // 50: dp3
    reg_tmp12.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp14));
    // 51: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp13));
    // 52: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp13));
    // 53: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp13));
    // 54: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 55: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 56: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 57: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 58: dp3
    reg_tmp14.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp12));
    // 59: dp3
    reg_tmp14.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp12));
    // 60: dp3
    reg_tmp14.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp12));
    // 61: dp3
    reg_tmp13.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp11));
    // 62: dp3
    reg_tmp13.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp11));
    // 63: dp3
    reg_tmp13.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp11));
    // 64: call
    {
        sub_100_176();
    }
    // 65: nop
    return false;
}
bool sub_66_71() {
    // 66: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 67: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 68: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 69: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 70: mov
    vs_out_attr1 = uniforms.f[93].xxxx;
    return false;
}
bool sub_81_82() {
    // 81: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_83_100() {
    uint jmp_to = 83u;
    while (true) {
        switch (jmp_to) {
        case 83u: {
            // 83: dp3
            reg_tmp6.x = dot(vec3(reg_tmp14), vec3(reg_tmp14));
            // 84: dp3
            reg_tmp7.x = dot(vec3(reg_tmp12), vec3(reg_tmp12));
            // 85: rsq
            reg_tmp6.x = rsq_safe(reg_tmp6.xxxx.x);
            // 86: rsq
            reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
            // 87: mul
            reg_tmp14.xyz = (mul_safe(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 88: mul
            reg_tmp12.xyz = (mul_safe(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 89: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 90: jmpu
            if (!uniforms.b[3]) {
                { jmp_to = 99u; break; }
            }
            // 91: add
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            // 92: mul
            reg_tmp4 = mul_safe(uniforms.f[94].zzzz, reg_tmp4);
            // 93: cmp
            conditional_code = greaterThanEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp4.xxxx));
            // 94: rsq
            reg_tmp4 = vec4(rsq_safe(reg_tmp4.xxxx.x));
            // 95: mul
            reg_tmp5 = mul_safe(uniforms.f[94].zzzz, reg_tmp14);
            // 96: jmpc
            if (conditional_code.x) {
                { jmp_to = 99u; break; }
            }
            // 97: rcp
            reg_tmp0.z = rcp_safe(reg_tmp4.xxxx.x);
            // 98: mul
            reg_tmp0.xy = (mul_safe(reg_tmp5, reg_tmp4)).xy;
        }
        case 99u: {
            // 99: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_100_176() {
    uint jmp_to = 100u;
    while (true) {
        switch (jmp_to) {
        case 100u: {
            // 100: dp3
            reg_tmp6.x = dot(vec3(reg_tmp14), vec3(reg_tmp14));
            // 101: dp3
            reg_tmp7.x = dot(vec3(reg_tmp12), vec3(reg_tmp12));
            // 102: rsq
            reg_tmp6.x = rsq_safe(reg_tmp6.xxxx.x);
            // 103: rsq
            reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
            // 104: mul
            reg_tmp14.xyz = (mul_safe(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 105: mul
            reg_tmp12.xyz = (mul_safe(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 106: mul
            reg_tmp13.xyz = (mul_safe(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            // 107: mul
            reg_tmp11.xyz = (mul_safe(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            // 108: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 109: jmpu
            if (!uniforms.b[3]) {
                { jmp_to = 175u; break; }
            }
            // 110: mul
            reg_tmp13.xyz = (mul_safe(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            // 111: mul
            reg_tmp11.xyz = (mul_safe(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            // 112: mul
            reg_tmp5 = mul_safe(reg_tmp14.yzxx, reg_tmp13.zxyy);
            // 113: mad
            reg_tmp5 = fma_safe(-reg_tmp13.yzxx, reg_tmp14.zxyy, reg_tmp5);
            // 114: dp3
            reg_tmp5.w = dot(vec3(reg_tmp5), vec3(reg_tmp5));
            // 115: rsq
            reg_tmp5.w = rsq_safe(reg_tmp5.wwww.x);
            // 116: mul
            reg_tmp5 = mul_safe(reg_tmp5, reg_tmp5.wwww);
            // 117: add
            reg_tmp6.w = (reg_tmp14.zzzz + reg_tmp5.yyyy).w;
            // 118: mul
            reg_tmp13 = mul_safe(reg_tmp5.yzxx, reg_tmp14.zxyy);
            // 119: mad
            reg_tmp13 = fma_safe(-reg_tmp14.yzxx, reg_tmp5.zxyy, reg_tmp13);
            // 120: add
            reg_tmp6.w = (reg_tmp13.xxxx + reg_tmp6).w;
            // 121: mov
            reg_tmp13.w = (reg_tmp5.zzzz).w;
            // 122: mov
            reg_tmp5.z = (reg_tmp13.xxxx).z;
            // 123: add
            reg_tmp6.w = (uniforms.f[93].yyyy + reg_tmp6).w;
            // 124: mov
            reg_tmp14.w = (reg_tmp5.xxxx).w;
            // 125: mov
            reg_tmp5.x = (reg_tmp14.zzzz).x;
            // 126: cmp
            conditional_code = lessThan(vec2(uniforms.f[94].yyyy), vec2(reg_tmp6.wwww));
            // 127: mov
            reg_tmp6.x = (uniforms.f[93].yyyy).x;
            // 128: mov
            reg_tmp6.y = (-uniforms.f[93].yyyy).y;
            // 129: jmpc
            if (!conditional_code.x) {
                { jmp_to = 137u; break; }
            }
            // 130: add
            reg_tmp7.xz = (reg_tmp13.wwyy + -reg_tmp14.yyww).xz;
            // 131: add
            reg_tmp7.y = (reg_tmp14.xxxx + -reg_tmp13.zzzz).y;
            // 132: mov
            reg_tmp7.w = (reg_tmp6).w;
            // 133: dp4
            reg_tmp6 = vec4(dot(reg_tmp7, reg_tmp7));
            // 134: rsq
            reg_tmp6 = vec4(rsq_safe(reg_tmp6.xxxx.x));
            // 135: mul
            reg_tmp0 = mul_safe(reg_tmp7, reg_tmp6);
            // 136: jmpu
            if (uniforms.b[0]) {
                { jmp_to = 175u; break; }
            }
        }
        case 137u: {
            // 137: cmp
            conditional_code = greaterThan(vec2(reg_tmp5.zyyy), vec2(reg_tmp5.yxxx));
            // 138: ifc
            if (conditional_code.x) {
                sub_139_159();
            } else {
                sub_159_172();
            }
            // 172: dp4
            reg_tmp6 = vec4(dot(reg_tmp8, reg_tmp8));
            // 173: rsq
            reg_tmp6 = vec4(rsq_safe(reg_tmp6.xxxx.x));
            // 174: mul
            reg_tmp0 = mul_safe(reg_tmp8, reg_tmp6);
        }
        case 175u: {
            // 175: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_139_159() {
    // 139: ifc
    if (conditional_code.y) {
        sub_140_145();
    } else {
        sub_145_158();
    }
    // 158: mov
    reg_tmp8.w = (-reg_tmp8).w;
    return false;
}
bool sub_140_145() {
    // 140: mul
    reg_tmp8 = mul_safe(reg_tmp13.yyzw, reg_tmp6.xxxy);
    // 141: add
    reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
    // 142: add
    reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
    // 143: add
    reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
    // 144: add
    reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
    return false;
}
bool sub_145_158() {
    // 145: cmp
    conditional_code = greaterThan(vec2(reg_tmp5.zzzz), vec2(reg_tmp5.xxxx));
    // 146: mul
    reg_tmp8 = mul_safe(reg_tmp13.yyzw, reg_tmp6.xxxy);
    // 147: add
    reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
    // 148: ifc
    if (conditional_code.x) {
        sub_149_152();
    } else {
        sub_152_157();
    }
    // 157: nop
    return false;
}
bool sub_149_152() {
    // 149: add
    reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
    // 150: add
    reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
    // 151: add
    reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
    return false;
}
bool sub_152_157() {
    // 152: mul
    reg_tmp8 = mul_safe(reg_tmp13.zwwy, reg_tmp6.xxxy);
    // 153: add
    reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
    // 154: add
    reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
    // 155: add
    reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
    // 156: add
    reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
    return false;
}
bool sub_159_172() {
    // 159: ifc
    if (conditional_code.y) {
        sub_160_165();
    } else {
        sub_165_171();
    }
    // 171: nop
    return false;
}
bool sub_160_165() {
    // 160: mul
    reg_tmp8 = mul_safe(reg_tmp13.yywz, reg_tmp6.xxxy);
    // 161: add
    reg_tmp8.y = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).y;
    // 162: add
    reg_tmp9 = reg_tmp5.yyyy + -reg_tmp5.xxxx;
    // 163: add
    reg_tmp8.xzw = (reg_tmp8 + reg_tmp14.wwyx).xzw;
    // 164: add
    reg_tmp8.y = (reg_tmp9 + reg_tmp8).y;
    return false;
}
bool sub_165_171() {
    // 165: mul
    reg_tmp8 = mul_safe(reg_tmp13.zwwy, reg_tmp6.xxxy);
    // 166: add
    reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
    // 167: add
    reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
    // 168: add
    reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
    // 169: add
    reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
    // 170: mov
    reg_tmp8.w = (-reg_tmp8).w;
    return false;
}
bool sub_176_188() {
    // 176: mov
    reg_tmp0.y = (uniforms.f[7].wwww).y;
    // 177: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.xyyy));
    // 178: mov
    reg_tmp9.xyz = (uniforms.f[93].xxxx).xyz;
    // 179: mov
    reg_tmp9.w = (uniforms.f[21].wwww).w;
    // 180: ifc
    if (conditional_code.y) {
        sub_181_186();
    }
    // 186: call
    {
        sub_188_198();
    }
    // 187: max
    vs_out_attr3 = max(uniforms.f[93].xxxx, reg_tmp9);
    return false;
}
bool sub_181_186() {
    // 181: mul
    reg_tmp0 = mul_safe(uniforms.f[7].wwww, vs_in_reg3);
    // 182: ifu
    if (uniforms.b[7]) {
        sub_183_184();
    }
    // 184: mul
    reg_tmp9.xyz = (mul_safe(uniforms.f[20].wwww, reg_tmp0.xyzz)).xyz;
    // 185: mov
    reg_tmp8.x = (uniforms.f[93].yyyy).x;
    return false;
}
bool sub_183_184() {
    // 183: mul
    reg_tmp9.w = (mul_safe(reg_tmp9.wwww, reg_tmp0.wwww)).w;
    return false;
}
bool sub_188_198() {
    // 188: dp3
    reg_tmp1 = vec4(dot(vec3(uniforms.f[24]), vec3(reg_tmp14)));
    // 189: mov
    reg_tmp2 = uniforms.f[24].wwww;
    // 190: mad
    reg_tmp1 = fma_safe(reg_tmp1, reg_tmp2, reg_tmp2);
    // 191: mov
    reg_tmp3 = uniforms.f[22];
    // 192: add
    reg_tmp2 = uniforms.f[23] + -reg_tmp3;
    // 193: mad
    reg_tmp4 = fma_safe(reg_tmp2, reg_tmp1, reg_tmp3);
    // 194: ifu
    if (uniforms.b[6]) {
        sub_195_196();
    }
    // 196: mad
    reg_tmp9.xyz = (fma_safe(reg_tmp4, uniforms.f[21], reg_tmp9)).xyz;
    // 197: mov
    reg_tmp8.x = (uniforms.f[93].yyyy).x;
    return false;
}
bool sub_195_196() {
    // 195: mul
    reg_tmp4 = mul_safe(reg_tmp4, reg_tmp9.wwww);
    return false;
}
bool sub_198_226() {
    // 198: mov
    reg_tmp0.xy = (uniforms.f[10].xxxx).xy;
    // 199: ifu
    if (uniforms.b[9]) {
        sub_200_206();
    } else {
        sub_206_225();
    }
    // 225: nop
    return false;
}
bool sub_200_206() {
    // 200: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
    // 201: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 202: dp4
    reg_tmp3.x = dot(uniforms.f[11].xywz, reg_tmp6);
    // 203: dp4
    reg_tmp3.y = dot(uniforms.f[12].xywz, reg_tmp6);
    // 204: mov
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    // 205: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_206_225() {
    // 206: cmp
    conditional_code = equal(vec2(uniforms.f[95].xyyy), vec2(reg_tmp0.xyyy));
    // 207: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 208: ifc
    if (all(not(conditional_code))) {
        sub_209_215();
    } else {
        sub_215_224();
    }
    // 224: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_209_215() {
    // 209: mov
    reg_tmp6 = reg_tmp10;
    // 210: dp4
    reg_tmp3.x = dot(uniforms.f[11], reg_tmp6);
    // 211: dp4
    reg_tmp3.y = dot(uniforms.f[12], reg_tmp6);
    // 212: dp4
    reg_tmp3.z = dot(uniforms.f[13], reg_tmp6);
    // 213: mul
    reg_tmp0.xy = (mul_safe(uniforms.f[19].xyyy, reg_tmp3.zzzz)).xy;
    // 214: add
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_215_224() {
    // 215: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_216_220();
    } else {
        sub_220_223();
    }
    // 223: nop
    return false;
}
bool sub_216_220() {
    // 216: call
    {
        sub_226_233();
    }
    // 217: dp3
    reg_tmp3.x = dot(vec3(uniforms.f[11]), vec3(reg_tmp6));
    // 218: dp3
    reg_tmp3.y = dot(vec3(uniforms.f[12]), vec3(reg_tmp6));
    // 219: dp3
    reg_tmp3.z = dot(vec3(uniforms.f[13]), vec3(reg_tmp6));
    return false;
}
bool sub_220_223() {
    // 220: call
    {
        sub_233_237();
    }
    // 221: dp4
    reg_tmp3.x = dot(uniforms.f[11], reg_tmp6);
    // 222: dp4
    reg_tmp3.y = dot(uniforms.f[12], reg_tmp6);
    return false;
}
bool sub_226_233() {
    // 226: mov
    reg_tmp2 = -reg_tmp15;
    // 227: dp3
    reg_tmp2.w = dot(vec3(reg_tmp2), vec3(reg_tmp2));
    // 228: rsq
    reg_tmp2.w = rsq_safe(reg_tmp2.wwww.x);
    // 229: mul
    reg_tmp2 = mul_safe(reg_tmp2, reg_tmp2.wwww);
    // 230: dp3
    reg_tmp1 = vec4(dot(vec3(reg_tmp2), vec3(reg_tmp14)));
    // 231: add
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    // 232: mad
    reg_tmp6 = fma_safe(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_233_237() {
    // 233: mov
    reg_tmp1.xy = (uniforms.f[94].zzzz).xy;
    // 234: mov
    reg_tmp1.zw = (uniforms.f[93].xxxx).zw;
    // 235: mad
    reg_tmp6 = fma_safe(reg_tmp14, reg_tmp1, reg_tmp1);
    // 236: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_284_4096() {
    // 284: call
    {
        sub_7_83();
    }
    // 285: call
    {
        sub_176_188();
    }
    // 286: call
    {
        sub_198_226();
    }
    // 287: end
    return true;
}
// reference: 8263781138F5F8C8, 70D24D55BDEC0B06
// shader: 8DD9, 6CF3F3B70E23AA85

layout(triangles) in;
layout(triangle_strip, max_vertices = 3) out;

out vec4 primary_color;
out vec2 texcoord0;
out vec2 texcoord1;
out vec2 texcoord2;
out float texcoord0_w;
out vec4 normquat;
out vec3 view;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

 in vec4 vs_out_attr0[];
 in vec4 vs_out_attr1[];
 in vec4 vs_out_attr2[];
 in vec4 vs_out_attr3[];
 in vec4 vs_out_attr4[];

struct Vertex {
    vec4 attributes[5];
};

vec4 GetVertexQuaternion(Vertex vtx) {
    return vec4(vtx.attributes[1].x, vtx.attributes[1].y, vtx.attributes[1].z, vtx.attributes[1].w);
}

void EmitVtx(Vertex vtx, bool quats_opposite) {
    vec4 vtx_pos = vec4(vtx.attributes[0].x, vtx.attributes[0].y, vtx.attributes[0].z, vtx.attributes[0].w);
    gl_Position = vtx_pos;
#if !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)
    gl_ClipDistance[0] = -vtx_pos.z;
    gl_ClipDistance[1] = dot(clip_coef, vtx_pos);
#endif // !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)

    vec4 vtx_quat = GetVertexQuaternion(vtx);
    normquat = mix(vtx_quat, -vtx_quat, bvec4(quats_opposite));

    vec4 vtx_color = vec4(vtx.attributes[3].x, vtx.attributes[3].y, vtx.attributes[3].z, vtx.attributes[3].w);
    primary_color = min(abs(vtx_color), vec4(1.0));

    texcoord0 = vec2(vtx.attributes[4].x, vtx.attributes[4].y);
    texcoord1 = vec2(0.0, 0.0);

    texcoord0_w = vtx.attributes[4].z;
    view = vec3(vtx.attributes[2].x, vtx.attributes[2].y, vtx.attributes[2].z);

    texcoord2 = vec2(0.0, 0.0);

    EmitVertex();
}

bool AreQuaternionsOpposite(vec4 qa, vec4 qb) {
    return (dot(qa, qb) < 0.0);
}

void EmitPrim(Vertex vtx0, Vertex vtx1, Vertex vtx2) {
    EmitVtx(vtx0, false);
    EmitVtx(vtx1, AreQuaternionsOpposite(GetVertexQuaternion(vtx0), GetVertexQuaternion(vtx1)));
    EmitVtx(vtx2, AreQuaternionsOpposite(GetVertexQuaternion(vtx0), GetVertexQuaternion(vtx2)));
    EndPrimitive();
}

void main() {
    Vertex prim_buffer[3];
    prim_buffer[0].attributes = vec4[5](vs_out_attr0[0], vs_out_attr1[0], vs_out_attr2[0], vs_out_attr3[0], vs_out_attr4[0]);
    prim_buffer[1].attributes = vec4[5](vs_out_attr0[1], vs_out_attr1[1], vs_out_attr2[1], vs_out_attr3[1], vs_out_attr4[1]);
    prim_buffer[2].attributes = vec4[5](vs_out_attr0[2], vs_out_attr1[2], vs_out_attr2[2], vs_out_attr3[2], vs_out_attr4[2]);
    EmitPrim(prim_buffer[0], prim_buffer[1], prim_buffer[2]);
}
// reference: CD8210802464D9AE, 6CF3F3B70E23AA85
// shader: 8B30, 0E016FFAD6D3532B

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(view)), 0.0))) * light_src[0].specular_0) + ((lut_scale_d1 * LookupLightingLUTUnsigned(1, max(dot(normal, normalize(view)), 0.0))) * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1 * 2.0, alpha_output_1 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor0.aaa) * (secondary_fragment_color.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 8945BF5110070BC2, 0E016FFAD6D3532B
// program: 70D24D55BDEC0B06, 6CF3F3B70E23AA85, 0E016FFAD6D3532B
// reference: 0983AFBEE34C598F, 70D24D55BDEC0B06
// shader: 8B31, DEFAC6F185DB6EB9

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 7) in vec4 vs_in_reg7;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define fma_safe(x, y, z) fma(x, y, z)
#define mul_safe(x, y) (x * y)
#define rcp_safe(x) (1.0f / x)
#define rsq_safe(x) inversesqrt(x)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_7_83();
bool sub_15_25();
bool sub_25_34();
bool sub_35_47();
bool sub_47_72();
bool sub_48_66();
bool sub_66_71();
bool sub_81_82();
bool sub_83_100();
bool sub_100_176();
bool sub_139_159();
bool sub_140_145();
bool sub_145_158();
bool sub_149_152();
bool sub_152_157();
bool sub_159_172();
bool sub_160_165();
bool sub_165_171();
bool sub_176_186();
bool sub_181_185();
bool sub_182_183();
bool sub_186_214();
bool sub_188_194();
bool sub_194_213();
bool sub_197_203();
bool sub_203_212();
bool sub_204_208();
bool sub_208_211();
bool sub_214_221();
bool sub_221_225();
bool sub_272_4096();

bool exec_shader() {
    sub_272_4096();
    return true;
}

bool sub_7_83() {
    // 7: mul
    reg_tmp15.xyz = (mul_safe(uniforms.f[7].xxxx, vs_in_reg0)).xyz;
    // 8: mul
    reg_tmp14.xyz = (mul_safe(uniforms.f[7].yyyy, vs_in_reg1)).xyz;
    // 9: mul
    reg_tmp13.xyz = (mul_safe(uniforms.f[7].zzzz, vs_in_reg2)).xyz;
    // 10: add
    reg_tmp15.xyz = (uniforms.f[6] + reg_tmp15).xyz;
    // 11: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 12: mov
    reg_tmp0 = uniforms.f[7];
    // 13: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.yzzz));
    // 14: ifu
    if (uniforms.b[2]) {
        sub_15_25();
    } else {
        sub_25_34();
    }
    // 34: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_35_47();
    } else {
        sub_47_72();
    }
    // 72: mov
    vs_out_attr2 = -reg_tmp15;
    // 73: dp4
    reg_tmp0.x = dot(uniforms.f[86], reg_tmp15);
    // 74: dp4
    reg_tmp0.y = dot(uniforms.f[87], reg_tmp15);
    // 75: dp4
    reg_tmp0.z = dot(uniforms.f[88], reg_tmp15);
    // 76: dp4
    reg_tmp0.w = dot(uniforms.f[89], reg_tmp15);
    // 77: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 78: mul
    reg_tmp1.y = (mul_safe(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
    // 79: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 80: ifc
    if (all(conditional_code)) {
        sub_81_82();
    }
    // 82: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_15_25() {
    // 15: mul
    reg_tmp1.x = (mul_safe(uniforms.f[93].wwww, vs_in_reg7.xxxx)).x;
    // 16: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 17: dp4
    reg_tmp7.x = dot(uniforms.f[25 + address_registers.x], reg_tmp15);
    // 18: dp4
    reg_tmp7.y = dot(uniforms.f[26 + address_registers.x], reg_tmp15);
    // 19: dp4
    reg_tmp7.z = dot(uniforms.f[27 + address_registers.x], reg_tmp15);
    // 20: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 21: dp4
    reg_tmp10.x = dot(uniforms.f[0], reg_tmp7);
    // 22: dp4
    reg_tmp10.y = dot(uniforms.f[1], reg_tmp7);
    // 23: dp4
    reg_tmp10.z = dot(uniforms.f[2], reg_tmp7);
    // 24: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_25_34() {
    // 25: mova
    address_registers.x = (ivec2(uniforms.f[93].xxxx)).x;
    // 26: dp4
    reg_tmp7.x = dot(uniforms.f[25], reg_tmp15);
    // 27: dp4
    reg_tmp7.y = dot(uniforms.f[26], reg_tmp15);
    // 28: dp4
    reg_tmp7.z = dot(uniforms.f[27], reg_tmp15);
    // 29: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 30: dp4
    reg_tmp10.x = dot(uniforms.f[0], reg_tmp7);
    // 31: dp4
    reg_tmp10.y = dot(uniforms.f[1], reg_tmp7);
    // 32: dp4
    reg_tmp10.z = dot(uniforms.f[2], reg_tmp7);
    // 33: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_35_47() {
    // 35: dp3
    reg_tmp12.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp14));
    // 36: dp3
    reg_tmp12.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp14));
    // 37: dp3
    reg_tmp12.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp14));
    // 38: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 39: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 40: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 41: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 42: dp3
    reg_tmp14.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp12));
    // 43: dp3
    reg_tmp14.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp12));
    // 44: dp3
    reg_tmp14.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp12));
    // 45: call
    {
        sub_83_100();
    }
    // 46: nop
    return false;
}
bool sub_47_72() {
    // 47: ifc
    if (all(conditional_code)) {
        sub_48_66();
    } else {
        sub_66_71();
    }
    // 71: nop
    return false;
}
bool sub_48_66() {
    // 48: dp3
    reg_tmp12.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp14));
    // 49: dp3
    reg_tmp12.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp14));
    // 50: dp3
    reg_tmp12.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp14));
    // 51: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp13));
    // 52: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp13));
    // 53: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp13));
    // 54: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 55: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 56: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 57: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 58: dp3
    reg_tmp14.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp12));
    // 59: dp3
    reg_tmp14.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp12));
    // 60: dp3
    reg_tmp14.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp12));
    // 61: dp3
    reg_tmp13.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp11));
    // 62: dp3
    reg_tmp13.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp11));
    // 63: dp3
    reg_tmp13.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp11));
    // 64: call
    {
        sub_100_176();
    }
    // 65: nop
    return false;
}
bool sub_66_71() {
    // 66: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 67: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 68: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 69: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 70: mov
    vs_out_attr1 = uniforms.f[93].xxxx;
    return false;
}
bool sub_81_82() {
    // 81: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_83_100() {
    uint jmp_to = 83u;
    while (true) {
        switch (jmp_to) {
        case 83u: {
            // 83: dp3
            reg_tmp6.x = dot(vec3(reg_tmp14), vec3(reg_tmp14));
            // 84: dp3
            reg_tmp7.x = dot(vec3(reg_tmp12), vec3(reg_tmp12));
            // 85: rsq
            reg_tmp6.x = rsq_safe(reg_tmp6.xxxx.x);
            // 86: rsq
            reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
            // 87: mul
            reg_tmp14.xyz = (mul_safe(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 88: mul
            reg_tmp12.xyz = (mul_safe(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 89: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 90: jmpu
            if (!uniforms.b[3]) {
                { jmp_to = 99u; break; }
            }
            // 91: add
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            // 92: mul
            reg_tmp4 = mul_safe(uniforms.f[94].zzzz, reg_tmp4);
            // 93: cmp
            conditional_code = greaterThanEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp4.xxxx));
            // 94: rsq
            reg_tmp4 = vec4(rsq_safe(reg_tmp4.xxxx.x));
            // 95: mul
            reg_tmp5 = mul_safe(uniforms.f[94].zzzz, reg_tmp14);
            // 96: jmpc
            if (conditional_code.x) {
                { jmp_to = 99u; break; }
            }
            // 97: rcp
            reg_tmp0.z = rcp_safe(reg_tmp4.xxxx.x);
            // 98: mul
            reg_tmp0.xy = (mul_safe(reg_tmp5, reg_tmp4)).xy;
        }
        case 99u: {
            // 99: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_100_176() {
    uint jmp_to = 100u;
    while (true) {
        switch (jmp_to) {
        case 100u: {
            // 100: dp3
            reg_tmp6.x = dot(vec3(reg_tmp14), vec3(reg_tmp14));
            // 101: dp3
            reg_tmp7.x = dot(vec3(reg_tmp12), vec3(reg_tmp12));
            // 102: rsq
            reg_tmp6.x = rsq_safe(reg_tmp6.xxxx.x);
            // 103: rsq
            reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
            // 104: mul
            reg_tmp14.xyz = (mul_safe(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 105: mul
            reg_tmp12.xyz = (mul_safe(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 106: mul
            reg_tmp13.xyz = (mul_safe(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            // 107: mul
            reg_tmp11.xyz = (mul_safe(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            // 108: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 109: jmpu
            if (!uniforms.b[3]) {
                { jmp_to = 175u; break; }
            }
            // 110: mul
            reg_tmp13.xyz = (mul_safe(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            // 111: mul
            reg_tmp11.xyz = (mul_safe(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            // 112: mul
            reg_tmp5 = mul_safe(reg_tmp14.yzxx, reg_tmp13.zxyy);
            // 113: mad
            reg_tmp5 = fma_safe(-reg_tmp13.yzxx, reg_tmp14.zxyy, reg_tmp5);
            // 114: dp3
            reg_tmp5.w = dot(vec3(reg_tmp5), vec3(reg_tmp5));
            // 115: rsq
            reg_tmp5.w = rsq_safe(reg_tmp5.wwww.x);
            // 116: mul
            reg_tmp5 = mul_safe(reg_tmp5, reg_tmp5.wwww);
            // 117: add
            reg_tmp6.w = (reg_tmp14.zzzz + reg_tmp5.yyyy).w;
            // 118: mul
            reg_tmp13 = mul_safe(reg_tmp5.yzxx, reg_tmp14.zxyy);
            // 119: mad
            reg_tmp13 = fma_safe(-reg_tmp14.yzxx, reg_tmp5.zxyy, reg_tmp13);
            // 120: add
            reg_tmp6.w = (reg_tmp13.xxxx + reg_tmp6).w;
            // 121: mov
            reg_tmp13.w = (reg_tmp5.zzzz).w;
            // 122: mov
            reg_tmp5.z = (reg_tmp13.xxxx).z;
            // 123: add
            reg_tmp6.w = (uniforms.f[93].yyyy + reg_tmp6).w;
            // 124: mov
            reg_tmp14.w = (reg_tmp5.xxxx).w;
            // 125: mov
            reg_tmp5.x = (reg_tmp14.zzzz).x;
            // 126: cmp
            conditional_code = lessThan(vec2(uniforms.f[94].yyyy), vec2(reg_tmp6.wwww));
            // 127: mov
            reg_tmp6.x = (uniforms.f[93].yyyy).x;
            // 128: mov
            reg_tmp6.y = (-uniforms.f[93].yyyy).y;
            // 129: jmpc
            if (!conditional_code.x) {
                { jmp_to = 137u; break; }
            }
            // 130: add
            reg_tmp7.xz = (reg_tmp13.wwyy + -reg_tmp14.yyww).xz;
            // 131: add
            reg_tmp7.y = (reg_tmp14.xxxx + -reg_tmp13.zzzz).y;
            // 132: mov
            reg_tmp7.w = (reg_tmp6).w;
            // 133: dp4
            reg_tmp6 = vec4(dot(reg_tmp7, reg_tmp7));
            // 134: rsq
            reg_tmp6 = vec4(rsq_safe(reg_tmp6.xxxx.x));
            // 135: mul
            reg_tmp0 = mul_safe(reg_tmp7, reg_tmp6);
            // 136: jmpu
            if (uniforms.b[0]) {
                { jmp_to = 175u; break; }
            }
        }
        case 137u: {
            // 137: cmp
            conditional_code = greaterThan(vec2(reg_tmp5.zyyy), vec2(reg_tmp5.yxxx));
            // 138: ifc
            if (conditional_code.x) {
                sub_139_159();
            } else {
                sub_159_172();
            }
            // 172: dp4
            reg_tmp6 = vec4(dot(reg_tmp8, reg_tmp8));
            // 173: rsq
            reg_tmp6 = vec4(rsq_safe(reg_tmp6.xxxx.x));
            // 174: mul
            reg_tmp0 = mul_safe(reg_tmp8, reg_tmp6);
        }
        case 175u: {
            // 175: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_139_159() {
    // 139: ifc
    if (conditional_code.y) {
        sub_140_145();
    } else {
        sub_145_158();
    }
    // 158: mov
    reg_tmp8.w = (-reg_tmp8).w;
    return false;
}
bool sub_140_145() {
    // 140: mul
    reg_tmp8 = mul_safe(reg_tmp13.yyzw, reg_tmp6.xxxy);
    // 141: add
    reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
    // 142: add
    reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
    // 143: add
    reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
    // 144: add
    reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
    return false;
}
bool sub_145_158() {
    // 145: cmp
    conditional_code = greaterThan(vec2(reg_tmp5.zzzz), vec2(reg_tmp5.xxxx));
    // 146: mul
    reg_tmp8 = mul_safe(reg_tmp13.yyzw, reg_tmp6.xxxy);
    // 147: add
    reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
    // 148: ifc
    if (conditional_code.x) {
        sub_149_152();
    } else {
        sub_152_157();
    }
    // 157: nop
    return false;
}
bool sub_149_152() {
    // 149: add
    reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
    // 150: add
    reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
    // 151: add
    reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
    return false;
}
bool sub_152_157() {
    // 152: mul
    reg_tmp8 = mul_safe(reg_tmp13.zwwy, reg_tmp6.xxxy);
    // 153: add
    reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
    // 154: add
    reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
    // 155: add
    reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
    // 156: add
    reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
    return false;
}
bool sub_159_172() {
    // 159: ifc
    if (conditional_code.y) {
        sub_160_165();
    } else {
        sub_165_171();
    }
    // 171: nop
    return false;
}
bool sub_160_165() {
    // 160: mul
    reg_tmp8 = mul_safe(reg_tmp13.yywz, reg_tmp6.xxxy);
    // 161: add
    reg_tmp8.y = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).y;
    // 162: add
    reg_tmp9 = reg_tmp5.yyyy + -reg_tmp5.xxxx;
    // 163: add
    reg_tmp8.xzw = (reg_tmp8 + reg_tmp14.wwyx).xzw;
    // 164: add
    reg_tmp8.y = (reg_tmp9 + reg_tmp8).y;
    return false;
}
bool sub_165_171() {
    // 165: mul
    reg_tmp8 = mul_safe(reg_tmp13.zwwy, reg_tmp6.xxxy);
    // 166: add
    reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
    // 167: add
    reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
    // 168: add
    reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
    // 169: add
    reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
    // 170: mov
    reg_tmp8.w = (-reg_tmp8).w;
    return false;
}
bool sub_176_186() {
    // 176: mov
    reg_tmp0.y = (uniforms.f[7].wwww).y;
    // 177: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.xyyy));
    // 178: mov
    reg_tmp9 = uniforms.f[21];
    // 179: mul
    reg_tmp0 = mul_safe(uniforms.f[7].wwww, vs_in_reg3);
    // 180: ifc
    if (conditional_code.y) {
        sub_181_185();
    }
    // 185: max
    vs_out_attr3 = max(uniforms.f[93].xxxx, reg_tmp9);
    return false;
}
bool sub_181_185() {
    // 181: ifu
    if (uniforms.b[7]) {
        sub_182_183();
    }
    // 183: mul
    reg_tmp9.xyz = (mul_safe(uniforms.f[20].wwww, reg_tmp0.xyzz)).xyz;
    // 184: mov
    reg_tmp8.x = (uniforms.f[93].yyyy).x;
    return false;
}
bool sub_182_183() {
    // 182: mul
    reg_tmp9.w = (mul_safe(reg_tmp9.wwww, reg_tmp0.wwww)).w;
    return false;
}
bool sub_186_214() {
    // 186: mov
    reg_tmp0.xy = (uniforms.f[10].xxxx).xy;
    // 187: ifu
    if (uniforms.b[9]) {
        sub_188_194();
    } else {
        sub_194_213();
    }
    // 213: nop
    return false;
}
bool sub_188_194() {
    // 188: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
    // 189: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 190: dp4
    reg_tmp3.x = dot(uniforms.f[11].xywz, reg_tmp6);
    // 191: dp4
    reg_tmp3.y = dot(uniforms.f[12].xywz, reg_tmp6);
    // 192: mov
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    // 193: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_194_213() {
    // 194: cmp
    conditional_code = equal(vec2(uniforms.f[95].xyyy), vec2(reg_tmp0.xyyy));
    // 195: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 196: ifc
    if (all(not(conditional_code))) {
        sub_197_203();
    } else {
        sub_203_212();
    }
    // 212: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_197_203() {
    // 197: mov
    reg_tmp6 = reg_tmp10;
    // 198: dp4
    reg_tmp3.x = dot(uniforms.f[11], reg_tmp6);
    // 199: dp4
    reg_tmp3.y = dot(uniforms.f[12], reg_tmp6);
    // 200: dp4
    reg_tmp3.z = dot(uniforms.f[13], reg_tmp6);
    // 201: mul
    reg_tmp0.xy = (mul_safe(uniforms.f[19].xyyy, reg_tmp3.zzzz)).xy;
    // 202: add
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_203_212() {
    // 203: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_204_208();
    } else {
        sub_208_211();
    }
    // 211: nop
    return false;
}
bool sub_204_208() {
    // 204: call
    {
        sub_214_221();
    }
    // 205: dp3
    reg_tmp3.x = dot(vec3(uniforms.f[11]), vec3(reg_tmp6));
    // 206: dp3
    reg_tmp3.y = dot(vec3(uniforms.f[12]), vec3(reg_tmp6));
    // 207: dp3
    reg_tmp3.z = dot(vec3(uniforms.f[13]), vec3(reg_tmp6));
    return false;
}
bool sub_208_211() {
    // 208: call
    {
        sub_221_225();
    }
    // 209: dp4
    reg_tmp3.x = dot(uniforms.f[11], reg_tmp6);
    // 210: dp4
    reg_tmp3.y = dot(uniforms.f[12], reg_tmp6);
    return false;
}
bool sub_214_221() {
    // 214: mov
    reg_tmp2 = -reg_tmp15;
    // 215: dp3
    reg_tmp2.w = dot(vec3(reg_tmp2), vec3(reg_tmp2));
    // 216: rsq
    reg_tmp2.w = rsq_safe(reg_tmp2.wwww.x);
    // 217: mul
    reg_tmp2 = mul_safe(reg_tmp2, reg_tmp2.wwww);
    // 218: dp3
    reg_tmp1 = vec4(dot(vec3(reg_tmp2), vec3(reg_tmp14)));
    // 219: add
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    // 220: mad
    reg_tmp6 = fma_safe(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_221_225() {
    // 221: mov
    reg_tmp1.xy = (uniforms.f[94].zzzz).xy;
    // 222: mov
    reg_tmp1.zw = (uniforms.f[93].xxxx).zw;
    // 223: mad
    reg_tmp6 = fma_safe(reg_tmp14, reg_tmp1, reg_tmp1);
    // 224: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_272_4096() {
    // 272: call
    {
        sub_7_83();
    }
    // 273: call
    {
        sub_176_186();
    }
    // 274: call
    {
        sub_186_214();
    }
    // 275: end
    return true;
}
// reference: DCE2FF3963112407, DEFAC6F185DB6EB9
// shader: 8B30, 4276C3E7186D8D1B

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0 * 2.0, alpha_output_0 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 8B3F3A8941904923, 4276C3E7186D8D1B
// program: DEFAC6F185DB6EB9, 6CF3F3B70E23AA85, 4276C3E7186D8D1B
// shader: 8B31, 46F6395BEBA5C2A1

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define fma_safe(x, y, z) fma(x, y, z)
#define mul_safe(x, y) (x * y)
#define rcp_safe(x) (1.0f / x)
#define rsq_safe(x) inversesqrt(x)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_7_12();
bool sub_12_21();
bool sub_21_34();
bool sub_34_218();
bool sub_40_146();
bool sub_47_76();
bool sub_58_62();
bool sub_76_135();
bool sub_77_109();
bool sub_88_92();
bool sub_109_134();
bool sub_120_124();
bool sub_144_145();
bool sub_146_217();
bool sub_149_159();
bool sub_159_168();
bool sub_169_181();
bool sub_181_206();
bool sub_182_200();
bool sub_200_205();
bool sub_215_216();
bool sub_218_235();
bool sub_235_311();
bool sub_274_294();
bool sub_275_280();
bool sub_280_293();
bool sub_284_287();
bool sub_287_292();
bool sub_294_307();
bool sub_295_300();
bool sub_300_306();
bool sub_311_323();
bool sub_316_321();
bool sub_318_319();
bool sub_323_333();
bool sub_330_331();
bool sub_333_360();
bool sub_335_340();
bool sub_340_359();
bool sub_343_349();
bool sub_349_358();
bool sub_350_354();
bool sub_354_357();
bool sub_360_368();
bool sub_362_363();
bool sub_363_367();
bool sub_364_365();
bool sub_365_366();
bool sub_368_375();
bool sub_375_379();
bool sub_379_403();
bool sub_381_385();
bool sub_385_402();
bool sub_386_400();
bool sub_389_396();
bool sub_396_399();
bool sub_400_401();
bool sub_419_4096();

bool exec_shader() {
    sub_419_4096();
    return true;
}

bool sub_7_12() {
    // 7: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 8: dp4
    reg_tmp3.x = dot(uniforms.f[25 + address_registers.x], reg_tmp15);
    // 9: dp4
    reg_tmp3.y = dot(uniforms.f[26 + address_registers.x], reg_tmp15);
    // 10: dp4
    reg_tmp3.z = dot(uniforms.f[27 + address_registers.x], reg_tmp15);
    // 11: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    return false;
}
bool sub_12_21() {
    // 12: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 13: dp4
    reg_tmp3.x = dot(uniforms.f[25 + address_registers.x], reg_tmp15);
    // 14: dp4
    reg_tmp3.y = dot(uniforms.f[26 + address_registers.x], reg_tmp15);
    // 15: dp4
    reg_tmp3.z = dot(uniforms.f[27 + address_registers.x], reg_tmp15);
    // 16: dp3
    reg_tmp4.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp14));
    // 17: dp3
    reg_tmp4.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp14));
    // 18: dp3
    reg_tmp4.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp14));
    // 19: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 20: mad
    reg_tmp12 = fma_safe(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_21_34() {
    // 21: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 22: dp4
    reg_tmp3.x = dot(uniforms.f[25 + address_registers.x], reg_tmp15);
    // 23: dp4
    reg_tmp3.y = dot(uniforms.f[26 + address_registers.x], reg_tmp15);
    // 24: dp4
    reg_tmp3.z = dot(uniforms.f[27 + address_registers.x], reg_tmp15);
    // 25: dp3
    reg_tmp4.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp14));
    // 26: dp3
    reg_tmp4.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp14));
    // 27: dp3
    reg_tmp4.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp14));
    // 28: dp3
    reg_tmp5.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp13));
    // 29: dp3
    reg_tmp5.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp13));
    // 30: dp3
    reg_tmp5.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp13));
    // 31: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 32: mad
    reg_tmp12 = fma_safe(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    // 33: mad
    reg_tmp11 = fma_safe(reg_tmp1.wwww, reg_tmp5, reg_tmp11);
    return false;
}
bool sub_34_218() {
    // 34: mul
    reg_tmp15.xyz = (mul_safe(uniforms.f[7].xxxx, vs_in_reg0)).xyz;
    // 35: mul
    reg_tmp14.xyz = (mul_safe(uniforms.f[7].yyyy, vs_in_reg1)).xyz;
    // 36: mul
    reg_tmp13.xyz = (mul_safe(uniforms.f[7].zzzz, vs_in_reg2)).xyz;
    // 37: add
    reg_tmp15.xyz = (uniforms.f[6] + reg_tmp15).xyz;
    // 38: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 39: ifu
    if (uniforms.b[1]) {
        sub_40_146();
    } else {
        sub_146_217();
    }
    // 217: nop
    return false;
}
bool sub_40_146() {
    // 40: mov
    reg_tmp0 = uniforms.f[7];
    // 41: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.yzzz));
    // 42: mov
    reg_tmp7 = uniforms.f[93].xxxx;
    // 43: mov
    reg_tmp12 = uniforms.f[93].xxxx;
    // 44: mov
    reg_tmp11 = uniforms.f[93].xxxx;
    // 45: mul
    reg_tmp2 = mul_safe(uniforms.f[93].wwww, vs_in_reg7);
    // 46: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_47_76();
    } else {
        sub_76_135();
    }
    // 135: mov
    vs_out_attr2 = -reg_tmp15;
    // 136: dp4
    reg_tmp0.x = dot(uniforms.f[86], reg_tmp15);
    // 137: dp4
    reg_tmp0.y = dot(uniforms.f[87], reg_tmp15);
    // 138: dp4
    reg_tmp0.z = dot(uniforms.f[88], reg_tmp15);
    // 139: dp4
    reg_tmp0.w = dot(uniforms.f[89], reg_tmp15);
    // 140: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 141: mul
    reg_tmp1.y = (mul_safe(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
    // 142: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 143: ifc
    if (all(conditional_code)) {
        sub_144_145();
    }
    // 145: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_47_76() {
    // 47: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 48: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 49: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 50: call
    {
        sub_12_21();
    }
    // 51: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 52: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 53: call
    {
        sub_12_21();
    }
    // 54: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 55: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 56: callc
    if (conditional_code.x) {
        sub_12_21();
    }
    // 57: ifu
    if (uniforms.b[8]) {
        sub_58_62();
    }
    // 62: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 63: dp4
    reg_tmp10.x = dot(uniforms.f[0], reg_tmp7);
    // 64: dp4
    reg_tmp10.y = dot(uniforms.f[1], reg_tmp7);
    // 65: dp4
    reg_tmp10.z = dot(uniforms.f[2], reg_tmp7);
    // 66: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 67: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 68: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 69: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 70: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 71: dp3
    reg_tmp14.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp12));
    // 72: dp3
    reg_tmp14.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp12));
    // 73: dp3
    reg_tmp14.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp12));
    // 74: call
    {
        sub_218_235();
    }
    // 75: nop
    return false;
}
bool sub_58_62() {
    // 58: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 59: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 60: callc
    if (conditional_code.y) {
        sub_12_21();
    }
    // 61: nop
    return false;
}
bool sub_76_135() {
    // 76: ifc
    if (all(conditional_code)) {
        sub_77_109();
    } else {
        sub_109_134();
    }
    // 134: nop
    return false;
}
bool sub_77_109() {
    // 77: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 78: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 79: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 80: call
    {
        sub_21_34();
    }
    // 81: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 82: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 83: call
    {
        sub_21_34();
    }
    // 84: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 85: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 86: callc
    if (conditional_code.x) {
        sub_21_34();
    }
    // 87: ifu
    if (uniforms.b[8]) {
        sub_88_92();
    }
    // 92: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 93: dp4
    reg_tmp10.x = dot(uniforms.f[0], reg_tmp7);
    // 94: dp4
    reg_tmp10.y = dot(uniforms.f[1], reg_tmp7);
    // 95: dp4
    reg_tmp10.z = dot(uniforms.f[2], reg_tmp7);
    // 96: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 97: dp3
    reg_tmp13.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp11));
    // 98: dp3
    reg_tmp13.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp11));
    // 99: dp3
    reg_tmp13.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp11));
    // 100: dp3
    reg_tmp14.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp12));
    // 101: dp3
    reg_tmp14.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp12));
    // 102: dp3
    reg_tmp14.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp12));
    // 103: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 104: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 105: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 106: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 107: call
    {
        sub_235_311();
    }
    // 108: nop
    return false;
}
bool sub_88_92() {
    // 88: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 89: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 90: callc
    if (conditional_code.y) {
        sub_21_34();
    }
    // 91: nop
    return false;
}
bool sub_109_134() {
    // 109: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 110: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 111: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 112: call
    {
        sub_7_12();
    }
    // 113: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 114: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 115: call
    {
        sub_7_12();
    }
    // 116: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 117: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 118: callc
    if (conditional_code.x) {
        sub_7_12();
    }
    // 119: ifu
    if (uniforms.b[8]) {
        sub_120_124();
    }
    // 124: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 125: dp4
    reg_tmp10.x = dot(uniforms.f[0], reg_tmp7);
    // 126: dp4
    reg_tmp10.y = dot(uniforms.f[1], reg_tmp7);
    // 127: dp4
    reg_tmp10.z = dot(uniforms.f[2], reg_tmp7);
    // 128: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 129: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 130: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 131: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 132: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 133: mov
    vs_out_attr1 = uniforms.f[93].xxxx;
    return false;
}
bool sub_120_124() {
    // 120: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 121: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 122: callc
    if (conditional_code.y) {
        sub_7_12();
    }
    // 123: nop
    return false;
}
bool sub_144_145() {
    // 144: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_146_217() {
    // 146: mov
    reg_tmp0 = uniforms.f[7];
    // 147: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.yzzz));
    // 148: ifu
    if (uniforms.b[2]) {
        sub_149_159();
    } else {
        sub_159_168();
    }
    // 168: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_169_181();
    } else {
        sub_181_206();
    }
    // 206: mov
    vs_out_attr2 = -reg_tmp15;
    // 207: dp4
    reg_tmp0.x = dot(uniforms.f[86], reg_tmp15);
    // 208: dp4
    reg_tmp0.y = dot(uniforms.f[87], reg_tmp15);
    // 209: dp4
    reg_tmp0.z = dot(uniforms.f[88], reg_tmp15);
    // 210: dp4
    reg_tmp0.w = dot(uniforms.f[89], reg_tmp15);
    // 211: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 212: mul
    reg_tmp1.y = (mul_safe(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
    // 213: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 214: ifc
    if (all(conditional_code)) {
        sub_215_216();
    }
    // 216: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_149_159() {
    // 149: mul
    reg_tmp1.x = (mul_safe(uniforms.f[93].wwww, vs_in_reg7.xxxx)).x;
    // 150: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 151: dp4
    reg_tmp7.x = dot(uniforms.f[25 + address_registers.x], reg_tmp15);
    // 152: dp4
    reg_tmp7.y = dot(uniforms.f[26 + address_registers.x], reg_tmp15);
    // 153: dp4
    reg_tmp7.z = dot(uniforms.f[27 + address_registers.x], reg_tmp15);
    // 154: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 155: dp4
    reg_tmp10.x = dot(uniforms.f[0], reg_tmp7);
    // 156: dp4
    reg_tmp10.y = dot(uniforms.f[1], reg_tmp7);
    // 157: dp4
    reg_tmp10.z = dot(uniforms.f[2], reg_tmp7);
    // 158: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_159_168() {
    // 159: mova
    address_registers.x = (ivec2(uniforms.f[93].xxxx)).x;
    // 160: dp4
    reg_tmp7.x = dot(uniforms.f[25], reg_tmp15);
    // 161: dp4
    reg_tmp7.y = dot(uniforms.f[26], reg_tmp15);
    // 162: dp4
    reg_tmp7.z = dot(uniforms.f[27], reg_tmp15);
    // 163: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 164: dp4
    reg_tmp10.x = dot(uniforms.f[0], reg_tmp7);
    // 165: dp4
    reg_tmp10.y = dot(uniforms.f[1], reg_tmp7);
    // 166: dp4
    reg_tmp10.z = dot(uniforms.f[2], reg_tmp7);
    // 167: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_169_181() {
    // 169: dp3
    reg_tmp12.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp14));
    // 170: dp3
    reg_tmp12.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp14));
    // 171: dp3
    reg_tmp12.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp14));
    // 172: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 173: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 174: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 175: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 176: dp3
    reg_tmp14.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp12));
    // 177: dp3
    reg_tmp14.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp12));
    // 178: dp3
    reg_tmp14.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp12));
    // 179: call
    {
        sub_218_235();
    }
    // 180: nop
    return false;
}
bool sub_181_206() {
    // 181: ifc
    if (all(conditional_code)) {
        sub_182_200();
    } else {
        sub_200_205();
    }
    // 205: nop
    return false;
}
bool sub_182_200() {
    // 182: dp3
    reg_tmp12.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp14));
    // 183: dp3
    reg_tmp12.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp14));
    // 184: dp3
    reg_tmp12.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp14));
    // 185: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp13));
    // 186: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp13));
    // 187: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp13));
    // 188: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 189: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 190: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 191: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 192: dp3
    reg_tmp14.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp12));
    // 193: dp3
    reg_tmp14.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp12));
    // 194: dp3
    reg_tmp14.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp12));
    // 195: dp3
    reg_tmp13.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp11));
    // 196: dp3
    reg_tmp13.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp11));
    // 197: dp3
    reg_tmp13.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp11));
    // 198: call
    {
        sub_235_311();
    }
    // 199: nop
    return false;
}
bool sub_200_205() {
    // 200: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 201: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 202: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 203: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 204: mov
    vs_out_attr1 = uniforms.f[93].xxxx;
    return false;
}
bool sub_215_216() {
    // 215: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_218_235() {
    uint jmp_to = 218u;
    while (true) {
        switch (jmp_to) {
        case 218u: {
            // 218: dp3
            reg_tmp6.x = dot(vec3(reg_tmp14), vec3(reg_tmp14));
            // 219: dp3
            reg_tmp7.x = dot(vec3(reg_tmp12), vec3(reg_tmp12));
            // 220: rsq
            reg_tmp6.x = rsq_safe(reg_tmp6.xxxx.x);
            // 221: rsq
            reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
            // 222: mul
            reg_tmp14.xyz = (mul_safe(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 223: mul
            reg_tmp12.xyz = (mul_safe(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 224: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 225: jmpu
            if (!uniforms.b[3]) {
                { jmp_to = 234u; break; }
            }
            // 226: add
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            // 227: mul
            reg_tmp4 = mul_safe(uniforms.f[94].zzzz, reg_tmp4);
            // 228: cmp
            conditional_code = greaterThanEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp4.xxxx));
            // 229: rsq
            reg_tmp4 = vec4(rsq_safe(reg_tmp4.xxxx.x));
            // 230: mul
            reg_tmp5 = mul_safe(uniforms.f[94].zzzz, reg_tmp14);
            // 231: jmpc
            if (conditional_code.x) {
                { jmp_to = 234u; break; }
            }
            // 232: rcp
            reg_tmp0.z = rcp_safe(reg_tmp4.xxxx.x);
            // 233: mul
            reg_tmp0.xy = (mul_safe(reg_tmp5, reg_tmp4)).xy;
        }
        case 234u: {
            // 234: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_235_311() {
    uint jmp_to = 235u;
    while (true) {
        switch (jmp_to) {
        case 235u: {
            // 235: dp3
            reg_tmp6.x = dot(vec3(reg_tmp14), vec3(reg_tmp14));
            // 236: dp3
            reg_tmp7.x = dot(vec3(reg_tmp12), vec3(reg_tmp12));
            // 237: rsq
            reg_tmp6.x = rsq_safe(reg_tmp6.xxxx.x);
            // 238: rsq
            reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
            // 239: mul
            reg_tmp14.xyz = (mul_safe(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 240: mul
            reg_tmp12.xyz = (mul_safe(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 241: mul
            reg_tmp13.xyz = (mul_safe(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            // 242: mul
            reg_tmp11.xyz = (mul_safe(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            // 243: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 244: jmpu
            if (!uniforms.b[3]) {
                { jmp_to = 310u; break; }
            }
            // 245: mul
            reg_tmp13.xyz = (mul_safe(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            // 246: mul
            reg_tmp11.xyz = (mul_safe(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            // 247: mul
            reg_tmp5 = mul_safe(reg_tmp14.yzxx, reg_tmp13.zxyy);
            // 248: mad
            reg_tmp5 = fma_safe(-reg_tmp13.yzxx, reg_tmp14.zxyy, reg_tmp5);
            // 249: dp3
            reg_tmp5.w = dot(vec3(reg_tmp5), vec3(reg_tmp5));
            // 250: rsq
            reg_tmp5.w = rsq_safe(reg_tmp5.wwww.x);
            // 251: mul
            reg_tmp5 = mul_safe(reg_tmp5, reg_tmp5.wwww);
            // 252: add
            reg_tmp6.w = (reg_tmp14.zzzz + reg_tmp5.yyyy).w;
            // 253: mul
            reg_tmp13 = mul_safe(reg_tmp5.yzxx, reg_tmp14.zxyy);
            // 254: mad
            reg_tmp13 = fma_safe(-reg_tmp14.yzxx, reg_tmp5.zxyy, reg_tmp13);
            // 255: add
            reg_tmp6.w = (reg_tmp13.xxxx + reg_tmp6).w;
            // 256: mov
            reg_tmp13.w = (reg_tmp5.zzzz).w;
            // 257: mov
            reg_tmp5.z = (reg_tmp13.xxxx).z;
            // 258: add
            reg_tmp6.w = (uniforms.f[93].yyyy + reg_tmp6).w;
            // 259: mov
            reg_tmp14.w = (reg_tmp5.xxxx).w;
            // 260: mov
            reg_tmp5.x = (reg_tmp14.zzzz).x;
            // 261: cmp
            conditional_code = lessThan(vec2(uniforms.f[94].yyyy), vec2(reg_tmp6.wwww));
            // 262: mov
            reg_tmp6.x = (uniforms.f[93].yyyy).x;
            // 263: mov
            reg_tmp6.y = (-uniforms.f[93].yyyy).y;
            // 264: jmpc
            if (!conditional_code.x) {
                { jmp_to = 272u; break; }
            }
            // 265: add
            reg_tmp7.xz = (reg_tmp13.wwyy + -reg_tmp14.yyww).xz;
            // 266: add
            reg_tmp7.y = (reg_tmp14.xxxx + -reg_tmp13.zzzz).y;
            // 267: mov
            reg_tmp7.w = (reg_tmp6).w;
            // 268: dp4
            reg_tmp6 = vec4(dot(reg_tmp7, reg_tmp7));
            // 269: rsq
            reg_tmp6 = vec4(rsq_safe(reg_tmp6.xxxx.x));
            // 270: mul
            reg_tmp0 = mul_safe(reg_tmp7, reg_tmp6);
            // 271: jmpu
            if (uniforms.b[0]) {
                { jmp_to = 310u; break; }
            }
        }
        case 272u: {
            // 272: cmp
            conditional_code = greaterThan(vec2(reg_tmp5.zyyy), vec2(reg_tmp5.yxxx));
            // 273: ifc
            if (conditional_code.x) {
                sub_274_294();
            } else {
                sub_294_307();
            }
            // 307: dp4
            reg_tmp6 = vec4(dot(reg_tmp8, reg_tmp8));
            // 308: rsq
            reg_tmp6 = vec4(rsq_safe(reg_tmp6.xxxx.x));
            // 309: mul
            reg_tmp0 = mul_safe(reg_tmp8, reg_tmp6);
        }
        case 310u: {
            // 310: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_274_294() {
    // 274: ifc
    if (conditional_code.y) {
        sub_275_280();
    } else {
        sub_280_293();
    }
    // 293: mov
    reg_tmp8.w = (-reg_tmp8).w;
    return false;
}
bool sub_275_280() {
    // 275: mul
    reg_tmp8 = mul_safe(reg_tmp13.yyzw, reg_tmp6.xxxy);
    // 276: add
    reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
    // 277: add
    reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
    // 278: add
    reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
    // 279: add
    reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
    return false;
}
bool sub_280_293() {
    // 280: cmp
    conditional_code = greaterThan(vec2(reg_tmp5.zzzz), vec2(reg_tmp5.xxxx));
    // 281: mul
    reg_tmp8 = mul_safe(reg_tmp13.yyzw, reg_tmp6.xxxy);
    // 282: add
    reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
    // 283: ifc
    if (conditional_code.x) {
        sub_284_287();
    } else {
        sub_287_292();
    }
    // 292: nop
    return false;
}
bool sub_284_287() {
    // 284: add
    reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
    // 285: add
    reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
    // 286: add
    reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
    return false;
}
bool sub_287_292() {
    // 287: mul
    reg_tmp8 = mul_safe(reg_tmp13.zwwy, reg_tmp6.xxxy);
    // 288: add
    reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
    // 289: add
    reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
    // 290: add
    reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
    // 291: add
    reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
    return false;
}
bool sub_294_307() {
    // 294: ifc
    if (conditional_code.y) {
        sub_295_300();
    } else {
        sub_300_306();
    }
    // 306: nop
    return false;
}
bool sub_295_300() {
    // 295: mul
    reg_tmp8 = mul_safe(reg_tmp13.yywz, reg_tmp6.xxxy);
    // 296: add
    reg_tmp8.y = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).y;
    // 297: add
    reg_tmp9 = reg_tmp5.yyyy + -reg_tmp5.xxxx;
    // 298: add
    reg_tmp8.xzw = (reg_tmp8 + reg_tmp14.wwyx).xzw;
    // 299: add
    reg_tmp8.y = (reg_tmp9 + reg_tmp8).y;
    return false;
}
bool sub_300_306() {
    // 300: mul
    reg_tmp8 = mul_safe(reg_tmp13.zwwy, reg_tmp6.xxxy);
    // 301: add
    reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
    // 302: add
    reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
    // 303: add
    reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
    // 304: add
    reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
    // 305: mov
    reg_tmp8.w = (-reg_tmp8).w;
    return false;
}
bool sub_311_323() {
    // 311: mov
    reg_tmp0.y = (uniforms.f[7].wwww).y;
    // 312: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.xyyy));
    // 313: mov
    reg_tmp9.xyz = (uniforms.f[93].xxxx).xyz;
    // 314: mov
    reg_tmp9.w = (uniforms.f[21].wwww).w;
    // 315: ifc
    if (conditional_code.y) {
        sub_316_321();
    }
    // 321: call
    {
        sub_323_333();
    }
    // 322: max
    vs_out_attr3 = max(uniforms.f[93].xxxx, reg_tmp9);
    return false;
}
bool sub_316_321() {
    // 316: mul
    reg_tmp0 = mul_safe(uniforms.f[7].wwww, vs_in_reg3);
    // 317: ifu
    if (uniforms.b[7]) {
        sub_318_319();
    }
    // 319: mul
    reg_tmp9.xyz = (mul_safe(uniforms.f[20].wwww, reg_tmp0.xyzz)).xyz;
    // 320: mov
    reg_tmp8.x = (uniforms.f[93].yyyy).x;
    return false;
}
bool sub_318_319() {
    // 318: mul
    reg_tmp9.w = (mul_safe(reg_tmp9.wwww, reg_tmp0.wwww)).w;
    return false;
}
bool sub_323_333() {
    // 323: dp3
    reg_tmp1 = vec4(dot(vec3(uniforms.f[24]), vec3(reg_tmp14)));
    // 324: mov
    reg_tmp2 = uniforms.f[24].wwww;
    // 325: mad
    reg_tmp1 = fma_safe(reg_tmp1, reg_tmp2, reg_tmp2);
    // 326: mov
    reg_tmp3 = uniforms.f[22];
    // 327: add
    reg_tmp2 = uniforms.f[23] + -reg_tmp3;
    // 328: mad
    reg_tmp4 = fma_safe(reg_tmp2, reg_tmp1, reg_tmp3);
    // 329: ifu
    if (uniforms.b[6]) {
        sub_330_331();
    }
    // 331: mad
    reg_tmp9.xyz = (fma_safe(reg_tmp4, uniforms.f[21], reg_tmp9)).xyz;
    // 332: mov
    reg_tmp8.x = (uniforms.f[93].yyyy).x;
    return false;
}
bool sub_330_331() {
    // 330: mul
    reg_tmp4 = mul_safe(reg_tmp4, reg_tmp9.wwww);
    return false;
}
bool sub_333_360() {
    // 333: mov
    reg_tmp0.xy = (uniforms.f[10].xxxx).xy;
    // 334: ifu
    if (uniforms.b[9]) {
        sub_335_340();
    } else {
        sub_340_359();
    }
    // 359: nop
    return false;
}
bool sub_335_340() {
    // 335: call
    {
        sub_360_368();
    }
    // 336: dp4
    reg_tmp3.x = dot(uniforms.f[11].xywz, reg_tmp6);
    // 337: dp4
    reg_tmp3.y = dot(uniforms.f[12].xywz, reg_tmp6);
    // 338: mov
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    // 339: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_340_359() {
    // 340: cmp
    conditional_code = equal(vec2(uniforms.f[95].xyyy), vec2(reg_tmp0.xyyy));
    // 341: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 342: ifc
    if (all(not(conditional_code))) {
        sub_343_349();
    } else {
        sub_349_358();
    }
    // 358: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_343_349() {
    // 343: mov
    reg_tmp6 = reg_tmp10;
    // 344: dp4
    reg_tmp3.x = dot(uniforms.f[11], reg_tmp6);
    // 345: dp4
    reg_tmp3.y = dot(uniforms.f[12], reg_tmp6);
    // 346: dp4
    reg_tmp3.z = dot(uniforms.f[13], reg_tmp6);
    // 347: mul
    reg_tmp0.xy = (mul_safe(uniforms.f[19].xyyy, reg_tmp3.zzzz)).xy;
    // 348: add
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_349_358() {
    // 349: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_350_354();
    } else {
        sub_354_357();
    }
    // 357: nop
    return false;
}
bool sub_350_354() {
    // 350: call
    {
        sub_368_375();
    }
    // 351: dp3
    reg_tmp3.x = dot(vec3(uniforms.f[11]), vec3(reg_tmp6));
    // 352: dp3
    reg_tmp3.y = dot(vec3(uniforms.f[12]), vec3(reg_tmp6));
    // 353: dp3
    reg_tmp3.z = dot(vec3(uniforms.f[13]), vec3(reg_tmp6));
    return false;
}
bool sub_354_357() {
    // 354: call
    {
        sub_375_379();
    }
    // 355: dp4
    reg_tmp3.x = dot(uniforms.f[11], reg_tmp6);
    // 356: dp4
    reg_tmp3.y = dot(uniforms.f[12], reg_tmp6);
    return false;
}
bool sub_360_368() {
    // 360: cmp
    conditional_code = equal(vec2(uniforms.f[93].yzzz), vec2(reg_tmp0.xyyy));
    // 361: ifc
    if (all(not(conditional_code))) {
        sub_362_363();
    } else {
        sub_363_367();
    }
    // 367: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_362_363() {
    // 362: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
    return false;
}
bool sub_363_367() {
    // 363: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_364_365();
    } else {
        sub_365_366();
    }
    // 366: nop
    return false;
}
bool sub_364_365() {
    // 364: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
    return false;
}
bool sub_365_366() {
    // 365: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
    return false;
}
bool sub_368_375() {
    // 368: mov
    reg_tmp2 = -reg_tmp15;
    // 369: dp3
    reg_tmp2.w = dot(vec3(reg_tmp2), vec3(reg_tmp2));
    // 370: rsq
    reg_tmp2.w = rsq_safe(reg_tmp2.wwww.x);
    // 371: mul
    reg_tmp2 = mul_safe(reg_tmp2, reg_tmp2.wwww);
    // 372: dp3
    reg_tmp1 = vec4(dot(vec3(reg_tmp2), vec3(reg_tmp14)));
    // 373: add
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    // 374: mad
    reg_tmp6 = fma_safe(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_375_379() {
    // 375: mov
    reg_tmp1.xy = (uniforms.f[94].zzzz).xy;
    // 376: mov
    reg_tmp1.zw = (uniforms.f[93].xxxx).zw;
    // 377: mad
    reg_tmp6 = fma_safe(reg_tmp14, reg_tmp1, reg_tmp1);
    // 378: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_379_403() {
    // 379: mov
    reg_tmp0.xy = (uniforms.f[10].yyyy).xy;
    // 380: ifu
    if (uniforms.b[10]) {
        sub_381_385();
    } else {
        sub_385_402();
    }
    // 402: nop
    return false;
}
bool sub_381_385() {
    // 381: call
    {
        sub_360_368();
    }
    // 382: dp4
    reg_tmp4.x = dot(uniforms.f[14].xywz, reg_tmp6);
    // 383: dp4
    reg_tmp4.y = dot(uniforms.f[15].xywz, reg_tmp6);
    // 384: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_385_402() {
    // 385: ifu
    if (uniforms.b[13]) {
        sub_386_400();
    } else {
        sub_400_401();
    }
    // 401: nop
    return false;
}
bool sub_386_400() {
    // 386: cmp
    conditional_code = equal(vec2(uniforms.f[95].xyyy), vec2(reg_tmp0.xyyy));
    // 387: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 388: ifc
    if (all(not(conditional_code))) {
        sub_389_396();
    } else {
        sub_396_399();
    }
    // 399: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_389_396() {
    // 389: mov
    reg_tmp6 = reg_tmp10;
    // 390: dp4
    reg_tmp4.x = dot(uniforms.f[14], reg_tmp6);
    // 391: dp4
    reg_tmp4.y = dot(uniforms.f[15], reg_tmp6);
    // 392: dp4
    reg_tmp4.z = dot(uniforms.f[16], reg_tmp6);
    // 393: rcp
    reg_tmp6.w = rcp_safe(reg_tmp4.zzzz.x);
    // 394: mul
    reg_tmp4.xy = (mul_safe(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    // 395: add
    reg_tmp4.xy = (uniforms.f[19].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_396_399() {
    // 396: call
    {
        sub_375_379();
    }
    // 397: dp4
    reg_tmp4.x = dot(uniforms.f[14], reg_tmp6);
    // 398: dp4
    reg_tmp4.y = dot(uniforms.f[15], reg_tmp6);
    return false;
}
bool sub_400_401() {
    // 400: mov
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_419_4096() {
    // 419: call
    {
        sub_34_218();
    }
    // 420: call
    {
        sub_311_323();
    }
    // 421: call
    {
        sub_333_360();
    }
    // 422: call
    {
        sub_379_403();
    }
    // 423: end
    return true;
}
// reference: B4192FD7513EBD34, 46F6395BEBA5C2A1
// shader: 8DD9, 3B3AE026C742C7D5

layout(triangles) in;
layout(triangle_strip, max_vertices = 3) out;

out vec4 primary_color;
out vec2 texcoord0;
out vec2 texcoord1;
out vec2 texcoord2;
out float texcoord0_w;
out vec4 normquat;
out vec3 view;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

 in vec4 vs_out_attr0[];
 in vec4 vs_out_attr1[];
 in vec4 vs_out_attr2[];
 in vec4 vs_out_attr3[];
 in vec4 vs_out_attr4[];
 in vec4 vs_out_attr5[];

struct Vertex {
    vec4 attributes[6];
};

vec4 GetVertexQuaternion(Vertex vtx) {
    return vec4(vtx.attributes[1].x, vtx.attributes[1].y, vtx.attributes[1].z, vtx.attributes[1].w);
}

void EmitVtx(Vertex vtx, bool quats_opposite) {
    vec4 vtx_pos = vec4(vtx.attributes[0].x, vtx.attributes[0].y, vtx.attributes[0].z, vtx.attributes[0].w);
    gl_Position = vtx_pos;
#if !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)
    gl_ClipDistance[0] = -vtx_pos.z;
    gl_ClipDistance[1] = dot(clip_coef, vtx_pos);
#endif // !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)

    vec4 vtx_quat = GetVertexQuaternion(vtx);
    normquat = mix(vtx_quat, -vtx_quat, bvec4(quats_opposite));

    vec4 vtx_color = vec4(vtx.attributes[3].x, vtx.attributes[3].y, vtx.attributes[3].z, vtx.attributes[3].w);
    primary_color = min(abs(vtx_color), vec4(1.0));

    texcoord0 = vec2(vtx.attributes[4].x, vtx.attributes[4].y);
    texcoord1 = vec2(vtx.attributes[5].x, vtx.attributes[5].y);

    texcoord0_w = vtx.attributes[4].z;
    view = vec3(vtx.attributes[2].x, vtx.attributes[2].y, vtx.attributes[2].z);

    texcoord2 = vec2(0.0, 0.0);

    EmitVertex();
}

bool AreQuaternionsOpposite(vec4 qa, vec4 qb) {
    return (dot(qa, qb) < 0.0);
}

void EmitPrim(Vertex vtx0, Vertex vtx1, Vertex vtx2) {
    EmitVtx(vtx0, false);
    EmitVtx(vtx1, AreQuaternionsOpposite(GetVertexQuaternion(vtx0), GetVertexQuaternion(vtx1)));
    EmitVtx(vtx2, AreQuaternionsOpposite(GetVertexQuaternion(vtx0), GetVertexQuaternion(vtx2)));
    EndPrimitive();
}

void main() {
    Vertex prim_buffer[3];
    prim_buffer[0].attributes = vec4[6](vs_out_attr0[0], vs_out_attr1[0], vs_out_attr2[0], vs_out_attr3[0], vs_out_attr4[0], vs_out_attr5[0]);
    prim_buffer[1].attributes = vec4[6](vs_out_attr0[1], vs_out_attr1[1], vs_out_attr2[1], vs_out_attr3[1], vs_out_attr4[1], vs_out_attr5[1]);
    prim_buffer[2].attributes = vec4[6](vs_out_attr0[2], vs_out_attr1[2], vs_out_attr2[2], vs_out_attr3[2], vs_out_attr4[2], vs_out_attr5[2]);
    EmitPrim(prim_buffer[0], prim_buffer[1], prim_buffer[2]);
}
// reference: 46A0C2E6B155D5CD, 3B3AE026C742C7D5
// shader: 8B30, A58936DDD19F88C1

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(view)), 0.0))) * light_src[0].specular_0) + ((lut_scale_d1 * LookupLightingLUTUnsigned(1, max(dot(normal, normalize(view)), 0.0))) * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texture(tex_cube, vec3(texcoord0, texcoord0_w)).rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (texture(tex_cube, vec3(texcoord0, texcoord0_w)).a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1 * 2.0, alpha_output_1 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((texcolor1.aaa) * (secondary_fragment_color.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4 * 2.0, alpha_output_4 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 43CC6A3C2DE37AC6, A58936DDD19F88C1
// program: 46F6395BEBA5C2A1, 3B3AE026C742C7D5, A58936DDD19F88C1
// reference: 6157D9ACC3463122, DEFAC6F185DB6EB9
// shader: 8B30, 7D251428D9104055

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: E30C444A7932FB14, 7D251428D9104055
// program: DEFAC6F185DB6EB9, 6CF3F3B70E23AA85, 7D251428D9104055
// shader: 8B30, 089F98A92317B4E3

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 62300EFEEC3789FF, 089F98A92317B4E3
// program: DEFAC6F185DB6EB9, 6CF3F3B70E23AA85, 089F98A92317B4E3
// shader: 8B31, 65138AC5CA635BBF

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define fma_safe(x, y, z) fma(x, y, z)
#define mul_safe(x, y) (x * y)
#define rcp_safe(x) (1.0f / x)
#define rsq_safe(x) inversesqrt(x)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_7_12();
bool sub_12_21();
bool sub_21_34();
bool sub_34_218();
bool sub_40_146();
bool sub_47_76();
bool sub_58_62();
bool sub_76_135();
bool sub_77_109();
bool sub_88_92();
bool sub_109_134();
bool sub_120_124();
bool sub_144_145();
bool sub_146_217();
bool sub_149_159();
bool sub_159_168();
bool sub_169_181();
bool sub_181_206();
bool sub_182_200();
bool sub_200_205();
bool sub_215_216();
bool sub_218_235();
bool sub_235_311();
bool sub_274_294();
bool sub_275_280();
bool sub_280_293();
bool sub_284_287();
bool sub_287_292();
bool sub_294_307();
bool sub_295_300();
bool sub_300_306();
bool sub_311_321();
bool sub_316_320();
bool sub_317_318();
bool sub_321_348();
bool sub_323_328();
bool sub_328_347();
bool sub_331_337();
bool sub_337_346();
bool sub_338_342();
bool sub_342_345();
bool sub_348_356();
bool sub_350_351();
bool sub_351_355();
bool sub_352_353();
bool sub_353_354();
bool sub_356_363();
bool sub_363_367();
bool sub_367_391();
bool sub_369_373();
bool sub_373_390();
bool sub_374_388();
bool sub_377_384();
bool sub_384_387();
bool sub_388_389();
bool sub_407_4096();

bool exec_shader() {
    sub_407_4096();
    return true;
}

bool sub_7_12() {
    // 7: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 8: dp4
    reg_tmp3.x = dot(uniforms.f[25 + address_registers.x], reg_tmp15);
    // 9: dp4
    reg_tmp3.y = dot(uniforms.f[26 + address_registers.x], reg_tmp15);
    // 10: dp4
    reg_tmp3.z = dot(uniforms.f[27 + address_registers.x], reg_tmp15);
    // 11: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    return false;
}
bool sub_12_21() {
    // 12: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 13: dp4
    reg_tmp3.x = dot(uniforms.f[25 + address_registers.x], reg_tmp15);
    // 14: dp4
    reg_tmp3.y = dot(uniforms.f[26 + address_registers.x], reg_tmp15);
    // 15: dp4
    reg_tmp3.z = dot(uniforms.f[27 + address_registers.x], reg_tmp15);
    // 16: dp3
    reg_tmp4.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp14));
    // 17: dp3
    reg_tmp4.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp14));
    // 18: dp3
    reg_tmp4.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp14));
    // 19: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 20: mad
    reg_tmp12 = fma_safe(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_21_34() {
    // 21: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 22: dp4
    reg_tmp3.x = dot(uniforms.f[25 + address_registers.x], reg_tmp15);
    // 23: dp4
    reg_tmp3.y = dot(uniforms.f[26 + address_registers.x], reg_tmp15);
    // 24: dp4
    reg_tmp3.z = dot(uniforms.f[27 + address_registers.x], reg_tmp15);
    // 25: dp3
    reg_tmp4.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp14));
    // 26: dp3
    reg_tmp4.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp14));
    // 27: dp3
    reg_tmp4.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp14));
    // 28: dp3
    reg_tmp5.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp13));
    // 29: dp3
    reg_tmp5.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp13));
    // 30: dp3
    reg_tmp5.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp13));
    // 31: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 32: mad
    reg_tmp12 = fma_safe(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    // 33: mad
    reg_tmp11 = fma_safe(reg_tmp1.wwww, reg_tmp5, reg_tmp11);
    return false;
}
bool sub_34_218() {
    // 34: mul
    reg_tmp15.xyz = (mul_safe(uniforms.f[7].xxxx, vs_in_reg0)).xyz;
    // 35: mul
    reg_tmp14.xyz = (mul_safe(uniforms.f[7].yyyy, vs_in_reg1)).xyz;
    // 36: mul
    reg_tmp13.xyz = (mul_safe(uniforms.f[7].zzzz, vs_in_reg2)).xyz;
    // 37: add
    reg_tmp15.xyz = (uniforms.f[6] + reg_tmp15).xyz;
    // 38: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 39: ifu
    if (uniforms.b[1]) {
        sub_40_146();
    } else {
        sub_146_217();
    }
    // 217: nop
    return false;
}
bool sub_40_146() {
    // 40: mov
    reg_tmp0 = uniforms.f[7];
    // 41: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.yzzz));
    // 42: mov
    reg_tmp7 = uniforms.f[93].xxxx;
    // 43: mov
    reg_tmp12 = uniforms.f[93].xxxx;
    // 44: mov
    reg_tmp11 = uniforms.f[93].xxxx;
    // 45: mul
    reg_tmp2 = mul_safe(uniforms.f[93].wwww, vs_in_reg7);
    // 46: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_47_76();
    } else {
        sub_76_135();
    }
    // 135: mov
    vs_out_attr2 = -reg_tmp15;
    // 136: dp4
    reg_tmp0.x = dot(uniforms.f[86], reg_tmp15);
    // 137: dp4
    reg_tmp0.y = dot(uniforms.f[87], reg_tmp15);
    // 138: dp4
    reg_tmp0.z = dot(uniforms.f[88], reg_tmp15);
    // 139: dp4
    reg_tmp0.w = dot(uniforms.f[89], reg_tmp15);
    // 140: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 141: mul
    reg_tmp1.y = (mul_safe(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
    // 142: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 143: ifc
    if (all(conditional_code)) {
        sub_144_145();
    }
    // 145: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_47_76() {
    // 47: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 48: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 49: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 50: call
    {
        sub_12_21();
    }
    // 51: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 52: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 53: call
    {
        sub_12_21();
    }
    // 54: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 55: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 56: callc
    if (conditional_code.x) {
        sub_12_21();
    }
    // 57: ifu
    if (uniforms.b[8]) {
        sub_58_62();
    }
    // 62: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 63: dp4
    reg_tmp10.x = dot(uniforms.f[0], reg_tmp7);
    // 64: dp4
    reg_tmp10.y = dot(uniforms.f[1], reg_tmp7);
    // 65: dp4
    reg_tmp10.z = dot(uniforms.f[2], reg_tmp7);
    // 66: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 67: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 68: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 69: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 70: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 71: dp3
    reg_tmp14.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp12));
    // 72: dp3
    reg_tmp14.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp12));
    // 73: dp3
    reg_tmp14.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp12));
    // 74: call
    {
        sub_218_235();
    }
    // 75: nop
    return false;
}
bool sub_58_62() {
    // 58: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 59: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 60: callc
    if (conditional_code.y) {
        sub_12_21();
    }
    // 61: nop
    return false;
}
bool sub_76_135() {
    // 76: ifc
    if (all(conditional_code)) {
        sub_77_109();
    } else {
        sub_109_134();
    }
    // 134: nop
    return false;
}
bool sub_77_109() {
    // 77: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 78: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 79: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 80: call
    {
        sub_21_34();
    }
    // 81: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 82: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 83: call
    {
        sub_21_34();
    }
    // 84: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 85: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 86: callc
    if (conditional_code.x) {
        sub_21_34();
    }
    // 87: ifu
    if (uniforms.b[8]) {
        sub_88_92();
    }
    // 92: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 93: dp4
    reg_tmp10.x = dot(uniforms.f[0], reg_tmp7);
    // 94: dp4
    reg_tmp10.y = dot(uniforms.f[1], reg_tmp7);
    // 95: dp4
    reg_tmp10.z = dot(uniforms.f[2], reg_tmp7);
    // 96: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 97: dp3
    reg_tmp13.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp11));
    // 98: dp3
    reg_tmp13.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp11));
    // 99: dp3
    reg_tmp13.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp11));
    // 100: dp3
    reg_tmp14.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp12));
    // 101: dp3
    reg_tmp14.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp12));
    // 102: dp3
    reg_tmp14.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp12));
    // 103: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 104: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 105: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 106: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 107: call
    {
        sub_235_311();
    }
    // 108: nop
    return false;
}
bool sub_88_92() {
    // 88: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 89: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 90: callc
    if (conditional_code.y) {
        sub_21_34();
    }
    // 91: nop
    return false;
}
bool sub_109_134() {
    // 109: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 110: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 111: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 112: call
    {
        sub_7_12();
    }
    // 113: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 114: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 115: call
    {
        sub_7_12();
    }
    // 116: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 117: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 118: callc
    if (conditional_code.x) {
        sub_7_12();
    }
    // 119: ifu
    if (uniforms.b[8]) {
        sub_120_124();
    }
    // 124: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 125: dp4
    reg_tmp10.x = dot(uniforms.f[0], reg_tmp7);
    // 126: dp4
    reg_tmp10.y = dot(uniforms.f[1], reg_tmp7);
    // 127: dp4
    reg_tmp10.z = dot(uniforms.f[2], reg_tmp7);
    // 128: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 129: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 130: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 131: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 132: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 133: mov
    vs_out_attr1 = uniforms.f[93].xxxx;
    return false;
}
bool sub_120_124() {
    // 120: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 121: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 122: callc
    if (conditional_code.y) {
        sub_7_12();
    }
    // 123: nop
    return false;
}
bool sub_144_145() {
    // 144: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_146_217() {
    // 146: mov
    reg_tmp0 = uniforms.f[7];
    // 147: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.yzzz));
    // 148: ifu
    if (uniforms.b[2]) {
        sub_149_159();
    } else {
        sub_159_168();
    }
    // 168: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_169_181();
    } else {
        sub_181_206();
    }
    // 206: mov
    vs_out_attr2 = -reg_tmp15;
    // 207: dp4
    reg_tmp0.x = dot(uniforms.f[86], reg_tmp15);
    // 208: dp4
    reg_tmp0.y = dot(uniforms.f[87], reg_tmp15);
    // 209: dp4
    reg_tmp0.z = dot(uniforms.f[88], reg_tmp15);
    // 210: dp4
    reg_tmp0.w = dot(uniforms.f[89], reg_tmp15);
    // 211: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 212: mul
    reg_tmp1.y = (mul_safe(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
    // 213: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 214: ifc
    if (all(conditional_code)) {
        sub_215_216();
    }
    // 216: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_149_159() {
    // 149: mul
    reg_tmp1.x = (mul_safe(uniforms.f[93].wwww, vs_in_reg7.xxxx)).x;
    // 150: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 151: dp4
    reg_tmp7.x = dot(uniforms.f[25 + address_registers.x], reg_tmp15);
    // 152: dp4
    reg_tmp7.y = dot(uniforms.f[26 + address_registers.x], reg_tmp15);
    // 153: dp4
    reg_tmp7.z = dot(uniforms.f[27 + address_registers.x], reg_tmp15);
    // 154: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 155: dp4
    reg_tmp10.x = dot(uniforms.f[0], reg_tmp7);
    // 156: dp4
    reg_tmp10.y = dot(uniforms.f[1], reg_tmp7);
    // 157: dp4
    reg_tmp10.z = dot(uniforms.f[2], reg_tmp7);
    // 158: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_159_168() {
    // 159: mova
    address_registers.x = (ivec2(uniforms.f[93].xxxx)).x;
    // 160: dp4
    reg_tmp7.x = dot(uniforms.f[25], reg_tmp15);
    // 161: dp4
    reg_tmp7.y = dot(uniforms.f[26], reg_tmp15);
    // 162: dp4
    reg_tmp7.z = dot(uniforms.f[27], reg_tmp15);
    // 163: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 164: dp4
    reg_tmp10.x = dot(uniforms.f[0], reg_tmp7);
    // 165: dp4
    reg_tmp10.y = dot(uniforms.f[1], reg_tmp7);
    // 166: dp4
    reg_tmp10.z = dot(uniforms.f[2], reg_tmp7);
    // 167: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_169_181() {
    // 169: dp3
    reg_tmp12.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp14));
    // 170: dp3
    reg_tmp12.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp14));
    // 171: dp3
    reg_tmp12.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp14));
    // 172: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 173: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 174: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 175: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 176: dp3
    reg_tmp14.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp12));
    // 177: dp3
    reg_tmp14.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp12));
    // 178: dp3
    reg_tmp14.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp12));
    // 179: call
    {
        sub_218_235();
    }
    // 180: nop
    return false;
}
bool sub_181_206() {
    // 181: ifc
    if (all(conditional_code)) {
        sub_182_200();
    } else {
        sub_200_205();
    }
    // 205: nop
    return false;
}
bool sub_182_200() {
    // 182: dp3
    reg_tmp12.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp14));
    // 183: dp3
    reg_tmp12.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp14));
    // 184: dp3
    reg_tmp12.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp14));
    // 185: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp13));
    // 186: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp13));
    // 187: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp13));
    // 188: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 189: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 190: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 191: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 192: dp3
    reg_tmp14.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp12));
    // 193: dp3
    reg_tmp14.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp12));
    // 194: dp3
    reg_tmp14.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp12));
    // 195: dp3
    reg_tmp13.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp11));
    // 196: dp3
    reg_tmp13.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp11));
    // 197: dp3
    reg_tmp13.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp11));
    // 198: call
    {
        sub_235_311();
    }
    // 199: nop
    return false;
}
bool sub_200_205() {
    // 200: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 201: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 202: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 203: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 204: mov
    vs_out_attr1 = uniforms.f[93].xxxx;
    return false;
}
bool sub_215_216() {
    // 215: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_218_235() {
    uint jmp_to = 218u;
    while (true) {
        switch (jmp_to) {
        case 218u: {
            // 218: dp3
            reg_tmp6.x = dot(vec3(reg_tmp14), vec3(reg_tmp14));
            // 219: dp3
            reg_tmp7.x = dot(vec3(reg_tmp12), vec3(reg_tmp12));
            // 220: rsq
            reg_tmp6.x = rsq_safe(reg_tmp6.xxxx.x);
            // 221: rsq
            reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
            // 222: mul
            reg_tmp14.xyz = (mul_safe(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 223: mul
            reg_tmp12.xyz = (mul_safe(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 224: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 225: jmpu
            if (!uniforms.b[3]) {
                { jmp_to = 234u; break; }
            }
            // 226: add
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            // 227: mul
            reg_tmp4 = mul_safe(uniforms.f[94].zzzz, reg_tmp4);
            // 228: cmp
            conditional_code = greaterThanEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp4.xxxx));
            // 229: rsq
            reg_tmp4 = vec4(rsq_safe(reg_tmp4.xxxx.x));
            // 230: mul
            reg_tmp5 = mul_safe(uniforms.f[94].zzzz, reg_tmp14);
            // 231: jmpc
            if (conditional_code.x) {
                { jmp_to = 234u; break; }
            }
            // 232: rcp
            reg_tmp0.z = rcp_safe(reg_tmp4.xxxx.x);
            // 233: mul
            reg_tmp0.xy = (mul_safe(reg_tmp5, reg_tmp4)).xy;
        }
        case 234u: {
            // 234: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_235_311() {
    uint jmp_to = 235u;
    while (true) {
        switch (jmp_to) {
        case 235u: {
            // 235: dp3
            reg_tmp6.x = dot(vec3(reg_tmp14), vec3(reg_tmp14));
            // 236: dp3
            reg_tmp7.x = dot(vec3(reg_tmp12), vec3(reg_tmp12));
            // 237: rsq
            reg_tmp6.x = rsq_safe(reg_tmp6.xxxx.x);
            // 238: rsq
            reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
            // 239: mul
            reg_tmp14.xyz = (mul_safe(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 240: mul
            reg_tmp12.xyz = (mul_safe(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 241: mul
            reg_tmp13.xyz = (mul_safe(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            // 242: mul
            reg_tmp11.xyz = (mul_safe(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            // 243: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 244: jmpu
            if (!uniforms.b[3]) {
                { jmp_to = 310u; break; }
            }
            // 245: mul
            reg_tmp13.xyz = (mul_safe(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            // 246: mul
            reg_tmp11.xyz = (mul_safe(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            // 247: mul
            reg_tmp5 = mul_safe(reg_tmp14.yzxx, reg_tmp13.zxyy);
            // 248: mad
            reg_tmp5 = fma_safe(-reg_tmp13.yzxx, reg_tmp14.zxyy, reg_tmp5);
            // 249: dp3
            reg_tmp5.w = dot(vec3(reg_tmp5), vec3(reg_tmp5));
            // 250: rsq
            reg_tmp5.w = rsq_safe(reg_tmp5.wwww.x);
            // 251: mul
            reg_tmp5 = mul_safe(reg_tmp5, reg_tmp5.wwww);
            // 252: add
            reg_tmp6.w = (reg_tmp14.zzzz + reg_tmp5.yyyy).w;
            // 253: mul
            reg_tmp13 = mul_safe(reg_tmp5.yzxx, reg_tmp14.zxyy);
            // 254: mad
            reg_tmp13 = fma_safe(-reg_tmp14.yzxx, reg_tmp5.zxyy, reg_tmp13);
            // 255: add
            reg_tmp6.w = (reg_tmp13.xxxx + reg_tmp6).w;
            // 256: mov
            reg_tmp13.w = (reg_tmp5.zzzz).w;
            // 257: mov
            reg_tmp5.z = (reg_tmp13.xxxx).z;
            // 258: add
            reg_tmp6.w = (uniforms.f[93].yyyy + reg_tmp6).w;
            // 259: mov
            reg_tmp14.w = (reg_tmp5.xxxx).w;
            // 260: mov
            reg_tmp5.x = (reg_tmp14.zzzz).x;
            // 261: cmp
            conditional_code = lessThan(vec2(uniforms.f[94].yyyy), vec2(reg_tmp6.wwww));
            // 262: mov
            reg_tmp6.x = (uniforms.f[93].yyyy).x;
            // 263: mov
            reg_tmp6.y = (-uniforms.f[93].yyyy).y;
            // 264: jmpc
            if (!conditional_code.x) {
                { jmp_to = 272u; break; }
            }
            // 265: add
            reg_tmp7.xz = (reg_tmp13.wwyy + -reg_tmp14.yyww).xz;
            // 266: add
            reg_tmp7.y = (reg_tmp14.xxxx + -reg_tmp13.zzzz).y;
            // 267: mov
            reg_tmp7.w = (reg_tmp6).w;
            // 268: dp4
            reg_tmp6 = vec4(dot(reg_tmp7, reg_tmp7));
            // 269: rsq
            reg_tmp6 = vec4(rsq_safe(reg_tmp6.xxxx.x));
            // 270: mul
            reg_tmp0 = mul_safe(reg_tmp7, reg_tmp6);
            // 271: jmpu
            if (uniforms.b[0]) {
                { jmp_to = 310u; break; }
            }
        }
        case 272u: {
            // 272: cmp
            conditional_code = greaterThan(vec2(reg_tmp5.zyyy), vec2(reg_tmp5.yxxx));
            // 273: ifc
            if (conditional_code.x) {
                sub_274_294();
            } else {
                sub_294_307();
            }
            // 307: dp4
            reg_tmp6 = vec4(dot(reg_tmp8, reg_tmp8));
            // 308: rsq
            reg_tmp6 = vec4(rsq_safe(reg_tmp6.xxxx.x));
            // 309: mul
            reg_tmp0 = mul_safe(reg_tmp8, reg_tmp6);
        }
        case 310u: {
            // 310: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_274_294() {
    // 274: ifc
    if (conditional_code.y) {
        sub_275_280();
    } else {
        sub_280_293();
    }
    // 293: mov
    reg_tmp8.w = (-reg_tmp8).w;
    return false;
}
bool sub_275_280() {
    // 275: mul
    reg_tmp8 = mul_safe(reg_tmp13.yyzw, reg_tmp6.xxxy);
    // 276: add
    reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
    // 277: add
    reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
    // 278: add
    reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
    // 279: add
    reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
    return false;
}
bool sub_280_293() {
    // 280: cmp
    conditional_code = greaterThan(vec2(reg_tmp5.zzzz), vec2(reg_tmp5.xxxx));
    // 281: mul
    reg_tmp8 = mul_safe(reg_tmp13.yyzw, reg_tmp6.xxxy);
    // 282: add
    reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
    // 283: ifc
    if (conditional_code.x) {
        sub_284_287();
    } else {
        sub_287_292();
    }
    // 292: nop
    return false;
}
bool sub_284_287() {
    // 284: add
    reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
    // 285: add
    reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
    // 286: add
    reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
    return false;
}
bool sub_287_292() {
    // 287: mul
    reg_tmp8 = mul_safe(reg_tmp13.zwwy, reg_tmp6.xxxy);
    // 288: add
    reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
    // 289: add
    reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
    // 290: add
    reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
    // 291: add
    reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
    return false;
}
bool sub_294_307() {
    // 294: ifc
    if (conditional_code.y) {
        sub_295_300();
    } else {
        sub_300_306();
    }
    // 306: nop
    return false;
}
bool sub_295_300() {
    // 295: mul
    reg_tmp8 = mul_safe(reg_tmp13.yywz, reg_tmp6.xxxy);
    // 296: add
    reg_tmp8.y = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).y;
    // 297: add
    reg_tmp9 = reg_tmp5.yyyy + -reg_tmp5.xxxx;
    // 298: add
    reg_tmp8.xzw = (reg_tmp8 + reg_tmp14.wwyx).xzw;
    // 299: add
    reg_tmp8.y = (reg_tmp9 + reg_tmp8).y;
    return false;
}
bool sub_300_306() {
    // 300: mul
    reg_tmp8 = mul_safe(reg_tmp13.zwwy, reg_tmp6.xxxy);
    // 301: add
    reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
    // 302: add
    reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
    // 303: add
    reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
    // 304: add
    reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
    // 305: mov
    reg_tmp8.w = (-reg_tmp8).w;
    return false;
}
bool sub_311_321() {
    // 311: mov
    reg_tmp0.y = (uniforms.f[7].wwww).y;
    // 312: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.xyyy));
    // 313: mov
    reg_tmp9 = uniforms.f[21];
    // 314: mul
    reg_tmp0 = mul_safe(uniforms.f[7].wwww, vs_in_reg3);
    // 315: ifc
    if (conditional_code.y) {
        sub_316_320();
    }
    // 320: max
    vs_out_attr3 = max(uniforms.f[93].xxxx, reg_tmp9);
    return false;
}
bool sub_316_320() {
    // 316: ifu
    if (uniforms.b[7]) {
        sub_317_318();
    }
    // 318: mul
    reg_tmp9.xyz = (mul_safe(uniforms.f[20].wwww, reg_tmp0.xyzz)).xyz;
    // 319: mov
    reg_tmp8.x = (uniforms.f[93].yyyy).x;
    return false;
}
bool sub_317_318() {
    // 317: mul
    reg_tmp9.w = (mul_safe(reg_tmp9.wwww, reg_tmp0.wwww)).w;
    return false;
}
bool sub_321_348() {
    // 321: mov
    reg_tmp0.xy = (uniforms.f[10].xxxx).xy;
    // 322: ifu
    if (uniforms.b[9]) {
        sub_323_328();
    } else {
        sub_328_347();
    }
    // 347: nop
    return false;
}
bool sub_323_328() {
    // 323: call
    {
        sub_348_356();
    }
    // 324: dp4
    reg_tmp3.x = dot(uniforms.f[11].xywz, reg_tmp6);
    // 325: dp4
    reg_tmp3.y = dot(uniforms.f[12].xywz, reg_tmp6);
    // 326: mov
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    // 327: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_328_347() {
    // 328: cmp
    conditional_code = equal(vec2(uniforms.f[95].xyyy), vec2(reg_tmp0.xyyy));
    // 329: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 330: ifc
    if (all(not(conditional_code))) {
        sub_331_337();
    } else {
        sub_337_346();
    }
    // 346: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_331_337() {
    // 331: mov
    reg_tmp6 = reg_tmp10;
    // 332: dp4
    reg_tmp3.x = dot(uniforms.f[11], reg_tmp6);
    // 333: dp4
    reg_tmp3.y = dot(uniforms.f[12], reg_tmp6);
    // 334: dp4
    reg_tmp3.z = dot(uniforms.f[13], reg_tmp6);
    // 335: mul
    reg_tmp0.xy = (mul_safe(uniforms.f[19].xyyy, reg_tmp3.zzzz)).xy;
    // 336: add
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_337_346() {
    // 337: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_338_342();
    } else {
        sub_342_345();
    }
    // 345: nop
    return false;
}
bool sub_338_342() {
    // 338: call
    {
        sub_356_363();
    }
    // 339: dp3
    reg_tmp3.x = dot(vec3(uniforms.f[11]), vec3(reg_tmp6));
    // 340: dp3
    reg_tmp3.y = dot(vec3(uniforms.f[12]), vec3(reg_tmp6));
    // 341: dp3
    reg_tmp3.z = dot(vec3(uniforms.f[13]), vec3(reg_tmp6));
    return false;
}
bool sub_342_345() {
    // 342: call
    {
        sub_363_367();
    }
    // 343: dp4
    reg_tmp3.x = dot(uniforms.f[11], reg_tmp6);
    // 344: dp4
    reg_tmp3.y = dot(uniforms.f[12], reg_tmp6);
    return false;
}
bool sub_348_356() {
    // 348: cmp
    conditional_code = equal(vec2(uniforms.f[93].yzzz), vec2(reg_tmp0.xyyy));
    // 349: ifc
    if (all(not(conditional_code))) {
        sub_350_351();
    } else {
        sub_351_355();
    }
    // 355: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_350_351() {
    // 350: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
    return false;
}
bool sub_351_355() {
    // 351: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_352_353();
    } else {
        sub_353_354();
    }
    // 354: nop
    return false;
}
bool sub_352_353() {
    // 352: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
    return false;
}
bool sub_353_354() {
    // 353: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
    return false;
}
bool sub_356_363() {
    // 356: mov
    reg_tmp2 = -reg_tmp15;
    // 357: dp3
    reg_tmp2.w = dot(vec3(reg_tmp2), vec3(reg_tmp2));
    // 358: rsq
    reg_tmp2.w = rsq_safe(reg_tmp2.wwww.x);
    // 359: mul
    reg_tmp2 = mul_safe(reg_tmp2, reg_tmp2.wwww);
    // 360: dp3
    reg_tmp1 = vec4(dot(vec3(reg_tmp2), vec3(reg_tmp14)));
    // 361: add
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    // 362: mad
    reg_tmp6 = fma_safe(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_363_367() {
    // 363: mov
    reg_tmp1.xy = (uniforms.f[94].zzzz).xy;
    // 364: mov
    reg_tmp1.zw = (uniforms.f[93].xxxx).zw;
    // 365: mad
    reg_tmp6 = fma_safe(reg_tmp14, reg_tmp1, reg_tmp1);
    // 366: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_367_391() {
    // 367: mov
    reg_tmp0.xy = (uniforms.f[10].yyyy).xy;
    // 368: ifu
    if (uniforms.b[10]) {
        sub_369_373();
    } else {
        sub_373_390();
    }
    // 390: nop
    return false;
}
bool sub_369_373() {
    // 369: call
    {
        sub_348_356();
    }
    // 370: dp4
    reg_tmp4.x = dot(uniforms.f[14].xywz, reg_tmp6);
    // 371: dp4
    reg_tmp4.y = dot(uniforms.f[15].xywz, reg_tmp6);
    // 372: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_373_390() {
    // 373: ifu
    if (uniforms.b[13]) {
        sub_374_388();
    } else {
        sub_388_389();
    }
    // 389: nop
    return false;
}
bool sub_374_388() {
    // 374: cmp
    conditional_code = equal(vec2(uniforms.f[95].xyyy), vec2(reg_tmp0.xyyy));
    // 375: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 376: ifc
    if (all(not(conditional_code))) {
        sub_377_384();
    } else {
        sub_384_387();
    }
    // 387: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_377_384() {
    // 377: mov
    reg_tmp6 = reg_tmp10;
    // 378: dp4
    reg_tmp4.x = dot(uniforms.f[14], reg_tmp6);
    // 379: dp4
    reg_tmp4.y = dot(uniforms.f[15], reg_tmp6);
    // 380: dp4
    reg_tmp4.z = dot(uniforms.f[16], reg_tmp6);
    // 381: rcp
    reg_tmp6.w = rcp_safe(reg_tmp4.zzzz.x);
    // 382: mul
    reg_tmp4.xy = (mul_safe(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    // 383: add
    reg_tmp4.xy = (uniforms.f[19].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_384_387() {
    // 384: call
    {
        sub_363_367();
    }
    // 385: dp4
    reg_tmp4.x = dot(uniforms.f[14], reg_tmp6);
    // 386: dp4
    reg_tmp4.y = dot(uniforms.f[15], reg_tmp6);
    return false;
}
bool sub_388_389() {
    // 388: mov
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_407_4096() {
    // 407: call
    {
        sub_34_218();
    }
    // 408: call
    {
        sub_311_321();
    }
    // 409: call
    {
        sub_321_348();
    }
    // 410: call
    {
        sub_367_391();
    }
    // 411: end
    return true;
}
// reference: B6CED4A6D6819D46, 65138AC5CA635BBF
// shader: 8B30, D1080BEE730275ED

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor1.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 7BA56E25B5416F8C, D1080BEE730275ED
// program: 65138AC5CA635BBF, 3B3AE026C742C7D5, D1080BEE730275ED
// reference: 7B8090440F2511A0, DEFAC6F185DB6EB9
// shader: 8B30, 871AB913AEE1988A

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.a = (lut_scale_fr * LookupLightingLUTUnsigned(3, max(dot(normal, normalize(view)), 0.0)));
specular_sum.a = (lut_scale_fr * LookupLightingLUTUnsigned(3, max(dot(normal, normalize(view)), 0.0)));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (primary_fragment_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (const_color[2].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: C57738E4CE063932, 871AB913AEE1988A
// program: DEFAC6F185DB6EB9, 6CF3F3B70E23AA85, 871AB913AEE1988A
// shader: 8B30, 14FCCA2A8365EF09

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0 * 2.0, alpha_output_0 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 8B3F3A8908FCCF76, 14FCCA2A8365EF09
// program: DEFAC6F185DB6EB9, 6CF3F3B70E23AA85, 14FCCA2A8365EF09
// shader: 8B30, 36CA1B64DD9336C3

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 8B3F3A892E33BE25, 36CA1B64DD9336C3
// program: DEFAC6F185DB6EB9, 6CF3F3B70E23AA85, 36CA1B64DD9336C3
// shader: 8B31, 3295BFC9E1117A37

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define fma_safe(x, y, z) fma(x, y, z)
#define mul_safe(x, y) (x * y)
#define rcp_safe(x) (1.0f / x)
#define rsq_safe(x) inversesqrt(x)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_8();
bool sub_9_32();
bool sub_33_96();
bool sub_97_113();
bool sub_146_166();
bool sub_167_259();
bool sub_190_192();
bool sub_194_195();
bool sub_197_198();
bool sub_200_202();
bool sub_232_234();
bool sub_236_237();
bool sub_239_240();
bool sub_242_244();
bool sub_260_4096();
bool sub_280_281();
bool sub_281_282();

bool exec_shader() {
    sub_260_4096();
    return true;
}

bool sub_0_8() {
    // 0: mova
    address_registers.x = (ivec2(vs_in_reg0.zzzz)).x;
    // 1: mov
    reg_tmp10 = uniforms.f[0].xxxz;
    // 2: mov
    reg_tmp10.xy = (vs_in_reg0.xyyy).xy;
    // 3: mov
    reg_tmp11 = uniforms.f[0].xxxx;
    // 4: mov
    reg_tmp12 = uniforms.f[0].xxxx;
    // 5: mov
    reg_tmp13 = uniforms.f[0].zzzz;
    // 6: mov
    reg_tmp4 = uniforms.f[0].xxxx;
    // 7: mov
    reg_tmp5 = uniforms.f[0].xxxx;
    return false;
}
bool sub_9_32() {
    // 9: mov
    vs_out_attr0 = reg_tmp10;
    // 10: mul
    reg_tmp13 = mul_safe(uniforms.f[82], reg_tmp13);
    // 11: mov
    vs_out_attr1 = reg_tmp13;
    // 12: add
    reg_tmp11.y = (uniforms.f[0].zzzz + -reg_tmp11.yyyy).y;
    // 13: add
    reg_tmp12.y = (uniforms.f[0].zzzz + -reg_tmp12.yyyy).y;
    // 14: mov
    reg_tmp14.y = (uniforms.f[81].wwww).y;
    // 15: mul
    reg_tmp14.x = (mul_safe(uniforms.f[0].wwww, reg_tmp14.yyyy)).x;
    // 16: rcp
    reg_tmp2.x = rcp_safe(reg_tmp14.xxxx.x);
    // 17: mov
    reg_tmp14.z = (reg_tmp2.xxxx).z;
    // 18: add
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp11.xyyy).xy;
    // 19: mul
    reg_tmp5.xy = (mul_safe(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    // 20: flr
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    // 21: mul
    reg_tmp4.xy = (mul_safe(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    // 22: add
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    // 23: add
    reg_tmp11.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    // 24: add
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp12.xyyy).xy;
    // 25: mul
    reg_tmp5.xy = (mul_safe(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    // 26: flr
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    // 27: mul
    reg_tmp4.xy = (mul_safe(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    // 28: add
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    // 29: add
    reg_tmp12.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    // 30: mov
    vs_out_attr2 = reg_tmp11;
    // 31: mov
    vs_out_attr3 = reg_tmp12;
    return false;
}
bool sub_33_96() {
    // 33: mov
    reg_tmp6.xyz = (-reg_tmp0.xyzz).xyz;
    // 34: mov
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    // 35: rcp
    reg_tmp7.xyz = vec3(rcp_safe(uniforms.f[81].yyyy.x));
    // 36: madi
    reg_tmp8.xyz = (fma_safe(reg_tmp6.xyzz, reg_tmp7.xyzz, uniforms.f[0].yyyy)).xyz;
    // 37: flr
    reg_tmp7.xyz = (floor(reg_tmp8.xyzz)).xyz;
    // 38: mad
    reg_tmp6.xyz = (fma_safe(reg_tmp7.xyzz, -uniforms.f[81].yyyy, reg_tmp6.xyzz)).xyz;
    // 39: min
    reg_tmp6 = min(uniforms.f[81].xxxx, reg_tmp6);
    // 40: max
    reg_tmp6 = max(-uniforms.f[81].xxxx, reg_tmp6);
    // 41: mov
    reg_tmp2 = uniforms.f[95];
    // 42: mov
    reg_tmp3 = uniforms.f[94];
    // 43: mul
    reg_tmp1.z = (mul_safe(reg_tmp6.xxxx, reg_tmp6.xxxx)).z;
    // 44: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 45: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 46: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 47: mov
    reg_tmp2 = uniforms.f[93];
    // 48: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 49: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 50: mul
    reg_tmp1.y = (mul_safe(reg_tmp1.yyyy, reg_tmp6.xxxx)).y;
    // 51: mov
    reg_tmp4.x = (reg_tmp1.xxxx).x;
    // 52: mov
    reg_tmp5.x = (reg_tmp1.yyyy).x;
    // 53: mov
    reg_tmp2 = uniforms.f[95];
    // 54: mov
    reg_tmp3 = uniforms.f[94];
    // 55: mul
    reg_tmp1.z = (mul_safe(reg_tmp6.yyyy, reg_tmp6.yyyy)).z;
    // 56: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 57: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 58: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 59: mov
    reg_tmp2 = uniforms.f[93];
    // 60: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 61: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 62: mul
    reg_tmp1.y = (mul_safe(reg_tmp1.yyyy, reg_tmp6.yyyy)).y;
    // 63: mov
    reg_tmp4.y = (reg_tmp1.xxxx).y;
    // 64: mov
    reg_tmp5.y = (reg_tmp1.yyyy).y;
    // 65: mov
    reg_tmp2 = uniforms.f[95];
    // 66: mov
    reg_tmp3 = uniforms.f[94];
    // 67: mul
    reg_tmp1.z = (mul_safe(reg_tmp6.zzzz, reg_tmp6.zzzz)).z;
    // 68: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 69: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 70: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 71: mov
    reg_tmp2 = uniforms.f[93];
    // 72: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 73: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 74: mul
    reg_tmp1.y = (mul_safe(reg_tmp1.yyyy, reg_tmp6.zzzz)).y;
    // 75: mov
    reg_tmp4.z = (reg_tmp1.xxxx).z;
    // 76: mov
    reg_tmp5.z = (reg_tmp1.yyyy).z;
    // 77: mul
    reg_tmp2.x = (mul_safe(reg_tmp4.yyyy, reg_tmp5.zzzz)).x;
    // 78: mul
    reg_tmp2.y = (mul_safe(reg_tmp5.yyyy, reg_tmp5.zzzz)).y;
    // 79: mul
    reg_tmp6.x = (mul_safe(reg_tmp4.yyyy, reg_tmp4.zzzz)).x;
    // 80: mov
    reg_tmp6.y = (reg_tmp5.zzzz).y;
    // 81: mul
    reg_tmp6.z = (mul_safe(-reg_tmp5.yyyy, reg_tmp4.zzzz)).z;
    // 82: mov
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    // 83: mul
    reg_tmp7.x = (mul_safe(-reg_tmp2.xxxx, reg_tmp4.xxxx)).x;
    // 84: mad
    reg_tmp7.x = (fma_safe(reg_tmp5.yyyy, reg_tmp5.xxxx, reg_tmp7.xxxx)).x;
    // 85: mul
    reg_tmp7.y = (mul_safe(reg_tmp4.zzzz, reg_tmp4.xxxx)).y;
    // 86: mul
    reg_tmp7.z = (mul_safe(reg_tmp2.yyyy, reg_tmp4.xxxx)).z;
    // 87: mad
    reg_tmp7.z = (fma_safe(reg_tmp4.yyyy, reg_tmp5.xxxx, reg_tmp7.zzzz)).z;
    // 88: mov
    reg_tmp7.w = (uniforms.f[0].xxxx).w;
    // 89: mul
    reg_tmp8.x = (mul_safe(reg_tmp2.xxxx, reg_tmp5.xxxx)).x;
    // 90: mad
    reg_tmp8.x = (fma_safe(reg_tmp5.yyyy, reg_tmp4.xxxx, reg_tmp8.xxxx)).x;
    // 91: mul
    reg_tmp8.y = (mul_safe(-reg_tmp4.zzzz, reg_tmp5.xxxx)).y;
    // 92: mul
    reg_tmp8.z = (mul_safe(-reg_tmp2.yyyy, reg_tmp5.xxxx)).z;
    // 93: mad
    reg_tmp8.z = (fma_safe(reg_tmp4.yyyy, reg_tmp4.xxxx, reg_tmp8.zzzz)).z;
    // 94: mov
    reg_tmp8.w = (uniforms.f[0].xxxx).w;
    // 95: mov
    reg_tmp9 = uniforms.f[0].xxxz;
    return false;
}
bool sub_97_113() {
    // 97: mov
    reg_tmp6.x = (uniforms.f[90].xxxx).x;
    // 98: mov
    reg_tmp6.y = (uniforms.f[91].xxxx).y;
    // 99: mov
    reg_tmp6.z = (uniforms.f[92].xxxx).z;
    // 100: mov
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    // 101: mov
    reg_tmp7.x = (uniforms.f[90].yyyy).x;
    // 102: mov
    reg_tmp7.y = (uniforms.f[91].yyyy).y;
    // 103: mov
    reg_tmp7.z = (uniforms.f[92].yyyy).z;
    // 104: mov
    reg_tmp7.w = (uniforms.f[0].xxxx).w;
    // 105: mov
    reg_tmp8.x = (uniforms.f[90].zzzz).x;
    // 106: mov
    reg_tmp8.y = (uniforms.f[91].zzzz).y;
    // 107: mov
    reg_tmp8.z = (uniforms.f[92].zzzz).z;
    // 108: mov
    reg_tmp8.w = (uniforms.f[0].xxxx).w;
    // 109: mov
    reg_tmp9.x = (uniforms.f[90].wwww).x;
    // 110: mov
    reg_tmp9.y = (uniforms.f[91].wwww).y;
    // 111: mov
    reg_tmp9.z = (uniforms.f[92].wwww).z;
    // 112: mov
    reg_tmp9.w = (uniforms.f[0].zzzz).w;
    return false;
}
bool sub_146_166() {
    // 146: mov
    reg_tmp2 = uniforms.f[90];
    // 147: mov
    reg_tmp3 = uniforms.f[91];
    // 148: mov
    reg_tmp4 = uniforms.f[92];
    // 149: mov
    reg_tmp5 = uniforms.f[0].xxxz;
    // 150: mul
    reg_tmp6 = mul_safe(uniforms.f[86].xxxx, reg_tmp2);
    // 151: mad
    reg_tmp6 = fma_safe(reg_tmp3, uniforms.f[86].yyyy, reg_tmp6);
    // 152: mad
    reg_tmp6 = fma_safe(reg_tmp4, uniforms.f[86].zzzz, reg_tmp6);
    // 153: mad
    reg_tmp6 = fma_safe(reg_tmp5, uniforms.f[86].wwww, reg_tmp6);
    // 154: mul
    reg_tmp7 = mul_safe(uniforms.f[87].xxxx, reg_tmp2);
    // 155: mad
    reg_tmp7 = fma_safe(reg_tmp3, uniforms.f[87].yyyy, reg_tmp7);
    // 156: mad
    reg_tmp7 = fma_safe(reg_tmp4, uniforms.f[87].zzzz, reg_tmp7);
    // 157: mad
    reg_tmp7 = fma_safe(reg_tmp5, uniforms.f[87].wwww, reg_tmp7);
    // 158: mul
    reg_tmp8 = mul_safe(uniforms.f[88].xxxx, reg_tmp2);
    // 159: mad
    reg_tmp8 = fma_safe(reg_tmp3, uniforms.f[88].yyyy, reg_tmp8);
    // 160: mad
    reg_tmp8 = fma_safe(reg_tmp4, uniforms.f[88].zzzz, reg_tmp8);
    // 161: mad
    reg_tmp8 = fma_safe(reg_tmp5, uniforms.f[88].wwww, reg_tmp8);
    // 162: mul
    reg_tmp9 = mul_safe(uniforms.f[89].xxxx, reg_tmp2);
    // 163: mad
    reg_tmp9 = fma_safe(reg_tmp3, uniforms.f[89].yyyy, reg_tmp9);
    // 164: mad
    reg_tmp9 = fma_safe(reg_tmp4, uniforms.f[89].zzzz, reg_tmp9);
    // 165: mad
    reg_tmp9 = fma_safe(reg_tmp5, uniforms.f[89].wwww, reg_tmp9);
    return false;
}
bool sub_167_259() {
    // 167: rcp
    reg_tmp2.x = rcp_safe(uniforms.f[81].yyyy.x);
    // 168: mul
    reg_tmp2.xy = (mul_safe(uniforms.f[2 + address_registers.x].zwww, reg_tmp2.xxxx)).xy;
    // 169: add
    reg_tmp2.xy = (uniforms.f[0].yyyy + reg_tmp2.xyyy).xy;
    // 170: flr
    reg_tmp3.xy = (floor(reg_tmp2.xyyy)).xy;
    // 171: mul
    reg_tmp2.xy = (mul_safe(uniforms.f[81].yyyy, reg_tmp3.xyyy)).xy;
    // 172: add
    reg_tmp2.xy = (uniforms.f[2 + address_registers.x].zwww + -reg_tmp2.xyyy).xy;
    // 173: min
    reg_tmp0.xy = (min(uniforms.f[81].xxxx, -reg_tmp2.xyyy)).xy;
    // 174: max
    reg_tmp0.xy = (max(-uniforms.f[81].xxxx, reg_tmp0.xyyy)).xy;
    // 175: mov
    reg_tmp2 = uniforms.f[95];
    // 176: mov
    reg_tmp3 = uniforms.f[94];
    // 177: mul
    reg_tmp1.z = (mul_safe(reg_tmp0.xxxx, reg_tmp0.xxxx)).z;
    // 178: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 179: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 180: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 181: mov
    reg_tmp2 = uniforms.f[93];
    // 182: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 183: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 184: mul
    reg_tmp1.y = (mul_safe(reg_tmp1.yyyy, reg_tmp0.xxxx)).y;
    // 185: mov
    reg_tmp5.x = (uniforms.f[5 + address_registers.x].wwww).x;
    // 186: mov
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    // 187: mov
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    // 188: cmp
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    // 189: ifc
    if (conditional_code.x) {
        sub_190_192();
    }
    // 192: cmp
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    // 193: ifc
    if (conditional_code.x) {
        sub_194_195();
    }
    // 195: cmp
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 196: ifc
    if (conditional_code.x) {
        sub_197_198();
    }
    // 198: cmp
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 199: ifc
    if (conditional_code.x) {
        sub_200_202();
    }
    // 202: mul
    reg_tmp4.xy = (mul_safe(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    // 203: mad
    reg_tmp4.x = (fma_safe(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    // 204: mad
    reg_tmp4.y = (fma_safe(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    // 205: add
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    // 206: add
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    // 207: mov
    reg_tmp4.z = (uniforms.f[83].xxxx).z;
    // 208: mov
    reg_tmp4.w = (-uniforms.f[83].yyyy).w;
    // 209: madi
    reg_tmp5.xy = (fma_safe(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[3 + address_registers.x].xyyy)).xy;
    // 210: mov
    reg_tmp4.z = (-uniforms.f[3 + address_registers.x].zzzz).z;
    // 211: mov
    reg_tmp4.w = (-uniforms.f[3 + address_registers.x].wwww).w;
    // 212: add
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    // 213: add
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    // 214: mad
    reg_tmp5.x = (fma_safe(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    // 215: mad
    reg_tmp5.y = (fma_safe(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    // 216: mov
    reg_tmp11.xy = (reg_tmp5.xyyy).xy;
    // 217: mov
    reg_tmp2 = uniforms.f[95];
    // 218: mov
    reg_tmp3 = uniforms.f[94];
    // 219: mul
    reg_tmp1.z = (mul_safe(reg_tmp0.yyyy, reg_tmp0.yyyy)).z;
    // 220: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 221: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 222: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 223: mov
    reg_tmp2 = uniforms.f[93];
    // 224: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 225: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 226: mul
    reg_tmp1.y = (mul_safe(reg_tmp1.yyyy, reg_tmp0.yyyy)).y;
    // 227: mov
    reg_tmp5.x = (uniforms.f[6 + address_registers.x].wwww).x;
    // 228: mov
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    // 229: mov
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    // 230: cmp
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    // 231: ifc
    if (conditional_code.x) {
        sub_232_234();
    }
    // 234: cmp
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    // 235: ifc
    if (conditional_code.x) {
        sub_236_237();
    }
    // 237: cmp
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 238: ifc
    if (conditional_code.x) {
        sub_239_240();
    }
    // 240: cmp
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 241: ifc
    if (conditional_code.x) {
        sub_242_244();
    }
    // 244: mul
    reg_tmp4.xy = (mul_safe(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    // 245: mad
    reg_tmp4.x = (fma_safe(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    // 246: mad
    reg_tmp4.y = (fma_safe(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    // 247: add
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    // 248: add
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    // 249: mov
    reg_tmp4.z = (uniforms.f[83].zzzz).z;
    // 250: mov
    reg_tmp4.w = (-uniforms.f[83].wwww).w;
    // 251: madi
    reg_tmp5.xy = (fma_safe(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[4 + address_registers.x].xyyy)).xy;
    // 252: mov
    reg_tmp4.z = (-uniforms.f[4 + address_registers.x].zzzz).z;
    // 253: mov
    reg_tmp4.w = (-uniforms.f[4 + address_registers.x].wwww).w;
    // 254: add
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    // 255: add
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    // 256: mad
    reg_tmp5.x = (fma_safe(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    // 257: mad
    reg_tmp5.y = (fma_safe(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    // 258: mov
    reg_tmp12.xy = (reg_tmp5.xyyy).xy;
    return false;
}
bool sub_190_192() {
    // 190: mov
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    // 191: mov
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_194_195() {
    // 194: mov
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_197_198() {
    // 197: mov
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_200_202() {
    // 200: mov
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    // 201: mov
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_232_234() {
    // 232: mov
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    // 233: mov
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_236_237() {
    // 236: mov
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_239_240() {
    // 239: mov
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_242_244() {
    // 242: mov
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    // 243: mov
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_260_4096() {
    // 260: call
    {
        sub_0_8();
    }
    // 261: add
    reg_tmp10.xy = (uniforms.f[84].xyyy + reg_tmp10.xyyy).xy;
    // 262: mul
    reg_tmp10.xy = (mul_safe(uniforms.f[2 + address_registers.x].xyyy, reg_tmp10.xyyy)).xy;
    // 263: mov
    reg_tmp0 = uniforms.f[7 + address_registers.x];
    // 264: call
    {
        sub_33_96();
    }
    // 265: dp4
    reg_tmp2.x = dot(reg_tmp10, reg_tmp6);
    // 266: dp4
    reg_tmp2.y = dot(reg_tmp10, reg_tmp7);
    // 267: dp4
    reg_tmp2.z = dot(reg_tmp10, reg_tmp8);
    // 268: dp4
    reg_tmp2.w = dot(reg_tmp10, reg_tmp9);
    // 269: mov
    reg_tmp10 = reg_tmp2;
    // 270: call
    {
        sub_97_113();
    }
    // 271: dp4
    reg_tmp2.x = dot(reg_tmp10, reg_tmp6);
    // 272: dp4
    reg_tmp2.y = dot(reg_tmp10, reg_tmp7);
    // 273: dp4
    reg_tmp2.z = dot(reg_tmp10, reg_tmp8);
    // 274: dp4
    reg_tmp2.w = dot(uniforms.f[0].xxxz, reg_tmp10);
    // 275: mov
    reg_tmp3.xyz = (uniforms.f[5 + address_registers.x].xyzz).xyz;
    // 276: add
    reg_tmp3.xyz = (uniforms.f[85].xyzz + -reg_tmp3.xyzz).xyz;
    // 277: dp3
    reg_tmp4.x = dot(vec3(reg_tmp3.xyzz), vec3(reg_tmp3.xyzz));
    // 278: cmp
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
    // 279: ifc
    if (conditional_code.x) {
        sub_280_281();
    } else {
        sub_281_282();
    }
    // 282: mul
    reg_tmp3.xyz = (mul_safe(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
    // 283: add
    reg_tmp10.xyz = (uniforms.f[5 + address_registers.x].xyzz + reg_tmp2.xyzz).xyz;
    // 284: mad
    reg_tmp10.xyz = (fma_safe(reg_tmp3.xyzz, uniforms.f[84].zzzz, reg_tmp10.xyzz)).xyz;
    // 285: call
    {
        sub_146_166();
    }
    // 286: mov
    reg_tmp2 = reg_tmp10;
    // 287: dp4
    reg_tmp10.x = dot(reg_tmp2, reg_tmp6);
    // 288: dp4
    reg_tmp10.y = dot(reg_tmp2, reg_tmp7);
    // 289: dp4
    reg_tmp10.z = dot(reg_tmp2, reg_tmp8);
    // 290: dp4
    reg_tmp10.w = dot(reg_tmp2, reg_tmp9);
    // 291: mov
    reg_tmp2 = uniforms.f[1 + address_registers.x];
    // 292: max
    reg_tmp3 = max(uniforms.f[0].xxxx, reg_tmp2);
    // 293: min
    reg_tmp2 = min(uniforms.f[0].zzzz, reg_tmp3);
    // 294: mov
    reg_tmp13 = reg_tmp2;
    // 295: call
    {
        sub_167_259();
    }
    // 296: call
    {
        sub_9_32();
    }
    // 297: end
    return true;
}
bool sub_280_281() {
    // 280: mov
    reg_tmp4.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_281_282() {
    // 281: rsq
    reg_tmp4.x = rsq_safe(reg_tmp4.xxxx.x);
    return false;
}
// reference: 6749AE3C8145241C, 3295BFC9E1117A37
// shader: 8DD9, CEF02063E9A18B2F

layout(triangles) in;
layout(triangle_strip, max_vertices = 3) out;

out vec4 primary_color;
out vec2 texcoord0;
out vec2 texcoord1;
out vec2 texcoord2;
out float texcoord0_w;
out vec4 normquat;
out vec3 view;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

 in vec4 vs_out_attr0[];
 in vec4 vs_out_attr1[];
 in vec4 vs_out_attr2[];
 in vec4 vs_out_attr3[];

struct Vertex {
    vec4 attributes[4];
};

vec4 GetVertexQuaternion(Vertex vtx) {
    return vec4(0.0, 0.0, 0.0, 0.0);
}

void EmitVtx(Vertex vtx, bool quats_opposite) {
    vec4 vtx_pos = vec4(vtx.attributes[0].x, vtx.attributes[0].y, vtx.attributes[0].z, vtx.attributes[0].w);
    gl_Position = vtx_pos;
#if !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)
    gl_ClipDistance[0] = -vtx_pos.z;
    gl_ClipDistance[1] = dot(clip_coef, vtx_pos);
#endif // !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)

    vec4 vtx_quat = GetVertexQuaternion(vtx);
    normquat = mix(vtx_quat, -vtx_quat, bvec4(quats_opposite));

    vec4 vtx_color = vec4(vtx.attributes[1].x, vtx.attributes[1].y, vtx.attributes[1].z, vtx.attributes[1].w);
    primary_color = min(abs(vtx_color), vec4(1.0));

    texcoord0 = vec2(vtx.attributes[2].x, vtx.attributes[2].y);
    texcoord1 = vec2(vtx.attributes[3].x, vtx.attributes[3].y);

    texcoord0_w = 0.0;
    view = vec3(0.0, 0.0, 0.0);

    texcoord2 = vec2(0.0, 0.0);

    EmitVertex();
}

bool AreQuaternionsOpposite(vec4 qa, vec4 qb) {
    return (dot(qa, qb) < 0.0);
}

void EmitPrim(Vertex vtx0, Vertex vtx1, Vertex vtx2) {
    EmitVtx(vtx0, false);
    EmitVtx(vtx1, AreQuaternionsOpposite(GetVertexQuaternion(vtx0), GetVertexQuaternion(vtx1)));
    EmitVtx(vtx2, AreQuaternionsOpposite(GetVertexQuaternion(vtx0), GetVertexQuaternion(vtx2)));
    EndPrimitive();
}

void main() {
    Vertex prim_buffer[3];
    prim_buffer[0].attributes = vec4[4](vs_out_attr0[0], vs_out_attr1[0], vs_out_attr2[0], vs_out_attr3[0]);
    prim_buffer[1].attributes = vec4[4](vs_out_attr0[1], vs_out_attr1[1], vs_out_attr2[1], vs_out_attr3[1]);
    prim_buffer[2].attributes = vec4[4](vs_out_attr0[2], vs_out_attr1[2], vs_out_attr2[2], vs_out_attr3[2]);
    EmitPrim(prim_buffer[0], prim_buffer[1], prim_buffer[2]);
}
// reference: A55C6948CCF76B42, CEF02063E9A18B2F
// shader: 8B30, C0234F4E2DEC3D4D

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 5CCCF89DC472A1B8, C0234F4E2DEC3D4D
// program: 3295BFC9E1117A37, CEF02063E9A18B2F, C0234F4E2DEC3D4D
// reference: ECA979935AFC855B, 3295BFC9E1117A37
// reference: 2132B078E0E1BACB, DEFAC6F185DB6EB9
// shader: 8B30, 35EA3527A49BC4B5

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 558E609643E66C2A, 35EA3527A49BC4B5
// program: DEFAC6F185DB6EB9, 6CF3F3B70E23AA85, 35EA3527A49BC4B5
// reference: AAD267D73B581B8C, DEFAC6F185DB6EB9
// shader: 8B30, 665EE456131D3E7B

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 8B3F3A894E8DF1AE, 665EE456131D3E7B
// program: DEFAC6F185DB6EB9, 6CF3F3B70E23AA85, 665EE456131D3E7B
// reference: 8467D83E66D884F0, D82E12A9D19ACD63
// reference: 94D8F324365F39E0, 70D24D55BDEC0B06
// reference: 1F38248BEDE698A7, 70D24D55BDEC0B06
// reference: CA59740C6DBBE52F, DEFAC6F185DB6EB9
// reference: 2B1604F9B5416F8C, D1080BEE730275ED
// reference: 5B37ECAF8E4F9349, D82E12A9D19ACD63
// reference: DB8C505541904923, 4276C3E7186D8D1B
// reference: 8B3F3A891E3E9B72, 665EE456131D3E7B
// reference: B3BF2E967932FB14, 7D251428D9104055
// reference: DB8C50551E3E9B72, 665EE456131D3E7B
// reference: 95C45238CE063932, 871AB913AEE1988A
// reference: DB8C505508FCCF76, 14FCCA2A8365EF09
// reference: DB8C50552E33BE25, 36CA1B64DD9336C3
// reference: D0D73B0055F6320E, D82E12A9D19ACD63
// reference: 32836422EC3789FF, 089F98A92317B4E3
// reference: C57738E49EB553EE, 871AB913AEE1988A
// reference: 7BA56E25E5F20550, D1080BEE730275ED
// reference: 62300EFEBC84E323, 089F98A92317B4E3
// reference: E30C444A298191C8, 7D251428D9104055
// reference: 8B3F3A89112323FF, 4276C3E7186D8D1B
// shader: 8B30, 4982B44D494E20C9

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D4F4BEF9BD73912B, 4982B44D494E20C9
// program: D82E12A9D19ACD63, 5D764F9A6220D694, 4982B44D494E20C9
// shader: 8B30, 6B4333F5156E44E0

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) == alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: CE312E68729CB9C7, 6B4333F5156E44E0
// program: D82E12A9D19ACD63, 5D764F9A6220D694, 6B4333F5156E44E0
// shader: 8B30, 53682975156E44E0

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) != alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: CE312E68156B2DB1, 53682975156E44E0
// program: D82E12A9D19ACD63, 5D764F9A6220D694, 53682975156E44E0
// shader: 8B30, C6D1945D8824B670

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 2824FA3498410408, C6D1945D8824B670
// program: DEFAC6F185DB6EB9, 6CF3F3B70E23AA85, C6D1945D8824B670
// shader: 8B30, CB1D52E704993510

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 9637A5319BF07B14, CB1D52E704993510
// program: DEFAC6F185DB6EB9, 6CF3F3B70E23AA85, CB1D52E704993510
// reference: E194312DD6819D46, 65138AC5CA635BBF
// shader: 8B30, 35C20F26F3839710

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (textureProj(tex0, vec3(texcoord0, texcoord0_w)).a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: F26A4A663EE451FF, 35C20F26F3839710
// program: 65138AC5CA635BBF, 3B3AE026C742C7D5, 35C20F26F3839710
// shader: 8B31, 48B3A6FBA8498826

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;
 out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define fma_safe(x, y, z) fma(x, y, z)
#define mul_safe(x, y) (x * y)
#define rcp_safe(x) (1.0f / x)
#define rsq_safe(x) inversesqrt(x)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_4096();
bool sub_7_12();
bool sub_12_21();
bool sub_21_34();
bool sub_34_218();
bool sub_40_146();
bool sub_47_76();
bool sub_58_62();
bool sub_76_135();
bool sub_77_109();
bool sub_88_92();
bool sub_109_134();
bool sub_120_124();
bool sub_144_145();
bool sub_146_217();
bool sub_149_159();
bool sub_159_168();
bool sub_169_181();
bool sub_181_206();
bool sub_182_200();
bool sub_200_205();
bool sub_215_216();
bool sub_218_235();
bool sub_235_311();
bool sub_274_294();
bool sub_275_280();
bool sub_280_293();
bool sub_284_287();
bool sub_287_292();
bool sub_294_307();
bool sub_295_300();
bool sub_300_306();
bool sub_311_321();
bool sub_316_320();
bool sub_317_318();
bool sub_321_348();
bool sub_323_328();
bool sub_328_347();
bool sub_331_337();
bool sub_337_346();
bool sub_338_342();
bool sub_342_345();
bool sub_348_356();
bool sub_350_351();
bool sub_351_355();
bool sub_352_353();
bool sub_353_354();
bool sub_356_363();
bool sub_363_367();
bool sub_367_391();
bool sub_369_373();
bool sub_373_390();
bool sub_374_388();
bool sub_377_384();
bool sub_384_387();
bool sub_388_389();
bool sub_391_407();
bool sub_393_397();
bool sub_397_406();
bool sub_398_404();
bool sub_404_405();

bool exec_shader() {
    sub_0_4096();
    return true;
}

bool sub_0_4096() {
    // 0: call
    {
        sub_34_218();
    }
    // 1: call
    {
        sub_311_321();
    }
    // 2: call
    {
        sub_321_348();
    }
    // 3: call
    {
        sub_367_391();
    }
    // 4: call
    {
        sub_391_407();
    }
    // 5: end
    return true;
}
bool sub_7_12() {
    // 7: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 8: dp4
    reg_tmp3.x = dot(uniforms.f[25 + address_registers.x], reg_tmp15);
    // 9: dp4
    reg_tmp3.y = dot(uniforms.f[26 + address_registers.x], reg_tmp15);
    // 10: dp4
    reg_tmp3.z = dot(uniforms.f[27 + address_registers.x], reg_tmp15);
    // 11: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    return false;
}
bool sub_12_21() {
    // 12: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 13: dp4
    reg_tmp3.x = dot(uniforms.f[25 + address_registers.x], reg_tmp15);
    // 14: dp4
    reg_tmp3.y = dot(uniforms.f[26 + address_registers.x], reg_tmp15);
    // 15: dp4
    reg_tmp3.z = dot(uniforms.f[27 + address_registers.x], reg_tmp15);
    // 16: dp3
    reg_tmp4.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp14));
    // 17: dp3
    reg_tmp4.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp14));
    // 18: dp3
    reg_tmp4.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp14));
    // 19: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 20: mad
    reg_tmp12 = fma_safe(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_21_34() {
    // 21: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 22: dp4
    reg_tmp3.x = dot(uniforms.f[25 + address_registers.x], reg_tmp15);
    // 23: dp4
    reg_tmp3.y = dot(uniforms.f[26 + address_registers.x], reg_tmp15);
    // 24: dp4
    reg_tmp3.z = dot(uniforms.f[27 + address_registers.x], reg_tmp15);
    // 25: dp3
    reg_tmp4.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp14));
    // 26: dp3
    reg_tmp4.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp14));
    // 27: dp3
    reg_tmp4.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp14));
    // 28: dp3
    reg_tmp5.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp13));
    // 29: dp3
    reg_tmp5.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp13));
    // 30: dp3
    reg_tmp5.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp13));
    // 31: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 32: mad
    reg_tmp12 = fma_safe(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    // 33: mad
    reg_tmp11 = fma_safe(reg_tmp1.wwww, reg_tmp5, reg_tmp11);
    return false;
}
bool sub_34_218() {
    // 34: mul
    reg_tmp15.xyz = (mul_safe(uniforms.f[7].xxxx, vs_in_reg0)).xyz;
    // 35: mul
    reg_tmp14.xyz = (mul_safe(uniforms.f[7].yyyy, vs_in_reg1)).xyz;
    // 36: mul
    reg_tmp13.xyz = (mul_safe(uniforms.f[7].zzzz, vs_in_reg2)).xyz;
    // 37: add
    reg_tmp15.xyz = (uniforms.f[6] + reg_tmp15).xyz;
    // 38: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 39: ifu
    if (uniforms.b[1]) {
        sub_40_146();
    } else {
        sub_146_217();
    }
    // 217: nop
    return false;
}
bool sub_40_146() {
    // 40: mov
    reg_tmp0 = uniforms.f[7];
    // 41: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.yzzz));
    // 42: mov
    reg_tmp7 = uniforms.f[93].xxxx;
    // 43: mov
    reg_tmp12 = uniforms.f[93].xxxx;
    // 44: mov
    reg_tmp11 = uniforms.f[93].xxxx;
    // 45: mul
    reg_tmp2 = mul_safe(uniforms.f[93].wwww, vs_in_reg7);
    // 46: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_47_76();
    } else {
        sub_76_135();
    }
    // 135: mov
    vs_out_attr2 = -reg_tmp15;
    // 136: dp4
    reg_tmp0.x = dot(uniforms.f[86], reg_tmp15);
    // 137: dp4
    reg_tmp0.y = dot(uniforms.f[87], reg_tmp15);
    // 138: dp4
    reg_tmp0.z = dot(uniforms.f[88], reg_tmp15);
    // 139: dp4
    reg_tmp0.w = dot(uniforms.f[89], reg_tmp15);
    // 140: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 141: mul
    reg_tmp1.y = (mul_safe(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
    // 142: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 143: ifc
    if (all(conditional_code)) {
        sub_144_145();
    }
    // 145: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_47_76() {
    // 47: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 48: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 49: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 50: call
    {
        sub_12_21();
    }
    // 51: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 52: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 53: call
    {
        sub_12_21();
    }
    // 54: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 55: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 56: callc
    if (conditional_code.x) {
        sub_12_21();
    }
    // 57: ifu
    if (uniforms.b[8]) {
        sub_58_62();
    }
    // 62: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 63: dp4
    reg_tmp10.x = dot(uniforms.f[0], reg_tmp7);
    // 64: dp4
    reg_tmp10.y = dot(uniforms.f[1], reg_tmp7);
    // 65: dp4
    reg_tmp10.z = dot(uniforms.f[2], reg_tmp7);
    // 66: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 67: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 68: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 69: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 70: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 71: dp3
    reg_tmp14.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp12));
    // 72: dp3
    reg_tmp14.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp12));
    // 73: dp3
    reg_tmp14.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp12));
    // 74: call
    {
        sub_218_235();
    }
    // 75: nop
    return false;
}
bool sub_58_62() {
    // 58: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 59: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 60: callc
    if (conditional_code.y) {
        sub_12_21();
    }
    // 61: nop
    return false;
}
bool sub_76_135() {
    // 76: ifc
    if (all(conditional_code)) {
        sub_77_109();
    } else {
        sub_109_134();
    }
    // 134: nop
    return false;
}
bool sub_77_109() {
    // 77: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 78: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 79: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 80: call
    {
        sub_21_34();
    }
    // 81: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 82: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 83: call
    {
        sub_21_34();
    }
    // 84: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 85: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 86: callc
    if (conditional_code.x) {
        sub_21_34();
    }
    // 87: ifu
    if (uniforms.b[8]) {
        sub_88_92();
    }
    // 92: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 93: dp4
    reg_tmp10.x = dot(uniforms.f[0], reg_tmp7);
    // 94: dp4
    reg_tmp10.y = dot(uniforms.f[1], reg_tmp7);
    // 95: dp4
    reg_tmp10.z = dot(uniforms.f[2], reg_tmp7);
    // 96: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 97: dp3
    reg_tmp13.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp11));
    // 98: dp3
    reg_tmp13.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp11));
    // 99: dp3
    reg_tmp13.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp11));
    // 100: dp3
    reg_tmp14.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp12));
    // 101: dp3
    reg_tmp14.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp12));
    // 102: dp3
    reg_tmp14.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp12));
    // 103: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 104: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 105: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 106: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 107: call
    {
        sub_235_311();
    }
    // 108: nop
    return false;
}
bool sub_88_92() {
    // 88: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 89: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 90: callc
    if (conditional_code.y) {
        sub_21_34();
    }
    // 91: nop
    return false;
}
bool sub_109_134() {
    // 109: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 110: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 111: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 112: call
    {
        sub_7_12();
    }
    // 113: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 114: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 115: call
    {
        sub_7_12();
    }
    // 116: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 117: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 118: callc
    if (conditional_code.x) {
        sub_7_12();
    }
    // 119: ifu
    if (uniforms.b[8]) {
        sub_120_124();
    }
    // 124: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 125: dp4
    reg_tmp10.x = dot(uniforms.f[0], reg_tmp7);
    // 126: dp4
    reg_tmp10.y = dot(uniforms.f[1], reg_tmp7);
    // 127: dp4
    reg_tmp10.z = dot(uniforms.f[2], reg_tmp7);
    // 128: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 129: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 130: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 131: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 132: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 133: mov
    vs_out_attr1 = uniforms.f[93].xxxx;
    return false;
}
bool sub_120_124() {
    // 120: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 121: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 122: callc
    if (conditional_code.y) {
        sub_7_12();
    }
    // 123: nop
    return false;
}
bool sub_144_145() {
    // 144: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_146_217() {
    // 146: mov
    reg_tmp0 = uniforms.f[7];
    // 147: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.yzzz));
    // 148: ifu
    if (uniforms.b[2]) {
        sub_149_159();
    } else {
        sub_159_168();
    }
    // 168: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_169_181();
    } else {
        sub_181_206();
    }
    // 206: mov
    vs_out_attr2 = -reg_tmp15;
    // 207: dp4
    reg_tmp0.x = dot(uniforms.f[86], reg_tmp15);
    // 208: dp4
    reg_tmp0.y = dot(uniforms.f[87], reg_tmp15);
    // 209: dp4
    reg_tmp0.z = dot(uniforms.f[88], reg_tmp15);
    // 210: dp4
    reg_tmp0.w = dot(uniforms.f[89], reg_tmp15);
    // 211: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 212: mul
    reg_tmp1.y = (mul_safe(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
    // 213: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 214: ifc
    if (all(conditional_code)) {
        sub_215_216();
    }
    // 216: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_149_159() {
    // 149: mul
    reg_tmp1.x = (mul_safe(uniforms.f[93].wwww, vs_in_reg7.xxxx)).x;
    // 150: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 151: dp4
    reg_tmp7.x = dot(uniforms.f[25 + address_registers.x], reg_tmp15);
    // 152: dp4
    reg_tmp7.y = dot(uniforms.f[26 + address_registers.x], reg_tmp15);
    // 153: dp4
    reg_tmp7.z = dot(uniforms.f[27 + address_registers.x], reg_tmp15);
    // 154: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 155: dp4
    reg_tmp10.x = dot(uniforms.f[0], reg_tmp7);
    // 156: dp4
    reg_tmp10.y = dot(uniforms.f[1], reg_tmp7);
    // 157: dp4
    reg_tmp10.z = dot(uniforms.f[2], reg_tmp7);
    // 158: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_159_168() {
    // 159: mova
    address_registers.x = (ivec2(uniforms.f[93].xxxx)).x;
    // 160: dp4
    reg_tmp7.x = dot(uniforms.f[25], reg_tmp15);
    // 161: dp4
    reg_tmp7.y = dot(uniforms.f[26], reg_tmp15);
    // 162: dp4
    reg_tmp7.z = dot(uniforms.f[27], reg_tmp15);
    // 163: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 164: dp4
    reg_tmp10.x = dot(uniforms.f[0], reg_tmp7);
    // 165: dp4
    reg_tmp10.y = dot(uniforms.f[1], reg_tmp7);
    // 166: dp4
    reg_tmp10.z = dot(uniforms.f[2], reg_tmp7);
    // 167: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_169_181() {
    // 169: dp3
    reg_tmp12.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp14));
    // 170: dp3
    reg_tmp12.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp14));
    // 171: dp3
    reg_tmp12.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp14));
    // 172: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 173: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 174: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 175: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 176: dp3
    reg_tmp14.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp12));
    // 177: dp3
    reg_tmp14.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp12));
    // 178: dp3
    reg_tmp14.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp12));
    // 179: call
    {
        sub_218_235();
    }
    // 180: nop
    return false;
}
bool sub_181_206() {
    // 181: ifc
    if (all(conditional_code)) {
        sub_182_200();
    } else {
        sub_200_205();
    }
    // 205: nop
    return false;
}
bool sub_182_200() {
    // 182: dp3
    reg_tmp12.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp14));
    // 183: dp3
    reg_tmp12.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp14));
    // 184: dp3
    reg_tmp12.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp14));
    // 185: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp13));
    // 186: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp13));
    // 187: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp13));
    // 188: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 189: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 190: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 191: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 192: dp3
    reg_tmp14.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp12));
    // 193: dp3
    reg_tmp14.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp12));
    // 194: dp3
    reg_tmp14.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp12));
    // 195: dp3
    reg_tmp13.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp11));
    // 196: dp3
    reg_tmp13.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp11));
    // 197: dp3
    reg_tmp13.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp11));
    // 198: call
    {
        sub_235_311();
    }
    // 199: nop
    return false;
}
bool sub_200_205() {
    // 200: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 201: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 202: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 203: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 204: mov
    vs_out_attr1 = uniforms.f[93].xxxx;
    return false;
}
bool sub_215_216() {
    // 215: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_218_235() {
    uint jmp_to = 218u;
    while (true) {
        switch (jmp_to) {
        case 218u: {
            // 218: dp3
            reg_tmp6.x = dot(vec3(reg_tmp14), vec3(reg_tmp14));
            // 219: dp3
            reg_tmp7.x = dot(vec3(reg_tmp12), vec3(reg_tmp12));
            // 220: rsq
            reg_tmp6.x = rsq_safe(reg_tmp6.xxxx.x);
            // 221: rsq
            reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
            // 222: mul
            reg_tmp14.xyz = (mul_safe(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 223: mul
            reg_tmp12.xyz = (mul_safe(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 224: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 225: jmpu
            if (!uniforms.b[3]) {
                { jmp_to = 234u; break; }
            }
            // 226: add
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            // 227: mul
            reg_tmp4 = mul_safe(uniforms.f[94].zzzz, reg_tmp4);
            // 228: cmp
            conditional_code = greaterThanEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp4.xxxx));
            // 229: rsq
            reg_tmp4 = vec4(rsq_safe(reg_tmp4.xxxx.x));
            // 230: mul
            reg_tmp5 = mul_safe(uniforms.f[94].zzzz, reg_tmp14);
            // 231: jmpc
            if (conditional_code.x) {
                { jmp_to = 234u; break; }
            }
            // 232: rcp
            reg_tmp0.z = rcp_safe(reg_tmp4.xxxx.x);
            // 233: mul
            reg_tmp0.xy = (mul_safe(reg_tmp5, reg_tmp4)).xy;
        }
        case 234u: {
            // 234: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_235_311() {
    uint jmp_to = 235u;
    while (true) {
        switch (jmp_to) {
        case 235u: {
            // 235: dp3
            reg_tmp6.x = dot(vec3(reg_tmp14), vec3(reg_tmp14));
            // 236: dp3
            reg_tmp7.x = dot(vec3(reg_tmp12), vec3(reg_tmp12));
            // 237: rsq
            reg_tmp6.x = rsq_safe(reg_tmp6.xxxx.x);
            // 238: rsq
            reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
            // 239: mul
            reg_tmp14.xyz = (mul_safe(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 240: mul
            reg_tmp12.xyz = (mul_safe(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 241: mul
            reg_tmp13.xyz = (mul_safe(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            // 242: mul
            reg_tmp11.xyz = (mul_safe(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            // 243: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 244: jmpu
            if (!uniforms.b[3]) {
                { jmp_to = 310u; break; }
            }
            // 245: mul
            reg_tmp13.xyz = (mul_safe(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            // 246: mul
            reg_tmp11.xyz = (mul_safe(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            // 247: mul
            reg_tmp5 = mul_safe(reg_tmp14.yzxx, reg_tmp13.zxyy);
            // 248: mad
            reg_tmp5 = fma_safe(-reg_tmp13.yzxx, reg_tmp14.zxyy, reg_tmp5);
            // 249: dp3
            reg_tmp5.w = dot(vec3(reg_tmp5), vec3(reg_tmp5));
            // 250: rsq
            reg_tmp5.w = rsq_safe(reg_tmp5.wwww.x);
            // 251: mul
            reg_tmp5 = mul_safe(reg_tmp5, reg_tmp5.wwww);
            // 252: add
            reg_tmp6.w = (reg_tmp14.zzzz + reg_tmp5.yyyy).w;
            // 253: mul
            reg_tmp13 = mul_safe(reg_tmp5.yzxx, reg_tmp14.zxyy);
            // 254: mad
            reg_tmp13 = fma_safe(-reg_tmp14.yzxx, reg_tmp5.zxyy, reg_tmp13);
            // 255: add
            reg_tmp6.w = (reg_tmp13.xxxx + reg_tmp6).w;
            // 256: mov
            reg_tmp13.w = (reg_tmp5.zzzz).w;
            // 257: mov
            reg_tmp5.z = (reg_tmp13.xxxx).z;
            // 258: add
            reg_tmp6.w = (uniforms.f[93].yyyy + reg_tmp6).w;
            // 259: mov
            reg_tmp14.w = (reg_tmp5.xxxx).w;
            // 260: mov
            reg_tmp5.x = (reg_tmp14.zzzz).x;
            // 261: cmp
            conditional_code = lessThan(vec2(uniforms.f[94].yyyy), vec2(reg_tmp6.wwww));
            // 262: mov
            reg_tmp6.x = (uniforms.f[93].yyyy).x;
            // 263: mov
            reg_tmp6.y = (-uniforms.f[93].yyyy).y;
            // 264: jmpc
            if (!conditional_code.x) {
                { jmp_to = 272u; break; }
            }
            // 265: add
            reg_tmp7.xz = (reg_tmp13.wwyy + -reg_tmp14.yyww).xz;
            // 266: add
            reg_tmp7.y = (reg_tmp14.xxxx + -reg_tmp13.zzzz).y;
            // 267: mov
            reg_tmp7.w = (reg_tmp6).w;
            // 268: dp4
            reg_tmp6 = vec4(dot(reg_tmp7, reg_tmp7));
            // 269: rsq
            reg_tmp6 = vec4(rsq_safe(reg_tmp6.xxxx.x));
            // 270: mul
            reg_tmp0 = mul_safe(reg_tmp7, reg_tmp6);
            // 271: jmpu
            if (uniforms.b[0]) {
                { jmp_to = 310u; break; }
            }
        }
        case 272u: {
            // 272: cmp
            conditional_code = greaterThan(vec2(reg_tmp5.zyyy), vec2(reg_tmp5.yxxx));
            // 273: ifc
            if (conditional_code.x) {
                sub_274_294();
            } else {
                sub_294_307();
            }
            // 307: dp4
            reg_tmp6 = vec4(dot(reg_tmp8, reg_tmp8));
            // 308: rsq
            reg_tmp6 = vec4(rsq_safe(reg_tmp6.xxxx.x));
            // 309: mul
            reg_tmp0 = mul_safe(reg_tmp8, reg_tmp6);
        }
        case 310u: {
            // 310: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_274_294() {
    // 274: ifc
    if (conditional_code.y) {
        sub_275_280();
    } else {
        sub_280_293();
    }
    // 293: mov
    reg_tmp8.w = (-reg_tmp8).w;
    return false;
}
bool sub_275_280() {
    // 275: mul
    reg_tmp8 = mul_safe(reg_tmp13.yyzw, reg_tmp6.xxxy);
    // 276: add
    reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
    // 277: add
    reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
    // 278: add
    reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
    // 279: add
    reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
    return false;
}
bool sub_280_293() {
    // 280: cmp
    conditional_code = greaterThan(vec2(reg_tmp5.zzzz), vec2(reg_tmp5.xxxx));
    // 281: mul
    reg_tmp8 = mul_safe(reg_tmp13.yyzw, reg_tmp6.xxxy);
    // 282: add
    reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
    // 283: ifc
    if (conditional_code.x) {
        sub_284_287();
    } else {
        sub_287_292();
    }
    // 292: nop
    return false;
}
bool sub_284_287() {
    // 284: add
    reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
    // 285: add
    reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
    // 286: add
    reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
    return false;
}
bool sub_287_292() {
    // 287: mul
    reg_tmp8 = mul_safe(reg_tmp13.zwwy, reg_tmp6.xxxy);
    // 288: add
    reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
    // 289: add
    reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
    // 290: add
    reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
    // 291: add
    reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
    return false;
}
bool sub_294_307() {
    // 294: ifc
    if (conditional_code.y) {
        sub_295_300();
    } else {
        sub_300_306();
    }
    // 306: nop
    return false;
}
bool sub_295_300() {
    // 295: mul
    reg_tmp8 = mul_safe(reg_tmp13.yywz, reg_tmp6.xxxy);
    // 296: add
    reg_tmp8.y = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).y;
    // 297: add
    reg_tmp9 = reg_tmp5.yyyy + -reg_tmp5.xxxx;
    // 298: add
    reg_tmp8.xzw = (reg_tmp8 + reg_tmp14.wwyx).xzw;
    // 299: add
    reg_tmp8.y = (reg_tmp9 + reg_tmp8).y;
    return false;
}
bool sub_300_306() {
    // 300: mul
    reg_tmp8 = mul_safe(reg_tmp13.zwwy, reg_tmp6.xxxy);
    // 301: add
    reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
    // 302: add
    reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
    // 303: add
    reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
    // 304: add
    reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
    // 305: mov
    reg_tmp8.w = (-reg_tmp8).w;
    return false;
}
bool sub_311_321() {
    // 311: mov
    reg_tmp0.y = (uniforms.f[7].wwww).y;
    // 312: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.xyyy));
    // 313: mov
    reg_tmp9 = uniforms.f[21];
    // 314: mul
    reg_tmp0 = mul_safe(uniforms.f[7].wwww, vs_in_reg3);
    // 315: ifc
    if (conditional_code.y) {
        sub_316_320();
    }
    // 320: max
    vs_out_attr3 = max(uniforms.f[93].xxxx, reg_tmp9);
    return false;
}
bool sub_316_320() {
    // 316: ifu
    if (uniforms.b[7]) {
        sub_317_318();
    }
    // 318: mul
    reg_tmp9.xyz = (mul_safe(uniforms.f[20].wwww, reg_tmp0.xyzz)).xyz;
    // 319: mov
    reg_tmp8.x = (uniforms.f[93].yyyy).x;
    return false;
}
bool sub_317_318() {
    // 317: mul
    reg_tmp9.w = (mul_safe(reg_tmp9.wwww, reg_tmp0.wwww)).w;
    return false;
}
bool sub_321_348() {
    // 321: mov
    reg_tmp0.xy = (uniforms.f[10].xxxx).xy;
    // 322: ifu
    if (uniforms.b[9]) {
        sub_323_328();
    } else {
        sub_328_347();
    }
    // 347: nop
    return false;
}
bool sub_323_328() {
    // 323: call
    {
        sub_348_356();
    }
    // 324: dp4
    reg_tmp3.x = dot(uniforms.f[11].xywz, reg_tmp6);
    // 325: dp4
    reg_tmp3.y = dot(uniforms.f[12].xywz, reg_tmp6);
    // 326: mov
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    // 327: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_328_347() {
    // 328: cmp
    conditional_code = equal(vec2(uniforms.f[95].xyyy), vec2(reg_tmp0.xyyy));
    // 329: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 330: ifc
    if (all(not(conditional_code))) {
        sub_331_337();
    } else {
        sub_337_346();
    }
    // 346: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_331_337() {
    // 331: mov
    reg_tmp6 = reg_tmp10;
    // 332: dp4
    reg_tmp3.x = dot(uniforms.f[11], reg_tmp6);
    // 333: dp4
    reg_tmp3.y = dot(uniforms.f[12], reg_tmp6);
    // 334: dp4
    reg_tmp3.z = dot(uniforms.f[13], reg_tmp6);
    // 335: mul
    reg_tmp0.xy = (mul_safe(uniforms.f[19].xyyy, reg_tmp3.zzzz)).xy;
    // 336: add
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_337_346() {
    // 337: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_338_342();
    } else {
        sub_342_345();
    }
    // 345: nop
    return false;
}
bool sub_338_342() {
    // 338: call
    {
        sub_356_363();
    }
    // 339: dp3
    reg_tmp3.x = dot(vec3(uniforms.f[11]), vec3(reg_tmp6));
    // 340: dp3
    reg_tmp3.y = dot(vec3(uniforms.f[12]), vec3(reg_tmp6));
    // 341: dp3
    reg_tmp3.z = dot(vec3(uniforms.f[13]), vec3(reg_tmp6));
    return false;
}
bool sub_342_345() {
    // 342: call
    {
        sub_363_367();
    }
    // 343: dp4
    reg_tmp3.x = dot(uniforms.f[11], reg_tmp6);
    // 344: dp4
    reg_tmp3.y = dot(uniforms.f[12], reg_tmp6);
    return false;
}
bool sub_348_356() {
    // 348: cmp
    conditional_code = equal(vec2(uniforms.f[93].yzzz), vec2(reg_tmp0.xyyy));
    // 349: ifc
    if (all(not(conditional_code))) {
        sub_350_351();
    } else {
        sub_351_355();
    }
    // 355: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_350_351() {
    // 350: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
    return false;
}
bool sub_351_355() {
    // 351: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_352_353();
    } else {
        sub_353_354();
    }
    // 354: nop
    return false;
}
bool sub_352_353() {
    // 352: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
    return false;
}
bool sub_353_354() {
    // 353: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
    return false;
}
bool sub_356_363() {
    // 356: mov
    reg_tmp2 = -reg_tmp15;
    // 357: dp3
    reg_tmp2.w = dot(vec3(reg_tmp2), vec3(reg_tmp2));
    // 358: rsq
    reg_tmp2.w = rsq_safe(reg_tmp2.wwww.x);
    // 359: mul
    reg_tmp2 = mul_safe(reg_tmp2, reg_tmp2.wwww);
    // 360: dp3
    reg_tmp1 = vec4(dot(vec3(reg_tmp2), vec3(reg_tmp14)));
    // 361: add
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    // 362: mad
    reg_tmp6 = fma_safe(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_363_367() {
    // 363: mov
    reg_tmp1.xy = (uniforms.f[94].zzzz).xy;
    // 364: mov
    reg_tmp1.zw = (uniforms.f[93].xxxx).zw;
    // 365: mad
    reg_tmp6 = fma_safe(reg_tmp14, reg_tmp1, reg_tmp1);
    // 366: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_367_391() {
    // 367: mov
    reg_tmp0.xy = (uniforms.f[10].yyyy).xy;
    // 368: ifu
    if (uniforms.b[10]) {
        sub_369_373();
    } else {
        sub_373_390();
    }
    // 390: nop
    return false;
}
bool sub_369_373() {
    // 369: call
    {
        sub_348_356();
    }
    // 370: dp4
    reg_tmp4.x = dot(uniforms.f[14].xywz, reg_tmp6);
    // 371: dp4
    reg_tmp4.y = dot(uniforms.f[15].xywz, reg_tmp6);
    // 372: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_373_390() {
    // 373: ifu
    if (uniforms.b[13]) {
        sub_374_388();
    } else {
        sub_388_389();
    }
    // 389: nop
    return false;
}
bool sub_374_388() {
    // 374: cmp
    conditional_code = equal(vec2(uniforms.f[95].xyyy), vec2(reg_tmp0.xyyy));
    // 375: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 376: ifc
    if (all(not(conditional_code))) {
        sub_377_384();
    } else {
        sub_384_387();
    }
    // 387: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_377_384() {
    // 377: mov
    reg_tmp6 = reg_tmp10;
    // 378: dp4
    reg_tmp4.x = dot(uniforms.f[14], reg_tmp6);
    // 379: dp4
    reg_tmp4.y = dot(uniforms.f[15], reg_tmp6);
    // 380: dp4
    reg_tmp4.z = dot(uniforms.f[16], reg_tmp6);
    // 381: rcp
    reg_tmp6.w = rcp_safe(reg_tmp4.zzzz.x);
    // 382: mul
    reg_tmp4.xy = (mul_safe(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    // 383: add
    reg_tmp4.xy = (uniforms.f[19].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_384_387() {
    // 384: call
    {
        sub_363_367();
    }
    // 385: dp4
    reg_tmp4.x = dot(uniforms.f[14], reg_tmp6);
    // 386: dp4
    reg_tmp4.y = dot(uniforms.f[15], reg_tmp6);
    return false;
}
bool sub_388_389() {
    // 388: mov
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_391_407() {
    // 391: mov
    reg_tmp0.xy = (uniforms.f[10].zzzz).xy;
    // 392: ifu
    if (uniforms.b[11]) {
        sub_393_397();
    } else {
        sub_397_406();
    }
    // 406: nop
    return false;
}
bool sub_393_397() {
    // 393: call
    {
        sub_348_356();
    }
    // 394: dp4
    reg_tmp5.x = dot(uniforms.f[17].xywz, reg_tmp6);
    // 395: dp4
    reg_tmp5.y = dot(uniforms.f[18].xywz, reg_tmp6);
    // 396: mov
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_397_406() {
    // 397: ifu
    if (uniforms.b[14]) {
        sub_398_404();
    } else {
        sub_404_405();
    }
    // 405: nop
    return false;
}
bool sub_398_404() {
    // 398: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 399: mov
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    // 400: call
    {
        sub_363_367();
    }
    // 401: dp4
    reg_tmp5.x = dot(uniforms.f[17], reg_tmp6);
    // 402: dp4
    reg_tmp5.y = dot(uniforms.f[18], reg_tmp6);
    // 403: mov
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_404_405() {
    // 404: mov
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
// reference: 4ED0A36A38CB5642, 48B3A6FBA8498826
// shader: 8DD9, AD7922A63ED54CA7

layout(triangles) in;
layout(triangle_strip, max_vertices = 3) out;

out vec4 primary_color;
out vec2 texcoord0;
out vec2 texcoord1;
out vec2 texcoord2;
out float texcoord0_w;
out vec4 normquat;
out vec3 view;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

 in vec4 vs_out_attr0[];
 in vec4 vs_out_attr1[];
 in vec4 vs_out_attr2[];
 in vec4 vs_out_attr3[];
 in vec4 vs_out_attr4[];
 in vec4 vs_out_attr5[];
 in vec4 vs_out_attr6[];

struct Vertex {
    vec4 attributes[7];
};

vec4 GetVertexQuaternion(Vertex vtx) {
    return vec4(vtx.attributes[1].x, vtx.attributes[1].y, vtx.attributes[1].z, vtx.attributes[1].w);
}

void EmitVtx(Vertex vtx, bool quats_opposite) {
    vec4 vtx_pos = vec4(vtx.attributes[0].x, vtx.attributes[0].y, vtx.attributes[0].z, vtx.attributes[0].w);
    gl_Position = vtx_pos;
#if !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)
    gl_ClipDistance[0] = -vtx_pos.z;
    gl_ClipDistance[1] = dot(clip_coef, vtx_pos);
#endif // !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)

    vec4 vtx_quat = GetVertexQuaternion(vtx);
    normquat = mix(vtx_quat, -vtx_quat, bvec4(quats_opposite));

    vec4 vtx_color = vec4(vtx.attributes[3].x, vtx.attributes[3].y, vtx.attributes[3].z, vtx.attributes[3].w);
    primary_color = min(abs(vtx_color), vec4(1.0));

    texcoord0 = vec2(vtx.attributes[4].x, vtx.attributes[4].y);
    texcoord1 = vec2(vtx.attributes[5].x, vtx.attributes[5].y);

    texcoord0_w = vtx.attributes[4].z;
    view = vec3(vtx.attributes[2].x, vtx.attributes[2].y, vtx.attributes[2].z);

    texcoord2 = vec2(vtx.attributes[6].x, vtx.attributes[6].y);

    EmitVertex();
}

bool AreQuaternionsOpposite(vec4 qa, vec4 qb) {
    return (dot(qa, qb) < 0.0);
}

void EmitPrim(Vertex vtx0, Vertex vtx1, Vertex vtx2) {
    EmitVtx(vtx0, false);
    EmitVtx(vtx1, AreQuaternionsOpposite(GetVertexQuaternion(vtx0), GetVertexQuaternion(vtx1)));
    EmitVtx(vtx2, AreQuaternionsOpposite(GetVertexQuaternion(vtx0), GetVertexQuaternion(vtx2)));
    EndPrimitive();
}

void main() {
    Vertex prim_buffer[3];
    prim_buffer[0].attributes = vec4[7](vs_out_attr0[0], vs_out_attr1[0], vs_out_attr2[0], vs_out_attr3[0], vs_out_attr4[0], vs_out_attr5[0], vs_out_attr6[0]);
    prim_buffer[1].attributes = vec4[7](vs_out_attr0[1], vs_out_attr1[1], vs_out_attr2[1], vs_out_attr3[1], vs_out_attr4[1], vs_out_attr5[1], vs_out_attr6[1]);
    prim_buffer[2].attributes = vec4[7](vs_out_attr0[2], vs_out_attr1[2], vs_out_attr2[2], vs_out_attr3[2], vs_out_attr4[2], vs_out_attr5[2], vs_out_attr6[2]);
    EmitPrim(prim_buffer[0], prim_buffer[1], prim_buffer[2]);
}
// reference: FC74FA4ACA1C8C74, AD7922A63ED54CA7
// shader: 8B30, 37746EF97975DC24

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor2.rrr) * (rounded_primary_color.rrr), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (textureProj(tex0, vec3(texcoord0, texcoord0_w)).a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((rounded_primary_color.ggg) * (texcolor2.ggg) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor2.bbb) * (rounded_primary_color.bbb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D89C35D7B9351384, 37746EF97975DC24
// program: 48B3A6FBA8498826, AD7922A63ED54CA7, 37746EF97975DC24
// reference: 4ED0A36A0E39C6B1, 48B3A6FBA8498826
// reference: 2CDA75CF39D78153, DEFAC6F185DB6EB9
// shader: 8B30, D896C1A0D13B6C62

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2 * 2.0, alpha_output_2 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 7F389146B8264ABE, D896C1A0D13B6C62
// program: DEFAC6F185DB6EB9, 6CF3F3B70E23AA85, D896C1A0D13B6C62
// reference: 2CDA75CF0F2511A0, DEFAC6F185DB6EB9
// shader: 8B30, E83C63DA8714B03E

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2 * 2.0, alpha_output_2 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 6102F0333DE8AAD8, E83C63DA8714B03E
// program: DEFAC6F185DB6EB9, 6CF3F3B70E23AA85, E83C63DA8714B03E
// reference: 7F389146D15F41DB, D896C1A0D13B6C62
// reference: 7F38914604368CCF, E83C63DA8714B03E
// shader: 8B30, 3E9E44CBED729440

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor1.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 66ADF19D7807513E, 3E9E44CBED729440
// program: 65138AC5CA635BBF, 3B3AE026C742C7D5, 3E9E44CBED729440
// reference: C5B6312077479017, 665EE456131D3E7B
// shader: 8B31, D3C285AB726883C8

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 7) in vec4 vs_in_reg7;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define fma_safe(x, y, z) fma(x, y, z)
#define mul_safe(x, y) (x * y)
#define rcp_safe(x) (1.0f / x)
#define rsq_safe(x) inversesqrt(x)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_7_83();
bool sub_15_25();
bool sub_25_34();
bool sub_35_47();
bool sub_47_72();
bool sub_48_66();
bool sub_66_71();
bool sub_81_82();
bool sub_83_100();
bool sub_100_176();
bool sub_139_159();
bool sub_140_145();
bool sub_145_158();
bool sub_149_152();
bool sub_152_157();
bool sub_159_172();
bool sub_160_165();
bool sub_165_171();
bool sub_176_186();
bool sub_181_185();
bool sub_182_183();
bool sub_277_4096();

bool exec_shader() {
    sub_277_4096();
    return true;
}

bool sub_7_83() {
    // 7: mul
    reg_tmp15.xyz = (mul_safe(uniforms.f[7].xxxx, vs_in_reg0)).xyz;
    // 8: mul
    reg_tmp14.xyz = (mul_safe(uniforms.f[7].yyyy, vs_in_reg1)).xyz;
    // 9: mul
    reg_tmp13.xyz = (mul_safe(uniforms.f[7].zzzz, vs_in_reg2)).xyz;
    // 10: add
    reg_tmp15.xyz = (uniforms.f[6] + reg_tmp15).xyz;
    // 11: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 12: mov
    reg_tmp0 = uniforms.f[7];
    // 13: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.yzzz));
    // 14: ifu
    if (uniforms.b[2]) {
        sub_15_25();
    } else {
        sub_25_34();
    }
    // 34: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_35_47();
    } else {
        sub_47_72();
    }
    // 72: mov
    vs_out_attr2 = -reg_tmp15;
    // 73: dp4
    reg_tmp0.x = dot(uniforms.f[86], reg_tmp15);
    // 74: dp4
    reg_tmp0.y = dot(uniforms.f[87], reg_tmp15);
    // 75: dp4
    reg_tmp0.z = dot(uniforms.f[88], reg_tmp15);
    // 76: dp4
    reg_tmp0.w = dot(uniforms.f[89], reg_tmp15);
    // 77: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 78: mul
    reg_tmp1.y = (mul_safe(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
    // 79: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 80: ifc
    if (all(conditional_code)) {
        sub_81_82();
    }
    // 82: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_15_25() {
    // 15: mul
    reg_tmp1.x = (mul_safe(uniforms.f[93].wwww, vs_in_reg7.xxxx)).x;
    // 16: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 17: dp4
    reg_tmp7.x = dot(uniforms.f[25 + address_registers.x], reg_tmp15);
    // 18: dp4
    reg_tmp7.y = dot(uniforms.f[26 + address_registers.x], reg_tmp15);
    // 19: dp4
    reg_tmp7.z = dot(uniforms.f[27 + address_registers.x], reg_tmp15);
    // 20: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 21: dp4
    reg_tmp10.x = dot(uniforms.f[0], reg_tmp7);
    // 22: dp4
    reg_tmp10.y = dot(uniforms.f[1], reg_tmp7);
    // 23: dp4
    reg_tmp10.z = dot(uniforms.f[2], reg_tmp7);
    // 24: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_25_34() {
    // 25: mova
    address_registers.x = (ivec2(uniforms.f[93].xxxx)).x;
    // 26: dp4
    reg_tmp7.x = dot(uniforms.f[25], reg_tmp15);
    // 27: dp4
    reg_tmp7.y = dot(uniforms.f[26], reg_tmp15);
    // 28: dp4
    reg_tmp7.z = dot(uniforms.f[27], reg_tmp15);
    // 29: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 30: dp4
    reg_tmp10.x = dot(uniforms.f[0], reg_tmp7);
    // 31: dp4
    reg_tmp10.y = dot(uniforms.f[1], reg_tmp7);
    // 32: dp4
    reg_tmp10.z = dot(uniforms.f[2], reg_tmp7);
    // 33: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_35_47() {
    // 35: dp3
    reg_tmp12.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp14));
    // 36: dp3
    reg_tmp12.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp14));
    // 37: dp3
    reg_tmp12.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp14));
    // 38: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 39: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 40: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 41: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 42: dp3
    reg_tmp14.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp12));
    // 43: dp3
    reg_tmp14.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp12));
    // 44: dp3
    reg_tmp14.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp12));
    // 45: call
    {
        sub_83_100();
    }
    // 46: nop
    return false;
}
bool sub_47_72() {
    // 47: ifc
    if (all(conditional_code)) {
        sub_48_66();
    } else {
        sub_66_71();
    }
    // 71: nop
    return false;
}
bool sub_48_66() {
    // 48: dp3
    reg_tmp12.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp14));
    // 49: dp3
    reg_tmp12.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp14));
    // 50: dp3
    reg_tmp12.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp14));
    // 51: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp13));
    // 52: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp13));
    // 53: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp13));
    // 54: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 55: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 56: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 57: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 58: dp3
    reg_tmp14.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp12));
    // 59: dp3
    reg_tmp14.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp12));
    // 60: dp3
    reg_tmp14.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp12));
    // 61: dp3
    reg_tmp13.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp11));
    // 62: dp3
    reg_tmp13.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp11));
    // 63: dp3
    reg_tmp13.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp11));
    // 64: call
    {
        sub_100_176();
    }
    // 65: nop
    return false;
}
bool sub_66_71() {
    // 66: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 67: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 68: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 69: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 70: mov
    vs_out_attr1 = uniforms.f[93].xxxx;
    return false;
}
bool sub_81_82() {
    // 81: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_83_100() {
    uint jmp_to = 83u;
    while (true) {
        switch (jmp_to) {
        case 83u: {
            // 83: dp3
            reg_tmp6.x = dot(vec3(reg_tmp14), vec3(reg_tmp14));
            // 84: dp3
            reg_tmp7.x = dot(vec3(reg_tmp12), vec3(reg_tmp12));
            // 85: rsq
            reg_tmp6.x = rsq_safe(reg_tmp6.xxxx.x);
            // 86: rsq
            reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
            // 87: mul
            reg_tmp14.xyz = (mul_safe(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 88: mul
            reg_tmp12.xyz = (mul_safe(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 89: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 90: jmpu
            if (!uniforms.b[3]) {
                { jmp_to = 99u; break; }
            }
            // 91: add
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            // 92: mul
            reg_tmp4 = mul_safe(uniforms.f[94].zzzz, reg_tmp4);
            // 93: cmp
            conditional_code = greaterThanEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp4.xxxx));
            // 94: rsq
            reg_tmp4 = vec4(rsq_safe(reg_tmp4.xxxx.x));
            // 95: mul
            reg_tmp5 = mul_safe(uniforms.f[94].zzzz, reg_tmp14);
            // 96: jmpc
            if (conditional_code.x) {
                { jmp_to = 99u; break; }
            }
            // 97: rcp
            reg_tmp0.z = rcp_safe(reg_tmp4.xxxx.x);
            // 98: mul
            reg_tmp0.xy = (mul_safe(reg_tmp5, reg_tmp4)).xy;
        }
        case 99u: {
            // 99: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_100_176() {
    uint jmp_to = 100u;
    while (true) {
        switch (jmp_to) {
        case 100u: {
            // 100: dp3
            reg_tmp6.x = dot(vec3(reg_tmp14), vec3(reg_tmp14));
            // 101: dp3
            reg_tmp7.x = dot(vec3(reg_tmp12), vec3(reg_tmp12));
            // 102: rsq
            reg_tmp6.x = rsq_safe(reg_tmp6.xxxx.x);
            // 103: rsq
            reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
            // 104: mul
            reg_tmp14.xyz = (mul_safe(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 105: mul
            reg_tmp12.xyz = (mul_safe(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 106: mul
            reg_tmp13.xyz = (mul_safe(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            // 107: mul
            reg_tmp11.xyz = (mul_safe(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            // 108: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 109: jmpu
            if (!uniforms.b[3]) {
                { jmp_to = 175u; break; }
            }
            // 110: mul
            reg_tmp13.xyz = (mul_safe(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            // 111: mul
            reg_tmp11.xyz = (mul_safe(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            // 112: mul
            reg_tmp5 = mul_safe(reg_tmp14.yzxx, reg_tmp13.zxyy);
            // 113: mad
            reg_tmp5 = fma_safe(-reg_tmp13.yzxx, reg_tmp14.zxyy, reg_tmp5);
            // 114: dp3
            reg_tmp5.w = dot(vec3(reg_tmp5), vec3(reg_tmp5));
            // 115: rsq
            reg_tmp5.w = rsq_safe(reg_tmp5.wwww.x);
            // 116: mul
            reg_tmp5 = mul_safe(reg_tmp5, reg_tmp5.wwww);
            // 117: add
            reg_tmp6.w = (reg_tmp14.zzzz + reg_tmp5.yyyy).w;
            // 118: mul
            reg_tmp13 = mul_safe(reg_tmp5.yzxx, reg_tmp14.zxyy);
            // 119: mad
            reg_tmp13 = fma_safe(-reg_tmp14.yzxx, reg_tmp5.zxyy, reg_tmp13);
            // 120: add
            reg_tmp6.w = (reg_tmp13.xxxx + reg_tmp6).w;
            // 121: mov
            reg_tmp13.w = (reg_tmp5.zzzz).w;
            // 122: mov
            reg_tmp5.z = (reg_tmp13.xxxx).z;
            // 123: add
            reg_tmp6.w = (uniforms.f[93].yyyy + reg_tmp6).w;
            // 124: mov
            reg_tmp14.w = (reg_tmp5.xxxx).w;
            // 125: mov
            reg_tmp5.x = (reg_tmp14.zzzz).x;
            // 126: cmp
            conditional_code = lessThan(vec2(uniforms.f[94].yyyy), vec2(reg_tmp6.wwww));
            // 127: mov
            reg_tmp6.x = (uniforms.f[93].yyyy).x;
            // 128: mov
            reg_tmp6.y = (-uniforms.f[93].yyyy).y;
            // 129: jmpc
            if (!conditional_code.x) {
                { jmp_to = 137u; break; }
            }
            // 130: add
            reg_tmp7.xz = (reg_tmp13.wwyy + -reg_tmp14.yyww).xz;
            // 131: add
            reg_tmp7.y = (reg_tmp14.xxxx + -reg_tmp13.zzzz).y;
            // 132: mov
            reg_tmp7.w = (reg_tmp6).w;
            // 133: dp4
            reg_tmp6 = vec4(dot(reg_tmp7, reg_tmp7));
            // 134: rsq
            reg_tmp6 = vec4(rsq_safe(reg_tmp6.xxxx.x));
            // 135: mul
            reg_tmp0 = mul_safe(reg_tmp7, reg_tmp6);
            // 136: jmpu
            if (uniforms.b[0]) {
                { jmp_to = 175u; break; }
            }
        }
        case 137u: {
            // 137: cmp
            conditional_code = greaterThan(vec2(reg_tmp5.zyyy), vec2(reg_tmp5.yxxx));
            // 138: ifc
            if (conditional_code.x) {
                sub_139_159();
            } else {
                sub_159_172();
            }
            // 172: dp4
            reg_tmp6 = vec4(dot(reg_tmp8, reg_tmp8));
            // 173: rsq
            reg_tmp6 = vec4(rsq_safe(reg_tmp6.xxxx.x));
            // 174: mul
            reg_tmp0 = mul_safe(reg_tmp8, reg_tmp6);
        }
        case 175u: {
            // 175: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_139_159() {
    // 139: ifc
    if (conditional_code.y) {
        sub_140_145();
    } else {
        sub_145_158();
    }
    // 158: mov
    reg_tmp8.w = (-reg_tmp8).w;
    return false;
}
bool sub_140_145() {
    // 140: mul
    reg_tmp8 = mul_safe(reg_tmp13.yyzw, reg_tmp6.xxxy);
    // 141: add
    reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
    // 142: add
    reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
    // 143: add
    reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
    // 144: add
    reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
    return false;
}
bool sub_145_158() {
    // 145: cmp
    conditional_code = greaterThan(vec2(reg_tmp5.zzzz), vec2(reg_tmp5.xxxx));
    // 146: mul
    reg_tmp8 = mul_safe(reg_tmp13.yyzw, reg_tmp6.xxxy);
    // 147: add
    reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
    // 148: ifc
    if (conditional_code.x) {
        sub_149_152();
    } else {
        sub_152_157();
    }
    // 157: nop
    return false;
}
bool sub_149_152() {
    // 149: add
    reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
    // 150: add
    reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
    // 151: add
    reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
    return false;
}
bool sub_152_157() {
    // 152: mul
    reg_tmp8 = mul_safe(reg_tmp13.zwwy, reg_tmp6.xxxy);
    // 153: add
    reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
    // 154: add
    reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
    // 155: add
    reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
    // 156: add
    reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
    return false;
}
bool sub_159_172() {
    // 159: ifc
    if (conditional_code.y) {
        sub_160_165();
    } else {
        sub_165_171();
    }
    // 171: nop
    return false;
}
bool sub_160_165() {
    // 160: mul
    reg_tmp8 = mul_safe(reg_tmp13.yywz, reg_tmp6.xxxy);
    // 161: add
    reg_tmp8.y = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).y;
    // 162: add
    reg_tmp9 = reg_tmp5.yyyy + -reg_tmp5.xxxx;
    // 163: add
    reg_tmp8.xzw = (reg_tmp8 + reg_tmp14.wwyx).xzw;
    // 164: add
    reg_tmp8.y = (reg_tmp9 + reg_tmp8).y;
    return false;
}
bool sub_165_171() {
    // 165: mul
    reg_tmp8 = mul_safe(reg_tmp13.zwwy, reg_tmp6.xxxy);
    // 166: add
    reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
    // 167: add
    reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
    // 168: add
    reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
    // 169: add
    reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
    // 170: mov
    reg_tmp8.w = (-reg_tmp8).w;
    return false;
}
bool sub_176_186() {
    // 176: mov
    reg_tmp0.y = (uniforms.f[7].wwww).y;
    // 177: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.xyyy));
    // 178: mov
    reg_tmp9 = uniforms.f[21];
    // 179: mul
    reg_tmp0 = mul_safe(uniforms.f[7].wwww, vs_in_reg3);
    // 180: ifc
    if (conditional_code.y) {
        sub_181_185();
    }
    // 185: max
    vs_out_attr3 = max(uniforms.f[93].xxxx, reg_tmp9);
    return false;
}
bool sub_181_185() {
    // 181: ifu
    if (uniforms.b[7]) {
        sub_182_183();
    }
    // 183: mul
    reg_tmp9.xyz = (mul_safe(uniforms.f[20].wwww, reg_tmp0.xyzz)).xyz;
    // 184: mov
    reg_tmp8.x = (uniforms.f[93].yyyy).x;
    return false;
}
bool sub_182_183() {
    // 182: mul
    reg_tmp9.w = (mul_safe(reg_tmp9.wwww, reg_tmp0.wwww)).w;
    return false;
}
bool sub_277_4096() {
    // 277: call
    {
        sub_7_83();
    }
    // 278: call
    {
        sub_176_186();
    }
    // 279: end
    return true;
}
// reference: 9E16C22C70E0C038, D3C285AB726883C8
// shader: 8DD9, 4BD70AD09292A3DA

layout(triangles) in;
layout(triangle_strip, max_vertices = 3) out;

out vec4 primary_color;
out vec2 texcoord0;
out vec2 texcoord1;
out vec2 texcoord2;
out float texcoord0_w;
out vec4 normquat;
out vec3 view;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

 in vec4 vs_out_attr0[];
 in vec4 vs_out_attr1[];
 in vec4 vs_out_attr2[];
 in vec4 vs_out_attr3[];

struct Vertex {
    vec4 attributes[4];
};

vec4 GetVertexQuaternion(Vertex vtx) {
    return vec4(vtx.attributes[1].x, vtx.attributes[1].y, vtx.attributes[1].z, vtx.attributes[1].w);
}

void EmitVtx(Vertex vtx, bool quats_opposite) {
    vec4 vtx_pos = vec4(vtx.attributes[0].x, vtx.attributes[0].y, vtx.attributes[0].z, vtx.attributes[0].w);
    gl_Position = vtx_pos;
#if !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)
    gl_ClipDistance[0] = -vtx_pos.z;
    gl_ClipDistance[1] = dot(clip_coef, vtx_pos);
#endif // !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)

    vec4 vtx_quat = GetVertexQuaternion(vtx);
    normquat = mix(vtx_quat, -vtx_quat, bvec4(quats_opposite));

    vec4 vtx_color = vec4(vtx.attributes[3].x, vtx.attributes[3].y, vtx.attributes[3].z, vtx.attributes[3].w);
    primary_color = min(abs(vtx_color), vec4(1.0));

    texcoord0 = vec2(0.0, 0.0);
    texcoord1 = vec2(0.0, 0.0);

    texcoord0_w = 0.0;
    view = vec3(vtx.attributes[2].x, vtx.attributes[2].y, vtx.attributes[2].z);

    texcoord2 = vec2(0.0, 0.0);

    EmitVertex();
}

bool AreQuaternionsOpposite(vec4 qa, vec4 qb) {
    return (dot(qa, qb) < 0.0);
}

void EmitPrim(Vertex vtx0, Vertex vtx1, Vertex vtx2) {
    EmitVtx(vtx0, false);
    EmitVtx(vtx1, AreQuaternionsOpposite(GetVertexQuaternion(vtx0), GetVertexQuaternion(vtx1)));
    EmitVtx(vtx2, AreQuaternionsOpposite(GetVertexQuaternion(vtx0), GetVertexQuaternion(vtx2)));
    EndPrimitive();
}

void main() {
    Vertex prim_buffer[3];
    prim_buffer[0].attributes = vec4[4](vs_out_attr0[0], vs_out_attr1[0], vs_out_attr2[0], vs_out_attr3[0]);
    prim_buffer[1].attributes = vec4[4](vs_out_attr0[1], vs_out_attr1[1], vs_out_attr2[1], vs_out_attr3[1]);
    prim_buffer[2].attributes = vec4[4](vs_out_attr0[2], vs_out_attr1[2], vs_out_attr2[2], vs_out_attr3[2]);
    EmitPrim(prim_buffer[0], prim_buffer[1], prim_buffer[2]);
}
// reference: 3901EC4BEC56958E, 4BD70AD09292A3DA
// shader: 8B30, C89A25AB5DFAEF68

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 52436FBFE411AC7D, C89A25AB5DFAEF68
// program: D3C285AB726883C8, 4BD70AD09292A3DA, C89A25AB5DFAEF68
// shader: 8B30, 01BBC054435D9EE9

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 352C658CDB530FE4, 01BBC054435D9EE9
// program: DEFAC6F185DB6EB9, 6CF3F3B70E23AA85, 01BBC054435D9EE9
// shader: 8B30, 0BBA166B3A7404D9

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (secondary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 893389AF31FB99E2, 0BBA166B3A7404D9
// program: DEFAC6F185DB6EB9, 6CF3F3B70E23AA85, 0BBA166B3A7404D9
// reference: 026FCA2652A58EDC, D82E12A9D19ACD63
// shader: 8B30, 349045CFC3ED61E5

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor0.rgb) * (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor0.a) + (const_color[2].a) - 0.5, 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2 * 1.0, alpha_output_2 * 2.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (last_tex_env_out.aaa), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) * (last_tex_env_out.aaa) + (texcolor0.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4 * 1.0, alpha_output_4 * 4.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb) + (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: FCABFC29D4039A15, 349045CFC3ED61E5
// program: D82E12A9D19ACD63, 5D764F9A6220D694, 349045CFC3ED61E5
// reference: 898F1D89891C2F9B, D82E12A9D19ACD63
// shader: 8B31, 734B56B7CFCD3D95

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define fma_safe(x, y, z) fma(x, y, z)
#define mul_safe(x, y) (x * y)
#define rcp_safe(x) (1.0f / x)
#define rsq_safe(x) inversesqrt(x)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_8();
bool sub_9_32();
bool sub_97_113();
bool sub_146_166();
bool sub_167_259();
bool sub_190_192();
bool sub_194_195();
bool sub_197_198();
bool sub_200_202();
bool sub_232_234();
bool sub_236_237();
bool sub_239_240();
bool sub_242_244();
bool sub_260_4096();
bool sub_273_274();
bool sub_274_275();

bool exec_shader() {
    sub_260_4096();
    return true;
}

bool sub_0_8() {
    // 0: mova
    address_registers.x = (ivec2(vs_in_reg0.zzzz)).x;
    // 1: mov
    reg_tmp10 = uniforms.f[0].xxxz;
    // 2: mov
    reg_tmp10.xy = (vs_in_reg0.xyyy).xy;
    // 3: mov
    reg_tmp11 = uniforms.f[0].xxxx;
    // 4: mov
    reg_tmp12 = uniforms.f[0].xxxx;
    // 5: mov
    reg_tmp13 = uniforms.f[0].zzzz;
    // 6: mov
    reg_tmp4 = uniforms.f[0].xxxx;
    // 7: mov
    reg_tmp5 = uniforms.f[0].xxxx;
    return false;
}
bool sub_9_32() {
    // 9: mov
    vs_out_attr0 = reg_tmp10;
    // 10: mul
    reg_tmp13 = mul_safe(uniforms.f[82], reg_tmp13);
    // 11: mov
    vs_out_attr1 = reg_tmp13;
    // 12: add
    reg_tmp11.y = (uniforms.f[0].zzzz + -reg_tmp11.yyyy).y;
    // 13: add
    reg_tmp12.y = (uniforms.f[0].zzzz + -reg_tmp12.yyyy).y;
    // 14: mov
    reg_tmp14.y = (uniforms.f[81].wwww).y;
    // 15: mul
    reg_tmp14.x = (mul_safe(uniforms.f[0].wwww, reg_tmp14.yyyy)).x;
    // 16: rcp
    reg_tmp2.x = rcp_safe(reg_tmp14.xxxx.x);
    // 17: mov
    reg_tmp14.z = (reg_tmp2.xxxx).z;
    // 18: add
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp11.xyyy).xy;
    // 19: mul
    reg_tmp5.xy = (mul_safe(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    // 20: flr
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    // 21: mul
    reg_tmp4.xy = (mul_safe(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    // 22: add
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    // 23: add
    reg_tmp11.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    // 24: add
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp12.xyyy).xy;
    // 25: mul
    reg_tmp5.xy = (mul_safe(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    // 26: flr
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    // 27: mul
    reg_tmp4.xy = (mul_safe(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    // 28: add
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    // 29: add
    reg_tmp12.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    // 30: mov
    vs_out_attr2 = reg_tmp11;
    // 31: mov
    vs_out_attr3 = reg_tmp12;
    return false;
}
bool sub_97_113() {
    // 97: mov
    reg_tmp6.x = (uniforms.f[90].xxxx).x;
    // 98: mov
    reg_tmp6.y = (uniforms.f[91].xxxx).y;
    // 99: mov
    reg_tmp6.z = (uniforms.f[92].xxxx).z;
    // 100: mov
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    // 101: mov
    reg_tmp7.x = (uniforms.f[90].yyyy).x;
    // 102: mov
    reg_tmp7.y = (uniforms.f[91].yyyy).y;
    // 103: mov
    reg_tmp7.z = (uniforms.f[92].yyyy).z;
    // 104: mov
    reg_tmp7.w = (uniforms.f[0].xxxx).w;
    // 105: mov
    reg_tmp8.x = (uniforms.f[90].zzzz).x;
    // 106: mov
    reg_tmp8.y = (uniforms.f[91].zzzz).y;
    // 107: mov
    reg_tmp8.z = (uniforms.f[92].zzzz).z;
    // 108: mov
    reg_tmp8.w = (uniforms.f[0].xxxx).w;
    // 109: mov
    reg_tmp9.x = (uniforms.f[90].wwww).x;
    // 110: mov
    reg_tmp9.y = (uniforms.f[91].wwww).y;
    // 111: mov
    reg_tmp9.z = (uniforms.f[92].wwww).z;
    // 112: mov
    reg_tmp9.w = (uniforms.f[0].zzzz).w;
    return false;
}
bool sub_146_166() {
    // 146: mov
    reg_tmp2 = uniforms.f[90];
    // 147: mov
    reg_tmp3 = uniforms.f[91];
    // 148: mov
    reg_tmp4 = uniforms.f[92];
    // 149: mov
    reg_tmp5 = uniforms.f[0].xxxz;
    // 150: mul
    reg_tmp6 = mul_safe(uniforms.f[86].xxxx, reg_tmp2);
    // 151: mad
    reg_tmp6 = fma_safe(reg_tmp3, uniforms.f[86].yyyy, reg_tmp6);
    // 152: mad
    reg_tmp6 = fma_safe(reg_tmp4, uniforms.f[86].zzzz, reg_tmp6);
    // 153: mad
    reg_tmp6 = fma_safe(reg_tmp5, uniforms.f[86].wwww, reg_tmp6);
    // 154: mul
    reg_tmp7 = mul_safe(uniforms.f[87].xxxx, reg_tmp2);
    // 155: mad
    reg_tmp7 = fma_safe(reg_tmp3, uniforms.f[87].yyyy, reg_tmp7);
    // 156: mad
    reg_tmp7 = fma_safe(reg_tmp4, uniforms.f[87].zzzz, reg_tmp7);
    // 157: mad
    reg_tmp7 = fma_safe(reg_tmp5, uniforms.f[87].wwww, reg_tmp7);
    // 158: mul
    reg_tmp8 = mul_safe(uniforms.f[88].xxxx, reg_tmp2);
    // 159: mad
    reg_tmp8 = fma_safe(reg_tmp3, uniforms.f[88].yyyy, reg_tmp8);
    // 160: mad
    reg_tmp8 = fma_safe(reg_tmp4, uniforms.f[88].zzzz, reg_tmp8);
    // 161: mad
    reg_tmp8 = fma_safe(reg_tmp5, uniforms.f[88].wwww, reg_tmp8);
    // 162: mul
    reg_tmp9 = mul_safe(uniforms.f[89].xxxx, reg_tmp2);
    // 163: mad
    reg_tmp9 = fma_safe(reg_tmp3, uniforms.f[89].yyyy, reg_tmp9);
    // 164: mad
    reg_tmp9 = fma_safe(reg_tmp4, uniforms.f[89].zzzz, reg_tmp9);
    // 165: mad
    reg_tmp9 = fma_safe(reg_tmp5, uniforms.f[89].wwww, reg_tmp9);
    return false;
}
bool sub_167_259() {
    // 167: rcp
    reg_tmp2.x = rcp_safe(uniforms.f[81].yyyy.x);
    // 168: mul
    reg_tmp2.xy = (mul_safe(uniforms.f[2 + address_registers.x].zwww, reg_tmp2.xxxx)).xy;
    // 169: add
    reg_tmp2.xy = (uniforms.f[0].yyyy + reg_tmp2.xyyy).xy;
    // 170: flr
    reg_tmp3.xy = (floor(reg_tmp2.xyyy)).xy;
    // 171: mul
    reg_tmp2.xy = (mul_safe(uniforms.f[81].yyyy, reg_tmp3.xyyy)).xy;
    // 172: add
    reg_tmp2.xy = (uniforms.f[2 + address_registers.x].zwww + -reg_tmp2.xyyy).xy;
    // 173: min
    reg_tmp0.xy = (min(uniforms.f[81].xxxx, -reg_tmp2.xyyy)).xy;
    // 174: max
    reg_tmp0.xy = (max(-uniforms.f[81].xxxx, reg_tmp0.xyyy)).xy;
    // 175: mov
    reg_tmp2 = uniforms.f[95];
    // 176: mov
    reg_tmp3 = uniforms.f[94];
    // 177: mul
    reg_tmp1.z = (mul_safe(reg_tmp0.xxxx, reg_tmp0.xxxx)).z;
    // 178: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 179: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 180: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 181: mov
    reg_tmp2 = uniforms.f[93];
    // 182: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 183: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 184: mul
    reg_tmp1.y = (mul_safe(reg_tmp1.yyyy, reg_tmp0.xxxx)).y;
    // 185: mov
    reg_tmp5.x = (uniforms.f[5 + address_registers.x].wwww).x;
    // 186: mov
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    // 187: mov
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    // 188: cmp
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    // 189: ifc
    if (conditional_code.x) {
        sub_190_192();
    }
    // 192: cmp
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    // 193: ifc
    if (conditional_code.x) {
        sub_194_195();
    }
    // 195: cmp
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 196: ifc
    if (conditional_code.x) {
        sub_197_198();
    }
    // 198: cmp
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 199: ifc
    if (conditional_code.x) {
        sub_200_202();
    }
    // 202: mul
    reg_tmp4.xy = (mul_safe(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    // 203: mad
    reg_tmp4.x = (fma_safe(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    // 204: mad
    reg_tmp4.y = (fma_safe(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    // 205: add
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    // 206: add
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    // 207: mov
    reg_tmp4.z = (uniforms.f[83].xxxx).z;
    // 208: mov
    reg_tmp4.w = (-uniforms.f[83].yyyy).w;
    // 209: madi
    reg_tmp5.xy = (fma_safe(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[3 + address_registers.x].xyyy)).xy;
    // 210: mov
    reg_tmp4.z = (-uniforms.f[3 + address_registers.x].zzzz).z;
    // 211: mov
    reg_tmp4.w = (-uniforms.f[3 + address_registers.x].wwww).w;
    // 212: add
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    // 213: add
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    // 214: mad
    reg_tmp5.x = (fma_safe(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    // 215: mad
    reg_tmp5.y = (fma_safe(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    // 216: mov
    reg_tmp11.xy = (reg_tmp5.xyyy).xy;
    // 217: mov
    reg_tmp2 = uniforms.f[95];
    // 218: mov
    reg_tmp3 = uniforms.f[94];
    // 219: mul
    reg_tmp1.z = (mul_safe(reg_tmp0.yyyy, reg_tmp0.yyyy)).z;
    // 220: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 221: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 222: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 223: mov
    reg_tmp2 = uniforms.f[93];
    // 224: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 225: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 226: mul
    reg_tmp1.y = (mul_safe(reg_tmp1.yyyy, reg_tmp0.yyyy)).y;
    // 227: mov
    reg_tmp5.x = (uniforms.f[6 + address_registers.x].wwww).x;
    // 228: mov
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    // 229: mov
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    // 230: cmp
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    // 231: ifc
    if (conditional_code.x) {
        sub_232_234();
    }
    // 234: cmp
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    // 235: ifc
    if (conditional_code.x) {
        sub_236_237();
    }
    // 237: cmp
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 238: ifc
    if (conditional_code.x) {
        sub_239_240();
    }
    // 240: cmp
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 241: ifc
    if (conditional_code.x) {
        sub_242_244();
    }
    // 244: mul
    reg_tmp4.xy = (mul_safe(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    // 245: mad
    reg_tmp4.x = (fma_safe(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    // 246: mad
    reg_tmp4.y = (fma_safe(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    // 247: add
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    // 248: add
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    // 249: mov
    reg_tmp4.z = (uniforms.f[83].zzzz).z;
    // 250: mov
    reg_tmp4.w = (-uniforms.f[83].wwww).w;
    // 251: madi
    reg_tmp5.xy = (fma_safe(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[4 + address_registers.x].xyyy)).xy;
    // 252: mov
    reg_tmp4.z = (-uniforms.f[4 + address_registers.x].zzzz).z;
    // 253: mov
    reg_tmp4.w = (-uniforms.f[4 + address_registers.x].wwww).w;
    // 254: add
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    // 255: add
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    // 256: mad
    reg_tmp5.x = (fma_safe(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    // 257: mad
    reg_tmp5.y = (fma_safe(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    // 258: mov
    reg_tmp12.xy = (reg_tmp5.xyyy).xy;
    return false;
}
bool sub_190_192() {
    // 190: mov
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    // 191: mov
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_194_195() {
    // 194: mov
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_197_198() {
    // 197: mov
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_200_202() {
    // 200: mov
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    // 201: mov
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_232_234() {
    // 232: mov
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    // 233: mov
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_236_237() {
    // 236: mov
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_239_240() {
    // 239: mov
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_242_244() {
    // 242: mov
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    // 243: mov
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_260_4096() {
    // 260: call
    {
        sub_0_8();
    }
    // 261: add
    reg_tmp10.xy = (uniforms.f[84].xyyy + reg_tmp10.xyyy).xy;
    // 262: mul
    reg_tmp10.xy = (mul_safe(uniforms.f[2 + address_registers.x].xyyy, reg_tmp10.xyyy)).xy;
    // 263: call
    {
        sub_97_113();
    }
    // 264: dp4
    reg_tmp2.x = dot(reg_tmp10, reg_tmp6);
    // 265: dp4
    reg_tmp2.y = dot(reg_tmp10, reg_tmp7);
    // 266: dp4
    reg_tmp2.z = dot(reg_tmp10, reg_tmp8);
    // 267: dp4
    reg_tmp2.w = dot(uniforms.f[0].xxxz, reg_tmp10);
    // 268: mov
    reg_tmp3.xyz = (uniforms.f[5 + address_registers.x].xyzz).xyz;
    // 269: add
    reg_tmp3.xyz = (uniforms.f[85].xyzz + -reg_tmp3.xyzz).xyz;
    // 270: dp3
    reg_tmp4.x = dot(vec3(reg_tmp3.xyzz), vec3(reg_tmp3.xyzz));
    // 271: cmp
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
    // 272: ifc
    if (conditional_code.x) {
        sub_273_274();
    } else {
        sub_274_275();
    }
    // 275: mul
    reg_tmp3.xyz = (mul_safe(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
    // 276: add
    reg_tmp10.xyz = (uniforms.f[5 + address_registers.x].xyzz + reg_tmp2.xyzz).xyz;
    // 277: mad
    reg_tmp10.xyz = (fma_safe(reg_tmp3.xyzz, uniforms.f[84].zzzz, reg_tmp10.xyzz)).xyz;
    // 278: call
    {
        sub_146_166();
    }
    // 279: mov
    reg_tmp2 = reg_tmp10;
    // 280: dp4
    reg_tmp10.x = dot(reg_tmp2, reg_tmp6);
    // 281: dp4
    reg_tmp10.y = dot(reg_tmp2, reg_tmp7);
    // 282: dp4
    reg_tmp10.z = dot(reg_tmp2, reg_tmp8);
    // 283: dp4
    reg_tmp10.w = dot(reg_tmp2, reg_tmp9);
    // 284: mov
    reg_tmp2 = uniforms.f[1 + address_registers.x];
    // 285: max
    reg_tmp3 = max(uniforms.f[0].xxxx, reg_tmp2);
    // 286: min
    reg_tmp2 = min(uniforms.f[0].zzzz, reg_tmp3);
    // 287: mov
    reg_tmp13 = reg_tmp2;
    // 288: call
    {
        sub_167_259();
    }
    // 289: call
    {
        sub_9_32();
    }
    // 290: end
    return true;
}
bool sub_273_274() {
    // 273: mov
    reg_tmp4.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_274_275() {
    // 274: rsq
    reg_tmp4.x = rsq_safe(reg_tmp4.xxxx.x);
    return false;
}
// reference: A9A14E2BF8024BFC, 734B56B7CFCD3D95
// program: 734B56B7CFCD3D95, CEF02063E9A18B2F, C0234F4E2DEC3D4D
// reference: 1E3FDB172CB15DEE, D82E12A9D19ACD63
// reference: 95DF0CB8F708FCA9, D82E12A9D19ACD63
// reference: EFDA506F42BFE466, DEFAC6F185DB6EB9
// reference: 643A87C099064521, DEFAC6F185DB6EB9
// reference: DA9CD50FD6819D46, 65138AC5CA635BBF
// reference: 75D8474838CB5642, 48B3A6FBA8498826
// reference: 75D847480E39C6B1, 48B3A6FBA8498826
// reference: 17D291ED39D78153, DEFAC6F185DB6EB9
// reference: 17D291ED0F2511A0, DEFAC6F185DB6EB9
// reference: 31B19AEF3DE8AAD8, E83C63DA8714B03E
// reference: A51E260E70E0C038, D3C285AB726883C8
// reference: 39672E0452A58EDC, D82E12A9D19ACD63
// reference: B287F9AB891C2F9B, D82E12A9D19ACD63
// reference: 7F38914681F86CA9, D896C1A0D13B6C62
// reference: 52436FBF8D68A718, C89A25AB5DFAEF68
// shader: 8B31, DD35FB9CAEB223CF

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define fma_safe(x, y, z) fma(x, y, z)
#define mul_safe(x, y) (x * y)
#define rcp_safe(x) (1.0f / x)
#define rsq_safe(x) inversesqrt(x)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_8();
bool sub_9_32();
bool sub_33_96();
bool sub_97_113();
bool sub_146_166();
bool sub_167_249();
bool sub_189_190();
bool sub_192_193();
bool sub_195_196();
bool sub_198_200();
bool sub_226_227();
bool sub_229_230();
bool sub_232_233();
bool sub_235_237();
bool sub_250_4096();
bool sub_270_271();
bool sub_271_272();

bool exec_shader() {
    sub_250_4096();
    return true;
}

bool sub_0_8() {
    // 0: mov
    reg_tmp10 = uniforms.f[0].xxxz;
    // 1: mov
    reg_tmp10.xyz = (vs_in_reg0.xyzz).xyz;
    // 2: mov
    reg_tmp11 = uniforms.f[0].xxxx;
    // 3: mov
    reg_tmp12 = uniforms.f[0].xxxx;
    // 4: mov
    reg_tmp11.xy = (vs_in_reg1.xyyy).xy;
    // 5: mov
    reg_tmp13 = uniforms.f[0].zzzz;
    // 6: mov
    reg_tmp4 = uniforms.f[0].xxxx;
    // 7: mov
    reg_tmp5 = uniforms.f[0].xxxx;
    return false;
}
bool sub_9_32() {
    // 9: mov
    vs_out_attr0 = reg_tmp10;
    // 10: mul
    reg_tmp13 = mul_safe(uniforms.f[82], reg_tmp13);
    // 11: mul
    vs_out_attr1 = mul_safe(vs_in_reg2, reg_tmp13);
    // 12: add
    reg_tmp11.y = (uniforms.f[0].zzzz + -reg_tmp11.yyyy).y;
    // 13: add
    reg_tmp12.y = (uniforms.f[0].zzzz + -reg_tmp12.yyyy).y;
    // 14: mov
    reg_tmp14.y = (uniforms.f[81].wwww).y;
    // 15: mul
    reg_tmp14.x = (mul_safe(uniforms.f[0].wwww, reg_tmp14.yyyy)).x;
    // 16: rcp
    reg_tmp2.x = rcp_safe(reg_tmp14.xxxx.x);
    // 17: mov
    reg_tmp14.z = (reg_tmp2.xxxx).z;
    // 18: add
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp11.xyyy).xy;
    // 19: mul
    reg_tmp5.xy = (mul_safe(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    // 20: flr
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    // 21: mul
    reg_tmp4.xy = (mul_safe(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    // 22: add
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    // 23: add
    reg_tmp11.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    // 24: add
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp12.xyyy).xy;
    // 25: mul
    reg_tmp5.xy = (mul_safe(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    // 26: flr
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    // 27: mul
    reg_tmp4.xy = (mul_safe(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    // 28: add
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    // 29: add
    reg_tmp12.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    // 30: mov
    vs_out_attr2 = reg_tmp11;
    // 31: mov
    vs_out_attr3 = reg_tmp12;
    return false;
}
bool sub_33_96() {
    // 33: mov
    reg_tmp6.xyz = (-reg_tmp0.xyzz).xyz;
    // 34: mov
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    // 35: rcp
    reg_tmp7.xyz = vec3(rcp_safe(uniforms.f[81].yyyy.x));
    // 36: madi
    reg_tmp8.xyz = (fma_safe(reg_tmp6.xyzz, reg_tmp7.xyzz, uniforms.f[0].yyyy)).xyz;
    // 37: flr
    reg_tmp7.xyz = (floor(reg_tmp8.xyzz)).xyz;
    // 38: mad
    reg_tmp6.xyz = (fma_safe(reg_tmp7.xyzz, -uniforms.f[81].yyyy, reg_tmp6.xyzz)).xyz;
    // 39: min
    reg_tmp6 = min(uniforms.f[81].xxxx, reg_tmp6);
    // 40: max
    reg_tmp6 = max(-uniforms.f[81].xxxx, reg_tmp6);
    // 41: mov
    reg_tmp2 = uniforms.f[95];
    // 42: mov
    reg_tmp3 = uniforms.f[94];
    // 43: mul
    reg_tmp1.z = (mul_safe(reg_tmp6.xxxx, reg_tmp6.xxxx)).z;
    // 44: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 45: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 46: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 47: mov
    reg_tmp2 = uniforms.f[93];
    // 48: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 49: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 50: mul
    reg_tmp1.y = (mul_safe(reg_tmp1.yyyy, reg_tmp6.xxxx)).y;
    // 51: mov
    reg_tmp4.x = (reg_tmp1.xxxx).x;
    // 52: mov
    reg_tmp5.x = (reg_tmp1.yyyy).x;
    // 53: mov
    reg_tmp2 = uniforms.f[95];
    // 54: mov
    reg_tmp3 = uniforms.f[94];
    // 55: mul
    reg_tmp1.z = (mul_safe(reg_tmp6.yyyy, reg_tmp6.yyyy)).z;
    // 56: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 57: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 58: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 59: mov
    reg_tmp2 = uniforms.f[93];
    // 60: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 61: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 62: mul
    reg_tmp1.y = (mul_safe(reg_tmp1.yyyy, reg_tmp6.yyyy)).y;
    // 63: mov
    reg_tmp4.y = (reg_tmp1.xxxx).y;
    // 64: mov
    reg_tmp5.y = (reg_tmp1.yyyy).y;
    // 65: mov
    reg_tmp2 = uniforms.f[95];
    // 66: mov
    reg_tmp3 = uniforms.f[94];
    // 67: mul
    reg_tmp1.z = (mul_safe(reg_tmp6.zzzz, reg_tmp6.zzzz)).z;
    // 68: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 69: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 70: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 71: mov
    reg_tmp2 = uniforms.f[93];
    // 72: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 73: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 74: mul
    reg_tmp1.y = (mul_safe(reg_tmp1.yyyy, reg_tmp6.zzzz)).y;
    // 75: mov
    reg_tmp4.z = (reg_tmp1.xxxx).z;
    // 76: mov
    reg_tmp5.z = (reg_tmp1.yyyy).z;
    // 77: mul
    reg_tmp2.x = (mul_safe(reg_tmp4.yyyy, reg_tmp5.zzzz)).x;
    // 78: mul
    reg_tmp2.y = (mul_safe(reg_tmp5.yyyy, reg_tmp5.zzzz)).y;
    // 79: mul
    reg_tmp6.x = (mul_safe(reg_tmp4.yyyy, reg_tmp4.zzzz)).x;
    // 80: mov
    reg_tmp6.y = (reg_tmp5.zzzz).y;
    // 81: mul
    reg_tmp6.z = (mul_safe(-reg_tmp5.yyyy, reg_tmp4.zzzz)).z;
    // 82: mov
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    // 83: mul
    reg_tmp7.x = (mul_safe(-reg_tmp2.xxxx, reg_tmp4.xxxx)).x;
    // 84: mad
    reg_tmp7.x = (fma_safe(reg_tmp5.yyyy, reg_tmp5.xxxx, reg_tmp7.xxxx)).x;
    // 85: mul
    reg_tmp7.y = (mul_safe(reg_tmp4.zzzz, reg_tmp4.xxxx)).y;
    // 86: mul
    reg_tmp7.z = (mul_safe(reg_tmp2.yyyy, reg_tmp4.xxxx)).z;
    // 87: mad
    reg_tmp7.z = (fma_safe(reg_tmp4.yyyy, reg_tmp5.xxxx, reg_tmp7.zzzz)).z;
    // 88: mov
    reg_tmp7.w = (uniforms.f[0].xxxx).w;
    // 89: mul
    reg_tmp8.x = (mul_safe(reg_tmp2.xxxx, reg_tmp5.xxxx)).x;
    // 90: mad
    reg_tmp8.x = (fma_safe(reg_tmp5.yyyy, reg_tmp4.xxxx, reg_tmp8.xxxx)).x;
    // 91: mul
    reg_tmp8.y = (mul_safe(-reg_tmp4.zzzz, reg_tmp5.xxxx)).y;
    // 92: mul
    reg_tmp8.z = (mul_safe(-reg_tmp2.yyyy, reg_tmp5.xxxx)).z;
    // 93: mad
    reg_tmp8.z = (fma_safe(reg_tmp4.yyyy, reg_tmp4.xxxx, reg_tmp8.zzzz)).z;
    // 94: mov
    reg_tmp8.w = (uniforms.f[0].xxxx).w;
    // 95: mov
    reg_tmp9 = uniforms.f[0].xxxz;
    return false;
}
bool sub_97_113() {
    // 97: mov
    reg_tmp6.x = (uniforms.f[90].xxxx).x;
    // 98: mov
    reg_tmp6.y = (uniforms.f[91].xxxx).y;
    // 99: mov
    reg_tmp6.z = (uniforms.f[92].xxxx).z;
    // 100: mov
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    // 101: mov
    reg_tmp7.x = (uniforms.f[90].yyyy).x;
    // 102: mov
    reg_tmp7.y = (uniforms.f[91].yyyy).y;
    // 103: mov
    reg_tmp7.z = (uniforms.f[92].yyyy).z;
    // 104: mov
    reg_tmp7.w = (uniforms.f[0].xxxx).w;
    // 105: mov
    reg_tmp8.x = (uniforms.f[90].zzzz).x;
    // 106: mov
    reg_tmp8.y = (uniforms.f[91].zzzz).y;
    // 107: mov
    reg_tmp8.z = (uniforms.f[92].zzzz).z;
    // 108: mov
    reg_tmp8.w = (uniforms.f[0].xxxx).w;
    // 109: mov
    reg_tmp9.x = (uniforms.f[90].wwww).x;
    // 110: mov
    reg_tmp9.y = (uniforms.f[91].wwww).y;
    // 111: mov
    reg_tmp9.z = (uniforms.f[92].wwww).z;
    // 112: mov
    reg_tmp9.w = (uniforms.f[0].zzzz).w;
    return false;
}
bool sub_146_166() {
    // 146: mov
    reg_tmp2 = uniforms.f[90];
    // 147: mov
    reg_tmp3 = uniforms.f[91];
    // 148: mov
    reg_tmp4 = uniforms.f[92];
    // 149: mov
    reg_tmp5 = uniforms.f[0].xxxz;
    // 150: mul
    reg_tmp6 = mul_safe(uniforms.f[86].xxxx, reg_tmp2);
    // 151: mad
    reg_tmp6 = fma_safe(reg_tmp3, uniforms.f[86].yyyy, reg_tmp6);
    // 152: mad
    reg_tmp6 = fma_safe(reg_tmp4, uniforms.f[86].zzzz, reg_tmp6);
    // 153: mad
    reg_tmp6 = fma_safe(reg_tmp5, uniforms.f[86].wwww, reg_tmp6);
    // 154: mul
    reg_tmp7 = mul_safe(uniforms.f[87].xxxx, reg_tmp2);
    // 155: mad
    reg_tmp7 = fma_safe(reg_tmp3, uniforms.f[87].yyyy, reg_tmp7);
    // 156: mad
    reg_tmp7 = fma_safe(reg_tmp4, uniforms.f[87].zzzz, reg_tmp7);
    // 157: mad
    reg_tmp7 = fma_safe(reg_tmp5, uniforms.f[87].wwww, reg_tmp7);
    // 158: mul
    reg_tmp8 = mul_safe(uniforms.f[88].xxxx, reg_tmp2);
    // 159: mad
    reg_tmp8 = fma_safe(reg_tmp3, uniforms.f[88].yyyy, reg_tmp8);
    // 160: mad
    reg_tmp8 = fma_safe(reg_tmp4, uniforms.f[88].zzzz, reg_tmp8);
    // 161: mad
    reg_tmp8 = fma_safe(reg_tmp5, uniforms.f[88].wwww, reg_tmp8);
    // 162: mul
    reg_tmp9 = mul_safe(uniforms.f[89].xxxx, reg_tmp2);
    // 163: mad
    reg_tmp9 = fma_safe(reg_tmp3, uniforms.f[89].yyyy, reg_tmp9);
    // 164: mad
    reg_tmp9 = fma_safe(reg_tmp4, uniforms.f[89].zzzz, reg_tmp9);
    // 165: mad
    reg_tmp9 = fma_safe(reg_tmp5, uniforms.f[89].wwww, reg_tmp9);
    return false;
}
bool sub_167_249() {
    // 167: rcp
    reg_tmp2.x = rcp_safe(uniforms.f[81].yyyy.x);
    // 168: mul
    reg_tmp2.xy = (mul_safe(uniforms.f[2].zwww, reg_tmp2.xxxx)).xy;
    // 169: add
    reg_tmp2.xy = (uniforms.f[0].yyyy + reg_tmp2.xyyy).xy;
    // 170: flr
    reg_tmp3.xy = (floor(reg_tmp2.xyyy)).xy;
    // 171: mul
    reg_tmp2.xy = (mul_safe(uniforms.f[81].yyyy, reg_tmp3.xyyy)).xy;
    // 172: add
    reg_tmp2.xy = (uniforms.f[2].zwww + -reg_tmp2.xyyy).xy;
    // 173: min
    reg_tmp0.xy = (min(uniforms.f[81].xxxx, reg_tmp2.xyyy)).xy;
    // 174: max
    reg_tmp0.xy = (max(-uniforms.f[81].xxxx, reg_tmp0.xyyy)).xy;
    // 175: mov
    reg_tmp2 = uniforms.f[95];
    // 176: mov
    reg_tmp3 = uniforms.f[94];
    // 177: mul
    reg_tmp1.z = (mul_safe(reg_tmp0.xxxx, reg_tmp0.xxxx)).z;
    // 178: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 179: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 180: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 181: mov
    reg_tmp2 = uniforms.f[93];
    // 182: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 183: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 184: mul
    reg_tmp1.y = (mul_safe(reg_tmp1.yyyy, reg_tmp0.xxxx)).y;
    // 185: mov
    reg_tmp5.x = (uniforms.f[5].wwww).x;
    // 186: mov
    reg_tmp14.xy = (vs_in_reg1.xyyy).xy;
    // 187: cmp
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    // 188: ifc
    if (conditional_code.x) {
        sub_189_190();
    }
    // 190: cmp
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    // 191: ifc
    if (conditional_code.x) {
        sub_192_193();
    }
    // 193: cmp
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 194: ifc
    if (conditional_code.x) {
        sub_195_196();
    }
    // 196: cmp
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 197: ifc
    if (conditional_code.x) {
        sub_198_200();
    }
    // 200: mov
    reg_tmp3 = reg_tmp14.xyxy;
    // 201: add
    reg_tmp3.y = (uniforms.f[0].zzzz + -reg_tmp3.yyyy).y;
    // 202: add
    reg_tmp3.w = (uniforms.f[0].zzzz + -reg_tmp3.wwww).w;
    // 203: mul
    reg_tmp2 = mul_safe(uniforms.f[83].xxyy, reg_tmp3);
    // 204: add
    reg_tmp2 = -uniforms.f[0].yyyy + reg_tmp2;
    // 205: mul
    reg_tmp2 = mul_safe(reg_tmp2, reg_tmp1.xyyx);
    // 206: add
    reg_tmp2.x = (reg_tmp2.xxxx + -reg_tmp2.yyyy).x;
    // 207: add
    reg_tmp2.y = (reg_tmp2.zzzz + reg_tmp2.wwww).y;
    // 208: mov
    reg_tmp4.xy = (uniforms.f[3].xyyy).xy;
    // 209: mad
    reg_tmp3.xy = (fma_safe(reg_tmp2.xyyy, uniforms.f[3].zwww, reg_tmp4.xyyy)).xy;
    // 210: add
    reg_tmp3.xy = (uniforms.f[0].yyyy + reg_tmp3.xyyy).xy;
    // 211: mov
    reg_tmp11.xy = (reg_tmp3.xyyy).xy;
    // 212: mov
    reg_tmp2 = uniforms.f[95];
    // 213: mov
    reg_tmp3 = uniforms.f[94];
    // 214: mul
    reg_tmp1.z = (mul_safe(reg_tmp0.yyyy, reg_tmp0.yyyy)).z;
    // 215: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 216: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 217: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 218: mov
    reg_tmp2 = uniforms.f[93];
    // 219: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 220: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 221: mul
    reg_tmp1.y = (mul_safe(reg_tmp1.yyyy, reg_tmp0.yyyy)).y;
    // 222: mov
    reg_tmp5.x = (uniforms.f[6].wwww).x;
    // 223: mov
    reg_tmp14.xy = (vs_in_reg1.xyyy).xy;
    // 224: cmp
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    // 225: ifc
    if (conditional_code.x) {
        sub_226_227();
    }
    // 227: cmp
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    // 228: ifc
    if (conditional_code.x) {
        sub_229_230();
    }
    // 230: cmp
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 231: ifc
    if (conditional_code.x) {
        sub_232_233();
    }
    // 233: cmp
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 234: ifc
    if (conditional_code.x) {
        sub_235_237();
    }
    // 237: mov
    reg_tmp3 = reg_tmp14.xyxy;
    // 238: add
    reg_tmp3.y = (uniforms.f[0].zzzz + -reg_tmp3.yyyy).y;
    // 239: add
    reg_tmp3.w = (uniforms.f[0].zzzz + -reg_tmp3.wwww).w;
    // 240: mul
    reg_tmp2 = mul_safe(uniforms.f[83].zzww, reg_tmp3);
    // 241: add
    reg_tmp2 = -uniforms.f[0].yyyy + reg_tmp2;
    // 242: mul
    reg_tmp2 = mul_safe(reg_tmp2, reg_tmp1.xyyx);
    // 243: add
    reg_tmp2.x = (reg_tmp2.xxxx + -reg_tmp2.yyyy).x;
    // 244: add
    reg_tmp2.y = (reg_tmp2.zzzz + reg_tmp2.wwww).y;
    // 245: mov
    reg_tmp4.xy = (uniforms.f[4].xyyy).xy;
    // 246: mad
    reg_tmp3.xy = (fma_safe(reg_tmp2.xyyy, uniforms.f[4].zwww, reg_tmp4.xyyy)).xy;
    // 247: add
    reg_tmp3.xy = (uniforms.f[0].yyyy + reg_tmp3.xyyy).xy;
    // 248: mov
    reg_tmp12.xy = (reg_tmp3.xyyy).xy;
    return false;
}
bool sub_189_190() {
    // 189: mov
    reg_tmp14.xy = (vs_in_reg1.xyyy).xy;
    return false;
}
bool sub_192_193() {
    // 192: add
    reg_tmp14.x = (uniforms.f[0].zzzz + -vs_in_reg1.xxxx).x;
    return false;
}
bool sub_195_196() {
    // 195: add
    reg_tmp14.y = (uniforms.f[0].zzzz + -vs_in_reg1.yyyy).y;
    return false;
}
bool sub_198_200() {
    // 198: add
    reg_tmp14.x = (uniforms.f[0].zzzz + -vs_in_reg1.xxxx).x;
    // 199: add
    reg_tmp14.y = (uniforms.f[0].zzzz + -vs_in_reg1.yyyy).y;
    return false;
}
bool sub_226_227() {
    // 226: mov
    reg_tmp14.xy = (vs_in_reg1.xyyy).xy;
    return false;
}
bool sub_229_230() {
    // 229: add
    reg_tmp14.x = (uniforms.f[0].zzzz + -vs_in_reg1.xxxx).x;
    return false;
}
bool sub_232_233() {
    // 232: add
    reg_tmp14.y = (uniforms.f[0].zzzz + -vs_in_reg1.yyyy).y;
    return false;
}
bool sub_235_237() {
    // 235: add
    reg_tmp14.x = (uniforms.f[0].zzzz + -vs_in_reg1.xxxx).x;
    // 236: add
    reg_tmp14.y = (uniforms.f[0].zzzz + -vs_in_reg1.yyyy).y;
    return false;
}
bool sub_250_4096() {
    // 250: call
    {
        sub_0_8();
    }
    // 251: add
    reg_tmp10.xy = (uniforms.f[84].xyyy + reg_tmp10.xyyy).xy;
    // 252: mul
    reg_tmp10.xyz = (mul_safe(uniforms.f[2].xyxx, reg_tmp10.xyzz)).xyz;
    // 253: mov
    reg_tmp0 = uniforms.f[7];
    // 254: call
    {
        sub_33_96();
    }
    // 255: dp4
    reg_tmp2.x = dot(reg_tmp10, reg_tmp6);
    // 256: dp4
    reg_tmp2.y = dot(reg_tmp10, reg_tmp7);
    // 257: dp4
    reg_tmp2.z = dot(reg_tmp10, reg_tmp8);
    // 258: dp4
    reg_tmp2.w = dot(reg_tmp10, reg_tmp9);
    // 259: mov
    reg_tmp10 = reg_tmp2;
    // 260: call
    {
        sub_97_113();
    }
    // 261: dp4
    reg_tmp2.x = dot(reg_tmp10, reg_tmp6);
    // 262: dp4
    reg_tmp2.y = dot(reg_tmp10, reg_tmp7);
    // 263: dp4
    reg_tmp2.z = dot(reg_tmp10, reg_tmp8);
    // 264: dp4
    reg_tmp2.w = dot(uniforms.f[0].xxxz, reg_tmp10);
    // 265: mov
    reg_tmp3.xyz = (uniforms.f[5].xyzz).xyz;
    // 266: add
    reg_tmp3.xyz = (uniforms.f[85].xyzz + -reg_tmp3.xyzz).xyz;
    // 267: dp3
    reg_tmp4.x = dot(vec3(reg_tmp3.xyzz), vec3(reg_tmp3.xyzz));
    // 268: cmp
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
    // 269: ifc
    if (conditional_code.x) {
        sub_270_271();
    } else {
        sub_271_272();
    }
    // 272: mul
    reg_tmp3.xyz = (mul_safe(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
    // 273: add
    reg_tmp10.xyz = (uniforms.f[5].xyzz + reg_tmp2.xyzz).xyz;
    // 274: mad
    reg_tmp10.xyz = (fma_safe(reg_tmp3.xyzz, uniforms.f[84].zzzz, reg_tmp10.xyzz)).xyz;
    // 275: call
    {
        sub_146_166();
    }
    // 276: mov
    reg_tmp2 = reg_tmp10;
    // 277: dp4
    reg_tmp10.x = dot(reg_tmp2, reg_tmp6);
    // 278: dp4
    reg_tmp10.y = dot(reg_tmp2, reg_tmp7);
    // 279: dp4
    reg_tmp10.z = dot(reg_tmp2, reg_tmp8);
    // 280: dp4
    reg_tmp10.w = dot(reg_tmp2, reg_tmp9);
    // 281: mov
    reg_tmp2 = uniforms.f[1];
    // 282: max
    reg_tmp3 = max(uniforms.f[0].xxxx, reg_tmp2);
    // 283: min
    reg_tmp2 = min(uniforms.f[0].zzzz, reg_tmp3);
    // 284: mov
    reg_tmp13 = reg_tmp2;
    // 285: call
    {
        sub_167_249();
    }
    // 286: call
    {
        sub_9_32();
    }
    // 287: end
    return true;
}
bool sub_270_271() {
    // 270: mov
    reg_tmp4.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_271_272() {
    // 271: rsq
    reg_tmp4.x = rsq_safe(reg_tmp4.xxxx.x);
    return false;
}
// reference: 635646A99FB3ED98, DD35FB9CAEB223CF
// reference: 574BE7D50BFA62E0, C0234F4E2DEC3D4D
// program: DD35FB9CAEB223CF, CEF02063E9A18B2F, C0234F4E2DEC3D4D
// reference: 4C42279CDAC43D28, D82E12A9D19ACD63
// reference: C7A2F033017D9C6F, D82E12A9D19ACD63
// reference: A26308B8F8024BFC, 734B56B7CFCD3D95
// reference: 9E1D4A2BF708FCA9, D82E12A9D19ACD63
// reference: 15FD9D842CB15DEE, D82E12A9D19ACD63
// reference: E41816FC42BFE466, DEFAC6F185DB6EB9
// reference: 6FF8C15399064521, DEFAC6F185DB6EB9
// reference: D15E939CD6819D46, 65138AC5CA635BBF
// reference: 7E1A01DB38CB5642, 48B3A6FBA8498826
// reference: 7E1A01DB0E39C6B1, 48B3A6FBA8498826
// reference: 1C10D77E39D78153, DEFAC6F185DB6EB9
// reference: 1C10D77E0F2511A0, DEFAC6F185DB6EB9
// reference: AEDC609D70E0C038, D3C285AB726883C8
// reference: 31B19AEF04368CCF, E83C63DA8714B03E
// reference: 7F3891463DE8AAD8, E83C63DA8714B03E
// reference: 352C658CB22A0481, 01BBC054435D9EE9
// reference: D379D7DEC0652D10, DEFAC6F185DB6EB9
// reference: 589900711BDC8C57, DEFAC6F185DB6EB9
// shader: 8B30, C9DC9547E66B0D76

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 01C2FBAE8D68A718, C9DC9547E66B0D76
// program: D3C285AB726883C8, 4BD70AD09292A3DA, C9DC9547E66B0D76
// shader: 8B30, C2F63C2173A12642

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 352C658CDDD729D9, C2F63C2173A12642
// program: DEFAC6F185DB6EB9, 6CF3F3B70E23AA85, C2F63C2173A12642
// reference: 31B19AEFE88167CC, D896C1A0D13B6C62
// shader: 8B30, C412D1F985BA4118

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((rounded_primary_color.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 66ADF19D2984D851, C412D1F985BA4118
// program: DEFAC6F185DB6EB9, 6CF3F3B70E23AA85, C412D1F985BA4118
// reference: 6102F03304368CCF, E83C63DA8714B03E
// reference: 893389AF58829287, 0BBA166B3A7404D9
// shader: 8B30, CFB4DE203627A781

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0 * 2.0, alpha_output_0 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((rounded_primary_color.a) * (const_color[1].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 7EA4B6F250D460B0, CFB4DE203627A781
// program: 65138AC5CA635BBF, 3B3AE026C742C7D5, CFB4DE203627A781
// reference: 6102F033E88167CC, D896C1A0D13B6C62
// reference: 7F389146E88167CC, D896C1A0D13B6C62
// reference: 2824FA347807513E, 3E9E44CBED729440
// reference: 66ADF19D40FDD334, C412D1F985BA4118
// reference: C5B631201E3E9B72, 665EE456131D3E7B
// shader: 8B30, CC258B64F7826C9B

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 2824FA3474F6EF0B, CC258B64F7826C9B
// program: DEFAC6F185DB6EB9, 6CF3F3B70E23AA85, CC258B64F7826C9B
// reference: 789790E874F6EF0B, CC258B64F7826C9B
// reference: 31B19AEFD15F41DB, D896C1A0D13B6C62
// reference: 66ADF19D74F6EF0B, CC258B64F7826C9B
// reference: 01C2FBAEE411AC7D, C9DC9547E66B0D76
// reference: 66ADF19DF1380F6D, C6D1945D8824B670
// reference: 7EA4B6F239AD6BD5, CFB4DE203627A781
// reference: 574BE7D562836985, C0234F4E2DEC3D4D
// reference: 6102F033D15F41DB, D896C1A0D13B6C62
// reference: 32A5689752A58EDC, D82E12A9D19ACD63
// reference: B945BF38891C2F9B, D82E12A9D19ACD63
// reference: 97F000D1D49CB0E7, DEFAC6F185DB6EB9
// reference: 8B3F3A89584FA5AA, 14FCCA2A8365EF09
// shader: 8B30, A871329938D2A2AD

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor2.rgb) * (texcolor2.aaa) + (texcolor0.rgb) * (vec3(1.0) - (texcolor2.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor2.a) + (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (const_color[1].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1 * 2.0, alpha_output_1 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (last_tex_env_out.aaa) + (combiner_buffer.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) + (combiner_buffer.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp(min((rounded_primary_color.rgb) + (rounded_primary_color.rgb), vec3(1.0)) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) + (rounded_primary_color.rgb) - vec3(0.5), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 0E774EC2DFD52B25, A871329938D2A2AD
// program: D82E12A9D19ACD63, 5D764F9A6220D694, A871329938D2A2AD
// reference: D0D73B00578490FB, D82E12A9D19ACD63
// shader: 8B30, 97CA4A7391A03814

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp(min((rounded_primary_color.rgb) + (rounded_primary_color.rgb), vec3(1.0)) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) + (rounded_primary_color.rgb) - vec3(0.5), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 47D11A600A798368, 97CA4A7391A03814
// program: D82E12A9D19ACD63, 5D764F9A6220D694, 97CA4A7391A03814
// shader: 8B30, 29CEA8462618C993

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 8B3F3A89DB530FE4, 29CEA8462618C993
// program: DEFAC6F185DB6EB9, 6CF3F3B70E23AA85, 29CEA8462618C993
// shader: 8B30, 52B81720FEA5F8B2

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.a = (lut_scale_fr * LookupLightingLUTUnsigned(3, max(dot(normal, normalize(view)), 0.0)));
specular_sum.a = (lut_scale_fr * LookupLightingLUTUnsigned(3, max(dot(normal, normalize(view)), 0.0)));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor1.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (primary_fragment_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (const_color[3].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 475EE3CD1B3E9A15, 52B81720FEA5F8B2
// program: 65138AC5CA635BBF, 3B3AE026C742C7D5, 52B81720FEA5F8B2
// shader: 8B30, EE860C112ED2CC0D

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (texcolor1.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (vec3(1.0) - textureProj(tex0, vec3(texcoord0, texcoord0_w)).rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (vec3(1.0) - textureProj(tex0, vec3(texcoord0, texcoord0_w)).rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: ED547435CFD79C1A, EE860C112ED2CC0D
// program: 65138AC5CA635BBF, 3B3AE026C742C7D5, EE860C112ED2CC0D
// shader: 8B30, D2FEA64E52B75F45

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.a = (lut_scale_fr * LookupLightingLUTUnsigned(3, max(dot(normal, normalize(view)), 0.0)));
specular_sum.a = (lut_scale_fr * LookupLightingLUTUnsigned(3, max(dot(normal, normalize(view)), 0.0)));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor1.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (primary_fragment_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2 * 2.0, alpha_output_2 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 6ACE2AB994A141B6, D2FEA64E52B75F45
// program: 65138AC5CA635BBF, 3B3AE026C742C7D5, D2FEA64E52B75F45
// reference: 113CC83BAC8F8248, C0234F4E2DEC3D4D
// shader: 8B31, B8A2CA3DB47999BF

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define fma_safe(x, y, z) fma(x, y, z)
#define mul_safe(x, y) (x * y)
#define rcp_safe(x) (1.0f / x)
#define rsq_safe(x) inversesqrt(x)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_4096();

bool exec_shader() {
    sub_0_4096();
    return true;
}

bool sub_0_4096() {
    // 0: mov
    reg_tmp0 = vs_in_reg0;
    // 1: mov
    reg_tmp0.w = (uniforms.f[78].yyyy).w;
    // 2: dp4
    vs_out_attr0.x = dot(uniforms.f[0], reg_tmp0);
    // 3: dp4
    vs_out_attr0.y = dot(uniforms.f[1], reg_tmp0);
    // 4: dp4
    vs_out_attr0.z = dot(uniforms.f[2], reg_tmp0);
    // 5: dp4
    vs_out_attr0.w = dot(uniforms.f[3], reg_tmp0);
    // 6: mul
    vs_out_attr1 = mul_safe(uniforms.f[77], vs_in_reg1);
    // 7: mov
    vs_out_attr2 = vs_in_reg2;
    // 8: mov
    vs_out_attr3 = vs_in_reg3;
    // 9: mov
    vs_out_attr4 = vs_in_reg4;
    // 10: end
    return true;
}
// reference: 3FD83353C5E6A6D0, B8A2CA3DB47999BF
// shader: 8B30, 164F185208504CA3

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((texcolor1.rgb) * (const_color[3].rgb) + (texcolor0.rgb) * (vec3(1.0) - (const_color[3].rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((1.0 - texcolor1.a) * (const_color[3].a) + (1.0 - texcolor0.a) * (1.0 - (const_color[3].a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((texcolor2.rgb) * (const_color[4].rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (const_color[4].rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((1.0 - texcolor2.a) * (const_color[4].a) + (last_tex_env_out.a) * (1.0 - (const_color[4].a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a) * (const_color[5].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: ABCCD8914DBA4F88, 164F185208504CA3
// program: B8A2CA3DB47999BF, 5D764F9A6220D694, 164F185208504CA3
// reference: B438E4FC1C2DA562, B8A2CA3DB47999BF
// shader: 8B30, 4A8DF800808D36AB

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((texcolor1.rgb) * (const_color[3].rgb) + (texcolor0.rgb) * (vec3(1.0) - (const_color[3].rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((1.0 - texcolor1.a) * (const_color[3].a) + (1.0 - texcolor0.a) * (1.0 - (const_color[3].a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((texcolor2.rgb) * (const_color[4].rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (const_color[4].rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((1.0 - texcolor2.a) * (const_color[4].a) + (last_tex_env_out.a) * (1.0 - (const_color[4].a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 2671DA8F87E960A8, 4A8DF800808D36AB
// program: B8A2CA3DB47999BF, 5D764F9A6220D694, 4A8DF800808D36AB
// shader: 8B30, C4E77F8F6068A470

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor1.aaa) * (const_color[0].rgb) + (texcolor1.aaa), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (last_tex_env_out.rgb) + (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((const_color[1].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rrr) * (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((const_color[2].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_3 = byteround(clamp((combiner_buffer.ggg) * (const_color[3].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_4 = byteround(clamp((combiner_buffer.bbb) * (const_color[4].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 616CE83E5B58BA9B, C4E77F8F6068A470
// program: B8A2CA3DB47999BF, 5D764F9A6220D694, C4E77F8F6068A470
// shader: 8B31, 5447A3297E824FE0

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define fma_safe(x, y, z) fma(x, y, z)
#define mul_safe(x, y) (x * y)
#define rcp_safe(x) (1.0f / x)
#define rsq_safe(x) inversesqrt(x)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_7_12();
bool sub_12_21();
bool sub_21_34();
bool sub_34_118();
bool sub_46_66();
bool sub_66_107();
bool sub_67_90();
bool sub_90_106();
bool sub_116_117();
bool sub_118_135();
bool sub_135_211();
bool sub_174_194();
bool sub_175_180();
bool sub_180_193();
bool sub_184_187();
bool sub_187_192();
bool sub_194_207();
bool sub_195_200();
bool sub_200_206();
bool sub_211_221();
bool sub_216_220();
bool sub_217_218();
bool sub_312_4096();

bool exec_shader() {
    sub_312_4096();
    return true;
}

bool sub_7_12() {
    // 7: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 8: dp4
    reg_tmp3.x = dot(uniforms.f[25 + address_registers.x], reg_tmp15);
    // 9: dp4
    reg_tmp3.y = dot(uniforms.f[26 + address_registers.x], reg_tmp15);
    // 10: dp4
    reg_tmp3.z = dot(uniforms.f[27 + address_registers.x], reg_tmp15);
    // 11: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    return false;
}
bool sub_12_21() {
    // 12: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 13: dp4
    reg_tmp3.x = dot(uniforms.f[25 + address_registers.x], reg_tmp15);
    // 14: dp4
    reg_tmp3.y = dot(uniforms.f[26 + address_registers.x], reg_tmp15);
    // 15: dp4
    reg_tmp3.z = dot(uniforms.f[27 + address_registers.x], reg_tmp15);
    // 16: dp3
    reg_tmp4.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp14));
    // 17: dp3
    reg_tmp4.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp14));
    // 18: dp3
    reg_tmp4.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp14));
    // 19: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 20: mad
    reg_tmp12 = fma_safe(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_21_34() {
    // 21: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 22: dp4
    reg_tmp3.x = dot(uniforms.f[25 + address_registers.x], reg_tmp15);
    // 23: dp4
    reg_tmp3.y = dot(uniforms.f[26 + address_registers.x], reg_tmp15);
    // 24: dp4
    reg_tmp3.z = dot(uniforms.f[27 + address_registers.x], reg_tmp15);
    // 25: dp3
    reg_tmp4.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp14));
    // 26: dp3
    reg_tmp4.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp14));
    // 27: dp3
    reg_tmp4.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp14));
    // 28: dp3
    reg_tmp5.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp13));
    // 29: dp3
    reg_tmp5.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp13));
    // 30: dp3
    reg_tmp5.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp13));
    // 31: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 32: mad
    reg_tmp12 = fma_safe(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    // 33: mad
    reg_tmp11 = fma_safe(reg_tmp1.wwww, reg_tmp5, reg_tmp11);
    return false;
}
bool sub_34_118() {
    // 34: mul
    reg_tmp15.xyz = (mul_safe(uniforms.f[7].xxxx, vs_in_reg0)).xyz;
    // 35: mul
    reg_tmp14.xyz = (mul_safe(uniforms.f[7].yyyy, vs_in_reg1)).xyz;
    // 36: mul
    reg_tmp13.xyz = (mul_safe(uniforms.f[7].zzzz, vs_in_reg2)).xyz;
    // 37: add
    reg_tmp15.xyz = (uniforms.f[6] + reg_tmp15).xyz;
    // 38: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 39: mov
    reg_tmp0 = uniforms.f[7];
    // 40: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.yzzz));
    // 41: mov
    reg_tmp7 = uniforms.f[93].xxxx;
    // 42: mov
    reg_tmp12 = uniforms.f[93].xxxx;
    // 43: mov
    reg_tmp11 = uniforms.f[93].xxxx;
    // 44: mul
    reg_tmp2 = mul_safe(uniforms.f[93].wwww, vs_in_reg7);
    // 45: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_46_66();
    } else {
        sub_66_107();
    }
    // 107: mov
    vs_out_attr2 = -reg_tmp15;
    // 108: dp4
    reg_tmp0.x = dot(uniforms.f[86], reg_tmp15);
    // 109: dp4
    reg_tmp0.y = dot(uniforms.f[87], reg_tmp15);
    // 110: dp4
    reg_tmp0.z = dot(uniforms.f[88], reg_tmp15);
    // 111: dp4
    reg_tmp0.w = dot(uniforms.f[89], reg_tmp15);
    // 112: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 113: mul
    reg_tmp1.y = (mul_safe(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
    // 114: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 115: ifc
    if (all(conditional_code)) {
        sub_116_117();
    }
    // 117: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_46_66() {
    // 46: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 47: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 48: call
    {
        sub_12_21();
    }
    // 49: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 50: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 51: call
    {
        sub_12_21();
    }
    // 52: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 53: dp4
    reg_tmp10.x = dot(uniforms.f[0], reg_tmp7);
    // 54: dp4
    reg_tmp10.y = dot(uniforms.f[1], reg_tmp7);
    // 55: dp4
    reg_tmp10.z = dot(uniforms.f[2], reg_tmp7);
    // 56: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 57: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 58: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 59: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 60: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 61: dp3
    reg_tmp14.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp12));
    // 62: dp3
    reg_tmp14.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp12));
    // 63: dp3
    reg_tmp14.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp12));
    // 64: call
    {
        sub_118_135();
    }
    // 65: nop
    return false;
}
bool sub_66_107() {
    // 66: ifc
    if (all(conditional_code)) {
        sub_67_90();
    } else {
        sub_90_106();
    }
    // 106: nop
    return false;
}
bool sub_67_90() {
    // 67: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 68: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 69: call
    {
        sub_21_34();
    }
    // 70: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 71: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 72: call
    {
        sub_21_34();
    }
    // 73: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 74: dp4
    reg_tmp10.x = dot(uniforms.f[0], reg_tmp7);
    // 75: dp4
    reg_tmp10.y = dot(uniforms.f[1], reg_tmp7);
    // 76: dp4
    reg_tmp10.z = dot(uniforms.f[2], reg_tmp7);
    // 77: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 78: dp3
    reg_tmp13.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp11));
    // 79: dp3
    reg_tmp13.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp11));
    // 80: dp3
    reg_tmp13.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp11));
    // 81: dp3
    reg_tmp14.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp12));
    // 82: dp3
    reg_tmp14.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp12));
    // 83: dp3
    reg_tmp14.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp12));
    // 84: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 85: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 86: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 87: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 88: call
    {
        sub_135_211();
    }
    // 89: nop
    return false;
}
bool sub_90_106() {
    // 90: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 91: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 92: call
    {
        sub_7_12();
    }
    // 93: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 94: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 95: call
    {
        sub_7_12();
    }
    // 96: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 97: dp4
    reg_tmp10.x = dot(uniforms.f[0], reg_tmp7);
    // 98: dp4
    reg_tmp10.y = dot(uniforms.f[1], reg_tmp7);
    // 99: dp4
    reg_tmp10.z = dot(uniforms.f[2], reg_tmp7);
    // 100: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 101: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 102: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 103: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 104: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 105: mov
    vs_out_attr1 = uniforms.f[93].xxxx;
    return false;
}
bool sub_116_117() {
    // 116: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_118_135() {
    uint jmp_to = 118u;
    while (true) {
        switch (jmp_to) {
        case 118u: {
            // 118: dp3
            reg_tmp6.x = dot(vec3(reg_tmp14), vec3(reg_tmp14));
            // 119: dp3
            reg_tmp7.x = dot(vec3(reg_tmp12), vec3(reg_tmp12));
            // 120: rsq
            reg_tmp6.x = rsq_safe(reg_tmp6.xxxx.x);
            // 121: rsq
            reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
            // 122: mul
            reg_tmp14.xyz = (mul_safe(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 123: mul
            reg_tmp12.xyz = (mul_safe(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 124: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 125: jmpu
            if (!uniforms.b[3]) {
                { jmp_to = 134u; break; }
            }
            // 126: add
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            // 127: mul
            reg_tmp4 = mul_safe(uniforms.f[94].zzzz, reg_tmp4);
            // 128: cmp
            conditional_code = greaterThanEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp4.xxxx));
            // 129: rsq
            reg_tmp4 = vec4(rsq_safe(reg_tmp4.xxxx.x));
            // 130: mul
            reg_tmp5 = mul_safe(uniforms.f[94].zzzz, reg_tmp14);
            // 131: jmpc
            if (conditional_code.x) {
                { jmp_to = 134u; break; }
            }
            // 132: rcp
            reg_tmp0.z = rcp_safe(reg_tmp4.xxxx.x);
            // 133: mul
            reg_tmp0.xy = (mul_safe(reg_tmp5, reg_tmp4)).xy;
        }
        case 134u: {
            // 134: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_135_211() {
    uint jmp_to = 135u;
    while (true) {
        switch (jmp_to) {
        case 135u: {
            // 135: dp3
            reg_tmp6.x = dot(vec3(reg_tmp14), vec3(reg_tmp14));
            // 136: dp3
            reg_tmp7.x = dot(vec3(reg_tmp12), vec3(reg_tmp12));
            // 137: rsq
            reg_tmp6.x = rsq_safe(reg_tmp6.xxxx.x);
            // 138: rsq
            reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
            // 139: mul
            reg_tmp14.xyz = (mul_safe(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 140: mul
            reg_tmp12.xyz = (mul_safe(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 141: mul
            reg_tmp13.xyz = (mul_safe(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            // 142: mul
            reg_tmp11.xyz = (mul_safe(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            // 143: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 144: jmpu
            if (!uniforms.b[3]) {
                { jmp_to = 210u; break; }
            }
            // 145: mul
            reg_tmp13.xyz = (mul_safe(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            // 146: mul
            reg_tmp11.xyz = (mul_safe(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            // 147: mul
            reg_tmp5 = mul_safe(reg_tmp14.yzxx, reg_tmp13.zxyy);
            // 148: mad
            reg_tmp5 = fma_safe(-reg_tmp13.yzxx, reg_tmp14.zxyy, reg_tmp5);
            // 149: dp3
            reg_tmp5.w = dot(vec3(reg_tmp5), vec3(reg_tmp5));
            // 150: rsq
            reg_tmp5.w = rsq_safe(reg_tmp5.wwww.x);
            // 151: mul
            reg_tmp5 = mul_safe(reg_tmp5, reg_tmp5.wwww);
            // 152: add
            reg_tmp6.w = (reg_tmp14.zzzz + reg_tmp5.yyyy).w;
            // 153: mul
            reg_tmp13 = mul_safe(reg_tmp5.yzxx, reg_tmp14.zxyy);
            // 154: mad
            reg_tmp13 = fma_safe(-reg_tmp14.yzxx, reg_tmp5.zxyy, reg_tmp13);
            // 155: add
            reg_tmp6.w = (reg_tmp13.xxxx + reg_tmp6).w;
            // 156: mov
            reg_tmp13.w = (reg_tmp5.zzzz).w;
            // 157: mov
            reg_tmp5.z = (reg_tmp13.xxxx).z;
            // 158: add
            reg_tmp6.w = (uniforms.f[93].yyyy + reg_tmp6).w;
            // 159: mov
            reg_tmp14.w = (reg_tmp5.xxxx).w;
            // 160: mov
            reg_tmp5.x = (reg_tmp14.zzzz).x;
            // 161: cmp
            conditional_code = lessThan(vec2(uniforms.f[94].yyyy), vec2(reg_tmp6.wwww));
            // 162: mov
            reg_tmp6.x = (uniforms.f[93].yyyy).x;
            // 163: mov
            reg_tmp6.y = (-uniforms.f[93].yyyy).y;
            // 164: jmpc
            if (!conditional_code.x) {
                { jmp_to = 172u; break; }
            }
            // 165: add
            reg_tmp7.xz = (reg_tmp13.wwyy + -reg_tmp14.yyww).xz;
            // 166: add
            reg_tmp7.y = (reg_tmp14.xxxx + -reg_tmp13.zzzz).y;
            // 167: mov
            reg_tmp7.w = (reg_tmp6).w;
            // 168: dp4
            reg_tmp6 = vec4(dot(reg_tmp7, reg_tmp7));
            // 169: rsq
            reg_tmp6 = vec4(rsq_safe(reg_tmp6.xxxx.x));
            // 170: mul
            reg_tmp0 = mul_safe(reg_tmp7, reg_tmp6);
            // 171: jmpu
            if (uniforms.b[0]) {
                { jmp_to = 210u; break; }
            }
        }
        case 172u: {
            // 172: cmp
            conditional_code = greaterThan(vec2(reg_tmp5.zyyy), vec2(reg_tmp5.yxxx));
            // 173: ifc
            if (conditional_code.x) {
                sub_174_194();
            } else {
                sub_194_207();
            }
            // 207: dp4
            reg_tmp6 = vec4(dot(reg_tmp8, reg_tmp8));
            // 208: rsq
            reg_tmp6 = vec4(rsq_safe(reg_tmp6.xxxx.x));
            // 209: mul
            reg_tmp0 = mul_safe(reg_tmp8, reg_tmp6);
        }
        case 210u: {
            // 210: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_174_194() {
    // 174: ifc
    if (conditional_code.y) {
        sub_175_180();
    } else {
        sub_180_193();
    }
    // 193: mov
    reg_tmp8.w = (-reg_tmp8).w;
    return false;
}
bool sub_175_180() {
    // 175: mul
    reg_tmp8 = mul_safe(reg_tmp13.yyzw, reg_tmp6.xxxy);
    // 176: add
    reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
    // 177: add
    reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
    // 178: add
    reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
    // 179: add
    reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
    return false;
}
bool sub_180_193() {
    // 180: cmp
    conditional_code = greaterThan(vec2(reg_tmp5.zzzz), vec2(reg_tmp5.xxxx));
    // 181: mul
    reg_tmp8 = mul_safe(reg_tmp13.yyzw, reg_tmp6.xxxy);
    // 182: add
    reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
    // 183: ifc
    if (conditional_code.x) {
        sub_184_187();
    } else {
        sub_187_192();
    }
    // 192: nop
    return false;
}
bool sub_184_187() {
    // 184: add
    reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
    // 185: add
    reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
    // 186: add
    reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
    return false;
}
bool sub_187_192() {
    // 187: mul
    reg_tmp8 = mul_safe(reg_tmp13.zwwy, reg_tmp6.xxxy);
    // 188: add
    reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
    // 189: add
    reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
    // 190: add
    reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
    // 191: add
    reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
    return false;
}
bool sub_194_207() {
    // 194: ifc
    if (conditional_code.y) {
        sub_195_200();
    } else {
        sub_200_206();
    }
    // 206: nop
    return false;
}
bool sub_195_200() {
    // 195: mul
    reg_tmp8 = mul_safe(reg_tmp13.yywz, reg_tmp6.xxxy);
    // 196: add
    reg_tmp8.y = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).y;
    // 197: add
    reg_tmp9 = reg_tmp5.yyyy + -reg_tmp5.xxxx;
    // 198: add
    reg_tmp8.xzw = (reg_tmp8 + reg_tmp14.wwyx).xzw;
    // 199: add
    reg_tmp8.y = (reg_tmp9 + reg_tmp8).y;
    return false;
}
bool sub_200_206() {
    // 200: mul
    reg_tmp8 = mul_safe(reg_tmp13.zwwy, reg_tmp6.xxxy);
    // 201: add
    reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
    // 202: add
    reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
    // 203: add
    reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
    // 204: add
    reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
    // 205: mov
    reg_tmp8.w = (-reg_tmp8).w;
    return false;
}
bool sub_211_221() {
    // 211: mov
    reg_tmp0.y = (uniforms.f[7].wwww).y;
    // 212: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.xyyy));
    // 213: mov
    reg_tmp9 = uniforms.f[21];
    // 214: mul
    reg_tmp0 = mul_safe(uniforms.f[7].wwww, vs_in_reg3);
    // 215: ifc
    if (conditional_code.y) {
        sub_216_220();
    }
    // 220: max
    vs_out_attr3 = max(uniforms.f[93].xxxx, reg_tmp9);
    return false;
}
bool sub_216_220() {
    // 216: ifu
    if (uniforms.b[7]) {
        sub_217_218();
    }
    // 218: mul
    reg_tmp9.xyz = (mul_safe(uniforms.f[20].wwww, reg_tmp0.xyzz)).xyz;
    // 219: mov
    reg_tmp8.x = (uniforms.f[93].yyyy).x;
    return false;
}
bool sub_217_218() {
    // 217: mul
    reg_tmp9.w = (mul_safe(reg_tmp9.wwww, reg_tmp0.wwww)).w;
    return false;
}
bool sub_312_4096() {
    // 312: call
    {
        sub_34_118();
    }
    // 313: call
    {
        sub_211_221();
    }
    // 314: end
    return true;
}
// reference: 726D6482E34B824E, 5447A3297E824FE0
// shader: 8B30, 47C12CB4EFB88BF9

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D4F4BEF9C319DFFA, 47C12CB4EFB88BF9
// program: 5447A3297E824FE0, 4BD70AD09292A3DA, 47C12CB4EFB88BF9
// reference: 9A53263D8729D1F6, B8A2CA3DB47999BF
// shader: 8B30, C35EFD5CB098882B

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((texcolor1.rrr) * (const_color[4].rrr) + (texcolor0.rrr) * (vec3(1.0) - (const_color[4].rrr)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((texcolor2.rrr) * (const_color[5].rrr) + (last_tex_env_out.ggg) * (vec3(1.0) - (const_color[5].rrr)), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((const_color[5].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 17848FD02DD362BD, C35EFD5CB098882B
// program: B8A2CA3DB47999BF, 5D764F9A6220D694, C35EFD5CB098882B
// reference: 11B3F192DE8681C7, B8A2CA3DB47999BF
// shader: 8B30, 6A1933A6AC0DAA00

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((texcolor1.rrr) * (const_color[4].rrr) + (texcolor0.rrr) * (vec3(1.0) - (const_color[4].rrr)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb) + (texcolor2.ggg) * (vec3(1.0) - (const_color[5].rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((const_color[5].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: EEDBFDA50343AD70, 6A1933A6AC0DAA00
// program: B8A2CA3DB47999BF, 5D764F9A6220D694, 6A1933A6AC0DAA00
// reference: 755C2E6E493E0501, D82E12A9D19ACD63
// reference: A46F7D222331DED1, DEFAC6F185DB6EB9
// shader: 8B31, C686B1FD59F65802

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;
 out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define fma_safe(x, y, z) fma(x, y, z)
#define mul_safe(x, y) (x * y)
#define rcp_safe(x) (1.0f / x)
#define rsq_safe(x) inversesqrt(x)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_4096();
bool sub_7_12();
bool sub_12_21();
bool sub_21_34();
bool sub_34_218();
bool sub_40_146();
bool sub_47_76();
bool sub_58_62();
bool sub_76_135();
bool sub_77_109();
bool sub_88_92();
bool sub_109_134();
bool sub_120_124();
bool sub_144_145();
bool sub_146_217();
bool sub_149_159();
bool sub_159_168();
bool sub_169_181();
bool sub_181_206();
bool sub_182_200();
bool sub_200_205();
bool sub_215_216();
bool sub_218_235();
bool sub_235_311();
bool sub_274_294();
bool sub_275_280();
bool sub_280_293();
bool sub_284_287();
bool sub_287_292();
bool sub_294_307();
bool sub_295_300();
bool sub_300_306();
bool sub_311_323();
bool sub_316_321();
bool sub_318_319();
bool sub_323_333();
bool sub_330_331();
bool sub_333_360();
bool sub_335_340();
bool sub_340_359();
bool sub_343_349();
bool sub_349_358();
bool sub_350_354();
bool sub_354_357();
bool sub_360_368();
bool sub_362_363();
bool sub_363_367();
bool sub_364_365();
bool sub_365_366();
bool sub_368_375();
bool sub_375_379();
bool sub_379_403();
bool sub_381_385();
bool sub_385_402();
bool sub_386_400();
bool sub_389_396();
bool sub_396_399();
bool sub_400_401();
bool sub_403_419();
bool sub_405_409();
bool sub_409_418();
bool sub_410_416();
bool sub_416_417();

bool exec_shader() {
    sub_0_4096();
    return true;
}

bool sub_0_4096() {
    // 0: call
    {
        sub_34_218();
    }
    // 1: call
    {
        sub_311_323();
    }
    // 2: call
    {
        sub_333_360();
    }
    // 3: call
    {
        sub_379_403();
    }
    // 4: call
    {
        sub_403_419();
    }
    // 5: end
    return true;
}
bool sub_7_12() {
    // 7: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 8: dp4
    reg_tmp3.x = dot(uniforms.f[25 + address_registers.x], reg_tmp15);
    // 9: dp4
    reg_tmp3.y = dot(uniforms.f[26 + address_registers.x], reg_tmp15);
    // 10: dp4
    reg_tmp3.z = dot(uniforms.f[27 + address_registers.x], reg_tmp15);
    // 11: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    return false;
}
bool sub_12_21() {
    // 12: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 13: dp4
    reg_tmp3.x = dot(uniforms.f[25 + address_registers.x], reg_tmp15);
    // 14: dp4
    reg_tmp3.y = dot(uniforms.f[26 + address_registers.x], reg_tmp15);
    // 15: dp4
    reg_tmp3.z = dot(uniforms.f[27 + address_registers.x], reg_tmp15);
    // 16: dp3
    reg_tmp4.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp14));
    // 17: dp3
    reg_tmp4.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp14));
    // 18: dp3
    reg_tmp4.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp14));
    // 19: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 20: mad
    reg_tmp12 = fma_safe(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_21_34() {
    // 21: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 22: dp4
    reg_tmp3.x = dot(uniforms.f[25 + address_registers.x], reg_tmp15);
    // 23: dp4
    reg_tmp3.y = dot(uniforms.f[26 + address_registers.x], reg_tmp15);
    // 24: dp4
    reg_tmp3.z = dot(uniforms.f[27 + address_registers.x], reg_tmp15);
    // 25: dp3
    reg_tmp4.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp14));
    // 26: dp3
    reg_tmp4.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp14));
    // 27: dp3
    reg_tmp4.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp14));
    // 28: dp3
    reg_tmp5.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp13));
    // 29: dp3
    reg_tmp5.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp13));
    // 30: dp3
    reg_tmp5.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp13));
    // 31: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 32: mad
    reg_tmp12 = fma_safe(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    // 33: mad
    reg_tmp11 = fma_safe(reg_tmp1.wwww, reg_tmp5, reg_tmp11);
    return false;
}
bool sub_34_218() {
    // 34: mul
    reg_tmp15.xyz = (mul_safe(uniforms.f[7].xxxx, vs_in_reg0)).xyz;
    // 35: mul
    reg_tmp14.xyz = (mul_safe(uniforms.f[7].yyyy, vs_in_reg1)).xyz;
    // 36: mul
    reg_tmp13.xyz = (mul_safe(uniforms.f[7].zzzz, vs_in_reg2)).xyz;
    // 37: add
    reg_tmp15.xyz = (uniforms.f[6] + reg_tmp15).xyz;
    // 38: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 39: ifu
    if (uniforms.b[1]) {
        sub_40_146();
    } else {
        sub_146_217();
    }
    // 217: nop
    return false;
}
bool sub_40_146() {
    // 40: mov
    reg_tmp0 = uniforms.f[7];
    // 41: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.yzzz));
    // 42: mov
    reg_tmp7 = uniforms.f[93].xxxx;
    // 43: mov
    reg_tmp12 = uniforms.f[93].xxxx;
    // 44: mov
    reg_tmp11 = uniforms.f[93].xxxx;
    // 45: mul
    reg_tmp2 = mul_safe(uniforms.f[93].wwww, vs_in_reg7);
    // 46: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_47_76();
    } else {
        sub_76_135();
    }
    // 135: mov
    vs_out_attr2 = -reg_tmp15;
    // 136: dp4
    reg_tmp0.x = dot(uniforms.f[86], reg_tmp15);
    // 137: dp4
    reg_tmp0.y = dot(uniforms.f[87], reg_tmp15);
    // 138: dp4
    reg_tmp0.z = dot(uniforms.f[88], reg_tmp15);
    // 139: dp4
    reg_tmp0.w = dot(uniforms.f[89], reg_tmp15);
    // 140: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 141: mul
    reg_tmp1.y = (mul_safe(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
    // 142: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 143: ifc
    if (all(conditional_code)) {
        sub_144_145();
    }
    // 145: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_47_76() {
    // 47: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 48: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 49: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 50: call
    {
        sub_12_21();
    }
    // 51: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 52: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 53: call
    {
        sub_12_21();
    }
    // 54: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 55: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 56: callc
    if (conditional_code.x) {
        sub_12_21();
    }
    // 57: ifu
    if (uniforms.b[8]) {
        sub_58_62();
    }
    // 62: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 63: dp4
    reg_tmp10.x = dot(uniforms.f[0], reg_tmp7);
    // 64: dp4
    reg_tmp10.y = dot(uniforms.f[1], reg_tmp7);
    // 65: dp4
    reg_tmp10.z = dot(uniforms.f[2], reg_tmp7);
    // 66: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 67: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 68: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 69: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 70: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 71: dp3
    reg_tmp14.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp12));
    // 72: dp3
    reg_tmp14.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp12));
    // 73: dp3
    reg_tmp14.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp12));
    // 74: call
    {
        sub_218_235();
    }
    // 75: nop
    return false;
}
bool sub_58_62() {
    // 58: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 59: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 60: callc
    if (conditional_code.y) {
        sub_12_21();
    }
    // 61: nop
    return false;
}
bool sub_76_135() {
    // 76: ifc
    if (all(conditional_code)) {
        sub_77_109();
    } else {
        sub_109_134();
    }
    // 134: nop
    return false;
}
bool sub_77_109() {
    // 77: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 78: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 79: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 80: call
    {
        sub_21_34();
    }
    // 81: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 82: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 83: call
    {
        sub_21_34();
    }
    // 84: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 85: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 86: callc
    if (conditional_code.x) {
        sub_21_34();
    }
    // 87: ifu
    if (uniforms.b[8]) {
        sub_88_92();
    }
    // 92: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 93: dp4
    reg_tmp10.x = dot(uniforms.f[0], reg_tmp7);
    // 94: dp4
    reg_tmp10.y = dot(uniforms.f[1], reg_tmp7);
    // 95: dp4
    reg_tmp10.z = dot(uniforms.f[2], reg_tmp7);
    // 96: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 97: dp3
    reg_tmp13.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp11));
    // 98: dp3
    reg_tmp13.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp11));
    // 99: dp3
    reg_tmp13.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp11));
    // 100: dp3
    reg_tmp14.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp12));
    // 101: dp3
    reg_tmp14.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp12));
    // 102: dp3
    reg_tmp14.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp12));
    // 103: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 104: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 105: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 106: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 107: call
    {
        sub_235_311();
    }
    // 108: nop
    return false;
}
bool sub_88_92() {
    // 88: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 89: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 90: callc
    if (conditional_code.y) {
        sub_21_34();
    }
    // 91: nop
    return false;
}
bool sub_109_134() {
    // 109: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 110: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 111: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 112: call
    {
        sub_7_12();
    }
    // 113: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 114: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 115: call
    {
        sub_7_12();
    }
    // 116: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 117: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 118: callc
    if (conditional_code.x) {
        sub_7_12();
    }
    // 119: ifu
    if (uniforms.b[8]) {
        sub_120_124();
    }
    // 124: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 125: dp4
    reg_tmp10.x = dot(uniforms.f[0], reg_tmp7);
    // 126: dp4
    reg_tmp10.y = dot(uniforms.f[1], reg_tmp7);
    // 127: dp4
    reg_tmp10.z = dot(uniforms.f[2], reg_tmp7);
    // 128: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 129: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 130: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 131: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 132: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 133: mov
    vs_out_attr1 = uniforms.f[93].xxxx;
    return false;
}
bool sub_120_124() {
    // 120: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 121: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 122: callc
    if (conditional_code.y) {
        sub_7_12();
    }
    // 123: nop
    return false;
}
bool sub_144_145() {
    // 144: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_146_217() {
    // 146: mov
    reg_tmp0 = uniforms.f[7];
    // 147: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.yzzz));
    // 148: ifu
    if (uniforms.b[2]) {
        sub_149_159();
    } else {
        sub_159_168();
    }
    // 168: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_169_181();
    } else {
        sub_181_206();
    }
    // 206: mov
    vs_out_attr2 = -reg_tmp15;
    // 207: dp4
    reg_tmp0.x = dot(uniforms.f[86], reg_tmp15);
    // 208: dp4
    reg_tmp0.y = dot(uniforms.f[87], reg_tmp15);
    // 209: dp4
    reg_tmp0.z = dot(uniforms.f[88], reg_tmp15);
    // 210: dp4
    reg_tmp0.w = dot(uniforms.f[89], reg_tmp15);
    // 211: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 212: mul
    reg_tmp1.y = (mul_safe(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
    // 213: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 214: ifc
    if (all(conditional_code)) {
        sub_215_216();
    }
    // 216: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_149_159() {
    // 149: mul
    reg_tmp1.x = (mul_safe(uniforms.f[93].wwww, vs_in_reg7.xxxx)).x;
    // 150: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 151: dp4
    reg_tmp7.x = dot(uniforms.f[25 + address_registers.x], reg_tmp15);
    // 152: dp4
    reg_tmp7.y = dot(uniforms.f[26 + address_registers.x], reg_tmp15);
    // 153: dp4
    reg_tmp7.z = dot(uniforms.f[27 + address_registers.x], reg_tmp15);
    // 154: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 155: dp4
    reg_tmp10.x = dot(uniforms.f[0], reg_tmp7);
    // 156: dp4
    reg_tmp10.y = dot(uniforms.f[1], reg_tmp7);
    // 157: dp4
    reg_tmp10.z = dot(uniforms.f[2], reg_tmp7);
    // 158: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_159_168() {
    // 159: mova
    address_registers.x = (ivec2(uniforms.f[93].xxxx)).x;
    // 160: dp4
    reg_tmp7.x = dot(uniforms.f[25], reg_tmp15);
    // 161: dp4
    reg_tmp7.y = dot(uniforms.f[26], reg_tmp15);
    // 162: dp4
    reg_tmp7.z = dot(uniforms.f[27], reg_tmp15);
    // 163: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 164: dp4
    reg_tmp10.x = dot(uniforms.f[0], reg_tmp7);
    // 165: dp4
    reg_tmp10.y = dot(uniforms.f[1], reg_tmp7);
    // 166: dp4
    reg_tmp10.z = dot(uniforms.f[2], reg_tmp7);
    // 167: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    return false;
}
bool sub_169_181() {
    // 169: dp3
    reg_tmp12.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp14));
    // 170: dp3
    reg_tmp12.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp14));
    // 171: dp3
    reg_tmp12.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp14));
    // 172: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 173: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 174: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 175: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 176: dp3
    reg_tmp14.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp12));
    // 177: dp3
    reg_tmp14.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp12));
    // 178: dp3
    reg_tmp14.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp12));
    // 179: call
    {
        sub_218_235();
    }
    // 180: nop
    return false;
}
bool sub_181_206() {
    // 181: ifc
    if (all(conditional_code)) {
        sub_182_200();
    } else {
        sub_200_205();
    }
    // 205: nop
    return false;
}
bool sub_182_200() {
    // 182: dp3
    reg_tmp12.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp14));
    // 183: dp3
    reg_tmp12.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp14));
    // 184: dp3
    reg_tmp12.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp14));
    // 185: dp3
    reg_tmp11.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp13));
    // 186: dp3
    reg_tmp11.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp13));
    // 187: dp3
    reg_tmp11.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp13));
    // 188: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 189: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 190: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 191: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 192: dp3
    reg_tmp14.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp12));
    // 193: dp3
    reg_tmp14.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp12));
    // 194: dp3
    reg_tmp14.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp12));
    // 195: dp3
    reg_tmp13.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp11));
    // 196: dp3
    reg_tmp13.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp11));
    // 197: dp3
    reg_tmp13.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp11));
    // 198: call
    {
        sub_235_311();
    }
    // 199: nop
    return false;
}
bool sub_200_205() {
    // 200: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 201: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 202: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 203: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 204: mov
    vs_out_attr1 = uniforms.f[93].xxxx;
    return false;
}
bool sub_215_216() {
    // 215: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_218_235() {
    uint jmp_to = 218u;
    while (true) {
        switch (jmp_to) {
        case 218u: {
            // 218: dp3
            reg_tmp6.x = dot(vec3(reg_tmp14), vec3(reg_tmp14));
            // 219: dp3
            reg_tmp7.x = dot(vec3(reg_tmp12), vec3(reg_tmp12));
            // 220: rsq
            reg_tmp6.x = rsq_safe(reg_tmp6.xxxx.x);
            // 221: rsq
            reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
            // 222: mul
            reg_tmp14.xyz = (mul_safe(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 223: mul
            reg_tmp12.xyz = (mul_safe(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 224: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 225: jmpu
            if (!uniforms.b[3]) {
                { jmp_to = 234u; break; }
            }
            // 226: add
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            // 227: mul
            reg_tmp4 = mul_safe(uniforms.f[94].zzzz, reg_tmp4);
            // 228: cmp
            conditional_code = greaterThanEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp4.xxxx));
            // 229: rsq
            reg_tmp4 = vec4(rsq_safe(reg_tmp4.xxxx.x));
            // 230: mul
            reg_tmp5 = mul_safe(uniforms.f[94].zzzz, reg_tmp14);
            // 231: jmpc
            if (conditional_code.x) {
                { jmp_to = 234u; break; }
            }
            // 232: rcp
            reg_tmp0.z = rcp_safe(reg_tmp4.xxxx.x);
            // 233: mul
            reg_tmp0.xy = (mul_safe(reg_tmp5, reg_tmp4)).xy;
        }
        case 234u: {
            // 234: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_235_311() {
    uint jmp_to = 235u;
    while (true) {
        switch (jmp_to) {
        case 235u: {
            // 235: dp3
            reg_tmp6.x = dot(vec3(reg_tmp14), vec3(reg_tmp14));
            // 236: dp3
            reg_tmp7.x = dot(vec3(reg_tmp12), vec3(reg_tmp12));
            // 237: rsq
            reg_tmp6.x = rsq_safe(reg_tmp6.xxxx.x);
            // 238: rsq
            reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
            // 239: mul
            reg_tmp14.xyz = (mul_safe(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 240: mul
            reg_tmp12.xyz = (mul_safe(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 241: mul
            reg_tmp13.xyz = (mul_safe(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            // 242: mul
            reg_tmp11.xyz = (mul_safe(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            // 243: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 244: jmpu
            if (!uniforms.b[3]) {
                { jmp_to = 310u; break; }
            }
            // 245: mul
            reg_tmp13.xyz = (mul_safe(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            // 246: mul
            reg_tmp11.xyz = (mul_safe(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            // 247: mul
            reg_tmp5 = mul_safe(reg_tmp14.yzxx, reg_tmp13.zxyy);
            // 248: mad
            reg_tmp5 = fma_safe(-reg_tmp13.yzxx, reg_tmp14.zxyy, reg_tmp5);
            // 249: dp3
            reg_tmp5.w = dot(vec3(reg_tmp5), vec3(reg_tmp5));
            // 250: rsq
            reg_tmp5.w = rsq_safe(reg_tmp5.wwww.x);
            // 251: mul
            reg_tmp5 = mul_safe(reg_tmp5, reg_tmp5.wwww);
            // 252: add
            reg_tmp6.w = (reg_tmp14.zzzz + reg_tmp5.yyyy).w;
            // 253: mul
            reg_tmp13 = mul_safe(reg_tmp5.yzxx, reg_tmp14.zxyy);
            // 254: mad
            reg_tmp13 = fma_safe(-reg_tmp14.yzxx, reg_tmp5.zxyy, reg_tmp13);
            // 255: add
            reg_tmp6.w = (reg_tmp13.xxxx + reg_tmp6).w;
            // 256: mov
            reg_tmp13.w = (reg_tmp5.zzzz).w;
            // 257: mov
            reg_tmp5.z = (reg_tmp13.xxxx).z;
            // 258: add
            reg_tmp6.w = (uniforms.f[93].yyyy + reg_tmp6).w;
            // 259: mov
            reg_tmp14.w = (reg_tmp5.xxxx).w;
            // 260: mov
            reg_tmp5.x = (reg_tmp14.zzzz).x;
            // 261: cmp
            conditional_code = lessThan(vec2(uniforms.f[94].yyyy), vec2(reg_tmp6.wwww));
            // 262: mov
            reg_tmp6.x = (uniforms.f[93].yyyy).x;
            // 263: mov
            reg_tmp6.y = (-uniforms.f[93].yyyy).y;
            // 264: jmpc
            if (!conditional_code.x) {
                { jmp_to = 272u; break; }
            }
            // 265: add
            reg_tmp7.xz = (reg_tmp13.wwyy + -reg_tmp14.yyww).xz;
            // 266: add
            reg_tmp7.y = (reg_tmp14.xxxx + -reg_tmp13.zzzz).y;
            // 267: mov
            reg_tmp7.w = (reg_tmp6).w;
            // 268: dp4
            reg_tmp6 = vec4(dot(reg_tmp7, reg_tmp7));
            // 269: rsq
            reg_tmp6 = vec4(rsq_safe(reg_tmp6.xxxx.x));
            // 270: mul
            reg_tmp0 = mul_safe(reg_tmp7, reg_tmp6);
            // 271: jmpu
            if (uniforms.b[0]) {
                { jmp_to = 310u; break; }
            }
        }
        case 272u: {
            // 272: cmp
            conditional_code = greaterThan(vec2(reg_tmp5.zyyy), vec2(reg_tmp5.yxxx));
            // 273: ifc
            if (conditional_code.x) {
                sub_274_294();
            } else {
                sub_294_307();
            }
            // 307: dp4
            reg_tmp6 = vec4(dot(reg_tmp8, reg_tmp8));
            // 308: rsq
            reg_tmp6 = vec4(rsq_safe(reg_tmp6.xxxx.x));
            // 309: mul
            reg_tmp0 = mul_safe(reg_tmp8, reg_tmp6);
        }
        case 310u: {
            // 310: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_274_294() {
    // 274: ifc
    if (conditional_code.y) {
        sub_275_280();
    } else {
        sub_280_293();
    }
    // 293: mov
    reg_tmp8.w = (-reg_tmp8).w;
    return false;
}
bool sub_275_280() {
    // 275: mul
    reg_tmp8 = mul_safe(reg_tmp13.yyzw, reg_tmp6.xxxy);
    // 276: add
    reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
    // 277: add
    reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
    // 278: add
    reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
    // 279: add
    reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
    return false;
}
bool sub_280_293() {
    // 280: cmp
    conditional_code = greaterThan(vec2(reg_tmp5.zzzz), vec2(reg_tmp5.xxxx));
    // 281: mul
    reg_tmp8 = mul_safe(reg_tmp13.yyzw, reg_tmp6.xxxy);
    // 282: add
    reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
    // 283: ifc
    if (conditional_code.x) {
        sub_284_287();
    } else {
        sub_287_292();
    }
    // 292: nop
    return false;
}
bool sub_284_287() {
    // 284: add
    reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
    // 285: add
    reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
    // 286: add
    reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
    return false;
}
bool sub_287_292() {
    // 287: mul
    reg_tmp8 = mul_safe(reg_tmp13.zwwy, reg_tmp6.xxxy);
    // 288: add
    reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
    // 289: add
    reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
    // 290: add
    reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
    // 291: add
    reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
    return false;
}
bool sub_294_307() {
    // 294: ifc
    if (conditional_code.y) {
        sub_295_300();
    } else {
        sub_300_306();
    }
    // 306: nop
    return false;
}
bool sub_295_300() {
    // 295: mul
    reg_tmp8 = mul_safe(reg_tmp13.yywz, reg_tmp6.xxxy);
    // 296: add
    reg_tmp8.y = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).y;
    // 297: add
    reg_tmp9 = reg_tmp5.yyyy + -reg_tmp5.xxxx;
    // 298: add
    reg_tmp8.xzw = (reg_tmp8 + reg_tmp14.wwyx).xzw;
    // 299: add
    reg_tmp8.y = (reg_tmp9 + reg_tmp8).y;
    return false;
}
bool sub_300_306() {
    // 300: mul
    reg_tmp8 = mul_safe(reg_tmp13.zwwy, reg_tmp6.xxxy);
    // 301: add
    reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
    // 302: add
    reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
    // 303: add
    reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
    // 304: add
    reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
    // 305: mov
    reg_tmp8.w = (-reg_tmp8).w;
    return false;
}
bool sub_311_323() {
    // 311: mov
    reg_tmp0.y = (uniforms.f[7].wwww).y;
    // 312: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.xyyy));
    // 313: mov
    reg_tmp9.xyz = (uniforms.f[93].xxxx).xyz;
    // 314: mov
    reg_tmp9.w = (uniforms.f[21].wwww).w;
    // 315: ifc
    if (conditional_code.y) {
        sub_316_321();
    }
    // 321: call
    {
        sub_323_333();
    }
    // 322: max
    vs_out_attr3 = max(uniforms.f[93].xxxx, reg_tmp9);
    return false;
}
bool sub_316_321() {
    // 316: mul
    reg_tmp0 = mul_safe(uniforms.f[7].wwww, vs_in_reg3);
    // 317: ifu
    if (uniforms.b[7]) {
        sub_318_319();
    }
    // 319: mul
    reg_tmp9.xyz = (mul_safe(uniforms.f[20].wwww, reg_tmp0.xyzz)).xyz;
    // 320: mov
    reg_tmp8.x = (uniforms.f[93].yyyy).x;
    return false;
}
bool sub_318_319() {
    // 318: mul
    reg_tmp9.w = (mul_safe(reg_tmp9.wwww, reg_tmp0.wwww)).w;
    return false;
}
bool sub_323_333() {
    // 323: dp3
    reg_tmp1 = vec4(dot(vec3(uniforms.f[24]), vec3(reg_tmp14)));
    // 324: mov
    reg_tmp2 = uniforms.f[24].wwww;
    // 325: mad
    reg_tmp1 = fma_safe(reg_tmp1, reg_tmp2, reg_tmp2);
    // 326: mov
    reg_tmp3 = uniforms.f[22];
    // 327: add
    reg_tmp2 = uniforms.f[23] + -reg_tmp3;
    // 328: mad
    reg_tmp4 = fma_safe(reg_tmp2, reg_tmp1, reg_tmp3);
    // 329: ifu
    if (uniforms.b[6]) {
        sub_330_331();
    }
    // 331: mad
    reg_tmp9.xyz = (fma_safe(reg_tmp4, uniforms.f[21], reg_tmp9)).xyz;
    // 332: mov
    reg_tmp8.x = (uniforms.f[93].yyyy).x;
    return false;
}
bool sub_330_331() {
    // 330: mul
    reg_tmp4 = mul_safe(reg_tmp4, reg_tmp9.wwww);
    return false;
}
bool sub_333_360() {
    // 333: mov
    reg_tmp0.xy = (uniforms.f[10].xxxx).xy;
    // 334: ifu
    if (uniforms.b[9]) {
        sub_335_340();
    } else {
        sub_340_359();
    }
    // 359: nop
    return false;
}
bool sub_335_340() {
    // 335: call
    {
        sub_360_368();
    }
    // 336: dp4
    reg_tmp3.x = dot(uniforms.f[11].xywz, reg_tmp6);
    // 337: dp4
    reg_tmp3.y = dot(uniforms.f[12].xywz, reg_tmp6);
    // 338: mov
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    // 339: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_340_359() {
    // 340: cmp
    conditional_code = equal(vec2(uniforms.f[95].xyyy), vec2(reg_tmp0.xyyy));
    // 341: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 342: ifc
    if (all(not(conditional_code))) {
        sub_343_349();
    } else {
        sub_349_358();
    }
    // 358: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_343_349() {
    // 343: mov
    reg_tmp6 = reg_tmp10;
    // 344: dp4
    reg_tmp3.x = dot(uniforms.f[11], reg_tmp6);
    // 345: dp4
    reg_tmp3.y = dot(uniforms.f[12], reg_tmp6);
    // 346: dp4
    reg_tmp3.z = dot(uniforms.f[13], reg_tmp6);
    // 347: mul
    reg_tmp0.xy = (mul_safe(uniforms.f[19].xyyy, reg_tmp3.zzzz)).xy;
    // 348: add
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_349_358() {
    // 349: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_350_354();
    } else {
        sub_354_357();
    }
    // 357: nop
    return false;
}
bool sub_350_354() {
    // 350: call
    {
        sub_368_375();
    }
    // 351: dp3
    reg_tmp3.x = dot(vec3(uniforms.f[11]), vec3(reg_tmp6));
    // 352: dp3
    reg_tmp3.y = dot(vec3(uniforms.f[12]), vec3(reg_tmp6));
    // 353: dp3
    reg_tmp3.z = dot(vec3(uniforms.f[13]), vec3(reg_tmp6));
    return false;
}
bool sub_354_357() {
    // 354: call
    {
        sub_375_379();
    }
    // 355: dp4
    reg_tmp3.x = dot(uniforms.f[11], reg_tmp6);
    // 356: dp4
    reg_tmp3.y = dot(uniforms.f[12], reg_tmp6);
    return false;
}
bool sub_360_368() {
    // 360: cmp
    conditional_code = equal(vec2(uniforms.f[93].yzzz), vec2(reg_tmp0.xyyy));
    // 361: ifc
    if (all(not(conditional_code))) {
        sub_362_363();
    } else {
        sub_363_367();
    }
    // 367: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_362_363() {
    // 362: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
    return false;
}
bool sub_363_367() {
    // 363: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_364_365();
    } else {
        sub_365_366();
    }
    // 366: nop
    return false;
}
bool sub_364_365() {
    // 364: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
    return false;
}
bool sub_365_366() {
    // 365: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
    return false;
}
bool sub_368_375() {
    // 368: mov
    reg_tmp2 = -reg_tmp15;
    // 369: dp3
    reg_tmp2.w = dot(vec3(reg_tmp2), vec3(reg_tmp2));
    // 370: rsq
    reg_tmp2.w = rsq_safe(reg_tmp2.wwww.x);
    // 371: mul
    reg_tmp2 = mul_safe(reg_tmp2, reg_tmp2.wwww);
    // 372: dp3
    reg_tmp1 = vec4(dot(vec3(reg_tmp2), vec3(reg_tmp14)));
    // 373: add
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    // 374: mad
    reg_tmp6 = fma_safe(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_375_379() {
    // 375: mov
    reg_tmp1.xy = (uniforms.f[94].zzzz).xy;
    // 376: mov
    reg_tmp1.zw = (uniforms.f[93].xxxx).zw;
    // 377: mad
    reg_tmp6 = fma_safe(reg_tmp14, reg_tmp1, reg_tmp1);
    // 378: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_379_403() {
    // 379: mov
    reg_tmp0.xy = (uniforms.f[10].yyyy).xy;
    // 380: ifu
    if (uniforms.b[10]) {
        sub_381_385();
    } else {
        sub_385_402();
    }
    // 402: nop
    return false;
}
bool sub_381_385() {
    // 381: call
    {
        sub_360_368();
    }
    // 382: dp4
    reg_tmp4.x = dot(uniforms.f[14].xywz, reg_tmp6);
    // 383: dp4
    reg_tmp4.y = dot(uniforms.f[15].xywz, reg_tmp6);
    // 384: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_385_402() {
    // 385: ifu
    if (uniforms.b[13]) {
        sub_386_400();
    } else {
        sub_400_401();
    }
    // 401: nop
    return false;
}
bool sub_386_400() {
    // 386: cmp
    conditional_code = equal(vec2(uniforms.f[95].xyyy), vec2(reg_tmp0.xyyy));
    // 387: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 388: ifc
    if (all(not(conditional_code))) {
        sub_389_396();
    } else {
        sub_396_399();
    }
    // 399: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_389_396() {
    // 389: mov
    reg_tmp6 = reg_tmp10;
    // 390: dp4
    reg_tmp4.x = dot(uniforms.f[14], reg_tmp6);
    // 391: dp4
    reg_tmp4.y = dot(uniforms.f[15], reg_tmp6);
    // 392: dp4
    reg_tmp4.z = dot(uniforms.f[16], reg_tmp6);
    // 393: rcp
    reg_tmp6.w = rcp_safe(reg_tmp4.zzzz.x);
    // 394: mul
    reg_tmp4.xy = (mul_safe(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    // 395: add
    reg_tmp4.xy = (uniforms.f[19].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_396_399() {
    // 396: call
    {
        sub_375_379();
    }
    // 397: dp4
    reg_tmp4.x = dot(uniforms.f[14], reg_tmp6);
    // 398: dp4
    reg_tmp4.y = dot(uniforms.f[15], reg_tmp6);
    return false;
}
bool sub_400_401() {
    // 400: mov
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_403_419() {
    // 403: mov
    reg_tmp0.xy = (uniforms.f[10].zzzz).xy;
    // 404: ifu
    if (uniforms.b[11]) {
        sub_405_409();
    } else {
        sub_409_418();
    }
    // 418: nop
    return false;
}
bool sub_405_409() {
    // 405: call
    {
        sub_360_368();
    }
    // 406: dp4
    reg_tmp5.x = dot(uniforms.f[17].xywz, reg_tmp6);
    // 407: dp4
    reg_tmp5.y = dot(uniforms.f[18].xywz, reg_tmp6);
    // 408: mov
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_409_418() {
    // 409: ifu
    if (uniforms.b[14]) {
        sub_410_416();
    } else {
        sub_416_417();
    }
    // 417: nop
    return false;
}
bool sub_410_416() {
    // 410: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 411: mov
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    // 412: call
    {
        sub_375_379();
    }
    // 413: dp4
    reg_tmp5.x = dot(uniforms.f[17], reg_tmp6);
    // 414: dp4
    reg_tmp5.y = dot(uniforms.f[18], reg_tmp6);
    // 415: mov
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_416_417() {
    // 416: mov
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
// reference: 1B5DBD90A9AD37AC, C686B1FD59F65802
// shader: 8B30, DA97C925583C796F

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(view)), 0.0))) * light_src[0].specular_0) + ((lut_scale_d1 * LookupLightingLUTUnsigned(1, max(dot(normal, normalize(view)), 0.0))) * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor1.rgb) * (const_color[0].aaa) + (texcolor2.rgb) * (vec3(1.0) - (const_color[0].aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].r) * (const_color[0].a) + (texcolor2.a) * (1.0 - (const_color[0].a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2 * 2.0, alpha_output_2 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((texcolor1.aaa) * (secondary_fragment_color.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: CE5EF91407F39434, DA97C925583C796F
// program: C686B1FD59F65802, AD7922A63ED54CA7, DA97C925583C796F
// reference: 1B5DBD9029C9642F, C686B1FD59F65802
// shader: 8B30, 74528811F959F6E2

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[0].specular_0) + ((lut_scale_d1 * LookupLightingLUTUnsigned(1, max(dot(normal, normalize(view)), 0.0))) * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor1.rgb) * (const_color[0].aaa) + (texcolor2.rgb) * (vec3(1.0) - (const_color[0].aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (textureProj(tex0, vec3(texcoord0, texcoord0_w)).a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3 * 2.0, alpha_output_3 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((secondary_fragment_color.rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 3C4D3189FE014C6A, 74528811F959F6E2
// program: C686B1FD59F65802, AD7922A63ED54CA7, 74528811F959F6E2
// reference: B4192FD7D15AEEB7, 46F6395BEBA5C2A1
// shader: 8B30, 1C802C20F608CB95

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(view)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(view)), 0.0))) * light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor1.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (textureProj(tex0, vec3(texcoord0, texcoord0_w)).a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2 * 2.0, alpha_output_2 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) + (secondary_fragment_color.rrr), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((texcolor1.aaa) * (secondary_fragment_color.ggg) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: EF56AFFDD182F579, 1C802C20F608CB95
// program: 46F6395BEBA5C2A1, 3B3AE026C742C7D5, 1C802C20F608CB95
// shader: 8B30, 06734AE8EE3A2FF9

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(view)), 0.0))) * light_src[0].specular_0) + ((lut_scale_d1 * LookupLightingLUTUnsigned(1, max(dot(normal, normalize(view)), 0.0))) * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor1.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (textureProj(tex0, vec3(texcoord0, texcoord0_w)).a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((primary_fragment_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2 * 2.0, alpha_output_2 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((secondary_fragment_color.rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 0FFADAC6A65CC0FA, 06734AE8EE3A2FF9
// program: 46F6395BEBA5C2A1, 3B3AE026C742C7D5, 06734AE8EE3A2FF9
// shader: 8B30, 2CCC9251D3E7EFF0

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[0].specular_0) + ((lut_scale_d1 * LookupLightingLUTUnsigned(1, max(dot(normal, normalize(view)), 0.0))) * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb) * (texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (texcolor1.aaa) + (texcolor2.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3 * 2.0, alpha_output_3 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((secondary_fragment_color.rgb) * (texcolor1.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: ECB30612BDCABBCD, 2CCC9251D3E7EFF0
// program: C686B1FD59F65802, AD7922A63ED54CA7, 2CCC9251D3E7EFF0
// reference: 1B5DBD909F5FA75F, C686B1FD59F65802
// reference: 6157D9AC75D0F252, DEFAC6F185DB6EB9
// reference: 17ED89111B3E9A15, 52B81720FEA5F8B2
// shader: 8B30, 1F674E53996E5139

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(view)), 0.0))) * light_src[0].specular_0) + ((lut_scale_d1 * LookupLightingLUTUnsigned(1, max(dot(normal, normalize(view)), 0.0))) * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor1.rgb) * (const_color[0].aaa) + (texcolor2.rgb) * (vec3(1.0) - (const_color[0].aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].r) * (const_color[0].a) + (texcolor2.a) * (1.0 - (const_color[0].a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2 * 2.0, alpha_output_2 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((texcolor1.aaa) * (secondary_fragment_color.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) * (vec3(1.0) - textureProj(tex0, vec3(texcoord0, texcoord0_w)).rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 08ADED921AA85036, 1F674E53996E5139
// program: C686B1FD59F65802, AD7922A63ED54CA7, 1F674E53996E5139
// shader: 8B30, A3B54E419C624D84

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[0].specular_0) + ((lut_scale_d1 * LookupLightingLUTUnsigned(1, max(dot(normal, normalize(view)), 0.0))) * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor1.rgb) * (const_color[0].aaa) + (texcolor2.rgb) * (vec3(1.0) - (const_color[0].aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (textureProj(tex0, vec3(texcoord0, texcoord0_w)).a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3 * 2.0, alpha_output_3 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((secondary_fragment_color.rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (vec3(1.0) - textureProj(tex0, vec3(texcoord0, texcoord0_w)).rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 5776FC437FC5ED22, A3B54E419C624D84
// program: C686B1FD59F65802, AD7922A63ED54CA7, A3B54E419C624D84
// shader: 8B30, 4BE9CE20C19E37BB

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(view)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(view)), 0.0))) * light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor1.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (textureProj(tex0, vec3(texcoord0, texcoord0_w)).a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2 * 2.0, alpha_output_2 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) + (secondary_fragment_color.rrr), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((texcolor1.aaa) * (secondary_fragment_color.ggg) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (vec3(1.0) - textureProj(tex0, vec3(texcoord0, texcoord0_w)).rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 846D623750465431, 4BE9CE20C19E37BB
// program: 46F6395BEBA5C2A1, 3B3AE026C742C7D5, 4BE9CE20C19E37BB
// shader: 8B30, 3B8EED78426FCEE7

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(view)), 0.0))) * light_src[0].specular_0) + ((lut_scale_d1 * LookupLightingLUTUnsigned(1, max(dot(normal, normalize(view)), 0.0))) * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].r) * (const_color[0].a) + (texcolor2.a) * (1.0 - (const_color[0].a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1 * 2.0, alpha_output_1 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((secondary_fragment_color.rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (vec3(1.0) - textureProj(tex0, vec3(texcoord0, texcoord0_w)).rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 94C5EB27FD301164, 3B8EED78426FCEE7
// program: 46F6395BEBA5C2A1, 3B3AE026C742C7D5, 3B8EED78426FCEE7
// reference: B4192FD767CC2DC7, 46F6395BEBA5C2A1
// reference: DB8C5055DB530FE4, 29CEA8462618C993
// shader: 8B30, 38C5A78A947E3F97

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) < alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: CE312E683633EE5E, 38C5A78A947E3F97
// program: D82E12A9D19ACD63, 5D764F9A6220D694, 38C5A78A947E3F97
// reference: 3A7D406594A141B6, D2FEA64E52B75F45
// reference: 418FA2E7AC8F8248, C0234F4E2DEC3D4D
// shader: 8B30, 00D74B8E7C815129

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) + (const_color[0].rrr), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 565FEE42CD1566A4, 00D74B8E7C815129
// program: DEFAC6F185DB6EB9, 6CF3F3B70E23AA85, 00D74B8E7C815129
// reference: 837BFCA3E6D1915A, 35EA3527A49BC4B5
// reference: A48BFC6F94614896, 35EA3527A49BC4B5
// reference: 053D0A4A2A9F674F, 35EA3527A49BC4B5
// reference: 558E60962A9F674F, 35EA3527A49BC4B5
// reference: 0F870F91BD6125B7, D82E12A9D19ACD63
// reference: F43896B394614896, 35EA3527A49BC4B5
// reference: F98DB32D38F22309, 5447A3297E824FE0
// shader: 8B31, B543C911C8D7EAAB

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define fma_safe(x, y, z) fma(x, y, z)
#define mul_safe(x, y) (x * y)
#define rcp_safe(x) (1.0f / x)
#define rsq_safe(x) inversesqrt(x)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_7_12();
bool sub_12_21();
bool sub_21_34();
bool sub_34_145();
bool sub_46_75();
bool sub_57_61();
bool sub_75_134();
bool sub_76_108();
bool sub_87_91();
bool sub_108_133();
bool sub_119_123();
bool sub_143_144();
bool sub_145_162();
bool sub_162_238();
bool sub_201_221();
bool sub_202_207();
bool sub_207_220();
bool sub_211_214();
bool sub_214_219();
bool sub_221_234();
bool sub_222_227();
bool sub_227_233();
bool sub_238_248();
bool sub_243_247();
bool sub_244_245();
bool sub_339_4096();

bool exec_shader() {
    sub_339_4096();
    return true;
}

bool sub_7_12() {
    // 7: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 8: dp4
    reg_tmp3.x = dot(uniforms.f[25 + address_registers.x], reg_tmp15);
    // 9: dp4
    reg_tmp3.y = dot(uniforms.f[26 + address_registers.x], reg_tmp15);
    // 10: dp4
    reg_tmp3.z = dot(uniforms.f[27 + address_registers.x], reg_tmp15);
    // 11: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    return false;
}
bool sub_12_21() {
    // 12: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 13: dp4
    reg_tmp3.x = dot(uniforms.f[25 + address_registers.x], reg_tmp15);
    // 14: dp4
    reg_tmp3.y = dot(uniforms.f[26 + address_registers.x], reg_tmp15);
    // 15: dp4
    reg_tmp3.z = dot(uniforms.f[27 + address_registers.x], reg_tmp15);
    // 16: dp3
    reg_tmp4.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp14));
    // 17: dp3
    reg_tmp4.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp14));
    // 18: dp3
    reg_tmp4.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp14));
    // 19: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 20: mad
    reg_tmp12 = fma_safe(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_21_34() {
    // 21: mova
    address_registers.x = (ivec2(reg_tmp1.xxxx)).x;
    // 22: dp4
    reg_tmp3.x = dot(uniforms.f[25 + address_registers.x], reg_tmp15);
    // 23: dp4
    reg_tmp3.y = dot(uniforms.f[26 + address_registers.x], reg_tmp15);
    // 24: dp4
    reg_tmp3.z = dot(uniforms.f[27 + address_registers.x], reg_tmp15);
    // 25: dp3
    reg_tmp4.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp14));
    // 26: dp3
    reg_tmp4.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp14));
    // 27: dp3
    reg_tmp4.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp14));
    // 28: dp3
    reg_tmp5.x = dot(vec3(uniforms.f[25 + address_registers.x]), vec3(reg_tmp13));
    // 29: dp3
    reg_tmp5.y = dot(vec3(uniforms.f[26 + address_registers.x]), vec3(reg_tmp13));
    // 30: dp3
    reg_tmp5.z = dot(vec3(uniforms.f[27 + address_registers.x]), vec3(reg_tmp13));
    // 31: mad
    reg_tmp7 = fma_safe(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 32: mad
    reg_tmp12 = fma_safe(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    // 33: mad
    reg_tmp11 = fma_safe(reg_tmp1.wwww, reg_tmp5, reg_tmp11);
    return false;
}
bool sub_34_145() {
    // 34: mul
    reg_tmp15.xyz = (mul_safe(uniforms.f[7].xxxx, vs_in_reg0)).xyz;
    // 35: mul
    reg_tmp14.xyz = (mul_safe(uniforms.f[7].yyyy, vs_in_reg1)).xyz;
    // 36: mul
    reg_tmp13.xyz = (mul_safe(uniforms.f[7].zzzz, vs_in_reg2)).xyz;
    // 37: add
    reg_tmp15.xyz = (uniforms.f[6] + reg_tmp15).xyz;
    // 38: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 39: mov
    reg_tmp0 = uniforms.f[7];
    // 40: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.yzzz));
    // 41: mov
    reg_tmp7 = uniforms.f[93].xxxx;
    // 42: mov
    reg_tmp12 = uniforms.f[93].xxxx;
    // 43: mov
    reg_tmp11 = uniforms.f[93].xxxx;
    // 44: mul
    reg_tmp2 = mul_safe(uniforms.f[93].wwww, vs_in_reg7);
    // 45: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_46_75();
    } else {
        sub_75_134();
    }
    // 134: mov
    vs_out_attr2 = -reg_tmp15;
    // 135: dp4
    reg_tmp0.x = dot(uniforms.f[86], reg_tmp15);
    // 136: dp4
    reg_tmp0.y = dot(uniforms.f[87], reg_tmp15);
    // 137: dp4
    reg_tmp0.z = dot(uniforms.f[88], reg_tmp15);
    // 138: dp4
    reg_tmp0.w = dot(uniforms.f[89], reg_tmp15);
    // 139: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 140: mul
    reg_tmp1.y = (mul_safe(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
    // 141: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 142: ifc
    if (all(conditional_code)) {
        sub_143_144();
    }
    // 144: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_46_75() {
    // 46: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 47: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 48: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 49: call
    {
        sub_12_21();
    }
    // 50: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 51: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 52: call
    {
        sub_12_21();
    }
    // 53: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 54: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 55: callc
    if (conditional_code.x) {
        sub_12_21();
    }
    // 56: ifu
    if (uniforms.b[8]) {
        sub_57_61();
    }
    // 61: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 62: dp4
    reg_tmp10.x = dot(uniforms.f[0], reg_tmp7);
    // 63: dp4
    reg_tmp10.y = dot(uniforms.f[1], reg_tmp7);
    // 64: dp4
    reg_tmp10.z = dot(uniforms.f[2], reg_tmp7);
    // 65: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 66: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 67: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 68: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 69: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 70: dp3
    reg_tmp14.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp12));
    // 71: dp3
    reg_tmp14.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp12));
    // 72: dp3
    reg_tmp14.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp12));
    // 73: call
    {
        sub_145_162();
    }
    // 74: nop
    return false;
}
bool sub_57_61() {
    // 57: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 58: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 59: callc
    if (conditional_code.y) {
        sub_12_21();
    }
    // 60: nop
    return false;
}
bool sub_75_134() {
    // 75: ifc
    if (all(conditional_code)) {
        sub_76_108();
    } else {
        sub_108_133();
    }
    // 133: nop
    return false;
}
bool sub_76_108() {
    // 76: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 77: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 78: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 79: call
    {
        sub_21_34();
    }
    // 80: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 81: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 82: call
    {
        sub_21_34();
    }
    // 83: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 84: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 85: callc
    if (conditional_code.x) {
        sub_21_34();
    }
    // 86: ifu
    if (uniforms.b[8]) {
        sub_87_91();
    }
    // 91: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 92: dp4
    reg_tmp10.x = dot(uniforms.f[0], reg_tmp7);
    // 93: dp4
    reg_tmp10.y = dot(uniforms.f[1], reg_tmp7);
    // 94: dp4
    reg_tmp10.z = dot(uniforms.f[2], reg_tmp7);
    // 95: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 96: dp3
    reg_tmp13.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp11));
    // 97: dp3
    reg_tmp13.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp11));
    // 98: dp3
    reg_tmp13.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp11));
    // 99: dp3
    reg_tmp14.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp12));
    // 100: dp3
    reg_tmp14.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp12));
    // 101: dp3
    reg_tmp14.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp12));
    // 102: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 103: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 104: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 105: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 106: call
    {
        sub_162_238();
    }
    // 107: nop
    return false;
}
bool sub_87_91() {
    // 87: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 88: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 89: callc
    if (conditional_code.y) {
        sub_21_34();
    }
    // 90: nop
    return false;
}
bool sub_108_133() {
    // 108: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(vs_in_reg8.zwww));
    // 109: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 110: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
    // 111: call
    {
        sub_7_12();
    }
    // 112: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 113: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
    // 114: call
    {
        sub_7_12();
    }
    // 115: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 116: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
    // 117: callc
    if (conditional_code.x) {
        sub_7_12();
    }
    // 118: ifu
    if (uniforms.b[8]) {
        sub_119_123();
    }
    // 123: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 124: dp4
    reg_tmp10.x = dot(uniforms.f[0], reg_tmp7);
    // 125: dp4
    reg_tmp10.y = dot(uniforms.f[1], reg_tmp7);
    // 126: dp4
    reg_tmp10.z = dot(uniforms.f[2], reg_tmp7);
    // 127: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 128: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 129: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 130: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 131: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 132: mov
    vs_out_attr1 = uniforms.f[93].xxxx;
    return false;
}
bool sub_119_123() {
    // 119: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 120: mul
    reg_tmp1.w = (mul_safe(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
    // 121: callc
    if (conditional_code.y) {
        sub_7_12();
    }
    // 122: nop
    return false;
}
bool sub_143_144() {
    // 143: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_145_162() {
    uint jmp_to = 145u;
    while (true) {
        switch (jmp_to) {
        case 145u: {
            // 145: dp3
            reg_tmp6.x = dot(vec3(reg_tmp14), vec3(reg_tmp14));
            // 146: dp3
            reg_tmp7.x = dot(vec3(reg_tmp12), vec3(reg_tmp12));
            // 147: rsq
            reg_tmp6.x = rsq_safe(reg_tmp6.xxxx.x);
            // 148: rsq
            reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
            // 149: mul
            reg_tmp14.xyz = (mul_safe(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 150: mul
            reg_tmp12.xyz = (mul_safe(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 151: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 152: jmpu
            if (!uniforms.b[3]) {
                { jmp_to = 161u; break; }
            }
            // 153: add
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            // 154: mul
            reg_tmp4 = mul_safe(uniforms.f[94].zzzz, reg_tmp4);
            // 155: cmp
            conditional_code = greaterThanEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp4.xxxx));
            // 156: rsq
            reg_tmp4 = vec4(rsq_safe(reg_tmp4.xxxx.x));
            // 157: mul
            reg_tmp5 = mul_safe(uniforms.f[94].zzzz, reg_tmp14);
            // 158: jmpc
            if (conditional_code.x) {
                { jmp_to = 161u; break; }
            }
            // 159: rcp
            reg_tmp0.z = rcp_safe(reg_tmp4.xxxx.x);
            // 160: mul
            reg_tmp0.xy = (mul_safe(reg_tmp5, reg_tmp4)).xy;
        }
        case 161u: {
            // 161: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_162_238() {
    uint jmp_to = 162u;
    while (true) {
        switch (jmp_to) {
        case 162u: {
            // 162: dp3
            reg_tmp6.x = dot(vec3(reg_tmp14), vec3(reg_tmp14));
            // 163: dp3
            reg_tmp7.x = dot(vec3(reg_tmp12), vec3(reg_tmp12));
            // 164: rsq
            reg_tmp6.x = rsq_safe(reg_tmp6.xxxx.x);
            // 165: rsq
            reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
            // 166: mul
            reg_tmp14.xyz = (mul_safe(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 167: mul
            reg_tmp12.xyz = (mul_safe(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 168: mul
            reg_tmp13.xyz = (mul_safe(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            // 169: mul
            reg_tmp11.xyz = (mul_safe(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            // 170: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 171: jmpu
            if (!uniforms.b[3]) {
                { jmp_to = 237u; break; }
            }
            // 172: mul
            reg_tmp13.xyz = (mul_safe(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            // 173: mul
            reg_tmp11.xyz = (mul_safe(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            // 174: mul
            reg_tmp5 = mul_safe(reg_tmp14.yzxx, reg_tmp13.zxyy);
            // 175: mad
            reg_tmp5 = fma_safe(-reg_tmp13.yzxx, reg_tmp14.zxyy, reg_tmp5);
            // 176: dp3
            reg_tmp5.w = dot(vec3(reg_tmp5), vec3(reg_tmp5));
            // 177: rsq
            reg_tmp5.w = rsq_safe(reg_tmp5.wwww.x);
            // 178: mul
            reg_tmp5 = mul_safe(reg_tmp5, reg_tmp5.wwww);
            // 179: add
            reg_tmp6.w = (reg_tmp14.zzzz + reg_tmp5.yyyy).w;
            // 180: mul
            reg_tmp13 = mul_safe(reg_tmp5.yzxx, reg_tmp14.zxyy);
            // 181: mad
            reg_tmp13 = fma_safe(-reg_tmp14.yzxx, reg_tmp5.zxyy, reg_tmp13);
            // 182: add
            reg_tmp6.w = (reg_tmp13.xxxx + reg_tmp6).w;
            // 183: mov
            reg_tmp13.w = (reg_tmp5.zzzz).w;
            // 184: mov
            reg_tmp5.z = (reg_tmp13.xxxx).z;
            // 185: add
            reg_tmp6.w = (uniforms.f[93].yyyy + reg_tmp6).w;
            // 186: mov
            reg_tmp14.w = (reg_tmp5.xxxx).w;
            // 187: mov
            reg_tmp5.x = (reg_tmp14.zzzz).x;
            // 188: cmp
            conditional_code = lessThan(vec2(uniforms.f[94].yyyy), vec2(reg_tmp6.wwww));
            // 189: mov
            reg_tmp6.x = (uniforms.f[93].yyyy).x;
            // 190: mov
            reg_tmp6.y = (-uniforms.f[93].yyyy).y;
            // 191: jmpc
            if (!conditional_code.x) {
                { jmp_to = 199u; break; }
            }
            // 192: add
            reg_tmp7.xz = (reg_tmp13.wwyy + -reg_tmp14.yyww).xz;
            // 193: add
            reg_tmp7.y = (reg_tmp14.xxxx + -reg_tmp13.zzzz).y;
            // 194: mov
            reg_tmp7.w = (reg_tmp6).w;
            // 195: dp4
            reg_tmp6 = vec4(dot(reg_tmp7, reg_tmp7));
            // 196: rsq
            reg_tmp6 = vec4(rsq_safe(reg_tmp6.xxxx.x));
            // 197: mul
            reg_tmp0 = mul_safe(reg_tmp7, reg_tmp6);
            // 198: jmpu
            if (uniforms.b[0]) {
                { jmp_to = 237u; break; }
            }
        }
        case 199u: {
            // 199: cmp
            conditional_code = greaterThan(vec2(reg_tmp5.zyyy), vec2(reg_tmp5.yxxx));
            // 200: ifc
            if (conditional_code.x) {
                sub_201_221();
            } else {
                sub_221_234();
            }
            // 234: dp4
            reg_tmp6 = vec4(dot(reg_tmp8, reg_tmp8));
            // 235: rsq
            reg_tmp6 = vec4(rsq_safe(reg_tmp6.xxxx.x));
            // 236: mul
            reg_tmp0 = mul_safe(reg_tmp8, reg_tmp6);
        }
        case 237u: {
            // 237: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_201_221() {
    // 201: ifc
    if (conditional_code.y) {
        sub_202_207();
    } else {
        sub_207_220();
    }
    // 220: mov
    reg_tmp8.w = (-reg_tmp8).w;
    return false;
}
bool sub_202_207() {
    // 202: mul
    reg_tmp8 = mul_safe(reg_tmp13.yyzw, reg_tmp6.xxxy);
    // 203: add
    reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
    // 204: add
    reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
    // 205: add
    reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
    // 206: add
    reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
    return false;
}
bool sub_207_220() {
    // 207: cmp
    conditional_code = greaterThan(vec2(reg_tmp5.zzzz), vec2(reg_tmp5.xxxx));
    // 208: mul
    reg_tmp8 = mul_safe(reg_tmp13.yyzw, reg_tmp6.xxxy);
    // 209: add
    reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
    // 210: ifc
    if (conditional_code.x) {
        sub_211_214();
    } else {
        sub_214_219();
    }
    // 219: nop
    return false;
}
bool sub_211_214() {
    // 211: add
    reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
    // 212: add
    reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
    // 213: add
    reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
    return false;
}
bool sub_214_219() {
    // 214: mul
    reg_tmp8 = mul_safe(reg_tmp13.zwwy, reg_tmp6.xxxy);
    // 215: add
    reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
    // 216: add
    reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
    // 217: add
    reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
    // 218: add
    reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
    return false;
}
bool sub_221_234() {
    // 221: ifc
    if (conditional_code.y) {
        sub_222_227();
    } else {
        sub_227_233();
    }
    // 233: nop
    return false;
}
bool sub_222_227() {
    // 222: mul
    reg_tmp8 = mul_safe(reg_tmp13.yywz, reg_tmp6.xxxy);
    // 223: add
    reg_tmp8.y = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).y;
    // 224: add
    reg_tmp9 = reg_tmp5.yyyy + -reg_tmp5.xxxx;
    // 225: add
    reg_tmp8.xzw = (reg_tmp8 + reg_tmp14.wwyx).xzw;
    // 226: add
    reg_tmp8.y = (reg_tmp9 + reg_tmp8).y;
    return false;
}
bool sub_227_233() {
    // 227: mul
    reg_tmp8 = mul_safe(reg_tmp13.zwwy, reg_tmp6.xxxy);
    // 228: add
    reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
    // 229: add
    reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
    // 230: add
    reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
    // 231: add
    reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
    // 232: mov
    reg_tmp8.w = (-reg_tmp8).w;
    return false;
}
bool sub_238_248() {
    // 238: mov
    reg_tmp0.y = (uniforms.f[7].wwww).y;
    // 239: cmp
    conditional_code = notEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp0.xyyy));
    // 240: mov
    reg_tmp9 = uniforms.f[21];
    // 241: mul
    reg_tmp0 = mul_safe(uniforms.f[7].wwww, vs_in_reg3);
    // 242: ifc
    if (conditional_code.y) {
        sub_243_247();
    }
    // 247: max
    vs_out_attr3 = max(uniforms.f[93].xxxx, reg_tmp9);
    return false;
}
bool sub_243_247() {
    // 243: ifu
    if (uniforms.b[7]) {
        sub_244_245();
    }
    // 245: mul
    reg_tmp9.xyz = (mul_safe(uniforms.f[20].wwww, reg_tmp0.xyzz)).xyz;
    // 246: mov
    reg_tmp8.x = (uniforms.f[93].yyyy).x;
    return false;
}
bool sub_244_245() {
    // 244: mul
    reg_tmp9.w = (mul_safe(reg_tmp9.wwww, reg_tmp0.wwww)).w;
    return false;
}
bool sub_339_4096() {
    // 339: call
    {
        sub_34_145();
    }
    // 340: call
    {
        sub_238_248();
    }
    // 341: end
    return true;
}
// reference: 0326BC31FEABFD0E, B543C911C8D7EAAB
// program: B543C911C8D7EAAB, 4BD70AD09292A3DA, 47C12CB4EFB88BF9
// reference: 60F829217D3BCDCB, B8A2CA3DB47999BF
// reference: EB18FE8E24949DFA, B8A2CA3DB47999BF
// reference: 8FF72172B32C193C, D82E12A9D19ACD63
// reference: 6F19FDE18D92D061, DEFAC6F185DB6EB9
// shader: 8B30, A6A1247B01BC9E0F

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texture(tex_cube, vec3(texcoord0, texcoord0_w)).rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (texture(tex_cube, vec3(texcoord0, texcoord0_w)).a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1 * 2.0, alpha_output_1 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: ED496EA2C23CDFE7, A6A1247B01BC9E0F
// program: DEFAC6F185DB6EB9, 6CF3F3B70E23AA85, A6A1247B01BC9E0F
// shader: 8B30, 8D406DCB231DC667

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor2.rrr) * (rounded_primary_color.rrr), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (textureProj(tex0, vec3(texcoord0, texcoord0_w)).a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor2.ggg) * (rounded_primary_color.ggg) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor2.bbb) * (rounded_primary_color.bbb) + (last_tex_env_out.bbb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (vec3(1.0) - textureProj(tex0, vec3(texcoord0, texcoord0_w)).rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 238816C74ED42F0E, 8D406DCB231DC667
// program: 48B3A6FBA8498826, AD7922A63ED54CA7, 8D406DCB231DC667
// shader: 8B31, F70C4BC6991FAFE8

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;
 out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define fma_safe(x, y, z) fma(x, y, z)
#define mul_safe(x, y) (x * y)
#define rcp_safe(x) (1.0f / x)
#define rsq_safe(x) inversesqrt(x)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_15();
bool sub_15_22();
bool sub_22_4096();

bool exec_shader() {
    sub_22_4096();
    return true;
}

bool sub_0_15() {
    // 0: dp3
    reg_tmp6.x = dot(vec3(reg_tmp14), vec3(reg_tmp14));
    // 1: dp3
    reg_tmp7.x = dot(vec3(reg_tmp12), vec3(reg_tmp12));
    // 2: rsq
    reg_tmp6.x = rsq_safe(reg_tmp6.xxxx.x);
    // 3: rsq
    reg_tmp7.x = rsq_safe(reg_tmp7.xxxx.x);
    // 4: mul
    reg_tmp14.xyz = (mul_safe(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
    // 5: mul
    reg_tmp12.xyz = (mul_safe(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
    // 6: mov
    reg_tmp0 = uniforms.f[93].yxxx;
    // 7: add
    reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
    // 8: mul
    reg_tmp4 = mul_safe(uniforms.f[94].zzzz, reg_tmp4);
    // 9: cmp
    conditional_code = greaterThanEqual(vec2(uniforms.f[93].xxxx), vec2(reg_tmp4.xxxx));
    // 10: rsq
    reg_tmp4 = vec4(rsq_safe(reg_tmp4.xxxx.x));
    // 11: mul
    reg_tmp5 = mul_safe(uniforms.f[94].zzzz, reg_tmp14);
    // 12: rcp
    reg_tmp0.z = rcp_safe(reg_tmp4.xxxx.x);
    // 13: mul
    reg_tmp0.xy = (mul_safe(reg_tmp5, reg_tmp4)).xy;
    // 14: mov
    vs_out_attr1 = reg_tmp0;
    return false;
}
bool sub_15_22() {
    // 15: mov
    reg_tmp0.xy = (uniforms.f[10].yyyy).xy;
    // 16: mul
    reg_tmp6.xy = (mul_safe(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
    // 17: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 18: dp4
    reg_tmp4.x = dot(uniforms.f[14].xywz, reg_tmp6);
    // 19: dp4
    reg_tmp4.y = dot(uniforms.f[15].xywz, reg_tmp6);
    // 20: mov
    vs_out_attr5 = reg_tmp4;
    // 21: nop
    return false;
}
bool sub_22_4096() {
    // 22: dp4
    reg_tmp10.x = dot(uniforms.f[25], vs_in_reg0);
    // 23: dp4
    reg_tmp10.y = dot(uniforms.f[26], vs_in_reg0);
    // 24: dp4
    reg_tmp10.z = dot(uniforms.f[27], vs_in_reg0);
    // 25: mul
    reg_tmp3 = mul_safe(uniforms.f[60], vs_in_reg3.xxxx);
    // 26: add
    reg_tmp10.xyz = (reg_tmp10 + reg_tmp3).xyz;
    // 27: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 28: dp3
    reg_tmp12.x = dot(vec3(uniforms.f[25]), vec3(vs_in_reg1));
    // 29: dp3
    reg_tmp12.y = dot(vec3(uniforms.f[26]), vec3(vs_in_reg1));
    // 30: dp3
    reg_tmp12.z = dot(vec3(uniforms.f[27]), vec3(vs_in_reg1));
    // 31: dp4
    reg_tmp15.x = dot(uniforms.f[90], reg_tmp10);
    // 32: dp4
    reg_tmp15.y = dot(uniforms.f[91], reg_tmp10);
    // 33: dp4
    reg_tmp15.z = dot(uniforms.f[92], reg_tmp10);
    // 34: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 35: dp3
    reg_tmp14.x = dot(vec3(uniforms.f[3]), vec3(reg_tmp12));
    // 36: dp3
    reg_tmp14.y = dot(vec3(uniforms.f[4]), vec3(reg_tmp12));
    // 37: dp3
    reg_tmp14.z = dot(vec3(uniforms.f[5]), vec3(reg_tmp12));
    // 38: call
    {
        sub_0_15();
    }
    // 39: nop
    // 40: mov
    vs_out_attr2 = -reg_tmp15;
    // 41: dp4
    reg_tmp0.x = dot(uniforms.f[86], reg_tmp15);
    // 42: dp4
    reg_tmp0.y = dot(uniforms.f[87], reg_tmp15);
    // 43: dp4
    reg_tmp0.z = dot(uniforms.f[88], reg_tmp15);
    // 44: dp4
    reg_tmp0.w = dot(uniforms.f[89], reg_tmp15);
    // 45: mov
    vs_out_attr0 = reg_tmp0;
    // 46: add
    reg_tmp0.z = (-uniforms.f[93].zzzz + reg_tmp0.zzzz).z;
    // 47: mul
    reg_tmp0.z = (mul_safe(uniforms.f[94].xxxx, reg_tmp0.zzzz)).z;
    // 48: mul
    reg_tmp0.z = (mul_safe(uniforms.f[94].wwww, reg_tmp0.zzzz)).z;
    // 49: max
    reg_tmp1.z = (max(uniforms.f[93].xxxx, -reg_tmp0.zzzz)).z;
    // 50: mov
    vs_out_attr3 = reg_tmp1.zzzz;
    // 51: mov
    vs_out_attr4 = uniforms.f[93].xxxx;
    // 52: call
    {
        sub_15_22();
    }
    // 53: mov
    vs_out_attr6 = uniforms.f[93].xxxx;
    // 54: end
    return true;
}
// reference: 5C57DEC850A36299, F70C4BC6991FAFE8
// shader: 8B30, B4AD2E8419D2C29F

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (texcolor1.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (vec3(1.0) - textureProj(tex0, vec3(texcoord0, texcoord0_w)).rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5 * 2.0, alpha_output_5 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D14F2252340580D2, B4AD2E8419D2C29F
// program: F70C4BC6991FAFE8, AD7922A63ED54CA7, B4AD2E8419D2C29F
// reference: 5C57DEC86651F26A, F70C4BC6991FAFE8
// shader: 8B30, 95AC54D58E4F10E1

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp(min((rounded_primary_color.a) + (rounded_primary_color.a), 1.0) * (texcolor1.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (vec3(1.0) - textureProj(tex0, vec3(texcoord0, texcoord0_w)).rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5 * 2.0, alpha_output_5 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 331F03775B0C0A33, 95AC54D58E4F10E1
// program: F70C4BC6991FAFE8, AD7922A63ED54CA7, 95AC54D58E4F10E1
// reference: B8362937340580D2, B4AD2E8419D2C29F
// shader: 8B30, 736924ED2A85392E

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor1.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (textureProj(tex0, vec3(texcoord0, texcoord0_w)).a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1 * 2.0, alpha_output_1 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (vec3(1.0) - textureProj(tex0, vec3(texcoord0, texcoord0_w)).rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: CE4DECDE82EFA510, 736924ED2A85392E
// program: 65138AC5CA635BBF, 3B3AE026C742C7D5, 736924ED2A85392E
// reference: 6D011D6E4ED42F0E, 8D406DCB231DC667
// reference: B4192FD7E7A87E44, 46F6395BEBA5C2A1
// shader: 8B30, 836703D29D0CD7E9

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(view)), 0.0))) * light_src[0].specular_0) + ((lut_scale_d1 * LookupLightingLUTUnsigned(1, max(dot(normal, normalize(view)), 0.0))) * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a) * (rounded_primary_color.a) + (texcolor1.a) * (1.0 - (rounded_primary_color.a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1 * 2.0, alpha_output_1 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((texcolor1.aaa) * (secondary_fragment_color.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) * (vec3(1.0) - textureProj(tex0, vec3(texcoord0, texcoord0_w)).rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: B1734DA41400CCCF, 836703D29D0CD7E9
// program: 46F6395BEBA5C2A1, 3B3AE026C742C7D5, 836703D29D0CD7E9
// reference: 1B5DBD901F3BF4DC, C686B1FD59F65802
// shader: 8B30, 2A901C5F231B5EF1

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(view)), 0.0))) * light_src[0].specular_0) + ((lut_scale_d1 * LookupLightingLUTUnsigned(1, max(dot(normal, normalize(view)), 0.0))) * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1 * 2.0, alpha_output_1 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((secondary_fragment_color.rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: C0628FD1AB489695, 2A901C5F231B5EF1
// program: 46F6395BEBA5C2A1, 3B3AE026C742C7D5, 2A901C5F231B5EF1
// shader: 8B30, 9E497369F79CE0FC

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(view)), 0.0))) * light_src[0].specular_0) + ((lut_scale_d1 * LookupLightingLUTUnsigned(1, max(dot(normal, normalize(view)), 0.0))) * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor1.aaa) - (const_color[0].rrr), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor1.a) * (texcolor1.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2 * 2.0, alpha_output_2 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((combiner_buffer.rgb) * (secondary_fragment_color.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) < alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 0D859B2CE5C3935C, 9E497369F79CE0FC
// program: 46F6395BEBA5C2A1, 3B3AE026C742C7D5, 9E497369F79CE0FC
// reference: 198A46E138CB5642, 48B3A6FBA8498826
// shader: 8B30, 0C4FAE4D08C76925

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.a = (lut_scale_fr * LookupLightingLUTUnsigned(3, max(dot(normal, normalize(view)), 0.0)));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[0].specular_0) + ((lut_scale_d1 * LookupLightingLUTUnsigned(1, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor2.rgb) * (texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (primary_fragment_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0 * 4.0, alpha_output_0 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (texture(tex_cube, vec3(texcoord0, texcoord0_w)).rgb) + (secondary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (const_color[2].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((combiner_buffer.rgb) * (const_color[3].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 95CFC0160E1D561B, 0C4FAE4D08C76925
// program: 48B3A6FBA8498826, AD7922A63ED54CA7, 0C4FAE4D08C76925
// reference: 298F9921C1EC365B, D82E12A9D19ACD63
// shader: 8B30, AC0F19FDD3562F8A

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((texcolor0.r) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.aaa), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: EA3EA9D769C86199, AC0F19FDD3562F8A
// program: D82E12A9D19ACD63, 5D764F9A6220D694, AC0F19FDD3562F8A
// reference: 4D6046DD8A4503C2, B8A2CA3DB47999BF
// reference: C6809172538E0070, B8A2CA3DB47999BF
// reference: A26F4E8E182735E9, D82E12A9D19ACD63
// reference: 4C6918C9E34B824E, 5447A3297E824FE0
// reference: C789CF663A8081FC, 5447A3297E824FE0
// reference: 2D7268CDFCD95FFB, B543C911C8D7EAAB
// reference: 4EACFDDD7D3BCDCB, B8A2CA3DB47999BF
// reference: C54C2A7224949DFA, B8A2CA3DB47999BF
// reference: A1A3F58EB32C193C, D82E12A9D19ACD63
// reference: 414D291D8D92D061, DEFAC6F185DB6EB9
// reference: 198A46E10E39C6B1, 48B3A6FBA8498826
// reference: 0B0D3B4350A36299, F70C4BC6991FAFE8
// reference: 0B0D3B436651F26A, F70C4BC6991FAFE8
// reference: 7B80904439D78153, DEFAC6F185DB6EB9
// reference: 63AC69AB5B0C0A33, 95AC54D58E4F10E1
// reference: D0778DAB82EFA510, 736924ED2A85392E
// reference: 635646A9A9417D6B, DD35FB9CAEB223CF
// shader: 8B30, ED9AAA1E39CE1504

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 89273F274AC3A4B8, ED9AAA1E39CE1504
// program: DD35FB9CAEB223CF, CEF02063E9A18B2F, ED9AAA1E39CE1504
// reference: 28ADF860916D08B1, B8A2CA3DB47999BF
// reference: A34D2FCF48A60B03, B8A2CA3DB47999BF
// reference: C7A2F033030F3E9A, D82E12A9D19ACD63
// reference: B4023056E34B824E, 5447A3297E824FE0
// reference: 3FE2E7F93A8081FC, 5447A3297E824FE0
// reference: B1D984C6FCD95FFB, B543C911C8D7EAAB
// reference: D20711D67D3BCDCB, B8A2CA3DB47999BF
// reference: 59E7C67924949DFA, B8A2CA3DB47999BF
// reference: 3D081985B32C193C, D82E12A9D19ACD63
// reference: DDE6C5168D92D061, DEFAC6F185DB6EB9
// reference: 6C9D7C7950A36299, F70C4BC6991FAFE8
// reference: 6C9D7C796651F26A, F70C4BC6991FAFE8
// reference: 71E1DAEDA9AD37AC, C686B1FD59F65802
// reference: 71E1DAED29C9642F, C686B1FD59F65802
// reference: DEA548AAD15AEEB7, 46F6395BEBA5C2A1
// reference: DEA548AA513EBD34, 46F6395BEBA5C2A1
// reference: DEA548AA67CC2DC7, 46F6395BEBA5C2A1
// reference: DEA548AAE7A87E44, 46F6395BEBA5C2A1
// reference: 71E1DAED1F3BF4DC, C686B1FD59F65802
// reference: 7336219C38CB5642, 48B3A6FBA8498826
// reference: 80C4E77782EFA510, 736924ED2A85392E
// reference: 4333FE5CC1EC365B, D82E12A9D19ACD63
// reference: 27DC21A08A4503C2, B8A2CA3DB47999BF
// reference: AC3CF60F538E0070, B8A2CA3DB47999BF
// reference: 26D57FB4E34B824E, 5447A3297E824FE0
// reference: AD35A81B3A8081FC, 5447A3297E824FE0
// reference: 47CE0FB0FCD95FFB, B543C911C8D7EAAB
// reference: 24109AA07D3BCDCB, B8A2CA3DB47999BF
// reference: AFF04D0F24949DFA, B8A2CA3DB47999BF
// reference: CB1F92F3B32C193C, D82E12A9D19ACD63
// reference: 2BF14E608D92D061, DEFAC6F185DB6EB9
// reference: 7336219C0E39C6B1, 48B3A6FBA8498826
// reference: 61B15C3E50A36299, F70C4BC6991FAFE8
// reference: 61B15C3E6651F26A, F70C4BC6991FAFE8
// reference: DC72B3DBD6819D46, 65138AC5CA635BBF
// reference: 113CF73939D78153, DEFAC6F185DB6EB9
// reference: 113CF7390F2511A0, DEFAC6F185DB6EB9
// reference: C8D329F3182735E9, D82E12A9D19ACD63
// shader: 8B30, 43A7C75AE8CBEC18

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2 * 2.0, alpha_output_2 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a) * (const_color[5].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: BC0C98F15DD83B12, 43A7C75AE8CBEC18
// program: DEFAC6F185DB6EB9, 6CF3F3B70E23AA85, 43A7C75AE8CBEC18
// reference: 4A43786D0BFA62E0, ED9AAA1E39CE1504
// reference: 3F8948D052A58EDC, D82E12A9D19ACD63
// reference: 5B66972C190CBB45, B8A2CA3DB47999BF
// reference: D0864083C0C7B8F7, B8A2CA3DB47999BF
// reference: B4699F7F8B6E8D6E, D82E12A9D19ACD63
// reference: 71E1DAED9F5FA75F, C686B1FD59F65802
// reference: 80D7F2BD07F39434, DA97C925583C796F
// reference: E88543EB340580D2, B4AD2E8419D2C29F
// reference: 9EFE860282EFA510, 736924ED2A85392E
// reference: 589900712D2E1CA4, DEFAC6F185DB6EB9
// reference: CE312E6814DBCCBC, 29CEA8462618C993
// reference: 2983DF1723BBEABB, 734B56B7CFCD3D95
// shader: 8B30, EA83856FEB3CAEC2

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 6FE6392B37D2A2A0, EA83856FEB3CAEC2
// program: 734B56B7CFCD3D95, CEF02063E9A18B2F, EA83856FEB3CAEC2
// reference: FAF295D7BCA1C930, B8A2CA3DB47999BF
// reference: 71124278656ACA82, B8A2CA3DB47999BF
// reference: B747C206E34B824E, 5447A3297E824FE0
// reference: 3CA715A93A8081FC, 5447A3297E824FE0
// reference: C60C1AB5FCD95FFB, B543C911C8D7EAAB
// reference: A5D28FA57D3BCDCB, B8A2CA3DB47999BF
// reference: 2E32580A24949DFA, B8A2CA3DB47999BF
// reference: 4ADD87F6B32C193C, D82E12A9D19ACD63
// reference: AA335B658D92D061, DEFAC6F185DB6EB9
// shader: 8B31, 1BE8D5DEECF8172C

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define fma_safe(x, y, z) fma(x, y, z)
#define mul_safe(x, y) (x * y)
#define rcp_safe(x) (1.0f / x)
#define rsq_safe(x) inversesqrt(x)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_8();
bool sub_9_32();
bool sub_143_145();
bool sub_146_166();
bool sub_167_259();
bool sub_190_192();
bool sub_194_195();
bool sub_197_198();
bool sub_200_202();
bool sub_232_234();
bool sub_236_237();
bool sub_239_240();
bool sub_242_244();
bool sub_260_4096();
bool sub_269_270();
bool sub_270_271();
bool sub_277_278();
bool sub_278_279();
bool sub_304_305();
bool sub_305_306();

bool exec_shader() {
    sub_260_4096();
    return true;
}

bool sub_0_8() {
    // 0: mova
    address_registers.x = (ivec2(vs_in_reg0.zzzz)).x;
    // 1: mov
    reg_tmp10 = uniforms.f[0].xxxz;
    // 2: mov
    reg_tmp10.xy = (vs_in_reg0.xyyy).xy;
    // 3: mov
    reg_tmp11 = uniforms.f[0].xxxx;
    // 4: mov
    reg_tmp12 = uniforms.f[0].xxxx;
    // 5: mov
    reg_tmp13 = uniforms.f[0].zzzz;
    // 6: mov
    reg_tmp4 = uniforms.f[0].xxxx;
    // 7: mov
    reg_tmp5 = uniforms.f[0].xxxx;
    return false;
}
bool sub_9_32() {
    // 9: mov
    vs_out_attr0 = reg_tmp10;
    // 10: mul
    reg_tmp13 = mul_safe(uniforms.f[82], reg_tmp13);
    // 11: mov
    vs_out_attr1 = reg_tmp13;
    // 12: add
    reg_tmp11.y = (uniforms.f[0].zzzz + -reg_tmp11.yyyy).y;
    // 13: add
    reg_tmp12.y = (uniforms.f[0].zzzz + -reg_tmp12.yyyy).y;
    // 14: mov
    reg_tmp14.y = (uniforms.f[81].wwww).y;
    // 15: mul
    reg_tmp14.x = (mul_safe(uniforms.f[0].wwww, reg_tmp14.yyyy)).x;
    // 16: rcp
    reg_tmp2.x = rcp_safe(reg_tmp14.xxxx.x);
    // 17: mov
    reg_tmp14.z = (reg_tmp2.xxxx).z;
    // 18: add
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp11.xyyy).xy;
    // 19: mul
    reg_tmp5.xy = (mul_safe(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    // 20: flr
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    // 21: mul
    reg_tmp4.xy = (mul_safe(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    // 22: add
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    // 23: add
    reg_tmp11.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    // 24: add
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp12.xyyy).xy;
    // 25: mul
    reg_tmp5.xy = (mul_safe(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    // 26: flr
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    // 27: mul
    reg_tmp4.xy = (mul_safe(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    // 28: add
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    // 29: add
    reg_tmp12.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    // 30: mov
    vs_out_attr2 = reg_tmp11;
    // 31: mov
    vs_out_attr3 = reg_tmp12;
    return false;
}
bool sub_143_145() {
    // 143: mov
    reg_tmp1.xyz = (uniforms.f[92].xyzz).xyz;
    // 144: mov
    reg_tmp1.w = (uniforms.f[0].xxxx).w;
    return false;
}
bool sub_146_166() {
    // 146: mov
    reg_tmp2 = uniforms.f[90];
    // 147: mov
    reg_tmp3 = uniforms.f[91];
    // 148: mov
    reg_tmp4 = uniforms.f[92];
    // 149: mov
    reg_tmp5 = uniforms.f[0].xxxz;
    // 150: mul
    reg_tmp6 = mul_safe(uniforms.f[86].xxxx, reg_tmp2);
    // 151: mad
    reg_tmp6 = fma_safe(reg_tmp3, uniforms.f[86].yyyy, reg_tmp6);
    // 152: mad
    reg_tmp6 = fma_safe(reg_tmp4, uniforms.f[86].zzzz, reg_tmp6);
    // 153: mad
    reg_tmp6 = fma_safe(reg_tmp5, uniforms.f[86].wwww, reg_tmp6);
    // 154: mul
    reg_tmp7 = mul_safe(uniforms.f[87].xxxx, reg_tmp2);
    // 155: mad
    reg_tmp7 = fma_safe(reg_tmp3, uniforms.f[87].yyyy, reg_tmp7);
    // 156: mad
    reg_tmp7 = fma_safe(reg_tmp4, uniforms.f[87].zzzz, reg_tmp7);
    // 157: mad
    reg_tmp7 = fma_safe(reg_tmp5, uniforms.f[87].wwww, reg_tmp7);
    // 158: mul
    reg_tmp8 = mul_safe(uniforms.f[88].xxxx, reg_tmp2);
    // 159: mad
    reg_tmp8 = fma_safe(reg_tmp3, uniforms.f[88].yyyy, reg_tmp8);
    // 160: mad
    reg_tmp8 = fma_safe(reg_tmp4, uniforms.f[88].zzzz, reg_tmp8);
    // 161: mad
    reg_tmp8 = fma_safe(reg_tmp5, uniforms.f[88].wwww, reg_tmp8);
    // 162: mul
    reg_tmp9 = mul_safe(uniforms.f[89].xxxx, reg_tmp2);
    // 163: mad
    reg_tmp9 = fma_safe(reg_tmp3, uniforms.f[89].yyyy, reg_tmp9);
    // 164: mad
    reg_tmp9 = fma_safe(reg_tmp4, uniforms.f[89].zzzz, reg_tmp9);
    // 165: mad
    reg_tmp9 = fma_safe(reg_tmp5, uniforms.f[89].wwww, reg_tmp9);
    return false;
}
bool sub_167_259() {
    // 167: rcp
    reg_tmp2.x = rcp_safe(uniforms.f[81].yyyy.x);
    // 168: mul
    reg_tmp2.xy = (mul_safe(uniforms.f[2 + address_registers.x].zwww, reg_tmp2.xxxx)).xy;
    // 169: add
    reg_tmp2.xy = (uniforms.f[0].yyyy + reg_tmp2.xyyy).xy;
    // 170: flr
    reg_tmp3.xy = (floor(reg_tmp2.xyyy)).xy;
    // 171: mul
    reg_tmp2.xy = (mul_safe(uniforms.f[81].yyyy, reg_tmp3.xyyy)).xy;
    // 172: add
    reg_tmp2.xy = (uniforms.f[2 + address_registers.x].zwww + -reg_tmp2.xyyy).xy;
    // 173: min
    reg_tmp0.xy = (min(uniforms.f[81].xxxx, -reg_tmp2.xyyy)).xy;
    // 174: max
    reg_tmp0.xy = (max(-uniforms.f[81].xxxx, reg_tmp0.xyyy)).xy;
    // 175: mov
    reg_tmp2 = uniforms.f[95];
    // 176: mov
    reg_tmp3 = uniforms.f[94];
    // 177: mul
    reg_tmp1.z = (mul_safe(reg_tmp0.xxxx, reg_tmp0.xxxx)).z;
    // 178: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 179: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 180: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 181: mov
    reg_tmp2 = uniforms.f[93];
    // 182: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 183: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 184: mul
    reg_tmp1.y = (mul_safe(reg_tmp1.yyyy, reg_tmp0.xxxx)).y;
    // 185: mov
    reg_tmp5.x = (uniforms.f[5 + address_registers.x].wwww).x;
    // 186: mov
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    // 187: mov
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    // 188: cmp
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    // 189: ifc
    if (conditional_code.x) {
        sub_190_192();
    }
    // 192: cmp
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    // 193: ifc
    if (conditional_code.x) {
        sub_194_195();
    }
    // 195: cmp
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 196: ifc
    if (conditional_code.x) {
        sub_197_198();
    }
    // 198: cmp
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 199: ifc
    if (conditional_code.x) {
        sub_200_202();
    }
    // 202: mul
    reg_tmp4.xy = (mul_safe(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    // 203: mad
    reg_tmp4.x = (fma_safe(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    // 204: mad
    reg_tmp4.y = (fma_safe(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    // 205: add
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    // 206: add
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    // 207: mov
    reg_tmp4.z = (uniforms.f[83].xxxx).z;
    // 208: mov
    reg_tmp4.w = (-uniforms.f[83].yyyy).w;
    // 209: madi
    reg_tmp5.xy = (fma_safe(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[3 + address_registers.x].xyyy)).xy;
    // 210: mov
    reg_tmp4.z = (-uniforms.f[3 + address_registers.x].zzzz).z;
    // 211: mov
    reg_tmp4.w = (-uniforms.f[3 + address_registers.x].wwww).w;
    // 212: add
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    // 213: add
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    // 214: mad
    reg_tmp5.x = (fma_safe(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    // 215: mad
    reg_tmp5.y = (fma_safe(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    // 216: mov
    reg_tmp11.xy = (reg_tmp5.xyyy).xy;
    // 217: mov
    reg_tmp2 = uniforms.f[95];
    // 218: mov
    reg_tmp3 = uniforms.f[94];
    // 219: mul
    reg_tmp1.z = (mul_safe(reg_tmp0.yyyy, reg_tmp0.yyyy)).z;
    // 220: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 221: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 222: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 223: mov
    reg_tmp2 = uniforms.f[93];
    // 224: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 225: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 226: mul
    reg_tmp1.y = (mul_safe(reg_tmp1.yyyy, reg_tmp0.yyyy)).y;
    // 227: mov
    reg_tmp5.x = (uniforms.f[6 + address_registers.x].wwww).x;
    // 228: mov
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    // 229: mov
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    // 230: cmp
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    // 231: ifc
    if (conditional_code.x) {
        sub_232_234();
    }
    // 234: cmp
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    // 235: ifc
    if (conditional_code.x) {
        sub_236_237();
    }
    // 237: cmp
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 238: ifc
    if (conditional_code.x) {
        sub_239_240();
    }
    // 240: cmp
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 241: ifc
    if (conditional_code.x) {
        sub_242_244();
    }
    // 244: mul
    reg_tmp4.xy = (mul_safe(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    // 245: mad
    reg_tmp4.x = (fma_safe(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    // 246: mad
    reg_tmp4.y = (fma_safe(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    // 247: add
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    // 248: add
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    // 249: mov
    reg_tmp4.z = (uniforms.f[83].zzzz).z;
    // 250: mov
    reg_tmp4.w = (-uniforms.f[83].wwww).w;
    // 251: madi
    reg_tmp5.xy = (fma_safe(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[4 + address_registers.x].xyyy)).xy;
    // 252: mov
    reg_tmp4.z = (-uniforms.f[4 + address_registers.x].zzzz).z;
    // 253: mov
    reg_tmp4.w = (-uniforms.f[4 + address_registers.x].wwww).w;
    // 254: add
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    // 255: add
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    // 256: mad
    reg_tmp5.x = (fma_safe(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    // 257: mad
    reg_tmp5.y = (fma_safe(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    // 258: mov
    reg_tmp12.xy = (reg_tmp5.xyyy).xy;
    return false;
}
bool sub_190_192() {
    // 190: mov
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    // 191: mov
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_194_195() {
    // 194: mov
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_197_198() {
    // 197: mov
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_200_202() {
    // 200: mov
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    // 201: mov
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_232_234() {
    // 232: mov
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    // 233: mov
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_236_237() {
    // 236: mov
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_239_240() {
    // 239: mov
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_242_244() {
    // 242: mov
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    // 243: mov
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_260_4096() {
    // 260: call
    {
        sub_0_8();
    }
    // 261: add
    reg_tmp10.xy = (uniforms.f[84].xyyy + reg_tmp10.xyyy).xy;
    // 262: mul
    reg_tmp10.xy = (mul_safe(uniforms.f[2 + address_registers.x].xyyy, reg_tmp10.xyyy)).xy;
    // 263: call
    {
        sub_143_145();
    }
    // 264: mov
    reg_tmp2.xyz = (reg_tmp1.xyzz).xyz;
    // 265: mov
    reg_tmp3.xyz = (uniforms.f[6 + address_registers.x].xyzz).xyz;
    // 266: dp3
    reg_tmp4.x = dot(vec3(reg_tmp3.xyzz), vec3(reg_tmp3.xyzz));
    // 267: cmp
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
    // 268: ifc
    if (conditional_code.x) {
        sub_269_270();
    } else {
        sub_270_271();
    }
    // 271: mul
    reg_tmp3.xyz = (mul_safe(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
    // 272: mul
    reg_tmp4.xyz = (mul_safe(reg_tmp3.yzxx, reg_tmp2.zxyy)).xyz;
    // 273: mad
    reg_tmp4.xyz = (fma_safe(-reg_tmp2.yzxx, reg_tmp3.zxyy, reg_tmp4)).xyz;
    // 274: dp3
    reg_tmp5.x = dot(vec3(reg_tmp4.xyzz), vec3(reg_tmp4.xyzz));
    // 275: cmp
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp5.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp5.y;
    // 276: ifc
    if (conditional_code.x) {
        sub_277_278();
    } else {
        sub_278_279();
    }
    // 279: mul
    reg_tmp4.xyz = (mul_safe(reg_tmp4.xyzz, reg_tmp5.xxxx)).xyz;
    // 280: mul
    reg_tmp5.xyz = (mul_safe(reg_tmp3.yzxx, reg_tmp4.zxyy)).xyz;
    // 281: mad
    reg_tmp5.xyz = (fma_safe(-reg_tmp4.yzxx, reg_tmp3.zxyy, reg_tmp5)).xyz;
    // 282: mov
    reg_tmp6.x = (reg_tmp4.xxxx).x;
    // 283: mov
    reg_tmp6.y = (reg_tmp3.xxxx).y;
    // 284: mov
    reg_tmp6.z = (reg_tmp5.xxxx).z;
    // 285: mov
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    // 286: mov
    reg_tmp7.x = (reg_tmp4.yyyy).x;
    // 287: mov
    reg_tmp7.y = (reg_tmp3.yyyy).y;
    // 288: mov
    reg_tmp7.z = (reg_tmp5.yyyy).z;
    // 289: mov
    reg_tmp7.w = (uniforms.f[0].xxxx).w;
    // 290: mov
    reg_tmp8.x = (reg_tmp4.zzzz).x;
    // 291: mov
    reg_tmp8.y = (reg_tmp3.zzzz).y;
    // 292: mov
    reg_tmp8.z = (reg_tmp5.zzzz).z;
    // 293: mov
    reg_tmp8.w = (uniforms.f[0].xxxx).w;
    // 294: mov
    reg_tmp9 = uniforms.f[0].xxxz;
    // 295: dp4
    reg_tmp2.x = dot(reg_tmp10, reg_tmp6);
    // 296: dp4
    reg_tmp2.y = dot(reg_tmp10, reg_tmp7);
    // 297: dp4
    reg_tmp2.z = dot(reg_tmp10, reg_tmp8);
    // 298: dp4
    reg_tmp2.w = dot(reg_tmp10, reg_tmp9);
    // 299: mov
    reg_tmp3.xyz = (uniforms.f[5 + address_registers.x].xyzz).xyz;
    // 300: add
    reg_tmp3.xyz = (-uniforms.f[85].xyzz + reg_tmp3.xyzz).xyz;
    // 301: dp3
    reg_tmp4.x = dot(vec3(reg_tmp3.xyzz), vec3(reg_tmp3.xyzz));
    // 302: cmp
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
    // 303: ifc
    if (conditional_code.x) {
        sub_304_305();
    } else {
        sub_305_306();
    }
    // 306: mul
    reg_tmp3.xyz = (mul_safe(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
    // 307: add
    reg_tmp10.xyz = (uniforms.f[5 + address_registers.x].xyzz + reg_tmp2.xyzz).xyz;
    // 308: mad
    reg_tmp10.xyz = (fma_safe(reg_tmp3.xyzz, -uniforms.f[84].zzzz, reg_tmp10.xyzz)).xyz;
    // 309: call
    {
        sub_146_166();
    }
    // 310: mov
    reg_tmp2 = reg_tmp10;
    // 311: dp4
    reg_tmp10.x = dot(reg_tmp2, reg_tmp6);
    // 312: dp4
    reg_tmp10.y = dot(reg_tmp2, reg_tmp7);
    // 313: dp4
    reg_tmp10.z = dot(reg_tmp2, reg_tmp8);
    // 314: dp4
    reg_tmp10.w = dot(reg_tmp2, reg_tmp9);
    // 315: mov
    reg_tmp2 = uniforms.f[1 + address_registers.x];
    // 316: max
    reg_tmp3 = max(uniforms.f[0].xxxx, reg_tmp2);
    // 317: min
    reg_tmp2 = min(uniforms.f[0].zzzz, reg_tmp3);
    // 318: mov
    reg_tmp13 = reg_tmp2;
    // 319: call
    {
        sub_167_259();
    }
    // 320: call
    {
        sub_9_32();
    }
    // 321: end
    return true;
}
bool sub_269_270() {
    // 269: mov
    reg_tmp4.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_270_271() {
    // 270: rsq
    reg_tmp4.x = rsq_safe(reg_tmp4.xxxx.x);
    return false;
}
bool sub_277_278() {
    // 277: mov
    reg_tmp5.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_278_279() {
    // 278: rsq
    reg_tmp5.x = rsq_safe(reg_tmp5.xxxx.x);
    return false;
}
bool sub_304_305() {
    // 304: mov
    reg_tmp4.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_305_306() {
    // 305: rsq
    reg_tmp4.x = rsq_safe(reg_tmp4.xxxx.x);
    return false;
}
// reference: BD70C0F846F99B26, 1BE8D5DEECF8172C
// program: 1BE8D5DEECF8172C, CEF02063E9A18B2F, EA83856FEB3CAEC2
// reference: 2983DF175BD743EB, 734B56B7CFCD3D95
// reference: 9E1D4A2B8F6455F9, D82E12A9D19ACD63
// reference: FAF295D7C4CD6060, B8A2CA3DB47999BF
// reference: 711242781D0663D2, B8A2CA3DB47999BF
// reference: B747C2069BFA51BA, 5447A3297E824FE0
// reference: 3CA715A942315208, 5447A3297E824FE0
// reference: 0AEE55C4924A8D34, D82E12A9D19ACD63
// reference: 6E018A38D9E3B8AD, B8A2CA3DB47999BF
// reference: E5E15D970028BB1F, B8A2CA3DB47999BF
// reference: E275DD5F9BFA51BA, 5447A3297E824FE0
// reference: 69950AF042315208, 5447A3297E824FE0
// reference: 933E05ECFCD95FFB, B543C911C8D7EAAB
// reference: F0E090FC7D3BCDCB, B8A2CA3DB47999BF
// reference: 7B00475324949DFA, B8A2CA3DB47999BF
// reference: 1FEF98AFB32C193C, D82E12A9D19ACD63
// reference: FF01443C8D92D061, DEFAC6F185DB6EB9
// reference: BD70C0F8700B0BD5, 1BE8D5DEECF8172C
// shader: 8B30, 931705B2EA3991A9

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: BA0DFE91B963A7A0, 931705B2EA3991A9
// program: 1BE8D5DEECF8172C, CEF02063E9A18B2F, 931705B2EA3991A9
// shader: 8B31, 9FB407F1EC1D74B1

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define fma_safe(x, y, z) fma(x, y, z)
#define mul_safe(x, y) (x * y)
#define rcp_safe(x) (1.0f / x)
#define rsq_safe(x) inversesqrt(x)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_8();
bool sub_9_32();
bool sub_33_96();
bool sub_146_166();
bool sub_167_249();
bool sub_189_190();
bool sub_192_193();
bool sub_195_196();
bool sub_198_200();
bool sub_226_227();
bool sub_229_230();
bool sub_232_233();
bool sub_235_237();
bool sub_250_4096();
bool sub_277_278();
bool sub_278_279();

bool exec_shader() {
    sub_250_4096();
    return true;
}

bool sub_0_8() {
    // 0: mov
    reg_tmp10 = uniforms.f[0].xxxz;
    // 1: mov
    reg_tmp10.xyz = (vs_in_reg0.xyzz).xyz;
    // 2: mov
    reg_tmp11 = uniforms.f[0].xxxx;
    // 3: mov
    reg_tmp12 = uniforms.f[0].xxxx;
    // 4: mov
    reg_tmp11.xy = (vs_in_reg1.xyyy).xy;
    // 5: mov
    reg_tmp13 = uniforms.f[0].zzzz;
    // 6: mov
    reg_tmp4 = uniforms.f[0].xxxx;
    // 7: mov
    reg_tmp5 = uniforms.f[0].xxxx;
    return false;
}
bool sub_9_32() {
    // 9: mov
    vs_out_attr0 = reg_tmp10;
    // 10: mul
    reg_tmp13 = mul_safe(uniforms.f[82], reg_tmp13);
    // 11: mul
    vs_out_attr1 = mul_safe(vs_in_reg2, reg_tmp13);
    // 12: add
    reg_tmp11.y = (uniforms.f[0].zzzz + -reg_tmp11.yyyy).y;
    // 13: add
    reg_tmp12.y = (uniforms.f[0].zzzz + -reg_tmp12.yyyy).y;
    // 14: mov
    reg_tmp14.y = (uniforms.f[81].wwww).y;
    // 15: mul
    reg_tmp14.x = (mul_safe(uniforms.f[0].wwww, reg_tmp14.yyyy)).x;
    // 16: rcp
    reg_tmp2.x = rcp_safe(reg_tmp14.xxxx.x);
    // 17: mov
    reg_tmp14.z = (reg_tmp2.xxxx).z;
    // 18: add
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp11.xyyy).xy;
    // 19: mul
    reg_tmp5.xy = (mul_safe(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    // 20: flr
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    // 21: mul
    reg_tmp4.xy = (mul_safe(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    // 22: add
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    // 23: add
    reg_tmp11.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    // 24: add
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp12.xyyy).xy;
    // 25: mul
    reg_tmp5.xy = (mul_safe(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    // 26: flr
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    // 27: mul
    reg_tmp4.xy = (mul_safe(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    // 28: add
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    // 29: add
    reg_tmp12.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    // 30: mov
    vs_out_attr2 = reg_tmp11;
    // 31: mov
    vs_out_attr3 = reg_tmp12;
    return false;
}
bool sub_33_96() {
    // 33: mov
    reg_tmp6.xyz = (-reg_tmp0.xyzz).xyz;
    // 34: mov
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    // 35: rcp
    reg_tmp7.xyz = vec3(rcp_safe(uniforms.f[81].yyyy.x));
    // 36: madi
    reg_tmp8.xyz = (fma_safe(reg_tmp6.xyzz, reg_tmp7.xyzz, uniforms.f[0].yyyy)).xyz;
    // 37: flr
    reg_tmp7.xyz = (floor(reg_tmp8.xyzz)).xyz;
    // 38: mad
    reg_tmp6.xyz = (fma_safe(reg_tmp7.xyzz, -uniforms.f[81].yyyy, reg_tmp6.xyzz)).xyz;
    // 39: min
    reg_tmp6 = min(uniforms.f[81].xxxx, reg_tmp6);
    // 40: max
    reg_tmp6 = max(-uniforms.f[81].xxxx, reg_tmp6);
    // 41: mov
    reg_tmp2 = uniforms.f[95];
    // 42: mov
    reg_tmp3 = uniforms.f[94];
    // 43: mul
    reg_tmp1.z = (mul_safe(reg_tmp6.xxxx, reg_tmp6.xxxx)).z;
    // 44: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 45: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 46: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 47: mov
    reg_tmp2 = uniforms.f[93];
    // 48: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 49: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 50: mul
    reg_tmp1.y = (mul_safe(reg_tmp1.yyyy, reg_tmp6.xxxx)).y;
    // 51: mov
    reg_tmp4.x = (reg_tmp1.xxxx).x;
    // 52: mov
    reg_tmp5.x = (reg_tmp1.yyyy).x;
    // 53: mov
    reg_tmp2 = uniforms.f[95];
    // 54: mov
    reg_tmp3 = uniforms.f[94];
    // 55: mul
    reg_tmp1.z = (mul_safe(reg_tmp6.yyyy, reg_tmp6.yyyy)).z;
    // 56: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 57: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 58: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 59: mov
    reg_tmp2 = uniforms.f[93];
    // 60: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 61: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 62: mul
    reg_tmp1.y = (mul_safe(reg_tmp1.yyyy, reg_tmp6.yyyy)).y;
    // 63: mov
    reg_tmp4.y = (reg_tmp1.xxxx).y;
    // 64: mov
    reg_tmp5.y = (reg_tmp1.yyyy).y;
    // 65: mov
    reg_tmp2 = uniforms.f[95];
    // 66: mov
    reg_tmp3 = uniforms.f[94];
    // 67: mul
    reg_tmp1.z = (mul_safe(reg_tmp6.zzzz, reg_tmp6.zzzz)).z;
    // 68: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 69: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 70: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 71: mov
    reg_tmp2 = uniforms.f[93];
    // 72: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 73: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 74: mul
    reg_tmp1.y = (mul_safe(reg_tmp1.yyyy, reg_tmp6.zzzz)).y;
    // 75: mov
    reg_tmp4.z = (reg_tmp1.xxxx).z;
    // 76: mov
    reg_tmp5.z = (reg_tmp1.yyyy).z;
    // 77: mul
    reg_tmp2.x = (mul_safe(reg_tmp4.yyyy, reg_tmp5.zzzz)).x;
    // 78: mul
    reg_tmp2.y = (mul_safe(reg_tmp5.yyyy, reg_tmp5.zzzz)).y;
    // 79: mul
    reg_tmp6.x = (mul_safe(reg_tmp4.yyyy, reg_tmp4.zzzz)).x;
    // 80: mov
    reg_tmp6.y = (reg_tmp5.zzzz).y;
    // 81: mul
    reg_tmp6.z = (mul_safe(-reg_tmp5.yyyy, reg_tmp4.zzzz)).z;
    // 82: mov
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    // 83: mul
    reg_tmp7.x = (mul_safe(-reg_tmp2.xxxx, reg_tmp4.xxxx)).x;
    // 84: mad
    reg_tmp7.x = (fma_safe(reg_tmp5.yyyy, reg_tmp5.xxxx, reg_tmp7.xxxx)).x;
    // 85: mul
    reg_tmp7.y = (mul_safe(reg_tmp4.zzzz, reg_tmp4.xxxx)).y;
    // 86: mul
    reg_tmp7.z = (mul_safe(reg_tmp2.yyyy, reg_tmp4.xxxx)).z;
    // 87: mad
    reg_tmp7.z = (fma_safe(reg_tmp4.yyyy, reg_tmp5.xxxx, reg_tmp7.zzzz)).z;
    // 88: mov
    reg_tmp7.w = (uniforms.f[0].xxxx).w;
    // 89: mul
    reg_tmp8.x = (mul_safe(reg_tmp2.xxxx, reg_tmp5.xxxx)).x;
    // 90: mad
    reg_tmp8.x = (fma_safe(reg_tmp5.yyyy, reg_tmp4.xxxx, reg_tmp8.xxxx)).x;
    // 91: mul
    reg_tmp8.y = (mul_safe(-reg_tmp4.zzzz, reg_tmp5.xxxx)).y;
    // 92: mul
    reg_tmp8.z = (mul_safe(-reg_tmp2.yyyy, reg_tmp5.xxxx)).z;
    // 93: mad
    reg_tmp8.z = (fma_safe(reg_tmp4.yyyy, reg_tmp4.xxxx, reg_tmp8.zzzz)).z;
    // 94: mov
    reg_tmp8.w = (uniforms.f[0].xxxx).w;
    // 95: mov
    reg_tmp9 = uniforms.f[0].xxxz;
    return false;
}
bool sub_146_166() {
    // 146: mov
    reg_tmp2 = uniforms.f[90];
    // 147: mov
    reg_tmp3 = uniforms.f[91];
    // 148: mov
    reg_tmp4 = uniforms.f[92];
    // 149: mov
    reg_tmp5 = uniforms.f[0].xxxz;
    // 150: mul
    reg_tmp6 = mul_safe(uniforms.f[86].xxxx, reg_tmp2);
    // 151: mad
    reg_tmp6 = fma_safe(reg_tmp3, uniforms.f[86].yyyy, reg_tmp6);
    // 152: mad
    reg_tmp6 = fma_safe(reg_tmp4, uniforms.f[86].zzzz, reg_tmp6);
    // 153: mad
    reg_tmp6 = fma_safe(reg_tmp5, uniforms.f[86].wwww, reg_tmp6);
    // 154: mul
    reg_tmp7 = mul_safe(uniforms.f[87].xxxx, reg_tmp2);
    // 155: mad
    reg_tmp7 = fma_safe(reg_tmp3, uniforms.f[87].yyyy, reg_tmp7);
    // 156: mad
    reg_tmp7 = fma_safe(reg_tmp4, uniforms.f[87].zzzz, reg_tmp7);
    // 157: mad
    reg_tmp7 = fma_safe(reg_tmp5, uniforms.f[87].wwww, reg_tmp7);
    // 158: mul
    reg_tmp8 = mul_safe(uniforms.f[88].xxxx, reg_tmp2);
    // 159: mad
    reg_tmp8 = fma_safe(reg_tmp3, uniforms.f[88].yyyy, reg_tmp8);
    // 160: mad
    reg_tmp8 = fma_safe(reg_tmp4, uniforms.f[88].zzzz, reg_tmp8);
    // 161: mad
    reg_tmp8 = fma_safe(reg_tmp5, uniforms.f[88].wwww, reg_tmp8);
    // 162: mul
    reg_tmp9 = mul_safe(uniforms.f[89].xxxx, reg_tmp2);
    // 163: mad
    reg_tmp9 = fma_safe(reg_tmp3, uniforms.f[89].yyyy, reg_tmp9);
    // 164: mad
    reg_tmp9 = fma_safe(reg_tmp4, uniforms.f[89].zzzz, reg_tmp9);
    // 165: mad
    reg_tmp9 = fma_safe(reg_tmp5, uniforms.f[89].wwww, reg_tmp9);
    return false;
}
bool sub_167_249() {
    // 167: rcp
    reg_tmp2.x = rcp_safe(uniforms.f[81].yyyy.x);
    // 168: mul
    reg_tmp2.xy = (mul_safe(uniforms.f[2].zwww, reg_tmp2.xxxx)).xy;
    // 169: add
    reg_tmp2.xy = (uniforms.f[0].yyyy + reg_tmp2.xyyy).xy;
    // 170: flr
    reg_tmp3.xy = (floor(reg_tmp2.xyyy)).xy;
    // 171: mul
    reg_tmp2.xy = (mul_safe(uniforms.f[81].yyyy, reg_tmp3.xyyy)).xy;
    // 172: add
    reg_tmp2.xy = (uniforms.f[2].zwww + -reg_tmp2.xyyy).xy;
    // 173: min
    reg_tmp0.xy = (min(uniforms.f[81].xxxx, reg_tmp2.xyyy)).xy;
    // 174: max
    reg_tmp0.xy = (max(-uniforms.f[81].xxxx, reg_tmp0.xyyy)).xy;
    // 175: mov
    reg_tmp2 = uniforms.f[95];
    // 176: mov
    reg_tmp3 = uniforms.f[94];
    // 177: mul
    reg_tmp1.z = (mul_safe(reg_tmp0.xxxx, reg_tmp0.xxxx)).z;
    // 178: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 179: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 180: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 181: mov
    reg_tmp2 = uniforms.f[93];
    // 182: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 183: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 184: mul
    reg_tmp1.y = (mul_safe(reg_tmp1.yyyy, reg_tmp0.xxxx)).y;
    // 185: mov
    reg_tmp5.x = (uniforms.f[5].wwww).x;
    // 186: mov
    reg_tmp14.xy = (vs_in_reg1.xyyy).xy;
    // 187: cmp
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    // 188: ifc
    if (conditional_code.x) {
        sub_189_190();
    }
    // 190: cmp
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    // 191: ifc
    if (conditional_code.x) {
        sub_192_193();
    }
    // 193: cmp
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 194: ifc
    if (conditional_code.x) {
        sub_195_196();
    }
    // 196: cmp
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 197: ifc
    if (conditional_code.x) {
        sub_198_200();
    }
    // 200: mov
    reg_tmp3 = reg_tmp14.xyxy;
    // 201: add
    reg_tmp3.y = (uniforms.f[0].zzzz + -reg_tmp3.yyyy).y;
    // 202: add
    reg_tmp3.w = (uniforms.f[0].zzzz + -reg_tmp3.wwww).w;
    // 203: mul
    reg_tmp2 = mul_safe(uniforms.f[83].xxyy, reg_tmp3);
    // 204: add
    reg_tmp2 = -uniforms.f[0].yyyy + reg_tmp2;
    // 205: mul
    reg_tmp2 = mul_safe(reg_tmp2, reg_tmp1.xyyx);
    // 206: add
    reg_tmp2.x = (reg_tmp2.xxxx + -reg_tmp2.yyyy).x;
    // 207: add
    reg_tmp2.y = (reg_tmp2.zzzz + reg_tmp2.wwww).y;
    // 208: mov
    reg_tmp4.xy = (uniforms.f[3].xyyy).xy;
    // 209: mad
    reg_tmp3.xy = (fma_safe(reg_tmp2.xyyy, uniforms.f[3].zwww, reg_tmp4.xyyy)).xy;
    // 210: add
    reg_tmp3.xy = (uniforms.f[0].yyyy + reg_tmp3.xyyy).xy;
    // 211: mov
    reg_tmp11.xy = (reg_tmp3.xyyy).xy;
    // 212: mov
    reg_tmp2 = uniforms.f[95];
    // 213: mov
    reg_tmp3 = uniforms.f[94];
    // 214: mul
    reg_tmp1.z = (mul_safe(reg_tmp0.yyyy, reg_tmp0.yyyy)).z;
    // 215: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 216: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 217: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 218: mov
    reg_tmp2 = uniforms.f[93];
    // 219: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 220: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 221: mul
    reg_tmp1.y = (mul_safe(reg_tmp1.yyyy, reg_tmp0.yyyy)).y;
    // 222: mov
    reg_tmp5.x = (uniforms.f[6].wwww).x;
    // 223: mov
    reg_tmp14.xy = (vs_in_reg1.xyyy).xy;
    // 224: cmp
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    // 225: ifc
    if (conditional_code.x) {
        sub_226_227();
    }
    // 227: cmp
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    // 228: ifc
    if (conditional_code.x) {
        sub_229_230();
    }
    // 230: cmp
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 231: ifc
    if (conditional_code.x) {
        sub_232_233();
    }
    // 233: cmp
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 234: ifc
    if (conditional_code.x) {
        sub_235_237();
    }
    // 237: mov
    reg_tmp3 = reg_tmp14.xyxy;
    // 238: add
    reg_tmp3.y = (uniforms.f[0].zzzz + -reg_tmp3.yyyy).y;
    // 239: add
    reg_tmp3.w = (uniforms.f[0].zzzz + -reg_tmp3.wwww).w;
    // 240: mul
    reg_tmp2 = mul_safe(uniforms.f[83].zzww, reg_tmp3);
    // 241: add
    reg_tmp2 = -uniforms.f[0].yyyy + reg_tmp2;
    // 242: mul
    reg_tmp2 = mul_safe(reg_tmp2, reg_tmp1.xyyx);
    // 243: add
    reg_tmp2.x = (reg_tmp2.xxxx + -reg_tmp2.yyyy).x;
    // 244: add
    reg_tmp2.y = (reg_tmp2.zzzz + reg_tmp2.wwww).y;
    // 245: mov
    reg_tmp4.xy = (uniforms.f[4].xyyy).xy;
    // 246: mad
    reg_tmp3.xy = (fma_safe(reg_tmp2.xyyy, uniforms.f[4].zwww, reg_tmp4.xyyy)).xy;
    // 247: add
    reg_tmp3.xy = (uniforms.f[0].yyyy + reg_tmp3.xyyy).xy;
    // 248: mov
    reg_tmp12.xy = (reg_tmp3.xyyy).xy;
    return false;
}
bool sub_189_190() {
    // 189: mov
    reg_tmp14.xy = (vs_in_reg1.xyyy).xy;
    return false;
}
bool sub_192_193() {
    // 192: add
    reg_tmp14.x = (uniforms.f[0].zzzz + -vs_in_reg1.xxxx).x;
    return false;
}
bool sub_195_196() {
    // 195: add
    reg_tmp14.y = (uniforms.f[0].zzzz + -vs_in_reg1.yyyy).y;
    return false;
}
bool sub_198_200() {
    // 198: add
    reg_tmp14.x = (uniforms.f[0].zzzz + -vs_in_reg1.xxxx).x;
    // 199: add
    reg_tmp14.y = (uniforms.f[0].zzzz + -vs_in_reg1.yyyy).y;
    return false;
}
bool sub_226_227() {
    // 226: mov
    reg_tmp14.xy = (vs_in_reg1.xyyy).xy;
    return false;
}
bool sub_229_230() {
    // 229: add
    reg_tmp14.x = (uniforms.f[0].zzzz + -vs_in_reg1.xxxx).x;
    return false;
}
bool sub_232_233() {
    // 232: add
    reg_tmp14.y = (uniforms.f[0].zzzz + -vs_in_reg1.yyyy).y;
    return false;
}
bool sub_235_237() {
    // 235: add
    reg_tmp14.x = (uniforms.f[0].zzzz + -vs_in_reg1.xxxx).x;
    // 236: add
    reg_tmp14.y = (uniforms.f[0].zzzz + -vs_in_reg1.yyyy).y;
    return false;
}
bool sub_250_4096() {
    // 250: call
    {
        sub_0_8();
    }
    // 251: add
    reg_tmp10.xy = (uniforms.f[84].xyyy + reg_tmp10.xyyy).xy;
    // 252: mul
    reg_tmp10.xyz = (mul_safe(uniforms.f[2].xyxx, reg_tmp10.xyzz)).xyz;
    // 253: mov
    reg_tmp14 = reg_tmp10;
    // 254: mov
    reg_tmp0 = uniforms.f[7];
    // 255: call
    {
        sub_33_96();
    }
    // 256: dp4
    reg_tmp10.x = dot(reg_tmp14, reg_tmp6);
    // 257: dp4
    reg_tmp10.y = dot(reg_tmp14, reg_tmp7);
    // 258: dp4
    reg_tmp10.z = dot(reg_tmp14, reg_tmp8);
    // 259: dp4
    reg_tmp10.w = dot(reg_tmp14, reg_tmp9);
    // 260: mov
    reg_tmp6 = uniforms.f[8];
    // 261: mov
    reg_tmp7 = uniforms.f[9];
    // 262: mov
    reg_tmp8 = uniforms.f[10];
    // 263: mov
    reg_tmp9 = uniforms.f[0].xxxz;
    // 264: mov
    reg_tmp6.w = (uniforms.f[5].xxxx).w;
    // 265: mov
    reg_tmp7.w = (uniforms.f[5].yyyy).w;
    // 266: mov
    reg_tmp8.w = (uniforms.f[5].zzzz).w;
    // 267: dp4
    reg_tmp2.x = dot(reg_tmp10, reg_tmp6);
    // 268: dp4
    reg_tmp2.y = dot(reg_tmp10, reg_tmp7);
    // 269: dp4
    reg_tmp2.z = dot(reg_tmp10, reg_tmp8);
    // 270: dp4
    reg_tmp2.w = dot(reg_tmp10, reg_tmp9);
    // 271: mov
    reg_tmp10 = reg_tmp2;
    // 272: mov
    reg_tmp3.xyz = (uniforms.f[5].xyzz).xyz;
    // 273: add
    reg_tmp3.xyz = (uniforms.f[85].xyzz + -reg_tmp3.xyzz).xyz;
    // 274: dp3
    reg_tmp4.x = dot(vec3(reg_tmp3.xyzz), vec3(reg_tmp3.xyzz));
    // 275: cmp
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
    // 276: ifc
    if (conditional_code.x) {
        sub_277_278();
    } else {
        sub_278_279();
    }
    // 279: mul
    reg_tmp3.xyz = (mul_safe(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
    // 280: mad
    reg_tmp10.xyz = (fma_safe(reg_tmp3.xyzz, uniforms.f[84].zzzz, reg_tmp10.xyzz)).xyz;
    // 281: call
    {
        sub_146_166();
    }
    // 282: mov
    reg_tmp2 = reg_tmp10;
    // 283: dp4
    reg_tmp10.x = dot(reg_tmp2, reg_tmp6);
    // 284: dp4
    reg_tmp10.y = dot(reg_tmp2, reg_tmp7);
    // 285: dp4
    reg_tmp10.z = dot(reg_tmp2, reg_tmp8);
    // 286: dp4
    reg_tmp10.w = dot(reg_tmp2, reg_tmp9);
    // 287: mov
    reg_tmp2 = uniforms.f[1];
    // 288: max
    reg_tmp3 = max(uniforms.f[0].xxxx, reg_tmp2);
    // 289: min
    reg_tmp2 = min(uniforms.f[0].zzzz, reg_tmp3);
    // 290: mov
    reg_tmp13 = reg_tmp2;
    // 291: call
    {
        sub_167_249();
    }
    // 292: call
    {
        sub_9_32();
    }
    // 293: end
    return true;
}
bool sub_277_278() {
    // 277: mov
    reg_tmp4.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_278_279() {
    // 278: rsq
    reg_tmp4.x = rsq_safe(reg_tmp4.xxxx.x);
    return false;
}
// reference: 01EC2DEE7D5410D9, 9FB407F1EC1D74B1
// program: 9FB407F1EC1D74B1, CEF02063E9A18B2F, ED9AAA1E39CE1504
// reference: 2EF84CDB0ED1509A, D82E12A9D19ACD63
// reference: 4A17932745786503, B8A2CA3DB47999BF
// reference: C1F744889CB366B1, B8A2CA3DB47999BF
// reference: D6B85B11E34B824E, 5447A3297E824FE0
// reference: 5D588CBE3A8081FC, 5447A3297E824FE0
// reference: D363EF81FCD95FFB, B543C911C8D7EAAB
// reference: B0BD7A917D3BCDCB, B8A2CA3DB47999BF
// reference: 3B5DAD3E24949DFA, B8A2CA3DB47999BF
// reference: 5FB272C2B32C193C, D82E12A9D19ACD63
// reference: BF5CAE518D92D061, DEFAC6F185DB6EB9
// reference: 1CA06A9C38CB5642, 48B3A6FBA8498826
// reference: 1CA06A9C0E39C6B1, 48B3A6FBA8498826
// reference: 0E27173E50A36299, F70C4BC6991FAFE8
// reference: 0E27173E6651F26A, F70C4BC6991FAFE8
// reference: B3E4F8DBD6819D46, 65138AC5CA635BBF
// reference: 7EAABC3939D78153, DEFAC6F185DB6EB9
// reference: 7EAABC390F2511A0, DEFAC6F185DB6EB9
// reference: 635646A962AEFA4C, DD35FB9CAEB223CF
// reference: 4C42279C112BBA0F, D82E12A9D19ACD63
// reference: 28ADF8605A828F96, B8A2CA3DB47999BF
// reference: A34D2FCF83498C24, B8A2CA3DB47999BF
// shader: 8B31, F8064BC04B6228AD

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define fma_safe(x, y, z) fma(x, y, z)
#define mul_safe(x, y) (x * y)
#define rcp_safe(x) (1.0f / x)
#define rsq_safe(x) inversesqrt(x)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_8();
bool sub_9_32();
bool sub_33_96();
bool sub_114_142();
bool sub_146_166();
bool sub_167_249();
bool sub_189_190();
bool sub_192_193();
bool sub_195_196();
bool sub_198_200();
bool sub_226_227();
bool sub_229_230();
bool sub_232_233();
bool sub_235_237();
bool sub_250_4096();
bool sub_269_270();
bool sub_270_271();

bool exec_shader() {
    sub_250_4096();
    return true;
}

bool sub_0_8() {
    // 0: mov
    reg_tmp10 = uniforms.f[0].xxxz;
    // 1: mov
    reg_tmp10.xyz = (vs_in_reg0.xyzz).xyz;
    // 2: mov
    reg_tmp11 = uniforms.f[0].xxxx;
    // 3: mov
    reg_tmp12 = uniforms.f[0].xxxx;
    // 4: mov
    reg_tmp11.xy = (vs_in_reg1.xyyy).xy;
    // 5: mov
    reg_tmp13 = uniforms.f[0].zzzz;
    // 6: mov
    reg_tmp4 = uniforms.f[0].xxxx;
    // 7: mov
    reg_tmp5 = uniforms.f[0].xxxx;
    return false;
}
bool sub_9_32() {
    // 9: mov
    vs_out_attr0 = reg_tmp10;
    // 10: mul
    reg_tmp13 = mul_safe(uniforms.f[82], reg_tmp13);
    // 11: mul
    vs_out_attr1 = mul_safe(vs_in_reg2, reg_tmp13);
    // 12: add
    reg_tmp11.y = (uniforms.f[0].zzzz + -reg_tmp11.yyyy).y;
    // 13: add
    reg_tmp12.y = (uniforms.f[0].zzzz + -reg_tmp12.yyyy).y;
    // 14: mov
    reg_tmp14.y = (uniforms.f[81].wwww).y;
    // 15: mul
    reg_tmp14.x = (mul_safe(uniforms.f[0].wwww, reg_tmp14.yyyy)).x;
    // 16: rcp
    reg_tmp2.x = rcp_safe(reg_tmp14.xxxx.x);
    // 17: mov
    reg_tmp14.z = (reg_tmp2.xxxx).z;
    // 18: add
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp11.xyyy).xy;
    // 19: mul
    reg_tmp5.xy = (mul_safe(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    // 20: flr
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    // 21: mul
    reg_tmp4.xy = (mul_safe(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    // 22: add
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    // 23: add
    reg_tmp11.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    // 24: add
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp12.xyyy).xy;
    // 25: mul
    reg_tmp5.xy = (mul_safe(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    // 26: flr
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    // 27: mul
    reg_tmp4.xy = (mul_safe(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    // 28: add
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    // 29: add
    reg_tmp12.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    // 30: mov
    vs_out_attr2 = reg_tmp11;
    // 31: mov
    vs_out_attr3 = reg_tmp12;
    return false;
}
bool sub_33_96() {
    // 33: mov
    reg_tmp6.xyz = (-reg_tmp0.xyzz).xyz;
    // 34: mov
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    // 35: rcp
    reg_tmp7.xyz = vec3(rcp_safe(uniforms.f[81].yyyy.x));
    // 36: madi
    reg_tmp8.xyz = (fma_safe(reg_tmp6.xyzz, reg_tmp7.xyzz, uniforms.f[0].yyyy)).xyz;
    // 37: flr
    reg_tmp7.xyz = (floor(reg_tmp8.xyzz)).xyz;
    // 38: mad
    reg_tmp6.xyz = (fma_safe(reg_tmp7.xyzz, -uniforms.f[81].yyyy, reg_tmp6.xyzz)).xyz;
    // 39: min
    reg_tmp6 = min(uniforms.f[81].xxxx, reg_tmp6);
    // 40: max
    reg_tmp6 = max(-uniforms.f[81].xxxx, reg_tmp6);
    // 41: mov
    reg_tmp2 = uniforms.f[95];
    // 42: mov
    reg_tmp3 = uniforms.f[94];
    // 43: mul
    reg_tmp1.z = (mul_safe(reg_tmp6.xxxx, reg_tmp6.xxxx)).z;
    // 44: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 45: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 46: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 47: mov
    reg_tmp2 = uniforms.f[93];
    // 48: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 49: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 50: mul
    reg_tmp1.y = (mul_safe(reg_tmp1.yyyy, reg_tmp6.xxxx)).y;
    // 51: mov
    reg_tmp4.x = (reg_tmp1.xxxx).x;
    // 52: mov
    reg_tmp5.x = (reg_tmp1.yyyy).x;
    // 53: mov
    reg_tmp2 = uniforms.f[95];
    // 54: mov
    reg_tmp3 = uniforms.f[94];
    // 55: mul
    reg_tmp1.z = (mul_safe(reg_tmp6.yyyy, reg_tmp6.yyyy)).z;
    // 56: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 57: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 58: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 59: mov
    reg_tmp2 = uniforms.f[93];
    // 60: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 61: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 62: mul
    reg_tmp1.y = (mul_safe(reg_tmp1.yyyy, reg_tmp6.yyyy)).y;
    // 63: mov
    reg_tmp4.y = (reg_tmp1.xxxx).y;
    // 64: mov
    reg_tmp5.y = (reg_tmp1.yyyy).y;
    // 65: mov
    reg_tmp2 = uniforms.f[95];
    // 66: mov
    reg_tmp3 = uniforms.f[94];
    // 67: mul
    reg_tmp1.z = (mul_safe(reg_tmp6.zzzz, reg_tmp6.zzzz)).z;
    // 68: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 69: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 70: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 71: mov
    reg_tmp2 = uniforms.f[93];
    // 72: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 73: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 74: mul
    reg_tmp1.y = (mul_safe(reg_tmp1.yyyy, reg_tmp6.zzzz)).y;
    // 75: mov
    reg_tmp4.z = (reg_tmp1.xxxx).z;
    // 76: mov
    reg_tmp5.z = (reg_tmp1.yyyy).z;
    // 77: mul
    reg_tmp2.x = (mul_safe(reg_tmp4.yyyy, reg_tmp5.zzzz)).x;
    // 78: mul
    reg_tmp2.y = (mul_safe(reg_tmp5.yyyy, reg_tmp5.zzzz)).y;
    // 79: mul
    reg_tmp6.x = (mul_safe(reg_tmp4.yyyy, reg_tmp4.zzzz)).x;
    // 80: mov
    reg_tmp6.y = (reg_tmp5.zzzz).y;
    // 81: mul
    reg_tmp6.z = (mul_safe(-reg_tmp5.yyyy, reg_tmp4.zzzz)).z;
    // 82: mov
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    // 83: mul
    reg_tmp7.x = (mul_safe(-reg_tmp2.xxxx, reg_tmp4.xxxx)).x;
    // 84: mad
    reg_tmp7.x = (fma_safe(reg_tmp5.yyyy, reg_tmp5.xxxx, reg_tmp7.xxxx)).x;
    // 85: mul
    reg_tmp7.y = (mul_safe(reg_tmp4.zzzz, reg_tmp4.xxxx)).y;
    // 86: mul
    reg_tmp7.z = (mul_safe(reg_tmp2.yyyy, reg_tmp4.xxxx)).z;
    // 87: mad
    reg_tmp7.z = (fma_safe(reg_tmp4.yyyy, reg_tmp5.xxxx, reg_tmp7.zzzz)).z;
    // 88: mov
    reg_tmp7.w = (uniforms.f[0].xxxx).w;
    // 89: mul
    reg_tmp8.x = (mul_safe(reg_tmp2.xxxx, reg_tmp5.xxxx)).x;
    // 90: mad
    reg_tmp8.x = (fma_safe(reg_tmp5.yyyy, reg_tmp4.xxxx, reg_tmp8.xxxx)).x;
    // 91: mul
    reg_tmp8.y = (mul_safe(-reg_tmp4.zzzz, reg_tmp5.xxxx)).y;
    // 92: mul
    reg_tmp8.z = (mul_safe(-reg_tmp2.yyyy, reg_tmp5.xxxx)).z;
    // 93: mad
    reg_tmp8.z = (fma_safe(reg_tmp4.yyyy, reg_tmp4.xxxx, reg_tmp8.zzzz)).z;
    // 94: mov
    reg_tmp8.w = (uniforms.f[0].xxxx).w;
    // 95: mov
    reg_tmp9 = uniforms.f[0].xxxz;
    return false;
}
bool sub_114_142() {
    // 114: mov
    reg_tmp2 = uniforms.f[85];
    // 115: add
    reg_tmp2.xz = (-uniforms.f[5].xzzz + reg_tmp2.xzzz).xz;
    // 116: mov
    reg_tmp2.yw = (uniforms.f[0].xxxx).yw;
    // 117: dp3
    reg_tmp3.x = dot(vec3(reg_tmp2.xyzz), vec3(reg_tmp2.xyzz));
    // 118: rsq
    reg_tmp3.x = rsq_safe(reg_tmp3.xxxx.x);
    // 119: mul
    reg_tmp2.xyz = (mul_safe(reg_tmp2.xyzz, reg_tmp3.xxxx)).xyz;
    // 120: mov
    reg_tmp4 = uniforms.f[0].xzxx;
    // 121: mul
    reg_tmp5.xyz = (mul_safe(reg_tmp2.yzxx, reg_tmp4.zxyy)).xyz;
    // 122: mad
    reg_tmp5.xyz = (fma_safe(-reg_tmp4.yzxx, reg_tmp2.zxyy, reg_tmp5)).xyz;
    // 123: dp3
    reg_tmp3.x = dot(vec3(reg_tmp5.xyzz), vec3(reg_tmp5.xyzz));
    // 124: rsq
    reg_tmp3.x = rsq_safe(reg_tmp3.xxxx.x);
    // 125: mul
    reg_tmp5.xyz = (mul_safe(reg_tmp5.xyzz, reg_tmp3.xxxx)).xyz;
    // 126: mov
    reg_tmp6.x = (-reg_tmp5.xxxx).x;
    // 127: mov
    reg_tmp6.y = (-reg_tmp5.yyyy).y;
    // 128: mov
    reg_tmp6.z = (-reg_tmp5.zzzz).z;
    // 129: mov
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    // 130: mov
    reg_tmp7.x = (reg_tmp4.xxxx).x;
    // 131: mov
    reg_tmp7.y = (reg_tmp4.yyyy).y;
    // 132: mov
    reg_tmp7.z = (reg_tmp4.zzzz).z;
    // 133: mov
    reg_tmp7.w = (uniforms.f[0].xxxx).w;
    // 134: mov
    reg_tmp8.x = (-reg_tmp2.xxxx).x;
    // 135: mov
    reg_tmp8.y = (-reg_tmp2.yyyy).y;
    // 136: mov
    reg_tmp8.z = (-reg_tmp2.zzzz).z;
    // 137: mov
    reg_tmp8.w = (uniforms.f[0].xxxx).w;
    // 138: mov
    reg_tmp9.x = (uniforms.f[90].wwww).x;
    // 139: mov
    reg_tmp9.y = (uniforms.f[91].wwww).y;
    // 140: mov
    reg_tmp9.z = (uniforms.f[92].wwww).z;
    // 141: mov
    reg_tmp9.w = (uniforms.f[0].zzzz).w;
    return false;
}
bool sub_146_166() {
    // 146: mov
    reg_tmp2 = uniforms.f[90];
    // 147: mov
    reg_tmp3 = uniforms.f[91];
    // 148: mov
    reg_tmp4 = uniforms.f[92];
    // 149: mov
    reg_tmp5 = uniforms.f[0].xxxz;
    // 150: mul
    reg_tmp6 = mul_safe(uniforms.f[86].xxxx, reg_tmp2);
    // 151: mad
    reg_tmp6 = fma_safe(reg_tmp3, uniforms.f[86].yyyy, reg_tmp6);
    // 152: mad
    reg_tmp6 = fma_safe(reg_tmp4, uniforms.f[86].zzzz, reg_tmp6);
    // 153: mad
    reg_tmp6 = fma_safe(reg_tmp5, uniforms.f[86].wwww, reg_tmp6);
    // 154: mul
    reg_tmp7 = mul_safe(uniforms.f[87].xxxx, reg_tmp2);
    // 155: mad
    reg_tmp7 = fma_safe(reg_tmp3, uniforms.f[87].yyyy, reg_tmp7);
    // 156: mad
    reg_tmp7 = fma_safe(reg_tmp4, uniforms.f[87].zzzz, reg_tmp7);
    // 157: mad
    reg_tmp7 = fma_safe(reg_tmp5, uniforms.f[87].wwww, reg_tmp7);
    // 158: mul
    reg_tmp8 = mul_safe(uniforms.f[88].xxxx, reg_tmp2);
    // 159: mad
    reg_tmp8 = fma_safe(reg_tmp3, uniforms.f[88].yyyy, reg_tmp8);
    // 160: mad
    reg_tmp8 = fma_safe(reg_tmp4, uniforms.f[88].zzzz, reg_tmp8);
    // 161: mad
    reg_tmp8 = fma_safe(reg_tmp5, uniforms.f[88].wwww, reg_tmp8);
    // 162: mul
    reg_tmp9 = mul_safe(uniforms.f[89].xxxx, reg_tmp2);
    // 163: mad
    reg_tmp9 = fma_safe(reg_tmp3, uniforms.f[89].yyyy, reg_tmp9);
    // 164: mad
    reg_tmp9 = fma_safe(reg_tmp4, uniforms.f[89].zzzz, reg_tmp9);
    // 165: mad
    reg_tmp9 = fma_safe(reg_tmp5, uniforms.f[89].wwww, reg_tmp9);
    return false;
}
bool sub_167_249() {
    // 167: rcp
    reg_tmp2.x = rcp_safe(uniforms.f[81].yyyy.x);
    // 168: mul
    reg_tmp2.xy = (mul_safe(uniforms.f[2].zwww, reg_tmp2.xxxx)).xy;
    // 169: add
    reg_tmp2.xy = (uniforms.f[0].yyyy + reg_tmp2.xyyy).xy;
    // 170: flr
    reg_tmp3.xy = (floor(reg_tmp2.xyyy)).xy;
    // 171: mul
    reg_tmp2.xy = (mul_safe(uniforms.f[81].yyyy, reg_tmp3.xyyy)).xy;
    // 172: add
    reg_tmp2.xy = (uniforms.f[2].zwww + -reg_tmp2.xyyy).xy;
    // 173: min
    reg_tmp0.xy = (min(uniforms.f[81].xxxx, reg_tmp2.xyyy)).xy;
    // 174: max
    reg_tmp0.xy = (max(-uniforms.f[81].xxxx, reg_tmp0.xyyy)).xy;
    // 175: mov
    reg_tmp2 = uniforms.f[95];
    // 176: mov
    reg_tmp3 = uniforms.f[94];
    // 177: mul
    reg_tmp1.z = (mul_safe(reg_tmp0.xxxx, reg_tmp0.xxxx)).z;
    // 178: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 179: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 180: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 181: mov
    reg_tmp2 = uniforms.f[93];
    // 182: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 183: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 184: mul
    reg_tmp1.y = (mul_safe(reg_tmp1.yyyy, reg_tmp0.xxxx)).y;
    // 185: mov
    reg_tmp5.x = (uniforms.f[5].wwww).x;
    // 186: mov
    reg_tmp14.xy = (vs_in_reg1.xyyy).xy;
    // 187: cmp
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    // 188: ifc
    if (conditional_code.x) {
        sub_189_190();
    }
    // 190: cmp
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    // 191: ifc
    if (conditional_code.x) {
        sub_192_193();
    }
    // 193: cmp
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 194: ifc
    if (conditional_code.x) {
        sub_195_196();
    }
    // 196: cmp
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 197: ifc
    if (conditional_code.x) {
        sub_198_200();
    }
    // 200: mov
    reg_tmp3 = reg_tmp14.xyxy;
    // 201: add
    reg_tmp3.y = (uniforms.f[0].zzzz + -reg_tmp3.yyyy).y;
    // 202: add
    reg_tmp3.w = (uniforms.f[0].zzzz + -reg_tmp3.wwww).w;
    // 203: mul
    reg_tmp2 = mul_safe(uniforms.f[83].xxyy, reg_tmp3);
    // 204: add
    reg_tmp2 = -uniforms.f[0].yyyy + reg_tmp2;
    // 205: mul
    reg_tmp2 = mul_safe(reg_tmp2, reg_tmp1.xyyx);
    // 206: add
    reg_tmp2.x = (reg_tmp2.xxxx + -reg_tmp2.yyyy).x;
    // 207: add
    reg_tmp2.y = (reg_tmp2.zzzz + reg_tmp2.wwww).y;
    // 208: mov
    reg_tmp4.xy = (uniforms.f[3].xyyy).xy;
    // 209: mad
    reg_tmp3.xy = (fma_safe(reg_tmp2.xyyy, uniforms.f[3].zwww, reg_tmp4.xyyy)).xy;
    // 210: add
    reg_tmp3.xy = (uniforms.f[0].yyyy + reg_tmp3.xyyy).xy;
    // 211: mov
    reg_tmp11.xy = (reg_tmp3.xyyy).xy;
    // 212: mov
    reg_tmp2 = uniforms.f[95];
    // 213: mov
    reg_tmp3 = uniforms.f[94];
    // 214: mul
    reg_tmp1.z = (mul_safe(reg_tmp0.yyyy, reg_tmp0.yyyy)).z;
    // 215: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 216: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 217: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 218: mov
    reg_tmp2 = uniforms.f[93];
    // 219: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 220: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 221: mul
    reg_tmp1.y = (mul_safe(reg_tmp1.yyyy, reg_tmp0.yyyy)).y;
    // 222: mov
    reg_tmp5.x = (uniforms.f[6].wwww).x;
    // 223: mov
    reg_tmp14.xy = (vs_in_reg1.xyyy).xy;
    // 224: cmp
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    // 225: ifc
    if (conditional_code.x) {
        sub_226_227();
    }
    // 227: cmp
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    // 228: ifc
    if (conditional_code.x) {
        sub_229_230();
    }
    // 230: cmp
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 231: ifc
    if (conditional_code.x) {
        sub_232_233();
    }
    // 233: cmp
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 234: ifc
    if (conditional_code.x) {
        sub_235_237();
    }
    // 237: mov
    reg_tmp3 = reg_tmp14.xyxy;
    // 238: add
    reg_tmp3.y = (uniforms.f[0].zzzz + -reg_tmp3.yyyy).y;
    // 239: add
    reg_tmp3.w = (uniforms.f[0].zzzz + -reg_tmp3.wwww).w;
    // 240: mul
    reg_tmp2 = mul_safe(uniforms.f[83].zzww, reg_tmp3);
    // 241: add
    reg_tmp2 = -uniforms.f[0].yyyy + reg_tmp2;
    // 242: mul
    reg_tmp2 = mul_safe(reg_tmp2, reg_tmp1.xyyx);
    // 243: add
    reg_tmp2.x = (reg_tmp2.xxxx + -reg_tmp2.yyyy).x;
    // 244: add
    reg_tmp2.y = (reg_tmp2.zzzz + reg_tmp2.wwww).y;
    // 245: mov
    reg_tmp4.xy = (uniforms.f[4].xyyy).xy;
    // 246: mad
    reg_tmp3.xy = (fma_safe(reg_tmp2.xyyy, uniforms.f[4].zwww, reg_tmp4.xyyy)).xy;
    // 247: add
    reg_tmp3.xy = (uniforms.f[0].yyyy + reg_tmp3.xyyy).xy;
    // 248: mov
    reg_tmp12.xy = (reg_tmp3.xyyy).xy;
    return false;
}
bool sub_189_190() {
    // 189: mov
    reg_tmp14.xy = (vs_in_reg1.xyyy).xy;
    return false;
}
bool sub_192_193() {
    // 192: add
    reg_tmp14.x = (uniforms.f[0].zzzz + -vs_in_reg1.xxxx).x;
    return false;
}
bool sub_195_196() {
    // 195: add
    reg_tmp14.y = (uniforms.f[0].zzzz + -vs_in_reg1.yyyy).y;
    return false;
}
bool sub_198_200() {
    // 198: add
    reg_tmp14.x = (uniforms.f[0].zzzz + -vs_in_reg1.xxxx).x;
    // 199: add
    reg_tmp14.y = (uniforms.f[0].zzzz + -vs_in_reg1.yyyy).y;
    return false;
}
bool sub_226_227() {
    // 226: mov
    reg_tmp14.xy = (vs_in_reg1.xyyy).xy;
    return false;
}
bool sub_229_230() {
    // 229: add
    reg_tmp14.x = (uniforms.f[0].zzzz + -vs_in_reg1.xxxx).x;
    return false;
}
bool sub_232_233() {
    // 232: add
    reg_tmp14.y = (uniforms.f[0].zzzz + -vs_in_reg1.yyyy).y;
    return false;
}
bool sub_235_237() {
    // 235: add
    reg_tmp14.x = (uniforms.f[0].zzzz + -vs_in_reg1.xxxx).x;
    // 236: add
    reg_tmp14.y = (uniforms.f[0].zzzz + -vs_in_reg1.yyyy).y;
    return false;
}
bool sub_250_4096() {
    // 250: call
    {
        sub_0_8();
    }
    // 251: add
    reg_tmp10.xy = (uniforms.f[84].xyyy + reg_tmp10.xyyy).xy;
    // 252: mul
    reg_tmp10.xyz = (mul_safe(uniforms.f[2].xyxx, reg_tmp10.xyzz)).xyz;
    // 253: call
    {
        sub_114_142();
    }
    // 254: dp4
    reg_tmp14.x = dot(reg_tmp10, reg_tmp6);
    // 255: dp4
    reg_tmp14.y = dot(reg_tmp10, reg_tmp7);
    // 256: dp4
    reg_tmp14.z = dot(reg_tmp10, reg_tmp8);
    // 257: dp4
    reg_tmp14.w = dot(uniforms.f[0].xxxz, reg_tmp10);
    // 258: mov
    reg_tmp0 = uniforms.f[7];
    // 259: call
    {
        sub_33_96();
    }
    // 260: dp4
    reg_tmp2.x = dot(reg_tmp14, reg_tmp6);
    // 261: dp4
    reg_tmp2.y = dot(reg_tmp14, reg_tmp7);
    // 262: dp4
    reg_tmp2.z = dot(reg_tmp14, reg_tmp8);
    // 263: dp4
    reg_tmp2.w = dot(reg_tmp14, reg_tmp9);
    // 264: mov
    reg_tmp3.xyz = (uniforms.f[5].xyzz).xyz;
    // 265: add
    reg_tmp3.xyz = (uniforms.f[85].xyzz + -reg_tmp3.xyzz).xyz;
    // 266: dp3
    reg_tmp4.x = dot(vec3(reg_tmp3.xyzz), vec3(reg_tmp3.xyzz));
    // 267: cmp
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
    // 268: ifc
    if (conditional_code.x) {
        sub_269_270();
    } else {
        sub_270_271();
    }
    // 271: mul
    reg_tmp3.xyz = (mul_safe(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
    // 272: add
    reg_tmp10.xyz = (uniforms.f[5].xyzz + reg_tmp2.xyzz).xyz;
    // 273: mad
    reg_tmp10.xyz = (fma_safe(reg_tmp3.xyzz, uniforms.f[84].zzzz, reg_tmp10.xyzz)).xyz;
    // 274: call
    {
        sub_146_166();
    }
    // 275: mov
    reg_tmp2 = reg_tmp10;
    // 276: dp4
    reg_tmp10.x = dot(reg_tmp2, reg_tmp6);
    // 277: dp4
    reg_tmp10.y = dot(reg_tmp2, reg_tmp7);
    // 278: dp4
    reg_tmp10.z = dot(reg_tmp2, reg_tmp8);
    // 279: dp4
    reg_tmp10.w = dot(reg_tmp2, reg_tmp9);
    // 280: mov
    reg_tmp2 = uniforms.f[1];
    // 281: max
    reg_tmp3 = max(uniforms.f[0].xxxx, reg_tmp2);
    // 282: min
    reg_tmp2 = min(uniforms.f[0].zzzz, reg_tmp3);
    // 283: mov
    reg_tmp13 = reg_tmp2;
    // 284: call
    {
        sub_167_249();
    }
    // 285: call
    {
        sub_9_32();
    }
    // 286: end
    return true;
}
bool sub_269_270() {
    // 269: mov
    reg_tmp4.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_270_271() {
    // 270: rsq
    reg_tmp4.x = rsq_safe(reg_tmp4.xxxx.x);
    return false;
}
// reference: F74BED4111835624, F8064BC04B6228AD
// program: F8064BC04B6228AD, CEF02063E9A18B2F, ED9AAA1E39CE1504
// reference: F74BED41DA6CD103, F8064BC04B6228AD
// reference: E76B3F006C0E15A8, 3295BFC9E1117A37
// program: 3295BFC9E1117A37, CEF02063E9A18B2F, ED9AAA1E39CE1504
// reference: 50F5AA3C8E4F9349, D82E12A9D19ACD63
// reference: 341A75C0C5E6A6D0, B8A2CA3DB47999BF
// reference: BFFAA26F1C2DA562, B8A2CA3DB47999BF
// reference: 79AF2211E34B824E, 5447A3297E824FE0
// reference: F24FF5BE3A8081FC, 5447A3297E824FE0
// reference: 08E4FAA2FCD95FFB, B543C911C8D7EAAB
// reference: 6B3A6FB27D3BCDCB, B8A2CA3DB47999BF
// reference: E0DAB81D24949DFA, B8A2CA3DB47999BF
// reference: 843567E1B32C193C, D82E12A9D19ACD63
// reference: 64DBBB728D92D061, DEFAC6F185DB6EB9
// reference: 4512E5F938CB5642, 48B3A6FBA8498826
// reference: 4512E5F90E39C6B1, 48B3A6FBA8498826
// reference: 5795985B50A36299, F70C4BC6991FAFE8
// reference: 5795985B6651F26A, F70C4BC6991FAFE8
// reference: EA5677BED6819D46, 65138AC5CA635BBF
// reference: 2718335C39D78153, DEFAC6F185DB6EB9
// reference: 2718335C0F2511A0, DEFAC6F185DB6EB9
// reference: 635646A9AE655196, DD35FB9CAEB223CF
// reference: 4C42279CDDE011D5, D82E12A9D19ACD63
// reference: 28ADF8609649244C, B8A2CA3DB47999BF
// reference: A34D2FCF4F8227FE, B8A2CA3DB47999BF
// reference: 01EC2DEE74628101, 9FB407F1EC1D74B1
// reference: 2EF84CDB07E7C142, D82E12A9D19ACD63
// reference: 4A1793274C4EF4DB, B8A2CA3DB47999BF
// reference: C1F744889585F769, B8A2CA3DB47999BF
// reference: 635646A96B986B94, DD35FB9CAEB223CF
// reference: 4C42279C181D2BD7, D82E12A9D19ACD63
// reference: 28ADF86053B41E4E, B8A2CA3DB47999BF
// reference: A34D2FCF8A7F1DFC, B8A2CA3DB47999BF
// reference: 2983DF1787F0C99D, 734B56B7CFCD3D95
// program: 734B56B7CFCD3D95, CEF02063E9A18B2F, 931705B2EA3991A9
// shader: 8B31, FDCB6921459E149F

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define fma_safe(x, y, z) fma(x, y, z)
#define mul_safe(x, y) (x * y)
#define rcp_safe(x) (1.0f / x)
#define rsq_safe(x) inversesqrt(x)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_8();
bool sub_9_32();
bool sub_146_166();
bool sub_167_259();
bool sub_190_192();
bool sub_194_195();
bool sub_197_198();
bool sub_200_202();
bool sub_232_234();
bool sub_236_237();
bool sub_239_240();
bool sub_242_244();
bool sub_260_4096();
bool sub_280_281();
bool sub_281_282();

bool exec_shader() {
    sub_260_4096();
    return true;
}

bool sub_0_8() {
    // 0: mova
    address_registers.x = (ivec2(vs_in_reg0.zzzz)).x;
    // 1: mov
    reg_tmp10 = uniforms.f[0].xxxz;
    // 2: mov
    reg_tmp10.xy = (vs_in_reg0.xyyy).xy;
    // 3: mov
    reg_tmp11 = uniforms.f[0].xxxx;
    // 4: mov
    reg_tmp12 = uniforms.f[0].xxxx;
    // 5: mov
    reg_tmp13 = uniforms.f[0].zzzz;
    // 6: mov
    reg_tmp4 = uniforms.f[0].xxxx;
    // 7: mov
    reg_tmp5 = uniforms.f[0].xxxx;
    return false;
}
bool sub_9_32() {
    // 9: mov
    vs_out_attr0 = reg_tmp10;
    // 10: mul
    reg_tmp13 = mul_safe(uniforms.f[82], reg_tmp13);
    // 11: mov
    vs_out_attr1 = reg_tmp13;
    // 12: add
    reg_tmp11.y = (uniforms.f[0].zzzz + -reg_tmp11.yyyy).y;
    // 13: add
    reg_tmp12.y = (uniforms.f[0].zzzz + -reg_tmp12.yyyy).y;
    // 14: mov
    reg_tmp14.y = (uniforms.f[81].wwww).y;
    // 15: mul
    reg_tmp14.x = (mul_safe(uniforms.f[0].wwww, reg_tmp14.yyyy)).x;
    // 16: rcp
    reg_tmp2.x = rcp_safe(reg_tmp14.xxxx.x);
    // 17: mov
    reg_tmp14.z = (reg_tmp2.xxxx).z;
    // 18: add
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp11.xyyy).xy;
    // 19: mul
    reg_tmp5.xy = (mul_safe(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    // 20: flr
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    // 21: mul
    reg_tmp4.xy = (mul_safe(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    // 22: add
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    // 23: add
    reg_tmp11.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    // 24: add
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp12.xyyy).xy;
    // 25: mul
    reg_tmp5.xy = (mul_safe(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    // 26: flr
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    // 27: mul
    reg_tmp4.xy = (mul_safe(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    // 28: add
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    // 29: add
    reg_tmp12.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    // 30: mov
    vs_out_attr2 = reg_tmp11;
    // 31: mov
    vs_out_attr3 = reg_tmp12;
    return false;
}
bool sub_146_166() {
    // 146: mov
    reg_tmp2 = uniforms.f[90];
    // 147: mov
    reg_tmp3 = uniforms.f[91];
    // 148: mov
    reg_tmp4 = uniforms.f[92];
    // 149: mov
    reg_tmp5 = uniforms.f[0].xxxz;
    // 150: mul
    reg_tmp6 = mul_safe(uniforms.f[86].xxxx, reg_tmp2);
    // 151: mad
    reg_tmp6 = fma_safe(reg_tmp3, uniforms.f[86].yyyy, reg_tmp6);
    // 152: mad
    reg_tmp6 = fma_safe(reg_tmp4, uniforms.f[86].zzzz, reg_tmp6);
    // 153: mad
    reg_tmp6 = fma_safe(reg_tmp5, uniforms.f[86].wwww, reg_tmp6);
    // 154: mul
    reg_tmp7 = mul_safe(uniforms.f[87].xxxx, reg_tmp2);
    // 155: mad
    reg_tmp7 = fma_safe(reg_tmp3, uniforms.f[87].yyyy, reg_tmp7);
    // 156: mad
    reg_tmp7 = fma_safe(reg_tmp4, uniforms.f[87].zzzz, reg_tmp7);
    // 157: mad
    reg_tmp7 = fma_safe(reg_tmp5, uniforms.f[87].wwww, reg_tmp7);
    // 158: mul
    reg_tmp8 = mul_safe(uniforms.f[88].xxxx, reg_tmp2);
    // 159: mad
    reg_tmp8 = fma_safe(reg_tmp3, uniforms.f[88].yyyy, reg_tmp8);
    // 160: mad
    reg_tmp8 = fma_safe(reg_tmp4, uniforms.f[88].zzzz, reg_tmp8);
    // 161: mad
    reg_tmp8 = fma_safe(reg_tmp5, uniforms.f[88].wwww, reg_tmp8);
    // 162: mul
    reg_tmp9 = mul_safe(uniforms.f[89].xxxx, reg_tmp2);
    // 163: mad
    reg_tmp9 = fma_safe(reg_tmp3, uniforms.f[89].yyyy, reg_tmp9);
    // 164: mad
    reg_tmp9 = fma_safe(reg_tmp4, uniforms.f[89].zzzz, reg_tmp9);
    // 165: mad
    reg_tmp9 = fma_safe(reg_tmp5, uniforms.f[89].wwww, reg_tmp9);
    return false;
}
bool sub_167_259() {
    // 167: rcp
    reg_tmp2.x = rcp_safe(uniforms.f[81].yyyy.x);
    // 168: mul
    reg_tmp2.xy = (mul_safe(uniforms.f[2 + address_registers.x].zwww, reg_tmp2.xxxx)).xy;
    // 169: add
    reg_tmp2.xy = (uniforms.f[0].yyyy + reg_tmp2.xyyy).xy;
    // 170: flr
    reg_tmp3.xy = (floor(reg_tmp2.xyyy)).xy;
    // 171: mul
    reg_tmp2.xy = (mul_safe(uniforms.f[81].yyyy, reg_tmp3.xyyy)).xy;
    // 172: add
    reg_tmp2.xy = (uniforms.f[2 + address_registers.x].zwww + -reg_tmp2.xyyy).xy;
    // 173: min
    reg_tmp0.xy = (min(uniforms.f[81].xxxx, -reg_tmp2.xyyy)).xy;
    // 174: max
    reg_tmp0.xy = (max(-uniforms.f[81].xxxx, reg_tmp0.xyyy)).xy;
    // 175: mov
    reg_tmp2 = uniforms.f[95];
    // 176: mov
    reg_tmp3 = uniforms.f[94];
    // 177: mul
    reg_tmp1.z = (mul_safe(reg_tmp0.xxxx, reg_tmp0.xxxx)).z;
    // 178: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 179: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 180: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 181: mov
    reg_tmp2 = uniforms.f[93];
    // 182: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 183: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 184: mul
    reg_tmp1.y = (mul_safe(reg_tmp1.yyyy, reg_tmp0.xxxx)).y;
    // 185: mov
    reg_tmp5.x = (uniforms.f[5 + address_registers.x].wwww).x;
    // 186: mov
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    // 187: mov
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    // 188: cmp
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    // 189: ifc
    if (conditional_code.x) {
        sub_190_192();
    }
    // 192: cmp
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    // 193: ifc
    if (conditional_code.x) {
        sub_194_195();
    }
    // 195: cmp
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 196: ifc
    if (conditional_code.x) {
        sub_197_198();
    }
    // 198: cmp
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 199: ifc
    if (conditional_code.x) {
        sub_200_202();
    }
    // 202: mul
    reg_tmp4.xy = (mul_safe(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    // 203: mad
    reg_tmp4.x = (fma_safe(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    // 204: mad
    reg_tmp4.y = (fma_safe(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    // 205: add
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    // 206: add
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    // 207: mov
    reg_tmp4.z = (uniforms.f[83].xxxx).z;
    // 208: mov
    reg_tmp4.w = (-uniforms.f[83].yyyy).w;
    // 209: madi
    reg_tmp5.xy = (fma_safe(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[3 + address_registers.x].xyyy)).xy;
    // 210: mov
    reg_tmp4.z = (-uniforms.f[3 + address_registers.x].zzzz).z;
    // 211: mov
    reg_tmp4.w = (-uniforms.f[3 + address_registers.x].wwww).w;
    // 212: add
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    // 213: add
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    // 214: mad
    reg_tmp5.x = (fma_safe(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    // 215: mad
    reg_tmp5.y = (fma_safe(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    // 216: mov
    reg_tmp11.xy = (reg_tmp5.xyyy).xy;
    // 217: mov
    reg_tmp2 = uniforms.f[95];
    // 218: mov
    reg_tmp3 = uniforms.f[94];
    // 219: mul
    reg_tmp1.z = (mul_safe(reg_tmp0.yyyy, reg_tmp0.yyyy)).z;
    // 220: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 221: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 222: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 223: mov
    reg_tmp2 = uniforms.f[93];
    // 224: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 225: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 226: mul
    reg_tmp1.y = (mul_safe(reg_tmp1.yyyy, reg_tmp0.yyyy)).y;
    // 227: mov
    reg_tmp5.x = (uniforms.f[6 + address_registers.x].wwww).x;
    // 228: mov
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    // 229: mov
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    // 230: cmp
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    // 231: ifc
    if (conditional_code.x) {
        sub_232_234();
    }
    // 234: cmp
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    // 235: ifc
    if (conditional_code.x) {
        sub_236_237();
    }
    // 237: cmp
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 238: ifc
    if (conditional_code.x) {
        sub_239_240();
    }
    // 240: cmp
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 241: ifc
    if (conditional_code.x) {
        sub_242_244();
    }
    // 244: mul
    reg_tmp4.xy = (mul_safe(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    // 245: mad
    reg_tmp4.x = (fma_safe(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    // 246: mad
    reg_tmp4.y = (fma_safe(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    // 247: add
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    // 248: add
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    // 249: mov
    reg_tmp4.z = (uniforms.f[83].zzzz).z;
    // 250: mov
    reg_tmp4.w = (-uniforms.f[83].wwww).w;
    // 251: madi
    reg_tmp5.xy = (fma_safe(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[4 + address_registers.x].xyyy)).xy;
    // 252: mov
    reg_tmp4.z = (-uniforms.f[4 + address_registers.x].zzzz).z;
    // 253: mov
    reg_tmp4.w = (-uniforms.f[4 + address_registers.x].wwww).w;
    // 254: add
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    // 255: add
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    // 256: mad
    reg_tmp5.x = (fma_safe(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    // 257: mad
    reg_tmp5.y = (fma_safe(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    // 258: mov
    reg_tmp12.xy = (reg_tmp5.xyyy).xy;
    return false;
}
bool sub_190_192() {
    // 190: mov
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    // 191: mov
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_194_195() {
    // 194: mov
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_197_198() {
    // 197: mov
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_200_202() {
    // 200: mov
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    // 201: mov
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_232_234() {
    // 232: mov
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    // 233: mov
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_236_237() {
    // 236: mov
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_239_240() {
    // 239: mov
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_242_244() {
    // 242: mov
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    // 243: mov
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_260_4096() {
    // 260: call
    {
        sub_0_8();
    }
    // 261: add
    reg_tmp10.xy = (uniforms.f[84].xyyy + reg_tmp10.xyyy).xy;
    // 262: mul
    reg_tmp10.xy = (mul_safe(uniforms.f[2 + address_registers.x].xyyy, reg_tmp10.xyyy)).xy;
    // 263: mov
    reg_tmp6 = uniforms.f[8 + address_registers.x];
    // 264: mov
    reg_tmp7 = uniforms.f[9 + address_registers.x];
    // 265: mov
    reg_tmp8 = uniforms.f[10 + address_registers.x];
    // 266: mov
    reg_tmp9 = uniforms.f[0].xxxz;
    // 267: mov
    reg_tmp6.w = (uniforms.f[5 + address_registers.x].xxxx).w;
    // 268: mov
    reg_tmp7.w = (uniforms.f[5 + address_registers.x].yyyy).w;
    // 269: mov
    reg_tmp8.w = (uniforms.f[5 + address_registers.x].zzzz).w;
    // 270: dp4
    reg_tmp2.x = dot(reg_tmp10, reg_tmp6);
    // 271: dp4
    reg_tmp2.y = dot(reg_tmp10, reg_tmp7);
    // 272: dp4
    reg_tmp2.z = dot(reg_tmp10, reg_tmp8);
    // 273: dp4
    reg_tmp2.w = dot(reg_tmp10, reg_tmp9);
    // 274: mov
    reg_tmp10 = reg_tmp2;
    // 275: mov
    reg_tmp3.xyz = (uniforms.f[5 + address_registers.x].xyzz).xyz;
    // 276: add
    reg_tmp3.xyz = (uniforms.f[85].xyzz + -reg_tmp3.xyzz).xyz;
    // 277: dp3
    reg_tmp4.x = dot(vec3(reg_tmp3.xyzz), vec3(reg_tmp3.xyzz));
    // 278: cmp
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
    // 279: ifc
    if (conditional_code.x) {
        sub_280_281();
    } else {
        sub_281_282();
    }
    // 282: mul
    reg_tmp3.xyz = (mul_safe(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
    // 283: mad
    reg_tmp10.xyz = (fma_safe(reg_tmp3.xyzz, uniforms.f[84].zzzz, reg_tmp10.xyzz)).xyz;
    // 284: call
    {
        sub_146_166();
    }
    // 285: mov
    reg_tmp2 = reg_tmp10;
    // 286: dp4
    reg_tmp10.x = dot(reg_tmp2, reg_tmp6);
    // 287: dp4
    reg_tmp10.y = dot(reg_tmp2, reg_tmp7);
    // 288: dp4
    reg_tmp10.z = dot(reg_tmp2, reg_tmp8);
    // 289: dp4
    reg_tmp10.w = dot(reg_tmp2, reg_tmp9);
    // 290: mov
    reg_tmp2 = uniforms.f[1 + address_registers.x];
    // 291: max
    reg_tmp3 = max(uniforms.f[0].xxxx, reg_tmp2);
    // 292: min
    reg_tmp2 = min(uniforms.f[0].zzzz, reg_tmp3);
    // 293: mov
    reg_tmp13 = reg_tmp2;
    // 294: call
    {
        sub_167_259();
    }
    // 295: call
    {
        sub_9_32();
    }
    // 296: end
    return true;
}
bool sub_280_281() {
    // 280: mov
    reg_tmp4.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_281_282() {
    // 281: rsq
    reg_tmp4.x = rsq_safe(reg_tmp4.xxxx.x);
    return false;
}
// reference: B25B901BEA0C3654, FDCB6921459E149F
// program: FDCB6921459E149F, CEF02063E9A18B2F, ED9AAA1E39CE1504
// reference: 05C50527084DB0B5, D82E12A9D19ACD63
// reference: 612ADADB43E4852C, B8A2CA3DB47999BF
// reference: EACA0D749A2F869E, B8A2CA3DB47999BF
// reference: 30A31DACE34B824E, 5447A3297E824FE0
// reference: BB43CA033A8081FC, 5447A3297E824FE0
// reference: C2571AEAFCD95FFB, B543C911C8D7EAAB
// reference: A1898FFA7D3BCDCB, B8A2CA3DB47999BF
// reference: 2A69585524949DFA, B8A2CA3DB47999BF
// reference: 4E8687A9B32C193C, D82E12A9D19ACD63
// reference: AE685B3A8D92D061, DEFAC6F185DB6EB9
// reference: 44945D27700B0BD5, 1BE8D5DEECF8172C
// program: 1BE8D5DEECF8172C, CEF02063E9A18B2F, ED9AAA1E39CE1504
// reference: F30AC81B924A8D34, D82E12A9D19ACD63
// reference: 97E517E7D9E3B8AD, B8A2CA3DB47999BF
// reference: 1C05C0480028BB1F, B8A2CA3DB47999BF
// reference: 1B9140809BFA51BA, 5447A3297E824FE0
// reference: 9071972F42315208, 5447A3297E824FE0
// reference: 6ADA9833FCD95FFB, B543C911C8D7EAAB
// reference: 09040D237D3BCDCB, B8A2CA3DB47999BF
// reference: 82E4DA8C24949DFA, B8A2CA3DB47999BF
// reference: E60B0570B32C193C, D82E12A9D19ACD63
// reference: 06E5D9E38D92D061, DEFAC6F185DB6EB9
// reference: 2983DF178EC65845, 734B56B7CFCD3D95
// reference: B25B901BC880E88B, FDCB6921459E149F
// shader: 8B31, 306D0F33E4D14FB9

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define fma_safe(x, y, z) fma(x, y, z)
#define mul_safe(x, y) (x * y)
#define rcp_safe(x) (1.0f / x)
#define rsq_safe(x) inversesqrt(x)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_8();
bool sub_9_32();
bool sub_33_96();
bool sub_146_166();
bool sub_167_259();
bool sub_190_192();
bool sub_194_195();
bool sub_197_198();
bool sub_200_202();
bool sub_232_234();
bool sub_236_237();
bool sub_239_240();
bool sub_242_244();
bool sub_260_4096();
bool sub_277_278();
bool sub_278_279();
bool sub_285_286();
bool sub_286_287();
bool sub_312_313();
bool sub_313_314();

bool exec_shader() {
    sub_260_4096();
    return true;
}

bool sub_0_8() {
    // 0: mova
    address_registers.x = (ivec2(vs_in_reg0.zzzz)).x;
    // 1: mov
    reg_tmp10 = uniforms.f[0].xxxz;
    // 2: mov
    reg_tmp10.xy = (vs_in_reg0.xyyy).xy;
    // 3: mov
    reg_tmp11 = uniforms.f[0].xxxx;
    // 4: mov
    reg_tmp12 = uniforms.f[0].xxxx;
    // 5: mov
    reg_tmp13 = uniforms.f[0].zzzz;
    // 6: mov
    reg_tmp4 = uniforms.f[0].xxxx;
    // 7: mov
    reg_tmp5 = uniforms.f[0].xxxx;
    return false;
}
bool sub_9_32() {
    // 9: mov
    vs_out_attr0 = reg_tmp10;
    // 10: mul
    reg_tmp13 = mul_safe(uniforms.f[82], reg_tmp13);
    // 11: mov
    vs_out_attr1 = reg_tmp13;
    // 12: add
    reg_tmp11.y = (uniforms.f[0].zzzz + -reg_tmp11.yyyy).y;
    // 13: add
    reg_tmp12.y = (uniforms.f[0].zzzz + -reg_tmp12.yyyy).y;
    // 14: mov
    reg_tmp14.y = (uniforms.f[81].wwww).y;
    // 15: mul
    reg_tmp14.x = (mul_safe(uniforms.f[0].wwww, reg_tmp14.yyyy)).x;
    // 16: rcp
    reg_tmp2.x = rcp_safe(reg_tmp14.xxxx.x);
    // 17: mov
    reg_tmp14.z = (reg_tmp2.xxxx).z;
    // 18: add
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp11.xyyy).xy;
    // 19: mul
    reg_tmp5.xy = (mul_safe(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    // 20: flr
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    // 21: mul
    reg_tmp4.xy = (mul_safe(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    // 22: add
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    // 23: add
    reg_tmp11.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    // 24: add
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp12.xyyy).xy;
    // 25: mul
    reg_tmp5.xy = (mul_safe(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    // 26: flr
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    // 27: mul
    reg_tmp4.xy = (mul_safe(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    // 28: add
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    // 29: add
    reg_tmp12.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    // 30: mov
    vs_out_attr2 = reg_tmp11;
    // 31: mov
    vs_out_attr3 = reg_tmp12;
    return false;
}
bool sub_33_96() {
    // 33: mov
    reg_tmp6.xyz = (-reg_tmp0.xyzz).xyz;
    // 34: mov
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    // 35: rcp
    reg_tmp7.xyz = vec3(rcp_safe(uniforms.f[81].yyyy.x));
    // 36: madi
    reg_tmp8.xyz = (fma_safe(reg_tmp6.xyzz, reg_tmp7.xyzz, uniforms.f[0].yyyy)).xyz;
    // 37: flr
    reg_tmp7.xyz = (floor(reg_tmp8.xyzz)).xyz;
    // 38: mad
    reg_tmp6.xyz = (fma_safe(reg_tmp7.xyzz, -uniforms.f[81].yyyy, reg_tmp6.xyzz)).xyz;
    // 39: min
    reg_tmp6 = min(uniforms.f[81].xxxx, reg_tmp6);
    // 40: max
    reg_tmp6 = max(-uniforms.f[81].xxxx, reg_tmp6);
    // 41: mov
    reg_tmp2 = uniforms.f[95];
    // 42: mov
    reg_tmp3 = uniforms.f[94];
    // 43: mul
    reg_tmp1.z = (mul_safe(reg_tmp6.xxxx, reg_tmp6.xxxx)).z;
    // 44: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 45: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 46: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 47: mov
    reg_tmp2 = uniforms.f[93];
    // 48: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 49: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 50: mul
    reg_tmp1.y = (mul_safe(reg_tmp1.yyyy, reg_tmp6.xxxx)).y;
    // 51: mov
    reg_tmp4.x = (reg_tmp1.xxxx).x;
    // 52: mov
    reg_tmp5.x = (reg_tmp1.yyyy).x;
    // 53: mov
    reg_tmp2 = uniforms.f[95];
    // 54: mov
    reg_tmp3 = uniforms.f[94];
    // 55: mul
    reg_tmp1.z = (mul_safe(reg_tmp6.yyyy, reg_tmp6.yyyy)).z;
    // 56: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 57: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 58: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 59: mov
    reg_tmp2 = uniforms.f[93];
    // 60: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 61: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 62: mul
    reg_tmp1.y = (mul_safe(reg_tmp1.yyyy, reg_tmp6.yyyy)).y;
    // 63: mov
    reg_tmp4.y = (reg_tmp1.xxxx).y;
    // 64: mov
    reg_tmp5.y = (reg_tmp1.yyyy).y;
    // 65: mov
    reg_tmp2 = uniforms.f[95];
    // 66: mov
    reg_tmp3 = uniforms.f[94];
    // 67: mul
    reg_tmp1.z = (mul_safe(reg_tmp6.zzzz, reg_tmp6.zzzz)).z;
    // 68: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 69: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 70: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 71: mov
    reg_tmp2 = uniforms.f[93];
    // 72: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 73: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 74: mul
    reg_tmp1.y = (mul_safe(reg_tmp1.yyyy, reg_tmp6.zzzz)).y;
    // 75: mov
    reg_tmp4.z = (reg_tmp1.xxxx).z;
    // 76: mov
    reg_tmp5.z = (reg_tmp1.yyyy).z;
    // 77: mul
    reg_tmp2.x = (mul_safe(reg_tmp4.yyyy, reg_tmp5.zzzz)).x;
    // 78: mul
    reg_tmp2.y = (mul_safe(reg_tmp5.yyyy, reg_tmp5.zzzz)).y;
    // 79: mul
    reg_tmp6.x = (mul_safe(reg_tmp4.yyyy, reg_tmp4.zzzz)).x;
    // 80: mov
    reg_tmp6.y = (reg_tmp5.zzzz).y;
    // 81: mul
    reg_tmp6.z = (mul_safe(-reg_tmp5.yyyy, reg_tmp4.zzzz)).z;
    // 82: mov
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    // 83: mul
    reg_tmp7.x = (mul_safe(-reg_tmp2.xxxx, reg_tmp4.xxxx)).x;
    // 84: mad
    reg_tmp7.x = (fma_safe(reg_tmp5.yyyy, reg_tmp5.xxxx, reg_tmp7.xxxx)).x;
    // 85: mul
    reg_tmp7.y = (mul_safe(reg_tmp4.zzzz, reg_tmp4.xxxx)).y;
    // 86: mul
    reg_tmp7.z = (mul_safe(reg_tmp2.yyyy, reg_tmp4.xxxx)).z;
    // 87: mad
    reg_tmp7.z = (fma_safe(reg_tmp4.yyyy, reg_tmp5.xxxx, reg_tmp7.zzzz)).z;
    // 88: mov
    reg_tmp7.w = (uniforms.f[0].xxxx).w;
    // 89: mul
    reg_tmp8.x = (mul_safe(reg_tmp2.xxxx, reg_tmp5.xxxx)).x;
    // 90: mad
    reg_tmp8.x = (fma_safe(reg_tmp5.yyyy, reg_tmp4.xxxx, reg_tmp8.xxxx)).x;
    // 91: mul
    reg_tmp8.y = (mul_safe(-reg_tmp4.zzzz, reg_tmp5.xxxx)).y;
    // 92: mul
    reg_tmp8.z = (mul_safe(-reg_tmp2.yyyy, reg_tmp5.xxxx)).z;
    // 93: mad
    reg_tmp8.z = (fma_safe(reg_tmp4.yyyy, reg_tmp4.xxxx, reg_tmp8.zzzz)).z;
    // 94: mov
    reg_tmp8.w = (uniforms.f[0].xxxx).w;
    // 95: mov
    reg_tmp9 = uniforms.f[0].xxxz;
    return false;
}
bool sub_146_166() {
    // 146: mov
    reg_tmp2 = uniforms.f[90];
    // 147: mov
    reg_tmp3 = uniforms.f[91];
    // 148: mov
    reg_tmp4 = uniforms.f[92];
    // 149: mov
    reg_tmp5 = uniforms.f[0].xxxz;
    // 150: mul
    reg_tmp6 = mul_safe(uniforms.f[86].xxxx, reg_tmp2);
    // 151: mad
    reg_tmp6 = fma_safe(reg_tmp3, uniforms.f[86].yyyy, reg_tmp6);
    // 152: mad
    reg_tmp6 = fma_safe(reg_tmp4, uniforms.f[86].zzzz, reg_tmp6);
    // 153: mad
    reg_tmp6 = fma_safe(reg_tmp5, uniforms.f[86].wwww, reg_tmp6);
    // 154: mul
    reg_tmp7 = mul_safe(uniforms.f[87].xxxx, reg_tmp2);
    // 155: mad
    reg_tmp7 = fma_safe(reg_tmp3, uniforms.f[87].yyyy, reg_tmp7);
    // 156: mad
    reg_tmp7 = fma_safe(reg_tmp4, uniforms.f[87].zzzz, reg_tmp7);
    // 157: mad
    reg_tmp7 = fma_safe(reg_tmp5, uniforms.f[87].wwww, reg_tmp7);
    // 158: mul
    reg_tmp8 = mul_safe(uniforms.f[88].xxxx, reg_tmp2);
    // 159: mad
    reg_tmp8 = fma_safe(reg_tmp3, uniforms.f[88].yyyy, reg_tmp8);
    // 160: mad
    reg_tmp8 = fma_safe(reg_tmp4, uniforms.f[88].zzzz, reg_tmp8);
    // 161: mad
    reg_tmp8 = fma_safe(reg_tmp5, uniforms.f[88].wwww, reg_tmp8);
    // 162: mul
    reg_tmp9 = mul_safe(uniforms.f[89].xxxx, reg_tmp2);
    // 163: mad
    reg_tmp9 = fma_safe(reg_tmp3, uniforms.f[89].yyyy, reg_tmp9);
    // 164: mad
    reg_tmp9 = fma_safe(reg_tmp4, uniforms.f[89].zzzz, reg_tmp9);
    // 165: mad
    reg_tmp9 = fma_safe(reg_tmp5, uniforms.f[89].wwww, reg_tmp9);
    return false;
}
bool sub_167_259() {
    // 167: rcp
    reg_tmp2.x = rcp_safe(uniforms.f[81].yyyy.x);
    // 168: mul
    reg_tmp2.xy = (mul_safe(uniforms.f[2 + address_registers.x].zwww, reg_tmp2.xxxx)).xy;
    // 169: add
    reg_tmp2.xy = (uniforms.f[0].yyyy + reg_tmp2.xyyy).xy;
    // 170: flr
    reg_tmp3.xy = (floor(reg_tmp2.xyyy)).xy;
    // 171: mul
    reg_tmp2.xy = (mul_safe(uniforms.f[81].yyyy, reg_tmp3.xyyy)).xy;
    // 172: add
    reg_tmp2.xy = (uniforms.f[2 + address_registers.x].zwww + -reg_tmp2.xyyy).xy;
    // 173: min
    reg_tmp0.xy = (min(uniforms.f[81].xxxx, -reg_tmp2.xyyy)).xy;
    // 174: max
    reg_tmp0.xy = (max(-uniforms.f[81].xxxx, reg_tmp0.xyyy)).xy;
    // 175: mov
    reg_tmp2 = uniforms.f[95];
    // 176: mov
    reg_tmp3 = uniforms.f[94];
    // 177: mul
    reg_tmp1.z = (mul_safe(reg_tmp0.xxxx, reg_tmp0.xxxx)).z;
    // 178: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 179: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 180: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 181: mov
    reg_tmp2 = uniforms.f[93];
    // 182: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 183: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 184: mul
    reg_tmp1.y = (mul_safe(reg_tmp1.yyyy, reg_tmp0.xxxx)).y;
    // 185: mov
    reg_tmp5.x = (uniforms.f[5 + address_registers.x].wwww).x;
    // 186: mov
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    // 187: mov
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    // 188: cmp
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    // 189: ifc
    if (conditional_code.x) {
        sub_190_192();
    }
    // 192: cmp
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    // 193: ifc
    if (conditional_code.x) {
        sub_194_195();
    }
    // 195: cmp
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 196: ifc
    if (conditional_code.x) {
        sub_197_198();
    }
    // 198: cmp
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 199: ifc
    if (conditional_code.x) {
        sub_200_202();
    }
    // 202: mul
    reg_tmp4.xy = (mul_safe(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    // 203: mad
    reg_tmp4.x = (fma_safe(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    // 204: mad
    reg_tmp4.y = (fma_safe(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    // 205: add
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    // 206: add
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    // 207: mov
    reg_tmp4.z = (uniforms.f[83].xxxx).z;
    // 208: mov
    reg_tmp4.w = (-uniforms.f[83].yyyy).w;
    // 209: madi
    reg_tmp5.xy = (fma_safe(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[3 + address_registers.x].xyyy)).xy;
    // 210: mov
    reg_tmp4.z = (-uniforms.f[3 + address_registers.x].zzzz).z;
    // 211: mov
    reg_tmp4.w = (-uniforms.f[3 + address_registers.x].wwww).w;
    // 212: add
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    // 213: add
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    // 214: mad
    reg_tmp5.x = (fma_safe(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    // 215: mad
    reg_tmp5.y = (fma_safe(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    // 216: mov
    reg_tmp11.xy = (reg_tmp5.xyyy).xy;
    // 217: mov
    reg_tmp2 = uniforms.f[95];
    // 218: mov
    reg_tmp3 = uniforms.f[94];
    // 219: mul
    reg_tmp1.z = (mul_safe(reg_tmp0.yyyy, reg_tmp0.yyyy)).z;
    // 220: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 221: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 222: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 223: mov
    reg_tmp2 = uniforms.f[93];
    // 224: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 225: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 226: mul
    reg_tmp1.y = (mul_safe(reg_tmp1.yyyy, reg_tmp0.yyyy)).y;
    // 227: mov
    reg_tmp5.x = (uniforms.f[6 + address_registers.x].wwww).x;
    // 228: mov
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    // 229: mov
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    // 230: cmp
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    // 231: ifc
    if (conditional_code.x) {
        sub_232_234();
    }
    // 234: cmp
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    // 235: ifc
    if (conditional_code.x) {
        sub_236_237();
    }
    // 237: cmp
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 238: ifc
    if (conditional_code.x) {
        sub_239_240();
    }
    // 240: cmp
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 241: ifc
    if (conditional_code.x) {
        sub_242_244();
    }
    // 244: mul
    reg_tmp4.xy = (mul_safe(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    // 245: mad
    reg_tmp4.x = (fma_safe(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    // 246: mad
    reg_tmp4.y = (fma_safe(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    // 247: add
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    // 248: add
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    // 249: mov
    reg_tmp4.z = (uniforms.f[83].zzzz).z;
    // 250: mov
    reg_tmp4.w = (-uniforms.f[83].wwww).w;
    // 251: madi
    reg_tmp5.xy = (fma_safe(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[4 + address_registers.x].xyyy)).xy;
    // 252: mov
    reg_tmp4.z = (-uniforms.f[4 + address_registers.x].zzzz).z;
    // 253: mov
    reg_tmp4.w = (-uniforms.f[4 + address_registers.x].wwww).w;
    // 254: add
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    // 255: add
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    // 256: mad
    reg_tmp5.x = (fma_safe(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    // 257: mad
    reg_tmp5.y = (fma_safe(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    // 258: mov
    reg_tmp12.xy = (reg_tmp5.xyyy).xy;
    return false;
}
bool sub_190_192() {
    // 190: mov
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    // 191: mov
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_194_195() {
    // 194: mov
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_197_198() {
    // 197: mov
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_200_202() {
    // 200: mov
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    // 201: mov
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_232_234() {
    // 232: mov
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    // 233: mov
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_236_237() {
    // 236: mov
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_239_240() {
    // 239: mov
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_242_244() {
    // 242: mov
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    // 243: mov
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_260_4096() {
    // 260: call
    {
        sub_0_8();
    }
    // 261: add
    reg_tmp10.xy = (uniforms.f[84].xyyy + reg_tmp10.xyyy).xy;
    // 262: mul
    reg_tmp10.xy = (mul_safe(uniforms.f[2 + address_registers.x].xyyy, reg_tmp10.xyyy)).xy;
    // 263: mov
    reg_tmp14 = reg_tmp10;
    // 264: mov
    reg_tmp0 = uniforms.f[7 + address_registers.x];
    // 265: call
    {
        sub_33_96();
    }
    // 266: dp4
    reg_tmp10.x = dot(reg_tmp14, reg_tmp6);
    // 267: dp4
    reg_tmp10.y = dot(reg_tmp14, reg_tmp7);
    // 268: dp4
    reg_tmp10.z = dot(reg_tmp14, reg_tmp8);
    // 269: dp4
    reg_tmp10.w = dot(reg_tmp14, reg_tmp9);
    // 270: mov
    reg_tmp2.x = (uniforms.f[8 + address_registers.x].yyyy).x;
    // 271: mov
    reg_tmp2.y = (uniforms.f[9 + address_registers.x].yyyy).y;
    // 272: mov
    reg_tmp2.z = (uniforms.f[10 + address_registers.x].yyyy).z;
    // 273: mov
    reg_tmp3.xyz = (uniforms.f[6 + address_registers.x].xyzz).xyz;
    // 274: dp3
    reg_tmp4.x = dot(vec3(reg_tmp3.xyzz), vec3(reg_tmp3.xyzz));
    // 275: cmp
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
    // 276: ifc
    if (conditional_code.x) {
        sub_277_278();
    } else {
        sub_278_279();
    }
    // 279: mul
    reg_tmp3.xyz = (mul_safe(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
    // 280: mul
    reg_tmp4.xyz = (mul_safe(reg_tmp3.yzxx, reg_tmp2.zxyy)).xyz;
    // 281: mad
    reg_tmp4.xyz = (fma_safe(-reg_tmp2.yzxx, reg_tmp3.zxyy, reg_tmp4)).xyz;
    // 282: dp3
    reg_tmp5.x = dot(vec3(reg_tmp4.xyzz), vec3(reg_tmp4.xyzz));
    // 283: cmp
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp5.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp5.y;
    // 284: ifc
    if (conditional_code.x) {
        sub_285_286();
    } else {
        sub_286_287();
    }
    // 287: mul
    reg_tmp4.xyz = (mul_safe(reg_tmp4.xyzz, reg_tmp5.xxxx)).xyz;
    // 288: mul
    reg_tmp5.xyz = (mul_safe(reg_tmp3.yzxx, reg_tmp4.zxyy)).xyz;
    // 289: mad
    reg_tmp5.xyz = (fma_safe(-reg_tmp4.yzxx, reg_tmp3.zxyy, reg_tmp5)).xyz;
    // 290: mov
    reg_tmp6.x = (reg_tmp4.xxxx).x;
    // 291: mov
    reg_tmp6.y = (reg_tmp3.xxxx).y;
    // 292: mov
    reg_tmp6.z = (reg_tmp5.xxxx).z;
    // 293: mov
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    // 294: mov
    reg_tmp7.x = (reg_tmp4.yyyy).x;
    // 295: mov
    reg_tmp7.y = (reg_tmp3.yyyy).y;
    // 296: mov
    reg_tmp7.z = (reg_tmp5.yyyy).z;
    // 297: mov
    reg_tmp7.w = (uniforms.f[0].xxxx).w;
    // 298: mov
    reg_tmp8.x = (reg_tmp4.zzzz).x;
    // 299: mov
    reg_tmp8.y = (reg_tmp3.zzzz).y;
    // 300: mov
    reg_tmp8.z = (reg_tmp5.zzzz).z;
    // 301: mov
    reg_tmp8.w = (uniforms.f[0].xxxx).w;
    // 302: mov
    reg_tmp9 = uniforms.f[0].xxxz;
    // 303: dp4
    reg_tmp2.x = dot(reg_tmp10, reg_tmp6);
    // 304: dp4
    reg_tmp2.y = dot(reg_tmp10, reg_tmp7);
    // 305: dp4
    reg_tmp2.z = dot(reg_tmp10, reg_tmp8);
    // 306: dp4
    reg_tmp2.w = dot(reg_tmp10, reg_tmp9);
    // 307: mov
    reg_tmp3.xyz = (uniforms.f[5 + address_registers.x].xyzz).xyz;
    // 308: add
    reg_tmp3.xyz = (uniforms.f[85].xyzz + -reg_tmp3.xyzz).xyz;
    // 309: dp3
    reg_tmp4.x = dot(vec3(reg_tmp3.xyzz), vec3(reg_tmp3.xyzz));
    // 310: cmp
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
    // 311: ifc
    if (conditional_code.x) {
        sub_312_313();
    } else {
        sub_313_314();
    }
    // 314: mul
    reg_tmp3.xyz = (mul_safe(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
    // 315: add
    reg_tmp10.xyz = (uniforms.f[5 + address_registers.x].xyzz + reg_tmp2.xyzz).xyz;
    // 316: mad
    reg_tmp10.xyz = (fma_safe(reg_tmp3.xyzz, uniforms.f[84].zzzz, reg_tmp10.xyzz)).xyz;
    // 317: call
    {
        sub_146_166();
    }
    // 318: mov
    reg_tmp2 = reg_tmp10;
    // 319: dp4
    reg_tmp10.x = dot(reg_tmp2, reg_tmp6);
    // 320: dp4
    reg_tmp10.y = dot(reg_tmp2, reg_tmp7);
    // 321: dp4
    reg_tmp10.z = dot(reg_tmp2, reg_tmp8);
    // 322: dp4
    reg_tmp10.w = dot(reg_tmp2, reg_tmp9);
    // 323: mov
    reg_tmp2 = uniforms.f[1 + address_registers.x];
    // 324: max
    reg_tmp3 = max(uniforms.f[0].xxxx, reg_tmp2);
    // 325: min
    reg_tmp2 = min(uniforms.f[0].zzzz, reg_tmp3);
    // 326: mov
    reg_tmp13 = reg_tmp2;
    // 327: call
    {
        sub_167_259();
    }
    // 328: call
    {
        sub_9_32();
    }
    // 329: end
    return true;
}
bool sub_277_278() {
    // 277: mov
    reg_tmp4.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_278_279() {
    // 278: rsq
    reg_tmp4.x = rsq_safe(reg_tmp4.xxxx.x);
    return false;
}
bool sub_285_286() {
    // 285: mov
    reg_tmp5.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_286_287() {
    // 286: rsq
    reg_tmp5.x = rsq_safe(reg_tmp5.xxxx.x);
    return false;
}
bool sub_312_313() {
    // 312: mov
    reg_tmp4.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_313_314() {
    // 313: rsq
    reg_tmp4.x = rsq_safe(reg_tmp4.xxxx.x);
    return false;
}
// reference: BE5DB9B37D75EA4C, 306D0F33E4D14FB9
// program: 306D0F33E4D14FB9, CEF02063E9A18B2F, 931705B2EA3991A9
// reference: 09C32C8F9F346CAD, D82E12A9D19ACD63
// reference: 6D2CF373D49D5934, B8A2CA3DB47999BF
// reference: E6CC24DC0D565A86, B8A2CA3DB47999BF
// reference: 2099A4A2F1F4980F, 5447A3297E824FE0
// reference: AB79730D283F9BBD, 5447A3297E824FE0
// reference: 51D27C11FCD95FFB, B543C911C8D7EAAB
// reference: 320CE9017D3BCDCB, B8A2CA3DB47999BF
// reference: B9EC3EAE24949DFA, B8A2CA3DB47999BF
// reference: DD03E152B32C193C, D82E12A9D19ACD63
// reference: 3DED3DC18D92D061, DEFAC6F185DB6EB9
// reference: 85555D917D75EA4C, 306D0F33E4D14FB9
// reference: 32CBC8AD9F346CAD, D82E12A9D19ACD63
// reference: 56241751D49D5934, B8A2CA3DB47999BF
// reference: DDC4C0FE0D565A86, B8A2CA3DB47999BF
// reference: 1B914080F1F4980F, 5447A3297E824FE0
// reference: 9071972F283F9BBD, 5447A3297E824FE0
// reference: B92B1F0246FF6F1F, D82E12A9D19ACD63
// reference: 88797DD67D75EA4C, 306D0F33E4D14FB9
// reference: 3FE7E8EA9F346CAD, D82E12A9D19ACD63
// reference: 5B083716D49D5934, B8A2CA3DB47999BF
// reference: D0E8E0B90D565A86, B8A2CA3DB47999BF
// reference: B4073F4546FF6F1F, D82E12A9D19ACD63
// reference: 16BD60C7F1F4980F, 5447A3297E824FE0
// reference: 9D5DB768283F9BBD, 5447A3297E824FE0
// reference: 67F6B874FCD95FFB, B543C911C8D7EAAB
// reference: 04282D647D3BCDCB, B8A2CA3DB47999BF
// reference: 8FC8FACB24949DFA, B8A2CA3DB47999BF
// reference: EB272537B32C193C, D82E12A9D19ACD63
// reference: 0BC9F9A48D92D061, DEFAC6F185DB6EB9
// reference: F8D6F633E372F705, 48B3A6FBA8498826
// shader: 8B30, 98B9CBCC0C24F17B

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor2.rrr) * (rounded_primary_color.rrr), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) + (const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor2.ggg) * (rounded_primary_color.ggg) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor2.bbb) * (rounded_primary_color.bbb) + (last_tex_env_out.bbb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: DF5F82DE00C5EB06, 98B9CBCC0C24F17B
// program: 48B3A6FBA8498826, AD7922A63ED54CA7, 98B9CBCC0C24F17B
// reference: DC72B3DBE0730DB5, 65138AC5CA635BBF
// shader: 8B30, F1B79BC02FD8ECBB

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor1.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (textureProj(tex0, vec3(texcoord0, texcoord0_w)).a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1 * 2.0, alpha_output_1 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: EBFF2ABD958A4F2A, F1B79BC02FD8ECBB
// program: 65138AC5CA635BBF, 3B3AE026C742C7D5, F1B79BC02FD8ECBB
// shader: 8B30, E80EAA640B16C3C9

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor2.rrr) * (rounded_primary_color.rrr), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (textureProj(tex0, vec3(texcoord0, texcoord0_w)).a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor2.ggg) * (rounded_primary_color.ggg) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor2.bbb) * (rounded_primary_color.bbb) + (last_tex_env_out.bbb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 063AD0A430C8CE51, E80EAA640B16C3C9
// program: 48B3A6FBA8498826, AD7922A63ED54CA7, E80EAA640B16C3C9
// reference: DB46CBBF0E1D561B, 0C4FAE4D08C76925
// reference: C8D329F32CA707EF, D82E12A9D19ACD63
// shader: 8B30, 3AB56B96DC7B73E5

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor0.rgb) * (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor0.a) + (const_color[2].a) - 0.5, 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2 * 1.0, alpha_output_2 * 2.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (last_tex_env_out.aaa), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) * (last_tex_env_out.aaa) + (texcolor0.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4 * 1.0, alpha_output_4 * 4.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 4951D2BAEA3E4ED6, 3AB56B96DC7B73E5
// program: D82E12A9D19ACD63, 5D764F9A6220D694, 3AB56B96DC7B73E5
// shader: 8B30, C102EF64F4A32F93

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor0.rgb) * (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor0.a) + (const_color[2].a) - 0.5, 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2 * 1.0, alpha_output_2 * 2.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (last_tex_env_out.aaa), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) * (last_tex_env_out.aaa) + (texcolor0.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4 * 1.0, alpha_output_4 * 4.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: C4ECD0A47590FED4, C102EF64F4A32F93
// program: D82E12A9D19ACD63, 5D764F9A6220D694, C102EF64F4A32F93
// reference: 9ADC2096D49CB0E7, DEFAC6F185DB6EB9
// shader: 8B30, C7ABA51961F09A56

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) + (vec3(1.0) - const_color[0].rrr), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: C028D730329080AB, C7ABA51961F09A56
// program: DEFAC6F185DB6EB9, 6CF3F3B70E23AA85, C7ABA51961F09A56
// shader: 8B30, 1E0170BE21B1AF6B

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((vec3(1.0) - const_color[0].rrr) + (vec3(1.0) - texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: A6C86C7C4783FB9C, 1E0170BE21B1AF6B
// program: DEFAC6F185DB6EB9, 6CF3F3B70E23AA85, 1E0170BE21B1AF6B
// shader: 8B30, 69452BAC839E6819

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (texcolor1.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) + (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: A70D0AE49AF155CE, 69452BAC839E6819
// program: 65138AC5CA635BBF, 3B3AE026C742C7D5, 69452BAC839E6819
// reference: A70D0AE421C4AFDC, 69452BAC839E6819
// shader: 8B30, BE4C56FFB541C62D

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (texcolor0.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 9D48A5FD7BFC06FE, BE4C56FFB541C62D
// program: DEFAC6F185DB6EB9, 6CF3F3B70E23AA85, BE4C56FFB541C62D
// shader: 8B30, C59EA4758EB9FB8A

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 10807477801C7747, C59EA4758EB9FB8A
// program: DEFAC6F185DB6EB9, 6CF3F3B70E23AA85, C59EA4758EB9FB8A
// reference: B4699F7F891C2F9B, D82E12A9D19ACD63
// reference: DB973FC8FD1843F3, 00D74B8E7C815129
// shader: 8B30, 20A72E97AF8E39F2

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 91FAAA1820EEEA14, 20A72E97AF8E39F2
// program: DEFAC6F185DB6EB9, 6CF3F3B70E23AA85, 20A72E97AF8E39F2
// shader: 8B30, 79AE694A7B008028

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a) * (texcolor0.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D846B11CDB0E9BAD, 79AE694A7B008028
// program: DEFAC6F185DB6EB9, 6CF3F3B70E23AA85, 79AE694A7B008028
// reference: D4F4BEF9EF66294C, 20A72E97AF8E39F2
// shader: 8B30, AAEB40CB76CC69C8

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor0.rgb) * (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor0.a) + (const_color[2].a) - 0.5, 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2 * 1.0, alpha_output_2 * 2.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (last_tex_env_out.aaa), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) * (last_tex_env_out.aaa) + (texcolor0.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4 * 1.0, alpha_output_4 * 4.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb) + (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: E66E6CB838B47116, AAEB40CB76CC69C8
// program: D82E12A9D19ACD63, 5D764F9A6220D694, AAEB40CB76CC69C8
// reference: 11992A6F51C47A28, 3F3EC97B868B23C2
// shader: 8B30, E7FBEA02DF3E94C7

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor1.aaa) * (const_color[0].rgb) + (texcolor1.aaa), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (last_tex_env_out.rgb) + (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((const_color[1].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rrr) * (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((const_color[2].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_3 = byteround(clamp((combiner_buffer.ggg) * (const_color[3].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_4 = byteround(clamp((combiner_buffer.bbb) * (const_color[4].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((texcolor2.rgb) * (const_color[5].rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (const_color[5].rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((const_color[5].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 0D7DFD1BBD31297B, E7FBEA02DF3E94C7
// program: B8A2CA3DB47999BF, 5D764F9A6220D694, E7FBEA02DF3E94C7
// shader: 8B30, 05CFD75FDB2A58E7

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor2.rrr) * (rounded_primary_color.rrr), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) + (const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor2.ggg) * (rounded_primary_color.ggg) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor2.bbb) * (rounded_primary_color.bbb) + (last_tex_env_out.bbb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (vec3(1.0) - textureProj(tex0, vec3(texcoord0, texcoord0_w)).rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: B4644F147ED90A59, 05CFD75FDB2A58E7
// program: 48B3A6FBA8498826, AD7922A63ED54CA7, 05CFD75FDB2A58E7
// shader: 8B30, F2D13A2700B9A3BE

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (const_color[1].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 1E0FE35528BB8D45, F2D13A2700B9A3BE
// program: DEFAC6F185DB6EB9, 6CF3F3B70E23AA85, F2D13A2700B9A3BE
// reference: CEEB3D0B8729D1F6, B8A2CA3DB47999BF
// reference: 450BEAA4DE8681C7, B8A2CA3DB47999BF
// reference: 21E43558493E0501, D82E12A9D19ACD63
// reference: 21E43558C95A5682, D82E12A9D19ACD63
// reference: F0D766142331DED1, DEFAC6F185DB6EB9
// shader: 8B30, 63E778B1E6285564

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[0].specular_0) + ((lut_scale_d1 * LookupLightingLUTUnsigned(1, max(dot(normal, normalize(view)), 0.0))) * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb) * (texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (texcolor1.aaa) + (texcolor2.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3 * 2.0, alpha_output_3 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((secondary_fragment_color.rgb) * (texcolor1.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (vec3(1.0) - textureProj(tex0, vec3(texcoord0, texcoord0_w)).rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 8788CBD83C0E1A85, 63E778B1E6285564
// program: C686B1FD59F65802, AD7922A63ED54CA7, 63E778B1E6285564
// shader: 8B30, 61AA2643D3723F4A

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(view)), 0.0))) * light_src[0].specular_0) + ((lut_scale_d1 * LookupLightingLUTUnsigned(1, max(dot(normal, normalize(view)), 0.0))) * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor1.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (textureProj(tex0, vec3(texcoord0, texcoord0_w)).a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((primary_fragment_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2 * 2.0, alpha_output_2 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((secondary_fragment_color.rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) * (vec3(1.0) - textureProj(tex0, vec3(texcoord0, texcoord0_w)).rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: C909CE40BB0704F8, 61AA2643D3723F4A
// program: C686B1FD59F65802, AD7922A63ED54CA7, 61AA2643D3723F4A
// reference: E4D725C87ED90A59, 05CFD75FDB2A58E7
// reference: 0035822028BB8D45, F2D13A2700B9A3BE
// shader: 8B30, 163CE5AA2AAAB87B

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (const_color[1].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a) * (const_color[5].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: DD3BEAE2A43CF78C, 163CE5AA2AAAB87B
// program: DEFAC6F185DB6EB9, 6CF3F3B70E23AA85, 163CE5AA2AAAB87B
// reference: D57593945DD83B12, 43A7C75AE8CBEC18
// reference: 5086E8FC28BB8D45, F2D13A2700B9A3BE
// reference: B442E187A43CF78C, 163CE5AA2AAAB87B
// reference: B836293764B6EA0E, B4AD2E8419D2C29F
// reference: 789790E898410408, C6D1945D8824B670
// shader: 8B31, 7CBFDF058AA76880

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define fma_safe(x, y, z) fma(x, y, z)
#define mul_safe(x, y) (x * y)
#define rcp_safe(x) (1.0f / x)
#define rsq_safe(x) inversesqrt(x)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_8();
bool sub_9_32();
bool sub_33_96();
bool sub_114_142();
bool sub_146_166();
bool sub_167_259();
bool sub_190_192();
bool sub_194_195();
bool sub_197_198();
bool sub_200_202();
bool sub_232_234();
bool sub_236_237();
bool sub_239_240();
bool sub_242_244();
bool sub_260_4096();
bool sub_279_280();
bool sub_280_281();

bool exec_shader() {
    sub_260_4096();
    return true;
}

bool sub_0_8() {
    // 0: mova
    address_registers.x = (ivec2(vs_in_reg0.zzzz)).x;
    // 1: mov
    reg_tmp10 = uniforms.f[0].xxxz;
    // 2: mov
    reg_tmp10.xy = (vs_in_reg0.xyyy).xy;
    // 3: mov
    reg_tmp11 = uniforms.f[0].xxxx;
    // 4: mov
    reg_tmp12 = uniforms.f[0].xxxx;
    // 5: mov
    reg_tmp13 = uniforms.f[0].zzzz;
    // 6: mov
    reg_tmp4 = uniforms.f[0].xxxx;
    // 7: mov
    reg_tmp5 = uniforms.f[0].xxxx;
    return false;
}
bool sub_9_32() {
    // 9: mov
    vs_out_attr0 = reg_tmp10;
    // 10: mul
    reg_tmp13 = mul_safe(uniforms.f[82], reg_tmp13);
    // 11: mov
    vs_out_attr1 = reg_tmp13;
    // 12: add
    reg_tmp11.y = (uniforms.f[0].zzzz + -reg_tmp11.yyyy).y;
    // 13: add
    reg_tmp12.y = (uniforms.f[0].zzzz + -reg_tmp12.yyyy).y;
    // 14: mov
    reg_tmp14.y = (uniforms.f[81].wwww).y;
    // 15: mul
    reg_tmp14.x = (mul_safe(uniforms.f[0].wwww, reg_tmp14.yyyy)).x;
    // 16: rcp
    reg_tmp2.x = rcp_safe(reg_tmp14.xxxx.x);
    // 17: mov
    reg_tmp14.z = (reg_tmp2.xxxx).z;
    // 18: add
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp11.xyyy).xy;
    // 19: mul
    reg_tmp5.xy = (mul_safe(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    // 20: flr
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    // 21: mul
    reg_tmp4.xy = (mul_safe(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    // 22: add
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    // 23: add
    reg_tmp11.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    // 24: add
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp12.xyyy).xy;
    // 25: mul
    reg_tmp5.xy = (mul_safe(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    // 26: flr
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    // 27: mul
    reg_tmp4.xy = (mul_safe(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    // 28: add
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    // 29: add
    reg_tmp12.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    // 30: mov
    vs_out_attr2 = reg_tmp11;
    // 31: mov
    vs_out_attr3 = reg_tmp12;
    return false;
}
bool sub_33_96() {
    // 33: mov
    reg_tmp6.xyz = (-reg_tmp0.xyzz).xyz;
    // 34: mov
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    // 35: rcp
    reg_tmp7.xyz = vec3(rcp_safe(uniforms.f[81].yyyy.x));
    // 36: madi
    reg_tmp8.xyz = (fma_safe(reg_tmp6.xyzz, reg_tmp7.xyzz, uniforms.f[0].yyyy)).xyz;
    // 37: flr
    reg_tmp7.xyz = (floor(reg_tmp8.xyzz)).xyz;
    // 38: mad
    reg_tmp6.xyz = (fma_safe(reg_tmp7.xyzz, -uniforms.f[81].yyyy, reg_tmp6.xyzz)).xyz;
    // 39: min
    reg_tmp6 = min(uniforms.f[81].xxxx, reg_tmp6);
    // 40: max
    reg_tmp6 = max(-uniforms.f[81].xxxx, reg_tmp6);
    // 41: mov
    reg_tmp2 = uniforms.f[95];
    // 42: mov
    reg_tmp3 = uniforms.f[94];
    // 43: mul
    reg_tmp1.z = (mul_safe(reg_tmp6.xxxx, reg_tmp6.xxxx)).z;
    // 44: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 45: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 46: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 47: mov
    reg_tmp2 = uniforms.f[93];
    // 48: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 49: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 50: mul
    reg_tmp1.y = (mul_safe(reg_tmp1.yyyy, reg_tmp6.xxxx)).y;
    // 51: mov
    reg_tmp4.x = (reg_tmp1.xxxx).x;
    // 52: mov
    reg_tmp5.x = (reg_tmp1.yyyy).x;
    // 53: mov
    reg_tmp2 = uniforms.f[95];
    // 54: mov
    reg_tmp3 = uniforms.f[94];
    // 55: mul
    reg_tmp1.z = (mul_safe(reg_tmp6.yyyy, reg_tmp6.yyyy)).z;
    // 56: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 57: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 58: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 59: mov
    reg_tmp2 = uniforms.f[93];
    // 60: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 61: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 62: mul
    reg_tmp1.y = (mul_safe(reg_tmp1.yyyy, reg_tmp6.yyyy)).y;
    // 63: mov
    reg_tmp4.y = (reg_tmp1.xxxx).y;
    // 64: mov
    reg_tmp5.y = (reg_tmp1.yyyy).y;
    // 65: mov
    reg_tmp2 = uniforms.f[95];
    // 66: mov
    reg_tmp3 = uniforms.f[94];
    // 67: mul
    reg_tmp1.z = (mul_safe(reg_tmp6.zzzz, reg_tmp6.zzzz)).z;
    // 68: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 69: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 70: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 71: mov
    reg_tmp2 = uniforms.f[93];
    // 72: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 73: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 74: mul
    reg_tmp1.y = (mul_safe(reg_tmp1.yyyy, reg_tmp6.zzzz)).y;
    // 75: mov
    reg_tmp4.z = (reg_tmp1.xxxx).z;
    // 76: mov
    reg_tmp5.z = (reg_tmp1.yyyy).z;
    // 77: mul
    reg_tmp2.x = (mul_safe(reg_tmp4.yyyy, reg_tmp5.zzzz)).x;
    // 78: mul
    reg_tmp2.y = (mul_safe(reg_tmp5.yyyy, reg_tmp5.zzzz)).y;
    // 79: mul
    reg_tmp6.x = (mul_safe(reg_tmp4.yyyy, reg_tmp4.zzzz)).x;
    // 80: mov
    reg_tmp6.y = (reg_tmp5.zzzz).y;
    // 81: mul
    reg_tmp6.z = (mul_safe(-reg_tmp5.yyyy, reg_tmp4.zzzz)).z;
    // 82: mov
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    // 83: mul
    reg_tmp7.x = (mul_safe(-reg_tmp2.xxxx, reg_tmp4.xxxx)).x;
    // 84: mad
    reg_tmp7.x = (fma_safe(reg_tmp5.yyyy, reg_tmp5.xxxx, reg_tmp7.xxxx)).x;
    // 85: mul
    reg_tmp7.y = (mul_safe(reg_tmp4.zzzz, reg_tmp4.xxxx)).y;
    // 86: mul
    reg_tmp7.z = (mul_safe(reg_tmp2.yyyy, reg_tmp4.xxxx)).z;
    // 87: mad
    reg_tmp7.z = (fma_safe(reg_tmp4.yyyy, reg_tmp5.xxxx, reg_tmp7.zzzz)).z;
    // 88: mov
    reg_tmp7.w = (uniforms.f[0].xxxx).w;
    // 89: mul
    reg_tmp8.x = (mul_safe(reg_tmp2.xxxx, reg_tmp5.xxxx)).x;
    // 90: mad
    reg_tmp8.x = (fma_safe(reg_tmp5.yyyy, reg_tmp4.xxxx, reg_tmp8.xxxx)).x;
    // 91: mul
    reg_tmp8.y = (mul_safe(-reg_tmp4.zzzz, reg_tmp5.xxxx)).y;
    // 92: mul
    reg_tmp8.z = (mul_safe(-reg_tmp2.yyyy, reg_tmp5.xxxx)).z;
    // 93: mad
    reg_tmp8.z = (fma_safe(reg_tmp4.yyyy, reg_tmp4.xxxx, reg_tmp8.zzzz)).z;
    // 94: mov
    reg_tmp8.w = (uniforms.f[0].xxxx).w;
    // 95: mov
    reg_tmp9 = uniforms.f[0].xxxz;
    return false;
}
bool sub_114_142() {
    // 114: mov
    reg_tmp2 = uniforms.f[85];
    // 115: add
    reg_tmp2.xz = (-uniforms.f[5 + address_registers.x].xzzz + reg_tmp2.xzzz).xz;
    // 116: mov
    reg_tmp2.yw = (uniforms.f[0].xxxx).yw;
    // 117: dp3
    reg_tmp3.x = dot(vec3(reg_tmp2.xyzz), vec3(reg_tmp2.xyzz));
    // 118: rsq
    reg_tmp3.x = rsq_safe(reg_tmp3.xxxx.x);
    // 119: mul
    reg_tmp2.xyz = (mul_safe(reg_tmp2.xyzz, reg_tmp3.xxxx)).xyz;
    // 120: mov
    reg_tmp4 = uniforms.f[0].xzxx;
    // 121: mul
    reg_tmp5.xyz = (mul_safe(reg_tmp2.yzxx, reg_tmp4.zxyy)).xyz;
    // 122: mad
    reg_tmp5.xyz = (fma_safe(-reg_tmp4.yzxx, reg_tmp2.zxyy, reg_tmp5)).xyz;
    // 123: dp3
    reg_tmp3.x = dot(vec3(reg_tmp5.xyzz), vec3(reg_tmp5.xyzz));
    // 124: rsq
    reg_tmp3.x = rsq_safe(reg_tmp3.xxxx.x);
    // 125: mul
    reg_tmp5.xyz = (mul_safe(reg_tmp5.xyzz, reg_tmp3.xxxx)).xyz;
    // 126: mov
    reg_tmp6.x = (-reg_tmp5.xxxx).x;
    // 127: mov
    reg_tmp6.y = (-reg_tmp5.yyyy).y;
    // 128: mov
    reg_tmp6.z = (-reg_tmp5.zzzz).z;
    // 129: mov
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    // 130: mov
    reg_tmp7.x = (reg_tmp4.xxxx).x;
    // 131: mov
    reg_tmp7.y = (reg_tmp4.yyyy).y;
    // 132: mov
    reg_tmp7.z = (reg_tmp4.zzzz).z;
    // 133: mov
    reg_tmp7.w = (uniforms.f[0].xxxx).w;
    // 134: mov
    reg_tmp8.x = (-reg_tmp2.xxxx).x;
    // 135: mov
    reg_tmp8.y = (-reg_tmp2.yyyy).y;
    // 136: mov
    reg_tmp8.z = (-reg_tmp2.zzzz).z;
    // 137: mov
    reg_tmp8.w = (uniforms.f[0].xxxx).w;
    // 138: mov
    reg_tmp9.x = (uniforms.f[90].wwww).x;
    // 139: mov
    reg_tmp9.y = (uniforms.f[91].wwww).y;
    // 140: mov
    reg_tmp9.z = (uniforms.f[92].wwww).z;
    // 141: mov
    reg_tmp9.w = (uniforms.f[0].zzzz).w;
    return false;
}
bool sub_146_166() {
    // 146: mov
    reg_tmp2 = uniforms.f[90];
    // 147: mov
    reg_tmp3 = uniforms.f[91];
    // 148: mov
    reg_tmp4 = uniforms.f[92];
    // 149: mov
    reg_tmp5 = uniforms.f[0].xxxz;
    // 150: mul
    reg_tmp6 = mul_safe(uniforms.f[86].xxxx, reg_tmp2);
    // 151: mad
    reg_tmp6 = fma_safe(reg_tmp3, uniforms.f[86].yyyy, reg_tmp6);
    // 152: mad
    reg_tmp6 = fma_safe(reg_tmp4, uniforms.f[86].zzzz, reg_tmp6);
    // 153: mad
    reg_tmp6 = fma_safe(reg_tmp5, uniforms.f[86].wwww, reg_tmp6);
    // 154: mul
    reg_tmp7 = mul_safe(uniforms.f[87].xxxx, reg_tmp2);
    // 155: mad
    reg_tmp7 = fma_safe(reg_tmp3, uniforms.f[87].yyyy, reg_tmp7);
    // 156: mad
    reg_tmp7 = fma_safe(reg_tmp4, uniforms.f[87].zzzz, reg_tmp7);
    // 157: mad
    reg_tmp7 = fma_safe(reg_tmp5, uniforms.f[87].wwww, reg_tmp7);
    // 158: mul
    reg_tmp8 = mul_safe(uniforms.f[88].xxxx, reg_tmp2);
    // 159: mad
    reg_tmp8 = fma_safe(reg_tmp3, uniforms.f[88].yyyy, reg_tmp8);
    // 160: mad
    reg_tmp8 = fma_safe(reg_tmp4, uniforms.f[88].zzzz, reg_tmp8);
    // 161: mad
    reg_tmp8 = fma_safe(reg_tmp5, uniforms.f[88].wwww, reg_tmp8);
    // 162: mul
    reg_tmp9 = mul_safe(uniforms.f[89].xxxx, reg_tmp2);
    // 163: mad
    reg_tmp9 = fma_safe(reg_tmp3, uniforms.f[89].yyyy, reg_tmp9);
    // 164: mad
    reg_tmp9 = fma_safe(reg_tmp4, uniforms.f[89].zzzz, reg_tmp9);
    // 165: mad
    reg_tmp9 = fma_safe(reg_tmp5, uniforms.f[89].wwww, reg_tmp9);
    return false;
}
bool sub_167_259() {
    // 167: rcp
    reg_tmp2.x = rcp_safe(uniforms.f[81].yyyy.x);
    // 168: mul
    reg_tmp2.xy = (mul_safe(uniforms.f[2 + address_registers.x].zwww, reg_tmp2.xxxx)).xy;
    // 169: add
    reg_tmp2.xy = (uniforms.f[0].yyyy + reg_tmp2.xyyy).xy;
    // 170: flr
    reg_tmp3.xy = (floor(reg_tmp2.xyyy)).xy;
    // 171: mul
    reg_tmp2.xy = (mul_safe(uniforms.f[81].yyyy, reg_tmp3.xyyy)).xy;
    // 172: add
    reg_tmp2.xy = (uniforms.f[2 + address_registers.x].zwww + -reg_tmp2.xyyy).xy;
    // 173: min
    reg_tmp0.xy = (min(uniforms.f[81].xxxx, -reg_tmp2.xyyy)).xy;
    // 174: max
    reg_tmp0.xy = (max(-uniforms.f[81].xxxx, reg_tmp0.xyyy)).xy;
    // 175: mov
    reg_tmp2 = uniforms.f[95];
    // 176: mov
    reg_tmp3 = uniforms.f[94];
    // 177: mul
    reg_tmp1.z = (mul_safe(reg_tmp0.xxxx, reg_tmp0.xxxx)).z;
    // 178: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 179: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 180: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 181: mov
    reg_tmp2 = uniforms.f[93];
    // 182: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 183: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 184: mul
    reg_tmp1.y = (mul_safe(reg_tmp1.yyyy, reg_tmp0.xxxx)).y;
    // 185: mov
    reg_tmp5.x = (uniforms.f[5 + address_registers.x].wwww).x;
    // 186: mov
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    // 187: mov
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    // 188: cmp
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    // 189: ifc
    if (conditional_code.x) {
        sub_190_192();
    }
    // 192: cmp
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    // 193: ifc
    if (conditional_code.x) {
        sub_194_195();
    }
    // 195: cmp
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 196: ifc
    if (conditional_code.x) {
        sub_197_198();
    }
    // 198: cmp
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 199: ifc
    if (conditional_code.x) {
        sub_200_202();
    }
    // 202: mul
    reg_tmp4.xy = (mul_safe(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    // 203: mad
    reg_tmp4.x = (fma_safe(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    // 204: mad
    reg_tmp4.y = (fma_safe(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    // 205: add
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    // 206: add
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    // 207: mov
    reg_tmp4.z = (uniforms.f[83].xxxx).z;
    // 208: mov
    reg_tmp4.w = (-uniforms.f[83].yyyy).w;
    // 209: madi
    reg_tmp5.xy = (fma_safe(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[3 + address_registers.x].xyyy)).xy;
    // 210: mov
    reg_tmp4.z = (-uniforms.f[3 + address_registers.x].zzzz).z;
    // 211: mov
    reg_tmp4.w = (-uniforms.f[3 + address_registers.x].wwww).w;
    // 212: add
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    // 213: add
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    // 214: mad
    reg_tmp5.x = (fma_safe(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    // 215: mad
    reg_tmp5.y = (fma_safe(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    // 216: mov
    reg_tmp11.xy = (reg_tmp5.xyyy).xy;
    // 217: mov
    reg_tmp2 = uniforms.f[95];
    // 218: mov
    reg_tmp3 = uniforms.f[94];
    // 219: mul
    reg_tmp1.z = (mul_safe(reg_tmp0.yyyy, reg_tmp0.yyyy)).z;
    // 220: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 221: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 222: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 223: mov
    reg_tmp2 = uniforms.f[93];
    // 224: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 225: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 226: mul
    reg_tmp1.y = (mul_safe(reg_tmp1.yyyy, reg_tmp0.yyyy)).y;
    // 227: mov
    reg_tmp5.x = (uniforms.f[6 + address_registers.x].wwww).x;
    // 228: mov
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    // 229: mov
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    // 230: cmp
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    // 231: ifc
    if (conditional_code.x) {
        sub_232_234();
    }
    // 234: cmp
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    // 235: ifc
    if (conditional_code.x) {
        sub_236_237();
    }
    // 237: cmp
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 238: ifc
    if (conditional_code.x) {
        sub_239_240();
    }
    // 240: cmp
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 241: ifc
    if (conditional_code.x) {
        sub_242_244();
    }
    // 244: mul
    reg_tmp4.xy = (mul_safe(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    // 245: mad
    reg_tmp4.x = (fma_safe(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    // 246: mad
    reg_tmp4.y = (fma_safe(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    // 247: add
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    // 248: add
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    // 249: mov
    reg_tmp4.z = (uniforms.f[83].zzzz).z;
    // 250: mov
    reg_tmp4.w = (-uniforms.f[83].wwww).w;
    // 251: madi
    reg_tmp5.xy = (fma_safe(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[4 + address_registers.x].xyyy)).xy;
    // 252: mov
    reg_tmp4.z = (-uniforms.f[4 + address_registers.x].zzzz).z;
    // 253: mov
    reg_tmp4.w = (-uniforms.f[4 + address_registers.x].wwww).w;
    // 254: add
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    // 255: add
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    // 256: mad
    reg_tmp5.x = (fma_safe(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    // 257: mad
    reg_tmp5.y = (fma_safe(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    // 258: mov
    reg_tmp12.xy = (reg_tmp5.xyyy).xy;
    return false;
}
bool sub_190_192() {
    // 190: mov
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    // 191: mov
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_194_195() {
    // 194: mov
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_197_198() {
    // 197: mov
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_200_202() {
    // 200: mov
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    // 201: mov
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_232_234() {
    // 232: mov
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    // 233: mov
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_236_237() {
    // 236: mov
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_239_240() {
    // 239: mov
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_242_244() {
    // 242: mov
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    // 243: mov
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_260_4096() {
    // 260: call
    {
        sub_0_8();
    }
    // 261: add
    reg_tmp10.xy = (uniforms.f[84].xyyy + reg_tmp10.xyyy).xy;
    // 262: mul
    reg_tmp10.xy = (mul_safe(uniforms.f[2 + address_registers.x].xyyy, reg_tmp10.xyyy)).xy;
    // 263: call
    {
        sub_114_142();
    }
    // 264: dp4
    reg_tmp14.x = dot(reg_tmp10, reg_tmp6);
    // 265: dp4
    reg_tmp14.y = dot(reg_tmp10, reg_tmp7);
    // 266: dp4
    reg_tmp14.z = dot(reg_tmp10, reg_tmp8);
    // 267: dp4
    reg_tmp14.w = dot(uniforms.f[0].xxxz, reg_tmp10);
    // 268: mov
    reg_tmp0 = uniforms.f[7 + address_registers.x];
    // 269: call
    {
        sub_33_96();
    }
    // 270: dp4
    reg_tmp2.x = dot(reg_tmp14, reg_tmp6);
    // 271: dp4
    reg_tmp2.y = dot(reg_tmp14, reg_tmp7);
    // 272: dp4
    reg_tmp2.z = dot(reg_tmp14, reg_tmp8);
    // 273: dp4
    reg_tmp2.w = dot(reg_tmp14, reg_tmp9);
    // 274: mov
    reg_tmp3.xyz = (uniforms.f[5 + address_registers.x].xyzz).xyz;
    // 275: add
    reg_tmp3.xyz = (uniforms.f[85].xyzz + -reg_tmp3.xyzz).xyz;
    // 276: dp3
    reg_tmp4.x = dot(vec3(reg_tmp3.xyzz), vec3(reg_tmp3.xyzz));
    // 277: cmp
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
    // 278: ifc
    if (conditional_code.x) {
        sub_279_280();
    } else {
        sub_280_281();
    }
    // 281: mul
    reg_tmp3.xyz = (mul_safe(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
    // 282: add
    reg_tmp10.xyz = (uniforms.f[5 + address_registers.x].xyzz + reg_tmp2.xyzz).xyz;
    // 283: mad
    reg_tmp10.xyz = (fma_safe(reg_tmp3.xyzz, uniforms.f[84].zzzz, reg_tmp10.xyzz)).xyz;
    // 284: call
    {
        sub_146_166();
    }
    // 285: mov
    reg_tmp2 = reg_tmp10;
    // 286: dp4
    reg_tmp10.x = dot(reg_tmp2, reg_tmp6);
    // 287: dp4
    reg_tmp10.y = dot(reg_tmp2, reg_tmp7);
    // 288: dp4
    reg_tmp10.z = dot(reg_tmp2, reg_tmp8);
    // 289: dp4
    reg_tmp10.w = dot(reg_tmp2, reg_tmp9);
    // 290: mov
    reg_tmp2 = uniforms.f[1 + address_registers.x];
    // 291: max
    reg_tmp3 = max(uniforms.f[0].xxxx, reg_tmp2);
    // 292: min
    reg_tmp2 = min(uniforms.f[0].zzzz, reg_tmp3);
    // 293: mov
    reg_tmp13 = reg_tmp2;
    // 294: call
    {
        sub_167_259();
    }
    // 295: call
    {
        sub_9_32();
    }
    // 296: end
    return true;
}
bool sub_279_280() {
    // 279: mov
    reg_tmp4.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_280_281() {
    // 280: rsq
    reg_tmp4.x = rsq_safe(reg_tmp4.xxxx.x);
    return false;
}
// reference: 48FDFEF954A3367E, 7CBFDF058AA76880
// program: 7CBFDF058AA76880, CEF02063E9A18B2F, ED9AAA1E39CE1504
// reference: 86151EEE6C0E15A8, 3295BFC9E1117A37
// reference: 318B8BD28E4F9349, D82E12A9D19ACD63
// reference: 5564542EC5E6A6D0, B8A2CA3DB47999BF
// reference: DE8483811C2DA562, B8A2CA3DB47999BF
// reference: 18D103FFE34B824E, 5447A3297E824FE0
// reference: 9331D4503A8081FC, 5447A3297E824FE0
// reference: F0EF41408729D1F6, B8A2CA3DB47999BF
// reference: 7B0F96EFDE8681C7, B8A2CA3DB47999BF
// reference: 1FE04913493E0501, D82E12A9D19ACD63
// reference: 1FE04913C95A5682, D82E12A9D19ACD63
// reference: CED31A5F2331DED1, DEFAC6F185DB6EB9
// reference: 246CC41738CB5642, 48B3A6FBA8498826
// reference: 246CC4170E39C6B1, 48B3A6FBA8498826
// reference: 36EBB9B550A36299, F70C4BC6991FAFE8
// reference: 36EBB9B56651F26A, F70C4BC6991FAFE8
// reference: 8B285650D6819D46, 65138AC5CA635BBF
// reference: 466612B239D78153, DEFAC6F185DB6EB9
// reference: 466612B20F2511A0, DEFAC6F185DB6EB9
// shader: 8B31, EE0B6065741A8CB9

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define fma_safe(x, y, z) fma(x, y, z)
#define mul_safe(x, y) (x * y)
#define rcp_safe(x) (1.0f / x)
#define rsq_safe(x) inversesqrt(x)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_8();
bool sub_9_32();
bool sub_33_96();
bool sub_146_166();
bool sub_167_259();
bool sub_190_192();
bool sub_194_195();
bool sub_197_198();
bool sub_200_202();
bool sub_232_234();
bool sub_236_237();
bool sub_239_240();
bool sub_242_244();
bool sub_260_4096();
bool sub_287_288();
bool sub_288_289();

bool exec_shader() {
    sub_260_4096();
    return true;
}

bool sub_0_8() {
    // 0: mova
    address_registers.x = (ivec2(vs_in_reg0.zzzz)).x;
    // 1: mov
    reg_tmp10 = uniforms.f[0].xxxz;
    // 2: mov
    reg_tmp10.xy = (vs_in_reg0.xyyy).xy;
    // 3: mov
    reg_tmp11 = uniforms.f[0].xxxx;
    // 4: mov
    reg_tmp12 = uniforms.f[0].xxxx;
    // 5: mov
    reg_tmp13 = uniforms.f[0].zzzz;
    // 6: mov
    reg_tmp4 = uniforms.f[0].xxxx;
    // 7: mov
    reg_tmp5 = uniforms.f[0].xxxx;
    return false;
}
bool sub_9_32() {
    // 9: mov
    vs_out_attr0 = reg_tmp10;
    // 10: mul
    reg_tmp13 = mul_safe(uniforms.f[82], reg_tmp13);
    // 11: mov
    vs_out_attr1 = reg_tmp13;
    // 12: add
    reg_tmp11.y = (uniforms.f[0].zzzz + -reg_tmp11.yyyy).y;
    // 13: add
    reg_tmp12.y = (uniforms.f[0].zzzz + -reg_tmp12.yyyy).y;
    // 14: mov
    reg_tmp14.y = (uniforms.f[81].wwww).y;
    // 15: mul
    reg_tmp14.x = (mul_safe(uniforms.f[0].wwww, reg_tmp14.yyyy)).x;
    // 16: rcp
    reg_tmp2.x = rcp_safe(reg_tmp14.xxxx.x);
    // 17: mov
    reg_tmp14.z = (reg_tmp2.xxxx).z;
    // 18: add
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp11.xyyy).xy;
    // 19: mul
    reg_tmp5.xy = (mul_safe(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    // 20: flr
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    // 21: mul
    reg_tmp4.xy = (mul_safe(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    // 22: add
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    // 23: add
    reg_tmp11.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    // 24: add
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp12.xyyy).xy;
    // 25: mul
    reg_tmp5.xy = (mul_safe(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    // 26: flr
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    // 27: mul
    reg_tmp4.xy = (mul_safe(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    // 28: add
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    // 29: add
    reg_tmp12.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    // 30: mov
    vs_out_attr2 = reg_tmp11;
    // 31: mov
    vs_out_attr3 = reg_tmp12;
    return false;
}
bool sub_33_96() {
    // 33: mov
    reg_tmp6.xyz = (-reg_tmp0.xyzz).xyz;
    // 34: mov
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    // 35: rcp
    reg_tmp7.xyz = vec3(rcp_safe(uniforms.f[81].yyyy.x));
    // 36: madi
    reg_tmp8.xyz = (fma_safe(reg_tmp6.xyzz, reg_tmp7.xyzz, uniforms.f[0].yyyy)).xyz;
    // 37: flr
    reg_tmp7.xyz = (floor(reg_tmp8.xyzz)).xyz;
    // 38: mad
    reg_tmp6.xyz = (fma_safe(reg_tmp7.xyzz, -uniforms.f[81].yyyy, reg_tmp6.xyzz)).xyz;
    // 39: min
    reg_tmp6 = min(uniforms.f[81].xxxx, reg_tmp6);
    // 40: max
    reg_tmp6 = max(-uniforms.f[81].xxxx, reg_tmp6);
    // 41: mov
    reg_tmp2 = uniforms.f[95];
    // 42: mov
    reg_tmp3 = uniforms.f[94];
    // 43: mul
    reg_tmp1.z = (mul_safe(reg_tmp6.xxxx, reg_tmp6.xxxx)).z;
    // 44: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 45: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 46: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 47: mov
    reg_tmp2 = uniforms.f[93];
    // 48: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 49: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 50: mul
    reg_tmp1.y = (mul_safe(reg_tmp1.yyyy, reg_tmp6.xxxx)).y;
    // 51: mov
    reg_tmp4.x = (reg_tmp1.xxxx).x;
    // 52: mov
    reg_tmp5.x = (reg_tmp1.yyyy).x;
    // 53: mov
    reg_tmp2 = uniforms.f[95];
    // 54: mov
    reg_tmp3 = uniforms.f[94];
    // 55: mul
    reg_tmp1.z = (mul_safe(reg_tmp6.yyyy, reg_tmp6.yyyy)).z;
    // 56: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 57: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 58: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 59: mov
    reg_tmp2 = uniforms.f[93];
    // 60: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 61: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 62: mul
    reg_tmp1.y = (mul_safe(reg_tmp1.yyyy, reg_tmp6.yyyy)).y;
    // 63: mov
    reg_tmp4.y = (reg_tmp1.xxxx).y;
    // 64: mov
    reg_tmp5.y = (reg_tmp1.yyyy).y;
    // 65: mov
    reg_tmp2 = uniforms.f[95];
    // 66: mov
    reg_tmp3 = uniforms.f[94];
    // 67: mul
    reg_tmp1.z = (mul_safe(reg_tmp6.zzzz, reg_tmp6.zzzz)).z;
    // 68: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 69: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 70: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 71: mov
    reg_tmp2 = uniforms.f[93];
    // 72: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 73: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 74: mul
    reg_tmp1.y = (mul_safe(reg_tmp1.yyyy, reg_tmp6.zzzz)).y;
    // 75: mov
    reg_tmp4.z = (reg_tmp1.xxxx).z;
    // 76: mov
    reg_tmp5.z = (reg_tmp1.yyyy).z;
    // 77: mul
    reg_tmp2.x = (mul_safe(reg_tmp4.yyyy, reg_tmp5.zzzz)).x;
    // 78: mul
    reg_tmp2.y = (mul_safe(reg_tmp5.yyyy, reg_tmp5.zzzz)).y;
    // 79: mul
    reg_tmp6.x = (mul_safe(reg_tmp4.yyyy, reg_tmp4.zzzz)).x;
    // 80: mov
    reg_tmp6.y = (reg_tmp5.zzzz).y;
    // 81: mul
    reg_tmp6.z = (mul_safe(-reg_tmp5.yyyy, reg_tmp4.zzzz)).z;
    // 82: mov
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    // 83: mul
    reg_tmp7.x = (mul_safe(-reg_tmp2.xxxx, reg_tmp4.xxxx)).x;
    // 84: mad
    reg_tmp7.x = (fma_safe(reg_tmp5.yyyy, reg_tmp5.xxxx, reg_tmp7.xxxx)).x;
    // 85: mul
    reg_tmp7.y = (mul_safe(reg_tmp4.zzzz, reg_tmp4.xxxx)).y;
    // 86: mul
    reg_tmp7.z = (mul_safe(reg_tmp2.yyyy, reg_tmp4.xxxx)).z;
    // 87: mad
    reg_tmp7.z = (fma_safe(reg_tmp4.yyyy, reg_tmp5.xxxx, reg_tmp7.zzzz)).z;
    // 88: mov
    reg_tmp7.w = (uniforms.f[0].xxxx).w;
    // 89: mul
    reg_tmp8.x = (mul_safe(reg_tmp2.xxxx, reg_tmp5.xxxx)).x;
    // 90: mad
    reg_tmp8.x = (fma_safe(reg_tmp5.yyyy, reg_tmp4.xxxx, reg_tmp8.xxxx)).x;
    // 91: mul
    reg_tmp8.y = (mul_safe(-reg_tmp4.zzzz, reg_tmp5.xxxx)).y;
    // 92: mul
    reg_tmp8.z = (mul_safe(-reg_tmp2.yyyy, reg_tmp5.xxxx)).z;
    // 93: mad
    reg_tmp8.z = (fma_safe(reg_tmp4.yyyy, reg_tmp4.xxxx, reg_tmp8.zzzz)).z;
    // 94: mov
    reg_tmp8.w = (uniforms.f[0].xxxx).w;
    // 95: mov
    reg_tmp9 = uniforms.f[0].xxxz;
    return false;
}
bool sub_146_166() {
    // 146: mov
    reg_tmp2 = uniforms.f[90];
    // 147: mov
    reg_tmp3 = uniforms.f[91];
    // 148: mov
    reg_tmp4 = uniforms.f[92];
    // 149: mov
    reg_tmp5 = uniforms.f[0].xxxz;
    // 150: mul
    reg_tmp6 = mul_safe(uniforms.f[86].xxxx, reg_tmp2);
    // 151: mad
    reg_tmp6 = fma_safe(reg_tmp3, uniforms.f[86].yyyy, reg_tmp6);
    // 152: mad
    reg_tmp6 = fma_safe(reg_tmp4, uniforms.f[86].zzzz, reg_tmp6);
    // 153: mad
    reg_tmp6 = fma_safe(reg_tmp5, uniforms.f[86].wwww, reg_tmp6);
    // 154: mul
    reg_tmp7 = mul_safe(uniforms.f[87].xxxx, reg_tmp2);
    // 155: mad
    reg_tmp7 = fma_safe(reg_tmp3, uniforms.f[87].yyyy, reg_tmp7);
    // 156: mad
    reg_tmp7 = fma_safe(reg_tmp4, uniforms.f[87].zzzz, reg_tmp7);
    // 157: mad
    reg_tmp7 = fma_safe(reg_tmp5, uniforms.f[87].wwww, reg_tmp7);
    // 158: mul
    reg_tmp8 = mul_safe(uniforms.f[88].xxxx, reg_tmp2);
    // 159: mad
    reg_tmp8 = fma_safe(reg_tmp3, uniforms.f[88].yyyy, reg_tmp8);
    // 160: mad
    reg_tmp8 = fma_safe(reg_tmp4, uniforms.f[88].zzzz, reg_tmp8);
    // 161: mad
    reg_tmp8 = fma_safe(reg_tmp5, uniforms.f[88].wwww, reg_tmp8);
    // 162: mul
    reg_tmp9 = mul_safe(uniforms.f[89].xxxx, reg_tmp2);
    // 163: mad
    reg_tmp9 = fma_safe(reg_tmp3, uniforms.f[89].yyyy, reg_tmp9);
    // 164: mad
    reg_tmp9 = fma_safe(reg_tmp4, uniforms.f[89].zzzz, reg_tmp9);
    // 165: mad
    reg_tmp9 = fma_safe(reg_tmp5, uniforms.f[89].wwww, reg_tmp9);
    return false;
}
bool sub_167_259() {
    // 167: rcp
    reg_tmp2.x = rcp_safe(uniforms.f[81].yyyy.x);
    // 168: mul
    reg_tmp2.xy = (mul_safe(uniforms.f[2 + address_registers.x].zwww, reg_tmp2.xxxx)).xy;
    // 169: add
    reg_tmp2.xy = (uniforms.f[0].yyyy + reg_tmp2.xyyy).xy;
    // 170: flr
    reg_tmp3.xy = (floor(reg_tmp2.xyyy)).xy;
    // 171: mul
    reg_tmp2.xy = (mul_safe(uniforms.f[81].yyyy, reg_tmp3.xyyy)).xy;
    // 172: add
    reg_tmp2.xy = (uniforms.f[2 + address_registers.x].zwww + -reg_tmp2.xyyy).xy;
    // 173: min
    reg_tmp0.xy = (min(uniforms.f[81].xxxx, -reg_tmp2.xyyy)).xy;
    // 174: max
    reg_tmp0.xy = (max(-uniforms.f[81].xxxx, reg_tmp0.xyyy)).xy;
    // 175: mov
    reg_tmp2 = uniforms.f[95];
    // 176: mov
    reg_tmp3 = uniforms.f[94];
    // 177: mul
    reg_tmp1.z = (mul_safe(reg_tmp0.xxxx, reg_tmp0.xxxx)).z;
    // 178: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 179: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 180: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 181: mov
    reg_tmp2 = uniforms.f[93];
    // 182: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 183: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 184: mul
    reg_tmp1.y = (mul_safe(reg_tmp1.yyyy, reg_tmp0.xxxx)).y;
    // 185: mov
    reg_tmp5.x = (uniforms.f[5 + address_registers.x].wwww).x;
    // 186: mov
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    // 187: mov
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    // 188: cmp
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    // 189: ifc
    if (conditional_code.x) {
        sub_190_192();
    }
    // 192: cmp
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    // 193: ifc
    if (conditional_code.x) {
        sub_194_195();
    }
    // 195: cmp
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 196: ifc
    if (conditional_code.x) {
        sub_197_198();
    }
    // 198: cmp
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 199: ifc
    if (conditional_code.x) {
        sub_200_202();
    }
    // 202: mul
    reg_tmp4.xy = (mul_safe(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    // 203: mad
    reg_tmp4.x = (fma_safe(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    // 204: mad
    reg_tmp4.y = (fma_safe(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    // 205: add
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    // 206: add
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    // 207: mov
    reg_tmp4.z = (uniforms.f[83].xxxx).z;
    // 208: mov
    reg_tmp4.w = (-uniforms.f[83].yyyy).w;
    // 209: madi
    reg_tmp5.xy = (fma_safe(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[3 + address_registers.x].xyyy)).xy;
    // 210: mov
    reg_tmp4.z = (-uniforms.f[3 + address_registers.x].zzzz).z;
    // 211: mov
    reg_tmp4.w = (-uniforms.f[3 + address_registers.x].wwww).w;
    // 212: add
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    // 213: add
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    // 214: mad
    reg_tmp5.x = (fma_safe(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    // 215: mad
    reg_tmp5.y = (fma_safe(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    // 216: mov
    reg_tmp11.xy = (reg_tmp5.xyyy).xy;
    // 217: mov
    reg_tmp2 = uniforms.f[95];
    // 218: mov
    reg_tmp3 = uniforms.f[94];
    // 219: mul
    reg_tmp1.z = (mul_safe(reg_tmp0.yyyy, reg_tmp0.yyyy)).z;
    // 220: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 221: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 222: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 223: mov
    reg_tmp2 = uniforms.f[93];
    // 224: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 225: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 226: mul
    reg_tmp1.y = (mul_safe(reg_tmp1.yyyy, reg_tmp0.yyyy)).y;
    // 227: mov
    reg_tmp5.x = (uniforms.f[6 + address_registers.x].wwww).x;
    // 228: mov
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    // 229: mov
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    // 230: cmp
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    // 231: ifc
    if (conditional_code.x) {
        sub_232_234();
    }
    // 234: cmp
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    // 235: ifc
    if (conditional_code.x) {
        sub_236_237();
    }
    // 237: cmp
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 238: ifc
    if (conditional_code.x) {
        sub_239_240();
    }
    // 240: cmp
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 241: ifc
    if (conditional_code.x) {
        sub_242_244();
    }
    // 244: mul
    reg_tmp4.xy = (mul_safe(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    // 245: mad
    reg_tmp4.x = (fma_safe(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    // 246: mad
    reg_tmp4.y = (fma_safe(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    // 247: add
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    // 248: add
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    // 249: mov
    reg_tmp4.z = (uniforms.f[83].zzzz).z;
    // 250: mov
    reg_tmp4.w = (-uniforms.f[83].wwww).w;
    // 251: madi
    reg_tmp5.xy = (fma_safe(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[4 + address_registers.x].xyyy)).xy;
    // 252: mov
    reg_tmp4.z = (-uniforms.f[4 + address_registers.x].zzzz).z;
    // 253: mov
    reg_tmp4.w = (-uniforms.f[4 + address_registers.x].wwww).w;
    // 254: add
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    // 255: add
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    // 256: mad
    reg_tmp5.x = (fma_safe(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    // 257: mad
    reg_tmp5.y = (fma_safe(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    // 258: mov
    reg_tmp12.xy = (reg_tmp5.xyyy).xy;
    return false;
}
bool sub_190_192() {
    // 190: mov
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    // 191: mov
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_194_195() {
    // 194: mov
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_197_198() {
    // 197: mov
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_200_202() {
    // 200: mov
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    // 201: mov
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_232_234() {
    // 232: mov
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    // 233: mov
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_236_237() {
    // 236: mov
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_239_240() {
    // 239: mov
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_242_244() {
    // 242: mov
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    // 243: mov
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_260_4096() {
    // 260: call
    {
        sub_0_8();
    }
    // 261: add
    reg_tmp10.xy = (uniforms.f[84].xyyy + reg_tmp10.xyyy).xy;
    // 262: mul
    reg_tmp10.xy = (mul_safe(uniforms.f[2 + address_registers.x].xyyy, reg_tmp10.xyyy)).xy;
    // 263: mov
    reg_tmp14 = reg_tmp10;
    // 264: mov
    reg_tmp0 = uniforms.f[7 + address_registers.x];
    // 265: call
    {
        sub_33_96();
    }
    // 266: dp4
    reg_tmp10.x = dot(reg_tmp14, reg_tmp6);
    // 267: dp4
    reg_tmp10.y = dot(reg_tmp14, reg_tmp7);
    // 268: dp4
    reg_tmp10.z = dot(reg_tmp14, reg_tmp8);
    // 269: dp4
    reg_tmp10.w = dot(reg_tmp14, reg_tmp9);
    // 270: mov
    reg_tmp6 = uniforms.f[8 + address_registers.x];
    // 271: mov
    reg_tmp7 = uniforms.f[9 + address_registers.x];
    // 272: mov
    reg_tmp8 = uniforms.f[10 + address_registers.x];
    // 273: mov
    reg_tmp9 = uniforms.f[0].xxxz;
    // 274: mov
    reg_tmp6.w = (uniforms.f[5 + address_registers.x].xxxx).w;
    // 275: mov
    reg_tmp7.w = (uniforms.f[5 + address_registers.x].yyyy).w;
    // 276: mov
    reg_tmp8.w = (uniforms.f[5 + address_registers.x].zzzz).w;
    // 277: dp4
    reg_tmp2.x = dot(reg_tmp10, reg_tmp6);
    // 278: dp4
    reg_tmp2.y = dot(reg_tmp10, reg_tmp7);
    // 279: dp4
    reg_tmp2.z = dot(reg_tmp10, reg_tmp8);
    // 280: dp4
    reg_tmp2.w = dot(reg_tmp10, reg_tmp9);
    // 281: mov
    reg_tmp10 = reg_tmp2;
    // 282: mov
    reg_tmp3.xyz = (uniforms.f[5 + address_registers.x].xyzz).xyz;
    // 283: add
    reg_tmp3.xyz = (uniforms.f[85].xyzz + -reg_tmp3.xyzz).xyz;
    // 284: dp3
    reg_tmp4.x = dot(vec3(reg_tmp3.xyzz), vec3(reg_tmp3.xyzz));
    // 285: cmp
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
    // 286: ifc
    if (conditional_code.x) {
        sub_287_288();
    } else {
        sub_288_289();
    }
    // 289: mul
    reg_tmp3.xyz = (mul_safe(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
    // 290: mad
    reg_tmp10.xyz = (fma_safe(reg_tmp3.xyzz, uniforms.f[84].zzzz, reg_tmp10.xyzz)).xyz;
    // 291: call
    {
        sub_146_166();
    }
    // 292: mov
    reg_tmp2 = reg_tmp10;
    // 293: dp4
    reg_tmp10.x = dot(reg_tmp2, reg_tmp6);
    // 294: dp4
    reg_tmp10.y = dot(reg_tmp2, reg_tmp7);
    // 295: dp4
    reg_tmp10.z = dot(reg_tmp2, reg_tmp8);
    // 296: dp4
    reg_tmp10.w = dot(reg_tmp2, reg_tmp9);
    // 297: mov
    reg_tmp2 = uniforms.f[1 + address_registers.x];
    // 298: max
    reg_tmp3 = max(uniforms.f[0].xxxx, reg_tmp2);
    // 299: min
    reg_tmp2 = min(uniforms.f[0].zzzz, reg_tmp3);
    // 300: mov
    reg_tmp13 = reg_tmp2;
    // 301: call
    {
        sub_167_259();
    }
    // 302: call
    {
        sub_9_32();
    }
    // 303: end
    return true;
}
bool sub_287_288() {
    // 287: mov
    reg_tmp4.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_288_289() {
    // 288: rsq
    reg_tmp4.x = rsq_safe(reg_tmp4.xxxx.x);
    return false;
}
// reference: 79C21CED5E9DAA15, EE0B6065741A8CB9
// program: EE0B6065741A8CB9, CEF02063E9A18B2F, ED9AAA1E39CE1504
// reference: 86151EEECC53737D, 3295BFC9E1117A37
// reference: 48FDFEF9D6728E74, 7CBFDF058AA76880
// reference: 318B8BD22E12F59C, D82E12A9D19ACD63
// reference: 5564542E65BBC005, B8A2CA3DB47999BF
// reference: DE848381BC70C3B7, B8A2CA3DB47999BF
// reference: 79C21CED686F3AE6, EE0B6065741A8CB9
// reference: 86151EEEFAA1E38E, 3295BFC9E1117A37
// shader: 8B30, D5752EDCE40AA0F7

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a) * (const_color[5].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: CCE0F34F14C67EC1, D5752EDCE40AA0F7
// program: DEFAC6F185DB6EB9, 6CF3F3B70E23AA85, D5752EDCE40AA0F7
// reference: 233A73080BFA62E0, ED9AAA1E39CE1504
// reference: C06E00AA9B057D59, DEFAC6F185DB6EB9
// reference: 48FDFEF9FC9CD7A1, 734B56B7CFCD3D95
// reference: FF636BC5282FC1B3, D82E12A9D19ACD63
// reference: 9B8CB4396386F42A, B8A2CA3DB47999BF
// reference: 106C6396BA4DF798, B8A2CA3DB47999BF
// reference: D639E3E8E34B824E, 5447A3297E824FE0
// reference: 5DD934473A8081FC, 5447A3297E824FE0
// reference: 3E07A1578729D1F6, B8A2CA3DB47999BF
// reference: B5E776F8DE8681C7, B8A2CA3DB47999BF
// reference: D108A904493E0501, D82E12A9D19ACD63
// reference: D108A904C95A5682, D82E12A9D19ACD63
// reference: 003BFA482331DED1, DEFAC6F185DB6EB9
// reference: 1F64203538CB5642, 48B3A6FBA8498826
// reference: 1F6420350E39C6B1, 48B3A6FBA8498826
// reference: 0DE35D9750A36299, F70C4BC6991FAFE8
// reference: 0DE35D976651F26A, F70C4BC6991FAFE8
// reference: B020B272D6819D46, 65138AC5CA635BBF
// reference: 7D6EF69039D78153, DEFAC6F185DB6EB9
// reference: 7D6EF6900F2511A0, DEFAC6F185DB6EB9
// reference: A599F82A14C67EC1, D5752EDCE40AA0F7
// reference: 47D41E5846F99B26, 1BE8D5DEECF8172C
// reference: 48FDFEF95BD743EB, 734B56B7CFCD3D95
// reference: FF636BC58F6455F9, D82E12A9D19ACD63
// reference: 9B8CB439C4CD6060, B8A2CA3DB47999BF
// reference: 106C63961D0663D2, B8A2CA3DB47999BF
// reference: 7483BC6A56AF564B, D82E12A9D19ACD63
// reference: D639E3E89BFA51BA, 5447A3297E824FE0
// reference: 5DD9344742315208, 5447A3297E824FE0
// reference: 3E07A157FF980202, B8A2CA3DB47999BF
// reference: B5E776F8A6375233, B8A2CA3DB47999BF
// reference: D108A904318FD6F5, D82E12A9D19ACD63
// reference: D108A904B1EB8576, D82E12A9D19ACD63
// reference: 003BFA485B800D25, DEFAC6F185DB6EB9
// reference: C06E00AAADF7EDAA, DEFAC6F185DB6EB9
// reference: 635646A90E383743, DD35FB9CAEB223CF
// reference: 589900718A57568C, DEFAC6F185DB6EB9
// reference: 58990071BCA5C67F, DEFAC6F185DB6EB9
// reference: 810E826B4B818E86, D82E12A9D19ACD63
// reference: 0A4B9FE0FF980202, B8A2CA3DB47999BF
// reference: 81AB484FA6375233, B8A2CA3DB47999BF
// reference: E54497B3318FD6F5, D82E12A9D19ACD63
// reference: E54497B3B1EB8576, D82E12A9D19ACD63
// reference: 3477C4FF5B800D25, DEFAC6F185DB6EB9
// reference: 01EC2DEED43FE7D4, 9FB407F1EC1D74B1
// reference: 3A236B364C7408B6, DEFAC6F185DB6EB9
// reference: 3A236B367A869845, DEFAC6F185DB6EB9
// reference: DFCAABBF46F99B26, 1BE8D5DEECF8172C
// reference: 68543E83924A8D34, D82E12A9D19ACD63
// reference: 0CBBE17FD9E3B8AD, B8A2CA3DB47999BF
// reference: 875B36D00028BB1F, B8A2CA3DB47999BF
// reference: E3B4E92C4B818E86, D82E12A9D19ACD63
// reference: 80CFB6189BFA51BA, 5447A3297E824FE0
// reference: 0B2F61B742315208, 5447A3297E824FE0
// reference: 68F1F4A7FF980202, B8A2CA3DB47999BF
// reference: E3112308A6375233, B8A2CA3DB47999BF
// reference: 87FEFCF4318FD6F5, D82E12A9D19ACD63
// reference: 87FEFCF4B1EB8576, D82E12A9D19ACD63
// reference: 56CDAFB85B800D25, DEFAC6F185DB6EB9
// reference: EF56AFFD81319FA5, 1C802C20F608CB95
// reference: 3A236B36E51FFFBB, DEFAC6F185DB6EB9
// reference: 3A236B36D3ED6F48, DEFAC6F185DB6EB9
// reference: DFCAABBF700B0BD5, 1BE8D5DEECF8172C
// reference: C7A2F033C8E0B9BD, D82E12A9D19ACD63
// reference: 5C3C72E98729D1F6, B8A2CA3DB47999BF
// reference: D7DCA546DE8681C7, B8A2CA3DB47999BF
// reference: B3337ABA493E0501, D82E12A9D19ACD63
// reference: B3337ABAC95A5682, D82E12A9D19ACD63
// reference: 620029F62331DED1, DEFAC6F185DB6EB9
// reference: A5189B74D71A5328, D82E12A9D19ACD63
// reference: 3E8619AE8729D1F6, B8A2CA3DB47999BF
// reference: B566CE01DE8681C7, B8A2CA3DB47999BF
// reference: D18911FD493E0501, D82E12A9D19ACD63
// reference: D18911FDC95A5682, D82E12A9D19ACD63
// reference: 00BA42B12331DED1, DEFAC6F185DB6EB9
// reference: 01EC2DEE4BA6802A, 9FB407F1EC1D74B1
// reference: 635646A9545C6ABF, DD35FB9CAEB223CF
// reference: 8D88803EA43CF78C, 163CE5AA2AAAB87B
// reference: 1AF012B10BFA62E0, ED9AAA1E39CE1504
// reference: 2D2562025B0C0A33, 95AC54D58E4F10E1
// reference: 63AC69AB0BBF60EF, 95AC54D58E4F10E1
// reference: D14F22525D7C8BB7, B4AD2E8419D2C29F
// reference: 5F7980B98729D1F6, B8A2CA3DB47999BF
// reference: D4995716DE8681C7, B8A2CA3DB47999BF
// reference: B07688EA493E0501, D82E12A9D19ACD63
// reference: B07688EAC95A5682, D82E12A9D19ACD63
// reference: 6145DBA62331DED1, DEFAC6F185DB6EB9
// reference: 15FD9D8456AF564B, D82E12A9D19ACD63
// reference: 5F7980B9FF980202, B8A2CA3DB47999BF
// reference: D4995716A6375233, B8A2CA3DB47999BF
// reference: B07688EA318FD6F5, D82E12A9D19ACD63
// reference: B07688EAB1EB8576, D82E12A9D19ACD63
// reference: 6145DBA65B800D25, DEFAC6F185DB6EB9
// reference: 58990071E6C19B83, DEFAC6F185DB6EB9
// reference: 58990071D0330B70, DEFAC6F185DB6EB9
// reference: 2983DF17B834C8B6, 734B56B7CFCD3D95
// reference: 9E1D4A2B6C87DEA4, D82E12A9D19ACD63
// reference: FAF295D7272EEB3D, B8A2CA3DB47999BF
// reference: 71124278FEE5E88F, B8A2CA3DB47999BF
// shader: 8B30, 7ACDF80016160D6B

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) + (const_color[0].a) - 0.5, 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0 * 1.0, alpha_output_0 * 2.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (last_tex_env_out.aaa), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (last_tex_env_out.aaa) + (texcolor0.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2 * 1.0, alpha_output_2 * 4.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rrr) + (last_tex_env_out.ggg), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb) + (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: F8D9F09354C98EAE, 7ACDF80016160D6B
// program: D82E12A9D19ACD63, 5D764F9A6220D694, 7ACDF80016160D6B
// shader: 8B30, 4F1CB33AB2EDEAE2

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) + (const_color[0].a) - 0.5, 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0 * 1.0, alpha_output_0 * 2.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (last_tex_env_out.aaa), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (last_tex_env_out.aaa) + (texcolor0.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2 * 1.0, alpha_output_2 * 4.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rrr) + (last_tex_env_out.ggg), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: C09EDC1EF55AEA6F, 4F1CB33AB2EDEAE2
// program: D82E12A9D19ACD63, 5D764F9A6220D694, 4F1CB33AB2EDEAE2
// shader: 8B30, B781BE3C6605FA66

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) + (const_color[0].a) - 0.5, 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0 * 1.0, alpha_output_0 * 2.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (last_tex_env_out.aaa), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor0.rgb) * (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor0.a) + (const_color[2].a) - 0.5, 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2 * 1.0, alpha_output_2 * 2.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (last_tex_env_out.aaa), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) * (last_tex_env_out.aaa) + (texcolor0.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4 * 1.0, alpha_output_4 * 4.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb) + (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: DDC581267BE09200, B781BE3C6605FA66
// program: D82E12A9D19ACD63, 5D764F9A6220D694, B781BE3C6605FA66
// shader: 8B30, 1124F6B1C25B0C8C

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) + (const_color[0].a) - 0.5, 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0 * 1.0, alpha_output_0 * 2.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (last_tex_env_out.aaa), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor0.rgb) * (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor0.a) + (const_color[2].a) - 0.5, 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2 * 1.0, alpha_output_2 * 2.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (last_tex_env_out.aaa), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) * (last_tex_env_out.aaa) + (texcolor0.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4 * 1.0, alpha_output_4 * 4.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: E582ADABDA73F6C1, 1124F6B1C25B0C8C
// program: D82E12A9D19ACD63, 5D764F9A6220D694, 1124F6B1C25B0C8C
// reference: A3E84AF02463A27A, 70D24D55BDEC0B06
// program: 70D24D55BDEC0B06, 6CF3F3B70E23AA85, 20A72E97AF8E39F2
// reference: 76891A77A43EDFF2, DEFAC6F185DB6EB9
// reference: 96CFBAB5B27790C8, 79AE694A7B008028
// reference: 583CA59EF9BE408E, D82E12A9D19ACD63
// reference: D3DC72312207E1C9, D82E12A9D19ACD63
// shader: 8B31, DC9976EED0CC7E67

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define fma_safe(x, y, z) fma(x, y, z)
#define mul_safe(x, y) (x * y)
#define rcp_safe(x) (1.0f / x)
#define rsq_safe(x) inversesqrt(x)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_8();
bool sub_9_32();
bool sub_97_113();
bool sub_146_166();
bool sub_167_249();
bool sub_189_190();
bool sub_192_193();
bool sub_195_196();
bool sub_198_200();
bool sub_226_227();
bool sub_229_230();
bool sub_232_233();
bool sub_235_237();
bool sub_250_4096();
bool sub_263_264();
bool sub_264_265();

bool exec_shader() {
    sub_250_4096();
    return true;
}

bool sub_0_8() {
    // 0: mov
    reg_tmp10 = uniforms.f[0].xxxz;
    // 1: mov
    reg_tmp10.xyz = (vs_in_reg0.xyzz).xyz;
    // 2: mov
    reg_tmp11 = uniforms.f[0].xxxx;
    // 3: mov
    reg_tmp12 = uniforms.f[0].xxxx;
    // 4: mov
    reg_tmp11.xy = (vs_in_reg1.xyyy).xy;
    // 5: mov
    reg_tmp13 = uniforms.f[0].zzzz;
    // 6: mov
    reg_tmp4 = uniforms.f[0].xxxx;
    // 7: mov
    reg_tmp5 = uniforms.f[0].xxxx;
    return false;
}
bool sub_9_32() {
    // 9: mov
    vs_out_attr0 = reg_tmp10;
    // 10: mul
    reg_tmp13 = mul_safe(uniforms.f[82], reg_tmp13);
    // 11: mul
    vs_out_attr1 = mul_safe(vs_in_reg2, reg_tmp13);
    // 12: add
    reg_tmp11.y = (uniforms.f[0].zzzz + -reg_tmp11.yyyy).y;
    // 13: add
    reg_tmp12.y = (uniforms.f[0].zzzz + -reg_tmp12.yyyy).y;
    // 14: mov
    reg_tmp14.y = (uniforms.f[81].wwww).y;
    // 15: mul
    reg_tmp14.x = (mul_safe(uniforms.f[0].wwww, reg_tmp14.yyyy)).x;
    // 16: rcp
    reg_tmp2.x = rcp_safe(reg_tmp14.xxxx.x);
    // 17: mov
    reg_tmp14.z = (reg_tmp2.xxxx).z;
    // 18: add
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp11.xyyy).xy;
    // 19: mul
    reg_tmp5.xy = (mul_safe(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    // 20: flr
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    // 21: mul
    reg_tmp4.xy = (mul_safe(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    // 22: add
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    // 23: add
    reg_tmp11.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    // 24: add
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp12.xyyy).xy;
    // 25: mul
    reg_tmp5.xy = (mul_safe(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    // 26: flr
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    // 27: mul
    reg_tmp4.xy = (mul_safe(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    // 28: add
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    // 29: add
    reg_tmp12.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    // 30: mov
    vs_out_attr2 = reg_tmp11;
    // 31: mov
    vs_out_attr3 = reg_tmp12;
    return false;
}
bool sub_97_113() {
    // 97: mov
    reg_tmp6.x = (uniforms.f[90].xxxx).x;
    // 98: mov
    reg_tmp6.y = (uniforms.f[91].xxxx).y;
    // 99: mov
    reg_tmp6.z = (uniforms.f[92].xxxx).z;
    // 100: mov
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    // 101: mov
    reg_tmp7.x = (uniforms.f[90].yyyy).x;
    // 102: mov
    reg_tmp7.y = (uniforms.f[91].yyyy).y;
    // 103: mov
    reg_tmp7.z = (uniforms.f[92].yyyy).z;
    // 104: mov
    reg_tmp7.w = (uniforms.f[0].xxxx).w;
    // 105: mov
    reg_tmp8.x = (uniforms.f[90].zzzz).x;
    // 106: mov
    reg_tmp8.y = (uniforms.f[91].zzzz).y;
    // 107: mov
    reg_tmp8.z = (uniforms.f[92].zzzz).z;
    // 108: mov
    reg_tmp8.w = (uniforms.f[0].xxxx).w;
    // 109: mov
    reg_tmp9.x = (uniforms.f[90].wwww).x;
    // 110: mov
    reg_tmp9.y = (uniforms.f[91].wwww).y;
    // 111: mov
    reg_tmp9.z = (uniforms.f[92].wwww).z;
    // 112: mov
    reg_tmp9.w = (uniforms.f[0].zzzz).w;
    return false;
}
bool sub_146_166() {
    // 146: mov
    reg_tmp2 = uniforms.f[90];
    // 147: mov
    reg_tmp3 = uniforms.f[91];
    // 148: mov
    reg_tmp4 = uniforms.f[92];
    // 149: mov
    reg_tmp5 = uniforms.f[0].xxxz;
    // 150: mul
    reg_tmp6 = mul_safe(uniforms.f[86].xxxx, reg_tmp2);
    // 151: mad
    reg_tmp6 = fma_safe(reg_tmp3, uniforms.f[86].yyyy, reg_tmp6);
    // 152: mad
    reg_tmp6 = fma_safe(reg_tmp4, uniforms.f[86].zzzz, reg_tmp6);
    // 153: mad
    reg_tmp6 = fma_safe(reg_tmp5, uniforms.f[86].wwww, reg_tmp6);
    // 154: mul
    reg_tmp7 = mul_safe(uniforms.f[87].xxxx, reg_tmp2);
    // 155: mad
    reg_tmp7 = fma_safe(reg_tmp3, uniforms.f[87].yyyy, reg_tmp7);
    // 156: mad
    reg_tmp7 = fma_safe(reg_tmp4, uniforms.f[87].zzzz, reg_tmp7);
    // 157: mad
    reg_tmp7 = fma_safe(reg_tmp5, uniforms.f[87].wwww, reg_tmp7);
    // 158: mul
    reg_tmp8 = mul_safe(uniforms.f[88].xxxx, reg_tmp2);
    // 159: mad
    reg_tmp8 = fma_safe(reg_tmp3, uniforms.f[88].yyyy, reg_tmp8);
    // 160: mad
    reg_tmp8 = fma_safe(reg_tmp4, uniforms.f[88].zzzz, reg_tmp8);
    // 161: mad
    reg_tmp8 = fma_safe(reg_tmp5, uniforms.f[88].wwww, reg_tmp8);
    // 162: mul
    reg_tmp9 = mul_safe(uniforms.f[89].xxxx, reg_tmp2);
    // 163: mad
    reg_tmp9 = fma_safe(reg_tmp3, uniforms.f[89].yyyy, reg_tmp9);
    // 164: mad
    reg_tmp9 = fma_safe(reg_tmp4, uniforms.f[89].zzzz, reg_tmp9);
    // 165: mad
    reg_tmp9 = fma_safe(reg_tmp5, uniforms.f[89].wwww, reg_tmp9);
    return false;
}
bool sub_167_249() {
    // 167: rcp
    reg_tmp2.x = rcp_safe(uniforms.f[81].yyyy.x);
    // 168: mul
    reg_tmp2.xy = (mul_safe(uniforms.f[2].zwww, reg_tmp2.xxxx)).xy;
    // 169: add
    reg_tmp2.xy = (uniforms.f[0].yyyy + reg_tmp2.xyyy).xy;
    // 170: flr
    reg_tmp3.xy = (floor(reg_tmp2.xyyy)).xy;
    // 171: mul
    reg_tmp2.xy = (mul_safe(uniforms.f[81].yyyy, reg_tmp3.xyyy)).xy;
    // 172: add
    reg_tmp2.xy = (uniforms.f[2].zwww + -reg_tmp2.xyyy).xy;
    // 173: min
    reg_tmp0.xy = (min(uniforms.f[81].xxxx, reg_tmp2.xyyy)).xy;
    // 174: max
    reg_tmp0.xy = (max(-uniforms.f[81].xxxx, reg_tmp0.xyyy)).xy;
    // 175: mov
    reg_tmp2 = uniforms.f[95];
    // 176: mov
    reg_tmp3 = uniforms.f[94];
    // 177: mul
    reg_tmp1.z = (mul_safe(reg_tmp0.xxxx, reg_tmp0.xxxx)).z;
    // 178: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 179: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 180: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 181: mov
    reg_tmp2 = uniforms.f[93];
    // 182: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 183: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 184: mul
    reg_tmp1.y = (mul_safe(reg_tmp1.yyyy, reg_tmp0.xxxx)).y;
    // 185: mov
    reg_tmp5.x = (uniforms.f[5].wwww).x;
    // 186: mov
    reg_tmp14.xy = (vs_in_reg1.xyyy).xy;
    // 187: cmp
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    // 188: ifc
    if (conditional_code.x) {
        sub_189_190();
    }
    // 190: cmp
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    // 191: ifc
    if (conditional_code.x) {
        sub_192_193();
    }
    // 193: cmp
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 194: ifc
    if (conditional_code.x) {
        sub_195_196();
    }
    // 196: cmp
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 197: ifc
    if (conditional_code.x) {
        sub_198_200();
    }
    // 200: mov
    reg_tmp3 = reg_tmp14.xyxy;
    // 201: add
    reg_tmp3.y = (uniforms.f[0].zzzz + -reg_tmp3.yyyy).y;
    // 202: add
    reg_tmp3.w = (uniforms.f[0].zzzz + -reg_tmp3.wwww).w;
    // 203: mul
    reg_tmp2 = mul_safe(uniforms.f[83].xxyy, reg_tmp3);
    // 204: add
    reg_tmp2 = -uniforms.f[0].yyyy + reg_tmp2;
    // 205: mul
    reg_tmp2 = mul_safe(reg_tmp2, reg_tmp1.xyyx);
    // 206: add
    reg_tmp2.x = (reg_tmp2.xxxx + -reg_tmp2.yyyy).x;
    // 207: add
    reg_tmp2.y = (reg_tmp2.zzzz + reg_tmp2.wwww).y;
    // 208: mov
    reg_tmp4.xy = (uniforms.f[3].xyyy).xy;
    // 209: mad
    reg_tmp3.xy = (fma_safe(reg_tmp2.xyyy, uniforms.f[3].zwww, reg_tmp4.xyyy)).xy;
    // 210: add
    reg_tmp3.xy = (uniforms.f[0].yyyy + reg_tmp3.xyyy).xy;
    // 211: mov
    reg_tmp11.xy = (reg_tmp3.xyyy).xy;
    // 212: mov
    reg_tmp2 = uniforms.f[95];
    // 213: mov
    reg_tmp3 = uniforms.f[94];
    // 214: mul
    reg_tmp1.z = (mul_safe(reg_tmp0.yyyy, reg_tmp0.yyyy)).z;
    // 215: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 216: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 217: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 218: mov
    reg_tmp2 = uniforms.f[93];
    // 219: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 220: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 221: mul
    reg_tmp1.y = (mul_safe(reg_tmp1.yyyy, reg_tmp0.yyyy)).y;
    // 222: mov
    reg_tmp5.x = (uniforms.f[6].wwww).x;
    // 223: mov
    reg_tmp14.xy = (vs_in_reg1.xyyy).xy;
    // 224: cmp
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    // 225: ifc
    if (conditional_code.x) {
        sub_226_227();
    }
    // 227: cmp
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    // 228: ifc
    if (conditional_code.x) {
        sub_229_230();
    }
    // 230: cmp
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 231: ifc
    if (conditional_code.x) {
        sub_232_233();
    }
    // 233: cmp
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 234: ifc
    if (conditional_code.x) {
        sub_235_237();
    }
    // 237: mov
    reg_tmp3 = reg_tmp14.xyxy;
    // 238: add
    reg_tmp3.y = (uniforms.f[0].zzzz + -reg_tmp3.yyyy).y;
    // 239: add
    reg_tmp3.w = (uniforms.f[0].zzzz + -reg_tmp3.wwww).w;
    // 240: mul
    reg_tmp2 = mul_safe(uniforms.f[83].zzww, reg_tmp3);
    // 241: add
    reg_tmp2 = -uniforms.f[0].yyyy + reg_tmp2;
    // 242: mul
    reg_tmp2 = mul_safe(reg_tmp2, reg_tmp1.xyyx);
    // 243: add
    reg_tmp2.x = (reg_tmp2.xxxx + -reg_tmp2.yyyy).x;
    // 244: add
    reg_tmp2.y = (reg_tmp2.zzzz + reg_tmp2.wwww).y;
    // 245: mov
    reg_tmp4.xy = (uniforms.f[4].xyyy).xy;
    // 246: mad
    reg_tmp3.xy = (fma_safe(reg_tmp2.xyyy, uniforms.f[4].zwww, reg_tmp4.xyyy)).xy;
    // 247: add
    reg_tmp3.xy = (uniforms.f[0].yyyy + reg_tmp3.xyyy).xy;
    // 248: mov
    reg_tmp12.xy = (reg_tmp3.xyyy).xy;
    return false;
}
bool sub_189_190() {
    // 189: mov
    reg_tmp14.xy = (vs_in_reg1.xyyy).xy;
    return false;
}
bool sub_192_193() {
    // 192: add
    reg_tmp14.x = (uniforms.f[0].zzzz + -vs_in_reg1.xxxx).x;
    return false;
}
bool sub_195_196() {
    // 195: add
    reg_tmp14.y = (uniforms.f[0].zzzz + -vs_in_reg1.yyyy).y;
    return false;
}
bool sub_198_200() {
    // 198: add
    reg_tmp14.x = (uniforms.f[0].zzzz + -vs_in_reg1.xxxx).x;
    // 199: add
    reg_tmp14.y = (uniforms.f[0].zzzz + -vs_in_reg1.yyyy).y;
    return false;
}
bool sub_226_227() {
    // 226: mov
    reg_tmp14.xy = (vs_in_reg1.xyyy).xy;
    return false;
}
bool sub_229_230() {
    // 229: add
    reg_tmp14.x = (uniforms.f[0].zzzz + -vs_in_reg1.xxxx).x;
    return false;
}
bool sub_232_233() {
    // 232: add
    reg_tmp14.y = (uniforms.f[0].zzzz + -vs_in_reg1.yyyy).y;
    return false;
}
bool sub_235_237() {
    // 235: add
    reg_tmp14.x = (uniforms.f[0].zzzz + -vs_in_reg1.xxxx).x;
    // 236: add
    reg_tmp14.y = (uniforms.f[0].zzzz + -vs_in_reg1.yyyy).y;
    return false;
}
bool sub_250_4096() {
    // 250: call
    {
        sub_0_8();
    }
    // 251: add
    reg_tmp10.xy = (uniforms.f[84].xyyy + reg_tmp10.xyyy).xy;
    // 252: mul
    reg_tmp10.xyz = (mul_safe(uniforms.f[2].xyxx, reg_tmp10.xyzz)).xyz;
    // 253: call
    {
        sub_97_113();
    }
    // 254: dp4
    reg_tmp2.x = dot(reg_tmp10, reg_tmp6);
    // 255: dp4
    reg_tmp2.y = dot(reg_tmp10, reg_tmp7);
    // 256: dp4
    reg_tmp2.z = dot(reg_tmp10, reg_tmp8);
    // 257: dp4
    reg_tmp2.w = dot(uniforms.f[0].xxxz, reg_tmp10);
    // 258: mov
    reg_tmp3.xyz = (uniforms.f[5].xyzz).xyz;
    // 259: add
    reg_tmp3.xyz = (uniforms.f[85].xyzz + -reg_tmp3.xyzz).xyz;
    // 260: dp3
    reg_tmp4.x = dot(vec3(reg_tmp3.xyzz), vec3(reg_tmp3.xyzz));
    // 261: cmp
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
    // 262: ifc
    if (conditional_code.x) {
        sub_263_264();
    } else {
        sub_264_265();
    }
    // 265: mul
    reg_tmp3.xyz = (mul_safe(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
    // 266: add
    reg_tmp10.xyz = (uniforms.f[5].xyzz + reg_tmp2.xyzz).xyz;
    // 267: mad
    reg_tmp10.xyz = (fma_safe(reg_tmp3.xyzz, uniforms.f[84].zzzz, reg_tmp10.xyzz)).xyz;
    // 268: call
    {
        sub_146_166();
    }
    // 269: mov
    reg_tmp2 = reg_tmp10;
    // 270: dp4
    reg_tmp10.x = dot(reg_tmp2, reg_tmp6);
    // 271: dp4
    reg_tmp10.y = dot(reg_tmp2, reg_tmp7);
    // 272: dp4
    reg_tmp10.z = dot(reg_tmp2, reg_tmp8);
    // 273: dp4
    reg_tmp10.w = dot(reg_tmp2, reg_tmp9);
    // 274: mov
    reg_tmp2 = uniforms.f[1];
    // 275: max
    reg_tmp3 = max(uniforms.f[0].xxxx, reg_tmp2);
    // 276: min
    reg_tmp2 = min(uniforms.f[0].zzzz, reg_tmp3);
    // 277: mov
    reg_tmp13 = reg_tmp2;
    // 278: call
    {
        sub_167_249();
    }
    // 279: call
    {
        sub_9_32();
    }
    // 280: end
    return true;
}
bool sub_263_264() {
    // 263: mov
    reg_tmp4.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_264_265() {
    // 264: rsq
    reg_tmp4.x = rsq_safe(reg_tmp4.xxxx.x);
    return false;
}
// reference: F74BED41B6051846, DC9976EED0CC7E67
// shader: 8B30, 931705B2B7379FF3

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 2A8EDBC8B963A7A0, 931705B2B7379FF3
// program: DC9976EED0CC7E67, CEF02063E9A18B2F, 931705B2B7379FF3
// reference: EE9FF47A5E9DAA15, EE0B6065741A8CB9
// reference: F484F538B963A7A0, 931705B2EA3991A9
// program: EE0B6065741A8CB9, CEF02063E9A18B2F, 931705B2EA3991A9
// reference: 59016146BCDC2CF4, D82E12A9D19ACD63
// reference: D2E1B6E951971D40, D82E12A9D19ACD63
// reference: 38D1FB2FE372F705, 48B3A6FBA8498826
// reference: B3312C800E39C6B1, 48B3A6FBA8498826
// reference: 1C75BEC7E0730DB5, 65138AC5CA635BBF
// reference: B3312C8038CB5642, 48B3A6FBA8498826
// reference: D13BFA2539D78153, DEFAC6F185DB6EB9
// reference: D13BFA250F2511A0, DEFAC6F185DB6EB9
// reference: 8334F340C1EC365B, D82E12A9D19ACD63
// reference: 08D424EF2CA707EF, D82E12A9D19ACD63
// reference: E7DB2CBC8A4503C2, B8A2CA3DB47999BF
// reference: 6C3BFB13538E0070, B8A2CA3DB47999BF
// reference: 08D424EF182735E9, D82E12A9D19ACD63
// reference: 5ADB2D8AD49CB0E7, DEFAC6F185DB6EB9
// reference: A1B6512250A36299, F70C4BC6991FAFE8
// reference: A1B651226651F26A, F70C4BC6991FAFE8
// reference: 1C75BEC7D6819D46, 65138AC5CA635BBF
// reference: E6D272A8E34B824E, 5447A3297E824FE0
// reference: 6D32A5073A8081FC, 5447A3297E824FE0
// reference: 87C902ACFCD95FFB, B543C911C8D7EAAB
// reference: E41797BC7D3BCDCB, B8A2CA3DB47999BF
// reference: 6FF7401324949DFA, B8A2CA3DB47999BF
// reference: 0B189FEFB32C193C, D82E12A9D19ACD63
// reference: 0B189FEF33484ABF, D82E12A9D19ACD63
// reference: EBF6437C8D92D061, DEFAC6F185DB6EB9
// reference: 7D9608DE5B0C0A33, 95AC54D58E4F10E1
// reference: D22979A8A9AD37AC, C686B1FD59F65802
// reference: D22979A829C9642F, C686B1FD59F65802
// reference: 7D6DEBEFD15AEEB7, 46F6395BEBA5C2A1
// reference: 7D6DEBEF67CC2DC7, 46F6395BEBA5C2A1
// reference: 9A0E89D007F39434, DA97C925583C796F
// shader: 8B30, 5F027F62C62E4809

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(view)), 0.0))) * light_src[0].specular_0) + ((lut_scale_d1 * LookupLightingLUTUnsigned(1, max(dot(normal, normalize(view)), 0.0))) * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor1.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1 * 2.0, alpha_output_1 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((texcolor1.aaa) * (secondary_fragment_color.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) * (vec3(1.0) - textureProj(tex0, vec3(texcoord0, texcoord0_w)).rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 16426B1E9D00C383, 5F027F62C62E4809
// program: 46F6395BEBA5C2A1, 3B3AE026C742C7D5, 5F027F62C62E4809
// reference: 7D6DEBEF513EBD34, 46F6395BEBA5C2A1
// reference: D22979A81F3BF4DC, C686B1FD59F65802
// reference: 7D6DEBEFE7A87E44, 46F6395BEBA5C2A1
// shader: 8B30, 6C11729E2035EF43

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(view)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(view)), 0.0))) * light_src[0].specular_0) + ((lut_scale_d1 * LookupLightingLUTUnsigned(1, max(dot(normal, normalize(view)), 0.0))) * refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor1.rgb) * (const_color[0].aaa) + (texcolor2.rgb) * (vec3(1.0) - (const_color[0].aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].r) * (const_color[0].a) + (texcolor2.a) * (1.0 - (const_color[0].a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2 * 2.0, alpha_output_2 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((texcolor1.aaa) * (secondary_fragment_color.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) * (vec3(1.0) - textureProj(tex0, vec3(texcoord0, texcoord0_w)).rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: CE08E3CD2719BCEA, 6C11729E2035EF43
// program: C686B1FD59F65802, AD7922A63ED54CA7, 6C11729E2035EF43
// reference: D0FE82D938CB5642, 48B3A6FBA8498826
// reference: E0FB5D19C1EC365B, D82E12A9D19ACD63
// reference: 6B1B8AB62CA707EF, D82E12A9D19ACD63
// reference: F68D3C408A871C73, 46F6395BEBA5C2A1
// shader: 8B30, 4F823895C8BC6A43

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 31D38FC164C761DA, 4F823895C8BC6A43
// program: 46F6395BEBA5C2A1, 3B3AE026C742C7D5, 4F823895C8BC6A43
// reference: 80F679DEF4A876F8, D82E12A9D19ACD63
// reference: E419A622BF014361, B8A2CA3DB47999BF
// reference: 6FF9718D66CA40D3, B8A2CA3DB47999BF
// reference: 0B16AE712D63754A, D82E12A9D19ACD63
// reference: 44B82DB3B2C172CA, 5447A3297E824FE0
// reference: CF58FA1C6B0A7178, 5447A3297E824FE0
// reference: 3C4CC3C7BCADC215, B543C911C8D7EAAB
// reference: 5F9256D73D4F5025, B8A2CA3DB47999BF
// reference: D472817864E00014, B8A2CA3DB47999BF
// reference: B09D5E84F35884D2, D82E12A9D19ACD63
// reference: B09D5E84733CD751, D82E12A9D19ACD63
// reference: 50738217CDE64D8F, DEFAC6F185DB6EB9
// reference: D0FE82D90E39C6B1, 48B3A6FBA8498826
// reference: C279FF7B50A36299, F70C4BC6991FAFE8
// reference: C279FF7B6651F26A, F70C4BC6991FAFE8
// reference: 7FBA109ED6819D46, 65138AC5CA635BBF
// reference: B2F4547C39D78153, DEFAC6F185DB6EB9
// reference: B2F4547C0F2511A0, DEFAC6F185DB6EB9
// reference: 31D38FC134740B06, 4F823895C8BC6A43
// reference: 391483D3D49CB0E7, DEFAC6F185DB6EB9
// reference: 58AA84A41677B816, 4F823895C8BC6A43
// reference: 233EDA9BF4A876F8, D82E12A9D19ACD63
// reference: 47D10567BF014361, B8A2CA3DB47999BF
// reference: CC31D2C866CA40D3, B8A2CA3DB47999BF
// reference: A8DE0D342D63754A, D82E12A9D19ACD63
// reference: E7708EF6B2C172CA, 5447A3297E824FE0
// reference: 6C9059596B0A7178, 5447A3297E824FE0
// reference: 9F846082BCADC215, B543C911C8D7EAAB
// reference: FC5AF5923D4F5025, B8A2CA3DB47999BF
// reference: 77BA223D64E00014, B8A2CA3DB47999BF
// reference: 1355FDC1F35884D2, D82E12A9D19ACD63
// reference: 1355FDC1733CD751, D82E12A9D19ACD63
// reference: F3BB2152CDE64D8F, DEFAC6F185DB6EB9
// reference: 7D9608DE0BBF60EF, 95AC54D58E4F10E1
// reference: E8B69106440A4CDF, DD35FB9CAEB223CF
// reference: 6160E51D64C761DA, 4F823895C8BC6A43
// reference: 8A0CFA41901F216D, 9FB407F1EC1D74B1
// program: 9FB407F1EC1D74B1, CEF02063E9A18B2F, C0234F4E2DEC3D4D
// reference: 2FE9EEB40DBE6ABF, 4F823895C8BC6A43
// reference: 7F5A84680DBE6ABF, 4F823895C8BC6A43
// reference: 0BEBBED1C3463122, DEFAC6F185DB6EB9
// reference: 48FDFEF9A88E8D0F, 734B56B7CFCD3D95
// reference: FF636BC57C3D9B1D, D82E12A9D19ACD63
// reference: 9B8CB4393794AE84, B8A2CA3DB47999BF
// reference: 106C6396EE5FAD36, B8A2CA3DB47999BF
// reference: D639E3E8B2C172CA, 5447A3297E824FE0
// reference: 5DD934476B0A7178, 5447A3297E824FE0
// reference: A7723B5BBCADC215, B543C911C8D7EAAB
// reference: C4ACAE4B3D4F5025, B8A2CA3DB47999BF
// reference: 4F4C79E464E00014, B8A2CA3DB47999BF
// reference: 2BA3A618F35884D2, D82E12A9D19ACD63
// reference: 2BA3A618733CD751, D82E12A9D19ACD63
// reference: CB4D7A8BCDE64D8F, DEFAC6F185DB6EB9
// reference: 01EC2DEEC093E79E, 9FB407F1EC1D74B1
// reference: 19C2EC7C0BFA62E0, C0234F4E2DEC3D4D
// reference: 4B39B450E964C139, 7CBFDF058AA76880
// program: 7CBFDF058AA76880, CEF02063E9A18B2F, C0234F4E2DEC3D4D
// reference: 262E366006C6B817, 1BE8D5DEECF8172C
// program: 1BE8D5DEECF8172C, CEF02063E9A18B2F, C0234F4E2DEC3D4D
// reference: A1942892846733D9, DEFAC6F185DB6EB9
// reference: 4B39B4501BE860DA, 734B56B7CFCD3D95
// reference: FCA7216CCF5B76C8, D82E12A9D19ACD63
// reference: 9848FE9084F24351, B8A2CA3DB47999BF
// reference: 13A8293F5D3940E3, B8A2CA3DB47999BF
// reference: 7747F6C31690757A, D82E12A9D19ACD63
// reference: D5FDA941DBC5728B, 5447A3297E824FE0
// reference: 5E1D7EEE020E7139, 5447A3297E824FE0
// reference: A4B671F2BCADC215, B543C911C8D7EAAB
// reference: C768E4E23D4F5025, B8A2CA3DB47999BF
// reference: 4C88334D64E00014, B8A2CA3DB47999BF
// reference: 2867ECB1F35884D2, D82E12A9D19ACD63
// reference: 2867ECB1733CD751, D82E12A9D19ACD63
// reference: C8893022CDE64D8F, DEFAC6F185DB6EB9
// reference: 91B0A35CD275AE05, D82E12A9D19ACD63
// reference: F55F7CA099DC9B9C, B8A2CA3DB47999BF
// reference: 7EBFAB0F4017982E, B8A2CA3DB47999BF
// reference: 1A5074F30BBEADB7, D82E12A9D19ACD63
// reference: 792B2BC7DBC5728B, 5447A3297E824FE0
// reference: F2CBFC68020E7139, 5447A3297E824FE0
// reference: 0860F374BCADC215, B543C911C8D7EAAB
// reference: 6BBE66643D4F5025, B8A2CA3DB47999BF
// reference: E05EB1CB64E00014, B8A2CA3DB47999BF
// reference: 84B16E37F35884D2, D82E12A9D19ACD63
// reference: 84B16E37733CD751, D82E12A9D19ACD63
// reference: 645FB2A4CDE64D8F, DEFAC6F185DB6EB9
// reference: 27A88EBE38CB5642, 48B3A6FBA8498826
// reference: 27A88EBE0E39C6B1, 48B3A6FBA8498826
// reference: 352FF31C50A36299, F70C4BC6991FAFE8
// reference: 352FF31C6651F26A, F70C4BC6991FAFE8
// reference: 88EC1CF9D6819D46, 65138AC5CA635BBF
// reference: 45A2581B39D78153, DEFAC6F185DB6EB9
// reference: 45A2581B0F2511A0, DEFAC6F185DB6EB9
// reference: DFCAABBF06C6B817, 1BE8D5DEECF8172C
// reference: 5870B54D846733D9, DEFAC6F185DB6EB9
// reference: 68543E83D275AE05, D82E12A9D19ACD63
// reference: 0CBBE17F99DC9B9C, B8A2CA3DB47999BF
// reference: 875B36D04017982E, B8A2CA3DB47999BF
// reference: E3B4E92C0BBEADB7, D82E12A9D19ACD63
// reference: 80CFB618DBC5728B, 5447A3297E824FE0
// reference: 0B2F61B7020E7139, 5447A3297E824FE0
// reference: F1846EABBCADC215, B543C911C8D7EAAB
// reference: 925AFBBB3D4F5025, B8A2CA3DB47999BF
// reference: 19BA2C1464E00014, B8A2CA3DB47999BF
// reference: 7D55F3E8F35884D2, D82E12A9D19ACD63
// reference: 7D55F3E8733CD751, D82E12A9D19ACD63
// reference: 9DBB2F7BCDE64D8F, DEFAC6F185DB6EB9
// reference: 2AE82DCAF85A61F8, EA83856FEB3CAEC2
// reference: 497186A00BFA62E0, C0234F4E2DEC3D4D
// reference: 7A5B4716F85A61F8, EA83856FEB3CAEC2
// reference: 882F31B006C6B817, 1BE8D5DEECF8172C
// reference: 3FB1A48CD275AE05, D82E12A9D19ACD63
// reference: 5B5E7B7099DC9B9C, B8A2CA3DB47999BF
// reference: D0BEACDF4017982E, B8A2CA3DB47999BF
// reference: B45173230BBEADB7, D82E12A9D19ACD63
// reference: D72A2C17DBC5728B, 5447A3297E824FE0
// reference: 5CCAFBB8020E7139, 5447A3297E824FE0
// reference: A661F4A4BCADC215, B543C911C8D7EAAB
// reference: C5BF61B43D4F5025, B8A2CA3DB47999BF
// reference: 4E5FB61B64E00014, B8A2CA3DB47999BF
// reference: 2AB069E7F35884D2, D82E12A9D19ACD63
// reference: 2AB069E7733CD751, D82E12A9D19ACD63
// reference: CA5EB574CDE64D8F, DEFAC6F185DB6EB9
// reference: E88543EB64B6EA0E, B4AD2E8419D2C29F
// reference: 86151EEED1C9E2EF, 3295BFC9E1117A37
// reference: 318B8BD2057AF4FD, D82E12A9D19ACD63
// reference: 5564542E4ED3C164, B8A2CA3DB47999BF
// reference: DE8483819718C2D6, B8A2CA3DB47999BF
// reference: 18D103FFB2C172CA, 5447A3297E824FE0
// reference: 9331D4506B0A7178, 5447A3297E824FE0
// reference: 699ADB4CBCADC215, B543C911C8D7EAAB
// reference: 0A444E5C3D4F5025, B8A2CA3DB47999BF
// reference: 81A499F364E00014, B8A2CA3DB47999BF
// reference: E54B460FF35884D2, D82E12A9D19ACD63
// reference: E54B460F733CD751, D82E12A9D19ACD63
// reference: 05A59A9CCDE64D8F, DEFAC6F185DB6EB9
// reference: F94260E614110CE7, D3C285AB726883C8
// shader: 8B30, D965E5B5D6139706

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a) * (const_color[5].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 5949BCE720E4FB38, D965E5B5D6139706
// program: D3C285AB726883C8, 4BD70AD09292A3DA, D965E5B5D6139706
// reference: 0DF5C9410A7043A8, 3295BFC9E1117A37
// program: 0000000000000000, 0000000000000000, 3F3EC97B868B23C2
// reference: B59CF97C3903F9EE, D82E12A9D19ACD63
// reference: 48FDFEF9D7F4D6C0, 734B56B7CFCD3D95
// shader: 8B30, 52F15AB07872CB3F

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_2 = byteround(clamp((vec3(1.0) - combiner_buffer.rgb) * (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: EB333308F039D468, 52F15AB07872CB3F
// program: 734B56B7CFCD3D95, CEF02063E9A18B2F, 52F15AB07872CB3F
// reference: FF636BC50347C0D2, D82E12A9D19ACD63
// reference: 9B8CB43948EEF54B, B8A2CA3DB47999BF
// reference: 106C63969125F6F9, B8A2CA3DB47999BF
// reference: 37AA80F1C9350985, D3C285AB726883C8
// reference: 48FDFEF9D5867435, 734B56B7CFCD3D95
// reference: AE3D27E93FB11730, 52F15AB07872CB3F
// reference: 7B74196B3F3ECDC1, D82E12A9D19ACD63
// shader: 8B31, 01CD144CA8DEFCA2

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define fma_safe(x, y, z) fma(x, y, z)
#define mul_safe(x, y) (x * y)
#define rcp_safe(x) (1.0f / x)
#define rsq_safe(x) inversesqrt(x)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_8();
bool sub_9_32();
bool sub_33_96();
bool sub_146_166();
bool sub_167_259();
bool sub_190_192();
bool sub_194_195();
bool sub_197_198();
bool sub_200_202();
bool sub_232_234();
bool sub_236_237();
bool sub_239_240();
bool sub_242_244();
bool sub_260_4096();
bool sub_288_289();
bool sub_289_290();

bool exec_shader() {
    sub_260_4096();
    return true;
}

bool sub_0_8() {
    // 0: mova
    address_registers.x = (ivec2(vs_in_reg0.zzzz)).x;
    // 1: mov
    reg_tmp10 = uniforms.f[0].xxxz;
    // 2: mov
    reg_tmp10.xy = (vs_in_reg0.xyyy).xy;
    // 3: mov
    reg_tmp11 = uniforms.f[0].xxxx;
    // 4: mov
    reg_tmp12 = uniforms.f[0].xxxx;
    // 5: mov
    reg_tmp13 = uniforms.f[0].zzzz;
    // 6: mov
    reg_tmp4 = uniforms.f[0].xxxx;
    // 7: mov
    reg_tmp5 = uniforms.f[0].xxxx;
    return false;
}
bool sub_9_32() {
    // 9: mov
    vs_out_attr0 = reg_tmp10;
    // 10: mul
    reg_tmp13 = mul_safe(uniforms.f[82], reg_tmp13);
    // 11: mov
    vs_out_attr1 = reg_tmp13;
    // 12: add
    reg_tmp11.y = (uniforms.f[0].zzzz + -reg_tmp11.yyyy).y;
    // 13: add
    reg_tmp12.y = (uniforms.f[0].zzzz + -reg_tmp12.yyyy).y;
    // 14: mov
    reg_tmp14.y = (uniforms.f[81].wwww).y;
    // 15: mul
    reg_tmp14.x = (mul_safe(uniforms.f[0].wwww, reg_tmp14.yyyy)).x;
    // 16: rcp
    reg_tmp2.x = rcp_safe(reg_tmp14.xxxx.x);
    // 17: mov
    reg_tmp14.z = (reg_tmp2.xxxx).z;
    // 18: add
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp11.xyyy).xy;
    // 19: mul
    reg_tmp5.xy = (mul_safe(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    // 20: flr
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    // 21: mul
    reg_tmp4.xy = (mul_safe(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    // 22: add
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    // 23: add
    reg_tmp11.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    // 24: add
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp12.xyyy).xy;
    // 25: mul
    reg_tmp5.xy = (mul_safe(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    // 26: flr
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    // 27: mul
    reg_tmp4.xy = (mul_safe(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    // 28: add
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    // 29: add
    reg_tmp12.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    // 30: mov
    vs_out_attr2 = reg_tmp11;
    // 31: mov
    vs_out_attr3 = reg_tmp12;
    return false;
}
bool sub_33_96() {
    // 33: mov
    reg_tmp6.xyz = (-reg_tmp0.xyzz).xyz;
    // 34: mov
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    // 35: rcp
    reg_tmp7.xyz = vec3(rcp_safe(uniforms.f[81].yyyy.x));
    // 36: madi
    reg_tmp8.xyz = (fma_safe(reg_tmp6.xyzz, reg_tmp7.xyzz, uniforms.f[0].yyyy)).xyz;
    // 37: flr
    reg_tmp7.xyz = (floor(reg_tmp8.xyzz)).xyz;
    // 38: mad
    reg_tmp6.xyz = (fma_safe(reg_tmp7.xyzz, -uniforms.f[81].yyyy, reg_tmp6.xyzz)).xyz;
    // 39: min
    reg_tmp6 = min(uniforms.f[81].xxxx, reg_tmp6);
    // 40: max
    reg_tmp6 = max(-uniforms.f[81].xxxx, reg_tmp6);
    // 41: mov
    reg_tmp2 = uniforms.f[95];
    // 42: mov
    reg_tmp3 = uniforms.f[94];
    // 43: mul
    reg_tmp1.z = (mul_safe(reg_tmp6.xxxx, reg_tmp6.xxxx)).z;
    // 44: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 45: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 46: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 47: mov
    reg_tmp2 = uniforms.f[93];
    // 48: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 49: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 50: mul
    reg_tmp1.y = (mul_safe(reg_tmp1.yyyy, reg_tmp6.xxxx)).y;
    // 51: mov
    reg_tmp4.x = (reg_tmp1.xxxx).x;
    // 52: mov
    reg_tmp5.x = (reg_tmp1.yyyy).x;
    // 53: mov
    reg_tmp2 = uniforms.f[95];
    // 54: mov
    reg_tmp3 = uniforms.f[94];
    // 55: mul
    reg_tmp1.z = (mul_safe(reg_tmp6.yyyy, reg_tmp6.yyyy)).z;
    // 56: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 57: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 58: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 59: mov
    reg_tmp2 = uniforms.f[93];
    // 60: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 61: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 62: mul
    reg_tmp1.y = (mul_safe(reg_tmp1.yyyy, reg_tmp6.yyyy)).y;
    // 63: mov
    reg_tmp4.y = (reg_tmp1.xxxx).y;
    // 64: mov
    reg_tmp5.y = (reg_tmp1.yyyy).y;
    // 65: mov
    reg_tmp2 = uniforms.f[95];
    // 66: mov
    reg_tmp3 = uniforms.f[94];
    // 67: mul
    reg_tmp1.z = (mul_safe(reg_tmp6.zzzz, reg_tmp6.zzzz)).z;
    // 68: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 69: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 70: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 71: mov
    reg_tmp2 = uniforms.f[93];
    // 72: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 73: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 74: mul
    reg_tmp1.y = (mul_safe(reg_tmp1.yyyy, reg_tmp6.zzzz)).y;
    // 75: mov
    reg_tmp4.z = (reg_tmp1.xxxx).z;
    // 76: mov
    reg_tmp5.z = (reg_tmp1.yyyy).z;
    // 77: mul
    reg_tmp2.x = (mul_safe(reg_tmp4.yyyy, reg_tmp5.zzzz)).x;
    // 78: mul
    reg_tmp2.y = (mul_safe(reg_tmp5.yyyy, reg_tmp5.zzzz)).y;
    // 79: mul
    reg_tmp6.x = (mul_safe(reg_tmp4.yyyy, reg_tmp4.zzzz)).x;
    // 80: mov
    reg_tmp6.y = (reg_tmp5.zzzz).y;
    // 81: mul
    reg_tmp6.z = (mul_safe(-reg_tmp5.yyyy, reg_tmp4.zzzz)).z;
    // 82: mov
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    // 83: mul
    reg_tmp7.x = (mul_safe(-reg_tmp2.xxxx, reg_tmp4.xxxx)).x;
    // 84: mad
    reg_tmp7.x = (fma_safe(reg_tmp5.yyyy, reg_tmp5.xxxx, reg_tmp7.xxxx)).x;
    // 85: mul
    reg_tmp7.y = (mul_safe(reg_tmp4.zzzz, reg_tmp4.xxxx)).y;
    // 86: mul
    reg_tmp7.z = (mul_safe(reg_tmp2.yyyy, reg_tmp4.xxxx)).z;
    // 87: mad
    reg_tmp7.z = (fma_safe(reg_tmp4.yyyy, reg_tmp5.xxxx, reg_tmp7.zzzz)).z;
    // 88: mov
    reg_tmp7.w = (uniforms.f[0].xxxx).w;
    // 89: mul
    reg_tmp8.x = (mul_safe(reg_tmp2.xxxx, reg_tmp5.xxxx)).x;
    // 90: mad
    reg_tmp8.x = (fma_safe(reg_tmp5.yyyy, reg_tmp4.xxxx, reg_tmp8.xxxx)).x;
    // 91: mul
    reg_tmp8.y = (mul_safe(-reg_tmp4.zzzz, reg_tmp5.xxxx)).y;
    // 92: mul
    reg_tmp8.z = (mul_safe(-reg_tmp2.yyyy, reg_tmp5.xxxx)).z;
    // 93: mad
    reg_tmp8.z = (fma_safe(reg_tmp4.yyyy, reg_tmp4.xxxx, reg_tmp8.zzzz)).z;
    // 94: mov
    reg_tmp8.w = (uniforms.f[0].xxxx).w;
    // 95: mov
    reg_tmp9 = uniforms.f[0].xxxz;
    return false;
}
bool sub_146_166() {
    // 146: mov
    reg_tmp2 = uniforms.f[90];
    // 147: mov
    reg_tmp3 = uniforms.f[91];
    // 148: mov
    reg_tmp4 = uniforms.f[92];
    // 149: mov
    reg_tmp5 = uniforms.f[0].xxxz;
    // 150: mul
    reg_tmp6 = mul_safe(uniforms.f[86].xxxx, reg_tmp2);
    // 151: mad
    reg_tmp6 = fma_safe(reg_tmp3, uniforms.f[86].yyyy, reg_tmp6);
    // 152: mad
    reg_tmp6 = fma_safe(reg_tmp4, uniforms.f[86].zzzz, reg_tmp6);
    // 153: mad
    reg_tmp6 = fma_safe(reg_tmp5, uniforms.f[86].wwww, reg_tmp6);
    // 154: mul
    reg_tmp7 = mul_safe(uniforms.f[87].xxxx, reg_tmp2);
    // 155: mad
    reg_tmp7 = fma_safe(reg_tmp3, uniforms.f[87].yyyy, reg_tmp7);
    // 156: mad
    reg_tmp7 = fma_safe(reg_tmp4, uniforms.f[87].zzzz, reg_tmp7);
    // 157: mad
    reg_tmp7 = fma_safe(reg_tmp5, uniforms.f[87].wwww, reg_tmp7);
    // 158: mul
    reg_tmp8 = mul_safe(uniforms.f[88].xxxx, reg_tmp2);
    // 159: mad
    reg_tmp8 = fma_safe(reg_tmp3, uniforms.f[88].yyyy, reg_tmp8);
    // 160: mad
    reg_tmp8 = fma_safe(reg_tmp4, uniforms.f[88].zzzz, reg_tmp8);
    // 161: mad
    reg_tmp8 = fma_safe(reg_tmp5, uniforms.f[88].wwww, reg_tmp8);
    // 162: mul
    reg_tmp9 = mul_safe(uniforms.f[89].xxxx, reg_tmp2);
    // 163: mad
    reg_tmp9 = fma_safe(reg_tmp3, uniforms.f[89].yyyy, reg_tmp9);
    // 164: mad
    reg_tmp9 = fma_safe(reg_tmp4, uniforms.f[89].zzzz, reg_tmp9);
    // 165: mad
    reg_tmp9 = fma_safe(reg_tmp5, uniforms.f[89].wwww, reg_tmp9);
    return false;
}
bool sub_167_259() {
    // 167: rcp
    reg_tmp2.x = rcp_safe(uniforms.f[81].yyyy.x);
    // 168: mul
    reg_tmp2.xy = (mul_safe(uniforms.f[2 + address_registers.x].zwww, reg_tmp2.xxxx)).xy;
    // 169: add
    reg_tmp2.xy = (uniforms.f[0].yyyy + reg_tmp2.xyyy).xy;
    // 170: flr
    reg_tmp3.xy = (floor(reg_tmp2.xyyy)).xy;
    // 171: mul
    reg_tmp2.xy = (mul_safe(uniforms.f[81].yyyy, reg_tmp3.xyyy)).xy;
    // 172: add
    reg_tmp2.xy = (uniforms.f[2 + address_registers.x].zwww + -reg_tmp2.xyyy).xy;
    // 173: min
    reg_tmp0.xy = (min(uniforms.f[81].xxxx, -reg_tmp2.xyyy)).xy;
    // 174: max
    reg_tmp0.xy = (max(-uniforms.f[81].xxxx, reg_tmp0.xyyy)).xy;
    // 175: mov
    reg_tmp2 = uniforms.f[95];
    // 176: mov
    reg_tmp3 = uniforms.f[94];
    // 177: mul
    reg_tmp1.z = (mul_safe(reg_tmp0.xxxx, reg_tmp0.xxxx)).z;
    // 178: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 179: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 180: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 181: mov
    reg_tmp2 = uniforms.f[93];
    // 182: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 183: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 184: mul
    reg_tmp1.y = (mul_safe(reg_tmp1.yyyy, reg_tmp0.xxxx)).y;
    // 185: mov
    reg_tmp5.x = (uniforms.f[5 + address_registers.x].wwww).x;
    // 186: mov
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    // 187: mov
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    // 188: cmp
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    // 189: ifc
    if (conditional_code.x) {
        sub_190_192();
    }
    // 192: cmp
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    // 193: ifc
    if (conditional_code.x) {
        sub_194_195();
    }
    // 195: cmp
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 196: ifc
    if (conditional_code.x) {
        sub_197_198();
    }
    // 198: cmp
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 199: ifc
    if (conditional_code.x) {
        sub_200_202();
    }
    // 202: mul
    reg_tmp4.xy = (mul_safe(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    // 203: mad
    reg_tmp4.x = (fma_safe(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    // 204: mad
    reg_tmp4.y = (fma_safe(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    // 205: add
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    // 206: add
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    // 207: mov
    reg_tmp4.z = (uniforms.f[83].xxxx).z;
    // 208: mov
    reg_tmp4.w = (-uniforms.f[83].yyyy).w;
    // 209: madi
    reg_tmp5.xy = (fma_safe(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[3 + address_registers.x].xyyy)).xy;
    // 210: mov
    reg_tmp4.z = (-uniforms.f[3 + address_registers.x].zzzz).z;
    // 211: mov
    reg_tmp4.w = (-uniforms.f[3 + address_registers.x].wwww).w;
    // 212: add
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    // 213: add
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    // 214: mad
    reg_tmp5.x = (fma_safe(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    // 215: mad
    reg_tmp5.y = (fma_safe(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    // 216: mov
    reg_tmp11.xy = (reg_tmp5.xyyy).xy;
    // 217: mov
    reg_tmp2 = uniforms.f[95];
    // 218: mov
    reg_tmp3 = uniforms.f[94];
    // 219: mul
    reg_tmp1.z = (mul_safe(reg_tmp0.yyyy, reg_tmp0.yyyy)).z;
    // 220: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 221: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 222: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 223: mov
    reg_tmp2 = uniforms.f[93];
    // 224: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 225: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 226: mul
    reg_tmp1.y = (mul_safe(reg_tmp1.yyyy, reg_tmp0.yyyy)).y;
    // 227: mov
    reg_tmp5.x = (uniforms.f[6 + address_registers.x].wwww).x;
    // 228: mov
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    // 229: mov
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    // 230: cmp
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    // 231: ifc
    if (conditional_code.x) {
        sub_232_234();
    }
    // 234: cmp
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    // 235: ifc
    if (conditional_code.x) {
        sub_236_237();
    }
    // 237: cmp
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 238: ifc
    if (conditional_code.x) {
        sub_239_240();
    }
    // 240: cmp
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 241: ifc
    if (conditional_code.x) {
        sub_242_244();
    }
    // 244: mul
    reg_tmp4.xy = (mul_safe(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    // 245: mad
    reg_tmp4.x = (fma_safe(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    // 246: mad
    reg_tmp4.y = (fma_safe(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    // 247: add
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    // 248: add
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    // 249: mov
    reg_tmp4.z = (uniforms.f[83].zzzz).z;
    // 250: mov
    reg_tmp4.w = (-uniforms.f[83].wwww).w;
    // 251: madi
    reg_tmp5.xy = (fma_safe(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[4 + address_registers.x].xyyy)).xy;
    // 252: mov
    reg_tmp4.z = (-uniforms.f[4 + address_registers.x].zzzz).z;
    // 253: mov
    reg_tmp4.w = (-uniforms.f[4 + address_registers.x].wwww).w;
    // 254: add
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    // 255: add
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    // 256: mad
    reg_tmp5.x = (fma_safe(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    // 257: mad
    reg_tmp5.y = (fma_safe(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    // 258: mov
    reg_tmp12.xy = (reg_tmp5.xyyy).xy;
    return false;
}
bool sub_190_192() {
    // 190: mov
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    // 191: mov
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_194_195() {
    // 194: mov
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_197_198() {
    // 197: mov
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_200_202() {
    // 200: mov
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    // 201: mov
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_232_234() {
    // 232: mov
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    // 233: mov
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_236_237() {
    // 236: mov
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_239_240() {
    // 239: mov
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_242_244() {
    // 242: mov
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    // 243: mov
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_260_4096() {
    // 260: call
    {
        sub_0_8();
    }
    // 261: add
    reg_tmp10.xy = (uniforms.f[84].xyyy + reg_tmp10.xyyy).xy;
    // 262: mul
    reg_tmp10.xy = (mul_safe(uniforms.f[2 + address_registers.x].xyyy, reg_tmp10.xyyy)).xy;
    // 263: mov
    reg_tmp2 = reg_tmp10.xzyw;
    // 264: mov
    reg_tmp2.z = (-reg_tmp2.zzzz).z;
    // 265: mov
    reg_tmp14 = reg_tmp2;
    // 266: mov
    reg_tmp0 = uniforms.f[7 + address_registers.x];
    // 267: call
    {
        sub_33_96();
    }
    // 268: dp4
    reg_tmp2.x = dot(reg_tmp14, reg_tmp6);
    // 269: dp4
    reg_tmp2.y = dot(reg_tmp14, reg_tmp7);
    // 270: dp4
    reg_tmp2.z = dot(reg_tmp14, reg_tmp8);
    // 271: dp4
    reg_tmp2.w = dot(reg_tmp14, reg_tmp9);
    // 272: mov
    reg_tmp6 = uniforms.f[8 + address_registers.x];
    // 273: mov
    reg_tmp7 = uniforms.f[9 + address_registers.x];
    // 274: mov
    reg_tmp8 = uniforms.f[10 + address_registers.x];
    // 275: mov
    reg_tmp9 = uniforms.f[0].xxxz;
    // 276: mov
    reg_tmp6.w = (uniforms.f[5 + address_registers.x].xxxx).w;
    // 277: mov
    reg_tmp7.w = (uniforms.f[5 + address_registers.x].yyyy).w;
    // 278: mov
    reg_tmp8.w = (uniforms.f[5 + address_registers.x].zzzz).w;
    // 279: dp4
    reg_tmp10.x = dot(reg_tmp2, reg_tmp6);
    // 280: dp4
    reg_tmp10.y = dot(reg_tmp2, reg_tmp7);
    // 281: dp4
    reg_tmp10.z = dot(reg_tmp2, reg_tmp8);
    // 282: dp4
    reg_tmp10.w = dot(reg_tmp2, reg_tmp9);
    // 283: mov
    reg_tmp3.xyz = (uniforms.f[5 + address_registers.x].xyzz).xyz;
    // 284: add
    reg_tmp3.xyz = (uniforms.f[85].xyzz + -reg_tmp3.xyzz).xyz;
    // 285: dp3
    reg_tmp4.x = dot(vec3(reg_tmp3.xyzz), vec3(reg_tmp3.xyzz));
    // 286: cmp
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
    // 287: ifc
    if (conditional_code.x) {
        sub_288_289();
    } else {
        sub_289_290();
    }
    // 290: mul
    reg_tmp3.xyz = (mul_safe(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
    // 291: mad
    reg_tmp10.xyz = (fma_safe(reg_tmp3.xyzz, uniforms.f[84].zzzz, reg_tmp10.xyzz)).xyz;
    // 292: call
    {
        sub_146_166();
    }
    // 293: mov
    reg_tmp2 = reg_tmp10;
    // 294: dp4
    reg_tmp10.x = dot(reg_tmp2, reg_tmp6);
    // 295: dp4
    reg_tmp10.y = dot(reg_tmp2, reg_tmp7);
    // 296: dp4
    reg_tmp10.z = dot(reg_tmp2, reg_tmp8);
    // 297: dp4
    reg_tmp10.w = dot(reg_tmp2, reg_tmp9);
    // 298: mov
    reg_tmp2 = uniforms.f[1 + address_registers.x];
    // 299: max
    reg_tmp3 = max(uniforms.f[0].xxxx, reg_tmp2);
    // 300: min
    reg_tmp2 = min(uniforms.f[0].zzzz, reg_tmp3);
    // 301: mov
    reg_tmp13 = reg_tmp2;
    // 302: call
    {
        sub_167_259();
    }
    // 303: call
    {
        sub_9_32();
    }
    // 304: end
    return true;
}
bool sub_288_289() {
    // 288: mov
    reg_tmp4.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_289_290() {
    // 289: rsq
    reg_tmp4.x = rsq_safe(reg_tmp4.xxxx.x);
    return false;
}
// reference: 4CC1983EC9000EA4, 01CD144CA8DEFCA2
// program: 01CD144CA8DEFCA2, CEF02063E9A18B2F, C0234F4E2DEC3D4D
// reference: FB5F0D021DB318B6, D82E12A9D19ACD63
// reference: 9FB0D2FE561A2D2F, B8A2CA3DB47999BF
// reference: 145005518FD12E9D, B8A2CA3DB47999BF
// reference: 3396E636CC09FC61, D3C285AB726883C8
// reference: 3960829341490D38, 3295BFC9E1117A37
// reference: 7C68B52B9EBF3AA5, 734B56B7CFCD3D95
// reference: 4FE152B974078351, D82E12A9D19ACD63
// reference: E2ACA83AB2C172CA, 5447A3297E824FE0
// reference: 694C7F956B0A7178, 5447A3297E824FE0
// reference: 93E77089BCADC215, B543C911C8D7EAAB
// reference: F039E5993D4F5025, B8A2CA3DB47999BF
// reference: 7BD9323664E00014, B8A2CA3DB47999BF
// reference: 1F36EDCAF35884D2, D82E12A9D19ACD63
// reference: 1F36EDCA733CD751, D82E12A9D19ACD63
// reference: FFD83159CDE64D8F, DEFAC6F185DB6EB9
// reference: 2BF16BE738CB5642, 48B3A6FBA8498826
// reference: 2BF16BE70E39C6B1, 48B3A6FBA8498826
// reference: 3976164550A36299, F70C4BC6991FAFE8
// reference: 397616456651F26A, F70C4BC6991FAFE8
// reference: 84B5F9A0D6819D46, 65138AC5CA635BBF
// reference: 49FBBD4239D78153, DEFAC6F185DB6EB9
// reference: 49FBBD420F2511A0, DEFAC6F185DB6EB9
// shader: 8B31, BE941576D67F1D56

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define fma_safe(x, y, z) fma(x, y, z)
#define mul_safe(x, y) (x * y)
#define rcp_safe(x) (1.0f / x)
#define rsq_safe(x) inversesqrt(x)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_8();
bool sub_9_32();
bool sub_146_166();
bool sub_167_259();
bool sub_190_192();
bool sub_194_195();
bool sub_197_198();
bool sub_200_202();
bool sub_232_234();
bool sub_236_237();
bool sub_239_240();
bool sub_242_244();
bool sub_260_4096();
bool sub_281_282();
bool sub_282_283();

bool exec_shader() {
    sub_260_4096();
    return true;
}

bool sub_0_8() {
    // 0: mova
    address_registers.x = (ivec2(vs_in_reg0.zzzz)).x;
    // 1: mov
    reg_tmp10 = uniforms.f[0].xxxz;
    // 2: mov
    reg_tmp10.xy = (vs_in_reg0.xyyy).xy;
    // 3: mov
    reg_tmp11 = uniforms.f[0].xxxx;
    // 4: mov
    reg_tmp12 = uniforms.f[0].xxxx;
    // 5: mov
    reg_tmp13 = uniforms.f[0].zzzz;
    // 6: mov
    reg_tmp4 = uniforms.f[0].xxxx;
    // 7: mov
    reg_tmp5 = uniforms.f[0].xxxx;
    return false;
}
bool sub_9_32() {
    // 9: mov
    vs_out_attr0 = reg_tmp10;
    // 10: mul
    reg_tmp13 = mul_safe(uniforms.f[82], reg_tmp13);
    // 11: mov
    vs_out_attr1 = reg_tmp13;
    // 12: add
    reg_tmp11.y = (uniforms.f[0].zzzz + -reg_tmp11.yyyy).y;
    // 13: add
    reg_tmp12.y = (uniforms.f[0].zzzz + -reg_tmp12.yyyy).y;
    // 14: mov
    reg_tmp14.y = (uniforms.f[81].wwww).y;
    // 15: mul
    reg_tmp14.x = (mul_safe(uniforms.f[0].wwww, reg_tmp14.yyyy)).x;
    // 16: rcp
    reg_tmp2.x = rcp_safe(reg_tmp14.xxxx.x);
    // 17: mov
    reg_tmp14.z = (reg_tmp2.xxxx).z;
    // 18: add
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp11.xyyy).xy;
    // 19: mul
    reg_tmp5.xy = (mul_safe(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    // 20: flr
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    // 21: mul
    reg_tmp4.xy = (mul_safe(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    // 22: add
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    // 23: add
    reg_tmp11.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    // 24: add
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp12.xyyy).xy;
    // 25: mul
    reg_tmp5.xy = (mul_safe(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    // 26: flr
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    // 27: mul
    reg_tmp4.xy = (mul_safe(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    // 28: add
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    // 29: add
    reg_tmp12.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    // 30: mov
    vs_out_attr2 = reg_tmp11;
    // 31: mov
    vs_out_attr3 = reg_tmp12;
    return false;
}
bool sub_146_166() {
    // 146: mov
    reg_tmp2 = uniforms.f[90];
    // 147: mov
    reg_tmp3 = uniforms.f[91];
    // 148: mov
    reg_tmp4 = uniforms.f[92];
    // 149: mov
    reg_tmp5 = uniforms.f[0].xxxz;
    // 150: mul
    reg_tmp6 = mul_safe(uniforms.f[86].xxxx, reg_tmp2);
    // 151: mad
    reg_tmp6 = fma_safe(reg_tmp3, uniforms.f[86].yyyy, reg_tmp6);
    // 152: mad
    reg_tmp6 = fma_safe(reg_tmp4, uniforms.f[86].zzzz, reg_tmp6);
    // 153: mad
    reg_tmp6 = fma_safe(reg_tmp5, uniforms.f[86].wwww, reg_tmp6);
    // 154: mul
    reg_tmp7 = mul_safe(uniforms.f[87].xxxx, reg_tmp2);
    // 155: mad
    reg_tmp7 = fma_safe(reg_tmp3, uniforms.f[87].yyyy, reg_tmp7);
    // 156: mad
    reg_tmp7 = fma_safe(reg_tmp4, uniforms.f[87].zzzz, reg_tmp7);
    // 157: mad
    reg_tmp7 = fma_safe(reg_tmp5, uniforms.f[87].wwww, reg_tmp7);
    // 158: mul
    reg_tmp8 = mul_safe(uniforms.f[88].xxxx, reg_tmp2);
    // 159: mad
    reg_tmp8 = fma_safe(reg_tmp3, uniforms.f[88].yyyy, reg_tmp8);
    // 160: mad
    reg_tmp8 = fma_safe(reg_tmp4, uniforms.f[88].zzzz, reg_tmp8);
    // 161: mad
    reg_tmp8 = fma_safe(reg_tmp5, uniforms.f[88].wwww, reg_tmp8);
    // 162: mul
    reg_tmp9 = mul_safe(uniforms.f[89].xxxx, reg_tmp2);
    // 163: mad
    reg_tmp9 = fma_safe(reg_tmp3, uniforms.f[89].yyyy, reg_tmp9);
    // 164: mad
    reg_tmp9 = fma_safe(reg_tmp4, uniforms.f[89].zzzz, reg_tmp9);
    // 165: mad
    reg_tmp9 = fma_safe(reg_tmp5, uniforms.f[89].wwww, reg_tmp9);
    return false;
}
bool sub_167_259() {
    // 167: rcp
    reg_tmp2.x = rcp_safe(uniforms.f[81].yyyy.x);
    // 168: mul
    reg_tmp2.xy = (mul_safe(uniforms.f[2 + address_registers.x].zwww, reg_tmp2.xxxx)).xy;
    // 169: add
    reg_tmp2.xy = (uniforms.f[0].yyyy + reg_tmp2.xyyy).xy;
    // 170: flr
    reg_tmp3.xy = (floor(reg_tmp2.xyyy)).xy;
    // 171: mul
    reg_tmp2.xy = (mul_safe(uniforms.f[81].yyyy, reg_tmp3.xyyy)).xy;
    // 172: add
    reg_tmp2.xy = (uniforms.f[2 + address_registers.x].zwww + -reg_tmp2.xyyy).xy;
    // 173: min
    reg_tmp0.xy = (min(uniforms.f[81].xxxx, -reg_tmp2.xyyy)).xy;
    // 174: max
    reg_tmp0.xy = (max(-uniforms.f[81].xxxx, reg_tmp0.xyyy)).xy;
    // 175: mov
    reg_tmp2 = uniforms.f[95];
    // 176: mov
    reg_tmp3 = uniforms.f[94];
    // 177: mul
    reg_tmp1.z = (mul_safe(reg_tmp0.xxxx, reg_tmp0.xxxx)).z;
    // 178: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 179: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 180: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 181: mov
    reg_tmp2 = uniforms.f[93];
    // 182: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 183: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 184: mul
    reg_tmp1.y = (mul_safe(reg_tmp1.yyyy, reg_tmp0.xxxx)).y;
    // 185: mov
    reg_tmp5.x = (uniforms.f[5 + address_registers.x].wwww).x;
    // 186: mov
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    // 187: mov
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    // 188: cmp
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    // 189: ifc
    if (conditional_code.x) {
        sub_190_192();
    }
    // 192: cmp
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    // 193: ifc
    if (conditional_code.x) {
        sub_194_195();
    }
    // 195: cmp
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 196: ifc
    if (conditional_code.x) {
        sub_197_198();
    }
    // 198: cmp
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 199: ifc
    if (conditional_code.x) {
        sub_200_202();
    }
    // 202: mul
    reg_tmp4.xy = (mul_safe(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    // 203: mad
    reg_tmp4.x = (fma_safe(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    // 204: mad
    reg_tmp4.y = (fma_safe(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    // 205: add
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    // 206: add
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    // 207: mov
    reg_tmp4.z = (uniforms.f[83].xxxx).z;
    // 208: mov
    reg_tmp4.w = (-uniforms.f[83].yyyy).w;
    // 209: madi
    reg_tmp5.xy = (fma_safe(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[3 + address_registers.x].xyyy)).xy;
    // 210: mov
    reg_tmp4.z = (-uniforms.f[3 + address_registers.x].zzzz).z;
    // 211: mov
    reg_tmp4.w = (-uniforms.f[3 + address_registers.x].wwww).w;
    // 212: add
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    // 213: add
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    // 214: mad
    reg_tmp5.x = (fma_safe(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    // 215: mad
    reg_tmp5.y = (fma_safe(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    // 216: mov
    reg_tmp11.xy = (reg_tmp5.xyyy).xy;
    // 217: mov
    reg_tmp2 = uniforms.f[95];
    // 218: mov
    reg_tmp3 = uniforms.f[94];
    // 219: mul
    reg_tmp1.z = (mul_safe(reg_tmp0.yyyy, reg_tmp0.yyyy)).z;
    // 220: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 221: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 222: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 223: mov
    reg_tmp2 = uniforms.f[93];
    // 224: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 225: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 226: mul
    reg_tmp1.y = (mul_safe(reg_tmp1.yyyy, reg_tmp0.yyyy)).y;
    // 227: mov
    reg_tmp5.x = (uniforms.f[6 + address_registers.x].wwww).x;
    // 228: mov
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    // 229: mov
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    // 230: cmp
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    // 231: ifc
    if (conditional_code.x) {
        sub_232_234();
    }
    // 234: cmp
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    // 235: ifc
    if (conditional_code.x) {
        sub_236_237();
    }
    // 237: cmp
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 238: ifc
    if (conditional_code.x) {
        sub_239_240();
    }
    // 240: cmp
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 241: ifc
    if (conditional_code.x) {
        sub_242_244();
    }
    // 244: mul
    reg_tmp4.xy = (mul_safe(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    // 245: mad
    reg_tmp4.x = (fma_safe(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    // 246: mad
    reg_tmp4.y = (fma_safe(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    // 247: add
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    // 248: add
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    // 249: mov
    reg_tmp4.z = (uniforms.f[83].zzzz).z;
    // 250: mov
    reg_tmp4.w = (-uniforms.f[83].wwww).w;
    // 251: madi
    reg_tmp5.xy = (fma_safe(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[4 + address_registers.x].xyyy)).xy;
    // 252: mov
    reg_tmp4.z = (-uniforms.f[4 + address_registers.x].zzzz).z;
    // 253: mov
    reg_tmp4.w = (-uniforms.f[4 + address_registers.x].wwww).w;
    // 254: add
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    // 255: add
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    // 256: mad
    reg_tmp5.x = (fma_safe(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    // 257: mad
    reg_tmp5.y = (fma_safe(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    // 258: mov
    reg_tmp12.xy = (reg_tmp5.xyyy).xy;
    return false;
}
bool sub_190_192() {
    // 190: mov
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    // 191: mov
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_194_195() {
    // 194: mov
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_197_198() {
    // 197: mov
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_200_202() {
    // 200: mov
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    // 201: mov
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_232_234() {
    // 232: mov
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    // 233: mov
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_236_237() {
    // 236: mov
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_239_240() {
    // 239: mov
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_242_244() {
    // 242: mov
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    // 243: mov
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_260_4096() {
    // 260: call
    {
        sub_0_8();
    }
    // 261: add
    reg_tmp10.xy = (uniforms.f[84].xyyy + reg_tmp10.xyyy).xy;
    // 262: mul
    reg_tmp10.xy = (mul_safe(uniforms.f[2 + address_registers.x].xyyy, reg_tmp10.xyyy)).xy;
    // 263: mov
    reg_tmp2 = reg_tmp10.xzyw;
    // 264: mov
    reg_tmp2.z = (-reg_tmp2.zzzz).z;
    // 265: mov
    reg_tmp6 = uniforms.f[8 + address_registers.x];
    // 266: mov
    reg_tmp7 = uniforms.f[9 + address_registers.x];
    // 267: mov
    reg_tmp8 = uniforms.f[10 + address_registers.x];
    // 268: mov
    reg_tmp9 = uniforms.f[0].xxxz;
    // 269: mov
    reg_tmp6.w = (uniforms.f[5 + address_registers.x].xxxx).w;
    // 270: mov
    reg_tmp7.w = (uniforms.f[5 + address_registers.x].yyyy).w;
    // 271: mov
    reg_tmp8.w = (uniforms.f[5 + address_registers.x].zzzz).w;
    // 272: dp4
    reg_tmp10.x = dot(reg_tmp2, reg_tmp6);
    // 273: dp4
    reg_tmp10.y = dot(reg_tmp2, reg_tmp7);
    // 274: dp4
    reg_tmp10.z = dot(reg_tmp2, reg_tmp8);
    // 275: dp4
    reg_tmp10.w = dot(reg_tmp2, reg_tmp9);
    // 276: mov
    reg_tmp3.xyz = (uniforms.f[5 + address_registers.x].xyzz).xyz;
    // 277: add
    reg_tmp3.xyz = (uniforms.f[85].xyzz + -reg_tmp3.xyzz).xyz;
    // 278: dp3
    reg_tmp4.x = dot(vec3(reg_tmp3.xyzz), vec3(reg_tmp3.xyzz));
    // 279: cmp
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
    // 280: ifc
    if (conditional_code.x) {
        sub_281_282();
    } else {
        sub_282_283();
    }
    // 283: mul
    reg_tmp3.xyz = (mul_safe(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
    // 284: mad
    reg_tmp10.xyz = (fma_safe(reg_tmp3.xyzz, uniforms.f[84].zzzz, reg_tmp10.xyzz)).xyz;
    // 285: call
    {
        sub_146_166();
    }
    // 286: mov
    reg_tmp2 = reg_tmp10;
    // 287: dp4
    reg_tmp10.x = dot(reg_tmp2, reg_tmp6);
    // 288: dp4
    reg_tmp10.y = dot(reg_tmp2, reg_tmp7);
    // 289: dp4
    reg_tmp10.z = dot(reg_tmp2, reg_tmp8);
    // 290: dp4
    reg_tmp10.w = dot(reg_tmp2, reg_tmp9);
    // 291: mov
    reg_tmp2 = uniforms.f[1 + address_registers.x];
    // 292: max
    reg_tmp3 = max(uniforms.f[0].xxxx, reg_tmp2);
    // 293: min
    reg_tmp2 = min(uniforms.f[0].zzzz, reg_tmp3);
    // 294: mov
    reg_tmp13 = reg_tmp2;
    // 295: call
    {
        sub_167_259();
    }
    // 296: call
    {
        sub_9_32();
    }
    // 297: end
    return true;
}
bool sub_281_282() {
    // 281: mov
    reg_tmp4.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_282_283() {
    // 282: rsq
    reg_tmp4.x = rsq_safe(reg_tmp4.xxxx.x);
    return false;
}
// reference: 4A3713A3B56DF9A8, BE941576D67F1D56
// program: BE941576D67F1D56, CEF02063E9A18B2F, C0234F4E2DEC3D4D
// reference: 4CC1983ECB72AC51, 01CD144CA8DEFCA2
// reference: 7F487FAC21CA15A5, D82E12A9D19ACD63
// reference: C3A9F320B2C172CA, 5447A3297E824FE0
// reference: 4849248F6B0A7178, 5447A3297E824FE0
// reference: 315DF466BCADC215, B543C911C8D7EAAB
// reference: 528361763D4F5025, B8A2CA3DB47999BF
// reference: D963B6D964E00014, B8A2CA3DB47999BF
// reference: BD8C6925F35884D2, D82E12A9D19ACD63
// reference: BD8C6925733CD751, D82E12A9D19ACD63
// reference: 5D62B5B6CDE64D8F, DEFAC6F185DB6EB9
// reference: B6180B7538CB5642, 48B3A6FBA8498826
// reference: B6180B750E39C6B1, 48B3A6FBA8498826
// reference: A49F76D750A36299, F70C4BC6991FAFE8
// reference: A49F76D76651F26A, F70C4BC6991FAFE8
// reference: 195C9932D6819D46, 65138AC5CA635BBF
// reference: D412DDD039D78153, DEFAC6F185DB6EB9
// reference: D412DDD00F2511A0, DEFAC6F185DB6EB9
// reference: 7C68B52B8779A332, 7CBFDF058AA76880
// reference: CBF6201753CAB520, D82E12A9D19ACD63
// reference: AF19FFEB186380B9, B8A2CA3DB47999BF
// reference: 24F92844C1A8830B, B8A2CA3DB47999BF
// reference: 033FCB234096432E, D3C285AB726883C8
// reference: 4A3713A3FC2615CD, BE941576D67F1D56
// reference: 7C68B52B850B01C7, 7CBFDF058AA76880
// reference: 4FE152B96FB3B833, D82E12A9D19ACD63
// reference: 10F98FC538CB5642, 48B3A6FBA8498826
// reference: 10F98FC50E39C6B1, 48B3A6FBA8498826
// reference: 027EF26750A36299, F70C4BC6991FAFE8
// reference: 027EF2676651F26A, F70C4BC6991FAFE8
// reference: BFBD1D82D6819D46, 65138AC5CA635BBF
// reference: 72F3596039D78153, DEFAC6F185DB6EB9
// reference: 72F359600F2511A0, DEFAC6F185DB6EB9
// reference: F7886284A63251C9, 734B56B7CFCD3D95
// reference: BB8059D4F039D468, 52F15AB07872CB3F
// reference: 48FDFEF9E964C139, 7CBFDF058AA76880
// reference: FF636BC53DD7D72B, D82E12A9D19ACD63
// reference: 9B8CB439767EE2B2, B8A2CA3DB47999BF
// reference: 106C6396AFB5E100, B8A2CA3DB47999BF
// reference: 7483BC6AE41CD499, D82E12A9D19ACD63
// reference: AF8C13B8E372F705, 48B3A6FBA8498826
// shader: 8B30, 429F43F1A9E29E68

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].aaa) + (texcolor1.rgb) * (vec3(1.0) - (const_color[0].aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a) + (texcolor1.a) * (1.0 - (const_color[0].a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (vec3(1.0) - texcolor2.aaa), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) + (texcolor2.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) * (texcolor2.aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 4877F5A63D5E2725, 429F43F1A9E29E68
// program: 48B3A6FBA8498826, AD7922A63ED54CA7, 429F43F1A9E29E68
// shader: 8B30, 5F79CBDEF448D5B1

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0 * 2.0, alpha_output_0 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 72E7F62E36239C05, 5F79CBDEF448D5B1
// program: DEFAC6F185DB6EB9, 6CF3F3B70E23AA85, 5F79CBDEF448D5B1
// reference: 7F4A72FEAB59617F, D3C285AB726883C8
// reference: C31D2956F8024BFC, 734B56B7CFCD3D95
// reference: 4CC1983E742408CD, 01CD144CA8DEFCA2
// reference: 7C68B52B3A5DA55B, 7CBFDF058AA76880
// reference: 4FE152B9D0E51CAF, D82E12A9D19ACD63
// reference: E2ACA83AE34B824E, 5447A3297E824FE0
// reference: 694C7F9538F22309, 5447A3297E824FE0
// reference: 93E77089FEABFD0E, B543C911C8D7EAAB
// reference: F039E5997D3BCDCB, B8A2CA3DB47999BF
// reference: 7BD9323624949DFA, B8A2CA3DB47999BF
// reference: 1F36EDCAB32C193C, D82E12A9D19ACD63
// reference: 1F36EDCA33484ABF, D82E12A9D19ACD63
// reference: FFD831598D92D061, DEFAC6F185DB6EB9
// reference: 7483BC6AA5F698AF, D82E12A9D19ACD63
// reference: 9484F79AE372F705, 48B3A6FBA8498826
// reference: 444296DCAB59617F, D3C285AB726883C8
// reference: 48FDFEF96251A68D, 7CBFDF058AA76880
// reference: 7B74196B88E91F79, D82E12A9D19ACD63
// reference: 5DD9344738F22309, 5447A3297E824FE0
// reference: A7723B5BFEABFD0E, B543C911C8D7EAAB
// reference: C4ACAE4B7D3BCDCB, B8A2CA3DB47999BF
// reference: 4F4C79E424949DFA, B8A2CA3DB47999BF
// reference: 2BA3A618B32C193C, D82E12A9D19ACD63
// reference: 2BA3A61833484ABF, D82E12A9D19ACD63
// reference: CB4D7A8B8D92D061, DEFAC6F185DB6EB9
// reference: 7B74196BC903534F, D82E12A9D19ACD63
// reference: 28109775AB59617F, D3C285AB726883C8
// reference: 32C7DE9D673A41FD, D3C285AB726883C8
// shader: 8B30, DEAA053775D715AE

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D4F4BEF9AC6381F1, DEAA053775D715AE
// program: D3C285AB726883C8, 4BD70AD09292A3DA, DEAA053775D715AE
// reference: B9270932BEF1424F, D3C285AB726883C8
// reference: 0BEBBED1C13493D7, DEFAC6F185DB6EB9
// shader: 8B30, E5E20FDB7C815129

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) + (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: B2E70C86329080AB, E5E20FDB7C815129
// program: DEFAC6F185DB6EB9, 6CF3F3B70E23AA85, E5E20FDB7C815129
// reference: 108074773EE2589E, C59EA4758EB9FB8A
// shader: 8B30, 02AD7BCFB15AD22C

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D4F4BEF973807F5E, 02AD7BCFB15AD22C
// program: DEFAC6F185DB6EB9, 6CF3F3B70E23AA85, 02AD7BCFB15AD22C
// reference: B4E7E57B5E0490E1, D82E12A9D19ACD63
// reference: AD35A81B38F22309, 5447A3297E824FE0
// reference: 47CE0FB0FEABFD0E, B543C911C8D7EAAB
// reference: CB1F92F333484ABF, D82E12A9D19ACD63
// reference: AE30AC9390151296, D82E12A9D19ACD63
// reference: F74BED412771C6D7, F8064BC04B6228AD
// reference: F74BED41EC9E41F0, F8064BC04B6228AD
// reference: E76B3F005AFC855B, 3295BFC9E1117A37
// reference: 37AA80F1B64F524A, D3C285AB726883C8
// reference: AB5DF2FF41600121, D82E12A9D19ACD63
// reference: F74BED414C94A837, DC9976EED0CC7E67
// program: DC9976EED0CC7E67, CEF02063E9A18B2F, C0234F4E2DEC3D4D
// reference: DFA0166EE964C139, 7CBFDF058AA76880
// reference: B2B7945E06C6B817, 1BE8D5DEECF8172C
// reference: F74BED41DC21D388, F8064BC04B6228AD
// program: F8064BC04B6228AD, CEF02063E9A18B2F, C0234F4E2DEC3D4D
// reference: 4CC1983E09170DD2, 01CD144CA8DEFCA2
// reference: 7C68B52B476EA044, 7CBFDF058AA76880
// reference: 3A13AB6F24FD3087, DEFAC6F185DB6EB9
// reference: 117F371B06C6B817, 1BE8D5DEECF8172C
// reference: 7C68B52B1BE860DA, 734B56B7CFCD3D95
// reference: CBF62017CF5B76C8, D82E12A9D19ACD63
// reference: AF19FFEB84F24351, B8A2CA3DB47999BF
// reference: 24F928445D3940E3, B8A2CA3DB47999BF
// reference: 4016F7B81690757A, D82E12A9D19ACD63
// reference: 033FCB230529BF9F, D3C285AB726883C8
// reference: 9FC8B92DF206ECF4, D82E12A9D19ACD63
// reference: E2ACA83ADBC5728B, 5447A3297E824FE0
// reference: 694C7F95020E7139, 5447A3297E824FE0
// reference: 635646A99897C165, DD35FB9CAEB223CF
// reference: 01EC2DEE429011F2, 9FB407F1EC1D74B1
// reference: 635646A95D6AFB67, DD35FB9CAEB223CF
// reference: A6E1A227D275AE05, D82E12A9D19ACD63
// reference: C20E7DDB99DC9B9C, B8A2CA3DB47999BF
// reference: 49EEAA744017982E, B8A2CA3DB47999BF
// reference: 2D0175880BBEADB7, D82E12A9D19ACD63
// reference: AFE949A5201B4306, D3C285AB726883C8
// reference: 331E3BABD734106D, D82E12A9D19ACD63
// reference: 4E7A2ABCDBC5728B, 5447A3297E824FE0
// reference: C59AFD13020E7139, 5447A3297E824FE0
// reference: 3F31F20FBCADC215, B543C911C8D7EAAB
// reference: 5CEF671F3D4F5025, B8A2CA3DB47999BF
// reference: D70FB0B064E00014, B8A2CA3DB47999BF
// reference: B3E06F4CF35884D2, D82E12A9D19ACD63
// reference: B3E06F4C733CD751, D82E12A9D19ACD63
// reference: 530EB3DFCDE64D8F, DEFAC6F185DB6EB9
// reference: 445C69675B0C0A33, 95AC54D58E4F10E1
// reference: DD3BEAE2F48F9D50, 163CE5AA2AAAB87B
// reference: 4A43786D5B49083C, ED9AAA1E39CE1504
// reference: 296D6B1006C6B817, 1BE8D5DEECF8172C
// reference: 0ABA867AA8628FC8, DEFAC6F185DB6EB9
// reference: B79EB3AB06C6B817, 1BE8D5DEECF8172C
// reference: 00002697D275AE05, D82E12A9D19ACD63
// reference: 64EFF96B99DC9B9C, B8A2CA3DB47999BF
// reference: EF0F2EC44017982E, B8A2CA3DB47999BF
// reference: 8BE0F1380BBEADB7, D82E12A9D19ACD63
// reference: 0908CD15201B4306, D3C285AB726883C8
// reference: 95FFBF1BD734106D, D82E12A9D19ACD63
// reference: E89BAE0CDBC5728B, 5447A3297E824FE0
// reference: 637B79A3020E7139, 5447A3297E824FE0
// reference: 99D076BFBCADC215, B543C911C8D7EAAB
// reference: FA0EE3AF3D4F5025, B8A2CA3DB47999BF
// reference: 71EE340064E00014, B8A2CA3DB47999BF
// reference: 1501EBFCF35884D2, D82E12A9D19ACD63
// reference: 1501EBFC733CD751, D82E12A9D19ACD63
// reference: F5EF376FCDE64D8F, DEFAC6F185DB6EB9
// reference: EF093B7B09170DD2, 01CD144CA8DEFCA2
// reference: 145610EE06C6B817, 1BE8D5DEECF8172C
// reference: A3C885D2D275AE05, D82E12A9D19ACD63
// reference: C7275A2E99DC9B9C, B8A2CA3DB47999BF
// reference: 4CC78D814017982E, B8A2CA3DB47999BF
// reference: 2828527D0BBEADB7, D82E12A9D19ACD63
// reference: AAC06E50201B4306, D3C285AB726883C8
// reference: 36371C5ED734106D, D82E12A9D19ACD63
// reference: 4B530D49DBC5728B, 5447A3297E824FE0
// reference: C0B3DAE6020E7139, 5447A3297E824FE0
// reference: 3A18D5FABCADC215, B543C911C8D7EAAB
// reference: 59C640EA3D4F5025, B8A2CA3DB47999BF
// reference: D226974564E00014, B8A2CA3DB47999BF
// reference: B6C948B9F35884D2, D82E12A9D19ACD63
// reference: B6C948B9733CD751, D82E12A9D19ACD63
// reference: 5627942ACDE64D8F, DEFAC6F185DB6EB9
// reference: 15D0A83038CB5642, 48B3A6FBA8498826
// reference: 15D0A8300E39C6B1, 48B3A6FBA8498826
// reference: 0757D59250A36299, F70C4BC6991FAFE8
// reference: 0757D5926651F26A, F70C4BC6991FAFE8
// reference: BA943A77D6819D46, 65138AC5CA635BBF
// reference: 77DA7E9539D78153, DEFAC6F185DB6EB9
// reference: 77DA7E950F2511A0, DEFAC6F185DB6EB9
// reference: 7C68B52BBD9CF3F8, 734B56B7CFCD3D95
// reference: CBF62017692FE5EA, D82E12A9D19ACD63
// reference: AF19FFEB2286D073, B8A2CA3DB47999BF
// reference: 24F92844FB4DD3C1, B8A2CA3DB47999BF
// reference: 4016F7B8B0E4E658, D82E12A9D19ACD63
// reference: 033FCB23A35D2CBD, D3C285AB726883C8
// reference: 9FC8B92D54727FD6, D82E12A9D19ACD63
// reference: F74BED418F506726, DC9976EED0CC7E67
// reference: DFA0166EE345C056, 7CBFDF058AA76880
// reference: 85D154476C0E15A8, 3295BFC9E1117A37
// reference: 9EF3FE2CD275AE05, D82E12A9D19ACD63
// reference: FA1C21D099DC9B9C, B8A2CA3DB47999BF
// reference: 71FCF67F4017982E, B8A2CA3DB47999BF
// reference: 151329830BBEADB7, D82E12A9D19ACD63
// reference: 97FB15AE201B4306, D3C285AB726883C8
// reference: 0B0C67A0D734106D, D82E12A9D19ACD63
// reference: 766876B7DBC5728B, 5447A3297E824FE0
// reference: FD88A118020E7139, 5447A3297E824FE0
// reference: 0723AE04BCADC215, B543C911C8D7EAAB
// reference: 64FD3B143D4F5025, B8A2CA3DB47999BF
// reference: EF1DECBB64E00014, B8A2CA3DB47999BF
// reference: 8BF23347F35884D2, D82E12A9D19ACD63
// reference: 8BF23347733CD751, D82E12A9D19ACD63
// reference: 6B1CEFD4CDE64D8F, DEFAC6F185DB6EB9
// reference: EA07AA3338CB5642, 48B3A6FBA8498826
// reference: EA07AA330E39C6B1, 48B3A6FBA8498826
// reference: F880D79150A36299, F70C4BC6991FAFE8
// reference: F880D7916651F26A, F70C4BC6991FAFE8
// reference: 45433874D6819D46, 65138AC5CA635BBF
// reference: 880D7C9639D78153, DEFAC6F185DB6EB9
// reference: 880D7C960F2511A0, DEFAC6F185DB6EB9
// reference: 45D6548FEE0CA316, D82E12A9D19ACD63
// reference: 19C2EC7C5B49083C, C0234F4E2DEC3D4D
// reference: 2AE82DCAA8E90B24, EA83856FEB3CAEC2
// reference: A972253FA8628FC8, DEFAC6F185DB6EB9
// reference: 2983DF1754A3367E, 7CBFDF058AA76880
// reference: 18BC3D035E9DAA15, EE0B6065741A8CB9
// reference: E76B3F00CC53737D, 3295BFC9E1117A37
// reference: 2983DF17D6728E74, 7CBFDF058AA76880
// reference: 635646A9CBC50D41, DD35FB9CAEB223CF
// reference: 18BC3D03686F3AE6, EE0B6065741A8CB9
// reference: E76B3F00FAA1E38E, 3295BFC9E1117A37
// reference: 635646A938CAA7B0, DD35FB9CAEB223CF
// reference: 01EC2DEEE2CD7727, 9FB407F1EC1D74B1
// reference: 635646A9FD379DB2, DD35FB9CAEB223CF
// reference: 7A0656445E9DAA15, EE0B6065741A8CB9
// reference: 85D15447CC53737D, 3295BFC9E1117A37
// shader: 8B30, 0F3087D7D9D433CA

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) + (const_color[0].a) - 0.5, 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0 * 1.0, alpha_output_0 * 2.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (last_tex_env_out.aaa), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (last_tex_env_out.aaa) + (texcolor0.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2 * 1.0, alpha_output_2 * 4.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rrr) + (last_tex_env_out.ggg), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 4D23DE006AF45A6D, 0F3087D7D9D433CA
// program: D82E12A9D19ACD63, 5D764F9A6220D694, 0F3087D7D9D433CA
// reference: D2E1B6E965172F46, D82E12A9D19ACD63
// reference: 23043D915D819B49, DEFAC6F185DB6EB9
// reference: 108074778C6EAF72, 35EA3527A49BC4B5
// reference: A8E4EA3E86383A0E, DEFAC6F185DB6EB9
// shader: 8B30, 9B69E3F71F5F6FC6

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: CE312E680B4EA6BC, 9B69E3F71F5F6FC6
// program: DEFAC6F185DB6EB9, 6CF3F3B70E23AA85, 9B69E3F71F5F6FC6
// reference: 865155D7DBB8A572, D82E12A9D19ACD63
// reference: 0DB1827800010435, D82E12A9D19ACD63
// reference: 9AA821D6211842C9, 3295BFC9E1117A37
// reference: 2D36B4EAC359C428, D82E12A9D19ACD63
// reference: A6D663452E12F59C, D82E12A9D19ACD63
// reference: DFA0166ECA6E4752, 734B56B7CFCD3D95
// reference: E3DE54FDC564F007, D82E12A9D19ACD63
// reference: 683E8352282FC1B3, D82E12A9D19ACD63
// reference: 03D91F0DE372F705, 48B3A6FBA8498826
// reference: 277D5AE5E0730DB5, 65138AC5CA635BBF
// reference: 8839C8A238CB5642, 48B3A6FBA8498826
// reference: EA331E0739D78153, DEFAC6F185DB6EB9
// reference: EA331E070F2511A0, DEFAC6F185DB6EB9
// reference: EF093B7B42D6983E, 01CD144CA8DEFCA2
// reference: D37779E84DDC2F6B, D82E12A9D19ACD63
// reference: 5897AE47A0971EDF, D82E12A9D19ACD63
// reference: 9E307F9FE372F705, 48B3A6FBA8498826
// reference: BA943A77E0730DB5, 65138AC5CA635BBF
// reference: E9FFB0E6A8F7683A, BE941576D67F1D56
// reference: DFA0166E0CAF35A8, 7CBFDF058AA76880
// reference: E3DE54FD03A582FD, D82E12A9D19ACD63
// reference: 683E8352EEEEB349, D82E12A9D19ACD63
// reference: 5440C1C1272576E6, 734B56B7CFCD3D95
// reference: 5440C1C1908C361C, 734B56B7CFCD3D95
// reference: 635646A9FA00A949, DD35FB9CAEB223CF
// reference: 2983DF17F65D6614, 734B56B7CFCD3D95
// reference: 15FD9D84F957D141, D82E12A9D19ACD63
// reference: 9E1D4A2B141CE0F5, D82E12A9D19ACD63
// reference: F5FAD674E372F705, 48B3A6FBA8498826
// reference: D15E939CE0730DB5, 65138AC5CA635BBF
// reference: E76B3F0011263AE5, 3295BFC9E1117A37
// reference: 635646A9D34D7EDB, DD35FB9CAEB223CF
// reference: 2983DF17171B0ECA, 734B56B7CFCD3D95
// reference: 15FD9D841811B99F, D82E12A9D19ACD63
// reference: 9E1D4A2BF55A882B, D82E12A9D19ACD63
// reference: DFA0166EDF9F4903, 7CBFDF058AA76880
// reference: 635646A92930D5E2, DD35FB9CAEB223CF
// reference: 2983DF17CA6E4752, 734B56B7CFCD3D95
// reference: 15FD9D84C564F007, D82E12A9D19ACD63
// reference: 9E1D4A2B282FC1B3, D82E12A9D19ACD63
// reference: 635646A98C80885D, DD35FB9CAEB223CF
// reference: E8B6910661CBB9E9, DD35FB9CAEB223CF
// reference: E8B691062AC0E4E0, DD35FB9CAEB223CF
// reference: 635646A9C78BD554, DD35FB9CAEB223CF
// shader: 8B30, FD5243D1FEFD5E87

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 9637A5311E3E9B72, FD5243D1FEFD5E87
// program: DEFAC6F185DB6EB9, 6CF3F3B70E23AA85, FD5243D1FEFD5E87
// reference: 2F8BFB9AD15F41DB, D896C1A0D13B6C62
// reference: 4A3713A3A8F7683A, BE941576D67F1D56
// program: BE941576D67F1D56, CEF02063E9A18B2F, EA83856FEB3CAEC2
// shader: 8B31, 5DC51233DD2793A1

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define fma_safe(x, y, z) fma(x, y, z)
#define mul_safe(x, y) (x * y)
#define rcp_safe(x) (1.0f / x)
#define rsq_safe(x) inversesqrt(x)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_8();
bool sub_9_32();
bool sub_114_142();
bool sub_146_166();
bool sub_167_259();
bool sub_190_192();
bool sub_194_195();
bool sub_197_198();
bool sub_200_202();
bool sub_232_234();
bool sub_236_237();
bool sub_239_240();
bool sub_242_244();
bool sub_260_4096();
bool sub_274_275();
bool sub_275_276();

bool exec_shader() {
    sub_260_4096();
    return true;
}

bool sub_0_8() {
    // 0: mova
    address_registers.x = (ivec2(vs_in_reg0.zzzz)).x;
    // 1: mov
    reg_tmp10 = uniforms.f[0].xxxz;
    // 2: mov
    reg_tmp10.xy = (vs_in_reg0.xyyy).xy;
    // 3: mov
    reg_tmp11 = uniforms.f[0].xxxx;
    // 4: mov
    reg_tmp12 = uniforms.f[0].xxxx;
    // 5: mov
    reg_tmp13 = uniforms.f[0].zzzz;
    // 6: mov
    reg_tmp4 = uniforms.f[0].xxxx;
    // 7: mov
    reg_tmp5 = uniforms.f[0].xxxx;
    return false;
}
bool sub_9_32() {
    // 9: mov
    vs_out_attr0 = reg_tmp10;
    // 10: mul
    reg_tmp13 = mul_safe(uniforms.f[82], reg_tmp13);
    // 11: mov
    vs_out_attr1 = reg_tmp13;
    // 12: add
    reg_tmp11.y = (uniforms.f[0].zzzz + -reg_tmp11.yyyy).y;
    // 13: add
    reg_tmp12.y = (uniforms.f[0].zzzz + -reg_tmp12.yyyy).y;
    // 14: mov
    reg_tmp14.y = (uniforms.f[81].wwww).y;
    // 15: mul
    reg_tmp14.x = (mul_safe(uniforms.f[0].wwww, reg_tmp14.yyyy)).x;
    // 16: rcp
    reg_tmp2.x = rcp_safe(reg_tmp14.xxxx.x);
    // 17: mov
    reg_tmp14.z = (reg_tmp2.xxxx).z;
    // 18: add
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp11.xyyy).xy;
    // 19: mul
    reg_tmp5.xy = (mul_safe(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    // 20: flr
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    // 21: mul
    reg_tmp4.xy = (mul_safe(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    // 22: add
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    // 23: add
    reg_tmp11.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    // 24: add
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp12.xyyy).xy;
    // 25: mul
    reg_tmp5.xy = (mul_safe(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    // 26: flr
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    // 27: mul
    reg_tmp4.xy = (mul_safe(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    // 28: add
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    // 29: add
    reg_tmp12.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    // 30: mov
    vs_out_attr2 = reg_tmp11;
    // 31: mov
    vs_out_attr3 = reg_tmp12;
    return false;
}
bool sub_114_142() {
    // 114: mov
    reg_tmp2 = uniforms.f[85];
    // 115: add
    reg_tmp2.xz = (-uniforms.f[5 + address_registers.x].xzzz + reg_tmp2.xzzz).xz;
    // 116: mov
    reg_tmp2.yw = (uniforms.f[0].xxxx).yw;
    // 117: dp3
    reg_tmp3.x = dot(vec3(reg_tmp2.xyzz), vec3(reg_tmp2.xyzz));
    // 118: rsq
    reg_tmp3.x = rsq_safe(reg_tmp3.xxxx.x);
    // 119: mul
    reg_tmp2.xyz = (mul_safe(reg_tmp2.xyzz, reg_tmp3.xxxx)).xyz;
    // 120: mov
    reg_tmp4 = uniforms.f[0].xzxx;
    // 121: mul
    reg_tmp5.xyz = (mul_safe(reg_tmp2.yzxx, reg_tmp4.zxyy)).xyz;
    // 122: mad
    reg_tmp5.xyz = (fma_safe(-reg_tmp4.yzxx, reg_tmp2.zxyy, reg_tmp5)).xyz;
    // 123: dp3
    reg_tmp3.x = dot(vec3(reg_tmp5.xyzz), vec3(reg_tmp5.xyzz));
    // 124: rsq
    reg_tmp3.x = rsq_safe(reg_tmp3.xxxx.x);
    // 125: mul
    reg_tmp5.xyz = (mul_safe(reg_tmp5.xyzz, reg_tmp3.xxxx)).xyz;
    // 126: mov
    reg_tmp6.x = (-reg_tmp5.xxxx).x;
    // 127: mov
    reg_tmp6.y = (-reg_tmp5.yyyy).y;
    // 128: mov
    reg_tmp6.z = (-reg_tmp5.zzzz).z;
    // 129: mov
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    // 130: mov
    reg_tmp7.x = (reg_tmp4.xxxx).x;
    // 131: mov
    reg_tmp7.y = (reg_tmp4.yyyy).y;
    // 132: mov
    reg_tmp7.z = (reg_tmp4.zzzz).z;
    // 133: mov
    reg_tmp7.w = (uniforms.f[0].xxxx).w;
    // 134: mov
    reg_tmp8.x = (-reg_tmp2.xxxx).x;
    // 135: mov
    reg_tmp8.y = (-reg_tmp2.yyyy).y;
    // 136: mov
    reg_tmp8.z = (-reg_tmp2.zzzz).z;
    // 137: mov
    reg_tmp8.w = (uniforms.f[0].xxxx).w;
    // 138: mov
    reg_tmp9.x = (uniforms.f[90].wwww).x;
    // 139: mov
    reg_tmp9.y = (uniforms.f[91].wwww).y;
    // 140: mov
    reg_tmp9.z = (uniforms.f[92].wwww).z;
    // 141: mov
    reg_tmp9.w = (uniforms.f[0].zzzz).w;
    return false;
}
bool sub_146_166() {
    // 146: mov
    reg_tmp2 = uniforms.f[90];
    // 147: mov
    reg_tmp3 = uniforms.f[91];
    // 148: mov
    reg_tmp4 = uniforms.f[92];
    // 149: mov
    reg_tmp5 = uniforms.f[0].xxxz;
    // 150: mul
    reg_tmp6 = mul_safe(uniforms.f[86].xxxx, reg_tmp2);
    // 151: mad
    reg_tmp6 = fma_safe(reg_tmp3, uniforms.f[86].yyyy, reg_tmp6);
    // 152: mad
    reg_tmp6 = fma_safe(reg_tmp4, uniforms.f[86].zzzz, reg_tmp6);
    // 153: mad
    reg_tmp6 = fma_safe(reg_tmp5, uniforms.f[86].wwww, reg_tmp6);
    // 154: mul
    reg_tmp7 = mul_safe(uniforms.f[87].xxxx, reg_tmp2);
    // 155: mad
    reg_tmp7 = fma_safe(reg_tmp3, uniforms.f[87].yyyy, reg_tmp7);
    // 156: mad
    reg_tmp7 = fma_safe(reg_tmp4, uniforms.f[87].zzzz, reg_tmp7);
    // 157: mad
    reg_tmp7 = fma_safe(reg_tmp5, uniforms.f[87].wwww, reg_tmp7);
    // 158: mul
    reg_tmp8 = mul_safe(uniforms.f[88].xxxx, reg_tmp2);
    // 159: mad
    reg_tmp8 = fma_safe(reg_tmp3, uniforms.f[88].yyyy, reg_tmp8);
    // 160: mad
    reg_tmp8 = fma_safe(reg_tmp4, uniforms.f[88].zzzz, reg_tmp8);
    // 161: mad
    reg_tmp8 = fma_safe(reg_tmp5, uniforms.f[88].wwww, reg_tmp8);
    // 162: mul
    reg_tmp9 = mul_safe(uniforms.f[89].xxxx, reg_tmp2);
    // 163: mad
    reg_tmp9 = fma_safe(reg_tmp3, uniforms.f[89].yyyy, reg_tmp9);
    // 164: mad
    reg_tmp9 = fma_safe(reg_tmp4, uniforms.f[89].zzzz, reg_tmp9);
    // 165: mad
    reg_tmp9 = fma_safe(reg_tmp5, uniforms.f[89].wwww, reg_tmp9);
    return false;
}
bool sub_167_259() {
    // 167: rcp
    reg_tmp2.x = rcp_safe(uniforms.f[81].yyyy.x);
    // 168: mul
    reg_tmp2.xy = (mul_safe(uniforms.f[2 + address_registers.x].zwww, reg_tmp2.xxxx)).xy;
    // 169: add
    reg_tmp2.xy = (uniforms.f[0].yyyy + reg_tmp2.xyyy).xy;
    // 170: flr
    reg_tmp3.xy = (floor(reg_tmp2.xyyy)).xy;
    // 171: mul
    reg_tmp2.xy = (mul_safe(uniforms.f[81].yyyy, reg_tmp3.xyyy)).xy;
    // 172: add
    reg_tmp2.xy = (uniforms.f[2 + address_registers.x].zwww + -reg_tmp2.xyyy).xy;
    // 173: min
    reg_tmp0.xy = (min(uniforms.f[81].xxxx, -reg_tmp2.xyyy)).xy;
    // 174: max
    reg_tmp0.xy = (max(-uniforms.f[81].xxxx, reg_tmp0.xyyy)).xy;
    // 175: mov
    reg_tmp2 = uniforms.f[95];
    // 176: mov
    reg_tmp3 = uniforms.f[94];
    // 177: mul
    reg_tmp1.z = (mul_safe(reg_tmp0.xxxx, reg_tmp0.xxxx)).z;
    // 178: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 179: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 180: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 181: mov
    reg_tmp2 = uniforms.f[93];
    // 182: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 183: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 184: mul
    reg_tmp1.y = (mul_safe(reg_tmp1.yyyy, reg_tmp0.xxxx)).y;
    // 185: mov
    reg_tmp5.x = (uniforms.f[5 + address_registers.x].wwww).x;
    // 186: mov
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    // 187: mov
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    // 188: cmp
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    // 189: ifc
    if (conditional_code.x) {
        sub_190_192();
    }
    // 192: cmp
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    // 193: ifc
    if (conditional_code.x) {
        sub_194_195();
    }
    // 195: cmp
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 196: ifc
    if (conditional_code.x) {
        sub_197_198();
    }
    // 198: cmp
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 199: ifc
    if (conditional_code.x) {
        sub_200_202();
    }
    // 202: mul
    reg_tmp4.xy = (mul_safe(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    // 203: mad
    reg_tmp4.x = (fma_safe(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    // 204: mad
    reg_tmp4.y = (fma_safe(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    // 205: add
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    // 206: add
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    // 207: mov
    reg_tmp4.z = (uniforms.f[83].xxxx).z;
    // 208: mov
    reg_tmp4.w = (-uniforms.f[83].yyyy).w;
    // 209: madi
    reg_tmp5.xy = (fma_safe(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[3 + address_registers.x].xyyy)).xy;
    // 210: mov
    reg_tmp4.z = (-uniforms.f[3 + address_registers.x].zzzz).z;
    // 211: mov
    reg_tmp4.w = (-uniforms.f[3 + address_registers.x].wwww).w;
    // 212: add
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    // 213: add
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    // 214: mad
    reg_tmp5.x = (fma_safe(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    // 215: mad
    reg_tmp5.y = (fma_safe(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    // 216: mov
    reg_tmp11.xy = (reg_tmp5.xyyy).xy;
    // 217: mov
    reg_tmp2 = uniforms.f[95];
    // 218: mov
    reg_tmp3 = uniforms.f[94];
    // 219: mul
    reg_tmp1.z = (mul_safe(reg_tmp0.yyyy, reg_tmp0.yyyy)).z;
    // 220: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 221: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 222: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 223: mov
    reg_tmp2 = uniforms.f[93];
    // 224: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 225: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 226: mul
    reg_tmp1.y = (mul_safe(reg_tmp1.yyyy, reg_tmp0.yyyy)).y;
    // 227: mov
    reg_tmp5.x = (uniforms.f[6 + address_registers.x].wwww).x;
    // 228: mov
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    // 229: mov
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    // 230: cmp
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    // 231: ifc
    if (conditional_code.x) {
        sub_232_234();
    }
    // 234: cmp
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    // 235: ifc
    if (conditional_code.x) {
        sub_236_237();
    }
    // 237: cmp
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 238: ifc
    if (conditional_code.x) {
        sub_239_240();
    }
    // 240: cmp
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 241: ifc
    if (conditional_code.x) {
        sub_242_244();
    }
    // 244: mul
    reg_tmp4.xy = (mul_safe(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    // 245: mad
    reg_tmp4.x = (fma_safe(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    // 246: mad
    reg_tmp4.y = (fma_safe(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    // 247: add
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    // 248: add
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    // 249: mov
    reg_tmp4.z = (uniforms.f[83].zzzz).z;
    // 250: mov
    reg_tmp4.w = (-uniforms.f[83].wwww).w;
    // 251: madi
    reg_tmp5.xy = (fma_safe(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[4 + address_registers.x].xyyy)).xy;
    // 252: mov
    reg_tmp4.z = (-uniforms.f[4 + address_registers.x].zzzz).z;
    // 253: mov
    reg_tmp4.w = (-uniforms.f[4 + address_registers.x].wwww).w;
    // 254: add
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    // 255: add
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    // 256: mad
    reg_tmp5.x = (fma_safe(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    // 257: mad
    reg_tmp5.y = (fma_safe(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    // 258: mov
    reg_tmp12.xy = (reg_tmp5.xyyy).xy;
    return false;
}
bool sub_190_192() {
    // 190: mov
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    // 191: mov
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_194_195() {
    // 194: mov
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_197_198() {
    // 197: mov
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_200_202() {
    // 200: mov
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    // 201: mov
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_232_234() {
    // 232: mov
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    // 233: mov
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_236_237() {
    // 236: mov
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_239_240() {
    // 239: mov
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_242_244() {
    // 242: mov
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    // 243: mov
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_260_4096() {
    // 260: call
    {
        sub_0_8();
    }
    // 261: add
    reg_tmp10.xy = (uniforms.f[84].xyyy + reg_tmp10.xyyy).xy;
    // 262: mul
    reg_tmp10.xy = (mul_safe(uniforms.f[2 + address_registers.x].xyyy, reg_tmp10.xyyy)).xy;
    // 263: call
    {
        sub_114_142();
    }
    // 264: dp4
    reg_tmp14.x = dot(reg_tmp10, reg_tmp6);
    // 265: dp4
    reg_tmp14.y = dot(reg_tmp10, reg_tmp7);
    // 266: dp4
    reg_tmp14.z = dot(reg_tmp10, reg_tmp8);
    // 267: dp4
    reg_tmp14.w = dot(uniforms.f[0].xxxz, reg_tmp10);
    // 268: mov
    reg_tmp2 = reg_tmp14;
    // 269: mov
    reg_tmp3.xyz = (uniforms.f[5 + address_registers.x].xyzz).xyz;
    // 270: add
    reg_tmp3.xyz = (uniforms.f[85].xyzz + -reg_tmp3.xyzz).xyz;
    // 271: dp3
    reg_tmp4.x = dot(vec3(reg_tmp3.xyzz), vec3(reg_tmp3.xyzz));
    // 272: cmp
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
    // 273: ifc
    if (conditional_code.x) {
        sub_274_275();
    } else {
        sub_275_276();
    }
    // 276: mul
    reg_tmp3.xyz = (mul_safe(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
    // 277: add
    reg_tmp10.xyz = (uniforms.f[5 + address_registers.x].xyzz + reg_tmp2.xyzz).xyz;
    // 278: mad
    reg_tmp10.xyz = (fma_safe(reg_tmp3.xyzz, uniforms.f[84].zzzz, reg_tmp10.xyzz)).xyz;
    // 279: call
    {
        sub_146_166();
    }
    // 280: mov
    reg_tmp2 = reg_tmp10;
    // 281: dp4
    reg_tmp10.x = dot(reg_tmp2, reg_tmp6);
    // 282: dp4
    reg_tmp10.y = dot(reg_tmp2, reg_tmp7);
    // 283: dp4
    reg_tmp10.z = dot(reg_tmp2, reg_tmp8);
    // 284: dp4
    reg_tmp10.w = dot(reg_tmp2, reg_tmp9);
    // 285: mov
    reg_tmp2 = uniforms.f[1 + address_registers.x];
    // 286: max
    reg_tmp3 = max(uniforms.f[0].xxxx, reg_tmp2);
    // 287: min
    reg_tmp2 = min(uniforms.f[0].zzzz, reg_tmp3);
    // 288: mov
    reg_tmp13 = reg_tmp2;
    // 289: call
    {
        sub_167_259();
    }
    // 290: call
    {
        sub_9_32();
    }
    // 291: end
    return true;
}
bool sub_274_275() {
    // 274: mov
    reg_tmp4.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_275_276() {
    // 275: rsq
    reg_tmp4.x = rsq_safe(reg_tmp4.xxxx.x);
    return false;
}
// reference: 7C68B52BEFB18A1B, 5DC51233DD2793A1
// shader: 8B30, EA83856F8213E7FC

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: B1EC17DB37D2A2A0, EA83856F8213E7FC
// program: 5DC51233DD2793A1, CEF02063E9A18B2F, EA83856F8213E7FC
// reference: 4016F7B8E0BB3D4E, D82E12A9D19ACD63
// reference: CBF620170DF00CFA, D82E12A9D19ACD63
// reference: A011BC48E372F705, 48B3A6FBA8498826
// reference: 84B5F9A0E0730DB5, 65138AC5CA635BBF
// shader: 8B31, FA7BEC2C98E412D6

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define fma_safe(x, y, z) fma(x, y, z)
#define mul_safe(x, y) (x * y)
#define rcp_safe(x) (1.0f / x)
#define rsq_safe(x) inversesqrt(x)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_8();
bool sub_9_32();
bool sub_146_166();
bool sub_167_259();
bool sub_190_192();
bool sub_194_195();
bool sub_197_198();
bool sub_200_202();
bool sub_232_234();
bool sub_236_237();
bool sub_239_240();
bool sub_242_244();
bool sub_260_4096();
bool sub_270_271();
bool sub_271_272();
bool sub_278_279();
bool sub_279_280();
bool sub_305_306();
bool sub_306_307();

bool exec_shader() {
    sub_260_4096();
    return true;
}

bool sub_0_8() {
    // 0: mova
    address_registers.x = (ivec2(vs_in_reg0.zzzz)).x;
    // 1: mov
    reg_tmp10 = uniforms.f[0].xxxz;
    // 2: mov
    reg_tmp10.xy = (vs_in_reg0.xyyy).xy;
    // 3: mov
    reg_tmp11 = uniforms.f[0].xxxx;
    // 4: mov
    reg_tmp12 = uniforms.f[0].xxxx;
    // 5: mov
    reg_tmp13 = uniforms.f[0].zzzz;
    // 6: mov
    reg_tmp4 = uniforms.f[0].xxxx;
    // 7: mov
    reg_tmp5 = uniforms.f[0].xxxx;
    return false;
}
bool sub_9_32() {
    // 9: mov
    vs_out_attr0 = reg_tmp10;
    // 10: mul
    reg_tmp13 = mul_safe(uniforms.f[82], reg_tmp13);
    // 11: mov
    vs_out_attr1 = reg_tmp13;
    // 12: add
    reg_tmp11.y = (uniforms.f[0].zzzz + -reg_tmp11.yyyy).y;
    // 13: add
    reg_tmp12.y = (uniforms.f[0].zzzz + -reg_tmp12.yyyy).y;
    // 14: mov
    reg_tmp14.y = (uniforms.f[81].wwww).y;
    // 15: mul
    reg_tmp14.x = (mul_safe(uniforms.f[0].wwww, reg_tmp14.yyyy)).x;
    // 16: rcp
    reg_tmp2.x = rcp_safe(reg_tmp14.xxxx.x);
    // 17: mov
    reg_tmp14.z = (reg_tmp2.xxxx).z;
    // 18: add
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp11.xyyy).xy;
    // 19: mul
    reg_tmp5.xy = (mul_safe(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    // 20: flr
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    // 21: mul
    reg_tmp4.xy = (mul_safe(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    // 22: add
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    // 23: add
    reg_tmp11.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    // 24: add
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp12.xyyy).xy;
    // 25: mul
    reg_tmp5.xy = (mul_safe(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    // 26: flr
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    // 27: mul
    reg_tmp4.xy = (mul_safe(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    // 28: add
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    // 29: add
    reg_tmp12.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    // 30: mov
    vs_out_attr2 = reg_tmp11;
    // 31: mov
    vs_out_attr3 = reg_tmp12;
    return false;
}
bool sub_146_166() {
    // 146: mov
    reg_tmp2 = uniforms.f[90];
    // 147: mov
    reg_tmp3 = uniforms.f[91];
    // 148: mov
    reg_tmp4 = uniforms.f[92];
    // 149: mov
    reg_tmp5 = uniforms.f[0].xxxz;
    // 150: mul
    reg_tmp6 = mul_safe(uniforms.f[86].xxxx, reg_tmp2);
    // 151: mad
    reg_tmp6 = fma_safe(reg_tmp3, uniforms.f[86].yyyy, reg_tmp6);
    // 152: mad
    reg_tmp6 = fma_safe(reg_tmp4, uniforms.f[86].zzzz, reg_tmp6);
    // 153: mad
    reg_tmp6 = fma_safe(reg_tmp5, uniforms.f[86].wwww, reg_tmp6);
    // 154: mul
    reg_tmp7 = mul_safe(uniforms.f[87].xxxx, reg_tmp2);
    // 155: mad
    reg_tmp7 = fma_safe(reg_tmp3, uniforms.f[87].yyyy, reg_tmp7);
    // 156: mad
    reg_tmp7 = fma_safe(reg_tmp4, uniforms.f[87].zzzz, reg_tmp7);
    // 157: mad
    reg_tmp7 = fma_safe(reg_tmp5, uniforms.f[87].wwww, reg_tmp7);
    // 158: mul
    reg_tmp8 = mul_safe(uniforms.f[88].xxxx, reg_tmp2);
    // 159: mad
    reg_tmp8 = fma_safe(reg_tmp3, uniforms.f[88].yyyy, reg_tmp8);
    // 160: mad
    reg_tmp8 = fma_safe(reg_tmp4, uniforms.f[88].zzzz, reg_tmp8);
    // 161: mad
    reg_tmp8 = fma_safe(reg_tmp5, uniforms.f[88].wwww, reg_tmp8);
    // 162: mul
    reg_tmp9 = mul_safe(uniforms.f[89].xxxx, reg_tmp2);
    // 163: mad
    reg_tmp9 = fma_safe(reg_tmp3, uniforms.f[89].yyyy, reg_tmp9);
    // 164: mad
    reg_tmp9 = fma_safe(reg_tmp4, uniforms.f[89].zzzz, reg_tmp9);
    // 165: mad
    reg_tmp9 = fma_safe(reg_tmp5, uniforms.f[89].wwww, reg_tmp9);
    return false;
}
bool sub_167_259() {
    // 167: rcp
    reg_tmp2.x = rcp_safe(uniforms.f[81].yyyy.x);
    // 168: mul
    reg_tmp2.xy = (mul_safe(uniforms.f[2 + address_registers.x].zwww, reg_tmp2.xxxx)).xy;
    // 169: add
    reg_tmp2.xy = (uniforms.f[0].yyyy + reg_tmp2.xyyy).xy;
    // 170: flr
    reg_tmp3.xy = (floor(reg_tmp2.xyyy)).xy;
    // 171: mul
    reg_tmp2.xy = (mul_safe(uniforms.f[81].yyyy, reg_tmp3.xyyy)).xy;
    // 172: add
    reg_tmp2.xy = (uniforms.f[2 + address_registers.x].zwww + -reg_tmp2.xyyy).xy;
    // 173: min
    reg_tmp0.xy = (min(uniforms.f[81].xxxx, -reg_tmp2.xyyy)).xy;
    // 174: max
    reg_tmp0.xy = (max(-uniforms.f[81].xxxx, reg_tmp0.xyyy)).xy;
    // 175: mov
    reg_tmp2 = uniforms.f[95];
    // 176: mov
    reg_tmp3 = uniforms.f[94];
    // 177: mul
    reg_tmp1.z = (mul_safe(reg_tmp0.xxxx, reg_tmp0.xxxx)).z;
    // 178: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 179: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 180: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 181: mov
    reg_tmp2 = uniforms.f[93];
    // 182: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 183: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 184: mul
    reg_tmp1.y = (mul_safe(reg_tmp1.yyyy, reg_tmp0.xxxx)).y;
    // 185: mov
    reg_tmp5.x = (uniforms.f[5 + address_registers.x].wwww).x;
    // 186: mov
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    // 187: mov
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    // 188: cmp
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    // 189: ifc
    if (conditional_code.x) {
        sub_190_192();
    }
    // 192: cmp
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    // 193: ifc
    if (conditional_code.x) {
        sub_194_195();
    }
    // 195: cmp
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 196: ifc
    if (conditional_code.x) {
        sub_197_198();
    }
    // 198: cmp
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 199: ifc
    if (conditional_code.x) {
        sub_200_202();
    }
    // 202: mul
    reg_tmp4.xy = (mul_safe(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    // 203: mad
    reg_tmp4.x = (fma_safe(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    // 204: mad
    reg_tmp4.y = (fma_safe(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    // 205: add
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    // 206: add
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    // 207: mov
    reg_tmp4.z = (uniforms.f[83].xxxx).z;
    // 208: mov
    reg_tmp4.w = (-uniforms.f[83].yyyy).w;
    // 209: madi
    reg_tmp5.xy = (fma_safe(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[3 + address_registers.x].xyyy)).xy;
    // 210: mov
    reg_tmp4.z = (-uniforms.f[3 + address_registers.x].zzzz).z;
    // 211: mov
    reg_tmp4.w = (-uniforms.f[3 + address_registers.x].wwww).w;
    // 212: add
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    // 213: add
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    // 214: mad
    reg_tmp5.x = (fma_safe(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    // 215: mad
    reg_tmp5.y = (fma_safe(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    // 216: mov
    reg_tmp11.xy = (reg_tmp5.xyyy).xy;
    // 217: mov
    reg_tmp2 = uniforms.f[95];
    // 218: mov
    reg_tmp3 = uniforms.f[94];
    // 219: mul
    reg_tmp1.z = (mul_safe(reg_tmp0.yyyy, reg_tmp0.yyyy)).z;
    // 220: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 221: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 222: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 223: mov
    reg_tmp2 = uniforms.f[93];
    // 224: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 225: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 226: mul
    reg_tmp1.y = (mul_safe(reg_tmp1.yyyy, reg_tmp0.yyyy)).y;
    // 227: mov
    reg_tmp5.x = (uniforms.f[6 + address_registers.x].wwww).x;
    // 228: mov
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    // 229: mov
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    // 230: cmp
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    // 231: ifc
    if (conditional_code.x) {
        sub_232_234();
    }
    // 234: cmp
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    // 235: ifc
    if (conditional_code.x) {
        sub_236_237();
    }
    // 237: cmp
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 238: ifc
    if (conditional_code.x) {
        sub_239_240();
    }
    // 240: cmp
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 241: ifc
    if (conditional_code.x) {
        sub_242_244();
    }
    // 244: mul
    reg_tmp4.xy = (mul_safe(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    // 245: mad
    reg_tmp4.x = (fma_safe(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    // 246: mad
    reg_tmp4.y = (fma_safe(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    // 247: add
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    // 248: add
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    // 249: mov
    reg_tmp4.z = (uniforms.f[83].zzzz).z;
    // 250: mov
    reg_tmp4.w = (-uniforms.f[83].wwww).w;
    // 251: madi
    reg_tmp5.xy = (fma_safe(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[4 + address_registers.x].xyyy)).xy;
    // 252: mov
    reg_tmp4.z = (-uniforms.f[4 + address_registers.x].zzzz).z;
    // 253: mov
    reg_tmp4.w = (-uniforms.f[4 + address_registers.x].wwww).w;
    // 254: add
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    // 255: add
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    // 256: mad
    reg_tmp5.x = (fma_safe(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    // 257: mad
    reg_tmp5.y = (fma_safe(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    // 258: mov
    reg_tmp12.xy = (reg_tmp5.xyyy).xy;
    return false;
}
bool sub_190_192() {
    // 190: mov
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    // 191: mov
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_194_195() {
    // 194: mov
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_197_198() {
    // 197: mov
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_200_202() {
    // 200: mov
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    // 201: mov
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_232_234() {
    // 232: mov
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    // 233: mov
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_236_237() {
    // 236: mov
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_239_240() {
    // 239: mov
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_242_244() {
    // 242: mov
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    // 243: mov
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_260_4096() {
    // 260: call
    {
        sub_0_8();
    }
    // 261: add
    reg_tmp10.xy = (uniforms.f[84].xyyy + reg_tmp10.xyyy).xy;
    // 262: mul
    reg_tmp10.xy = (mul_safe(uniforms.f[2 + address_registers.x].xyyy, reg_tmp10.xyyy)).xy;
    // 263: mov
    reg_tmp2.x = (uniforms.f[8 + address_registers.x].yyyy).x;
    // 264: mov
    reg_tmp2.y = (uniforms.f[9 + address_registers.x].yyyy).y;
    // 265: mov
    reg_tmp2.z = (uniforms.f[10 + address_registers.x].yyyy).z;
    // 266: mov
    reg_tmp3.xyz = (uniforms.f[6 + address_registers.x].xyzz).xyz;
    // 267: dp3
    reg_tmp4.x = dot(vec3(reg_tmp3.xyzz), vec3(reg_tmp3.xyzz));
    // 268: cmp
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
    // 269: ifc
    if (conditional_code.x) {
        sub_270_271();
    } else {
        sub_271_272();
    }
    // 272: mul
    reg_tmp3.xyz = (mul_safe(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
    // 273: mul
    reg_tmp4.xyz = (mul_safe(reg_tmp3.yzxx, reg_tmp2.zxyy)).xyz;
    // 274: mad
    reg_tmp4.xyz = (fma_safe(-reg_tmp2.yzxx, reg_tmp3.zxyy, reg_tmp4)).xyz;
    // 275: dp3
    reg_tmp5.x = dot(vec3(reg_tmp4.xyzz), vec3(reg_tmp4.xyzz));
    // 276: cmp
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp5.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp5.y;
    // 277: ifc
    if (conditional_code.x) {
        sub_278_279();
    } else {
        sub_279_280();
    }
    // 280: mul
    reg_tmp4.xyz = (mul_safe(reg_tmp4.xyzz, reg_tmp5.xxxx)).xyz;
    // 281: mul
    reg_tmp5.xyz = (mul_safe(reg_tmp3.yzxx, reg_tmp4.zxyy)).xyz;
    // 282: mad
    reg_tmp5.xyz = (fma_safe(-reg_tmp4.yzxx, reg_tmp3.zxyy, reg_tmp5)).xyz;
    // 283: mov
    reg_tmp6.x = (reg_tmp4.xxxx).x;
    // 284: mov
    reg_tmp6.y = (reg_tmp3.xxxx).y;
    // 285: mov
    reg_tmp6.z = (reg_tmp5.xxxx).z;
    // 286: mov
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    // 287: mov
    reg_tmp7.x = (reg_tmp4.yyyy).x;
    // 288: mov
    reg_tmp7.y = (reg_tmp3.yyyy).y;
    // 289: mov
    reg_tmp7.z = (reg_tmp5.yyyy).z;
    // 290: mov
    reg_tmp7.w = (uniforms.f[0].xxxx).w;
    // 291: mov
    reg_tmp8.x = (reg_tmp4.zzzz).x;
    // 292: mov
    reg_tmp8.y = (reg_tmp3.zzzz).y;
    // 293: mov
    reg_tmp8.z = (reg_tmp5.zzzz).z;
    // 294: mov
    reg_tmp8.w = (uniforms.f[0].xxxx).w;
    // 295: mov
    reg_tmp9 = uniforms.f[0].xxxz;
    // 296: dp4
    reg_tmp2.x = dot(reg_tmp10, reg_tmp6);
    // 297: dp4
    reg_tmp2.y = dot(reg_tmp10, reg_tmp7);
    // 298: dp4
    reg_tmp2.z = dot(reg_tmp10, reg_tmp8);
    // 299: dp4
    reg_tmp2.w = dot(reg_tmp10, reg_tmp9);
    // 300: mov
    reg_tmp3.xyz = (uniforms.f[5 + address_registers.x].xyzz).xyz;
    // 301: add
    reg_tmp3.xyz = (uniforms.f[85].xyzz + -reg_tmp3.xyzz).xyz;
    // 302: dp3
    reg_tmp4.x = dot(vec3(reg_tmp3.xyzz), vec3(reg_tmp3.xyzz));
    // 303: cmp
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
    // 304: ifc
    if (conditional_code.x) {
        sub_305_306();
    } else {
        sub_306_307();
    }
    // 307: mul
    reg_tmp3.xyz = (mul_safe(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
    // 308: add
    reg_tmp10.xyz = (uniforms.f[5 + address_registers.x].xyzz + reg_tmp2.xyzz).xyz;
    // 309: mad
    reg_tmp10.xyz = (fma_safe(reg_tmp3.xyzz, uniforms.f[84].zzzz, reg_tmp10.xyzz)).xyz;
    // 310: call
    {
        sub_146_166();
    }
    // 311: mov
    reg_tmp2 = reg_tmp10;
    // 312: dp4
    reg_tmp10.x = dot(reg_tmp2, reg_tmp6);
    // 313: dp4
    reg_tmp10.y = dot(reg_tmp2, reg_tmp7);
    // 314: dp4
    reg_tmp10.z = dot(reg_tmp2, reg_tmp8);
    // 315: dp4
    reg_tmp10.w = dot(reg_tmp2, reg_tmp9);
    // 316: mov
    reg_tmp2 = uniforms.f[1 + address_registers.x];
    // 317: max
    reg_tmp3 = max(uniforms.f[0].xxxx, reg_tmp2);
    // 318: min
    reg_tmp2 = min(uniforms.f[0].zzzz, reg_tmp3);
    // 319: mov
    reg_tmp13 = reg_tmp2;
    // 320: call
    {
        sub_167_259();
    }
    // 321: call
    {
        sub_9_32();
    }
    // 322: end
    return true;
}
bool sub_270_271() {
    // 270: mov
    reg_tmp4.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_271_272() {
    // 271: rsq
    reg_tmp4.x = rsq_safe(reg_tmp4.xxxx.x);
    return false;
}
bool sub_278_279() {
    // 278: mov
    reg_tmp5.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_279_280() {
    // 279: rsq
    reg_tmp5.x = rsq_safe(reg_tmp5.xxxx.x);
    return false;
}
bool sub_305_306() {
    // 305: mov
    reg_tmp4.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_306_307() {
    // 306: rsq
    reg_tmp4.x = rsq_safe(reg_tmp4.xxxx.x);
    return false;
}
// reference: 85555D91A23BE0D8, FA7BEC2C98E412D6
// program: FA7BEC2C98E412D6, CEF02063E9A18B2F, EA83856FEB3CAEC2
// program: 306D0F33E4D14FB9, CEF02063E9A18B2F, EA83856FEB3CAEC2
// reference: 4A3713A36EA2CB53, BE941576D67F1D56
// reference: B280553C0A06D014, 3295BFC9E1117A37
// reference: 635646A9C86D942A, DD35FB9CAEB223CF
// reference: 2983DF1729E42972, 5DC51233DD2793A1
// reference: 15FD9D8426EE9E27, D82E12A9D19ACD63
// reference: 9E1D4A2BCBA5AF93, D82E12A9D19ACD63
// reference: E76B3F000A06D014, 3295BFC9E1117A37
// reference: DB157D93050C6741, D82E12A9D19ACD63
// reference: 50F5AA3CE84756F5, D82E12A9D19ACD63
// reference: CEF23256E372F705, 48B3A6FBA8498826
// reference: EA5677BEE0730DB5, 65138AC5CA635BBF
// reference: BE5DB9B3A23BE0D8, FA7BEC2C98E412D6
// reference: E76B3F0084308E41, 3295BFC9E1117A37
// reference: C39EA7654F70D16C, FA7BEC2C98E412D6
// reference: 487E70CAA23BE0D8, FA7BEC2C98E412D6
// reference: 1148F67984308E41, 3295BFC9E1117A37
// reference: 487E70CA7D75EA4C, 306D0F33E4D14FB9
// reference: E9FFB0E66EA2CB53, BE941576D67F1D56
// reference: 1148F6790A06D014, 3295BFC9E1117A37
// reference: 75173A39C1EC365B, D82E12A9D19ACD63
// reference: FEF7ED962CA707EF, D82E12A9D19ACD63
// reference: 35BD6E1C4F70D16C, FA7BEC2C98E412D6
// reference: 4A3713A3E0949506, BE941576D67F1D56
// reference: B280553C84308E41, 3295BFC9E1117A37
// reference: 635646A9465BCA7F, DD35FB9CAEB223CF
// reference: 2983DF17A7D27727, 5DC51233DD2793A1
// reference: DB157D938B3A3914, D82E12A9D19ACD63
// reference: 50F5AA3C667108A0, D82E12A9D19ACD63
// reference: 6C8BE8AF697BBFF5, 3295BFC9E1117A37
// reference: 6C8BE8AF8145241C, 3295BFC9E1117A37
// reference: 4A3713A308AA0EEF, BE941576D67F1D56
// reference: B280553C6C0E15A8, 3295BFC9E1117A37
// reference: DB157D936304A2FD, D82E12A9D19ACD63
// reference: 8EFE17AF6304A2FD, D82E12A9D19ACD63
// reference: 051EC0008E4F9349, D82E12A9D19ACD63
// reference: 9B19586AE372F705, 48B3A6FBA8498826
// reference: BFBD1D82E0730DB5, 65138AC5CA635BBF
// reference: 20FC5005C1EC365B, D82E12A9D19ACD63
// reference: AB1C87AA2CA707EF, D82E12A9D19ACD63
// reference: 396082938145241C, 3295BFC9E1117A37
// reference: 5C46E68952A58EDC, D82E12A9D19ACD63
// reference: D7A63126891C2F9B, D82E12A9D19ACD63
// reference: B280553C5AFC855B, 3295BFC9E1117A37
// reference: 8EFE17AF55F6320E, D82E12A9D19ACD63
// reference: 8EFE17AF578490FB, D82E12A9D19ACD63
// reference: D7A631268B6E8D6E, D82E12A9D19ACD63
// shader: 8B30, CDE985E79C677EB9

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) + (const_color[0].a) - 0.5, 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0 * 1.0, alpha_output_0 * 2.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (last_tex_env_out.aaa), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor0.rgb) * (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor0.a) + (const_color[2].a) - 0.5, 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2 * 1.0, alpha_output_2 * 2.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (last_tex_env_out.aaa), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) * (last_tex_env_out.aaa) + (texcolor0.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4 * 1.0, alpha_output_4 * 4.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 683FAFB545DD46C3, CDE985E79C677EB9
// program: D82E12A9D19ACD63, 5D764F9A6220D694, CDE985E79C677EB9
// reference: 38A93975190CBB45, B8A2CA3DB47999BF
// reference: B349EEDAC0C7B8F7, B8A2CA3DB47999BF
// reference: C684CFED1E3E9B72, FD5243D1FEFD5E87
// reference: F9138ECFD49CB0E7, DEFAC6F185DB6EB9
// reference: 66ADF19D98410408, C6D1945D8824B670
// reference: 451AD1EDE34B824E, 5447A3297E824FE0
// reference: CEFA06423A8081FC, 5447A3297E824FE0
// reference: 2401A1E9FCD95FFB, B543C911C8D7EAAB
// reference: 47DF34F97D3BCDCB, B8A2CA3DB47999BF
// reference: CC3FE35624949DFA, B8A2CA3DB47999BF
// reference: A8D03CAAB32C193C, D82E12A9D19ACD63
// reference: A8D03CAA33484ABF, D82E12A9D19ACD63
// reference: 483EE0398D92D061, DEFAC6F185DB6EB9
// shader: 8B30, 866E3CD9AFFE6001

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(view)), 0.0))) * light_src[0].specular_0) + ((lut_scale_d1 * LookupLightingLUTUnsigned(1, max(dot(normal, normalize(view)), 0.0))) * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb) * (texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (texcolor1.aaa) + (texcolor2.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3 * 2.0, alpha_output_3 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((secondary_fragment_color.rgb) * (texcolor1.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: A2651D4DBDCABBCD, 866E3CD9AFFE6001
// program: C686B1FD59F65802, AD7922A63ED54CA7, 866E3CD9AFFE6001
// shader: 8B30, 9694E9E4B79CEA89

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(view)), 0.0))) * light_src[0].specular_0) + ((lut_scale_d1 * LookupLightingLUTUnsigned(1, max(dot(normal, normalize(view)), 0.0))) * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].r) * (const_color[0].a) + (texcolor2.a) * (1.0 - (const_color[0].a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1 * 2.0, alpha_output_1 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((secondary_fragment_color.rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 6753A96B797E0686, 9694E9E4B79CEA89
// program: 46F6395BEBA5C2A1, 3B3AE026C742C7D5, 9694E9E4B79CEA89
// reference: A8DE0D342F11D7BF, D82E12A9D19ACD63
// reference: 800B697E18FF9065, DEFAC6F185DB6EB9
// reference: 255E01389EC6AE5E, D82E12A9D19ACD63
// reference: 41B1DEC4D56F9BC7, B8A2CA3DB47999BF
// reference: CA51096B0CA49875, B8A2CA3DB47999BF
// reference: 0CC7EFCECA19542A, ED9AAA1E39CE1504
// program: 734B56B7CFCD3D95, CEF02063E9A18B2F, ED9AAA1E39CE1504
// reference: 3FED2E7839B95732, 931705B2EA3991A9
// shader: 8B30, 1F6564D6FA4D7F87

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(view)), 0.0))) * light_src[0].specular_0) + ((lut_scale_d1 * LookupLightingLUTUnsigned(1, max(dot(normal, normalize(view)), 0.0))) * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor1.rgb) * (const_color[0].aaa) + (texcolor2.rgb) * (vec3(1.0) - (const_color[0].aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].r) * (const_color[0].a) + (texcolor2.a) * (1.0 - (const_color[0].a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2 * 2.0, alpha_output_2 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((texcolor1.aaa) * (secondary_fragment_color.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a) * (const_color[5].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: F619D5992F00C8F6, 1F6564D6FA4D7F87
// program: C686B1FD59F65802, AD7922A63ED54CA7, 1F6564D6FA4D7F87
// shader: 8B30, 04D87A5429CE6CD8

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[0].specular_0) + ((lut_scale_d1 * LookupLightingLUTUnsigned(1, max(dot(normal, normalize(view)), 0.0))) * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor1.rgb) * (const_color[0].aaa) + (texcolor2.rgb) * (vec3(1.0) - (const_color[0].aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (textureProj(tex0, vec3(texcoord0, texcoord0_w)).a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3 * 2.0, alpha_output_3 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((secondary_fragment_color.rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a) * (const_color[5].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 6D731661D6F210A8, 04D87A5429CE6CD8
// program: C686B1FD59F65802, AD7922A63ED54CA7, 04D87A5429CE6CD8
// shader: 8B30, 9DA8FA3A58C6D0F8

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(view)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(view)), 0.0))) * light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor1.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (textureProj(tex0, vec3(texcoord0, texcoord0_w)).a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2 * 2.0, alpha_output_2 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) + (secondary_fragment_color.rrr), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((texcolor1.aaa) * (secondary_fragment_color.ggg) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a) * (const_color[5].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D7118370F971A9BB, 9DA8FA3A58C6D0F8
// program: 46F6395BEBA5C2A1, 3B3AE026C742C7D5, 9DA8FA3A58C6D0F8
// shader: 8B30, 69C3359658726645

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(view)), 0.0))) * light_src[0].specular_0) + ((lut_scale_d1 * LookupLightingLUTUnsigned(1, max(dot(normal, normalize(view)), 0.0))) * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb) * (texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (texcolor1.aaa) + (texcolor2.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3 * 2.0, alpha_output_3 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((secondary_fragment_color.rgb) * (texcolor1.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a) * (const_color[5].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: F35B3AA59539E70F, 69C3359658726645
// program: C686B1FD59F65802, AD7922A63ED54CA7, 69C3359658726645
// shader: 8B30, 2B367E6CC83DA5D2

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(view)), 0.0))) * light_src[0].specular_0) + ((lut_scale_d1 * LookupLightingLUTUnsigned(1, max(dot(normal, normalize(view)), 0.0))) * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor1.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (textureProj(tex0, vec3(texcoord0, texcoord0_w)).a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((primary_fragment_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2 * 2.0, alpha_output_2 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((secondary_fragment_color.rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a) * (const_color[5].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 5EC4FD2E8EAF9C38, 2B367E6CC83DA5D2
// program: 46F6395BEBA5C2A1, 3B3AE026C742C7D5, 2B367E6CC83DA5D2
// reference: 9F60DEFC2F00C8F6, 1F6564D6FA4D7F87
// shader: 8B30, 79E947F88465C55F

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(view)), 0.0))) * light_src[0].specular_0) + ((lut_scale_d1 * LookupLightingLUTUnsigned(1, max(dot(normal, normalize(view)), 0.0))) * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a) * (rounded_primary_color.a) + (texcolor1.a) * (1.0 - (rounded_primary_color.a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1 * 2.0, alpha_output_1 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((texcolor1.aaa) * (secondary_fragment_color.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) * (vec3(1.0) - textureProj(tex0, vec3(texcoord0, texcoord0_w)).rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a) * (const_color[5].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: E04D6A4C3CF3900D, 79E947F88465C55F
// program: 46F6395BEBA5C2A1, 3B3AE026C742C7D5, 79E947F88465C55F
// shader: 8B30, 39CDD9B2D50FBFBC

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(view)), 0.0))) * light_src[0].specular_0) + ((lut_scale_d1 * LookupLightingLUTUnsigned(1, max(dot(normal, normalize(view)), 0.0))) * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1 * 2.0, alpha_output_1 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((secondary_fragment_color.rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a) * (const_color[5].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: F825A35C83BBCA57, 39CDD9B2D50FBFBC
// program: 46F6395BEBA5C2A1, 3B3AE026C742C7D5, 39CDD9B2D50FBFBC
// reference: A727F27107F39434, DA97C925583C796F
// reference: A249A55D2F00C8F6, 1F6564D6FA4D7F87
// shader: 8B30, C48A4CA453847438

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[0].specular_0) + ((lut_scale_d1 * LookupLightingLUTUnsigned(1, max(dot(normal, normalize(view)), 0.0))) * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb) * (texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (texcolor1.aaa) + (texcolor2.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3 * 2.0, alpha_output_3 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((secondary_fragment_color.rgb) * (texcolor1.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a) * (const_color[5].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: BD8D21FA9539E70F, C48A4CA453847438
// program: C686B1FD59F65802, AD7922A63ED54CA7, C48A4CA453847438
// reference: 915CA83983BBCA57, 39CDD9B2D50FBFBC
// program: BE941576D67F1D56, CEF02063E9A18B2F, ED9AAA1E39CE1504
// reference: 7C68B52BD7F4D6C0, 734B56B7CFCD3D95
// reference: CBF620170347C0D2, D82E12A9D19ACD63
// reference: AF19FFEB48EEF54B, B8A2CA3DB47999BF
// reference: 24F928449125F6F9, B8A2CA3DB47999BF
// reference: 4016F7B8DA8CC360, D82E12A9D19ACD63
// program: 01CD144CA8DEFCA2, CEF02063E9A18B2F, ED9AAA1E39CE1504
// reference: 7C68B52B1A1B8E85, 734B56B7CFCD3D95
// reference: 4A3713A3FE54B738, BE941576D67F1D56
// reference: CBF62017CEA89897, D82E12A9D19ACD63
// reference: AF19FFEB8501AD0E, B8A2CA3DB47999BF
// reference: 24F928445CCAAEBC, B8A2CA3DB47999BF
// reference: 4016F7B817639B25, D82E12A9D19ACD63
// reference: 7C68B52B87D71636, 5DC51233DD2793A1
// program: 5DC51233DD2793A1, CEF02063E9A18B2F, 931705B2EA3991A9
// reference: 7C68B52B14F7BA6D, 734B56B7CFCD3D95
// reference: CBF6201753640024, D82E12A9D19ACD63
// reference: AF19FFEB18CD35BD, B8A2CA3DB47999BF
// reference: 24F92844C106360F, B8A2CA3DB47999BF
// reference: 4016F7B88AAF0396, D82E12A9D19ACD63
// reference: 48FDFEF93BAE2154, 5DC51233DD2793A1
// reference: FF636BC5EF1D3746, D82E12A9D19ACD63
// reference: 9B8CB439A4B402DF, B8A2CA3DB47999BF
// reference: 106C63967D7F016D, B8A2CA3DB47999BF
// reference: 7483BC6A36D634F4, D82E12A9D19ACD63
// shader: 8B31, 30A122D3BC979B4D

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();


#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}

#define fma_safe(x, y, z) fma(x, y, z)
#define mul_safe(x, y) (x * y)
#define rcp_safe(x) (1.0f / x)
#define rsq_safe(x) inversesqrt(x)
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_8();
bool sub_9_32();
bool sub_33_96();
bool sub_146_166();
bool sub_167_249();
bool sub_189_190();
bool sub_192_193();
bool sub_195_196();
bool sub_198_200();
bool sub_226_227();
bool sub_229_230();
bool sub_232_233();
bool sub_235_237();
bool sub_250_4096();
bool sub_267_268();
bool sub_268_269();
bool sub_275_276();
bool sub_276_277();
bool sub_302_303();
bool sub_303_304();

bool exec_shader() {
    sub_250_4096();
    return true;
}

bool sub_0_8() {
    // 0: mov
    reg_tmp10 = uniforms.f[0].xxxz;
    // 1: mov
    reg_tmp10.xyz = (vs_in_reg0.xyzz).xyz;
    // 2: mov
    reg_tmp11 = uniforms.f[0].xxxx;
    // 3: mov
    reg_tmp12 = uniforms.f[0].xxxx;
    // 4: mov
    reg_tmp11.xy = (vs_in_reg1.xyyy).xy;
    // 5: mov
    reg_tmp13 = uniforms.f[0].zzzz;
    // 6: mov
    reg_tmp4 = uniforms.f[0].xxxx;
    // 7: mov
    reg_tmp5 = uniforms.f[0].xxxx;
    return false;
}
bool sub_9_32() {
    // 9: mov
    vs_out_attr0 = reg_tmp10;
    // 10: mul
    reg_tmp13 = mul_safe(uniforms.f[82], reg_tmp13);
    // 11: mul
    vs_out_attr1 = mul_safe(vs_in_reg2, reg_tmp13);
    // 12: add
    reg_tmp11.y = (uniforms.f[0].zzzz + -reg_tmp11.yyyy).y;
    // 13: add
    reg_tmp12.y = (uniforms.f[0].zzzz + -reg_tmp12.yyyy).y;
    // 14: mov
    reg_tmp14.y = (uniforms.f[81].wwww).y;
    // 15: mul
    reg_tmp14.x = (mul_safe(uniforms.f[0].wwww, reg_tmp14.yyyy)).x;
    // 16: rcp
    reg_tmp2.x = rcp_safe(reg_tmp14.xxxx.x);
    // 17: mov
    reg_tmp14.z = (reg_tmp2.xxxx).z;
    // 18: add
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp11.xyyy).xy;
    // 19: mul
    reg_tmp5.xy = (mul_safe(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    // 20: flr
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    // 21: mul
    reg_tmp4.xy = (mul_safe(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    // 22: add
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    // 23: add
    reg_tmp11.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    // 24: add
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp12.xyyy).xy;
    // 25: mul
    reg_tmp5.xy = (mul_safe(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    // 26: flr
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    // 27: mul
    reg_tmp4.xy = (mul_safe(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    // 28: add
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    // 29: add
    reg_tmp12.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    // 30: mov
    vs_out_attr2 = reg_tmp11;
    // 31: mov
    vs_out_attr3 = reg_tmp12;
    return false;
}
bool sub_33_96() {
    // 33: mov
    reg_tmp6.xyz = (-reg_tmp0.xyzz).xyz;
    // 34: mov
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    // 35: rcp
    reg_tmp7.xyz = vec3(rcp_safe(uniforms.f[81].yyyy.x));
    // 36: madi
    reg_tmp8.xyz = (fma_safe(reg_tmp6.xyzz, reg_tmp7.xyzz, uniforms.f[0].yyyy)).xyz;
    // 37: flr
    reg_tmp7.xyz = (floor(reg_tmp8.xyzz)).xyz;
    // 38: mad
    reg_tmp6.xyz = (fma_safe(reg_tmp7.xyzz, -uniforms.f[81].yyyy, reg_tmp6.xyzz)).xyz;
    // 39: min
    reg_tmp6 = min(uniforms.f[81].xxxx, reg_tmp6);
    // 40: max
    reg_tmp6 = max(-uniforms.f[81].xxxx, reg_tmp6);
    // 41: mov
    reg_tmp2 = uniforms.f[95];
    // 42: mov
    reg_tmp3 = uniforms.f[94];
    // 43: mul
    reg_tmp1.z = (mul_safe(reg_tmp6.xxxx, reg_tmp6.xxxx)).z;
    // 44: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 45: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 46: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 47: mov
    reg_tmp2 = uniforms.f[93];
    // 48: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 49: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 50: mul
    reg_tmp1.y = (mul_safe(reg_tmp1.yyyy, reg_tmp6.xxxx)).y;
    // 51: mov
    reg_tmp4.x = (reg_tmp1.xxxx).x;
    // 52: mov
    reg_tmp5.x = (reg_tmp1.yyyy).x;
    // 53: mov
    reg_tmp2 = uniforms.f[95];
    // 54: mov
    reg_tmp3 = uniforms.f[94];
    // 55: mul
    reg_tmp1.z = (mul_safe(reg_tmp6.yyyy, reg_tmp6.yyyy)).z;
    // 56: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 57: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 58: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 59: mov
    reg_tmp2 = uniforms.f[93];
    // 60: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 61: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 62: mul
    reg_tmp1.y = (mul_safe(reg_tmp1.yyyy, reg_tmp6.yyyy)).y;
    // 63: mov
    reg_tmp4.y = (reg_tmp1.xxxx).y;
    // 64: mov
    reg_tmp5.y = (reg_tmp1.yyyy).y;
    // 65: mov
    reg_tmp2 = uniforms.f[95];
    // 66: mov
    reg_tmp3 = uniforms.f[94];
    // 67: mul
    reg_tmp1.z = (mul_safe(reg_tmp6.zzzz, reg_tmp6.zzzz)).z;
    // 68: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 69: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 70: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 71: mov
    reg_tmp2 = uniforms.f[93];
    // 72: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 73: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 74: mul
    reg_tmp1.y = (mul_safe(reg_tmp1.yyyy, reg_tmp6.zzzz)).y;
    // 75: mov
    reg_tmp4.z = (reg_tmp1.xxxx).z;
    // 76: mov
    reg_tmp5.z = (reg_tmp1.yyyy).z;
    // 77: mul
    reg_tmp2.x = (mul_safe(reg_tmp4.yyyy, reg_tmp5.zzzz)).x;
    // 78: mul
    reg_tmp2.y = (mul_safe(reg_tmp5.yyyy, reg_tmp5.zzzz)).y;
    // 79: mul
    reg_tmp6.x = (mul_safe(reg_tmp4.yyyy, reg_tmp4.zzzz)).x;
    // 80: mov
    reg_tmp6.y = (reg_tmp5.zzzz).y;
    // 81: mul
    reg_tmp6.z = (mul_safe(-reg_tmp5.yyyy, reg_tmp4.zzzz)).z;
    // 82: mov
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    // 83: mul
    reg_tmp7.x = (mul_safe(-reg_tmp2.xxxx, reg_tmp4.xxxx)).x;
    // 84: mad
    reg_tmp7.x = (fma_safe(reg_tmp5.yyyy, reg_tmp5.xxxx, reg_tmp7.xxxx)).x;
    // 85: mul
    reg_tmp7.y = (mul_safe(reg_tmp4.zzzz, reg_tmp4.xxxx)).y;
    // 86: mul
    reg_tmp7.z = (mul_safe(reg_tmp2.yyyy, reg_tmp4.xxxx)).z;
    // 87: mad
    reg_tmp7.z = (fma_safe(reg_tmp4.yyyy, reg_tmp5.xxxx, reg_tmp7.zzzz)).z;
    // 88: mov
    reg_tmp7.w = (uniforms.f[0].xxxx).w;
    // 89: mul
    reg_tmp8.x = (mul_safe(reg_tmp2.xxxx, reg_tmp5.xxxx)).x;
    // 90: mad
    reg_tmp8.x = (fma_safe(reg_tmp5.yyyy, reg_tmp4.xxxx, reg_tmp8.xxxx)).x;
    // 91: mul
    reg_tmp8.y = (mul_safe(-reg_tmp4.zzzz, reg_tmp5.xxxx)).y;
    // 92: mul
    reg_tmp8.z = (mul_safe(-reg_tmp2.yyyy, reg_tmp5.xxxx)).z;
    // 93: mad
    reg_tmp8.z = (fma_safe(reg_tmp4.yyyy, reg_tmp4.xxxx, reg_tmp8.zzzz)).z;
    // 94: mov
    reg_tmp8.w = (uniforms.f[0].xxxx).w;
    // 95: mov
    reg_tmp9 = uniforms.f[0].xxxz;
    return false;
}
bool sub_146_166() {
    // 146: mov
    reg_tmp2 = uniforms.f[90];
    // 147: mov
    reg_tmp3 = uniforms.f[91];
    // 148: mov
    reg_tmp4 = uniforms.f[92];
    // 149: mov
    reg_tmp5 = uniforms.f[0].xxxz;
    // 150: mul
    reg_tmp6 = mul_safe(uniforms.f[86].xxxx, reg_tmp2);
    // 151: mad
    reg_tmp6 = fma_safe(reg_tmp3, uniforms.f[86].yyyy, reg_tmp6);
    // 152: mad
    reg_tmp6 = fma_safe(reg_tmp4, uniforms.f[86].zzzz, reg_tmp6);
    // 153: mad
    reg_tmp6 = fma_safe(reg_tmp5, uniforms.f[86].wwww, reg_tmp6);
    // 154: mul
    reg_tmp7 = mul_safe(uniforms.f[87].xxxx, reg_tmp2);
    // 155: mad
    reg_tmp7 = fma_safe(reg_tmp3, uniforms.f[87].yyyy, reg_tmp7);
    // 156: mad
    reg_tmp7 = fma_safe(reg_tmp4, uniforms.f[87].zzzz, reg_tmp7);
    // 157: mad
    reg_tmp7 = fma_safe(reg_tmp5, uniforms.f[87].wwww, reg_tmp7);
    // 158: mul
    reg_tmp8 = mul_safe(uniforms.f[88].xxxx, reg_tmp2);
    // 159: mad
    reg_tmp8 = fma_safe(reg_tmp3, uniforms.f[88].yyyy, reg_tmp8);
    // 160: mad
    reg_tmp8 = fma_safe(reg_tmp4, uniforms.f[88].zzzz, reg_tmp8);
    // 161: mad
    reg_tmp8 = fma_safe(reg_tmp5, uniforms.f[88].wwww, reg_tmp8);
    // 162: mul
    reg_tmp9 = mul_safe(uniforms.f[89].xxxx, reg_tmp2);
    // 163: mad
    reg_tmp9 = fma_safe(reg_tmp3, uniforms.f[89].yyyy, reg_tmp9);
    // 164: mad
    reg_tmp9 = fma_safe(reg_tmp4, uniforms.f[89].zzzz, reg_tmp9);
    // 165: mad
    reg_tmp9 = fma_safe(reg_tmp5, uniforms.f[89].wwww, reg_tmp9);
    return false;
}
bool sub_167_249() {
    // 167: rcp
    reg_tmp2.x = rcp_safe(uniforms.f[81].yyyy.x);
    // 168: mul
    reg_tmp2.xy = (mul_safe(uniforms.f[2].zwww, reg_tmp2.xxxx)).xy;
    // 169: add
    reg_tmp2.xy = (uniforms.f[0].yyyy + reg_tmp2.xyyy).xy;
    // 170: flr
    reg_tmp3.xy = (floor(reg_tmp2.xyyy)).xy;
    // 171: mul
    reg_tmp2.xy = (mul_safe(uniforms.f[81].yyyy, reg_tmp3.xyyy)).xy;
    // 172: add
    reg_tmp2.xy = (uniforms.f[2].zwww + -reg_tmp2.xyyy).xy;
    // 173: min
    reg_tmp0.xy = (min(uniforms.f[81].xxxx, reg_tmp2.xyyy)).xy;
    // 174: max
    reg_tmp0.xy = (max(-uniforms.f[81].xxxx, reg_tmp0.xyyy)).xy;
    // 175: mov
    reg_tmp2 = uniforms.f[95];
    // 176: mov
    reg_tmp3 = uniforms.f[94];
    // 177: mul
    reg_tmp1.z = (mul_safe(reg_tmp0.xxxx, reg_tmp0.xxxx)).z;
    // 178: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 179: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 180: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 181: mov
    reg_tmp2 = uniforms.f[93];
    // 182: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 183: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 184: mul
    reg_tmp1.y = (mul_safe(reg_tmp1.yyyy, reg_tmp0.xxxx)).y;
    // 185: mov
    reg_tmp5.x = (uniforms.f[5].wwww).x;
    // 186: mov
    reg_tmp14.xy = (vs_in_reg1.xyyy).xy;
    // 187: cmp
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    // 188: ifc
    if (conditional_code.x) {
        sub_189_190();
    }
    // 190: cmp
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    // 191: ifc
    if (conditional_code.x) {
        sub_192_193();
    }
    // 193: cmp
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 194: ifc
    if (conditional_code.x) {
        sub_195_196();
    }
    // 196: cmp
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 197: ifc
    if (conditional_code.x) {
        sub_198_200();
    }
    // 200: mov
    reg_tmp3 = reg_tmp14.xyxy;
    // 201: add
    reg_tmp3.y = (uniforms.f[0].zzzz + -reg_tmp3.yyyy).y;
    // 202: add
    reg_tmp3.w = (uniforms.f[0].zzzz + -reg_tmp3.wwww).w;
    // 203: mul
    reg_tmp2 = mul_safe(uniforms.f[83].xxyy, reg_tmp3);
    // 204: add
    reg_tmp2 = -uniforms.f[0].yyyy + reg_tmp2;
    // 205: mul
    reg_tmp2 = mul_safe(reg_tmp2, reg_tmp1.xyyx);
    // 206: add
    reg_tmp2.x = (reg_tmp2.xxxx + -reg_tmp2.yyyy).x;
    // 207: add
    reg_tmp2.y = (reg_tmp2.zzzz + reg_tmp2.wwww).y;
    // 208: mov
    reg_tmp4.xy = (uniforms.f[3].xyyy).xy;
    // 209: mad
    reg_tmp3.xy = (fma_safe(reg_tmp2.xyyy, uniforms.f[3].zwww, reg_tmp4.xyyy)).xy;
    // 210: add
    reg_tmp3.xy = (uniforms.f[0].yyyy + reg_tmp3.xyyy).xy;
    // 211: mov
    reg_tmp11.xy = (reg_tmp3.xyyy).xy;
    // 212: mov
    reg_tmp2 = uniforms.f[95];
    // 213: mov
    reg_tmp3 = uniforms.f[94];
    // 214: mul
    reg_tmp1.z = (mul_safe(reg_tmp0.yyyy, reg_tmp0.yyyy)).z;
    // 215: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 216: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 217: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 218: mov
    reg_tmp2 = uniforms.f[93];
    // 219: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 220: mad
    reg_tmp1.xy = (fma_safe(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 221: mul
    reg_tmp1.y = (mul_safe(reg_tmp1.yyyy, reg_tmp0.yyyy)).y;
    // 222: mov
    reg_tmp5.x = (uniforms.f[6].wwww).x;
    // 223: mov
    reg_tmp14.xy = (vs_in_reg1.xyyy).xy;
    // 224: cmp
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    // 225: ifc
    if (conditional_code.x) {
        sub_226_227();
    }
    // 227: cmp
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    // 228: ifc
    if (conditional_code.x) {
        sub_229_230();
    }
    // 230: cmp
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 231: ifc
    if (conditional_code.x) {
        sub_232_233();
    }
    // 233: cmp
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 234: ifc
    if (conditional_code.x) {
        sub_235_237();
    }
    // 237: mov
    reg_tmp3 = reg_tmp14.xyxy;
    // 238: add
    reg_tmp3.y = (uniforms.f[0].zzzz + -reg_tmp3.yyyy).y;
    // 239: add
    reg_tmp3.w = (uniforms.f[0].zzzz + -reg_tmp3.wwww).w;
    // 240: mul
    reg_tmp2 = mul_safe(uniforms.f[83].zzww, reg_tmp3);
    // 241: add
    reg_tmp2 = -uniforms.f[0].yyyy + reg_tmp2;
    // 242: mul
    reg_tmp2 = mul_safe(reg_tmp2, reg_tmp1.xyyx);
    // 243: add
    reg_tmp2.x = (reg_tmp2.xxxx + -reg_tmp2.yyyy).x;
    // 244: add
    reg_tmp2.y = (reg_tmp2.zzzz + reg_tmp2.wwww).y;
    // 245: mov
    reg_tmp4.xy = (uniforms.f[4].xyyy).xy;
    // 246: mad
    reg_tmp3.xy = (fma_safe(reg_tmp2.xyyy, uniforms.f[4].zwww, reg_tmp4.xyyy)).xy;
    // 247: add
    reg_tmp3.xy = (uniforms.f[0].yyyy + reg_tmp3.xyyy).xy;
    // 248: mov
    reg_tmp12.xy = (reg_tmp3.xyyy).xy;
    return false;
}
bool sub_189_190() {
    // 189: mov
    reg_tmp14.xy = (vs_in_reg1.xyyy).xy;
    return false;
}
bool sub_192_193() {
    // 192: add
    reg_tmp14.x = (uniforms.f[0].zzzz + -vs_in_reg1.xxxx).x;
    return false;
}
bool sub_195_196() {
    // 195: add
    reg_tmp14.y = (uniforms.f[0].zzzz + -vs_in_reg1.yyyy).y;
    return false;
}
bool sub_198_200() {
    // 198: add
    reg_tmp14.x = (uniforms.f[0].zzzz + -vs_in_reg1.xxxx).x;
    // 199: add
    reg_tmp14.y = (uniforms.f[0].zzzz + -vs_in_reg1.yyyy).y;
    return false;
}
bool sub_226_227() {
    // 226: mov
    reg_tmp14.xy = (vs_in_reg1.xyyy).xy;
    return false;
}
bool sub_229_230() {
    // 229: add
    reg_tmp14.x = (uniforms.f[0].zzzz + -vs_in_reg1.xxxx).x;
    return false;
}
bool sub_232_233() {
    // 232: add
    reg_tmp14.y = (uniforms.f[0].zzzz + -vs_in_reg1.yyyy).y;
    return false;
}
bool sub_235_237() {
    // 235: add
    reg_tmp14.x = (uniforms.f[0].zzzz + -vs_in_reg1.xxxx).x;
    // 236: add
    reg_tmp14.y = (uniforms.f[0].zzzz + -vs_in_reg1.yyyy).y;
    return false;
}
bool sub_250_4096() {
    // 250: call
    {
        sub_0_8();
    }
    // 251: add
    reg_tmp10.xy = (uniforms.f[84].xyyy + reg_tmp10.xyyy).xy;
    // 252: mul
    reg_tmp10.xyz = (mul_safe(uniforms.f[2].xyxx, reg_tmp10.xyzz)).xyz;
    // 253: mov
    reg_tmp14 = reg_tmp10;
    // 254: mov
    reg_tmp0 = uniforms.f[7];
    // 255: call
    {
        sub_33_96();
    }
    // 256: dp4
    reg_tmp10.x = dot(reg_tmp14, reg_tmp6);
    // 257: dp4
    reg_tmp10.y = dot(reg_tmp14, reg_tmp7);
    // 258: dp4
    reg_tmp10.z = dot(reg_tmp14, reg_tmp8);
    // 259: dp4
    reg_tmp10.w = dot(reg_tmp14, reg_tmp9);
    // 260: mov
    reg_tmp2.x = (uniforms.f[8].yyyy).x;
    // 261: mov
    reg_tmp2.y = (uniforms.f[9].yyyy).y;
    // 262: mov
    reg_tmp2.z = (uniforms.f[10].yyyy).z;
    // 263: mov
    reg_tmp3.xyz = (uniforms.f[6].xyzz).xyz;
    // 264: dp3
    reg_tmp4.x = dot(vec3(reg_tmp3.xyzz), vec3(reg_tmp3.xyzz));
    // 265: cmp
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
    // 266: ifc
    if (conditional_code.x) {
        sub_267_268();
    } else {
        sub_268_269();
    }
    // 269: mul
    reg_tmp3.xyz = (mul_safe(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
    // 270: mul
    reg_tmp4.xyz = (mul_safe(reg_tmp3.yzxx, reg_tmp2.zxyy)).xyz;
    // 271: mad
    reg_tmp4.xyz = (fma_safe(-reg_tmp2.yzxx, reg_tmp3.zxyy, reg_tmp4)).xyz;
    // 272: dp3
    reg_tmp5.x = dot(vec3(reg_tmp4.xyzz), vec3(reg_tmp4.xyzz));
    // 273: cmp
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp5.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp5.y;
    // 274: ifc
    if (conditional_code.x) {
        sub_275_276();
    } else {
        sub_276_277();
    }
    // 277: mul
    reg_tmp4.xyz = (mul_safe(reg_tmp4.xyzz, reg_tmp5.xxxx)).xyz;
    // 278: mul
    reg_tmp5.xyz = (mul_safe(reg_tmp3.yzxx, reg_tmp4.zxyy)).xyz;
    // 279: mad
    reg_tmp5.xyz = (fma_safe(-reg_tmp4.yzxx, reg_tmp3.zxyy, reg_tmp5)).xyz;
    // 280: mov
    reg_tmp6.x = (reg_tmp4.xxxx).x;
    // 281: mov
    reg_tmp6.y = (reg_tmp3.xxxx).y;
    // 282: mov
    reg_tmp6.z = (reg_tmp5.xxxx).z;
    // 283: mov
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    // 284: mov
    reg_tmp7.x = (reg_tmp4.yyyy).x;
    // 285: mov
    reg_tmp7.y = (reg_tmp3.yyyy).y;
    // 286: mov
    reg_tmp7.z = (reg_tmp5.yyyy).z;
    // 287: mov
    reg_tmp7.w = (uniforms.f[0].xxxx).w;
    // 288: mov
    reg_tmp8.x = (reg_tmp4.zzzz).x;
    // 289: mov
    reg_tmp8.y = (reg_tmp3.zzzz).y;
    // 290: mov
    reg_tmp8.z = (reg_tmp5.zzzz).z;
    // 291: mov
    reg_tmp8.w = (uniforms.f[0].xxxx).w;
    // 292: mov
    reg_tmp9 = uniforms.f[0].xxxz;
    // 293: dp4
    reg_tmp2.x = dot(reg_tmp10, reg_tmp6);
    // 294: dp4
    reg_tmp2.y = dot(reg_tmp10, reg_tmp7);
    // 295: dp4
    reg_tmp2.z = dot(reg_tmp10, reg_tmp8);
    // 296: dp4
    reg_tmp2.w = dot(reg_tmp10, reg_tmp9);
    // 297: mov
    reg_tmp3.xyz = (uniforms.f[5].xyzz).xyz;
    // 298: add
    reg_tmp3.xyz = (uniforms.f[85].xyzz + -reg_tmp3.xyzz).xyz;
    // 299: dp3
    reg_tmp4.x = dot(vec3(reg_tmp3.xyzz), vec3(reg_tmp3.xyzz));
    // 300: cmp
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
    // 301: ifc
    if (conditional_code.x) {
        sub_302_303();
    } else {
        sub_303_304();
    }
    // 304: mul
    reg_tmp3.xyz = (mul_safe(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
    // 305: add
    reg_tmp10.xyz = (uniforms.f[5].xyzz + reg_tmp2.xyzz).xyz;
    // 306: mad
    reg_tmp10.xyz = (fma_safe(reg_tmp3.xyzz, uniforms.f[84].zzzz, reg_tmp10.xyzz)).xyz;
    // 307: call
    {
        sub_146_166();
    }
    // 308: mov
    reg_tmp2 = reg_tmp10;
    // 309: dp4
    reg_tmp10.x = dot(reg_tmp2, reg_tmp6);
    // 310: dp4
    reg_tmp10.y = dot(reg_tmp2, reg_tmp7);
    // 311: dp4
    reg_tmp10.z = dot(reg_tmp2, reg_tmp8);
    // 312: dp4
    reg_tmp10.w = dot(reg_tmp2, reg_tmp9);
    // 313: mov
    reg_tmp2 = uniforms.f[1];
    // 314: max
    reg_tmp3 = max(uniforms.f[0].xxxx, reg_tmp2);
    // 315: min
    reg_tmp2 = min(uniforms.f[0].zzzz, reg_tmp3);
    // 316: mov
    reg_tmp13 = reg_tmp2;
    // 317: call
    {
        sub_167_249();
    }
    // 318: call
    {
        sub_9_32();
    }
    // 319: end
    return true;
}
bool sub_267_268() {
    // 267: mov
    reg_tmp4.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_268_269() {
    // 268: rsq
    reg_tmp4.x = rsq_safe(reg_tmp4.xxxx.x);
    return false;
}
bool sub_275_276() {
    // 275: mov
    reg_tmp5.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_276_277() {
    // 276: rsq
    reg_tmp5.x = rsq_safe(reg_tmp5.xxxx.x);
    return false;
}
bool sub_302_303() {
    // 302: mov
    reg_tmp4.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_303_304() {
    // 303: rsq
    reg_tmp4.x = rsq_safe(reg_tmp4.xxxx.x);
    return false;
}
// reference: 4E8B894529892E93, 30A122D3BC979B4D
// program: 30A122D3BC979B4D, CEF02063E9A18B2F, EA83856FEB3CAEC2
// reference: 619FE8706CFEFE23, D82E12A9D19ACD63
// reference: 0570378C2757CBBA, B8A2CA3DB47999BF
// reference: 8E90E023FE9CC808, B8A2CA3DB47999BF
// reference: 99DFFFBA8815260E, 5447A3297E824FE0
// reference: 123F281551DE25BC, 5447A3297E824FE0
// reference: 9C044B2ABCADC215, B543C911C8D7EAAB
// reference: FFDADE3A3D4F5025, B8A2CA3DB47999BF
// reference: 743A099564E00014, B8A2CA3DB47999BF
// reference: 10D5D669F35884D2, D82E12A9D19ACD63
// reference: 10D5D669733CD751, D82E12A9D19ACD63
// reference: F03B0AFACDE64D8F, DEFAC6F185DB6EB9
// reference: 53C7CE3738CB5642, 48B3A6FBA8498826
// reference: 53C7CE370E39C6B1, 48B3A6FBA8498826
// reference: 4140B39550A36299, F70C4BC6991FAFE8
// reference: 4140B3956651F26A, F70C4BC6991FAFE8
// reference: FC835C70D6819D46, 65138AC5CA635BBF
// reference: 31CD189239D78153, DEFAC6F185DB6EB9
// reference: 31CD18920F2511A0, DEFAC6F185DB6EB9
// reference: 09D77F3DA9AD37AC, C686B1FD59F65802
// reference: 09D77F3D29C9642F, C686B1FD59F65802
// reference: A693ED7AD15AEEB7, 46F6395BEBA5C2A1
// reference: A693ED7A67CC2DC7, 46F6395BEBA5C2A1
// reference: A693ED7A513EBD34, 46F6395BEBA5C2A1
// reference: 09D77F3D1F3BF4DC, C686B1FD59F65802
// reference: A693ED7AE7A87E44, 46F6395BEBA5C2A1
// reference: 73DD1B01C3463122, DEFAC6F185DB6EB9
// reference: F019946006C6B817, 1BE8D5DEECF8172C
// reference: 30CB5B291BE860DA, 734B56B7CFCD3D95
// reference: 4E8B89452A1C6EE2, 30A122D3BC979B4D
// reference: 619FE8706F6BBE52, D82E12A9D19ACD63
// reference: 0570378C24C28BCB, B8A2CA3DB47999BF
// reference: 8E90E023FD098879, B8A2CA3DB47999BF
// reference: EA7F3FDFB6A0BDE0, D82E12A9D19ACD63
// reference: 99DFFFBA8B80667F, 5447A3297E824FE0
// reference: 123F2815524B65CD, 5447A3297E824FE0
// reference: 4787015CD275AE05, D82E12A9D19ACD63
// reference: 2368DEA099DC9B9C, B8A2CA3DB47999BF
// reference: A888090F4017982E, B8A2CA3DB47999BF
// reference: CC67D6F30BBEADB7, D82E12A9D19ACD63
// reference: AF1C89C7DBC5728B, 5447A3297E824FE0
// reference: 24FC5E68020E7139, 5447A3297E824FE0
// reference: DE575174BCADC215, B543C911C8D7EAAB
// reference: BD89C4643D4F5025, B8A2CA3DB47999BF
// reference: 366913CB64E00014, B8A2CA3DB47999BF
// reference: 5286CC37F35884D2, D82E12A9D19ACD63
// reference: 5286CC37733CD751, D82E12A9D19ACD63
// reference: B26810A4CDE64D8F, DEFAC6F185DB6EB9
// reference: 0B00844C38CB5642, 48B3A6FBA8498826
// reference: 0B00844C0E39C6B1, 48B3A6FBA8498826
// reference: 1987F9EE50A36299, F70C4BC6991FAFE8
// reference: 1987F9EE6651F26A, F70C4BC6991FAFE8
// reference: A444160BD6819D46, 65138AC5CA635BBF
// reference: 690A52E939D78153, DEFAC6F185DB6EB9
// reference: 690A52E90F2511A0, DEFAC6F185DB6EB9
// reference: 77A38A92846733D9, DEFAC6F185DB6EB9
// reference: 8755CE15CF5B76C8, D82E12A9D19ACD63
// reference: E3BA11E984F24351, B8A2CA3DB47999BF
// reference: 685AC6465D3940E3, B8A2CA3DB47999BF
// reference: 0CB519BA1690757A, D82E12A9D19ACD63
// reference: AE0F4638DBC5728B, 5447A3297E824FE0
// reference: 25EF9197020E7139, 5447A3297E824FE0
// reference: DF449E8BBCADC215, B543C911C8D7EAAB
// reference: BC9A0B9B3D4F5025, B8A2CA3DB47999BF
// reference: 377ADC3464E00014, B8A2CA3DB47999BF
// reference: 539503C8F35884D2, D82E12A9D19ACD63
// reference: 539503C8733CD751, D82E12A9D19ACD63
// reference: B37BDF5BCDE64D8F, DEFAC6F185DB6EB9
// reference: 675285E538CB5642, 48B3A6FBA8498826
// reference: 675285E50E39C6B1, 48B3A6FBA8498826
// reference: 75D5F84750A36299, F70C4BC6991FAFE8
// reference: 75D5F8476651F26A, F70C4BC6991FAFE8
// reference: C81617A2D6819D46, 65138AC5CA635BBF
// reference: 0558534039D78153, DEFAC6F185DB6EB9
// reference: 055853400F2511A0, DEFAC6F185DB6EB9
// reference: 5B087F4BF4A876F8, D82E12A9D19ACD63
// reference: 3FE7A0B7BF014361, B8A2CA3DB47999BF
// reference: B407771866CA40D3, B8A2CA3DB47999BF
// reference: D0E8A8E42D63754A, D82E12A9D19ACD63
// reference: 9F462B26B2C172CA, 5447A3297E824FE0
// reference: 14A6FC896B0A7178, 5447A3297E824FE0
// reference: E7B2C552BCADC215, B543C911C8D7EAAB
// reference: 846C50423D4F5025, B8A2CA3DB47999BF
// reference: 0F8C87ED64E00014, B8A2CA3DB47999BF
// reference: 6B635811F35884D2, D82E12A9D19ACD63
// reference: 6B635811733CD751, D82E12A9D19ACD63
// reference: 8B8D8482CDE64D8F, DEFAC6F185DB6EB9
// reference: 30CB5B29A88E8D0F, 734B56B7CFCD3D95
// reference: 8755CE157C3D9B1D, D82E12A9D19ACD63
// reference: E3BA11E93794AE84, B8A2CA3DB47999BF
// reference: 685AC646EE5FAD36, B8A2CA3DB47999BF
// reference: AE0F4638B2C172CA, 5447A3297E824FE0
// reference: 25EF91976B0A7178, 5447A3297E824FE0
// reference: 0CB519BAA5F698AF, D82E12A9D19ACD63
// reference: 635646A909AA22DA, DD35FB9CAEB223CF
// reference: 2983DF17E964C139, 7CBFDF058AA76880
// reference: 2983DF1713969285, 734B56B7CFCD3D95
// reference: 6FF8C153A92B3D1F, DEFAC6F185DB6EB9
// reference: 44945D2706C6B817, 1BE8D5DEECF8172C
// reference: 2983DF171BE860DA, 734B56B7CFCD3D95
// reference: 9E1D4A2BCF5B76C8, D82E12A9D19ACD63
// reference: FAF295D784F24351, B8A2CA3DB47999BF
// reference: 711242785D3940E3, B8A2CA3DB47999BF
// reference: 15FD9D841690757A, D82E12A9D19ACD63
// reference: B747C206DBC5728B, 5447A3297E824FE0
// reference: 3CA715A9020E7139, 5447A3297E824FE0
// reference: C60C1AB5BCADC215, B543C911C8D7EAAB
// reference: A5D28FA53D4F5025, B8A2CA3DB47999BF
// reference: 2E32580A64E00014, B8A2CA3DB47999BF
// reference: 4ADD87F6F35884D2, D82E12A9D19ACD63
// reference: 4ADD87F6733CD751, D82E12A9D19ACD63
// reference: AA335B65CDE64D8F, DEFAC6F185DB6EB9
// reference: E76B3F00D1C9E2EF, 3295BFC9E1117A37
// reference: 2983DF17CBE81FE6, 7CBFDF058AA76880
// reference: 2983DF17311A4C5A, 734B56B7CFCD3D95
// reference: 6FF8C1538BA7E3C0, DEFAC6F185DB6EB9
// reference: F30AC81BD275AE05, D82E12A9D19ACD63
// reference: 97E517E799DC9B9C, B8A2CA3DB47999BF
// reference: 1C05C0484017982E, B8A2CA3DB47999BF
// reference: 78EA1FB40BBEADB7, D82E12A9D19ACD63
// reference: 1B914080DBC5728B, 5447A3297E824FE0
// reference: 9071972F020E7139, 5447A3297E824FE0
// reference: 6ADA9833BCADC215, B543C911C8D7EAAB
// reference: 09040D233D4F5025, B8A2CA3DB47999BF
// reference: 82E4DA8C64E00014, B8A2CA3DB47999BF
// reference: E60B0570F35884D2, D82E12A9D19ACD63
// reference: E60B0570733CD751, D82E12A9D19ACD63
// reference: 06E5D9E3CDE64D8F, DEFAC6F185DB6EB9
// reference: 2983DF17D7F4D6C0, 734B56B7CFCD3D95
// reference: 6FF8C1536D49795A, DEFAC6F185DB6EB9
// reference: 26AA3FB606C6B817, 1BE8D5DEECF8172C
// reference: 9134AA8AD275AE05, D82E12A9D19ACD63
// reference: F5DB757699DC9B9C, B8A2CA3DB47999BF
// reference: 7E3BA2D94017982E, B8A2CA3DB47999BF
// reference: 1AD47D250BBEADB7, D82E12A9D19ACD63
// reference: 79AF2211DBC5728B, 5447A3297E824FE0
// reference: F24FF5BE020E7139, 5447A3297E824FE0
// reference: 08E4FAA2BCADC215, B543C911C8D7EAAB
// reference: 6B3A6FB23D4F5025, B8A2CA3DB47999BF
// reference: E0DAB81D64E00014, B8A2CA3DB47999BF
// reference: 843567E1F35884D2, D82E12A9D19ACD63
// reference: 843567E1733CD751, D82E12A9D19ACD63
// reference: 64DBBB72CDE64D8F, DEFAC6F185DB6EB9
// reference: 47D41E5806C6B817, 1BE8D5DEECF8172C
// reference: F04A8B64D275AE05, D82E12A9D19ACD63
// reference: 94A5549899DC9B9C, B8A2CA3DB47999BF
// reference: 1F4583374017982E, B8A2CA3DB47999BF
// reference: 7BAA5CCB0BBEADB7, D82E12A9D19ACD63
// reference: 18D103FFDBC5728B, 5447A3297E824FE0
// reference: 9331D450020E7139, 5447A3297E824FE0
// reference: BA6B5C7DDCB1F74F, D82E12A9D19ACD63
// reference: C06E00AAB06D7C38, DEFAC6F185DB6EB9
// reference: 7483BC6ADA8CC360, D82E12A9D19ACD63
// reference: 48FDFEF91BE860DA, 734B56B7CFCD3D95
// reference: FF636BC5CF5B76C8, D82E12A9D19ACD63
// reference: 9B8CB43984F24351, B8A2CA3DB47999BF
// reference: 106C63965D3940E3, B8A2CA3DB47999BF
// reference: 7483BC6A1690757A, D82E12A9D19ACD63
// reference: D639E3E8DBC5728B, 5447A3297E824FE0
// reference: 5DD93447020E7139, 5447A3297E824FE0
// reference: C149C0C420EEEA14, 20A72E97AF8E39F2
// reference: 88F5DBC0DB0E9BAD, 79AE694A7B008028
// reference: 2D2562020BBF60EF, 95AC54D58E4F10E1
// shader: 8B30, 882E490107A70418

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTUnsigned(6, max(dot(normal, normalize(view)), 0.0)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor1.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (textureProj(tex0, vec3(texcoord0, texcoord0_w)).a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2 * 2.0, alpha_output_2 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) + (secondary_fragment_color.rrr), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((texcolor1.aaa) * (secondary_fragment_color.ggg) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: A180B4A2D182F579, 882E490107A70418
// program: 46F6395BEBA5C2A1, 3B3AE026C742C7D5, 882E490107A70418
// shader: 8B30, 3099A8B180D0E876

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor1.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor1.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (texcolor1.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 23D0E157D3752907, 3099A8B180D0E876
// program: 46F6395BEBA5C2A1, 3B3AE026C742C7D5, 3099A8B180D0E876
// reference: 0F4ECC49D6A32172, B8A2CA3DB47999BF
// reference: 84AE1BE68F0C7143, B8A2CA3DB47999BF
// reference: E041C41A18B4F585, D82E12A9D19ACD63
// reference: E041C41A98D0A606, D82E12A9D19ACD63
// reference: 3172975672BB2E55, DEFAC6F185DB6EB9
// reference: 445C696732750156, 95AC54D58E4F10E1
// reference: 55459F058A871C73, 46F6395BEBA5C2A1
// reference: 4AA9EA32D3752907, 3099A8B180D0E876
// reference: 0420E19BBA0C2262, 3099A8B180D0E876
// reference: 589900718DC54315, DEFAC6F185DB6EB9
// reference: 2983DF17A88E8D0F, 734B56B7CFCD3D95
// shader: 8B30, 11CD7E777F4C640F

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(view)), 0.0))) * light_src[0].specular_0) + ((lut_scale_d1 * LookupLightingLUTUnsigned(1, max(dot(normal, normalize(view)), 0.0))) * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor1.rgb) * (const_color[0].aaa) + (texcolor2.rgb) * (vec3(1.0) - (const_color[0].aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].r) * (const_color[0].a) + (texcolor2.a) * (1.0 - (const_color[0].a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2 * 2.0, alpha_output_2 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((texcolor1.aaa) * (secondary_fragment_color.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) * (vec3(1.0) - textureProj(tex0, vec3(texcoord0, texcoord0_w)).rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a) * (const_color[5].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 5993CA7A325B0CF4, 11CD7E777F4C640F
// program: C686B1FD59F65802, AD7922A63ED54CA7, 11CD7E777F4C640F
// shader: 8B30, 0910CEE3B02AD3EB

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(view)), 0.0))) * light_src[0].specular_0) + ((lut_scale_d1 * LookupLightingLUTUnsigned(1, max(dot(normal, normalize(view)), 0.0))) * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].r) * (const_color[0].a) + (texcolor2.a) * (1.0 - (const_color[0].a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1 * 2.0, alpha_output_1 * 1.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((secondary_fragment_color.rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (vec3(1.0) - textureProj(tex0, vec3(texcoord0, texcoord0_w)).rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a) * (const_color[5].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: C5FBCCCFD5C34DA6, 0910CEE3B02AD3EB
// program: 46F6395BEBA5C2A1, 3B3AE026C742C7D5, 0910CEE3B02AD3EB
// reference: 65BEE4ABCA19542A, ED9AAA1E39CE1504
// reference: F74BED410E643CA1, DC9976EED0CC7E67
// reference: 2EF84CDB85E4372E, D82E12A9D19ACD63
// reference: 4A179327CE4D02B7, B8A2CA3DB47999BF
// reference: C1F7448817860105, B8A2CA3DB47999BF
// reference: D6B85B11B2C172CA, 5447A3297E824FE0
// reference: 5D588CBE6B0A7178, 5447A3297E824FE0
// reference: 3E8619AED6A32172, B8A2CA3DB47999BF
// reference: B566CE018F0C7143, B8A2CA3DB47999BF
// reference: D18911FD18B4F585, D82E12A9D19ACD63
// reference: D18911FD98D0A606, D82E12A9D19ACD63
// reference: 00BA42B172BB2E55, DEFAC6F185DB6EB9
// reference: 48FDFEF913969285, 734B56B7CFCD3D95
// reference: A5189B745C2F349C, D82E12A9D19ACD63
// reference: D4F4BEF9C3444BB3, 4982B44D494E20C9
// program: D3C285AB726883C8, 4BD70AD09292A3DA, 4982B44D494E20C9
// reference: A3F040DA70E0C038, D3C285AB726883C8
// shader: 8B30, 0BF681F5923810E1

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor0.rgb) * (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor0.a) + (const_color[2].a) - 0.5, 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2 * 1.0, alpha_output_2 * 2.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (last_tex_env_out.aaa), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: BF0E263764F6003E, 0BF681F5923810E1
// program: D82E12A9D19ACD63, 5D764F9A6220D694, 0BF681F5923810E1
// reference: 58AA84A464C761DA, 4F823895C8BC6A43
// shader: 8B30, 5D57F51D656636F9

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor1.rgb) * (texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor1.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: EF62D5DE57948B18, 5D57F51D656636F9
// program: 46F6395BEBA5C2A1, 3B3AE026C742C7D5, 5D57F51D656636F9
// shader: 8B30, FA80A6A78835943F

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((secondary_fragment_color.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 3E4FB805B6F0D597, FA80A6A78835943F
// program: 65138AC5CA635BBF, 3B3AE026C742C7D5, FA80A6A78835943F
// program: DC9976EED0CC7E67, CEF02063E9A18B2F, ED9AAA1E39CE1504
// reference: CC84AB991763F44E, DEFAC6F185DB6EB9
// reference: F285935834A13077, 43A7C75AE8CBEC18
// reference: 04CA73C462836985, ED9AAA1E39CE1504
// reference: D57593942F68E2DE, 43A7C75AE8CBEC18
// reference: BFD1BF0257948B18, 5D57F51D656636F9
// shader: 8B30, 1E040B39E96769DC

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTSigned(0, dot(normal, normalize(half_vector)))) * light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((secondary_fragment_color.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 6EFCD2D9B6F0D597, 1E040B39E96769DC
// program: 65138AC5CA635BBF, 3B3AE026C742C7D5, 1E040B39E96769DC
// reference: EF62D5DE0727E1C4, 5D57F51D656636F9
// reference: 7CAB3AEE972D0970, DC9976EED0CC7E67
// reference: 040A1D04D6F210A8, 04D87A5429CE6CD8
// shader: 8B30, 230BDE9CB92CBF45

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a) * (const_color[5].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 60EDA8293E84E4D4, 230BDE9CB92CBF45
// program: 46F6395BEBA5C2A1, 3B3AE026C742C7D5, 230BDE9CB92CBF45
// shader: 8B30, 5148981931EF8A35

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor1.rgb) * (texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor1.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a) * (const_color[5].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: BE5CF2367F67D7DA, 5148981931EF8A35
// program: 46F6395BEBA5C2A1, 3B3AE026C742C7D5, 5148981931EF8A35
// shader: 8B30, BD9D39FF67B36982

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += (((lut_scale_d0 * LookupLightingLUTUnsigned(0, max(dot(normal, normalize(half_vector)), 0.0))) * light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((secondary_fragment_color.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a) * (const_color[5].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 6F719FED9E038955, BD9D39FF67B36982
// program: 65138AC5CA635BBF, 3B3AE026C742C7D5, BD9D39FF67B36982
// reference: 2983DF173BAE2154, 5DC51233DD2793A1
// reference: 72C43A20FE014C6A, 74528811F959F6E2
// reference: F74BED41EBF79E72, DC9976EED0CC7E67
// reference: 841482E58A4503C2, B8A2CA3DB47999BF
// reference: 0FF4554A538E0070, B8A2CA3DB47999BF
// reference: 6B1B8AB6182735E9, D82E12A9D19ACD63
// reference: 851DDCF1E34B824E, 5447A3297E824FE0
// reference: 0EFD0B5E3A8081FC, 5447A3297E824FE0
// reference: 6D239E4E8729D1F6, B8A2CA3DB47999BF
// reference: E6C349E1DE8681C7, B8A2CA3DB47999BF
// reference: 822C961D493E0501, D82E12A9D19ACD63
// reference: 822C961DC95A5682, D82E12A9D19ACD63
// reference: 531FC5512331DED1, DEFAC6F185DB6EB9
// reference: EB355DBC23BBEABB, 734B56B7CFCD3D95
// reference: 4E8B8945CE1FEAA1, 30A122D3BC979B4D
// reference: 619FE8708B683A11, D82E12A9D19ACD63
// reference: 0570378CC0C10F88, B8A2CA3DB47999BF
// reference: 8E90E023190A0C3A, B8A2CA3DB47999BF
// reference: 99DFFFBA6F83E23C, 5447A3297E824FE0
// reference: 123F2815B648E18E, 5447A3297E824FE0
// reference: 71E1BD050BE1B184, B8A2CA3DB47999BF
// reference: FA016AAA524EE1B5, B8A2CA3DB47999BF
// reference: 9EEEB556C5F66573, D82E12A9D19ACD63
// reference: 9EEEB556459236F0, D82E12A9D19ACD63
// reference: 4FDDE61AAFF9BEA3, DEFAC6F185DB6EB9
// reference: 376047FC46F99B26, 1BE8D5DEECF8172C
// reference: EB355DBC5BD743EB, 734B56B7CFCD3D95
// reference: 4E8B89456A234DD3, 30A122D3BC979B4D
// reference: 619FE8702F549D63, D82E12A9D19ACD63
// reference: 0570378C64FDA8FA, B8A2CA3DB47999BF
// reference: 8E90E023BD36AB48, B8A2CA3DB47999BF
// reference: EA7F3FDFF69F9ED1, D82E12A9D19ACD63
// reference: 99DFFFBACBBF454E, 5447A3297E824FE0
// reference: 123F2815127446FC, 5447A3297E824FE0
// reference: 71E1BD05AFDD16F6, B8A2CA3DB47999BF
// reference: FA016AAAF67246C7, B8A2CA3DB47999BF
// reference: 9EEEB55661CAC201, D82E12A9D19ACD63
// reference: 9EEEB556E1AE9182, D82E12A9D19ACD63
// reference: 4FDDE61A0BC519D1, DEFAC6F185DB6EB9
// reference: 94A8E4B946F99B26, 1BE8D5DEECF8172C
// reference: 23367185924A8D34, D82E12A9D19ACD63
// reference: 47D9AE79D9E3B8AD, B8A2CA3DB47999BF
// reference: CC3979D60028BB1F, B8A2CA3DB47999BF
// reference: A8D6A62A4B818E86, D82E12A9D19ACD63
// reference: CBADF91E9BFA51BA, 5447A3297E824FE0
// reference: 404D2EB142315208, 5447A3297E824FE0
// reference: 2393BBA1FF980202, B8A2CA3DB47999BF
// reference: A8736C0EA6375233, B8A2CA3DB47999BF
// reference: CC9CB3F2318FD6F5, D82E12A9D19ACD63
// reference: CC9CB3F2B1EB8576, D82E12A9D19ACD63
// reference: 1DAFE0BE5B800D25, DEFAC6F185DB6EB9
// reference: A5DD005FF85A61F8, EA83856FEB3CAEC2
// reference: 18BC3D03D54B3C8F, EE0B6065741A8CB9
// reference: E76B3F004785E5E7, 3295BFC9E1117A37
// reference: 2983DF175DA418EE, 7CBFDF058AA76880
// reference: 635646A985EEA1D9, DD35FB9CAEB223CF
// reference: 48FDFEF923BBEABB, 734B56B7CFCD3D95
// reference: FF636BC5F708FCA9, D82E12A9D19ACD63
// reference: 9B8CB439BCA1C930, B8A2CA3DB47999BF
// reference: 106C6396656ACA82, B8A2CA3DB47999BF
// reference: 7483BC6A2EC3FF1B, D82E12A9D19ACD63
// reference: 01EC2DEE5FE9714E, 9FB407F1EC1D74B1
// reference: 635646A940139BDB, DD35FB9CAEB223CF
// reference: 635646A9DF690D0B, DD35FB9CAEB223CF
// reference: F56E6A83F85A61F8, EA83856FEB3CAEC2
// reference: 55343AECFE014C6A, 74528811F959F6E2
// reference: 846D623700F53EED, 4BE9CE20C19E37BB
// reference: 635646A94C5D43CE, DD35FB9CAEB223CF
// reference: 01EC2DEE6604E9A5, 9FB407F1EC1D74B1
// reference: 635646A979FE0330, DD35FB9CAEB223CF
// reference: 7F5A84685D0D0063, 4F823895C8BC6A43
// reference: 3E4FB805E643BF4B, FA80A6A78835943F
// reference: BFD1BF020727E1C4, 5D57F51D656636F9
// shader: 8B30, 2E9DBDC9E107BF7E

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 4FF084E8B8061D93, 2E9DBDC9E107BF7E
// program: DEFAC6F185DB6EB9, 6CF3F3B70E23AA85, 2E9DBDC9E107BF7E
// shader: 8B30, B2C64B9CA332EA99

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 558E6096F916E266, B2C64B9CA332EA99
// program: DEFAC6F185DB6EB9, 6CF3F3B70E23AA85, B2C64B9CA332EA99
// reference: 053D0A4AF916E266, B2C64B9CA332EA99
// reference: 558E60964F94B41F, C59EA4758EB9FB8A
// shader: 8B30, 4A488A338256AB9B

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.r) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 8B844E66B8061D93, 4A488A338256AB9B
// program: DEFAC6F185DB6EB9, 6CF3F3B70E23AA85, 4A488A338256AB9B
// reference: A8D6A62A49F32C73, D82E12A9D19ACD63
