// shader: 8B31, 502AB780D80D09C1

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;
out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_76_103();
bool sub_78_83();
bool sub_83_102();
bool sub_86_92();
bool sub_92_101();
bool sub_93_97();
bool sub_97_100();
bool sub_103_127();
bool sub_105_109();
bool sub_109_126();
bool sub_110_124();
bool sub_113_120();
bool sub_120_123();
bool sub_124_125();
bool sub_127_143();
bool sub_129_133();
bool sub_133_142();
bool sub_134_140();
bool sub_140_141();
bool sub_143_151();
bool sub_145_146();
bool sub_146_150();
bool sub_147_148();
bool sub_148_149();
bool sub_151_158();
bool sub_158_166();
bool sub_166_4096();

bool exec_shader() {
    sub_166_4096();
    return true;
}

bool sub_76_103() {
    reg_tmp0.xy = (uniforms.f[0].xxxx).xy;
    if (uniforms.b[2]) {
        sub_78_83();
    } else {
        sub_83_102();
    }
    return false;
}
bool sub_78_83() {
    {
        sub_143_151();
    }
    reg_tmp3.x = dot_s(uniforms.f[1].xywz, reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2].xywz, reg_tmp6);
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_83_102() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_86_92();
    } else {
        sub_92_101();
    }
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_86_92() {
    reg_tmp6 = reg_tmp10;
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    reg_tmp3.z = dot_s(uniforms.f[3], reg_tmp6);
    reg_tmp0.xy = (mul_s(uniforms.f[9].xyyy, reg_tmp3.zzzz)).xy;
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_92_101() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_93_97();
    } else {
        sub_97_100();
    }
    return false;
}
bool sub_93_97() {
    {
        sub_151_158();
    }
    reg_tmp3.x = dot_3(uniforms.f[1].xyz, reg_tmp6.xyz);
    reg_tmp3.y = dot_3(uniforms.f[2].xyz, reg_tmp6.xyz);
    reg_tmp3.z = dot_3(uniforms.f[3].xyz, reg_tmp6.xyz);
    return false;
}
bool sub_97_100() {
    {
        sub_158_166();
    }
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    return false;
}
bool sub_103_127() {
    reg_tmp0.xy = (uniforms.f[0].yyyy).xy;
    if (uniforms.b[3]) {
        sub_105_109();
    } else {
        sub_109_126();
    }
    return false;
}
bool sub_105_109() {
    {
        sub_143_151();
    }
    reg_tmp4.x = dot_s(uniforms.f[4].xywz, reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5].xywz, reg_tmp6);
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_109_126() {
    if (uniforms.b[5]) {
        sub_110_124();
    } else {
        sub_124_125();
    }
    return false;
}
bool sub_110_124() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_113_120();
    } else {
        sub_120_123();
    }
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_113_120() {
    reg_tmp6 = reg_tmp10;
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    reg_tmp4.z = dot_s(uniforms.f[6], reg_tmp6);
    reg_tmp6.w = rcp_s(reg_tmp4.z);
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    reg_tmp4.xy = (uniforms.f[9].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_120_123() {
    {
        sub_158_166();
    }
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    return false;
}
bool sub_124_125() {
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_127_143() {
    reg_tmp0.xy = (uniforms.f[0].zzzz).xy;
    if (uniforms.b[4]) {
        sub_129_133();
    } else {
        sub_133_142();
    }
    return false;
}
bool sub_129_133() {
    {
        sub_143_151();
    }
    reg_tmp5.x = dot_s(uniforms.f[7].xywz, reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8].xywz, reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_133_142() {
    if (uniforms.b[6]) {
        sub_134_140();
    } else {
        sub_140_141();
    }
    return false;
}
bool sub_134_140() {
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    {
        sub_158_166();
    }
    reg_tmp5.x = dot_s(uniforms.f[7], reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8], reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_140_141() {
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
bool sub_143_151() {
    conditional_code = equal(uniforms.f[93].yz, reg_tmp0.xy);
    if (all(not(conditional_code))) {
        sub_145_146();
    } else {
        sub_146_150();
    }
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_145_146() {
    reg_tmp6.xy = (vs_in_reg4.xyyy).xy;
    return false;
}
bool sub_146_150() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_147_148();
    } else {
        sub_148_149();
    }
    return false;
}
bool sub_147_148() {
    reg_tmp6.xy = (vs_in_reg5.xyyy).xy;
    return false;
}
bool sub_148_149() {
    reg_tmp6.xy = (vs_in_reg6.xyyy).xy;
    return false;
}
bool sub_151_158() {
    reg_tmp2 = -reg_tmp15;
    reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
    reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_158_166() {
    {
        sub_151_158();
    }
    reg_tmp1 = reg_tmp6;
    reg_tmp1.z = (uniforms.f[93].yyyy + reg_tmp1.zzzz).z;
    reg_tmp1 = vec4(dot_3(reg_tmp1.xyz, reg_tmp1.xyz));
    reg_tmp2 = vec4(rsq_s(reg_tmp1.x));
    reg_tmp2 = mul_s(uniforms.f[94].xxxx, reg_tmp2);
    reg_tmp6.xy = (mul_s(reg_tmp6.xyyy, reg_tmp2)).xy;
    reg_tmp6.xy = (uniforms.f[94].xxxx + reg_tmp6.xyyy).xy;
    return false;
}
bool sub_166_4096() {
    reg_tmp0 = vs_in_reg0;
    reg_tmp0.z = (uniforms.f[93].xxxx).z;
    reg_tmp0.w = (uniforms.f[93].yyyy).w;
    vs_out_attr0 = reg_tmp0;
    vs_out_attr2 = reg_tmp0;
    vs_out_attr1 = reg_tmp0;
    vs_out_attr3 = uniforms.f[93].yyyy;
    {
        sub_76_103();
    }
    {
        sub_103_127();
    }
    {
        sub_127_143();
    }
    return true;
}
// reference: 9049A31FB2BE2E18, 502AB780D80D09C1
// shader: 8DD9, B80FA1B7F97410CD

layout(triangles) in;
layout(triangle_strip, max_vertices = 3) out;

out vec4 primary_color;
out vec2 texcoord0;
out vec2 texcoord1;
out vec2 texcoord2;
out float texcoord0_w;
out vec4 normquat;
out vec3 view;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

in vec4 vs_out_attr0[];
in vec4 vs_out_attr1[];
in vec4 vs_out_attr2[];
in vec4 vs_out_attr3[];
in vec4 vs_out_attr4[];
in vec4 vs_out_attr5[];
in vec4 vs_out_attr6[];
struct Vertex {
    vec4 attributes[7];
};

vec4 GetVertexQuaternion(Vertex vtx) {
    return vec4(vtx.attributes[1].x, vtx.attributes[1].y, vtx.attributes[1].z, vtx.attributes[1].w);
}

void EmitVtx(Vertex vtx, bool quats_opposite) {
    vec4 vtx_pos = vec4(vtx.attributes[0].x, vtx.attributes[0].y, vtx.attributes[0].z, vtx.attributes[0].w);
    gl_Position = vtx_pos;
#if !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)
    gl_ClipDistance[0] = -vtx_pos.z;
    gl_ClipDistance[1] = dot(clip_coef, vtx_pos);
#endif // !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)

    vec4 vtx_quat = GetVertexQuaternion(vtx);
    normquat = mix(vtx_quat, -vtx_quat, bvec4(quats_opposite));

    vec4 vtx_color = vec4(vtx.attributes[3].x, vtx.attributes[3].y, vtx.attributes[3].z, vtx.attributes[3].w);
    primary_color = min(abs(vtx_color), vec4(1.0));

    texcoord0 = vec2(vtx.attributes[4].x, vtx.attributes[4].y);
    texcoord1 = vec2(vtx.attributes[5].x, vtx.attributes[5].y);

    texcoord0_w = vtx.attributes[4].z;
    view = vec3(vtx.attributes[2].x, vtx.attributes[2].y, vtx.attributes[2].z);
    texcoord2 = vec2(vtx.attributes[6].x, vtx.attributes[6].y);

    EmitVertex();
}

bool AreQuaternionsOpposite(vec4 qa, vec4 qb) {
    return (dot(qa, qb) < 0.0);
}

void EmitPrim(Vertex vtx0, Vertex vtx1, Vertex vtx2) {
    EmitVtx(vtx0, false);
    EmitVtx(vtx1, AreQuaternionsOpposite(GetVertexQuaternion(vtx0), GetVertexQuaternion(vtx1)));
    EmitVtx(vtx2, AreQuaternionsOpposite(GetVertexQuaternion(vtx0), GetVertexQuaternion(vtx2)));
    EndPrimitive();
}

void main() {
    Vertex prim_buffer[3];
    prim_buffer[0].attributes = vec4[7](vs_out_attr0[0], vs_out_attr1[0], vs_out_attr2[0], vs_out_attr3[0], vs_out_attr4[0], vs_out_attr5[0], vs_out_attr6[0]);
    prim_buffer[1].attributes = vec4[7](vs_out_attr0[1], vs_out_attr1[1], vs_out_attr2[1], vs_out_attr3[1], vs_out_attr4[1], vs_out_attr5[1], vs_out_attr6[1]);
    prim_buffer[2].attributes = vec4[7](vs_out_attr0[2], vs_out_attr1[2], vs_out_attr2[2], vs_out_attr3[2], vs_out_attr4[2], vs_out_attr5[2], vs_out_attr6[2]);
    EmitPrim(prim_buffer[0], prim_buffer[1], prim_buffer[2]);
}
// reference: FC74FA4ACA1C8C74, B80FA1B7F97410CD
// shader: 8B30, 8B9E362C16D3C52E

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = (last_tex_env_out.r);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 845FF0BC87927CCD, 8B9E362C16D3C52E
// program: 502AB780D80D09C1, B80FA1B7F97410CD, 8B9E362C16D3C52E
// shader: 8B31, D9C174A4A54356AC

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_97();
bool sub_5_50();
bool sub_12_13();
bool sub_20_21();
bool sub_22_24();
bool sub_31_32();
bool sub_33_34();
bool sub_40_41();
bool sub_42_43();
bool sub_48_49();
bool sub_52_69();
bool sub_57_60();
bool sub_60_68();
bool sub_62_63();
bool sub_63_64();
bool sub_65_66();
bool sub_66_67();
bool sub_69_96();
bool sub_70_93();
bool sub_74_79();
bool sub_79_92();
bool sub_83_87();
bool sub_84_85();
bool sub_85_86();
bool sub_87_91();
bool sub_88_89();
bool sub_89_90();
bool sub_93_95();
bool sub_97_109();
bool sub_109_4096();
bool sub_125_127();
bool sub_127_149();
bool sub_137_141();
bool sub_158_160();
bool sub_161_162();
bool sub_171_173();
bool sub_174_175();
bool sub_184_186();
bool sub_187_188();
bool sub_198_207();
bool sub_215_223();
bool sub_223_227();

bool exec_shader() {
    sub_109_4096();
    return true;
}

bool sub_0_97() {
    reg_tmp13 = floor(reg_tmp0.xxxx);
    reg_tmp13 = reg_tmp0.xxxx + -reg_tmp13;
    address_registers.y = (ivec2(reg_tmp11.zz)).y;
    conditional_code = lessThanEqual(uniforms.f[5].ww, reg_tmp13.xx);
    if (conditional_code.x) {
        sub_5_50();
    }
    conditional_code = lessThanEqual(uniforms.f[5].yy, reg_tmp11.xy);
    if (!conditional_code.y) {
        sub_52_69();
    } else {
        sub_69_96();
    }
    return false;
}
bool sub_5_50() {
    reg_tmp12.xy = (uniforms.f[5].xyyy + vs_in_reg0.zwww).xy;
    reg_tmp14.xy = (uniforms.f[6].wzzz).xy;
    reg_tmp13.xy = (mul_s(uniforms.f[5].zzzz, reg_tmp0.xxxx)).xy;
    reg_tmp13.y = (floor(reg_tmp13)).y;
    reg_tmp13.x = (reg_tmp13.xxxx + -reg_tmp13.yyyy).x;
    conditional_code = lessThanEqual(uniforms.f[5].ww, reg_tmp13.xx);
    if (conditional_code.x) {
        sub_12_13();
    }
    reg_tmp14.xy = (mul_s(reg_tmp14, reg_tmp2)).xy;
    reg_tmp13.x = (mul_s(uniforms.f[5].zzzz, reg_tmp13.xxxx)).x;
    reg_tmp13 = mul_s(uniforms.f[5].zyzy, reg_tmp13.xxxx);
    reg_tmp13.zw = (floor(reg_tmp13)).zw;
    reg_tmp13.xy = (reg_tmp13.xyyy + -reg_tmp13.zwww).xy;
    conditional_code = lessThanEqual(uniforms.f[5].ww, reg_tmp13.xy);
    if (conditional_code.y) {
        sub_20_21();
    }
    if (conditional_code.x) {
        sub_22_24();
    }
    reg_tmp14.xy = (uniforms.f[5].yyyy + -reg_tmp14.xyyy).xy;
    reg_tmp13.x = (mul_s(uniforms.f[5].zzzz, reg_tmp13.xxxx)).x;
    reg_tmp13 = mul_s(uniforms.f[5].zyzy, reg_tmp13.xxxx);
    reg_tmp13.zw = (floor(reg_tmp13)).zw;
    reg_tmp13.xy = (reg_tmp13.xyyy + -reg_tmp13.zwww).xy;
    conditional_code = lessThanEqual(uniforms.f[5].ww, reg_tmp13.xy);
    if (conditional_code.y) {
        sub_31_32();
    }
    if (conditional_code.x) {
        sub_33_34();
    }
    reg_tmp13.x = (mul_s(uniforms.f[5].zzzz, reg_tmp13.xxxx)).x;
    reg_tmp13 = mul_s(uniforms.f[5].zyzy, reg_tmp13.xxxx);
    reg_tmp13.zw = (floor(reg_tmp13)).zw;
    reg_tmp13.xy = (reg_tmp13.xyyy + -reg_tmp13.zwww).xy;
    conditional_code = lessThanEqual(uniforms.f[5].ww, reg_tmp13.xy);
    if (conditional_code.y) {
        sub_40_41();
    }
    if (conditional_code.x) {
        sub_42_43();
    }
    reg_tmp13.xy = (mul_s(uniforms.f[5].zzzz, reg_tmp0.xxxx)).xy;
    reg_tmp13.y = (floor(reg_tmp13)).y;
    reg_tmp13.x = (reg_tmp13.xxxx + -reg_tmp13.yyyy).x;
    conditional_code = lessThanEqual(uniforms.f[5].ww, reg_tmp13.xx);
    if (conditional_code.x) {
        sub_48_49();
    }
    reg_tmp12.y = (uniforms.f[5].yyyy + -reg_tmp12.yyyy).y;
    return false;
}
bool sub_12_13() {
    reg_tmp14.xy = (reg_tmp14.yxxx).xy;
    return false;
}
bool sub_20_21() {
    reg_tmp12.x = (mul_s(reg_tmp12.xxxx, reg_tmp14.xxxx)).x;
    return false;
}
bool sub_22_24() {
    reg_tmp12.y = (fma_s(reg_tmp12.yyyy, reg_tmp14.yyyy, uniforms.f[5].yyyy)).y;
    reg_tmp12.y = (reg_tmp12.yyyy + -reg_tmp14.yyyy).y;
    return false;
}
bool sub_31_32() {
    reg_tmp12.x = (reg_tmp12.xxxx + reg_tmp14.xxxx).x;
    return false;
}
bool sub_33_34() {
    reg_tmp12.y = (reg_tmp12.yyyy + -reg_tmp14.yyyy).y;
    return false;
}
bool sub_40_41() {
    reg_tmp12.x = (uniforms.f[5].yyyy + -reg_tmp12.xxxx).x;
    return false;
}
bool sub_42_43() {
    reg_tmp12.y = (uniforms.f[5].yyyy + -reg_tmp12.yyyy).y;
    return false;
}
bool sub_48_49() {
    reg_tmp12.xy = (uniforms.f[5].yyyy + -reg_tmp12.yxxx).xy;
    return false;
}
bool sub_52_69() {
    reg_tmp13.x = (floor(reg_tmp0.xxxx)).x;
    reg_tmp13.x = (reg_tmp0.xxxx + -reg_tmp13).x;
    conditional_code = lessThanEqual(uniforms.f[5].ww, reg_tmp13.xx);
    reg_tmp13 = uniforms.f[32 + address_registers.y].wzyx;
    if (conditional_code.x) {
        sub_57_60();
    } else {
        sub_60_68();
    }
    reg_tmp11.z = (uniforms.f[5].yyyy + reg_tmp11.zzzz).z;
    return false;
}
bool sub_57_60() {
    reg_tmp11.xy = (fma_s(reg_tmp12.xyyy, reg_tmp13.xyyy, reg_tmp13.zwww)).xy;
    reg_tmp11.xy = (mul_s(reg_tmp11.xyyy, reg_tmp14.zwww)).xy;
    reg_tmp11.y = (uniforms.f[5].yyyy + -reg_tmp11.yyyy).y;
    return false;
}
bool sub_60_68() {
    conditional_code = notEqual(uniforms.f[5].xx, vs_in_reg0.zw);
    if (!conditional_code.x) {
        sub_62_63();
    } else {
        sub_63_64();
    }
    if (!conditional_code.y) {
        sub_65_66();
    } else {
        sub_66_67();
    }
    return false;
}
bool sub_62_63() {
    reg_tmp11.x = (reg_tmp13.xxxx).x;
    return false;
}
bool sub_63_64() {
    reg_tmp11.x = (reg_tmp13.zzzz).x;
    return false;
}
bool sub_65_66() {
    reg_tmp11.y = (reg_tmp13.yyyy).y;
    return false;
}
bool sub_66_67() {
    reg_tmp11.y = (reg_tmp13.wwww).y;
    return false;
}
bool sub_69_96() {
    if (!conditional_code.x) {
        sub_70_93();
    } else {
        sub_93_95();
    }
    reg_tmp11.z = (uniforms.f[5].zzzz + reg_tmp11.zzzz).z;
    return false;
}
bool sub_70_93() {
    reg_tmp13.x = (floor(reg_tmp0.xxxx)).x;
    reg_tmp13.x = (reg_tmp0.xxxx + -reg_tmp13).x;
    conditional_code = lessThanEqual(uniforms.f[5].ww, reg_tmp13.xx);
    if (conditional_code.x) {
        sub_74_79();
    } else {
        sub_79_92();
    }
    return false;
}
bool sub_74_79() {
    reg_tmp12.zw = (uniforms.f[5].xxxy).zw;
    reg_tmp11.x = dot_s(uniforms.f[32 + address_registers.y].wzyx, reg_tmp12);
    reg_tmp11.y = dot_s(uniforms.f[33 + address_registers.y].wzyx, reg_tmp12);
    reg_tmp11.xy = (mul_s(reg_tmp11.xyyy, reg_tmp14.zwww)).xy;
    reg_tmp11.y = (uniforms.f[5].yyyy + -reg_tmp11.yyyy).y;
    return false;
}
bool sub_79_92() {
    reg_tmp14 = uniforms.f[32 + address_registers.y].wzyx;
    reg_tmp13 = uniforms.f[33 + address_registers.y].wzyx;
    conditional_code = notEqual(uniforms.f[5].xx, vs_in_reg0.zw);
    if (!conditional_code.y) {
        sub_83_87();
    } else {
        sub_87_91();
    }
    return false;
}
bool sub_83_87() {
    if (!conditional_code.x) {
        sub_84_85();
    } else {
        sub_85_86();
    }
    return false;
}
bool sub_84_85() {
    reg_tmp11.xy = (reg_tmp14.xyyy).xy;
    return false;
}
bool sub_85_86() {
    reg_tmp11.xy = (reg_tmp13.zwww).xy;
    return false;
}
bool sub_87_91() {
    if (!conditional_code.x) {
        sub_88_89();
    } else {
        sub_89_90();
    }
    return false;
}
bool sub_88_89() {
    reg_tmp11.xy = (reg_tmp13.xyyy).xy;
    return false;
}
bool sub_89_90() {
    reg_tmp11.xy = (reg_tmp14.zwww).xy;
    return false;
}
bool sub_93_95() {
    reg_tmp11.x = dot_s(uniforms.f[32 + address_registers.y].wzyx, reg_tmp1);
    reg_tmp11.y = dot_s(uniforms.f[33 + address_registers.y].wzyx, reg_tmp1);
    return false;
}
bool sub_97_109() {
    uint jmp_to = 97u;
    while (true) {
        switch (jmp_to) {
        case 97u: {
            reg_tmp3.x = dot_s(uniforms.f[32 + address_registers.x].wzyx, reg_tmp1);
            reg_tmp3.y = dot_s(uniforms.f[33 + address_registers.x].wzyx, reg_tmp1);
            reg_tmp3.z = dot_s(uniforms.f[34 + address_registers.x].wzyx, reg_tmp1);
            reg_tmp3.w = (reg_tmp1.wwww).w;
            reg_tmp11 = uniforms.f[4].wzyx;
            reg_tmp11.z = (-uniforms.f[34 + address_registers.x].xxxx + reg_tmp11.zzzz).z;
            conditional_code.x = uniforms.f[5].xxxx.x != reg_tmp11.xzzz.x;
            conditional_code.y = uniforms.f[5].xxxx.y < reg_tmp11.xzzz.y;
            if (any(not(conditional_code))) {
                { jmp_to = 108u; break; }
            }
            reg_tmp11.z = rcp_s(reg_tmp11.z);
            reg_tmp3.x = (reg_tmp3.xxxx + reg_tmp11.xxxx).x;
            reg_tmp3.x = (fma_s(-reg_tmp11.yyyy, reg_tmp11.zzzz, reg_tmp3.xxxx)).x;
        }
        case 108u: {
        }
        default: return false;
        }
    }
    return false;
}
bool sub_109_4096() {
    uint jmp_to = 109u;
    while (true) {
        switch (jmp_to) {
        case 109u: {
            address_registers.x = (ivec2(vs_in_reg0.xx)).x;
            reg_tmp0 = uniforms.f[9 + address_registers.x].wzyx;
            reg_tmp1.xy = (vs_in_reg0.zwzw).xy;
            reg_tmp1.zw = (uniforms.f[5].xyxy).zw;
            address_registers.xy = ivec2(reg_tmp0.xy);
            reg_tmp2 = uniforms.f[32 + address_registers.y].wzyx;
            if (uniforms.b[0]) {
                { jmp_to = 191u; break; }
            }
            reg_tmp4 = uniforms.f[31 + address_registers.x].wzyx;
            reg_tmp1.xy = (fma_s(reg_tmp1.xyyy, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
            {
                sub_97_109();
            }
            vs_out_attr0.x = dot_s(uniforms.f[0].wzyx, reg_tmp3);
            vs_out_attr0.y = dot_s(uniforms.f[1].wzyx, reg_tmp3);
            vs_out_attr0.z = dot_s(uniforms.f[2].wzyx, reg_tmp3);
            vs_out_attr0.w = dot_s(uniforms.f[3].wzyx, reg_tmp3);
            conditional_code = greaterThanEqual(uniforms.f[5].yy, reg_tmp0.ww);
            if (all(conditional_code)) {
                sub_125_127();
            } else {
                sub_127_149();
            }
            reg_tmp11.z = (reg_tmp0.zzzz).z;
            reg_tmp9 = mul_s(uniforms.f[5].zyzy, reg_tmp0.zzzz);
            reg_tmp9.xy = (floor(reg_tmp9)).xy;
            reg_tmp9.xy = (reg_tmp9.zwww + -reg_tmp9.xyyy).xy;
            reg_tmp9 = mul_s(uniforms.f[5].zzzz, reg_tmp9);
            reg_tmp14 = uniforms.f[6].wzyx;
            reg_tmp11.xy = (reg_tmp9.xyyy).xy;
            {
                sub_0_97();
            }
            if (uniforms.b[1]) {
                sub_158_160();
            }
            if (uniforms.b[2]) {
                sub_161_162();
            }
            vs_out_attr2 = reg_tmp11.xyyy;
            reg_tmp9 = mul_s(uniforms.f[5].zyzy, reg_tmp9.xxxx);
            reg_tmp9.xy = (floor(reg_tmp9)).xy;
            reg_tmp9.xy = (reg_tmp9.zwww + -reg_tmp9.xyyy).xy;
            reg_tmp9 = mul_s(uniforms.f[5].zzzz, reg_tmp9);
            reg_tmp14 = uniforms.f[7].wzyx;
            reg_tmp11.xy = (reg_tmp9.xyyy).xy;
            {
                sub_0_97();
            }
            if (uniforms.b[3]) {
                sub_171_173();
            }
            if (uniforms.b[4]) {
                sub_174_175();
            }
            vs_out_attr3 = reg_tmp11.xyyy;
            reg_tmp9 = mul_s(uniforms.f[5].zyzy, reg_tmp9.xxxx);
            reg_tmp9.xy = (floor(reg_tmp9)).xy;
            reg_tmp9.xy = (reg_tmp9.zwww + -reg_tmp9.xyyy).xy;
            reg_tmp9 = mul_s(uniforms.f[5].zzzz, reg_tmp9);
            reg_tmp14 = uniforms.f[8].wzyx;
            reg_tmp11.xy = (reg_tmp9.xyyy).xy;
            {
                sub_0_97();
            }
            if (uniforms.b[5]) {
                sub_184_186();
            }
            if (uniforms.b[6]) {
                sub_187_188();
            }
            vs_out_attr4 = reg_tmp11.xyyy;
            return true;
        }
        case 191u: {
            reg_tmp2.w = (reg_tmp2.wwww + reg_tmp2.yyyy).w;
            reg_tmp1.y = (-uniforms.f[5].yyyy + -reg_tmp1.yyyy).y;
            reg_tmp13.xy = (mul_s(uniforms.f[36 + address_registers.x].wzzz, reg_tmp2.xyyy)).xy;
            reg_tmp11.x = (mul_s(uniforms.f[35 + address_registers.x].wwww, -reg_tmp1.yyyy)).x;
            reg_tmp1.xy = (mul_s(reg_tmp1.xyyy, reg_tmp13.xyyy)).xy;
            reg_tmp1.x = (reg_tmp1.xxxx + reg_tmp11.xxxx).x;
            if (uniforms.b[1]) {
                sub_198_207();
            }
            reg_tmp1.xy = (reg_tmp1.xyyy + reg_tmp2.zwww).xy;
            reg_tmp1.xy = (uniforms.f[36 + address_registers.x].yxxx + reg_tmp1.xyyy).xy;
            {
                sub_97_109();
            }
            vs_out_attr0.x = dot_s(uniforms.f[0].wzyx, reg_tmp3);
            vs_out_attr0.y = dot_s(uniforms.f[1].wzyx, reg_tmp3);
            vs_out_attr0.z = dot_s(uniforms.f[2].wzyx, reg_tmp3);
            vs_out_attr0.w = dot_s(uniforms.f[3].wzyx, reg_tmp3);
            if (uniforms.b[2]) {
                sub_215_223();
            } else {
                sub_223_227();
            }
            reg_tmp8 = reg_tmp8 + -reg_tmp7;
            vs_out_attr1 = fma_s(reg_tmp8, reg_tmp11.yyyy, reg_tmp7);
            reg_tmp9.xy = (mul_s(uniforms.f[32 + address_registers.x].yxxx, reg_tmp11)).xy;
            reg_tmp11.zw = (vec4(lessThan(reg_tmp11, uniforms.f[5].yyyy))).zw;
            reg_tmp9.xy = (fma_s(reg_tmp11.zwww, uniforms.f[32 + address_registers.x].wzzz, reg_tmp9.xyyy)).xy;
            reg_tmp9.y = (uniforms.f[5].yyyy + -reg_tmp9.yyyy).y;
            vs_out_attr2 = reg_tmp9;
            vs_out_attr3 = reg_tmp9;
            vs_out_attr4 = reg_tmp9;
            return true;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_125_127() {
    vs_out_attr1.xyz = (uniforms.f[5].yyyy).xyz;
    vs_out_attr1.w = (reg_tmp0.wwww).w;
    return false;
}
bool sub_127_149() {
    address_registers.y = (ivec2(reg_tmp0.ww)).y;
    reg_tmp7 = uniforms.f[32 + address_registers.y].wzyx;
    reg_tmp8 = uniforms.f[33 + address_registers.y].wzyx;
    reg_tmp9 = uniforms.f[34 + address_registers.y].wzyx;
    reg_tmp10 = uniforms.f[35 + address_registers.y].wzyx;
    reg_tmp11.xy = (vs_in_reg0.zwww).xy;
    reg_tmp14.x = (floor(reg_tmp0.yyyy)).x;
    reg_tmp14.x = (reg_tmp0.yyyy + -reg_tmp14.xxxx).x;
    conditional_code = lessThanEqual(uniforms.f[5].ww, reg_tmp14.xx);
    if (conditional_code.x) {
        sub_137_141();
    }
    reg_tmp11.xy = (abs(reg_tmp11.xyyy)).xy;
    reg_tmp8 = reg_tmp8 + -reg_tmp7;
    reg_tmp8 = fma_s(reg_tmp8, reg_tmp11.xxxx, reg_tmp7);
    reg_tmp10 = reg_tmp10 + -reg_tmp9;
    reg_tmp10 = fma_s(reg_tmp10, reg_tmp11.xxxx, reg_tmp9);
    reg_tmp10 = reg_tmp10 + -reg_tmp8;
    reg_tmp10 = fma_s(reg_tmp10, reg_tmp11.yyyy, reg_tmp8);
    vs_out_attr1 = reg_tmp10;
    return false;
}
bool sub_137_141() {
    reg_tmp11.z = rcp_s(reg_tmp4.x);
    reg_tmp11.w = rcp_s(reg_tmp4.y);
    reg_tmp11.xy = (reg_tmp1.xyyy + -reg_tmp4.zwww).xy;
    reg_tmp11.xy = (mul_s(reg_tmp11.xyyy, reg_tmp11.zwww)).xy;
    return false;
}
bool sub_158_160() {
    reg_tmp11.xy = (reg_tmp11.yxxx).xy;
    reg_tmp11.y = (uniforms.f[5].yyyy + -reg_tmp11.yyyy).y;
    return false;
}
bool sub_161_162() {
    reg_tmp11.xy = (uniforms.f[5].yyyy + -reg_tmp11.yxxx).xy;
    return false;
}
bool sub_171_173() {
    reg_tmp11.xy = (reg_tmp11.yxxx).xy;
    reg_tmp11.y = (uniforms.f[5].yyyy + -reg_tmp11.yyyy).y;
    return false;
}
bool sub_174_175() {
    reg_tmp11.xy = (uniforms.f[5].yyyy + -reg_tmp11.yxxx).xy;
    return false;
}
bool sub_184_186() {
    reg_tmp11.xy = (reg_tmp11.yxxx).xy;
    reg_tmp11.y = (uniforms.f[5].yyyy + -reg_tmp11.yyyy).y;
    return false;
}
bool sub_187_188() {
    reg_tmp11.xy = (uniforms.f[5].yyyy + -reg_tmp11.yxxx).xy;
    return false;
}
bool sub_198_207() {
    reg_tmp13.xzw = (mul_s(uniforms.f[5].wxxx, reg_tmp13.xxxx)).xzw;
    reg_tmp13.y = (mul_s(uniforms.f[34 + address_registers.y].yyyy, reg_tmp13.yyyy)).y;
    reg_tmp11 = fma_s(reg_tmp1, uniforms.f[5].yyxx, -reg_tmp13);
    reg_tmp14 = uniforms.f[33 + address_registers.y].wzyx;
    reg_tmp1.x = dot_3(reg_tmp11.xyz, reg_tmp14.xyy);
    reg_tmp1.y = dot_3(reg_tmp11.xyz, reg_tmp14.zww);
    reg_tmp14 = uniforms.f[34 + address_registers.y].wzyx;
    reg_tmp1.z = dot_s(vec4(reg_tmp11.xyz, 1.0), reg_tmp14);
    reg_tmp1.xy = (reg_tmp1.xyyy + reg_tmp13.xyyy).xy;
    return false;
}
bool sub_215_223() {
    reg_tmp11 = abs(vs_in_reg0.zwzw);
    reg_tmp14.w = (floor(reg_tmp0.zzzz)).w;
    reg_tmp14.w = (reg_tmp0.zzzz + -reg_tmp14).w;
    address_registers.xy = ivec2(reg_tmp0.zx);
    reg_tmp14.w = (mul_s(uniforms.f[5].zzzz, reg_tmp14.wwww)).w;
    reg_tmp14.xyz = (uniforms.f[5].yyyy).xyz;
    reg_tmp7 = mul_s(uniforms.f[37 + address_registers.y].wzyx, reg_tmp14);
    reg_tmp8 = mul_s(uniforms.f[38 + address_registers.y].wzyx, reg_tmp14);
    return false;
}
bool sub_223_227() {
    reg_tmp11 = abs(vs_in_reg0.zwzw);
    address_registers.xy = ivec2(reg_tmp0.zw);
    reg_tmp7 = uniforms.f[32 + address_registers.y].wzyx;
    reg_tmp8 = uniforms.f[33 + address_registers.y].wzyx;
    return false;
}
// reference: 26B611F73A6918E6, D9C174A4A54356AC
// shader: 8DD9, 42937135801BAA7E

layout(triangles) in;
layout(triangle_strip, max_vertices = 3) out;

out vec4 primary_color;
out vec2 texcoord0;
out vec2 texcoord1;
out vec2 texcoord2;
out float texcoord0_w;
out vec4 normquat;
out vec3 view;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

in vec4 vs_out_attr0[];
in vec4 vs_out_attr1[];
in vec4 vs_out_attr2[];
in vec4 vs_out_attr3[];
in vec4 vs_out_attr4[];
struct Vertex {
    vec4 attributes[5];
};

vec4 GetVertexQuaternion(Vertex vtx) {
    return vec4(0.0, 0.0, 0.0, 0.0);
}

void EmitVtx(Vertex vtx, bool quats_opposite) {
    vec4 vtx_pos = vec4(vtx.attributes[0].x, vtx.attributes[0].y, vtx.attributes[0].z, vtx.attributes[0].w);
    gl_Position = vtx_pos;
#if !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)
    gl_ClipDistance[0] = -vtx_pos.z;
    gl_ClipDistance[1] = dot(clip_coef, vtx_pos);
#endif // !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)

    vec4 vtx_quat = GetVertexQuaternion(vtx);
    normquat = mix(vtx_quat, -vtx_quat, bvec4(quats_opposite));

    vec4 vtx_color = vec4(vtx.attributes[1].x, vtx.attributes[1].y, vtx.attributes[1].z, vtx.attributes[1].w);
    primary_color = min(abs(vtx_color), vec4(1.0));

    texcoord0 = vec2(vtx.attributes[2].x, vtx.attributes[2].y);
    texcoord1 = vec2(vtx.attributes[3].x, vtx.attributes[3].y);

    texcoord0_w = 0.0;
    view = vec3(0.0, 0.0, 0.0);
    texcoord2 = vec2(vtx.attributes[4].x, vtx.attributes[4].y);

    EmitVertex();
}

bool AreQuaternionsOpposite(vec4 qa, vec4 qb) {
    return (dot(qa, qb) < 0.0);
}

void EmitPrim(Vertex vtx0, Vertex vtx1, Vertex vtx2) {
    EmitVtx(vtx0, false);
    EmitVtx(vtx1, AreQuaternionsOpposite(GetVertexQuaternion(vtx0), GetVertexQuaternion(vtx1)));
    EmitVtx(vtx2, AreQuaternionsOpposite(GetVertexQuaternion(vtx0), GetVertexQuaternion(vtx2)));
    EndPrimitive();
}

void main() {
    Vertex prim_buffer[3];
    prim_buffer[0].attributes = vec4[5](vs_out_attr0[0], vs_out_attr1[0], vs_out_attr2[0], vs_out_attr3[0], vs_out_attr4[0]);
    prim_buffer[1].attributes = vec4[5](vs_out_attr0[1], vs_out_attr1[1], vs_out_attr2[1], vs_out_attr3[1], vs_out_attr4[1]);
    prim_buffer[2].attributes = vec4[5](vs_out_attr0[2], vs_out_attr1[2], vs_out_attr2[2], vs_out_attr3[2], vs_out_attr4[2]);
    EmitPrim(prim_buffer[0], prim_buffer[1], prim_buffer[2]);
}
// reference: 5DAD5699F59B3586, 42937135801BAA7E
// shader: 8B30, 21786A34D707A069

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 1F78A607E9F3C0A1, 21786A34D707A069
// program: D9C174A4A54356AC, 42937135801BAA7E, 21786A34D707A069
// reference: 2FBDCACD8CDF1967, 502AB780D80D09C1
// reference: 845FF0BC865016FA, 8B9E362C16D3C52E
// reference: 68E2EEB7B99C7E94, D9C174A4A54356AC
// shader: 8B30, 5124AD903EB19D9F

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 1F78A6071213B118, 5124AD903EB19D9F
// program: D9C174A4A54356AC, 42937135801BAA7E, 5124AD903EB19D9F
// shader: 8B30, DFCB363A2A0B3CC5

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor2.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 61A079249DFD89EE, DFCB363A2A0B3CC5
// program: D9C174A4A54356AC, 42937135801BAA7E, DFCB363A2A0B3CC5
// reference: 68E2EEB7CB23C7B6, D9C174A4A54356AC
// shader: 8B30, F560208BD4D2027B

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor2.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 61A079247B45F66B, F560208BD4D2027B
// program: D9C174A4A54356AC, 42937135801BAA7E, F560208BD4D2027B
// shader: 8B30, 0027CEC45E8FAB67

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor2.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 61A0792480A587D2, 0027CEC45E8FAB67
// program: D9C174A4A54356AC, 42937135801BAA7E, 0027CEC45E8FAB67
// shader: 8B30, 143AFBD072626A3C

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].aaa);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor2.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 5118666F2308FBFB, 143AFBD072626A3C
// program: D9C174A4A54356AC, 42937135801BAA7E, 143AFBD072626A3C
// shader: 8B30, 29C64432F3BC1BED

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor2.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D96FFE465B6167CB, 29C64432F3BC1BED
// program: D9C174A4A54356AC, 42937135801BAA7E, 29C64432F3BC1BED
// shader: 8B30, DF3F131ABF324C64

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor2.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D96FFE467E4D1A09, DF3F131ABF324C64
// program: D9C174A4A54356AC, 42937135801BAA7E, DF3F131ABF324C64
// shader: 8B30, 1213C240BC74F0A4

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].aaa);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor2.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: E9D7E10D2D37ED8D, 1213C240BC74F0A4
// program: D9C174A4A54356AC, 42937135801BAA7E, 1213C240BC74F0A4
// shader: 8B30, C8E2E0613F536B3E

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor2.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D96FFE468E9A91A4, C8E2E0613F536B3E
// program: D9C174A4A54356AC, 42937135801BAA7E, C8E2E0613F536B3E
// shader: 8B30, AA3A46EC91E54F18

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor2.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D96FFE46757AE01D, AA3A46EC91E54F18
// program: D9C174A4A54356AC, 42937135801BAA7E, AA3A46EC91E54F18
// shader: 8B31, D2A401390BA8C9C0

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;
out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_49();
bool sub_25_31();
bool sub_32_39();
bool sub_40_48();
bool sub_175_202();
bool sub_177_182();
bool sub_182_201();
bool sub_185_191();
bool sub_191_200();
bool sub_192_196();
bool sub_196_199();
bool sub_202_226();
bool sub_204_208();
bool sub_208_225();
bool sub_209_223();
bool sub_212_219();
bool sub_219_222();
bool sub_223_224();
bool sub_226_242();
bool sub_228_232();
bool sub_232_241();
bool sub_233_239();
bool sub_239_240();
bool sub_242_250();
bool sub_244_245();
bool sub_245_249();
bool sub_246_247();
bool sub_247_248();
bool sub_343_350();
bool sub_350_354();
bool sub_354_4096();
bool sub_361_363();
bool sub_363_364();

bool exec_shader() {
    sub_354_4096();
    return true;
}

bool sub_0_49() {
    reg_tmp1.xyz = (uniforms.f[93].xxyx).xyz;
    reg_tmp8.x = dot_3(uniforms.f[0].xyz, reg_tmp12.xyz);
    reg_tmp8.y = dot_3(uniforms.f[1].xyz, reg_tmp12.xyz);
    reg_tmp8.z = dot_3(uniforms.f[2].xyz, reg_tmp12.xyz);
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp8.xyz);
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp8.xyz);
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp8.xyz);
    reg_tmp14.w = (uniforms.f[93].xxxx).w;
    reg_tmp8 = reg_tmp14;
    reg_tmp14.x = dot_s(reg_tmp8, reg_tmp8);
    reg_tmp14.x = rsq_s(reg_tmp14.x);
    reg_tmp14 = mul_s(reg_tmp8, reg_tmp14.xxxx);
    reg_tmp0 = uniforms.f[23];
    reg_tmp8.x = dot_3(uniforms.f[0].xyz, reg_tmp0.xyz);
    reg_tmp8.y = dot_3(uniforms.f[1].xyz, reg_tmp0.xyz);
    reg_tmp8.z = dot_3(uniforms.f[2].xyz, reg_tmp0.xyz);
    reg_tmp6.x = dot_3(uniforms.f[90].xyz, reg_tmp8.xyz);
    reg_tmp6.y = dot_3(uniforms.f[91].xyz, reg_tmp8.xyz);
    reg_tmp6.z = dot_3(uniforms.f[92].xyz, reg_tmp8.xyz);
    reg_tmp8.xyz = (reg_tmp6.xyzz + reg_tmp1.xyzz).xyz;
    reg_tmp8.w = (uniforms.f[93].xxxx).w;
    reg_tmp0.x = dot_s(reg_tmp8, reg_tmp8);
    reg_tmp0.x = rsq_s(reg_tmp0.x);
    reg_tmp0 = mul_s(reg_tmp8, reg_tmp0.xxxx);
    if (uniforms.b[5]) {
        sub_25_31();
    }
    if (uniforms.b[3]) {
        sub_32_39();
    }
    if (uniforms.b[4]) {
        sub_40_48();
    }
    vs_out_attr3 = reg_tmp2;
    return false;
}
bool sub_25_31() {
    reg_tmp8.x = dot_3(reg_tmp14.xyz, -reg_tmp6.xyz);
    reg_tmp8.y = dot_3(reg_tmp1.xyz, -reg_tmp6.xyz);
    reg_tmp8 = max(uniforms.f[93].xxxx, reg_tmp8);
    reg_tmp8.y = (mul_s(uniforms.f[94].zzzz, reg_tmp8.yyyy)).y;
    reg_tmp8.y = (uniforms.f[94].zzzz + reg_tmp8.yyyy).y;
    reg_tmp2.y = (mul_s(reg_tmp8.xxxx, reg_tmp8.yyyy)).y;
    return false;
}
bool sub_32_39() {
    reg_tmp9.z = dot_3(reg_tmp14.xyz, reg_tmp0.xyz);
    reg_tmp9.z = (max(uniforms.f[93].xxxx, reg_tmp9.zzzz)).z;
    reg_tmp9.z = (min(uniforms.f[93].yyyy, reg_tmp9.zzzz)).z;
    reg_tmp9.z = log2(reg_tmp9.z);
    reg_tmp9.z = (mul_s(uniforms.f[22].zzzz, reg_tmp9.zzzz)).z;
    reg_tmp9.z = exp2(reg_tmp9.z);
    reg_tmp2.z = (mul_s(uniforms.f[22].wwww, reg_tmp9.zzzz)).z;
    return false;
}
bool sub_40_48() {
    reg_tmp9.x = dot_3(reg_tmp14.xyz, reg_tmp1.xyz);
    reg_tmp9.x = (max(uniforms.f[93].xxxx, reg_tmp9.xxxx)).x;
    reg_tmp9.x = (min(uniforms.f[93].yyyy, reg_tmp9.xxxx)).x;
    reg_tmp9.x = (uniforms.f[93].yyyy + -reg_tmp9.xxxx).x;
    reg_tmp9.x = log2(reg_tmp9.x);
    reg_tmp9.x = (mul_s(uniforms.f[22].xxxx, reg_tmp9.xxxx)).x;
    reg_tmp9.x = exp2(reg_tmp9.x);
    reg_tmp2.w = (mul_s(uniforms.f[22].yyyy, reg_tmp9.xxxx)).w;
    return false;
}
bool sub_175_202() {
    reg_tmp0.xy = (uniforms.f[10].xxxx).xy;
    if (uniforms.b[9]) {
        sub_177_182();
    } else {
        sub_182_201();
    }
    return false;
}
bool sub_177_182() {
    {
        sub_242_250();
    }
    reg_tmp3.x = dot_s(uniforms.f[11].xywz, reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[12].xywz, reg_tmp6);
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_182_201() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_185_191();
    } else {
        sub_191_200();
    }
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_185_191() {
    reg_tmp6 = reg_tmp10;
    reg_tmp3.x = dot_s(uniforms.f[11], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[12], reg_tmp6);
    reg_tmp3.z = dot_s(uniforms.f[13], reg_tmp6);
    reg_tmp0.xy = (mul_s(uniforms.f[19].xyyy, reg_tmp3.zzzz)).xy;
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_191_200() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_192_196();
    } else {
        sub_196_199();
    }
    return false;
}
bool sub_192_196() {
    {
        sub_343_350();
    }
    reg_tmp3.x = dot_3(uniforms.f[11].xyz, reg_tmp6.xyz);
    reg_tmp3.y = dot_3(uniforms.f[12].xyz, reg_tmp6.xyz);
    reg_tmp3.z = dot_3(uniforms.f[13].xyz, reg_tmp6.xyz);
    return false;
}
bool sub_196_199() {
    {
        sub_350_354();
    }
    reg_tmp3.x = dot_s(uniforms.f[11], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[12], reg_tmp6);
    return false;
}
bool sub_202_226() {
    reg_tmp0.xy = (uniforms.f[10].yyyy).xy;
    if (uniforms.b[10]) {
        sub_204_208();
    } else {
        sub_208_225();
    }
    return false;
}
bool sub_204_208() {
    {
        sub_242_250();
    }
    reg_tmp4.x = dot_s(uniforms.f[14].xywz, reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[15].xywz, reg_tmp6);
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_208_225() {
    if (uniforms.b[13]) {
        sub_209_223();
    } else {
        sub_223_224();
    }
    return false;
}
bool sub_209_223() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_212_219();
    } else {
        sub_219_222();
    }
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_212_219() {
    reg_tmp6 = reg_tmp10;
    reg_tmp4.x = dot_s(uniforms.f[14], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[15], reg_tmp6);
    reg_tmp4.z = dot_s(uniforms.f[16], reg_tmp6);
    reg_tmp6.w = rcp_s(reg_tmp4.z);
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    reg_tmp4.xy = (uniforms.f[19].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_219_222() {
    {
        sub_350_354();
    }
    reg_tmp4.x = dot_s(uniforms.f[14], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[15], reg_tmp6);
    return false;
}
bool sub_223_224() {
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_226_242() {
    reg_tmp0.xy = (uniforms.f[10].zzzz).xy;
    if (uniforms.b[11]) {
        sub_228_232();
    } else {
        sub_232_241();
    }
    return false;
}
bool sub_228_232() {
    {
        sub_242_250();
    }
    reg_tmp5.x = dot_s(uniforms.f[17].xywz, reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[18].xywz, reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_232_241() {
    if (uniforms.b[14]) {
        sub_233_239();
    } else {
        sub_239_240();
    }
    return false;
}
bool sub_233_239() {
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    {
        sub_350_354();
    }
    reg_tmp5.x = dot_s(uniforms.f[17], reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[18], reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_239_240() {
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
bool sub_242_250() {
    conditional_code = equal(uniforms.f[93].yz, reg_tmp0.xy);
    if (all(not(conditional_code))) {
        sub_244_245();
    } else {
        sub_245_249();
    }
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_244_245() {
    reg_tmp6.xy = (mul_s(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
    return false;
}
bool sub_245_249() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_246_247();
    } else {
        sub_247_248();
    }
    return false;
}
bool sub_246_247() {
    reg_tmp6.xy = (mul_s(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
    return false;
}
bool sub_247_248() {
    reg_tmp6.xy = (mul_s(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
    return false;
}
bool sub_343_350() {
    reg_tmp2 = -reg_tmp15;
    reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
    reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_350_354() {
    reg_tmp1.xy = (uniforms.f[94].zzzz).xy;
    reg_tmp1.zw = (uniforms.f[93].xxxx).zw;
    reg_tmp6 = fma_s(reg_tmp14, reg_tmp1, reg_tmp1);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_354_4096() {
    reg_tmp0 = vs_in_reg0;
    reg_tmp0.z = (uniforms.f[93].xxxx).z;
    reg_tmp0.w = (uniforms.f[93].yyyy).w;
    vs_out_attr0 = reg_tmp0;
    vs_out_attr2 = reg_tmp0;
    vs_out_attr1 = reg_tmp0;
    if (uniforms.b[6]) {
        sub_361_363();
    } else {
        sub_363_364();
    }
    {
        sub_175_202();
    }
    {
        sub_202_226();
    }
    {
        sub_226_242();
    }
    return true;
}
bool sub_361_363() {
    {
        sub_0_49();
    }
    return false;
}
bool sub_363_364() {
    vs_out_attr3 = uniforms.f[93].yyyy;
    return false;
}
// reference: A572BCB09D3142C8, D2A401390BA8C9C0
// shader: 8B30, 5C250F6C1418BBD3

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp(vec3(dot((texcolor0.rgb) - vec3(0.5), (texcolor1.rgb) - vec3(0.5)) * 4.0), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) + (1.0 - texcolor1.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_1 = byteround(clamp(vec3(dot((texcolor0.rgb) - vec3(0.5), (texcolor2.rgb) - vec3(0.5)) * 4.0), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp(min((texcolor1.a) + (1.0 - texcolor0.a), 1.0) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (combiner_buffer.rgb) + (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp(min((texcolor0.a) + (1.0 - texcolor2.a), 1.0) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp(min((texcolor2.a) + (1.0 - texcolor0.a), 1.0) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a) - (const_color[4].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4 * 1.0, alpha_output_4 * 4.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (last_tex_env_out.aaa) + (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a) - (primary_fragment_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5 * 1.0, alpha_output_5 * 4.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: BAE480A51A8FC20E, 5C250F6C1418BBD3
// program: D2A401390BA8C9C0, B80FA1B7F97410CD, 5C250F6C1418BBD3
// reference: BF76358EEAA716FF, D9C174A4A54356AC
// shader: 8B30, CAB8B665DC444CE4

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp(vec3(dot((texcolor0.rgb) - vec3(0.5), (texcolor2.rgb) - vec3(0.5)) * 4.0), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp(min((texcolor1.a) + (1.0 - texcolor0.a), 1.0) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (combiner_buffer.rgb) + (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp(min((texcolor0.a) + (1.0 - texcolor2.a), 1.0) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 2E99070DCB85802A, CAB8B665DC444CE4
// program: D9C174A4A54356AC, 42937135801BAA7E, CAB8B665DC444CE4
// reference: F122CACEB2EBD1CA, D9C174A4A54356AC
// shader: 8B30, B73728D36B8422D0

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp(vec3(dot((texcolor0.rgb) - vec3(0.5), (texcolor2.rgb) - vec3(0.5)) * 4.0), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp(min((texcolor1.a) + (1.0 - texcolor0.a), 1.0) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (combiner_buffer.rgb) + (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp(min((texcolor0.a) + (1.0 - texcolor2.a), 1.0) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 2E99070D3065F193, B73728D36B8422D0
// program: D9C174A4A54356AC, 42937135801BAA7E, B73728D36B8422D0
// reference: F122CACE1BEDC9AF, D9C174A4A54356AC
// shader: 8B31, 35CCCCDE75E2FF83

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;
out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_19_29();
bool sub_143_151();
bool sub_145_146();
bool sub_146_150();
bool sub_147_148();
bool sub_148_149();
bool sub_166_4096();
bool sub_170_192();
bool sub_192_200();
bool sub_212_213();

bool exec_shader() {
    sub_166_4096();
    return true;
}

bool sub_19_29() {
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    reg_tmp4.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_143_151() {
    conditional_code = equal(uniforms.f[93].yz, reg_tmp0.xy);
    if (all(not(conditional_code))) {
        sub_145_146();
    } else {
        sub_146_150();
    }
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_145_146() {
    reg_tmp6.xy = (vs_in_reg4.xyyy).xy;
    return false;
}
bool sub_146_150() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_147_148();
    } else {
        sub_148_149();
    }
    return false;
}
bool sub_147_148() {
    reg_tmp6.xy = (vs_in_reg5.xyyy).xy;
    return false;
}
bool sub_148_149() {
    reg_tmp6.xy = (vs_in_reg6.xyyy).xy;
    return false;
}
bool sub_166_4096() {
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    if (uniforms.b[0]) {
        sub_170_192();
    } else {
        sub_192_200();
    }
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    if (all(conditional_code)) {
        sub_212_213();
    }
    vs_out_attr0 = reg_tmp0;
    vs_out_attr1 = uniforms.f[93].xxxx;
    vs_out_attr2 = uniforms.f[93].xxxx;
    reg_tmp0 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
    vs_out_attr3 = uniforms.f[94].zzzz + reg_tmp0;
    reg_tmp5.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    reg_tmp5.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    reg_tmp5.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    reg_tmp4.x = dot_s(reg_tmp5.xyzz, reg_tmp5.xyzz);
    reg_tmp4.x = rsq_s(reg_tmp4.x);
    reg_tmp4.xyz = (mul_s(reg_tmp5.xyzz, reg_tmp4.xxxx)).xyz;
    reg_tmp4 = mul_s(uniforms.f[94].xxxx, reg_tmp4);
    reg_tmp12 = uniforms.f[94].xxxx + reg_tmp4;
    vs_out_attr4 = reg_tmp12;
    reg_tmp0.xy = (uniforms.f[0].xxxx).xy;
    {
        sub_143_151();
    }
    reg_tmp4.x = dot_s(uniforms.f[4].xywz, reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5].xywz, reg_tmp6);
    vs_out_attr5 = reg_tmp4;
    vs_out_attr6 = reg_tmp4;
    return true;
}
bool sub_170_192() {
    reg_tmp7 = uniforms.f[93].xxxx;
    reg_tmp12 = uniforms.f[93].xxxx;
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    {
        sub_19_29();
    }
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    {
        sub_19_29();
    }
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    if (conditional_code.x) {
        sub_19_29();
    }
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    if (conditional_code.y) {
        sub_19_29();
    }
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    reg_tmp10 = reg_tmp7;
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    return false;
}
bool sub_192_200() {
    reg_tmp7 = reg_tmp15;
    reg_tmp10.x = dot_s(uniforms.f[10], reg_tmp7);
    reg_tmp10.y = dot_s(uniforms.f[11], reg_tmp7);
    reg_tmp10.z = dot_s(uniforms.f[12], reg_tmp7);
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    reg_tmp12.x = dot_s(uniforms.f[10], reg_tmp14);
    reg_tmp12.y = dot_s(uniforms.f[11], reg_tmp14);
    reg_tmp12.z = dot_s(uniforms.f[12], reg_tmp14);
    return false;
}
bool sub_212_213() {
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
// reference: 8724C28EB12F0953, 35CCCCDE75E2FF83
// shader: 8B30, 490CACB848ED440A

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) + (const_color[0].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].aaa) + (const_color[1].rgb) * (vec3(1.0) - (const_color[1].aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (const_color[2].a) + (const_color[2].r) * (1.0 - (const_color[2].a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((texcolor1.a) * (const_color[3].a) + (texcolor1.r) * (1.0 - (const_color[3].a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = (last_tex_env_out.rgb);
float alpha_output_4 = byteround(clamp((last_tex_env_out.a) * (combiner_buffer.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D3310DE0F23CD476, 490CACB848ED440A
// program: 35CCCCDE75E2FF83, B80FA1B7F97410CD, 490CACB848ED440A
// reference: C9703DCE4065D603, 35CCCCDE75E2FF83
// shader: 8B31, 4CDB2C6E0A14815D

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;
out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_19();
bool sub_19_29();
bool sub_29_79();
bool sub_34_52();
bool sub_52_60();
bool sub_77_78();
bool sub_79_106();
bool sub_81_86();
bool sub_86_105();
bool sub_89_95();
bool sub_95_104();
bool sub_96_100();
bool sub_100_103();
bool sub_106_130();
bool sub_108_112();
bool sub_112_129();
bool sub_113_127();
bool sub_116_123();
bool sub_123_126();
bool sub_127_128();
bool sub_130_146();
bool sub_132_136();
bool sub_136_145();
bool sub_137_143();
bool sub_143_144();
bool sub_146_154();
bool sub_148_149();
bool sub_149_153();
bool sub_150_151();
bool sub_151_152();
bool sub_154_161();
bool sub_161_167();
bool sub_167_4096();

bool exec_shader() {
    sub_167_4096();
    return true;
}

bool sub_0_19() {
    uint jmp_to = 0u;
    while (true) {
        switch (jmp_to) {
        case 0u: {
            reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
            reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
            reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
            reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
            reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
            reg_tmp6.x = rsq_s(reg_tmp6.x);
            reg_tmp7.x = rsq_s(reg_tmp7.x);
            reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            reg_tmp0 = uniforms.f[93].yxxx;
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            reg_tmp4 = mul_s(uniforms.f[94].xxxx, reg_tmp4);
            conditional_code = greaterThanEqual(uniforms.f[93].xx, reg_tmp4.xx);
            reg_tmp4 = vec4(rsq_s(reg_tmp4.x));
            reg_tmp5 = mul_s(uniforms.f[94].xxxx, reg_tmp14);
            if (conditional_code.x) {
                { jmp_to = 18u; break; }
            }
            reg_tmp0.z = rcp_s(reg_tmp4.x);
            reg_tmp0.xy = (mul_s(reg_tmp5, reg_tmp4)).xy;
        }
        case 18u: {
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_19_29() {
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    reg_tmp4.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_29_79() {
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    reg_tmp13.xyz = (vs_in_reg2).xyz;
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    if (uniforms.b[0]) {
        sub_34_52();
    } else {
        sub_52_60();
    }
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    {
        sub_0_19();
    }
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    vs_out_attr2 = -reg_tmp15;
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    if (all(conditional_code)) {
        sub_77_78();
    }
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_34_52() {
    reg_tmp7 = uniforms.f[93].xxxx;
    reg_tmp12 = uniforms.f[93].xxxx;
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    {
        sub_19_29();
    }
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    {
        sub_19_29();
    }
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    {
        sub_19_29();
    }
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    {
        sub_19_29();
    }
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    reg_tmp10 = reg_tmp7;
    return false;
}
bool sub_52_60() {
    reg_tmp7 = reg_tmp15;
    reg_tmp10.x = dot_s(uniforms.f[10], reg_tmp7);
    reg_tmp10.y = dot_s(uniforms.f[11], reg_tmp7);
    reg_tmp10.z = dot_s(uniforms.f[12], reg_tmp7);
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    reg_tmp12.x = dot_3(uniforms.f[10].xyz, reg_tmp14.xyz);
    reg_tmp12.y = dot_3(uniforms.f[11].xyz, reg_tmp14.xyz);
    reg_tmp12.z = dot_3(uniforms.f[12].xyz, reg_tmp14.xyz);
    return false;
}
bool sub_77_78() {
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_79_106() {
    reg_tmp0.xy = (uniforms.f[0].xxxx).xy;
    if (uniforms.b[2]) {
        sub_81_86();
    } else {
        sub_86_105();
    }
    return false;
}
bool sub_81_86() {
    {
        sub_146_154();
    }
    reg_tmp3.x = dot_s(uniforms.f[1].xywz, reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2].xywz, reg_tmp6);
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_86_105() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_89_95();
    } else {
        sub_95_104();
    }
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_89_95() {
    reg_tmp6 = reg_tmp10;
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    reg_tmp3.z = dot_s(uniforms.f[3], reg_tmp6);
    reg_tmp0.xy = (mul_s(uniforms.f[9].xyyy, reg_tmp3.zzzz)).xy;
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_95_104() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_96_100();
    } else {
        sub_100_103();
    }
    return false;
}
bool sub_96_100() {
    {
        sub_154_161();
    }
    reg_tmp3.x = dot_3(uniforms.f[1].xyz, reg_tmp6.xyz);
    reg_tmp3.y = dot_3(uniforms.f[2].xyz, reg_tmp6.xyz);
    reg_tmp3.z = dot_3(uniforms.f[3].xyz, reg_tmp6.xyz);
    return false;
}
bool sub_100_103() {
    {
        sub_161_167();
    }
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    return false;
}
bool sub_106_130() {
    reg_tmp0.xy = (uniforms.f[0].yyyy).xy;
    if (uniforms.b[3]) {
        sub_108_112();
    } else {
        sub_112_129();
    }
    return false;
}
bool sub_108_112() {
    {
        sub_146_154();
    }
    reg_tmp4.x = dot_s(uniforms.f[4].xywz, reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5].xywz, reg_tmp6);
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_112_129() {
    if (uniforms.b[5]) {
        sub_113_127();
    } else {
        sub_127_128();
    }
    return false;
}
bool sub_113_127() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_116_123();
    } else {
        sub_123_126();
    }
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_116_123() {
    reg_tmp6 = reg_tmp10;
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    reg_tmp4.z = dot_s(uniforms.f[6], reg_tmp6);
    reg_tmp6.w = rcp_s(reg_tmp4.z);
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    reg_tmp4.xy = (uniforms.f[9].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_123_126() {
    {
        sub_161_167();
    }
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    return false;
}
bool sub_127_128() {
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_130_146() {
    reg_tmp0.xy = (uniforms.f[0].zzzz).xy;
    if (uniforms.b[4]) {
        sub_132_136();
    } else {
        sub_136_145();
    }
    return false;
}
bool sub_132_136() {
    {
        sub_146_154();
    }
    reg_tmp5.x = dot_s(uniforms.f[7].xywz, reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8].xywz, reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_136_145() {
    if (uniforms.b[6]) {
        sub_137_143();
    } else {
        sub_143_144();
    }
    return false;
}
bool sub_137_143() {
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    {
        sub_161_167();
    }
    reg_tmp5.x = dot_s(uniforms.f[7], reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8], reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_143_144() {
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
bool sub_146_154() {
    conditional_code = equal(uniforms.f[93].yz, reg_tmp0.xy);
    if (all(not(conditional_code))) {
        sub_148_149();
    } else {
        sub_149_153();
    }
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_148_149() {
    reg_tmp6.xy = (vs_in_reg4.xyyy).xy;
    return false;
}
bool sub_149_153() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_150_151();
    } else {
        sub_151_152();
    }
    return false;
}
bool sub_150_151() {
    reg_tmp6.xy = (vs_in_reg5.xyyy).xy;
    return false;
}
bool sub_151_152() {
    reg_tmp6.xy = (vs_in_reg6.xyyy).xy;
    return false;
}
bool sub_154_161() {
    reg_tmp2 = -reg_tmp15;
    reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
    reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_161_167() {
    reg_tmp1 = reg_tmp14;
    reg_tmp2.w = dot_3(reg_tmp1.xyz, reg_tmp1.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp1 = mul_s(reg_tmp1, reg_tmp2.wwww);
    reg_tmp1 = mul_s(uniforms.f[94].xxxx, reg_tmp1);
    reg_tmp6.xy = (uniforms.f[94].xxxx + reg_tmp1.xyyy).xy;
    return false;
}
bool sub_167_4096() {
    {
        sub_29_79();
    }
    reg_tmp2 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
    reg_tmp1.xyz = (uniforms.f[93].xxyx).xyz;
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    reg_tmp14.w = (uniforms.f[93].xxxx).w;
    reg_tmp8 = reg_tmp14;
    reg_tmp14.x = dot_s(reg_tmp8, reg_tmp8);
    reg_tmp14.x = rsq_s(reg_tmp14.x);
    reg_tmp14 = mul_s(reg_tmp8, reg_tmp14.xxxx);
    reg_tmp9.x = dot_3(reg_tmp14.xyz, reg_tmp1.xyz);
    reg_tmp9.x = (max(uniforms.f[93].xxxx, reg_tmp9.xxxx)).x;
    reg_tmp9.x = (min(uniforms.f[93].yyyy, reg_tmp9.xxxx)).x;
    reg_tmp9.x = (uniforms.f[93].yyyy + -reg_tmp9.xxxx).x;
    reg_tmp9.x = log2(reg_tmp9.x);
    reg_tmp9.x = (mul_s(uniforms.f[82].xxxx, reg_tmp9.xxxx)).x;
    reg_tmp9.x = exp2(reg_tmp9.x);
    reg_tmp2.w = (mul_s(uniforms.f[82].yyyy, reg_tmp9.xxxx)).w;
    vs_out_attr3 = reg_tmp2;
    {
        sub_79_106();
    }
    {
        sub_106_130();
    }
    {
        sub_130_146();
    }
    return true;
}
// reference: 5C640A05FCF66F8E, 4CDB2C6E0A14815D
// shader: 8B30, B3C2F6056AADCF6F

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(light_vector, normal)));
refl_value.g = (lut_scale_rg * LookupLightingLUTSigned(5, dot(light_vector, normal)));
refl_value.b = (lut_scale_rb * LookupLightingLUTSigned(4, dot(light_vector, normal)));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (secondary_fragment_color.r);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (texcolor0.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((secondary_fragment_color.ggg) * (last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) + (texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 5000F68D161C7DA9, B3C2F6056AADCF6F
// program: 4CDB2C6E0A14815D, B80FA1B7F97410CD, B3C2F6056AADCF6F
// reference: 1230F5450DBCB0DE, 4CDB2C6E0A14815D
// shader: 8B31, E81D148B6EF003F8

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;
out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_19();
bool sub_19_55();
bool sub_55_65();
bool sub_65_79();
bool sub_79_129();
bool sub_84_102();
bool sub_102_110();
bool sub_127_128();
bool sub_129_185();
bool sub_134_152();
bool sub_152_163();
bool sub_183_184();
bool sub_185_212();
bool sub_187_192();
bool sub_192_211();
bool sub_195_201();
bool sub_201_210();
bool sub_202_206();
bool sub_206_209();
bool sub_212_236();
bool sub_214_218();
bool sub_218_235();
bool sub_219_233();
bool sub_222_229();
bool sub_229_232();
bool sub_233_234();
bool sub_236_252();
bool sub_238_242();
bool sub_242_251();
bool sub_243_249();
bool sub_249_250();
bool sub_252_260();
bool sub_254_255();
bool sub_255_259();
bool sub_256_257();
bool sub_257_258();
bool sub_260_267();
bool sub_267_273();
bool sub_273_4096();
bool sub_274_276();
bool sub_276_278();
bool sub_279_286();
bool sub_286_287();

bool exec_shader() {
    sub_273_4096();
    return true;
}

bool sub_0_19() {
    uint jmp_to = 0u;
    while (true) {
        switch (jmp_to) {
        case 0u: {
            reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
            reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
            reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
            reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
            reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
            reg_tmp6.x = rsq_s(reg_tmp6.x);
            reg_tmp7.x = rsq_s(reg_tmp7.x);
            reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            reg_tmp0 = uniforms.f[93].yxxx;
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            reg_tmp4 = mul_s(uniforms.f[94].xxxx, reg_tmp4);
            conditional_code = greaterThanEqual(uniforms.f[93].xx, reg_tmp4.xx);
            reg_tmp4 = vec4(rsq_s(reg_tmp4.x));
            reg_tmp5 = mul_s(uniforms.f[94].xxxx, reg_tmp14);
            if (conditional_code.x) {
                { jmp_to = 18u; break; }
            }
            reg_tmp0.z = rcp_s(reg_tmp4.x);
            reg_tmp0.xy = (mul_s(reg_tmp5, reg_tmp4)).xy;
        }
        case 18u: {
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_19_55() {
    uint jmp_to = 19u;
    while (true) {
        switch (jmp_to) {
        case 19u: {
            reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
            reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
            reg_tmp6.x = rsq_s(reg_tmp6.x);
            reg_tmp7.x = rsq_s(reg_tmp7.x);
            reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            reg_tmp13.xyz = (mul_s(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            reg_tmp11.xyz = (mul_s(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            reg_tmp0 = uniforms.f[93].yxxx;
            reg_tmp13.xyz = (mul_s(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            reg_tmp11.xyz = (mul_s(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            reg_tmp5 = mul_s(reg_tmp14.yzxx, reg_tmp13.zxyy);
            reg_tmp5 = fma_s(-reg_tmp13.yzxx, reg_tmp14.zxyy, reg_tmp5);
            reg_tmp5.w = dot_3(reg_tmp5.xyz, reg_tmp5.xyz);
            reg_tmp5.w = rsq_s(reg_tmp5.w);
            reg_tmp5 = mul_s(reg_tmp5, reg_tmp5.wwww);
            reg_tmp6.w = (reg_tmp14.zzzz + reg_tmp5.yyyy).w;
            reg_tmp13 = mul_s(reg_tmp5.yzxx, reg_tmp14.zxyy);
            reg_tmp13 = fma_s(-reg_tmp14.yzxx, reg_tmp5.zxyy, reg_tmp13);
            reg_tmp6.w = (reg_tmp13.xxxx + reg_tmp6).w;
            reg_tmp13.w = (reg_tmp5.zzzz).w;
            reg_tmp5.z = (reg_tmp13.xxxx).z;
            reg_tmp6.w = (uniforms.f[93].yyyy + reg_tmp6).w;
            reg_tmp14.w = (reg_tmp5.xxxx).w;
            reg_tmp5.x = (reg_tmp14.zzzz).x;
            conditional_code = lessThan(uniforms.f[94].zz, reg_tmp6.ww);
            reg_tmp6.x = (uniforms.f[93].yyyy).x;
            reg_tmp6.y = (-uniforms.f[93].yyyy).y;
            if (!conditional_code.x) {
                { jmp_to = 54u; break; }
            }
            reg_tmp7.xz = (reg_tmp13.wwyy + -reg_tmp14.yyww).xz;
            reg_tmp7.y = (reg_tmp14.xxxx + -reg_tmp13.zzzz).y;
            reg_tmp7.w = (reg_tmp6).w;
            reg_tmp6 = vec4(dot_s(reg_tmp7, reg_tmp7));
            reg_tmp6 = vec4(rsq_s(reg_tmp6.x));
            reg_tmp0 = mul_s(reg_tmp7, reg_tmp6);
        }
        case 54u: {
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_55_65() {
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    reg_tmp4.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_65_79() {
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    reg_tmp4.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp5.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp13.xyz);
    reg_tmp5.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp13.xyz);
    reg_tmp5.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp13.xyz);
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    reg_tmp11 = fma_s(reg_tmp1.wwww, reg_tmp5, reg_tmp11);
    return false;
}
bool sub_79_129() {
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    reg_tmp13.xyz = (vs_in_reg2).xyz;
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    if (uniforms.b[0]) {
        sub_84_102();
    } else {
        sub_102_110();
    }
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    {
        sub_0_19();
    }
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    vs_out_attr2 = -reg_tmp15;
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    if (all(conditional_code)) {
        sub_127_128();
    }
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_84_102() {
    reg_tmp7 = uniforms.f[93].xxxx;
    reg_tmp12 = uniforms.f[93].xxxx;
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    {
        sub_55_65();
    }
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    {
        sub_55_65();
    }
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    {
        sub_55_65();
    }
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    {
        sub_55_65();
    }
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    reg_tmp10 = reg_tmp7;
    return false;
}
bool sub_102_110() {
    reg_tmp7 = reg_tmp15;
    reg_tmp10.x = dot_s(uniforms.f[10], reg_tmp7);
    reg_tmp10.y = dot_s(uniforms.f[11], reg_tmp7);
    reg_tmp10.z = dot_s(uniforms.f[12], reg_tmp7);
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    reg_tmp12.x = dot_3(uniforms.f[10].xyz, reg_tmp14.xyz);
    reg_tmp12.y = dot_3(uniforms.f[11].xyz, reg_tmp14.xyz);
    reg_tmp12.z = dot_3(uniforms.f[12].xyz, reg_tmp14.xyz);
    return false;
}
bool sub_127_128() {
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_129_185() {
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    reg_tmp13.xyz = (vs_in_reg2).xyz;
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    if (uniforms.b[0]) {
        sub_134_152();
    } else {
        sub_152_163();
    }
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    reg_tmp13.x = dot_3(uniforms.f[90].xyz, reg_tmp11.xyz);
    reg_tmp13.y = dot_3(uniforms.f[91].xyz, reg_tmp11.xyz);
    reg_tmp13.z = dot_3(uniforms.f[92].xyz, reg_tmp11.xyz);
    {
        sub_19_55();
    }
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    vs_out_attr2 = -reg_tmp15;
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    if (all(conditional_code)) {
        sub_183_184();
    }
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_134_152() {
    reg_tmp7 = uniforms.f[93].xxxx;
    reg_tmp12 = uniforms.f[93].xxxx;
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    {
        sub_65_79();
    }
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    {
        sub_65_79();
    }
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    {
        sub_65_79();
    }
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    {
        sub_65_79();
    }
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    reg_tmp10 = reg_tmp7;
    return false;
}
bool sub_152_163() {
    reg_tmp7 = reg_tmp15;
    reg_tmp10.x = dot_s(uniforms.f[10], reg_tmp7);
    reg_tmp10.y = dot_s(uniforms.f[11], reg_tmp7);
    reg_tmp10.z = dot_s(uniforms.f[12], reg_tmp7);
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    reg_tmp12.x = dot_3(uniforms.f[10].xyz, reg_tmp14.xyz);
    reg_tmp12.y = dot_3(uniforms.f[11].xyz, reg_tmp14.xyz);
    reg_tmp12.z = dot_3(uniforms.f[12].xyz, reg_tmp14.xyz);
    reg_tmp11.x = dot_3(uniforms.f[10].xyz, reg_tmp13.xyz);
    reg_tmp11.y = dot_3(uniforms.f[11].xyz, reg_tmp13.xyz);
    reg_tmp11.z = dot_3(uniforms.f[12].xyz, reg_tmp13.xyz);
    return false;
}
bool sub_183_184() {
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_185_212() {
    reg_tmp0.xy = (uniforms.f[0].xxxx).xy;
    if (uniforms.b[2]) {
        sub_187_192();
    } else {
        sub_192_211();
    }
    return false;
}
bool sub_187_192() {
    {
        sub_252_260();
    }
    reg_tmp3.x = dot_s(uniforms.f[1].xywz, reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2].xywz, reg_tmp6);
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_192_211() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_195_201();
    } else {
        sub_201_210();
    }
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_195_201() {
    reg_tmp6 = reg_tmp10;
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    reg_tmp3.z = dot_s(uniforms.f[3], reg_tmp6);
    reg_tmp0.xy = (mul_s(uniforms.f[9].xyyy, reg_tmp3.zzzz)).xy;
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_201_210() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_202_206();
    } else {
        sub_206_209();
    }
    return false;
}
bool sub_202_206() {
    {
        sub_260_267();
    }
    reg_tmp3.x = dot_3(uniforms.f[1].xyz, reg_tmp6.xyz);
    reg_tmp3.y = dot_3(uniforms.f[2].xyz, reg_tmp6.xyz);
    reg_tmp3.z = dot_3(uniforms.f[3].xyz, reg_tmp6.xyz);
    return false;
}
bool sub_206_209() {
    {
        sub_267_273();
    }
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    return false;
}
bool sub_212_236() {
    reg_tmp0.xy = (uniforms.f[0].yyyy).xy;
    if (uniforms.b[3]) {
        sub_214_218();
    } else {
        sub_218_235();
    }
    return false;
}
bool sub_214_218() {
    {
        sub_252_260();
    }
    reg_tmp4.x = dot_s(uniforms.f[4].xywz, reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5].xywz, reg_tmp6);
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_218_235() {
    if (uniforms.b[5]) {
        sub_219_233();
    } else {
        sub_233_234();
    }
    return false;
}
bool sub_219_233() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_222_229();
    } else {
        sub_229_232();
    }
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_222_229() {
    reg_tmp6 = reg_tmp10;
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    reg_tmp4.z = dot_s(uniforms.f[6], reg_tmp6);
    reg_tmp6.w = rcp_s(reg_tmp4.z);
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    reg_tmp4.xy = (uniforms.f[9].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_229_232() {
    {
        sub_267_273();
    }
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    return false;
}
bool sub_233_234() {
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_236_252() {
    reg_tmp0.xy = (uniforms.f[0].zzzz).xy;
    if (uniforms.b[4]) {
        sub_238_242();
    } else {
        sub_242_251();
    }
    return false;
}
bool sub_238_242() {
    {
        sub_252_260();
    }
    reg_tmp5.x = dot_s(uniforms.f[7].xywz, reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8].xywz, reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_242_251() {
    if (uniforms.b[6]) {
        sub_243_249();
    } else {
        sub_249_250();
    }
    return false;
}
bool sub_243_249() {
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    {
        sub_267_273();
    }
    reg_tmp5.x = dot_s(uniforms.f[7], reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8], reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_249_250() {
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
bool sub_252_260() {
    conditional_code = equal(uniforms.f[93].yz, reg_tmp0.xy);
    if (all(not(conditional_code))) {
        sub_254_255();
    } else {
        sub_255_259();
    }
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_254_255() {
    reg_tmp6.xy = (vs_in_reg4.xyyy).xy;
    return false;
}
bool sub_255_259() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_256_257();
    } else {
        sub_257_258();
    }
    return false;
}
bool sub_256_257() {
    reg_tmp6.xy = (vs_in_reg5.xyyy).xy;
    return false;
}
bool sub_257_258() {
    reg_tmp6.xy = (vs_in_reg6.xyyy).xy;
    return false;
}
bool sub_260_267() {
    reg_tmp2 = -reg_tmp15;
    reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
    reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_267_273() {
    reg_tmp1 = reg_tmp14;
    reg_tmp2.w = dot_3(reg_tmp1.xyz, reg_tmp1.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp1 = mul_s(reg_tmp1, reg_tmp2.wwww);
    reg_tmp1 = mul_s(uniforms.f[94].xxxx, reg_tmp1);
    reg_tmp6.xy = (uniforms.f[94].xxxx + reg_tmp1.xyyy).xy;
    return false;
}
bool sub_273_4096() {
    if (uniforms.b[10]) {
        sub_274_276();
    } else {
        sub_276_278();
    }
    if (uniforms.b[1]) {
        sub_279_286();
    } else {
        sub_286_287();
    }
    vs_out_attr3 = reg_tmp2;
    {
        sub_185_212();
    }
    {
        sub_212_236();
    }
    {
        sub_236_252();
    }
    return true;
}
bool sub_274_276() {
    {
        sub_129_185();
    }
    return false;
}
bool sub_276_278() {
    {
        sub_79_129();
    }
    return false;
}
bool sub_279_286() {
    reg_tmp0 = vec4(dot_3(uniforms.f[83].xyz, reg_tmp12.xyz));
    reg_tmp0 = max(uniforms.f[93].xxxx, reg_tmp0);
    reg_tmp0 = mul_s(uniforms.f[84], reg_tmp0);
    reg_tmp0 = uniforms.f[85] + reg_tmp0;
    reg_tmp0.w = (uniforms.f[93].yyyy).w;
    reg_tmp1 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
    reg_tmp2 = mul_s(reg_tmp0, reg_tmp1);
    return false;
}
bool sub_286_287() {
    reg_tmp2 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
    return false;
}
// reference: 9D04A1EB9CC42A9E, E81D148B6EF003F8
// shader: 8B30, 26CF8128A3DDBB83

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor1.aaa) * (texcolor1.aaa), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (rounded_primary_color.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.aaa), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) + (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: FBEC36122394C1DC, 26CF8128A3DDBB83
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 26CF8128A3DDBB83
// reference: D3505EAB6D8EF5CE, E81D148B6EF003F8
// shader: 8B30, 953385FED82E0FD1

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 2C801EA34245A1AF, 953385FED82E0FD1
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 953385FED82E0FD1
// shader: 8B30, E52C4E220978C964

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (texcolor1.rgb) + (texcolor2.rgb) * (vec3(1.0) - (texcolor1.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 88F70EAB2A0DD9B5, E52C4E220978C964
// program: E81D148B6EF003F8, B80FA1B7F97410CD, E52C4E220978C964
// reference: D3505EAB2BB17EEA, E81D148B6EF003F8
// shader: 8B30, 378438FF70532E82

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 186E808133587B0D, 378438FF70532E82
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 378438FF70532E82
// shader: 8B30, 9F25A997909124C1

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor1.g) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (texcolor1.rrr) + (const_color[2].rgb) * (vec3(1.0) - (texcolor1.rrr)), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 4CD3A9AD9C30D273, 9F25A997909124C1
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 9F25A997909124C1
// shader: 8B30, F35E8CA2CAC182F7

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 7F018AB24245A1AF, F35E8CA2CAC182F7
// program: E81D148B6EF003F8, B80FA1B7F97410CD, F35E8CA2CAC182F7
// reference: 7F018AB28F755D75, F35E8CA2CAC182F7
// shader: 8B30, 168DA83A29634DCC

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp(min((texcolor0.rgb) + (texcolor1.rgb), vec3(1.0)) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 28B6C1BB0A3D7126, 168DA83A29634DCC
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 168DA83A29634DCC
// shader: 8B30, 576E786439C2EA2F

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.aaa) + (texcolor1.rgb) * (vec3(1.0) - (rounded_primary_color.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 79E27667AB6B9A91, 576E786439C2EA2F
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 576E786439C2EA2F
// shader: 8B30, FFE5F81052CAA889

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp(min((texcolor0.rgb) + (texcolor1.rgb), vec3(1.0)) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 28B6C1BBE68A9A25, FFE5F81052CAA889
// program: E81D148B6EF003F8, B80FA1B7F97410CD, FFE5F81052CAA889
// shader: 8B30, 1471721266F6CFF3

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.aaa) + (texcolor1.rgb) * (vec3(1.0) - (rounded_primary_color.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_1 = byteround(clamp((texcolor1.aaa) * (texcolor2.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (last_tex_env_out.rrr) + (combiner_buffer.rgb) * (vec3(1.0) - (last_tex_env_out.rrr)), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb) * (combiner_buffer.ggg) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.ggg)), vec3(0.0), vec3(1.0)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 28303F0DA914F330, 1471721266F6CFF3
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 1471721266F6CFF3
// shader: 8B30, 90EA57FA2E348842

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(normal, normalize(half_vector))));
refl_value.g = (lut_scale_rg * LookupLightingLUTSigned(5, dot(normal, normalize(view))));
refl_value.b = (lut_scale_rb * LookupLightingLUTSigned(4, dot(normal, normalize(half_vector))));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) + (secondary_fragment_color.ggg), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D26D4A8A38E4BAF9, 90EA57FA2E348842
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 90EA57FA2E348842
// shader: 8B30, 1212B53523129C17

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(normal, normalize(view))));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (texcolor2.aaa) + (texcolor1.rgb) * (vec3(1.0) - (texcolor2.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (secondary_fragment_color.rrr) + (last_tex_env_out.rgb) * (vec3(1.0) - (secondary_fragment_color.rrr)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 447469C623185624, 1212B53523129C17
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 1212B53523129C17
// shader: 8B30, C9A23B908E5F8ABB

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(normal, normalize(view))));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.aaa) + (texcolor1.rgb) * (vec3(1.0) - (rounded_primary_color.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (secondary_fragment_color.rrr) + (last_tex_env_out.rgb) * (vec3(1.0) - (secondary_fragment_color.rrr)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: BBA477028CBAA9A3, C9A23B908E5F8ABB
// program: E81D148B6EF003F8, B80FA1B7F97410CD, C9A23B908E5F8ABB
// shader: 8B30, 7E2D94A79BE7422B

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(normal, normalize(view))));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb) * (secondary_fragment_color.rrr) + (texcolor1.rgb) * (vec3(1.0) - (secondary_fragment_color.rrr)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_1 = (texcolor0.rgb);
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor0.rgb) * (texcolor2.aaa) + (combiner_buffer.rgb) * (vec3(1.0) - (texcolor2.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) * (texcolor2.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D03CA6A18F5B2684, 7E2D94A79BE7422B
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 7E2D94A79BE7422B
// shader: 8B31, 87E005DC9696CDE3

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;
out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_19();
bool sub_19_29();
bool sub_29_90();
bool sub_33_51();
bool sub_51_59();
bool sub_88_89();
bool sub_90_117();
bool sub_92_97();
bool sub_97_116();
bool sub_100_106();
bool sub_106_115();
bool sub_107_111();
bool sub_111_114();
bool sub_117_141();
bool sub_119_123();
bool sub_123_140();
bool sub_124_138();
bool sub_127_134();
bool sub_134_137();
bool sub_138_139();
bool sub_141_157();
bool sub_143_147();
bool sub_147_156();
bool sub_148_154();
bool sub_154_155();
bool sub_157_165();
bool sub_159_160();
bool sub_160_164();
bool sub_161_162();
bool sub_162_163();
bool sub_165_172();
bool sub_172_178();
bool sub_178_4096();
bool sub_180_187();
bool sub_187_188();

bool exec_shader() {
    sub_178_4096();
    return true;
}

bool sub_0_19() {
    uint jmp_to = 0u;
    while (true) {
        switch (jmp_to) {
        case 0u: {
            reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
            reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
            reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
            reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
            reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
            reg_tmp6.x = rsq_s(reg_tmp6.x);
            reg_tmp7.x = rsq_s(reg_tmp7.x);
            reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            reg_tmp0 = uniforms.f[93].yxxx;
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            reg_tmp4 = mul_s(uniforms.f[94].xxxx, reg_tmp4);
            conditional_code = greaterThanEqual(uniforms.f[93].xx, reg_tmp4.xx);
            reg_tmp4 = vec4(rsq_s(reg_tmp4.x));
            reg_tmp5 = mul_s(uniforms.f[94].xxxx, reg_tmp14);
            if (conditional_code.x) {
                { jmp_to = 18u; break; }
            }
            reg_tmp0.z = rcp_s(reg_tmp4.x);
            reg_tmp0.xy = (mul_s(reg_tmp5, reg_tmp4)).xy;
        }
        case 18u: {
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_19_29() {
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    reg_tmp4.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_29_90() {
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    if (uniforms.b[0]) {
        sub_33_51();
    } else {
        sub_51_59();
    }
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    {
        sub_0_19();
    }
    vs_out_attr2 = -reg_tmp15;
    reg_tmp0.x = (uniforms.f[93].yyyy).x;
    address_registers.x = (ivec2(vs_in_reg3.xx)).x;
    reg_tmp0.x = (mul_s(uniforms.f[13 + address_registers.x].xxxx, reg_tmp0.xxxx)).x;
    address_registers.x = (ivec2(vs_in_reg3.yy)).x;
    reg_tmp0.x = (mul_s(uniforms.f[13 + address_registers.x].yyyy, reg_tmp0.xxxx)).x;
    address_registers.x = (ivec2(vs_in_reg3.zz)).x;
    reg_tmp0.x = (mul_s(uniforms.f[13 + address_registers.x].zzzz, reg_tmp0.xxxx)).x;
    address_registers.x = (ivec2(vs_in_reg3.ww)).x;
    reg_tmp0.x = (mul_s(uniforms.f[13 + address_registers.x].wwww, reg_tmp0.xxxx)).x;
    reg_tmp15.xyz = (mul_s(reg_tmp15.xyzz, reg_tmp0.xxxx)).xyz;
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    if (all(conditional_code)) {
        sub_88_89();
    }
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_33_51() {
    reg_tmp7 = uniforms.f[93].xxxx;
    reg_tmp12 = uniforms.f[93].xxxx;
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    {
        sub_19_29();
    }
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    {
        sub_19_29();
    }
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    {
        sub_19_29();
    }
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    {
        sub_19_29();
    }
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    reg_tmp10 = reg_tmp7;
    return false;
}
bool sub_51_59() {
    reg_tmp7 = reg_tmp15;
    reg_tmp10.x = dot_s(uniforms.f[10], reg_tmp7);
    reg_tmp10.y = dot_s(uniforms.f[11], reg_tmp7);
    reg_tmp10.z = dot_s(uniforms.f[12], reg_tmp7);
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    reg_tmp12.x = dot_3(uniforms.f[10].xyz, reg_tmp14.xyz);
    reg_tmp12.y = dot_3(uniforms.f[11].xyz, reg_tmp14.xyz);
    reg_tmp12.z = dot_3(uniforms.f[12].xyz, reg_tmp14.xyz);
    return false;
}
bool sub_88_89() {
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_90_117() {
    reg_tmp0.xy = (uniforms.f[0].xxxx).xy;
    if (uniforms.b[2]) {
        sub_92_97();
    } else {
        sub_97_116();
    }
    return false;
}
bool sub_92_97() {
    {
        sub_157_165();
    }
    reg_tmp3.x = dot_s(uniforms.f[1].xywz, reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2].xywz, reg_tmp6);
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_97_116() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_100_106();
    } else {
        sub_106_115();
    }
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_100_106() {
    reg_tmp6 = reg_tmp10;
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    reg_tmp3.z = dot_s(uniforms.f[3], reg_tmp6);
    reg_tmp0.xy = (mul_s(uniforms.f[9].xyyy, reg_tmp3.zzzz)).xy;
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_106_115() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_107_111();
    } else {
        sub_111_114();
    }
    return false;
}
bool sub_107_111() {
    {
        sub_165_172();
    }
    reg_tmp3.x = dot_3(uniforms.f[1].xyz, reg_tmp6.xyz);
    reg_tmp3.y = dot_3(uniforms.f[2].xyz, reg_tmp6.xyz);
    reg_tmp3.z = dot_3(uniforms.f[3].xyz, reg_tmp6.xyz);
    return false;
}
bool sub_111_114() {
    {
        sub_172_178();
    }
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    return false;
}
bool sub_117_141() {
    reg_tmp0.xy = (uniforms.f[0].yyyy).xy;
    if (uniforms.b[3]) {
        sub_119_123();
    } else {
        sub_123_140();
    }
    return false;
}
bool sub_119_123() {
    {
        sub_157_165();
    }
    reg_tmp4.x = dot_s(uniforms.f[4].xywz, reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5].xywz, reg_tmp6);
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_123_140() {
    if (uniforms.b[5]) {
        sub_124_138();
    } else {
        sub_138_139();
    }
    return false;
}
bool sub_124_138() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_127_134();
    } else {
        sub_134_137();
    }
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_127_134() {
    reg_tmp6 = reg_tmp10;
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    reg_tmp4.z = dot_s(uniforms.f[6], reg_tmp6);
    reg_tmp6.w = rcp_s(reg_tmp4.z);
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    reg_tmp4.xy = (uniforms.f[9].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_134_137() {
    {
        sub_172_178();
    }
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    return false;
}
bool sub_138_139() {
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_141_157() {
    reg_tmp0.xy = (uniforms.f[0].zzzz).xy;
    if (uniforms.b[4]) {
        sub_143_147();
    } else {
        sub_147_156();
    }
    return false;
}
bool sub_143_147() {
    {
        sub_157_165();
    }
    reg_tmp5.x = dot_s(uniforms.f[7].xywz, reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8].xywz, reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_147_156() {
    if (uniforms.b[6]) {
        sub_148_154();
    } else {
        sub_154_155();
    }
    return false;
}
bool sub_148_154() {
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    {
        sub_172_178();
    }
    reg_tmp5.x = dot_s(uniforms.f[7], reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8], reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_154_155() {
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
bool sub_157_165() {
    conditional_code = equal(uniforms.f[93].yz, reg_tmp0.xy);
    if (all(not(conditional_code))) {
        sub_159_160();
    } else {
        sub_160_164();
    }
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_159_160() {
    reg_tmp6.xy = (vs_in_reg4.xyyy).xy;
    return false;
}
bool sub_160_164() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_161_162();
    } else {
        sub_162_163();
    }
    return false;
}
bool sub_161_162() {
    reg_tmp6.xy = (vs_in_reg5.xyyy).xy;
    return false;
}
bool sub_162_163() {
    reg_tmp6.xy = (vs_in_reg6.xyyy).xy;
    return false;
}
bool sub_165_172() {
    reg_tmp2 = -reg_tmp15;
    reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
    reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_172_178() {
    reg_tmp1 = reg_tmp14;
    reg_tmp2.w = dot_3(reg_tmp1.xyz, reg_tmp1.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp1 = mul_s(reg_tmp1, reg_tmp2.wwww);
    reg_tmp1 = mul_s(uniforms.f[94].xxxx, reg_tmp1);
    reg_tmp6.xy = (uniforms.f[94].xxxx + reg_tmp1.xyyy).xy;
    return false;
}
bool sub_178_4096() {
    {
        sub_29_90();
    }
    if (uniforms.b[1]) {
        sub_180_187();
    } else {
        sub_187_188();
    }
    vs_out_attr3 = reg_tmp2;
    {
        sub_90_117();
    }
    {
        sub_117_141();
    }
    {
        sub_141_157();
    }
    return true;
}
bool sub_180_187() {
    reg_tmp0 = vec4(dot_3(uniforms.f[83].xyz, reg_tmp12.xyz));
    reg_tmp0 = max(uniforms.f[93].xxxx, reg_tmp0);
    reg_tmp0 = mul_s(uniforms.f[84], reg_tmp0);
    reg_tmp0 = uniforms.f[85] + reg_tmp0;
    reg_tmp0.w = (uniforms.f[93].yyyy).w;
    reg_tmp1 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
    reg_tmp2 = mul_s(reg_tmp0, reg_tmp1);
    return false;
}
bool sub_187_188() {
    reg_tmp2 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
    return false;
}
// reference: BE582411386BD04C, 87E005DC9696CDE3
// shader: 8B30, 9342C6596F83F706

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor1.r);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 90CF07C19129C1FB, 9342C6596F83F706
// program: 87E005DC9696CDE3, B80FA1B7F97410CD, 9342C6596F83F706
// shader: 8B30, D02B1E1378BD97CF

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(normal, normalize(view))));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb) * (secondary_fragment_color.rrr) + (texcolor1.rgb) * (vec3(1.0) - (secondary_fragment_color.rrr)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_1 = (texcolor0.rgb);
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor0.rgb) * (texcolor2.aaa) + (combiner_buffer.rgb) * (vec3(1.0) - (texcolor2.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) * (texcolor2.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D03CA6A163ECCD87, D02B1E1378BD97CF
// program: E81D148B6EF003F8, B80FA1B7F97410CD, D02B1E1378BD97CF
// shader: 8B30, B78314A585D12D9C

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.aaa) + (texcolor1.rgb) * (vec3(1.0) - (rounded_primary_color.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 9DF0A67F2437D1FB, B78314A585D12D9C
// program: E81D148B6EF003F8, B80FA1B7F97410CD, B78314A585D12D9C
// shader: 8B30, DEC6EAEA57FA4325

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (texcolor2.aaa) + (texcolor1.rgb) * (vec3(1.0) - (texcolor2.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (texcolor2.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 64BFB8231EF36FDE, DEC6EAEA57FA4325
// program: E81D148B6EF003F8, B80FA1B7F97410CD, DEC6EAEA57FA4325
// shader: 8B30, D4C50B709583D191

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp(min((texcolor0.rgb) + (texcolor1.rgb), vec3(1.0)) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D82C9517C77B4F94, D4C50B709583D191
// program: E81D148B6EF003F8, B80FA1B7F97410CD, D4C50B709583D191
// shader: 8B30, B20F7E72A7330A13

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (texcolor2.aaa) + (texcolor1.rgb) * (vec3(1.0) - (texcolor2.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 79E276679FA91F25, B20F7E72A7330A13
// program: E81D148B6EF003F8, B80FA1B7F97410CD, B20F7E72A7330A13
// shader: 8B30, 48065A05481CB4B8

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.aaa) + (texcolor1.rgb) * (vec3(1.0) - (rounded_primary_color.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (texcolor2.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 80AD683BDCD29352, 48065A05481CB4B8
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 48065A05481CB4B8
// shader: 8B30, BB80E4A110994B48

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (texcolor2.aaa) + (texcolor1.rgb) * (vec3(1.0) - (texcolor2.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (texcolor2.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 64BFB823F24484DD, BB80E4A110994B48
// program: E81D148B6EF003F8, B80FA1B7F97410CD, BB80E4A110994B48
// shader: 8B30, EAAC665924781109

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(normal, normalize(view))));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (texcolor2.aaa) + (texcolor1.rgb) * (vec3(1.0) - (texcolor2.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (secondary_fragment_color.rrr) + (last_tex_env_out.rgb) * (vec3(1.0) - (secondary_fragment_color.rrr)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 447469C6CFAFBD27, EAAC665924781109
// program: E81D148B6EF003F8, B80FA1B7F97410CD, EAAC665924781109
// shader: 8B30, 0656C780E79F2203

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) + (texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 8DB79618EF6F0D75, 0656C780E79F2203
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 0656C780E79F2203
// shader: 8B30, 31E556E9A7729BF4

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp(min((texcolor0.rgb) + (texcolor1.rgb), vec3(1.0)) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D82C95172BCCA497, 31E556E9A7729BF4
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 31E556E9A7729BF4
// shader: 8B30, 6C66577708AE1E87

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 79A26A61A6099509, 6C66577708AE1E87
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 6C66577708AE1E87
// shader: 8B30, FC7222C50C6F5038

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb) * (texcolor0.ggg) + (vec3(1.0) - texcolor1.aaa) * (vec3(1.0) - (texcolor0.ggg)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (rounded_primary_color.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (texcolor0.rrr) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor0.rrr)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (texcolor0.bbb) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor0.bbb)), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rrr) + (texcolor2.rgb) * (vec3(1.0) - (primary_fragment_color.rrr)), vec3(0.0), vec3(1.0)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) + (texcolor1.rgb) - vec3(0.5), vec3(0.0), vec3(1.0)));
float alpha_output_4 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 4B90C6E2FDE11654, FC7222C50C6F5038
// program: E81D148B6EF003F8, B80FA1B7F97410CD, FC7222C50C6F5038
// shader: 8B30, D1B1A073730D724F

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = 2.0 * (texcolor2).rgb - 1.0;
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(normal, normalize(view))));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb) + (texcolor0.aaa), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (texcolor1.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0 * 1.0, alpha_output_0 * 2.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = (last_tex_env_out.rgb);
float alpha_output_1 = (1.0 - secondary_fragment_color.r);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a) + (combiner_buffer.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = (last_tex_env_out.rgb);
float alpha_output_5 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D7E8E0CE5473F4A9, D1B1A073730D724F
// program: E81D148B6EF003F8, B80FA1B7F97410CD, D1B1A073730D724F
// shader: 8B30, 790FB95CC0B11076

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((const_color[1].a) * (texcolor1.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((1.0 - combiner_buffer.a) * (last_tex_env_out.a) + (combiner_buffer.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 2901127D29619BF1, 790FB95CC0B11076
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 790FB95CC0B11076
// shader: 8B30, 037898F85F34DE95

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((const_color[1].a) * (texcolor1.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((1.0 - combiner_buffer.a) * (last_tex_env_out.a) + (combiner_buffer.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) < alphatest_ref) discard;
float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 2901127D4E960F87, 037898F85F34DE95
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 037898F85F34DE95
// reference: EBE62C278DE3AC64, 502AB780D80D09C1
// shader: 8B30, 91931D139F54748D

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rrr) * (const_color[0].rrr), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor0.ggg) * (const_color[1].ggg) + (last_tex_env_out.rrr), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor0.bbb) * (const_color[2].bbb) + (last_tex_env_out.rrr), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((texcolor0.rgb) * (texcolor1.aaa), vec3(0.0), vec3(1.0)));
float alpha_output_3 = (last_tex_env_out.r);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: C769BC5CA0EADC59, 91931D139F54748D
// program: 502AB780D80D09C1, B80FA1B7F97410CD, 91931D139F54748D
// shader: 8B30, 5FACCC9E3E0584D2

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (const_color[1].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) * (const_color[2].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = (last_tex_env_out.r);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 7F53101FAE9E225A, 5FACCC9E3E0584D2
// program: 502AB780D80D09C1, B80FA1B7F97410CD, 5FACCC9E3E0584D2
// reference: A5B2D367614B0AD4, 502AB780D80D09C1
// reference: BF76358E4C3E982D, D9C174A4A54356AC
// shader: 8B30, 835CABE3A4B650D2

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (const_color[1].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) * (const_color[2].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 3AC51CBBC13DF401, 835CABE3A4B650D2
// program: D9C174A4A54356AC, 42937135801BAA7E, 835CABE3A4B650D2
// shader: 8B30, F5D54925A6AE705F

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (const_color[1].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) * (const_color[2].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 3AC51CBB3ADD85B8, F5D54925A6AE705F
// program: D9C174A4A54356AC, 42937135801BAA7E, F5D54925A6AE705F
// reference: F122CACE14725F18, D9C174A4A54356AC
// reference: D3505EABC488EDAB, E81D148B6EF003F8
// shader: 8B30, D4C9E99618707555

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) * (const_color[2].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 5BEBE6BBCD5F1A87, D4C9E99618707555
// program: D9C174A4A54356AC, 42937135801BAA7E, D4C9E99618707555
// shader: 8B30, 0951EE62DBCF2390

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) * (const_color[2].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 5BEBE6BBC668E093, 0951EE62DBCF2390
// program: D9C174A4A54356AC, 42937135801BAA7E, 0951EE62DBCF2390
// shader: 8B30, 233D9A25E7282666

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].aaa);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) * (const_color[2].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 6B53F9F065C59CBA, 233D9A25E7282666
// program: D9C174A4A54356AC, 42937135801BAA7E, 233D9A25E7282666
// shader: 8B30, 3013FC5CF83A846B

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.r) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 103B0098D5C9395D, 3013FC5CF83A846B
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 3013FC5CF83A846B
// shader: 8B30, FC9E10BE42F07103

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = (const_color[0].a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: B2CD74B51F680A00, FC9E10BE42F07103
// program: 502AB780D80D09C1, B80FA1B7F97410CD, FC9E10BE42F07103
// reference: 1F78A60766D02152, 21786A34D707A069
// reference: 1F78A6079D3050EB, 5124AD903EB19D9F
// shader: 8B30, 886AC14BAA341C33

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 9740E06317507773, 886AC14BAA341C33
// program: D9C174A4A54356AC, 42937135801BAA7E, 886AC14BAA341C33
// shader: 8B30, 7C14C907B3CCD849

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 9740E0631C678D67, 7C14C907B3CCD849
// program: D9C174A4A54356AC, 42937135801BAA7E, 7C14C907B3CCD849
// shader: 8B30, 9978311FA4F16C3C

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) * (const_color[2].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 5BEBE6BB3D88912A, 9978311FA4F16C3C
// program: D9C174A4A54356AC, 42937135801BAA7E, 9978311FA4F16C3C
// shader: 8B30, 01575BADBADD21EF

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp(min((texcolor0.rgb) + (texcolor1.rgb), vec3(1.0)) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 7B3755AA0A3D7126, 01575BADBADD21EF
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 01575BADBADD21EF
// shader: 8B30, ABC97C54A7BF4D60

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rrr) + (texcolor2.rgb) * (vec3(1.0) - (primary_fragment_color.rrr)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 4925DD1ED2A3C03F, ABC97C54A7BF4D60
// program: E81D148B6EF003F8, B80FA1B7F97410CD, ABC97C54A7BF4D60
// shader: 8B30, 26BBC1E6E0D6F7FF

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp(min((texcolor0.rgb) + (texcolor1.rgb), vec3(1.0)) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 8BAD0106C77B4F94, 26BBC1E6E0D6F7FF
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 26BBC1E6E0D6F7FF
// shader: 8B30, 7337CC71AC06DD60

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp(min((texcolor0.rgb) + (texcolor1.rgb), vec3(1.0)) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 8BAD01062BCCA497, 7337CC71AC06DD60
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 7337CC71AC06DD60
// shader: 8B30, CF7B55EB749B1745

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 2C801EA3AEF24AAC, CF7B55EB749B1745
// program: E81D148B6EF003F8, B80FA1B7F97410CD, CF7B55EB749B1745
// shader: 8B30, F2989B699B9A67E9

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor1.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (const_color[1].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (primary_fragment_color.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: F4FFC6A99CDFF886, F2989B699B9A67E9
// program: E81D148B6EF003F8, B80FA1B7F97410CD, F2989B699B9A67E9
// shader: 8B30, 64E77DF66C1C7766

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = (last_tex_env_out.rgb);
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (primary_fragment_color.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (const_color[2].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: B6C296E9F1628B97, 64E77DF66C1C7766
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 64E77DF66C1C7766
// shader: 8B30, 6A44D3E672630106

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 2A23FE70A6099509, 6A44D3E672630106
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 6A44D3E672630106
// shader: 8B30, 3D2F05F592BCAC45

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(normal, normalize(view))));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (secondary_fragment_color.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 2FAD43B77FC07EC1, 3D2F05F592BCAC45
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 3D2F05F592BCAC45
// shader: 8B30, DBAEBC3C69195AAA

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: F6779270599F0D6D, DBAEBC3C69195AAA
// program: D9C174A4A54356AC, 42937135801BAA7E, DBAEBC3C69195AAA
// shader: 8B30, 62CB16D7F16FAC9B

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: F6779270A27F7CD4, 62CB16D7F16FAC9B
// program: D9C174A4A54356AC, 42937135801BAA7E, 62CB16D7F16FAC9B
// shader: 8B30, 31DB35D8B8E9549F

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 8ED580B86326FA84, 31DB35D8B8E9549F
// program: D9C174A4A54356AC, 42937135801BAA7E, 31DB35D8B8E9549F
// shader: 8B30, EB5CA625F01267FB

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 8ED580B868110090, EB5CA625F01267FB
// program: D9C174A4A54356AC, 42937135801BAA7E, EB5CA625F01267FB
// shader: 8B30, F2C7CEFD4FAFF562

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 8ED580B893F17129, F2C7CEFD4FAFF562
// program: D9C174A4A54356AC, 42937135801BAA7E, F2C7CEFD4FAFF562
// shader: 8B30, 7ED2F034E5EB4FC6

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (texcolor1.r);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: A10BA44298400D8A, 7ED2F034E5EB4FC6
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 7ED2F034E5EB4FC6
// shader: 8B30, BC32652205728950

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (const_color[0].a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D4F4BEF9083F90BA, BC32652205728950
// program: E81D148B6EF003F8, B80FA1B7F97410CD, BC32652205728950
// shader: 8B30, 10AAC2A3349D1A7E

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor1.rgb) * (texcolor0.rgb) + (texcolor1.rgb) * (vec3(1.0) - (texcolor0.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.r) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = (last_tex_env_out.rgb);
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (texcolor2.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (const_color[2].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 4813F809EB2BD90D, 10AAC2A3349D1A7E
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 10AAC2A3349D1A7E
// shader: 8B30, 52F5F74AF1B519B6

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = (last_tex_env_out.rgb);
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (texcolor2.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (const_color[2].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 55C660775F93AA9D, 52F5F74AF1B519B6
// program: D9C174A4A54356AC, 42937135801BAA7E, 52F5F74AF1B519B6
// shader: 8B30, 98F0722A788E01FD

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = (last_tex_env_out.rgb);
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (texcolor2.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (const_color[2].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 55C66077A473DB24, 98F0722A788E01FD
// program: D9C174A4A54356AC, 42937135801BAA7E, 98F0722A788E01FD
// reference: F122CACEFB4BCC59, D9C174A4A54356AC
// shader: 8B30, 6E5C02D38B9C02DF

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (const_color[2].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 783519FFF0B542F7, 6E5C02D38B9C02DF
// program: D9C174A4A54356AC, 42937135801BAA7E, 6E5C02D38B9C02DF
// shader: 8B30, A4E2954DD6C4FB71

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (const_color[2].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 783519FFFB82B8E3, A4E2954DD6C4FB71
// program: D9C174A4A54356AC, 42937135801BAA7E, A4E2954DD6C4FB71
// shader: 8B31, D0293423BD9EA1E7

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;
out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_19();
bool sub_19_55();
bool sub_55_65();
bool sub_65_78();
bool sub_78_128();
bool sub_83_101();
bool sub_101_109();
bool sub_126_127();
bool sub_128_184();
bool sub_133_151();
bool sub_151_162();
bool sub_182_183();
bool sub_184_211();
bool sub_186_191();
bool sub_191_210();
bool sub_194_200();
bool sub_200_209();
bool sub_201_205();
bool sub_205_208();
bool sub_211_235();
bool sub_213_217();
bool sub_217_234();
bool sub_218_232();
bool sub_221_228();
bool sub_228_231();
bool sub_232_233();
bool sub_235_251();
bool sub_237_241();
bool sub_241_250();
bool sub_242_248();
bool sub_248_249();
bool sub_251_259();
bool sub_253_254();
bool sub_254_258();
bool sub_255_256();
bool sub_256_257();
bool sub_259_266();
bool sub_266_272();
bool sub_272_4096();
bool sub_273_275();
bool sub_275_277();
bool sub_278_285();
bool sub_285_286();

bool exec_shader() {
    sub_272_4096();
    return true;
}

bool sub_0_19() {
    uint jmp_to = 0u;
    while (true) {
        switch (jmp_to) {
        case 0u: {
            reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
            reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
            reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
            reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
            reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
            reg_tmp6.x = rsq_s(reg_tmp6.x);
            reg_tmp7.x = rsq_s(reg_tmp7.x);
            reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            reg_tmp0 = uniforms.f[93].yxxx;
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            reg_tmp4 = mul_s(uniforms.f[94].xxxx, reg_tmp4);
            conditional_code = greaterThanEqual(uniforms.f[93].xx, reg_tmp4.xx);
            reg_tmp4 = vec4(rsq_s(reg_tmp4.x));
            reg_tmp5 = mul_s(uniforms.f[94].xxxx, reg_tmp14);
            if (conditional_code.x) {
                { jmp_to = 18u; break; }
            }
            reg_tmp0.z = rcp_s(reg_tmp4.x);
            reg_tmp0.xy = (mul_s(reg_tmp5, reg_tmp4)).xy;
        }
        case 18u: {
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_19_55() {
    uint jmp_to = 19u;
    while (true) {
        switch (jmp_to) {
        case 19u: {
            reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
            reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
            reg_tmp6.x = rsq_s(reg_tmp6.x);
            reg_tmp7.x = rsq_s(reg_tmp7.x);
            reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            reg_tmp13.xyz = (mul_s(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            reg_tmp11.xyz = (mul_s(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            reg_tmp0 = uniforms.f[93].yxxx;
            reg_tmp13.xyz = (mul_s(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            reg_tmp11.xyz = (mul_s(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            reg_tmp5 = mul_s(reg_tmp14.yzxx, reg_tmp13.zxyy);
            reg_tmp5 = fma_s(-reg_tmp13.yzxx, reg_tmp14.zxyy, reg_tmp5);
            reg_tmp5.w = dot_3(reg_tmp5.xyz, reg_tmp5.xyz);
            reg_tmp5.w = rsq_s(reg_tmp5.w);
            reg_tmp5 = mul_s(reg_tmp5, reg_tmp5.wwww);
            reg_tmp6.w = (reg_tmp14.zzzz + reg_tmp5.yyyy).w;
            reg_tmp13 = mul_s(reg_tmp5.yzxx, reg_tmp14.zxyy);
            reg_tmp13 = fma_s(-reg_tmp14.yzxx, reg_tmp5.zxyy, reg_tmp13);
            reg_tmp6.w = (reg_tmp13.xxxx + reg_tmp6).w;
            reg_tmp13.w = (reg_tmp5.zzzz).w;
            reg_tmp5.z = (reg_tmp13.xxxx).z;
            reg_tmp6.w = (uniforms.f[93].yyyy + reg_tmp6).w;
            reg_tmp14.w = (reg_tmp5.xxxx).w;
            reg_tmp5.x = (reg_tmp14.zzzz).x;
            conditional_code = lessThan(uniforms.f[94].zz, reg_tmp6.ww);
            reg_tmp6.x = (uniforms.f[93].yyyy).x;
            reg_tmp6.y = (-uniforms.f[93].yyyy).y;
            if (!conditional_code.x) {
                { jmp_to = 54u; break; }
            }
            reg_tmp7.xz = (reg_tmp13.wwyy + -reg_tmp14.yyww).xz;
            reg_tmp7.y = (reg_tmp14.xxxx + -reg_tmp13.zzzz).y;
            reg_tmp7.w = (reg_tmp6).w;
            reg_tmp6 = vec4(dot_s(reg_tmp7, reg_tmp7));
            reg_tmp6 = vec4(rsq_s(reg_tmp6.x));
            reg_tmp0 = mul_s(reg_tmp7, reg_tmp6);
        }
        case 54u: {
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_55_65() {
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    reg_tmp4.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_65_78() {
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    reg_tmp4.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp5.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp13.xyz);
    reg_tmp5.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp13.xyz);
    reg_tmp5.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp13.xyz);
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    reg_tmp11 = fma_s(reg_tmp1.wwww, reg_tmp5, reg_tmp11);
    return false;
}
bool sub_78_128() {
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    reg_tmp13.xyz = (vs_in_reg2).xyz;
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    if (uniforms.b[0]) {
        sub_83_101();
    } else {
        sub_101_109();
    }
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    {
        sub_0_19();
    }
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    vs_out_attr2 = -reg_tmp15;
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    if (all(conditional_code)) {
        sub_126_127();
    }
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_83_101() {
    reg_tmp7 = uniforms.f[93].xxxx;
    reg_tmp12 = uniforms.f[93].xxxx;
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    {
        sub_55_65();
    }
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    {
        sub_55_65();
    }
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    {
        sub_55_65();
    }
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    {
        sub_55_65();
    }
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    reg_tmp10 = reg_tmp7;
    return false;
}
bool sub_101_109() {
    reg_tmp7 = reg_tmp15;
    reg_tmp10.x = dot_s(uniforms.f[10], reg_tmp7);
    reg_tmp10.y = dot_s(uniforms.f[11], reg_tmp7);
    reg_tmp10.z = dot_s(uniforms.f[12], reg_tmp7);
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    reg_tmp12.x = dot_3(uniforms.f[10].xyz, reg_tmp14.xyz);
    reg_tmp12.y = dot_3(uniforms.f[11].xyz, reg_tmp14.xyz);
    reg_tmp12.z = dot_3(uniforms.f[12].xyz, reg_tmp14.xyz);
    return false;
}
bool sub_126_127() {
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_128_184() {
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    reg_tmp13.xyz = (vs_in_reg2).xyz;
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    if (uniforms.b[0]) {
        sub_133_151();
    } else {
        sub_151_162();
    }
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    reg_tmp13.x = dot_3(uniforms.f[90].xyz, reg_tmp11.xyz);
    reg_tmp13.y = dot_3(uniforms.f[91].xyz, reg_tmp11.xyz);
    reg_tmp13.z = dot_3(uniforms.f[92].xyz, reg_tmp11.xyz);
    {
        sub_19_55();
    }
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    vs_out_attr2 = -reg_tmp15;
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    if (all(conditional_code)) {
        sub_182_183();
    }
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_133_151() {
    reg_tmp7 = uniforms.f[93].xxxx;
    reg_tmp12 = uniforms.f[93].xxxx;
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    {
        sub_65_78();
    }
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    {
        sub_65_78();
    }
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    {
        sub_65_78();
    }
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    {
        sub_65_78();
    }
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    reg_tmp10 = reg_tmp7;
    return false;
}
bool sub_151_162() {
    reg_tmp7 = reg_tmp15;
    reg_tmp10.x = dot_s(uniforms.f[10], reg_tmp7);
    reg_tmp10.y = dot_s(uniforms.f[11], reg_tmp7);
    reg_tmp10.z = dot_s(uniforms.f[12], reg_tmp7);
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    reg_tmp12.x = dot_3(uniforms.f[10].xyz, reg_tmp14.xyz);
    reg_tmp12.y = dot_3(uniforms.f[11].xyz, reg_tmp14.xyz);
    reg_tmp12.z = dot_3(uniforms.f[12].xyz, reg_tmp14.xyz);
    reg_tmp11.x = dot_3(uniforms.f[10].xyz, reg_tmp13.xyz);
    reg_tmp11.y = dot_3(uniforms.f[11].xyz, reg_tmp13.xyz);
    reg_tmp11.z = dot_3(uniforms.f[12].xyz, reg_tmp13.xyz);
    return false;
}
bool sub_182_183() {
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_184_211() {
    reg_tmp0.xy = (uniforms.f[0].xxxx).xy;
    if (uniforms.b[2]) {
        sub_186_191();
    } else {
        sub_191_210();
    }
    return false;
}
bool sub_186_191() {
    {
        sub_251_259();
    }
    reg_tmp3.x = dot_s(uniforms.f[1].xywz, reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2].xywz, reg_tmp6);
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_191_210() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_194_200();
    } else {
        sub_200_209();
    }
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_194_200() {
    reg_tmp6 = reg_tmp10;
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    reg_tmp3.z = dot_s(uniforms.f[3], reg_tmp6);
    reg_tmp0.xy = (mul_s(uniforms.f[9].xyyy, reg_tmp3.zzzz)).xy;
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_200_209() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_201_205();
    } else {
        sub_205_208();
    }
    return false;
}
bool sub_201_205() {
    {
        sub_259_266();
    }
    reg_tmp3.x = dot_3(uniforms.f[1].xyz, reg_tmp6.xyz);
    reg_tmp3.y = dot_3(uniforms.f[2].xyz, reg_tmp6.xyz);
    reg_tmp3.z = dot_3(uniforms.f[3].xyz, reg_tmp6.xyz);
    return false;
}
bool sub_205_208() {
    {
        sub_266_272();
    }
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    return false;
}
bool sub_211_235() {
    reg_tmp0.xy = (uniforms.f[0].yyyy).xy;
    if (uniforms.b[3]) {
        sub_213_217();
    } else {
        sub_217_234();
    }
    return false;
}
bool sub_213_217() {
    {
        sub_251_259();
    }
    reg_tmp4.x = dot_s(uniforms.f[4].xywz, reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5].xywz, reg_tmp6);
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_217_234() {
    if (uniforms.b[5]) {
        sub_218_232();
    } else {
        sub_232_233();
    }
    return false;
}
bool sub_218_232() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_221_228();
    } else {
        sub_228_231();
    }
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_221_228() {
    reg_tmp6 = reg_tmp10;
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    reg_tmp4.z = dot_s(uniforms.f[6], reg_tmp6);
    reg_tmp6.w = rcp_s(reg_tmp4.z);
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    reg_tmp4.xy = (uniforms.f[9].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_228_231() {
    {
        sub_266_272();
    }
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    return false;
}
bool sub_232_233() {
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_235_251() {
    reg_tmp0.xy = (uniforms.f[0].zzzz).xy;
    if (uniforms.b[4]) {
        sub_237_241();
    } else {
        sub_241_250();
    }
    return false;
}
bool sub_237_241() {
    {
        sub_251_259();
    }
    reg_tmp5.x = dot_s(uniforms.f[7].xywz, reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8].xywz, reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_241_250() {
    if (uniforms.b[6]) {
        sub_242_248();
    } else {
        sub_248_249();
    }
    return false;
}
bool sub_242_248() {
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    {
        sub_266_272();
    }
    reg_tmp5.x = dot_s(uniforms.f[7], reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8], reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_248_249() {
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
bool sub_251_259() {
    conditional_code = equal(uniforms.f[93].yz, reg_tmp0.xy);
    if (all(not(conditional_code))) {
        sub_253_254();
    } else {
        sub_254_258();
    }
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_253_254() {
    reg_tmp6.xy = (vs_in_reg4.xyyy).xy;
    return false;
}
bool sub_254_258() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_255_256();
    } else {
        sub_256_257();
    }
    return false;
}
bool sub_255_256() {
    reg_tmp6.xy = (vs_in_reg5.xyyy).xy;
    return false;
}
bool sub_256_257() {
    reg_tmp6.xy = (vs_in_reg6.xyyy).xy;
    return false;
}
bool sub_259_266() {
    reg_tmp2 = -reg_tmp15;
    reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
    reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_266_272() {
    reg_tmp1 = reg_tmp14;
    reg_tmp2.w = dot_3(reg_tmp1.xyz, reg_tmp1.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp1 = mul_s(reg_tmp1, reg_tmp2.wwww);
    reg_tmp1 = mul_s(uniforms.f[94].xxxx, reg_tmp1);
    reg_tmp6.xy = (uniforms.f[94].xxxx + reg_tmp1.xyyy).xy;
    return false;
}
bool sub_272_4096() {
    if (uniforms.b[10]) {
        sub_273_275();
    } else {
        sub_275_277();
    }
    if (uniforms.b[1]) {
        sub_278_285();
    } else {
        sub_285_286();
    }
    vs_out_attr3 = reg_tmp2;
    {
        sub_184_211();
    }
    {
        sub_211_235();
    }
    {
        sub_235_251();
    }
    return true;
}
bool sub_273_275() {
    {
        sub_128_184();
    }
    return false;
}
bool sub_275_277() {
    {
        sub_78_128();
    }
    return false;
}
bool sub_278_285() {
    reg_tmp0 = vec4(dot_3(uniforms.f[83].xyz, reg_tmp12.xyz));
    reg_tmp0 = max(uniforms.f[93].xxxx, reg_tmp0);
    reg_tmp0 = mul_s(uniforms.f[84], reg_tmp0);
    reg_tmp0 = uniforms.f[85] + reg_tmp0;
    reg_tmp0.w = (uniforms.f[93].yyyy).w;
    reg_tmp1 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
    reg_tmp2 = mul_s(reg_tmp0, reg_tmp1);
    return false;
}
bool sub_285_286() {
    reg_tmp2 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
    return false;
}
// reference: 9D04A1EB3622DD53, D0293423BD9EA1E7
// shader: 8B30, 19F7816C4117CF8E

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) + (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor1.r) + (const_color[0].a) - 0.5, 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) - (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 7F10713B89B30A02, 19F7816C4117CF8E
// program: D0293423BD9EA1E7, B80FA1B7F97410CD, 19F7816C4117CF8E
// reference: BF76358E352A53CB, D9C174A4A54356AC
// shader: 8B30, 5FBCCF5F27F5A7C1

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) - (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 9B69AC991B4FCF91, 5FBCCF5F27F5A7C1
// program: D9C174A4A54356AC, 42937135801BAA7E, 5FBCCF5F27F5A7C1
// reference: F122CACE825F07BF, D9C174A4A54356AC
// shader: 8B30, 63B6ADAD25C2A518

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) - (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 9B69AC99E0AFBE28, 63B6ADAD25C2A518
// program: D9C174A4A54356AC, 42937135801BAA7E, 63B6ADAD25C2A518
// shader: 8B30, 47E4BEE6B3304AF3

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) + (texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (const_color[0].a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (texcolor2.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = (last_tex_env_out.rgb);
float alpha_output_5 = byteround(clamp((last_tex_env_out.a) * (const_color[5].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 88BE7793AC0D0138, 47E4BEE6B3304AF3
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 47E4BEE6B3304AF3
// reference: D3505EABE42F6922, E81D148B6EF003F8
// shader: 8B30, C580B429ECAF519A

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor1.r) + (texcolor0.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) + (texcolor1.rrr), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (const_color[2].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: B2FF021960ACB158, C580B429ECAF519A
// program: E81D148B6EF003F8, B80FA1B7F97410CD, C580B429ECAF519A
// reference: E447428B9CC42A9E, E81D148B6EF003F8
// reference: AA13BDCBE42F6922, E81D148B6EF003F8
// reference: AA13BDCB2BB17EEA, E81D148B6EF003F8
// reference: E447428B3622DD53, D0293423BD9EA1E7
// shader: 8B30, 4BA25B84A31C492A

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb) * (texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.r) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) + (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 2A7EAF81D974A6D5, 4BA25B84A31C492A
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 4BA25B84A31C492A
// reference: 2E99070D93C88DBA, CAB8B665DC444CE4
// shader: 8B30, 6B98A4CC666FCBCF

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 2F8F6701E28F10BC, 6B98A4CC666FCBCF
// program: D9C174A4A54356AC, 42937135801BAA7E, 6B98A4CC666FCBCF
// shader: 8B30, D1257B6267770D05

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 2F8F670112589B11, D1257B6267770D05
// program: D9C174A4A54356AC, 42937135801BAA7E, D1257B6267770D05
// shader: 8B30, D134C63316570D84

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].aaa);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 1F37784AB1F5E738, D134C63316570D84
// program: D9C174A4A54356AC, 42937135801BAA7E, D134C63316570D84
// reference: C9A148E3F7D5D02D, 26CF8128A3DDBB83
// shader: 8B30, 40FC95A67F54598B

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 1ECD60529604B05E, 40FC95A67F54598B
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 40FC95A67F54598B
// reference: BABA705AFE4CC844, E52C4E220978C964
// reference: 2A23FE70E7196AFC, 378438FF70532E82
// shader: 8B30, D69A3CB52F0E3495

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor1.g) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (texcolor1.rrr) + (const_color[2].rgb) * (vec3(1.0) - (texcolor1.rrr)), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 7E9ED75C4871C382, D69A3CB52F0E3495
// program: E81D148B6EF003F8, B80FA1B7F97410CD, D69A3CB52F0E3495
// shader: 8B30, B5CB613BFC4BC41C

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 1080747790D7673D, B5CB613BFC4BC41C
// program: E81D148B6EF003F8, B80FA1B7F97410CD, B5CB613BFC4BC41C
// reference: B67DEEB4839C524A, 502AB780D80D09C1
// shader: 8B30, 1B4DA8DA884D39A1

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp(min((texcolor0.rrr) + (texcolor0.ggg), vec3(1.0)) * (const_color[0].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor0.bbb) * (const_color[1].aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (vec3(1.0) - const_color[2].aaa) + (const_color[2].rgb) * (vec3(1.0) - (vec3(1.0) - const_color[2].aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((texcolor0.rgb) * (vec3(1.0) - const_color[4].aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (vec3(1.0) - const_color[4].aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 404553C09B17931E, 1B4DA8DA884D39A1
// program: 502AB780D80D09C1, B80FA1B7F97410CD, 1B4DA8DA884D39A1
// shader: 8B30, D2BD0C5FAA2AB273

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (const_color[1].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 4609680C4B8F999F, D2BD0C5FAA2AB273
// program: E81D148B6EF003F8, B80FA1B7F97410CD, D2BD0C5FAA2AB273
// shader: 8B30, F8FBCC791CAC22F2

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a) + (texcolor1.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (const_color[1].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 176EE9B7C22C87F7, F8FBCC791CAC22F2
// program: E81D148B6EF003F8, B80FA1B7F97410CD, F8FBCC791CAC22F2
// shader: 8B30, FEE7FD4C7FD3D731

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (const_color[1].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 4609680CA738729C, FEE7FD4C7FD3D731
// program: E81D148B6EF003F8, B80FA1B7F97410CD, FEE7FD4C7FD3D731
// shader: 8B30, 8633243B2123B710

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor1.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (texcolor1.aaa) + (texcolor0.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (const_color[2].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 7603EF8AF031590B, 8633243B2123B710
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 8633243B2123B710
// shader: 8B30, 39E142A8F1F39B96

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.aaa) + (texcolor1.rgb) * (vec3(1.0) - (rounded_primary_color.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (const_color[0].a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (const_color[1].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 849E5E57673D3307, 39E142A8F1F39B96
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 39E142A8F1F39B96
// reference: D4F4BEF91F680A00, FC9E10BE42F07103
// program: E81D148B6EF003F8, B80FA1B7F97410CD, FC9E10BE42F07103
// shader: 8B31, 1BDE5ABD20055F26

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_8();
bool sub_9_32();
bool sub_33_96();
bool sub_146_166();
bool sub_167_259();
bool sub_190_192();
bool sub_194_195();
bool sub_197_198();
bool sub_200_202();
bool sub_232_234();
bool sub_236_237();
bool sub_239_240();
bool sub_242_244();
bool sub_260_4096();
bool sub_287_288();
bool sub_288_289();

bool exec_shader() {
    sub_260_4096();
    return true;
}

bool sub_0_8() {
    address_registers.x = (ivec2(vs_in_reg0.zz)).x;
    reg_tmp10 = uniforms.f[0].xxxz;
    reg_tmp10.xy = (vs_in_reg0.xyyy).xy;
    reg_tmp11 = uniforms.f[0].xxxx;
    reg_tmp12 = uniforms.f[0].xxxx;
    reg_tmp13 = uniforms.f[0].zzzz;
    reg_tmp4 = uniforms.f[0].xxxx;
    reg_tmp5 = uniforms.f[0].xxxx;
    return false;
}
bool sub_9_32() {
    vs_out_attr0 = reg_tmp10;
    reg_tmp13 = mul_s(uniforms.f[82], reg_tmp13);
    vs_out_attr1 = reg_tmp13;
    reg_tmp11.y = (uniforms.f[0].zzzz + -reg_tmp11.yyyy).y;
    reg_tmp12.y = (uniforms.f[0].zzzz + -reg_tmp12.yyyy).y;
    reg_tmp14.y = (uniforms.f[81].wwww).y;
    reg_tmp14.x = (mul_s(uniforms.f[0].wwww, reg_tmp14.yyyy)).x;
    reg_tmp2.x = rcp_s(reg_tmp14.x);
    reg_tmp14.z = (reg_tmp2.xxxx).z;
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp11.xyyy).xy;
    reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    reg_tmp11.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp12.xyyy).xy;
    reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    reg_tmp12.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    vs_out_attr2 = reg_tmp11;
    vs_out_attr3 = reg_tmp12;
    return false;
}
bool sub_33_96() {
    reg_tmp6.xyz = (-reg_tmp0.xyzz).xyz;
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    reg_tmp7.xyz = vec3(rcp_s(uniforms.f[81].y));
    reg_tmp8.xyz = (fma_s(reg_tmp6.xyzz, reg_tmp7.xyzz, uniforms.f[0].yyyy)).xyz;
    reg_tmp7.xyz = (floor(reg_tmp8.xyzz)).xyz;
    reg_tmp6.xyz = (fma_s(reg_tmp7.xyzz, -uniforms.f[81].yyyy, reg_tmp6.xyzz)).xyz;
    reg_tmp6 = min(uniforms.f[81].xxxx, reg_tmp6);
    reg_tmp6 = max(-uniforms.f[81].xxxx, reg_tmp6);
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp6.xxxx, reg_tmp6.xxxx)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp6.xxxx)).y;
    reg_tmp4.x = (reg_tmp1.xxxx).x;
    reg_tmp5.x = (reg_tmp1.yyyy).x;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp6.yyyy, reg_tmp6.yyyy)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp6.yyyy)).y;
    reg_tmp4.y = (reg_tmp1.xxxx).y;
    reg_tmp5.y = (reg_tmp1.yyyy).y;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp6.zzzz, reg_tmp6.zzzz)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp6.zzzz)).y;
    reg_tmp4.z = (reg_tmp1.xxxx).z;
    reg_tmp5.z = (reg_tmp1.yyyy).z;
    reg_tmp2.x = (mul_s(reg_tmp4.yyyy, reg_tmp5.zzzz)).x;
    reg_tmp2.y = (mul_s(reg_tmp5.yyyy, reg_tmp5.zzzz)).y;
    reg_tmp6.x = (mul_s(reg_tmp4.yyyy, reg_tmp4.zzzz)).x;
    reg_tmp6.y = (reg_tmp5.zzzz).y;
    reg_tmp6.z = (mul_s(-reg_tmp5.yyyy, reg_tmp4.zzzz)).z;
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    reg_tmp7.x = (mul_s(-reg_tmp2.xxxx, reg_tmp4.xxxx)).x;
    reg_tmp7.x = (fma_s(reg_tmp5.yyyy, reg_tmp5.xxxx, reg_tmp7.xxxx)).x;
    reg_tmp7.y = (mul_s(reg_tmp4.zzzz, reg_tmp4.xxxx)).y;
    reg_tmp7.z = (mul_s(reg_tmp2.yyyy, reg_tmp4.xxxx)).z;
    reg_tmp7.z = (fma_s(reg_tmp4.yyyy, reg_tmp5.xxxx, reg_tmp7.zzzz)).z;
    reg_tmp7.w = (uniforms.f[0].xxxx).w;
    reg_tmp8.x = (mul_s(reg_tmp2.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp8.x = (fma_s(reg_tmp5.yyyy, reg_tmp4.xxxx, reg_tmp8.xxxx)).x;
    reg_tmp8.y = (mul_s(-reg_tmp4.zzzz, reg_tmp5.xxxx)).y;
    reg_tmp8.z = (mul_s(-reg_tmp2.yyyy, reg_tmp5.xxxx)).z;
    reg_tmp8.z = (fma_s(reg_tmp4.yyyy, reg_tmp4.xxxx, reg_tmp8.zzzz)).z;
    reg_tmp8.w = (uniforms.f[0].xxxx).w;
    reg_tmp9 = uniforms.f[0].xxxz;
    return false;
}
bool sub_146_166() {
    reg_tmp2 = uniforms.f[90];
    reg_tmp3 = uniforms.f[91];
    reg_tmp4 = uniforms.f[92];
    reg_tmp5 = uniforms.f[0].xxxz;
    reg_tmp6 = mul_s(uniforms.f[86].xxxx, reg_tmp2);
    reg_tmp6 = fma_s(reg_tmp3, uniforms.f[86].yyyy, reg_tmp6);
    reg_tmp6 = fma_s(reg_tmp4, uniforms.f[86].zzzz, reg_tmp6);
    reg_tmp6 = fma_s(reg_tmp5, uniforms.f[86].wwww, reg_tmp6);
    reg_tmp7 = mul_s(uniforms.f[87].xxxx, reg_tmp2);
    reg_tmp7 = fma_s(reg_tmp3, uniforms.f[87].yyyy, reg_tmp7);
    reg_tmp7 = fma_s(reg_tmp4, uniforms.f[87].zzzz, reg_tmp7);
    reg_tmp7 = fma_s(reg_tmp5, uniforms.f[87].wwww, reg_tmp7);
    reg_tmp8 = mul_s(uniforms.f[88].xxxx, reg_tmp2);
    reg_tmp8 = fma_s(reg_tmp3, uniforms.f[88].yyyy, reg_tmp8);
    reg_tmp8 = fma_s(reg_tmp4, uniforms.f[88].zzzz, reg_tmp8);
    reg_tmp8 = fma_s(reg_tmp5, uniforms.f[88].wwww, reg_tmp8);
    reg_tmp9 = mul_s(uniforms.f[89].xxxx, reg_tmp2);
    reg_tmp9 = fma_s(reg_tmp3, uniforms.f[89].yyyy, reg_tmp9);
    reg_tmp9 = fma_s(reg_tmp4, uniforms.f[89].zzzz, reg_tmp9);
    reg_tmp9 = fma_s(reg_tmp5, uniforms.f[89].wwww, reg_tmp9);
    return false;
}
bool sub_167_259() {
    reg_tmp2.x = rcp_s(uniforms.f[81].y);
    reg_tmp2.xy = (mul_s(uniforms.f[2 + address_registers.x].zwww, reg_tmp2.xxxx)).xy;
    reg_tmp2.xy = (uniforms.f[0].yyyy + reg_tmp2.xyyy).xy;
    reg_tmp3.xy = (floor(reg_tmp2.xyyy)).xy;
    reg_tmp2.xy = (mul_s(uniforms.f[81].yyyy, reg_tmp3.xyyy)).xy;
    reg_tmp2.xy = (uniforms.f[2 + address_registers.x].zwww + -reg_tmp2.xyyy).xy;
    reg_tmp0.xy = (min(uniforms.f[81].xxxx, -reg_tmp2.xyyy)).xy;
    reg_tmp0.xy = (max(-uniforms.f[81].xxxx, reg_tmp0.xyyy)).xy;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp0.xxxx, reg_tmp0.xxxx)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.xxxx)).y;
    reg_tmp5.x = (uniforms.f[5 + address_registers.x].wwww).x;
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_190_192();
    }
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_194_195();
    }
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_197_198();
    }
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_200_202();
    }
    reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    reg_tmp4.z = (uniforms.f[83].xxxx).z;
    reg_tmp4.w = (-uniforms.f[83].yyyy).w;
    reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[3 + address_registers.x].xyyy)).xy;
    reg_tmp4.z = (-uniforms.f[3 + address_registers.x].zzzz).z;
    reg_tmp4.w = (-uniforms.f[3 + address_registers.x].wwww).w;
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    reg_tmp11.xy = (reg_tmp5.xyyy).xy;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp0.yyyy, reg_tmp0.yyyy)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.yyyy)).y;
    reg_tmp5.x = (uniforms.f[6 + address_registers.x].wwww).x;
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_232_234();
    }
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_236_237();
    }
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_239_240();
    }
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_242_244();
    }
    reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    reg_tmp4.z = (uniforms.f[83].zzzz).z;
    reg_tmp4.w = (-uniforms.f[83].wwww).w;
    reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[4 + address_registers.x].xyyy)).xy;
    reg_tmp4.z = (-uniforms.f[4 + address_registers.x].zzzz).z;
    reg_tmp4.w = (-uniforms.f[4 + address_registers.x].wwww).w;
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    reg_tmp12.xy = (reg_tmp5.xyyy).xy;
    return false;
}
bool sub_190_192() {
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_194_195() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_197_198() {
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_200_202() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_232_234() {
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_236_237() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_239_240() {
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_242_244() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_260_4096() {
    {
        sub_0_8();
    }
    reg_tmp10.xy = (uniforms.f[84].xyyy + reg_tmp10.xyyy).xy;
    reg_tmp10.xy = (mul_s(uniforms.f[2 + address_registers.x].xyyy, reg_tmp10.xyyy)).xy;
    reg_tmp14 = reg_tmp10;
    reg_tmp0 = uniforms.f[7 + address_registers.x];
    {
        sub_33_96();
    }
    reg_tmp10.x = dot_s(reg_tmp14, reg_tmp6);
    reg_tmp10.y = dot_s(reg_tmp14, reg_tmp7);
    reg_tmp10.z = dot_s(reg_tmp14, reg_tmp8);
    reg_tmp10.w = dot_s(reg_tmp14, reg_tmp9);
    reg_tmp6 = uniforms.f[8 + address_registers.x];
    reg_tmp7 = uniforms.f[9 + address_registers.x];
    reg_tmp8 = uniforms.f[10 + address_registers.x];
    reg_tmp9 = uniforms.f[0].xxxz;
    reg_tmp6.w = (uniforms.f[5 + address_registers.x].xxxx).w;
    reg_tmp7.w = (uniforms.f[5 + address_registers.x].yyyy).w;
    reg_tmp8.w = (uniforms.f[5 + address_registers.x].zzzz).w;
    reg_tmp2.x = dot_s(reg_tmp10, reg_tmp6);
    reg_tmp2.y = dot_s(reg_tmp10, reg_tmp7);
    reg_tmp2.z = dot_s(reg_tmp10, reg_tmp8);
    reg_tmp2.w = dot_s(reg_tmp10, reg_tmp9);
    reg_tmp10 = reg_tmp2;
    reg_tmp3.xyz = (uniforms.f[5 + address_registers.x].xyzz).xyz;
    reg_tmp3.xyz = (uniforms.f[85].xyzz + -reg_tmp3.xyzz).xyz;
    reg_tmp4.x = dot_3(reg_tmp3.xyz, reg_tmp3.xyz);
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
    if (conditional_code.x) {
        sub_287_288();
    } else {
        sub_288_289();
    }
    reg_tmp3.xyz = (mul_s(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
    reg_tmp10.xyz = (fma_s(reg_tmp3.xyzz, uniforms.f[84].zzzz, reg_tmp10.xyzz)).xyz;
    {
        sub_146_166();
    }
    reg_tmp2 = reg_tmp10;
    reg_tmp10.x = dot_s(reg_tmp2, reg_tmp6);
    reg_tmp10.y = dot_s(reg_tmp2, reg_tmp7);
    reg_tmp10.z = dot_s(reg_tmp2, reg_tmp8);
    reg_tmp10.w = dot_s(reg_tmp2, reg_tmp9);
    reg_tmp2 = uniforms.f[1 + address_registers.x];
    reg_tmp3 = max(uniforms.f[0].xxxx, reg_tmp2);
    reg_tmp2 = min(uniforms.f[0].zzzz, reg_tmp3);
    reg_tmp13 = reg_tmp2;
    {
        sub_167_259();
    }
    {
        sub_9_32();
    }
    return true;
}
bool sub_287_288() {
    reg_tmp4.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_288_289() {
    reg_tmp4.x = rsq_s(reg_tmp4.x);
    return false;
}
// reference: E545D249E2A2ED89, 1BDE5ABD20055F26
// shader: 8DD9, 082670B4222015B2

layout(triangles) in;
layout(triangle_strip, max_vertices = 3) out;

out vec4 primary_color;
out vec2 texcoord0;
out vec2 texcoord1;
out vec2 texcoord2;
out float texcoord0_w;
out vec4 normquat;
out vec3 view;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

in vec4 vs_out_attr0[];
in vec4 vs_out_attr1[];
in vec4 vs_out_attr2[];
in vec4 vs_out_attr3[];
struct Vertex {
    vec4 attributes[4];
};

vec4 GetVertexQuaternion(Vertex vtx) {
    return vec4(0.0, 0.0, 0.0, 0.0);
}

void EmitVtx(Vertex vtx, bool quats_opposite) {
    vec4 vtx_pos = vec4(vtx.attributes[0].x, vtx.attributes[0].y, vtx.attributes[0].z, vtx.attributes[0].w);
    gl_Position = vtx_pos;
#if !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)
    gl_ClipDistance[0] = -vtx_pos.z;
    gl_ClipDistance[1] = dot(clip_coef, vtx_pos);
#endif // !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)

    vec4 vtx_quat = GetVertexQuaternion(vtx);
    normquat = mix(vtx_quat, -vtx_quat, bvec4(quats_opposite));

    vec4 vtx_color = vec4(vtx.attributes[1].x, vtx.attributes[1].y, vtx.attributes[1].z, vtx.attributes[1].w);
    primary_color = min(abs(vtx_color), vec4(1.0));

    texcoord0 = vec2(vtx.attributes[2].x, vtx.attributes[2].y);
    texcoord1 = vec2(vtx.attributes[3].x, vtx.attributes[3].y);

    texcoord0_w = 0.0;
    view = vec3(0.0, 0.0, 0.0);
    texcoord2 = vec2(0.0, 0.0);

    EmitVertex();
}

bool AreQuaternionsOpposite(vec4 qa, vec4 qb) {
    return (dot(qa, qb) < 0.0);
}

void EmitPrim(Vertex vtx0, Vertex vtx1, Vertex vtx2) {
    EmitVtx(vtx0, false);
    EmitVtx(vtx1, AreQuaternionsOpposite(GetVertexQuaternion(vtx0), GetVertexQuaternion(vtx1)));
    EmitVtx(vtx2, AreQuaternionsOpposite(GetVertexQuaternion(vtx0), GetVertexQuaternion(vtx2)));
    EndPrimitive();
}

void main() {
    Vertex prim_buffer[3];
    prim_buffer[0].attributes = vec4[4](vs_out_attr0[0], vs_out_attr1[0], vs_out_attr2[0], vs_out_attr3[0]);
    prim_buffer[1].attributes = vec4[4](vs_out_attr0[1], vs_out_attr1[1], vs_out_attr2[1], vs_out_attr3[1]);
    prim_buffer[2].attributes = vec4[4](vs_out_attr0[2], vs_out_attr1[2], vs_out_attr2[2], vs_out_attr3[2]);
    EmitPrim(prim_buffer[0], prim_buffer[1], prim_buffer[2]);
}
// reference: A55C6948CCF76B42, 082670B4222015B2
// shader: 8B30, DBA0F8FE46AD8D9B

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.r);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_2 = byteround(clamp((vec3(1.0) - combiner_buffer.rgb) * (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 703709193E737D07, DBA0F8FE46AD8D9B
// program: 1BDE5ABD20055F26, 082670B4222015B2, DBA0F8FE46AD8D9B
// reference: 519CD67D995A097A, D9C174A4A54356AC
// shader: 8B30, 47A8279A60685F27

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((vec3(1.0) - combiner_buffer.rgb) * (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 5F0AA39F3D41FA2C, 47A8279A60685F27
// program: D9C174A4A54356AC, 42937135801BAA7E, 47A8279A60685F27
// reference: 1FC8293DC116CE4F, D9C174A4A54356AC
// reference: 5F0AA39F650CF7BC, 47A8279A60685F27
// reference: 73EE4218AC306A2F, E81D148B6EF003F8
// reference: 3DBABD58D4DB2993, E81D148B6EF003F8
// reference: 3DBABD581B453E5B, E81D148B6EF003F8
// reference: 73EE421806D69DE2, D0293423BD9EA1E7
// reference: 519CD67D05DE137A, D9C174A4A54356AC
// reference: 1FC8293DB2AB470E, D9C174A4A54356AC
// reference: 58970D47B36812FB, 502AB780D80D09C1
// shader: 8B31, 5E28DB645EED49B7

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;
out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_6();
bool sub_6_53();
bool sub_21_25();
bool sub_51_52();
bool sub_53_4096();

bool exec_shader() {
    sub_53_4096();
    return true;
}

bool sub_0_6() {
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    return false;
}
bool sub_6_53() {
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    reg_tmp7 = uniforms.f[93].xxxx;
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    {
        sub_0_6();
    }
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    {
        sub_0_6();
    }
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    if (conditional_code.x) {
        sub_0_6();
    }
    if (uniforms.b[11]) {
        sub_21_25();
    }
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    reg_tmp10 = reg_tmp7;
    reg_tmp6.y = (-uniforms.f[83].wwww + reg_tmp10.yyyy).y;
    reg_tmp9.xyz = (uniforms.f[83].xyzz).xyz;
    reg_tmp7.x = dot_s(reg_tmp9.xyzz, reg_tmp9.xyzz);
    reg_tmp7.x = rsq_s(reg_tmp7.x);
    reg_tmp7.xyz = (mul_s(reg_tmp9.xyzz, reg_tmp7.xxxx)).xyz;
    reg_tmp8.y = rcp_s(-reg_tmp7.y);
    reg_tmp8.y = (mul_s(reg_tmp6.yyyy, reg_tmp8.yyyy)).y;
    reg_tmp7.xyz = (mul_s(reg_tmp7.xyzz, reg_tmp8.yyyy)).xyz;
    reg_tmp10.xyz = (reg_tmp10.xyzz + reg_tmp7.xyzz).xyz;
    reg_tmp10.y = (uniforms.f[94].xxxx + reg_tmp10.yyyy).y;
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    vs_out_attr1 = uniforms.f[93].xxxx;
    vs_out_attr2 = reg_tmp15;
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    if (all(conditional_code)) {
        sub_51_52();
    }
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_21_25() {
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    if (conditional_code.y) {
        sub_0_6();
    }
    return false;
}
bool sub_51_52() {
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_53_4096() {
    {
        sub_6_53();
    }
    vs_out_attr4 = uniforms.f[93].xxxx;
    vs_out_attr5 = uniforms.f[93].xxxx;
    vs_out_attr6 = uniforms.f[93].xxxx;
    vs_out_attr3 = uniforms.f[93].yyyy;
    return true;
}
// reference: 9FD258F1D4C1BDAA, 5E28DB645EED49B7
// shader: 8B30, C2EEBEAE0D7F3560

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = (const_color[0].a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = (last_tex_env_out.rgb);
float alpha_output_5 = (const_color[5].r);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 7E0CA6739081C321, C2EEBEAE0D7F3560
// program: 5E28DB645EED49B7, B80FA1B7F97410CD, C2EEBEAE0D7F3560
// reference: 40A37A2A08FBB448, 35CCCCDE75E2FF83
// shader: 8B31, A40B5D829674D1F8

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;
out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_19();
bool sub_19_29();
bool sub_29_51();
bool sub_51_65();
bool sub_65_116();
bool sub_88_92();
bool sub_114_115();
bool sub_116_156();
bool sub_133_137();
bool sub_154_155();
bool sub_156_183();
bool sub_158_163();
bool sub_163_182();
bool sub_166_172();
bool sub_172_181();
bool sub_173_177();
bool sub_177_180();
bool sub_183_207();
bool sub_185_189();
bool sub_189_206();
bool sub_190_204();
bool sub_193_200();
bool sub_200_203();
bool sub_204_205();
bool sub_207_223();
bool sub_209_213();
bool sub_213_222();
bool sub_214_220();
bool sub_220_221();
bool sub_223_231();
bool sub_225_226();
bool sub_226_230();
bool sub_227_228();
bool sub_228_229();
bool sub_231_238();
bool sub_238_244();
bool sub_244_288();
bool sub_264_270();
bool sub_271_278();
bool sub_279_287();
bool sub_288_4096();
bool sub_289_291();
bool sub_291_293();
bool sub_294_296();
bool sub_296_298();

bool exec_shader() {
    sub_288_4096();
    return true;
}

bool sub_0_19() {
    uint jmp_to = 0u;
    while (true) {
        switch (jmp_to) {
        case 0u: {
            reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
            reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
            reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
            reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
            reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
            reg_tmp6.x = rsq_s(reg_tmp6.x);
            reg_tmp7.x = rsq_s(reg_tmp7.x);
            reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            reg_tmp0 = uniforms.f[93].yxxx;
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            reg_tmp4 = mul_s(uniforms.f[94].xxxx, reg_tmp4);
            conditional_code = greaterThanEqual(uniforms.f[93].xx, reg_tmp4.xx);
            reg_tmp4 = vec4(rsq_s(reg_tmp4.x));
            reg_tmp5 = mul_s(uniforms.f[94].xxxx, reg_tmp14);
            if (conditional_code.x) {
                { jmp_to = 18u; break; }
            }
            reg_tmp0.z = rcp_s(reg_tmp4.x);
            reg_tmp0.xy = (mul_s(reg_tmp5, reg_tmp4)).xy;
        }
        case 18u: {
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_19_29() {
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    reg_tmp4.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_29_51() {
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    reg_tmp3.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp3.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp3.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp12);
    reg_tmp3.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp13.xyz);
    reg_tmp3.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp13.xyz);
    reg_tmp3.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp13.xyz);
    reg_tmp11 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp11);
    reg_tmp3.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp5.xyz);
    reg_tmp3.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp5.xyz);
    reg_tmp3.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp5.xyz);
    reg_tmp9 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp9);
    reg_tmp3.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp6.xyz);
    reg_tmp3.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp6.xyz);
    reg_tmp3.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp6.xyz);
    reg_tmp8 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp8);
    return false;
}
bool sub_51_65() {
    reg_tmp0.xyz = (mul_s(reg_tmp9.yzxx, reg_tmp8.zxyy)).xyz;
    reg_tmp0.xyz = (fma_s(-reg_tmp8.yzxx, reg_tmp9.zxyy, reg_tmp0)).xyz;
    reg_tmp1 = uniforms.f[83];
    reg_tmp2.x = dot_s(reg_tmp1.xyzz, reg_tmp1.xyzz);
    reg_tmp2.x = rsq_s(reg_tmp2.x);
    reg_tmp2.xyz = (mul_s(reg_tmp1.xyzz, reg_tmp2.xxxx)).xyz;
    reg_tmp1.x = dot_3(reg_tmp2.xyz, reg_tmp8.xyz);
    reg_tmp1.y = dot_3(reg_tmp2.xyz, reg_tmp0.xyz);
    reg_tmp1.z = dot_3(reg_tmp2.xyz, reg_tmp9.xyz);
    reg_tmp2.x = dot_s(reg_tmp1.xyzz, reg_tmp1.xyzz);
    reg_tmp2.x = rsq_s(reg_tmp2.x);
    reg_tmp2.xyz = (mul_s(reg_tmp1.xyzz, reg_tmp2.xxxx)).xyz;
    reg_tmp2.w = (uniforms.f[93].yyyy).w;
    vs_out_attr2 = reg_tmp2;
    return false;
}
bool sub_65_116() {
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    reg_tmp13.xyz = (vs_in_reg2).xyz;
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    reg_tmp5 = uniforms.f[93].xxyy;
    reg_tmp6 = uniforms.f[93].yxxy;
    reg_tmp7 = uniforms.f[93].xxxx;
    reg_tmp12 = uniforms.f[93].xxxx;
    reg_tmp11 = uniforms.f[93].xxxx;
    reg_tmp9 = uniforms.f[93].xxxx;
    reg_tmp8 = uniforms.f[93].xxxx;
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    {
        sub_29_51();
    }
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    {
        sub_29_51();
    }
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    if (conditional_code.x) {
        sub_29_51();
    }
    if (uniforms.b[11]) {
        sub_88_92();
    }
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    reg_tmp10 = reg_tmp7;
    reg_tmp13.x = dot_3(uniforms.f[90].xyz, reg_tmp11.xyz);
    reg_tmp13.y = dot_3(uniforms.f[91].xyz, reg_tmp11.xyz);
    reg_tmp13.z = dot_3(uniforms.f[92].xyz, reg_tmp11.xyz);
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    {
        sub_51_65();
    }
    vs_out_attr1 = uniforms.f[93].xxxy;
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    if (all(conditional_code)) {
        sub_114_115();
    }
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_88_92() {
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    if (conditional_code.y) {
        sub_29_51();
    }
    return false;
}
bool sub_114_115() {
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_116_156() {
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    reg_tmp7 = uniforms.f[93].xxxx;
    reg_tmp12 = uniforms.f[93].xxxx;
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    {
        sub_19_29();
    }
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    {
        sub_19_29();
    }
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    if (conditional_code.x) {
        sub_19_29();
    }
    if (uniforms.b[11]) {
        sub_133_137();
    }
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    reg_tmp10 = reg_tmp7;
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    {
        sub_0_19();
    }
    vs_out_attr2 = -reg_tmp15;
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    if (all(conditional_code)) {
        sub_154_155();
    }
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_133_137() {
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    if (conditional_code.y) {
        sub_19_29();
    }
    return false;
}
bool sub_154_155() {
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_156_183() {
    reg_tmp0.xy = (uniforms.f[0].xxxx).xy;
    if (uniforms.b[2]) {
        sub_158_163();
    } else {
        sub_163_182();
    }
    return false;
}
bool sub_158_163() {
    {
        sub_223_231();
    }
    reg_tmp3.x = dot_s(uniforms.f[1].xywz, reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2].xywz, reg_tmp6);
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_163_182() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_166_172();
    } else {
        sub_172_181();
    }
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_166_172() {
    reg_tmp6 = reg_tmp10;
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    reg_tmp3.z = dot_s(uniforms.f[3], reg_tmp6);
    reg_tmp0.xy = (mul_s(uniforms.f[9].xyyy, reg_tmp3.zzzz)).xy;
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_172_181() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_173_177();
    } else {
        sub_177_180();
    }
    return false;
}
bool sub_173_177() {
    {
        sub_231_238();
    }
    reg_tmp3.x = dot_3(uniforms.f[1].xyz, reg_tmp6.xyz);
    reg_tmp3.y = dot_3(uniforms.f[2].xyz, reg_tmp6.xyz);
    reg_tmp3.z = dot_3(uniforms.f[3].xyz, reg_tmp6.xyz);
    return false;
}
bool sub_177_180() {
    {
        sub_238_244();
    }
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    return false;
}
bool sub_183_207() {
    reg_tmp0.xy = (uniforms.f[0].yyyy).xy;
    if (uniforms.b[3]) {
        sub_185_189();
    } else {
        sub_189_206();
    }
    return false;
}
bool sub_185_189() {
    {
        sub_223_231();
    }
    reg_tmp4.x = dot_s(uniforms.f[4].xywz, reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5].xywz, reg_tmp6);
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_189_206() {
    if (uniforms.b[5]) {
        sub_190_204();
    } else {
        sub_204_205();
    }
    return false;
}
bool sub_190_204() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_193_200();
    } else {
        sub_200_203();
    }
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_193_200() {
    reg_tmp6 = reg_tmp10;
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    reg_tmp4.z = dot_s(uniforms.f[6], reg_tmp6);
    reg_tmp6.w = rcp_s(reg_tmp4.z);
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    reg_tmp4.xy = (uniforms.f[9].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_200_203() {
    {
        sub_238_244();
    }
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    return false;
}
bool sub_204_205() {
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_207_223() {
    reg_tmp0.xy = (uniforms.f[0].zzzz).xy;
    if (uniforms.b[4]) {
        sub_209_213();
    } else {
        sub_213_222();
    }
    return false;
}
bool sub_209_213() {
    {
        sub_223_231();
    }
    reg_tmp5.x = dot_s(uniforms.f[7].xywz, reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8].xywz, reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_213_222() {
    if (uniforms.b[6]) {
        sub_214_220();
    } else {
        sub_220_221();
    }
    return false;
}
bool sub_214_220() {
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    {
        sub_238_244();
    }
    reg_tmp5.x = dot_s(uniforms.f[7], reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8], reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_220_221() {
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
bool sub_223_231() {
    conditional_code = equal(uniforms.f[93].yz, reg_tmp0.xy);
    if (all(not(conditional_code))) {
        sub_225_226();
    } else {
        sub_226_230();
    }
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_225_226() {
    reg_tmp6.xy = (vs_in_reg4.xyyy).xy;
    return false;
}
bool sub_226_230() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_227_228();
    } else {
        sub_228_229();
    }
    return false;
}
bool sub_227_228() {
    reg_tmp6.xy = (vs_in_reg5.xyyy).xy;
    return false;
}
bool sub_228_229() {
    reg_tmp6.xy = (vs_in_reg6.xyyy).xy;
    return false;
}
bool sub_231_238() {
    reg_tmp2 = -reg_tmp15;
    reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
    reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_238_244() {
    reg_tmp1 = reg_tmp14;
    reg_tmp2.w = dot_3(reg_tmp1.xyz, reg_tmp1.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp1 = mul_s(reg_tmp1, reg_tmp2.wwww);
    reg_tmp1 = mul_s(uniforms.f[94].xxxx, reg_tmp1);
    reg_tmp6.xy = (uniforms.f[94].xxxx + reg_tmp1.xyyy).xy;
    return false;
}
bool sub_244_288() {
    reg_tmp1.xyz = (uniforms.f[93].xxyx).xyz;
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    reg_tmp14.w = (uniforms.f[93].xxxx).w;
    reg_tmp8 = reg_tmp14;
    reg_tmp14.x = dot_s(reg_tmp8, reg_tmp8);
    reg_tmp14.x = rsq_s(reg_tmp14.x);
    reg_tmp14 = mul_s(reg_tmp8, reg_tmp14.xxxx);
    reg_tmp8 = uniforms.f[83];
    reg_tmp6.x = dot_3(uniforms.f[90].xyz, reg_tmp8.xyz);
    reg_tmp6.y = dot_3(uniforms.f[91].xyz, reg_tmp8.xyz);
    reg_tmp6.z = dot_3(uniforms.f[92].xyz, reg_tmp8.xyz);
    reg_tmp8.xyz = (reg_tmp6.xyzz + reg_tmp1.xyzz).xyz;
    reg_tmp8.w = (uniforms.f[93].xxxx).w;
    reg_tmp0.x = dot_s(reg_tmp8, reg_tmp8);
    reg_tmp0.x = rsq_s(reg_tmp0.x);
    reg_tmp0 = mul_s(reg_tmp8, reg_tmp0.xxxx);
    reg_tmp2 = uniforms.f[93].xxxx;
    if (uniforms.b[9]) {
        sub_264_270();
    }
    if (uniforms.b[7]) {
        sub_271_278();
    }
    if (uniforms.b[8]) {
        sub_279_287();
    }
    vs_out_attr3 = reg_tmp2;
    return false;
}
bool sub_264_270() {
    reg_tmp8.x = dot_3(reg_tmp14.xyz, -reg_tmp6.xyz);
    reg_tmp8.y = dot_3(reg_tmp1.xyz, -reg_tmp6.xyz);
    reg_tmp8 = max(uniforms.f[93].xxxx, reg_tmp8);
    reg_tmp8.y = (mul_s(uniforms.f[94].xxxx, reg_tmp8.yyyy)).y;
    reg_tmp8.y = (uniforms.f[94].xxxx + reg_tmp8.yyyy).y;
    reg_tmp2.y = (mul_s(reg_tmp8.xxxx, reg_tmp8.yyyy)).y;
    return false;
}
bool sub_271_278() {
    reg_tmp9.z = dot_3(reg_tmp14.xyz, reg_tmp0.xyz);
    reg_tmp9.z = (max(uniforms.f[93].xxxx, reg_tmp9.zzzz)).z;
    reg_tmp9.z = (min(uniforms.f[93].yyyy, reg_tmp9.zzzz)).z;
    reg_tmp9.z = log2(reg_tmp9.z);
    reg_tmp9.z = (mul_s(uniforms.f[82].zzzz, reg_tmp9.zzzz)).z;
    reg_tmp9.z = exp2(reg_tmp9.z);
    reg_tmp2.z = (mul_s(uniforms.f[82].wwww, reg_tmp9.zzzz)).z;
    return false;
}
bool sub_279_287() {
    reg_tmp9.x = dot_3(reg_tmp14.xyz, reg_tmp1.xyz);
    reg_tmp9.x = (max(uniforms.f[93].xxxx, reg_tmp9.xxxx)).x;
    reg_tmp9.x = (min(uniforms.f[93].yyyy, reg_tmp9.xxxx)).x;
    reg_tmp9.x = (uniforms.f[93].yyyy + -reg_tmp9.xxxx).x;
    reg_tmp9.x = log2(reg_tmp9.x);
    reg_tmp9.x = (mul_s(uniforms.f[82].xxxx, reg_tmp9.xxxx)).x;
    reg_tmp9.x = exp2(reg_tmp9.x);
    reg_tmp2.w = (mul_s(uniforms.f[82].yyyy, reg_tmp9.xxxx)).w;
    return false;
}
bool sub_288_4096() {
    if (uniforms.b[10]) {
        sub_289_291();
    } else {
        sub_291_293();
    }
    if (uniforms.b[1]) {
        sub_294_296();
    } else {
        sub_296_298();
    }
    {
        sub_156_183();
    }
    {
        sub_183_207();
    }
    {
        sub_207_223();
    }
    return true;
}
bool sub_289_291() {
    {
        sub_65_116();
    }
    return false;
}
bool sub_291_293() {
    {
        sub_116_156();
    }
    return false;
}
bool sub_294_296() {
    {
        sub_244_288();
    }
    return false;
}
bool sub_296_298() {
    vs_out_attr3 = uniforms.f[93].yyyy;
    return false;
}
// reference: 7189F773C418C5C3, A40B5D829674D1F8
// shader: 8B30, 1CBA1DD1EAE2F663

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = 2.0 * (texcolor2).rgb - 1.0;
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(normal, normalize(view))));
refl_value.g = (lut_scale_rg * LookupLightingLUTSigned(5, dot(normal, normalize(view))));
refl_value.b = (lut_scale_rb * LookupLightingLUTSigned(4, dot(normal, normalize(view))));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor1.rgb) * (vec3(1.0) - const_color[0].aaa) + (const_color[0].rgb) * (vec3(1.0) - (vec3(1.0) - const_color[0].aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (texcolor1.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_1 = byteround(clamp((texcolor0.rgb) + (last_tex_env_out.rgb) - vec3(0.5), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (combiner_buffer.rgb) - vec3(0.5), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((secondary_fragment_color.r) * (1.0 - const_color[2].a) + (secondary_fragment_color.b) * (1.0 - (1.0 - const_color[2].a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_3 = (texcolor1.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((secondary_fragment_color.ggg) * (last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 00F48736B45D4053, 1CBA1DD1EAE2F663
// program: A40B5D829674D1F8, B80FA1B7F97410CD, 1CBA1DD1EAE2F663
// reference: 3FDD0833736D91B7, A40B5D829674D1F8
// shader: 8B30, 6A08A79BE3FAC39D

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D4F4BEF95B3A33D3, 6A08A79BE3FAC39D
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 6A08A79BE3FAC39D
// reference: AA13BDCBC488EDAB, E81D148B6EF003F8
// program: D0293423BD9EA1E7, B80FA1B7F97410CD, 10AAC2A3349D1A7E
// reference: AA13BDCB81578927, D0293423BD9EA1E7
// shader: 8B31, 49AB6B882020674A

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_8();
bool sub_9_32();
bool sub_33_96();
bool sub_97_113();
bool sub_146_166();
bool sub_167_259();
bool sub_190_192();
bool sub_194_195();
bool sub_197_198();
bool sub_200_202();
bool sub_232_234();
bool sub_236_237();
bool sub_239_240();
bool sub_242_244();
bool sub_260_4096();
bool sub_280_281();
bool sub_281_282();

bool exec_shader() {
    sub_260_4096();
    return true;
}

bool sub_0_8() {
    address_registers.x = (ivec2(vs_in_reg0.zz)).x;
    reg_tmp10 = uniforms.f[0].xxxz;
    reg_tmp10.xy = (vs_in_reg0.xyyy).xy;
    reg_tmp11 = uniforms.f[0].xxxx;
    reg_tmp12 = uniforms.f[0].xxxx;
    reg_tmp13 = uniforms.f[0].zzzz;
    reg_tmp4 = uniforms.f[0].xxxx;
    reg_tmp5 = uniforms.f[0].xxxx;
    return false;
}
bool sub_9_32() {
    vs_out_attr0 = reg_tmp10;
    reg_tmp13 = mul_s(uniforms.f[82], reg_tmp13);
    vs_out_attr1 = reg_tmp13;
    reg_tmp11.y = (uniforms.f[0].zzzz + -reg_tmp11.yyyy).y;
    reg_tmp12.y = (uniforms.f[0].zzzz + -reg_tmp12.yyyy).y;
    reg_tmp14.y = (uniforms.f[81].wwww).y;
    reg_tmp14.x = (mul_s(uniforms.f[0].wwww, reg_tmp14.yyyy)).x;
    reg_tmp2.x = rcp_s(reg_tmp14.x);
    reg_tmp14.z = (reg_tmp2.xxxx).z;
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp11.xyyy).xy;
    reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    reg_tmp11.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp12.xyyy).xy;
    reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    reg_tmp12.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    vs_out_attr2 = reg_tmp11;
    vs_out_attr3 = reg_tmp12;
    return false;
}
bool sub_33_96() {
    reg_tmp6.xyz = (-reg_tmp0.xyzz).xyz;
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    reg_tmp7.xyz = vec3(rcp_s(uniforms.f[81].y));
    reg_tmp8.xyz = (fma_s(reg_tmp6.xyzz, reg_tmp7.xyzz, uniforms.f[0].yyyy)).xyz;
    reg_tmp7.xyz = (floor(reg_tmp8.xyzz)).xyz;
    reg_tmp6.xyz = (fma_s(reg_tmp7.xyzz, -uniforms.f[81].yyyy, reg_tmp6.xyzz)).xyz;
    reg_tmp6 = min(uniforms.f[81].xxxx, reg_tmp6);
    reg_tmp6 = max(-uniforms.f[81].xxxx, reg_tmp6);
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp6.xxxx, reg_tmp6.xxxx)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp6.xxxx)).y;
    reg_tmp4.x = (reg_tmp1.xxxx).x;
    reg_tmp5.x = (reg_tmp1.yyyy).x;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp6.yyyy, reg_tmp6.yyyy)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp6.yyyy)).y;
    reg_tmp4.y = (reg_tmp1.xxxx).y;
    reg_tmp5.y = (reg_tmp1.yyyy).y;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp6.zzzz, reg_tmp6.zzzz)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp6.zzzz)).y;
    reg_tmp4.z = (reg_tmp1.xxxx).z;
    reg_tmp5.z = (reg_tmp1.yyyy).z;
    reg_tmp2.x = (mul_s(reg_tmp4.yyyy, reg_tmp5.zzzz)).x;
    reg_tmp2.y = (mul_s(reg_tmp5.yyyy, reg_tmp5.zzzz)).y;
    reg_tmp6.x = (mul_s(reg_tmp4.yyyy, reg_tmp4.zzzz)).x;
    reg_tmp6.y = (reg_tmp5.zzzz).y;
    reg_tmp6.z = (mul_s(-reg_tmp5.yyyy, reg_tmp4.zzzz)).z;
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    reg_tmp7.x = (mul_s(-reg_tmp2.xxxx, reg_tmp4.xxxx)).x;
    reg_tmp7.x = (fma_s(reg_tmp5.yyyy, reg_tmp5.xxxx, reg_tmp7.xxxx)).x;
    reg_tmp7.y = (mul_s(reg_tmp4.zzzz, reg_tmp4.xxxx)).y;
    reg_tmp7.z = (mul_s(reg_tmp2.yyyy, reg_tmp4.xxxx)).z;
    reg_tmp7.z = (fma_s(reg_tmp4.yyyy, reg_tmp5.xxxx, reg_tmp7.zzzz)).z;
    reg_tmp7.w = (uniforms.f[0].xxxx).w;
    reg_tmp8.x = (mul_s(reg_tmp2.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp8.x = (fma_s(reg_tmp5.yyyy, reg_tmp4.xxxx, reg_tmp8.xxxx)).x;
    reg_tmp8.y = (mul_s(-reg_tmp4.zzzz, reg_tmp5.xxxx)).y;
    reg_tmp8.z = (mul_s(-reg_tmp2.yyyy, reg_tmp5.xxxx)).z;
    reg_tmp8.z = (fma_s(reg_tmp4.yyyy, reg_tmp4.xxxx, reg_tmp8.zzzz)).z;
    reg_tmp8.w = (uniforms.f[0].xxxx).w;
    reg_tmp9 = uniforms.f[0].xxxz;
    return false;
}
bool sub_97_113() {
    reg_tmp6.x = (uniforms.f[90].xxxx).x;
    reg_tmp6.y = (uniforms.f[91].xxxx).y;
    reg_tmp6.z = (uniforms.f[92].xxxx).z;
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    reg_tmp7.x = (uniforms.f[90].yyyy).x;
    reg_tmp7.y = (uniforms.f[91].yyyy).y;
    reg_tmp7.z = (uniforms.f[92].yyyy).z;
    reg_tmp7.w = (uniforms.f[0].xxxx).w;
    reg_tmp8.x = (uniforms.f[90].zzzz).x;
    reg_tmp8.y = (uniforms.f[91].zzzz).y;
    reg_tmp8.z = (uniforms.f[92].zzzz).z;
    reg_tmp8.w = (uniforms.f[0].xxxx).w;
    reg_tmp9.x = (uniforms.f[90].wwww).x;
    reg_tmp9.y = (uniforms.f[91].wwww).y;
    reg_tmp9.z = (uniforms.f[92].wwww).z;
    reg_tmp9.w = (uniforms.f[0].zzzz).w;
    return false;
}
bool sub_146_166() {
    reg_tmp2 = uniforms.f[90];
    reg_tmp3 = uniforms.f[91];
    reg_tmp4 = uniforms.f[92];
    reg_tmp5 = uniforms.f[0].xxxz;
    reg_tmp6 = mul_s(uniforms.f[86].xxxx, reg_tmp2);
    reg_tmp6 = fma_s(reg_tmp3, uniforms.f[86].yyyy, reg_tmp6);
    reg_tmp6 = fma_s(reg_tmp4, uniforms.f[86].zzzz, reg_tmp6);
    reg_tmp6 = fma_s(reg_tmp5, uniforms.f[86].wwww, reg_tmp6);
    reg_tmp7 = mul_s(uniforms.f[87].xxxx, reg_tmp2);
    reg_tmp7 = fma_s(reg_tmp3, uniforms.f[87].yyyy, reg_tmp7);
    reg_tmp7 = fma_s(reg_tmp4, uniforms.f[87].zzzz, reg_tmp7);
    reg_tmp7 = fma_s(reg_tmp5, uniforms.f[87].wwww, reg_tmp7);
    reg_tmp8 = mul_s(uniforms.f[88].xxxx, reg_tmp2);
    reg_tmp8 = fma_s(reg_tmp3, uniforms.f[88].yyyy, reg_tmp8);
    reg_tmp8 = fma_s(reg_tmp4, uniforms.f[88].zzzz, reg_tmp8);
    reg_tmp8 = fma_s(reg_tmp5, uniforms.f[88].wwww, reg_tmp8);
    reg_tmp9 = mul_s(uniforms.f[89].xxxx, reg_tmp2);
    reg_tmp9 = fma_s(reg_tmp3, uniforms.f[89].yyyy, reg_tmp9);
    reg_tmp9 = fma_s(reg_tmp4, uniforms.f[89].zzzz, reg_tmp9);
    reg_tmp9 = fma_s(reg_tmp5, uniforms.f[89].wwww, reg_tmp9);
    return false;
}
bool sub_167_259() {
    reg_tmp2.x = rcp_s(uniforms.f[81].y);
    reg_tmp2.xy = (mul_s(uniforms.f[2 + address_registers.x].zwww, reg_tmp2.xxxx)).xy;
    reg_tmp2.xy = (uniforms.f[0].yyyy + reg_tmp2.xyyy).xy;
    reg_tmp3.xy = (floor(reg_tmp2.xyyy)).xy;
    reg_tmp2.xy = (mul_s(uniforms.f[81].yyyy, reg_tmp3.xyyy)).xy;
    reg_tmp2.xy = (uniforms.f[2 + address_registers.x].zwww + -reg_tmp2.xyyy).xy;
    reg_tmp0.xy = (min(uniforms.f[81].xxxx, -reg_tmp2.xyyy)).xy;
    reg_tmp0.xy = (max(-uniforms.f[81].xxxx, reg_tmp0.xyyy)).xy;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp0.xxxx, reg_tmp0.xxxx)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.xxxx)).y;
    reg_tmp5.x = (uniforms.f[5 + address_registers.x].wwww).x;
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_190_192();
    }
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_194_195();
    }
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_197_198();
    }
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_200_202();
    }
    reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    reg_tmp4.z = (uniforms.f[83].xxxx).z;
    reg_tmp4.w = (-uniforms.f[83].yyyy).w;
    reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[3 + address_registers.x].xyyy)).xy;
    reg_tmp4.z = (-uniforms.f[3 + address_registers.x].zzzz).z;
    reg_tmp4.w = (-uniforms.f[3 + address_registers.x].wwww).w;
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    reg_tmp11.xy = (reg_tmp5.xyyy).xy;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp0.yyyy, reg_tmp0.yyyy)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.yyyy)).y;
    reg_tmp5.x = (uniforms.f[6 + address_registers.x].wwww).x;
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_232_234();
    }
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_236_237();
    }
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_239_240();
    }
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_242_244();
    }
    reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    reg_tmp4.z = (uniforms.f[83].zzzz).z;
    reg_tmp4.w = (-uniforms.f[83].wwww).w;
    reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[4 + address_registers.x].xyyy)).xy;
    reg_tmp4.z = (-uniforms.f[4 + address_registers.x].zzzz).z;
    reg_tmp4.w = (-uniforms.f[4 + address_registers.x].wwww).w;
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    reg_tmp12.xy = (reg_tmp5.xyyy).xy;
    return false;
}
bool sub_190_192() {
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_194_195() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_197_198() {
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_200_202() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_232_234() {
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_236_237() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_239_240() {
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_242_244() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_260_4096() {
    {
        sub_0_8();
    }
    reg_tmp10.xy = (uniforms.f[84].xyyy + reg_tmp10.xyyy).xy;
    reg_tmp10.xy = (mul_s(uniforms.f[2 + address_registers.x].xyyy, reg_tmp10.xyyy)).xy;
    reg_tmp0 = uniforms.f[7 + address_registers.x];
    {
        sub_33_96();
    }
    reg_tmp2.x = dot_s(reg_tmp10, reg_tmp6);
    reg_tmp2.y = dot_s(reg_tmp10, reg_tmp7);
    reg_tmp2.z = dot_s(reg_tmp10, reg_tmp8);
    reg_tmp2.w = dot_s(reg_tmp10, reg_tmp9);
    reg_tmp10 = reg_tmp2;
    {
        sub_97_113();
    }
    reg_tmp2.x = dot_s(reg_tmp10, reg_tmp6);
    reg_tmp2.y = dot_s(reg_tmp10, reg_tmp7);
    reg_tmp2.z = dot_s(reg_tmp10, reg_tmp8);
    reg_tmp2.w = dot_s(uniforms.f[0].xxxz, reg_tmp10);
    reg_tmp3.xyz = (uniforms.f[5 + address_registers.x].xyzz).xyz;
    reg_tmp3.xyz = (uniforms.f[85].xyzz + -reg_tmp3.xyzz).xyz;
    reg_tmp4.x = dot_3(reg_tmp3.xyz, reg_tmp3.xyz);
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
    if (conditional_code.x) {
        sub_280_281();
    } else {
        sub_281_282();
    }
    reg_tmp3.xyz = (mul_s(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
    reg_tmp10.xyz = (uniforms.f[5 + address_registers.x].xyzz + reg_tmp2.xyzz).xyz;
    reg_tmp10.xyz = (fma_s(reg_tmp3.xyzz, uniforms.f[84].zzzz, reg_tmp10.xyzz)).xyz;
    {
        sub_146_166();
    }
    reg_tmp2 = reg_tmp10;
    reg_tmp10.x = dot_s(reg_tmp2, reg_tmp6);
    reg_tmp10.y = dot_s(reg_tmp2, reg_tmp7);
    reg_tmp10.z = dot_s(reg_tmp2, reg_tmp8);
    reg_tmp10.w = dot_s(reg_tmp2, reg_tmp9);
    reg_tmp2 = uniforms.f[1 + address_registers.x];
    reg_tmp3 = max(uniforms.f[0].xxxx, reg_tmp2);
    reg_tmp2 = min(uniforms.f[0].zzzz, reg_tmp3);
    reg_tmp13 = reg_tmp2;
    {
        sub_167_259();
    }
    {
        sub_9_32();
    }
    return true;
}
bool sub_280_281() {
    reg_tmp4.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_281_282() {
    reg_tmp4.x = rsq_s(reg_tmp4.x);
    return false;
}
// reference: 54C62F0AC7196095, 49AB6B882020674A
// shader: 8B30, 0D19D21B46AD8D9B

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_2 = byteround(clamp((vec3(1.0) - combiner_buffer.rgb) * (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: AE3D27E93E737D07, 0D19D21B46AD8D9B
// program: 49AB6B882020674A, 082670B4222015B2, 0D19D21B46AD8D9B
// reference: AE4BD47E0B94D012, D9C174A4A54356AC
// reference: E01F2B3EBCE18466, D9C174A4A54356AC
// reference: 8C39401B19EBEC95, E81D148B6EF003F8
// reference: C26DBF5B6100AF29, E81D148B6EF003F8
// reference: C26DBF5BAE9EB8E1, E81D148B6EF003F8
// reference: 8C39401BB30D1B58, D0293423BD9EA1E7
// reference: AE4BD47EB00595C0, D9C174A4A54356AC
// reference: E01F2B3E0770C1B4, D9C174A4A54356AC
// reference: A7400F4406B39441, 502AB780D80D09C1
// reference: 60055AF2611A3B10, 5E28DB645EED49B7
// reference: BF747829BD2032F2, 35CCCCDE75E2FF83
// reference: 8E5EF570C418C5C3, A40B5D829674D1F8
// reference: C00A0A30736D91B7, A40B5D829674D1F8
// reference: AE4BD47EC9115E26, D9C174A4A54356AC
// reference: E01F2B3EB1FA1D9A, D9C174A4A54356AC
// reference: A7400F447FA75FA7, 502AB780D80D09C1
// reference: E01F2B3E7E640A52, D9C174A4A54356AC
// shader: 8B30, 29CD3EBE51FAA42A

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_2 = byteround(clamp((vec3(1.0) - combiner_buffer.rgb) * (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: E7C524FDD196C12C, 29CD3EBE51FAA42A
// program: D9C174A4A54356AC, 42937135801BAA7E, 29CD3EBE51FAA42A
// shader: 8B30, B2E64CFB9744D892

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((vec3(1.0) - combiner_buffer.rgb) * (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: E7C524FD21414A81, B2E64CFB9744D892
// program: D9C174A4A54356AC, 42937135801BAA7E, B2E64CFB9744D892
// shader: 8B30, 98647FD3CF93B689

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].aaa);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((vec3(1.0) - combiner_buffer.rgb) * (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D77D3BB682EC36A8, 98647FD3CF93B689
// program: D9C174A4A54356AC, 42937135801BAA7E, 98647FD3CF93B689
// reference: A7400F44BD22D193, 502AB780D80D09C1
// reference: 54C62F0A2820F3D4, 49AB6B882020674A
// reference: E01F2B3E53D81727, D9C174A4A54356AC
// reference: C26DBF5B41A72BA0, E81D148B6EF003F8
// program: 49AB6B882020674A, 082670B4222015B2, DBA0F8FE46AD8D9B
// shader: 8B31, 70A370D21404144E

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_8();
bool sub_9_32();
bool sub_97_113();
bool sub_146_166();
bool sub_167_259();
bool sub_190_192();
bool sub_194_195();
bool sub_197_198();
bool sub_200_202();
bool sub_232_234();
bool sub_236_237();
bool sub_239_240();
bool sub_242_244();
bool sub_260_4096();
bool sub_273_274();
bool sub_274_275();

bool exec_shader() {
    sub_260_4096();
    return true;
}

bool sub_0_8() {
    address_registers.x = (ivec2(vs_in_reg0.zz)).x;
    reg_tmp10 = uniforms.f[0].xxxz;
    reg_tmp10.xy = (vs_in_reg0.xyyy).xy;
    reg_tmp11 = uniforms.f[0].xxxx;
    reg_tmp12 = uniforms.f[0].xxxx;
    reg_tmp13 = uniforms.f[0].zzzz;
    reg_tmp4 = uniforms.f[0].xxxx;
    reg_tmp5 = uniforms.f[0].xxxx;
    return false;
}
bool sub_9_32() {
    vs_out_attr0 = reg_tmp10;
    reg_tmp13 = mul_s(uniforms.f[82], reg_tmp13);
    vs_out_attr1 = reg_tmp13;
    reg_tmp11.y = (uniforms.f[0].zzzz + -reg_tmp11.yyyy).y;
    reg_tmp12.y = (uniforms.f[0].zzzz + -reg_tmp12.yyyy).y;
    reg_tmp14.y = (uniforms.f[81].wwww).y;
    reg_tmp14.x = (mul_s(uniforms.f[0].wwww, reg_tmp14.yyyy)).x;
    reg_tmp2.x = rcp_s(reg_tmp14.x);
    reg_tmp14.z = (reg_tmp2.xxxx).z;
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp11.xyyy).xy;
    reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    reg_tmp11.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp12.xyyy).xy;
    reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    reg_tmp12.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    vs_out_attr2 = reg_tmp11;
    vs_out_attr3 = reg_tmp12;
    return false;
}
bool sub_97_113() {
    reg_tmp6.x = (uniforms.f[90].xxxx).x;
    reg_tmp6.y = (uniforms.f[91].xxxx).y;
    reg_tmp6.z = (uniforms.f[92].xxxx).z;
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    reg_tmp7.x = (uniforms.f[90].yyyy).x;
    reg_tmp7.y = (uniforms.f[91].yyyy).y;
    reg_tmp7.z = (uniforms.f[92].yyyy).z;
    reg_tmp7.w = (uniforms.f[0].xxxx).w;
    reg_tmp8.x = (uniforms.f[90].zzzz).x;
    reg_tmp8.y = (uniforms.f[91].zzzz).y;
    reg_tmp8.z = (uniforms.f[92].zzzz).z;
    reg_tmp8.w = (uniforms.f[0].xxxx).w;
    reg_tmp9.x = (uniforms.f[90].wwww).x;
    reg_tmp9.y = (uniforms.f[91].wwww).y;
    reg_tmp9.z = (uniforms.f[92].wwww).z;
    reg_tmp9.w = (uniforms.f[0].zzzz).w;
    return false;
}
bool sub_146_166() {
    reg_tmp2 = uniforms.f[90];
    reg_tmp3 = uniforms.f[91];
    reg_tmp4 = uniforms.f[92];
    reg_tmp5 = uniforms.f[0].xxxz;
    reg_tmp6 = mul_s(uniforms.f[86].xxxx, reg_tmp2);
    reg_tmp6 = fma_s(reg_tmp3, uniforms.f[86].yyyy, reg_tmp6);
    reg_tmp6 = fma_s(reg_tmp4, uniforms.f[86].zzzz, reg_tmp6);
    reg_tmp6 = fma_s(reg_tmp5, uniforms.f[86].wwww, reg_tmp6);
    reg_tmp7 = mul_s(uniforms.f[87].xxxx, reg_tmp2);
    reg_tmp7 = fma_s(reg_tmp3, uniforms.f[87].yyyy, reg_tmp7);
    reg_tmp7 = fma_s(reg_tmp4, uniforms.f[87].zzzz, reg_tmp7);
    reg_tmp7 = fma_s(reg_tmp5, uniforms.f[87].wwww, reg_tmp7);
    reg_tmp8 = mul_s(uniforms.f[88].xxxx, reg_tmp2);
    reg_tmp8 = fma_s(reg_tmp3, uniforms.f[88].yyyy, reg_tmp8);
    reg_tmp8 = fma_s(reg_tmp4, uniforms.f[88].zzzz, reg_tmp8);
    reg_tmp8 = fma_s(reg_tmp5, uniforms.f[88].wwww, reg_tmp8);
    reg_tmp9 = mul_s(uniforms.f[89].xxxx, reg_tmp2);
    reg_tmp9 = fma_s(reg_tmp3, uniforms.f[89].yyyy, reg_tmp9);
    reg_tmp9 = fma_s(reg_tmp4, uniforms.f[89].zzzz, reg_tmp9);
    reg_tmp9 = fma_s(reg_tmp5, uniforms.f[89].wwww, reg_tmp9);
    return false;
}
bool sub_167_259() {
    reg_tmp2.x = rcp_s(uniforms.f[81].y);
    reg_tmp2.xy = (mul_s(uniforms.f[2 + address_registers.x].zwww, reg_tmp2.xxxx)).xy;
    reg_tmp2.xy = (uniforms.f[0].yyyy + reg_tmp2.xyyy).xy;
    reg_tmp3.xy = (floor(reg_tmp2.xyyy)).xy;
    reg_tmp2.xy = (mul_s(uniforms.f[81].yyyy, reg_tmp3.xyyy)).xy;
    reg_tmp2.xy = (uniforms.f[2 + address_registers.x].zwww + -reg_tmp2.xyyy).xy;
    reg_tmp0.xy = (min(uniforms.f[81].xxxx, -reg_tmp2.xyyy)).xy;
    reg_tmp0.xy = (max(-uniforms.f[81].xxxx, reg_tmp0.xyyy)).xy;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp0.xxxx, reg_tmp0.xxxx)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.xxxx)).y;
    reg_tmp5.x = (uniforms.f[5 + address_registers.x].wwww).x;
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_190_192();
    }
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_194_195();
    }
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_197_198();
    }
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_200_202();
    }
    reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    reg_tmp4.z = (uniforms.f[83].xxxx).z;
    reg_tmp4.w = (-uniforms.f[83].yyyy).w;
    reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[3 + address_registers.x].xyyy)).xy;
    reg_tmp4.z = (-uniforms.f[3 + address_registers.x].zzzz).z;
    reg_tmp4.w = (-uniforms.f[3 + address_registers.x].wwww).w;
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    reg_tmp11.xy = (reg_tmp5.xyyy).xy;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp0.yyyy, reg_tmp0.yyyy)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.yyyy)).y;
    reg_tmp5.x = (uniforms.f[6 + address_registers.x].wwww).x;
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_232_234();
    }
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_236_237();
    }
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_239_240();
    }
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_242_244();
    }
    reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    reg_tmp4.z = (uniforms.f[83].zzzz).z;
    reg_tmp4.w = (-uniforms.f[83].wwww).w;
    reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[4 + address_registers.x].xyyy)).xy;
    reg_tmp4.z = (-uniforms.f[4 + address_registers.x].zzzz).z;
    reg_tmp4.w = (-uniforms.f[4 + address_registers.x].wwww).w;
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    reg_tmp12.xy = (reg_tmp5.xyyy).xy;
    return false;
}
bool sub_190_192() {
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_194_195() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_197_198() {
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_200_202() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_232_234() {
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_236_237() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_239_240() {
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_242_244() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_260_4096() {
    {
        sub_0_8();
    }
    reg_tmp10.xy = (uniforms.f[84].xyyy + reg_tmp10.xyyy).xy;
    reg_tmp10.xy = (mul_s(uniforms.f[2 + address_registers.x].xyyy, reg_tmp10.xyyy)).xy;
    {
        sub_97_113();
    }
    reg_tmp2.x = dot_s(reg_tmp10, reg_tmp6);
    reg_tmp2.y = dot_s(reg_tmp10, reg_tmp7);
    reg_tmp2.z = dot_s(reg_tmp10, reg_tmp8);
    reg_tmp2.w = dot_s(uniforms.f[0].xxxz, reg_tmp10);
    reg_tmp3.xyz = (uniforms.f[5 + address_registers.x].xyzz).xyz;
    reg_tmp3.xyz = (uniforms.f[85].xyzz + -reg_tmp3.xyzz).xyz;
    reg_tmp4.x = dot_3(reg_tmp3.xyz, reg_tmp3.xyz);
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
    if (conditional_code.x) {
        sub_273_274();
    } else {
        sub_274_275();
    }
    reg_tmp3.xyz = (mul_s(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
    reg_tmp10.xyz = (uniforms.f[5 + address_registers.x].xyzz + reg_tmp2.xyzz).xyz;
    reg_tmp10.xyz = (fma_s(reg_tmp3.xyzz, uniforms.f[84].zzzz, reg_tmp10.xyzz)).xyz;
    {
        sub_146_166();
    }
    reg_tmp2 = reg_tmp10;
    reg_tmp10.x = dot_s(reg_tmp2, reg_tmp6);
    reg_tmp10.y = dot_s(reg_tmp2, reg_tmp7);
    reg_tmp10.z = dot_s(reg_tmp2, reg_tmp8);
    reg_tmp10.w = dot_s(reg_tmp2, reg_tmp9);
    reg_tmp2 = uniforms.f[1 + address_registers.x];
    reg_tmp3 = max(uniforms.f[0].xxxx, reg_tmp2);
    reg_tmp2 = min(uniforms.f[0].zzzz, reg_tmp3);
    reg_tmp13 = reg_tmp2;
    {
        sub_167_259();
    }
    {
        sub_9_32();
    }
    return true;
}
bool sub_273_274() {
    reg_tmp4.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_274_275() {
    reg_tmp4.x = rsq_s(reg_tmp4.x);
    return false;
}
// reference: 9A2ECF1D2E1DC7FB, 70A370D21404144E
// program: 70A370D21404144E, 082670B4222015B2, DBA0F8FE46AD8D9B
// shader: 8B30, F4A415D97E9B6ED6

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.r) + (texcolor1.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 0FEF1F2F49AF6349, F4A415D97E9B6ED6
// program: 70A370D21404144E, 082670B4222015B2, F4A415D97E9B6ED6
// shader: 8B30, AB0D786CFAD777F8

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].aaa);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((vec3(1.0) - combiner_buffer.rgb) * (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 6FB2BCD49EEC8605, AB0D786CFAD777F8
// program: D9C174A4A54356AC, 42937135801BAA7E, AB0D786CFAD777F8
// reference: 58970D472FEC08FB, 502AB780D80D09C1
// reference: 3DBABD58F47CAD1A, E81D148B6EF003F8
// shader: 8B30, 0AC00F84117E7EFC

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) + (const_color[0].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].aaa) + (const_color[1].rgb) * (vec3(1.0) - (const_color[1].aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (const_color[2].a) + (const_color[2].r) * (1.0 - (const_color[2].a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((texcolor1.a) * (const_color[3].a) + (texcolor1.r) * (1.0 - (const_color[3].a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = (last_tex_env_out.rgb);
float alpha_output_4 = byteround(clamp((last_tex_env_out.a) * (combiner_buffer.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D3310DE01E8B3F75, 0AC00F84117E7EFC
// program: 35CCCCDE75E2FF83, B80FA1B7F97410CD, 0AC00F84117E7EFC
// reference: 36C80D52F25786E1, 4CDB2C6E0A14815D
// reference: 789CF2124522D295, 4CDB2C6E0A14815D
// reference: 9790BAAF5AC7E1C6, 4CDB2C6E0A14815D
// shader: 8B30, A36D1D6BA424DB28

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(light_vector, normal)));
refl_value.g = (lut_scale_rg * LookupLightingLUTSigned(5, dot(light_vector, normal)));
refl_value.b = (lut_scale_rb * LookupLightingLUTSigned(4, dot(light_vector, normal)));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (secondary_fragment_color.r);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (texcolor0.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) - (texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: F20DB75BD5534DAF, A36D1D6BA424DB28
// program: 4CDB2C6E0A14815D, B80FA1B7F97410CD, A36D1D6BA424DB28
// reference: D9C445EFEDB2B5B2, 4CDB2C6E0A14815D
// shader: 8B30, 641FDB3E9E36B758

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(light_vector, normal)));
refl_value.g = (lut_scale_rg * LookupLightingLUTSigned(5, dot(light_vector, normal)));
refl_value.b = (lut_scale_rb * LookupLightingLUTSigned(4, dot(light_vector, normal)));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (secondary_fragment_color.r);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (texcolor0.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) - (texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) * (const_color[4].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 314FAD7D3936E34B, 641FDB3E9E36B758
// program: 4CDB2C6E0A14815D, B80FA1B7F97410CD, 641FDB3E9E36B758
// reference: 1A92D04A4C856BDA, 49AB6B882020674A
// shader: 8B30, 1430EF96EBF7840F

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.r) * (texcolor1.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_2 = byteround(clamp((vec3(1.0) - combiner_buffer.rgb) * (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 6AF29988B26CD5C1, 1430EF96EBF7840F
// program: 49AB6B882020674A, 082670B4222015B2, 1430EF96EBF7840F
// reference: 54C62F0A14C9ACEF, 49AB6B882020674A
// shader: 8B31, 4028512EA840631E

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;
out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_6();
bool sub_6_53();
bool sub_21_25();
bool sub_51_52();
bool sub_53_4096();

bool exec_shader() {
    sub_53_4096();
    return true;
}

bool sub_0_6() {
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    return false;
}
bool sub_6_53() {
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    reg_tmp7 = uniforms.f[93].xxxx;
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    {
        sub_0_6();
    }
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    {
        sub_0_6();
    }
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    if (conditional_code.x) {
        sub_0_6();
    }
    if (uniforms.b[11]) {
        sub_21_25();
    }
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    reg_tmp10 = reg_tmp7;
    reg_tmp6.y = (-uniforms.f[83].wwww + reg_tmp10.yyyy).y;
    reg_tmp9.xyz = (uniforms.f[83].xyzz).xyz;
    reg_tmp7.x = dot_s(reg_tmp9.xyzz, reg_tmp9.xyzz);
    reg_tmp7.x = rsq_s(reg_tmp7.x);
    reg_tmp7.xyz = (mul_s(reg_tmp9.xyzz, reg_tmp7.xxxx)).xyz;
    reg_tmp8.y = rcp_s(-reg_tmp7.y);
    reg_tmp8.y = (mul_s(reg_tmp6.yyyy, reg_tmp8.yyyy)).y;
    reg_tmp7.xyz = (mul_s(reg_tmp7.xyzz, reg_tmp8.yyyy)).xyz;
    reg_tmp10.xyz = (reg_tmp10.xyzz + reg_tmp7.xyzz).xyz;
    reg_tmp10.y = (uniforms.f[94].xxxx + reg_tmp10.yyyy).y;
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    vs_out_attr1 = uniforms.f[93].xxxx;
    vs_out_attr2 = -reg_tmp15;
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    if (all(conditional_code)) {
        sub_51_52();
    }
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_21_25() {
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    if (conditional_code.y) {
        sub_0_6();
    }
    return false;
}
bool sub_51_52() {
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_53_4096() {
    {
        sub_6_53();
    }
    vs_out_attr4 = uniforms.f[93].xxxx;
    vs_out_attr5 = uniforms.f[93].xxxx;
    vs_out_attr6 = uniforms.f[93].xxxx;
    vs_out_attr3 = uniforms.f[93].xxxx;
    return true;
}
// reference: 88E78CBE97BB30E5, 4028512EA840631E
// program: 4028512EA840631E, B80FA1B7F97410CD, C2EEBEAE0D7F3560
// shader: 8B30, 9D0535C6802495CB

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = 2.0 * (texcolor2).rgb - 1.0;
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(normal, normalize(view))));
refl_value.g = (lut_scale_rg * LookupLightingLUTSigned(5, dot(normal, normalize(view))));
refl_value.b = (lut_scale_rb * LookupLightingLUTSigned(4, dot(normal, normalize(view))));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = byteround(clamp((secondary_fragment_color.r) * (texcolor2.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor0.rgb) * (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (1.0 - const_color[1].a) + (secondary_fragment_color.b) * (1.0 - (1.0 - const_color[1].a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (texcolor1.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((secondary_fragment_color.ggg) * (const_color[3].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((rounded_primary_color.aaa) * (const_color[4].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: B9C7C307E036E114, 9D0535C6802495CB
// program: A40B5D829674D1F8, B80FA1B7F97410CD, 9D0535C6802495CB
// reference: 9A2ECF1D12F498C0, 70A370D21404144E
// shader: 8B30, 63A5270519B4AE20

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.r);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_2 = byteround(clamp((vec3(1.0) - combiner_buffer.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 7037091908602FB1, 63A5270519B4AE20
// program: 49AB6B882020674A, 082670B4222015B2, 63A5270519B4AE20
// reference: D47A305D4AB85FF5, 70A370D21404144E
// reference: D47A305D43503FF0, 70A370D21404144E
// reference: 9A2ECF1D1B1CF8C5, 70A370D21404144E
// reference: D186A7B163B4E9DE, 5E28DB645EED49B7
// shader: 8B30, 49F399BDFAD777F8

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((vec3(1.0) - combiner_buffer.rgb) * (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 5F0AA39FC6A18B95, 49F399BDFAD777F8
// program: D9C174A4A54356AC, 42937135801BAA7E, 49F399BDFAD777F8
// shader: 8B30, 00F9BB7ACF93B689

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((vec3(1.0) - combiner_buffer.rgb) * (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: E7C524FDDAA13B38, 00F9BB7ACF93B689
// program: D9C174A4A54356AC, 42937135801BAA7E, 00F9BB7ACF93B689
// shader: 8B31, 3526EFD6EA584B4A

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;
out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_19();
bool sub_19_29();
bool sub_29_76();
bool sub_33_51();
bool sub_51_59();
bool sub_74_75();
bool sub_76_103();
bool sub_78_83();
bool sub_83_102();
bool sub_86_92();
bool sub_92_101();
bool sub_93_97();
bool sub_97_100();
bool sub_103_127();
bool sub_105_109();
bool sub_109_126();
bool sub_110_124();
bool sub_113_120();
bool sub_120_123();
bool sub_124_125();
bool sub_127_143();
bool sub_129_133();
bool sub_133_142();
bool sub_134_140();
bool sub_140_141();
bool sub_143_151();
bool sub_145_146();
bool sub_146_150();
bool sub_147_148();
bool sub_148_149();
bool sub_151_158();
bool sub_158_164();
bool sub_164_4096();
bool sub_166_173();
bool sub_173_174();

bool exec_shader() {
    sub_164_4096();
    return true;
}

bool sub_0_19() {
    uint jmp_to = 0u;
    while (true) {
        switch (jmp_to) {
        case 0u: {
            reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
            reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
            reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
            reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
            reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
            reg_tmp6.x = rsq_s(reg_tmp6.x);
            reg_tmp7.x = rsq_s(reg_tmp7.x);
            reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            reg_tmp0 = uniforms.f[93].yxxx;
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            reg_tmp4 = mul_s(uniforms.f[94].xxxx, reg_tmp4);
            conditional_code = greaterThanEqual(uniforms.f[93].xx, reg_tmp4.xx);
            reg_tmp4 = vec4(rsq_s(reg_tmp4.x));
            reg_tmp5 = mul_s(uniforms.f[94].xxxx, reg_tmp14);
            if (conditional_code.x) {
                { jmp_to = 18u; break; }
            }
            reg_tmp0.z = rcp_s(reg_tmp4.x);
            reg_tmp0.xy = (mul_s(reg_tmp5, reg_tmp4)).xy;
        }
        case 18u: {
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_19_29() {
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    reg_tmp4.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_29_76() {
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    if (uniforms.b[0]) {
        sub_33_51();
    } else {
        sub_51_59();
    }
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    {
        sub_0_19();
    }
    vs_out_attr2 = reg_tmp15;
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    if (all(conditional_code)) {
        sub_74_75();
    }
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_33_51() {
    reg_tmp7 = uniforms.f[93].xxxx;
    reg_tmp12 = uniforms.f[93].xxxx;
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    {
        sub_19_29();
    }
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    {
        sub_19_29();
    }
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    {
        sub_19_29();
    }
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    {
        sub_19_29();
    }
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    reg_tmp10 = reg_tmp7;
    return false;
}
bool sub_51_59() {
    reg_tmp7 = reg_tmp15;
    reg_tmp10.x = dot_s(uniforms.f[10], reg_tmp7);
    reg_tmp10.y = dot_s(uniforms.f[11], reg_tmp7);
    reg_tmp10.z = dot_s(uniforms.f[12], reg_tmp7);
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    reg_tmp12.x = dot_3(uniforms.f[10].xyz, reg_tmp14.xyz);
    reg_tmp12.y = dot_3(uniforms.f[11].xyz, reg_tmp14.xyz);
    reg_tmp12.z = dot_3(uniforms.f[12].xyz, reg_tmp14.xyz);
    return false;
}
bool sub_74_75() {
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_76_103() {
    reg_tmp0.xy = (uniforms.f[0].xxxx).xy;
    if (uniforms.b[2]) {
        sub_78_83();
    } else {
        sub_83_102();
    }
    return false;
}
bool sub_78_83() {
    {
        sub_143_151();
    }
    reg_tmp3.x = dot_s(uniforms.f[1].xywz, reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2].xywz, reg_tmp6);
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_83_102() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_86_92();
    } else {
        sub_92_101();
    }
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_86_92() {
    reg_tmp6 = reg_tmp10;
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    reg_tmp3.z = dot_s(uniforms.f[3], reg_tmp6);
    reg_tmp0.xy = (mul_s(uniforms.f[9].xyyy, reg_tmp3.zzzz)).xy;
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_92_101() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_93_97();
    } else {
        sub_97_100();
    }
    return false;
}
bool sub_93_97() {
    {
        sub_151_158();
    }
    reg_tmp3.x = dot_3(uniforms.f[1].xyz, reg_tmp6.xyz);
    reg_tmp3.y = dot_3(uniforms.f[2].xyz, reg_tmp6.xyz);
    reg_tmp3.z = dot_3(uniforms.f[3].xyz, reg_tmp6.xyz);
    return false;
}
bool sub_97_100() {
    {
        sub_158_164();
    }
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    return false;
}
bool sub_103_127() {
    reg_tmp0.xy = (uniforms.f[0].yyyy).xy;
    if (uniforms.b[3]) {
        sub_105_109();
    } else {
        sub_109_126();
    }
    return false;
}
bool sub_105_109() {
    {
        sub_143_151();
    }
    reg_tmp4.x = dot_s(uniforms.f[4].xywz, reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5].xywz, reg_tmp6);
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_109_126() {
    if (uniforms.b[5]) {
        sub_110_124();
    } else {
        sub_124_125();
    }
    return false;
}
bool sub_110_124() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_113_120();
    } else {
        sub_120_123();
    }
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_113_120() {
    reg_tmp6 = reg_tmp10;
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    reg_tmp4.z = dot_s(uniforms.f[6], reg_tmp6);
    reg_tmp6.w = rcp_s(reg_tmp4.z);
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    reg_tmp4.xy = (uniforms.f[9].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_120_123() {
    {
        sub_158_164();
    }
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    return false;
}
bool sub_124_125() {
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_127_143() {
    reg_tmp0.xy = (uniforms.f[0].zzzz).xy;
    if (uniforms.b[4]) {
        sub_129_133();
    } else {
        sub_133_142();
    }
    return false;
}
bool sub_129_133() {
    {
        sub_143_151();
    }
    reg_tmp5.x = dot_s(uniforms.f[7].xywz, reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8].xywz, reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_133_142() {
    if (uniforms.b[6]) {
        sub_134_140();
    } else {
        sub_140_141();
    }
    return false;
}
bool sub_134_140() {
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    {
        sub_158_164();
    }
    reg_tmp5.x = dot_s(uniforms.f[7], reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8], reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_140_141() {
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
bool sub_143_151() {
    conditional_code = equal(uniforms.f[93].yz, reg_tmp0.xy);
    if (all(not(conditional_code))) {
        sub_145_146();
    } else {
        sub_146_150();
    }
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_145_146() {
    reg_tmp6.xy = (vs_in_reg4.xyyy).xy;
    return false;
}
bool sub_146_150() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_147_148();
    } else {
        sub_148_149();
    }
    return false;
}
bool sub_147_148() {
    reg_tmp6.xy = (vs_in_reg5.xyyy).xy;
    return false;
}
bool sub_148_149() {
    reg_tmp6.xy = (vs_in_reg6.xyyy).xy;
    return false;
}
bool sub_151_158() {
    reg_tmp2 = -reg_tmp15;
    reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
    reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_158_164() {
    reg_tmp1 = reg_tmp14;
    reg_tmp2.w = dot_3(reg_tmp1.xyz, reg_tmp1.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp1 = mul_s(reg_tmp1, reg_tmp2.wwww);
    reg_tmp1 = mul_s(uniforms.f[94].xxxx, reg_tmp1);
    reg_tmp6.xy = (uniforms.f[94].xxxx + reg_tmp1.xyyy).xy;
    return false;
}
bool sub_164_4096() {
    {
        sub_29_76();
    }
    if (uniforms.b[1]) {
        sub_166_173();
    } else {
        sub_173_174();
    }
    vs_out_attr3 = reg_tmp2;
    {
        sub_76_103();
    }
    {
        sub_103_127();
    }
    {
        sub_127_143();
    }
    return true;
}
bool sub_166_173() {
    reg_tmp0 = vec4(dot_3(uniforms.f[83].xyz, reg_tmp12.xyz));
    reg_tmp0 = max(uniforms.f[93].xxxx, reg_tmp0);
    reg_tmp0 = mul_s(uniforms.f[84], reg_tmp0);
    reg_tmp0 = uniforms.f[85] + reg_tmp0;
    reg_tmp0.w = (uniforms.f[93].yyyy).w;
    reg_tmp1 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
    reg_tmp2 = mul_s(reg_tmp0, reg_tmp1);
    return false;
}
bool sub_173_174() {
    reg_tmp2 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
    return false;
}
// reference: 9E522B3776D80EC2, 3526EFD6EA584B4A
// shader: 8B30, B766CBB102E471E4

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = (const_color[0].a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D4F4BEF93E852CAC, B766CBB102E471E4
// program: 3526EFD6EA584B4A, B80FA1B7F97410CD, B766CBB102E471E4
// reference: 2589AD90369791C8, 5E28DB645EED49B7
// reference: 32BC79DF75ED1C87, 4028512EA840631E
// shader: 8B31, 8AA3B6DF4767940E

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_8();
bool sub_9_32();
bool sub_143_145();
bool sub_146_166();
bool sub_167_259();
bool sub_190_192();
bool sub_194_195();
bool sub_197_198();
bool sub_200_202();
bool sub_232_234();
bool sub_236_237();
bool sub_239_240();
bool sub_242_244();
bool sub_260_4096();
bool sub_269_270();
bool sub_270_271();
bool sub_277_278();
bool sub_278_279();
bool sub_304_305();
bool sub_305_306();

bool exec_shader() {
    sub_260_4096();
    return true;
}

bool sub_0_8() {
    address_registers.x = (ivec2(vs_in_reg0.zz)).x;
    reg_tmp10 = uniforms.f[0].xxxz;
    reg_tmp10.xy = (vs_in_reg0.xyyy).xy;
    reg_tmp11 = uniforms.f[0].xxxx;
    reg_tmp12 = uniforms.f[0].xxxx;
    reg_tmp13 = uniforms.f[0].zzzz;
    reg_tmp4 = uniforms.f[0].xxxx;
    reg_tmp5 = uniforms.f[0].xxxx;
    return false;
}
bool sub_9_32() {
    vs_out_attr0 = reg_tmp10;
    reg_tmp13 = mul_s(uniforms.f[82], reg_tmp13);
    vs_out_attr1 = reg_tmp13;
    reg_tmp11.y = (uniforms.f[0].zzzz + -reg_tmp11.yyyy).y;
    reg_tmp12.y = (uniforms.f[0].zzzz + -reg_tmp12.yyyy).y;
    reg_tmp14.y = (uniforms.f[81].wwww).y;
    reg_tmp14.x = (mul_s(uniforms.f[0].wwww, reg_tmp14.yyyy)).x;
    reg_tmp2.x = rcp_s(reg_tmp14.x);
    reg_tmp14.z = (reg_tmp2.xxxx).z;
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp11.xyyy).xy;
    reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    reg_tmp11.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp12.xyyy).xy;
    reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    reg_tmp12.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    vs_out_attr2 = reg_tmp11;
    vs_out_attr3 = reg_tmp12;
    return false;
}
bool sub_143_145() {
    reg_tmp1.xyz = (uniforms.f[92].xyzz).xyz;
    reg_tmp1.w = (uniforms.f[0].xxxx).w;
    return false;
}
bool sub_146_166() {
    reg_tmp2 = uniforms.f[90];
    reg_tmp3 = uniforms.f[91];
    reg_tmp4 = uniforms.f[92];
    reg_tmp5 = uniforms.f[0].xxxz;
    reg_tmp6 = mul_s(uniforms.f[86].xxxx, reg_tmp2);
    reg_tmp6 = fma_s(reg_tmp3, uniforms.f[86].yyyy, reg_tmp6);
    reg_tmp6 = fma_s(reg_tmp4, uniforms.f[86].zzzz, reg_tmp6);
    reg_tmp6 = fma_s(reg_tmp5, uniforms.f[86].wwww, reg_tmp6);
    reg_tmp7 = mul_s(uniforms.f[87].xxxx, reg_tmp2);
    reg_tmp7 = fma_s(reg_tmp3, uniforms.f[87].yyyy, reg_tmp7);
    reg_tmp7 = fma_s(reg_tmp4, uniforms.f[87].zzzz, reg_tmp7);
    reg_tmp7 = fma_s(reg_tmp5, uniforms.f[87].wwww, reg_tmp7);
    reg_tmp8 = mul_s(uniforms.f[88].xxxx, reg_tmp2);
    reg_tmp8 = fma_s(reg_tmp3, uniforms.f[88].yyyy, reg_tmp8);
    reg_tmp8 = fma_s(reg_tmp4, uniforms.f[88].zzzz, reg_tmp8);
    reg_tmp8 = fma_s(reg_tmp5, uniforms.f[88].wwww, reg_tmp8);
    reg_tmp9 = mul_s(uniforms.f[89].xxxx, reg_tmp2);
    reg_tmp9 = fma_s(reg_tmp3, uniforms.f[89].yyyy, reg_tmp9);
    reg_tmp9 = fma_s(reg_tmp4, uniforms.f[89].zzzz, reg_tmp9);
    reg_tmp9 = fma_s(reg_tmp5, uniforms.f[89].wwww, reg_tmp9);
    return false;
}
bool sub_167_259() {
    reg_tmp2.x = rcp_s(uniforms.f[81].y);
    reg_tmp2.xy = (mul_s(uniforms.f[2 + address_registers.x].zwww, reg_tmp2.xxxx)).xy;
    reg_tmp2.xy = (uniforms.f[0].yyyy + reg_tmp2.xyyy).xy;
    reg_tmp3.xy = (floor(reg_tmp2.xyyy)).xy;
    reg_tmp2.xy = (mul_s(uniforms.f[81].yyyy, reg_tmp3.xyyy)).xy;
    reg_tmp2.xy = (uniforms.f[2 + address_registers.x].zwww + -reg_tmp2.xyyy).xy;
    reg_tmp0.xy = (min(uniforms.f[81].xxxx, -reg_tmp2.xyyy)).xy;
    reg_tmp0.xy = (max(-uniforms.f[81].xxxx, reg_tmp0.xyyy)).xy;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp0.xxxx, reg_tmp0.xxxx)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.xxxx)).y;
    reg_tmp5.x = (uniforms.f[5 + address_registers.x].wwww).x;
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_190_192();
    }
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_194_195();
    }
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_197_198();
    }
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_200_202();
    }
    reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    reg_tmp4.z = (uniforms.f[83].xxxx).z;
    reg_tmp4.w = (-uniforms.f[83].yyyy).w;
    reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[3 + address_registers.x].xyyy)).xy;
    reg_tmp4.z = (-uniforms.f[3 + address_registers.x].zzzz).z;
    reg_tmp4.w = (-uniforms.f[3 + address_registers.x].wwww).w;
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    reg_tmp11.xy = (reg_tmp5.xyyy).xy;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp0.yyyy, reg_tmp0.yyyy)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.yyyy)).y;
    reg_tmp5.x = (uniforms.f[6 + address_registers.x].wwww).x;
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_232_234();
    }
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_236_237();
    }
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_239_240();
    }
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_242_244();
    }
    reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    reg_tmp4.z = (uniforms.f[83].zzzz).z;
    reg_tmp4.w = (-uniforms.f[83].wwww).w;
    reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[4 + address_registers.x].xyyy)).xy;
    reg_tmp4.z = (-uniforms.f[4 + address_registers.x].zzzz).z;
    reg_tmp4.w = (-uniforms.f[4 + address_registers.x].wwww).w;
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    reg_tmp12.xy = (reg_tmp5.xyyy).xy;
    return false;
}
bool sub_190_192() {
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_194_195() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_197_198() {
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_200_202() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_232_234() {
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_236_237() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_239_240() {
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_242_244() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_260_4096() {
    {
        sub_0_8();
    }
    reg_tmp10.xy = (uniforms.f[84].xyyy + reg_tmp10.xyyy).xy;
    reg_tmp10.xy = (mul_s(uniforms.f[2 + address_registers.x].xyyy, reg_tmp10.xyyy)).xy;
    {
        sub_143_145();
    }
    reg_tmp2.xyz = (reg_tmp1.xyzz).xyz;
    reg_tmp3.xyz = (uniforms.f[6 + address_registers.x].xyzz).xyz;
    reg_tmp4.x = dot_3(reg_tmp3.xyz, reg_tmp3.xyz);
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
    if (conditional_code.x) {
        sub_269_270();
    } else {
        sub_270_271();
    }
    reg_tmp3.xyz = (mul_s(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
    reg_tmp4.xyz = (mul_s(reg_tmp3.yzxx, reg_tmp2.zxyy)).xyz;
    reg_tmp4.xyz = (fma_s(-reg_tmp2.yzxx, reg_tmp3.zxyy, reg_tmp4)).xyz;
    reg_tmp5.x = dot_3(reg_tmp4.xyz, reg_tmp4.xyz);
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp5.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp5.y;
    if (conditional_code.x) {
        sub_277_278();
    } else {
        sub_278_279();
    }
    reg_tmp4.xyz = (mul_s(reg_tmp4.xyzz, reg_tmp5.xxxx)).xyz;
    reg_tmp5.xyz = (mul_s(reg_tmp3.yzxx, reg_tmp4.zxyy)).xyz;
    reg_tmp5.xyz = (fma_s(-reg_tmp4.yzxx, reg_tmp3.zxyy, reg_tmp5)).xyz;
    reg_tmp6.x = (reg_tmp4.xxxx).x;
    reg_tmp6.y = (reg_tmp3.xxxx).y;
    reg_tmp6.z = (reg_tmp5.xxxx).z;
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    reg_tmp7.x = (reg_tmp4.yyyy).x;
    reg_tmp7.y = (reg_tmp3.yyyy).y;
    reg_tmp7.z = (reg_tmp5.yyyy).z;
    reg_tmp7.w = (uniforms.f[0].xxxx).w;
    reg_tmp8.x = (reg_tmp4.zzzz).x;
    reg_tmp8.y = (reg_tmp3.zzzz).y;
    reg_tmp8.z = (reg_tmp5.zzzz).z;
    reg_tmp8.w = (uniforms.f[0].xxxx).w;
    reg_tmp9 = uniforms.f[0].xxxz;
    reg_tmp2.x = dot_s(reg_tmp10, reg_tmp6);
    reg_tmp2.y = dot_s(reg_tmp10, reg_tmp7);
    reg_tmp2.z = dot_s(reg_tmp10, reg_tmp8);
    reg_tmp2.w = dot_s(reg_tmp10, reg_tmp9);
    reg_tmp3.xyz = (uniforms.f[5 + address_registers.x].xyzz).xyz;
    reg_tmp3.xyz = (-uniforms.f[85].xyzz + reg_tmp3.xyzz).xyz;
    reg_tmp4.x = dot_3(reg_tmp3.xyz, reg_tmp3.xyz);
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
    if (conditional_code.x) {
        sub_304_305();
    } else {
        sub_305_306();
    }
    reg_tmp3.xyz = (mul_s(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
    reg_tmp10.xyz = (uniforms.f[5 + address_registers.x].xyzz + reg_tmp2.xyzz).xyz;
    reg_tmp10.xyz = (fma_s(reg_tmp3.xyzz, -uniforms.f[84].zzzz, reg_tmp10.xyzz)).xyz;
    {
        sub_146_166();
    }
    reg_tmp2 = reg_tmp10;
    reg_tmp10.x = dot_s(reg_tmp2, reg_tmp6);
    reg_tmp10.y = dot_s(reg_tmp2, reg_tmp7);
    reg_tmp10.z = dot_s(reg_tmp2, reg_tmp8);
    reg_tmp10.w = dot_s(reg_tmp2, reg_tmp9);
    reg_tmp2 = uniforms.f[1 + address_registers.x];
    reg_tmp3 = max(uniforms.f[0].xxxx, reg_tmp2);
    reg_tmp2 = min(uniforms.f[0].zzzz, reg_tmp3);
    reg_tmp13 = reg_tmp2;
    {
        sub_167_259();
    }
    {
        sub_9_32();
    }
    return true;
}
bool sub_269_270() {
    reg_tmp4.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_270_271() {
    reg_tmp4.x = rsq_s(reg_tmp4.x);
    return false;
}
bool sub_277_278() {
    reg_tmp5.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_278_279() {
    reg_tmp5.x = rsq_s(reg_tmp5.x);
    return false;
}
bool sub_304_305() {
    reg_tmp4.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_305_306() {
    reg_tmp4.x = rsq_s(reg_tmp4.x);
    return false;
}
// reference: 15AC41860116679C, 8AA3B6DF4767940E
// program: 8AA3B6DF4767940E, 082670B4222015B2, DBA0F8FE46AD8D9B
// reference: E545D2491B75F7B7, 1BDE5ABD20055F26
// reference: 519CD67D608D1344, D9C174A4A54356AC
// reference: 1FC8293D38C1D471, D9C174A4A54356AC
// reference: 58970D47D63B12C5, 502AB780D80D09C1
// reference: 73EE421855E77011, E81D148B6EF003F8
// reference: 3DBABD580DABB724, E81D148B6EF003F8
// reference: 3DBABD58E2922465, E81D148B6EF003F8
// reference: 9E522B378F0F14FC, 3526EFD6EA584B4A
// reference: 2589AD90CF408BF6, 5E28DB645EED49B7
// reference: 32BC79DF8C3A06B9, 4028512EA840631E
// reference: 40A37A2AF12CAE76, 35CCCCDE75E2FF83
// reference: 7189F7733DCFDFFD, A40B5D829674D1F8
// reference: 3FDD08338ABA8B89, A40B5D829674D1F8
// reference: D186A7B19A63F3E0, 5E28DB645EED49B7
// reference: 88E78CBE6E6C2ADB, 4028512EA840631E
// shader: 8B30, 558A6C807844C0F3

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.r);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) - (1.0 - rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1 * 1.0, alpha_output_1 * 2.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_2 = byteround(clamp((vec3(1.0) - combiner_buffer.rgb) * (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 277AD2EAA944BD87, 558A6C807844C0F3
// program: 8AA3B6DF4767940E, 082670B4222015B2, 558A6C807844C0F3
// reference: 5BF8BEC6595AA0A9, 8AA3B6DF4767940E
// reference: 54C62F0A57FD814F, 49AB6B882020674A
// reference: 73EE4218FF0187DC, D0293423BD9EA1E7
// shader: 8B30, 5741FC947D667CFB

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb) * (texcolor0.rgb) + (const_color[0].rgb) * (vec3(1.0) - (texcolor0.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_1 = (last_tex_env_out.rgb);
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (texcolor2.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor1.rgb) * (const_color[2].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = (last_tex_env_out.rgb);
float alpha_output_5 = byteround(clamp((last_tex_env_out.a) * (const_color[5].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 55A22F7A1AA2C3FC, 5741FC947D667CFB
// program: D0293423BD9EA1E7, B80FA1B7F97410CD, 5741FC947D667CFB
// reference: 3DBABD580C39FA79, D0293423BD9EA1E7
// shader: 8B30, 5FF3DF19FAD860D6

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb) * (texcolor0.rgb) + (const_color[0].rgb) * (vec3(1.0) - (texcolor0.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.r) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_1 = (last_tex_env_out.rgb);
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (texcolor2.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor1.rgb) * (const_color[2].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = (last_tex_env_out.rgb);
float alpha_output_5 = byteround(clamp((last_tex_env_out.a) * (const_color[5].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 8BA8018AF3FA96C4, 5FF3DF19FAD860D6
// program: D0293423BD9EA1E7, B80FA1B7F97410CD, 5FF3DF19FAD860D6
// reference: 95072FBC595AA0A9, 8AA3B6DF4767940E
// shader: 8B30, 1430EF96707A019C

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.r) * (texcolor1.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_2 = byteround(clamp((vec3(1.0) - combiner_buffer.rgb) * (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: E73A4802B26CD5C1, 1430EF96707A019C
// program: 8AA3B6DF4767940E, 082670B4222015B2, 1430EF96707A019C
// reference: 1A92D04A0FB1467A, 49AB6B882020674A
// reference: EDE38F4365B4B011, D0293423BD9EA1E7
// reference: EDE38F4321F999C0, D0293423BD9EA1E7
// reference: 9A2ECF1D51C0B560, 70A370D21404144E
// program: 70A370D21404144E, 082670B4222015B2, 63A5270519B4AE20
// reference: F7394D2D595AA0A9, 8AA3B6DF4767940E
// reference: 9FD258F12D16A794, 5E28DB645EED49B7
// reference: C6B373FE20CE6491, 4028512EA840631E
// reference: 50B2C7E2089F90FD, 87E005DC9696CDE3
// reference: 050CCFD4BD17ECD5, 502AB780D80D09C1
// reference: 4B58309451BF4A65, 502AB780D80D09C1
// reference: 519CD67D7CCAD89C, D9C174A4A54356AC
// reference: 1FC8293D24861FA9, D9C174A4A54356AC
// shader: 8B31, 2E530FFFDA886761

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;
out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define fma_s(x, y, z) (mix(x * y, vec4(0.0), isnan(x * y)) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_19();
bool sub_19_55();
bool sub_55_65();
bool sub_65_79();
bool sub_79_129();
bool sub_84_102();
bool sub_102_110();
bool sub_127_128();
bool sub_129_185();
bool sub_134_152();
bool sub_152_163();
bool sub_183_184();
bool sub_185_212();
bool sub_187_192();
bool sub_192_211();
bool sub_195_201();
bool sub_201_210();
bool sub_202_206();
bool sub_206_209();
bool sub_212_236();
bool sub_214_218();
bool sub_218_235();
bool sub_219_233();
bool sub_222_229();
bool sub_229_232();
bool sub_233_234();
bool sub_236_252();
bool sub_238_242();
bool sub_242_251();
bool sub_243_249();
bool sub_249_250();
bool sub_252_260();
bool sub_254_255();
bool sub_255_259();
bool sub_256_257();
bool sub_257_258();
bool sub_260_267();
bool sub_267_273();
bool sub_273_4096();
bool sub_274_276();
bool sub_276_278();
bool sub_279_286();
bool sub_286_287();

bool exec_shader() {
    sub_273_4096();
    return true;
}

bool sub_0_19() {
    uint jmp_to = 0u;
    while (true) {
        switch (jmp_to) {
        case 0u: {
            reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
            reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
            reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
            reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
            reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
            reg_tmp6.x = rsq_s(reg_tmp6.x);
            reg_tmp7.x = rsq_s(reg_tmp7.x);
            reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            reg_tmp0 = uniforms.f[93].yxxx;
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            reg_tmp4 = mul_s(uniforms.f[94].xxxx, reg_tmp4);
            conditional_code = greaterThanEqual(uniforms.f[93].xx, reg_tmp4.xx);
            reg_tmp4 = vec4(rsq_s(reg_tmp4.x));
            reg_tmp5 = mul_s(uniforms.f[94].xxxx, reg_tmp14);
            if (conditional_code.x) {
                { jmp_to = 18u; break; }
            }
            reg_tmp0.z = rcp_s(reg_tmp4.x);
            reg_tmp0.xy = (mul_s(reg_tmp5, reg_tmp4)).xy;
        }
        case 18u: {
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_19_55() {
    uint jmp_to = 19u;
    while (true) {
        switch (jmp_to) {
        case 19u: {
            reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
            reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
            reg_tmp6.x = rsq_s(reg_tmp6.x);
            reg_tmp7.x = rsq_s(reg_tmp7.x);
            reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            reg_tmp13.xyz = (mul_s(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            reg_tmp11.xyz = (mul_s(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            reg_tmp0 = uniforms.f[93].yxxx;
            reg_tmp13.xyz = (mul_s(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            reg_tmp11.xyz = (mul_s(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            reg_tmp5 = mul_s(reg_tmp14.yzxx, reg_tmp13.zxyy);
            reg_tmp5 = fma_s(-reg_tmp13.yzxx, reg_tmp14.zxyy, reg_tmp5);
            reg_tmp5.w = dot_3(reg_tmp5.xyz, reg_tmp5.xyz);
            reg_tmp5.w = rsq_s(reg_tmp5.w);
            reg_tmp5 = mul_s(reg_tmp5, reg_tmp5.wwww);
            reg_tmp6.w = (reg_tmp14.zzzz + reg_tmp5.yyyy).w;
            reg_tmp13 = mul_s(reg_tmp5.yzxx, reg_tmp14.zxyy);
            reg_tmp13 = fma_s(-reg_tmp14.yzxx, reg_tmp5.zxyy, reg_tmp13);
            reg_tmp6.w = (reg_tmp13.xxxx + reg_tmp6).w;
            reg_tmp13.w = (reg_tmp5.zzzz).w;
            reg_tmp5.z = (reg_tmp13.xxxx).z;
            reg_tmp6.w = (uniforms.f[93].yyyy + reg_tmp6).w;
            reg_tmp14.w = (reg_tmp5.xxxx).w;
            reg_tmp5.x = (reg_tmp14.zzzz).x;
            conditional_code = lessThan(uniforms.f[94].zz, reg_tmp6.ww);
            reg_tmp6.x = (uniforms.f[93].yyyy).x;
            reg_tmp6.y = (-uniforms.f[93].yyyy).y;
            if (!conditional_code.x) {
                { jmp_to = 54u; break; }
            }
            reg_tmp7.xz = (reg_tmp13.wwyy + -reg_tmp14.yyww).xz;
            reg_tmp7.y = (reg_tmp14.xxxx + -reg_tmp13.zzzz).y;
            reg_tmp7.w = (reg_tmp6).w;
            reg_tmp6 = vec4(dot_s(reg_tmp7, reg_tmp7));
            reg_tmp6 = vec4(rsq_s(reg_tmp6.x));
            reg_tmp0 = mul_s(reg_tmp7, reg_tmp6);
        }
        case 54u: {
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_55_65() {
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    reg_tmp4.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_65_79() {
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    reg_tmp4.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp5.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp13.xyz);
    reg_tmp5.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp13.xyz);
    reg_tmp5.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp13.xyz);
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    reg_tmp11 = fma_s(reg_tmp1.wwww, reg_tmp5, reg_tmp11);
    return false;
}
bool sub_79_129() {
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    reg_tmp13.xyz = (vs_in_reg2).xyz;
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    if (uniforms.b[0]) {
        sub_84_102();
    } else {
        sub_102_110();
    }
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    {
        sub_0_19();
    }
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    vs_out_attr2 = -reg_tmp15;
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    if (all(conditional_code)) {
        sub_127_128();
    }
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_84_102() {
    reg_tmp7 = uniforms.f[93].xxxx;
    reg_tmp12 = uniforms.f[93].xxxx;
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    {
        sub_55_65();
    }
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    {
        sub_55_65();
    }
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    {
        sub_55_65();
    }
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    {
        sub_55_65();
    }
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    reg_tmp10 = reg_tmp7;
    return false;
}
bool sub_102_110() {
    reg_tmp7 = reg_tmp15;
    reg_tmp10.x = dot_s(uniforms.f[10], reg_tmp7);
    reg_tmp10.y = dot_s(uniforms.f[11], reg_tmp7);
    reg_tmp10.z = dot_s(uniforms.f[12], reg_tmp7);
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    reg_tmp12.x = dot_3(uniforms.f[10].xyz, reg_tmp14.xyz);
    reg_tmp12.y = dot_3(uniforms.f[11].xyz, reg_tmp14.xyz);
    reg_tmp12.z = dot_3(uniforms.f[12].xyz, reg_tmp14.xyz);
    return false;
}
bool sub_127_128() {
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_129_185() {
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    reg_tmp13.xyz = (vs_in_reg2).xyz;
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    if (uniforms.b[0]) {
        sub_134_152();
    } else {
        sub_152_163();
    }
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    reg_tmp13.x = dot_3(uniforms.f[90].xyz, reg_tmp11.xyz);
    reg_tmp13.y = dot_3(uniforms.f[91].xyz, reg_tmp11.xyz);
    reg_tmp13.z = dot_3(uniforms.f[92].xyz, reg_tmp11.xyz);
    {
        sub_19_55();
    }
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    vs_out_attr2 = -reg_tmp15;
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    if (all(conditional_code)) {
        sub_183_184();
    }
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_134_152() {
    reg_tmp7 = uniforms.f[93].xxxx;
    reg_tmp12 = uniforms.f[93].xxxx;
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    {
        sub_65_79();
    }
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    {
        sub_65_79();
    }
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    {
        sub_65_79();
    }
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    {
        sub_65_79();
    }
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    reg_tmp10 = reg_tmp7;
    return false;
}
bool sub_152_163() {
    reg_tmp7 = reg_tmp15;
    reg_tmp10.x = dot_s(uniforms.f[10], reg_tmp7);
    reg_tmp10.y = dot_s(uniforms.f[11], reg_tmp7);
    reg_tmp10.z = dot_s(uniforms.f[12], reg_tmp7);
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    reg_tmp12.x = dot_3(uniforms.f[10].xyz, reg_tmp14.xyz);
    reg_tmp12.y = dot_3(uniforms.f[11].xyz, reg_tmp14.xyz);
    reg_tmp12.z = dot_3(uniforms.f[12].xyz, reg_tmp14.xyz);
    reg_tmp11.x = dot_3(uniforms.f[10].xyz, reg_tmp13.xyz);
    reg_tmp11.y = dot_3(uniforms.f[11].xyz, reg_tmp13.xyz);
    reg_tmp11.z = dot_3(uniforms.f[12].xyz, reg_tmp13.xyz);
    return false;
}
bool sub_183_184() {
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_185_212() {
    reg_tmp0.xy = (uniforms.f[0].xxxx).xy;
    if (uniforms.b[2]) {
        sub_187_192();
    } else {
        sub_192_211();
    }
    return false;
}
bool sub_187_192() {
    {
        sub_252_260();
    }
    reg_tmp3.x = dot_s(uniforms.f[1].xywz, reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2].xywz, reg_tmp6);
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_192_211() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_195_201();
    } else {
        sub_201_210();
    }
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_195_201() {
    reg_tmp6 = reg_tmp10;
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    reg_tmp3.z = dot_s(uniforms.f[3], reg_tmp6);
    reg_tmp0.xy = (mul_s(uniforms.f[9].xyyy, reg_tmp3.zzzz)).xy;
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_201_210() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_202_206();
    } else {
        sub_206_209();
    }
    return false;
}
bool sub_202_206() {
    {
        sub_260_267();
    }
    reg_tmp3.x = dot_3(uniforms.f[1].xyz, reg_tmp6.xyz);
    reg_tmp3.y = dot_3(uniforms.f[2].xyz, reg_tmp6.xyz);
    reg_tmp3.z = dot_3(uniforms.f[3].xyz, reg_tmp6.xyz);
    return false;
}
bool sub_206_209() {
    {
        sub_267_273();
    }
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    return false;
}
bool sub_212_236() {
    reg_tmp0.xy = (uniforms.f[0].yyyy).xy;
    if (uniforms.b[3]) {
        sub_214_218();
    } else {
        sub_218_235();
    }
    return false;
}
bool sub_214_218() {
    {
        sub_252_260();
    }
    reg_tmp4.x = dot_s(uniforms.f[4].xywz, reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5].xywz, reg_tmp6);
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_218_235() {
    if (uniforms.b[5]) {
        sub_219_233();
    } else {
        sub_233_234();
    }
    return false;
}
bool sub_219_233() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_222_229();
    } else {
        sub_229_232();
    }
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_222_229() {
    reg_tmp6 = reg_tmp10;
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    reg_tmp4.z = dot_s(uniforms.f[6], reg_tmp6);
    reg_tmp6.w = rcp_s(reg_tmp4.z);
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    reg_tmp4.xy = (uniforms.f[9].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_229_232() {
    {
        sub_267_273();
    }
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    return false;
}
bool sub_233_234() {
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_236_252() {
    reg_tmp0.xy = (uniforms.f[0].zzzz).xy;
    if (uniforms.b[4]) {
        sub_238_242();
    } else {
        sub_242_251();
    }
    return false;
}
bool sub_238_242() {
    {
        sub_252_260();
    }
    reg_tmp5.x = dot_s(uniforms.f[7].xywz, reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8].xywz, reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_242_251() {
    if (uniforms.b[6]) {
        sub_243_249();
    } else {
        sub_249_250();
    }
    return false;
}
bool sub_243_249() {
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    {
        sub_267_273();
    }
    reg_tmp5.x = dot_s(uniforms.f[7], reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8], reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_249_250() {
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
bool sub_252_260() {
    conditional_code = equal(uniforms.f[93].yz, reg_tmp0.xy);
    if (all(not(conditional_code))) {
        sub_254_255();
    } else {
        sub_255_259();
    }
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_254_255() {
    reg_tmp6.xy = (vs_in_reg4.xyyy).xy;
    return false;
}
bool sub_255_259() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_256_257();
    } else {
        sub_257_258();
    }
    return false;
}
bool sub_256_257() {
    reg_tmp6.xy = (vs_in_reg5.xyyy).xy;
    return false;
}
bool sub_257_258() {
    reg_tmp6.xy = (vs_in_reg6.xyyy).xy;
    return false;
}
bool sub_260_267() {
    reg_tmp2 = -reg_tmp15;
    reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
    reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_267_273() {
    reg_tmp1 = reg_tmp14;
    reg_tmp2.w = dot_3(reg_tmp1.xyz, reg_tmp1.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp1 = mul_s(reg_tmp1, reg_tmp2.wwww);
    reg_tmp1 = mul_s(uniforms.f[94].xxxx, reg_tmp1);
    reg_tmp6.xy = (uniforms.f[94].xxxx + reg_tmp1.xyyy).xy;
    return false;
}
bool sub_273_4096() {
    if (uniforms.b[10]) {
        sub_274_276();
    } else {
        sub_276_278();
    }
    if (uniforms.b[1]) {
        sub_279_286();
    } else {
        sub_286_287();
    }
    vs_out_attr3 = reg_tmp2;
    {
        sub_185_212();
    }
    {
        sub_212_236();
    }
    {
        sub_236_252();
    }
    return true;
}
bool sub_274_276() {
    {
        sub_129_185();
    }
    return false;
}
bool sub_276_278() {
    {
        sub_79_129();
    }
    return false;
}
bool sub_279_286() {
    reg_tmp0 = vec4(dot_3(uniforms.f[83].xyz, reg_tmp12.xyz));
    reg_tmp0 = max(uniforms.f[93].xxxx, reg_tmp0);
    reg_tmp0 = mul_s(uniforms.f[84], reg_tmp0);
    reg_tmp0 = uniforms.f[85] + reg_tmp0;
    reg_tmp0.w = (uniforms.f[93].yyyy).w;
    reg_tmp1 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
    reg_tmp2 = mul_s(reg_tmp0, reg_tmp1);
    return false;
}
bool sub_286_287() {
    reg_tmp2 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
    return false;
}
// reference: 73EE42183940BEBA, 2E530FFFDA886761
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 26CF8128A3DDBB83
// reference: 3DBABD58610C798F, 2E530FFFDA886761
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 953385FED82E0FD1
// program: 2E530FFFDA886761, B80FA1B7F97410CD, E52C4E220978C964
// reference: 3DBABD588E35EACE, 2E530FFFDA886761
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 378438FF70532E82
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 9F25A997909124C1
// program: 2E530FFFDA886761, B80FA1B7F97410CD, F35E8CA2CAC182F7
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 168DA83A29634DCC
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 576E786439C2EA2F
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 1471721266F6CFF3
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 90EA57FA2E348842
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 1212B53523129C17
// program: 2E530FFFDA886761, B80FA1B7F97410CD, C9A23B908E5F8ABB
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 7E2D94A79BE7422B
// shader: 8B31, 91D55C04BB07EE32

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;
out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define fma_s(x, y, z) (mix(x * y, vec4(0.0), isnan(x * y)) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_19();
bool sub_19_29();
bool sub_29_90();
bool sub_33_51();
bool sub_51_59();
bool sub_88_89();
bool sub_90_117();
bool sub_92_97();
bool sub_97_116();
bool sub_100_106();
bool sub_106_115();
bool sub_107_111();
bool sub_111_114();
bool sub_117_141();
bool sub_119_123();
bool sub_123_140();
bool sub_124_138();
bool sub_127_134();
bool sub_134_137();
bool sub_138_139();
bool sub_141_157();
bool sub_143_147();
bool sub_147_156();
bool sub_148_154();
bool sub_154_155();
bool sub_157_165();
bool sub_159_160();
bool sub_160_164();
bool sub_161_162();
bool sub_162_163();
bool sub_165_172();
bool sub_172_178();
bool sub_178_4096();
bool sub_180_187();
bool sub_187_188();

bool exec_shader() {
    sub_178_4096();
    return true;
}

bool sub_0_19() {
    uint jmp_to = 0u;
    while (true) {
        switch (jmp_to) {
        case 0u: {
            reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
            reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
            reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
            reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
            reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
            reg_tmp6.x = rsq_s(reg_tmp6.x);
            reg_tmp7.x = rsq_s(reg_tmp7.x);
            reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            reg_tmp0 = uniforms.f[93].yxxx;
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            reg_tmp4 = mul_s(uniforms.f[94].xxxx, reg_tmp4);
            conditional_code = greaterThanEqual(uniforms.f[93].xx, reg_tmp4.xx);
            reg_tmp4 = vec4(rsq_s(reg_tmp4.x));
            reg_tmp5 = mul_s(uniforms.f[94].xxxx, reg_tmp14);
            if (conditional_code.x) {
                { jmp_to = 18u; break; }
            }
            reg_tmp0.z = rcp_s(reg_tmp4.x);
            reg_tmp0.xy = (mul_s(reg_tmp5, reg_tmp4)).xy;
        }
        case 18u: {
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_19_29() {
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    reg_tmp4.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_29_90() {
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    if (uniforms.b[0]) {
        sub_33_51();
    } else {
        sub_51_59();
    }
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    {
        sub_0_19();
    }
    vs_out_attr2 = -reg_tmp15;
    reg_tmp0.x = (uniforms.f[93].yyyy).x;
    address_registers.x = (ivec2(vs_in_reg3.xx)).x;
    reg_tmp0.x = (mul_s(uniforms.f[13 + address_registers.x].xxxx, reg_tmp0.xxxx)).x;
    address_registers.x = (ivec2(vs_in_reg3.yy)).x;
    reg_tmp0.x = (mul_s(uniforms.f[13 + address_registers.x].yyyy, reg_tmp0.xxxx)).x;
    address_registers.x = (ivec2(vs_in_reg3.zz)).x;
    reg_tmp0.x = (mul_s(uniforms.f[13 + address_registers.x].zzzz, reg_tmp0.xxxx)).x;
    address_registers.x = (ivec2(vs_in_reg3.ww)).x;
    reg_tmp0.x = (mul_s(uniforms.f[13 + address_registers.x].wwww, reg_tmp0.xxxx)).x;
    reg_tmp15.xyz = (mul_s(reg_tmp15.xyzz, reg_tmp0.xxxx)).xyz;
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    if (all(conditional_code)) {
        sub_88_89();
    }
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_33_51() {
    reg_tmp7 = uniforms.f[93].xxxx;
    reg_tmp12 = uniforms.f[93].xxxx;
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    {
        sub_19_29();
    }
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    {
        sub_19_29();
    }
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    {
        sub_19_29();
    }
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    {
        sub_19_29();
    }
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    reg_tmp10 = reg_tmp7;
    return false;
}
bool sub_51_59() {
    reg_tmp7 = reg_tmp15;
    reg_tmp10.x = dot_s(uniforms.f[10], reg_tmp7);
    reg_tmp10.y = dot_s(uniforms.f[11], reg_tmp7);
    reg_tmp10.z = dot_s(uniforms.f[12], reg_tmp7);
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    reg_tmp12.x = dot_3(uniforms.f[10].xyz, reg_tmp14.xyz);
    reg_tmp12.y = dot_3(uniforms.f[11].xyz, reg_tmp14.xyz);
    reg_tmp12.z = dot_3(uniforms.f[12].xyz, reg_tmp14.xyz);
    return false;
}
bool sub_88_89() {
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_90_117() {
    reg_tmp0.xy = (uniforms.f[0].xxxx).xy;
    if (uniforms.b[2]) {
        sub_92_97();
    } else {
        sub_97_116();
    }
    return false;
}
bool sub_92_97() {
    {
        sub_157_165();
    }
    reg_tmp3.x = dot_s(uniforms.f[1].xywz, reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2].xywz, reg_tmp6);
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_97_116() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_100_106();
    } else {
        sub_106_115();
    }
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_100_106() {
    reg_tmp6 = reg_tmp10;
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    reg_tmp3.z = dot_s(uniforms.f[3], reg_tmp6);
    reg_tmp0.xy = (mul_s(uniforms.f[9].xyyy, reg_tmp3.zzzz)).xy;
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_106_115() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_107_111();
    } else {
        sub_111_114();
    }
    return false;
}
bool sub_107_111() {
    {
        sub_165_172();
    }
    reg_tmp3.x = dot_3(uniforms.f[1].xyz, reg_tmp6.xyz);
    reg_tmp3.y = dot_3(uniforms.f[2].xyz, reg_tmp6.xyz);
    reg_tmp3.z = dot_3(uniforms.f[3].xyz, reg_tmp6.xyz);
    return false;
}
bool sub_111_114() {
    {
        sub_172_178();
    }
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    return false;
}
bool sub_117_141() {
    reg_tmp0.xy = (uniforms.f[0].yyyy).xy;
    if (uniforms.b[3]) {
        sub_119_123();
    } else {
        sub_123_140();
    }
    return false;
}
bool sub_119_123() {
    {
        sub_157_165();
    }
    reg_tmp4.x = dot_s(uniforms.f[4].xywz, reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5].xywz, reg_tmp6);
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_123_140() {
    if (uniforms.b[5]) {
        sub_124_138();
    } else {
        sub_138_139();
    }
    return false;
}
bool sub_124_138() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_127_134();
    } else {
        sub_134_137();
    }
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_127_134() {
    reg_tmp6 = reg_tmp10;
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    reg_tmp4.z = dot_s(uniforms.f[6], reg_tmp6);
    reg_tmp6.w = rcp_s(reg_tmp4.z);
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    reg_tmp4.xy = (uniforms.f[9].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_134_137() {
    {
        sub_172_178();
    }
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    return false;
}
bool sub_138_139() {
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_141_157() {
    reg_tmp0.xy = (uniforms.f[0].zzzz).xy;
    if (uniforms.b[4]) {
        sub_143_147();
    } else {
        sub_147_156();
    }
    return false;
}
bool sub_143_147() {
    {
        sub_157_165();
    }
    reg_tmp5.x = dot_s(uniforms.f[7].xywz, reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8].xywz, reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_147_156() {
    if (uniforms.b[6]) {
        sub_148_154();
    } else {
        sub_154_155();
    }
    return false;
}
bool sub_148_154() {
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    {
        sub_172_178();
    }
    reg_tmp5.x = dot_s(uniforms.f[7], reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8], reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_154_155() {
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
bool sub_157_165() {
    conditional_code = equal(uniforms.f[93].yz, reg_tmp0.xy);
    if (all(not(conditional_code))) {
        sub_159_160();
    } else {
        sub_160_164();
    }
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_159_160() {
    reg_tmp6.xy = (vs_in_reg4.xyyy).xy;
    return false;
}
bool sub_160_164() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_161_162();
    } else {
        sub_162_163();
    }
    return false;
}
bool sub_161_162() {
    reg_tmp6.xy = (vs_in_reg5.xyyy).xy;
    return false;
}
bool sub_162_163() {
    reg_tmp6.xy = (vs_in_reg6.xyyy).xy;
    return false;
}
bool sub_165_172() {
    reg_tmp2 = -reg_tmp15;
    reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
    reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_172_178() {
    reg_tmp1 = reg_tmp14;
    reg_tmp2.w = dot_3(reg_tmp1.xyz, reg_tmp1.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp1 = mul_s(reg_tmp1, reg_tmp2.wwww);
    reg_tmp1 = mul_s(uniforms.f[94].xxxx, reg_tmp1);
    reg_tmp6.xy = (uniforms.f[94].xxxx + reg_tmp1.xyyy).xy;
    return false;
}
bool sub_178_4096() {
    {
        sub_29_90();
    }
    if (uniforms.b[1]) {
        sub_180_187();
    } else {
        sub_187_188();
    }
    vs_out_attr3 = reg_tmp2;
    {
        sub_90_117();
    }
    {
        sub_117_141();
    }
    {
        sub_141_157();
    }
    return true;
}
bool sub_180_187() {
    reg_tmp0 = vec4(dot_3(uniforms.f[83].xyz, reg_tmp12.xyz));
    reg_tmp0 = max(uniforms.f[93].xxxx, reg_tmp0);
    reg_tmp0 = mul_s(uniforms.f[84], reg_tmp0);
    reg_tmp0 = uniforms.f[85] + reg_tmp0;
    reg_tmp0.w = (uniforms.f[93].yyyy).w;
    reg_tmp1 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
    reg_tmp2 = mul_s(reg_tmp0, reg_tmp1);
    return false;
}
bool sub_187_188() {
    reg_tmp2 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
    return false;
}
// reference: 50B2C7E29DEF4468, 91D55C04BB07EE32
// program: 91D55C04BB07EE32, B80FA1B7F97410CD, 9342C6596F83F706
// program: 2E530FFFDA886761, B80FA1B7F97410CD, D02B1E1378BD97CF
// program: 2E530FFFDA886761, B80FA1B7F97410CD, B78314A585D12D9C
// program: 2E530FFFDA886761, B80FA1B7F97410CD, DEC6EAEA57FA4325
// program: 2E530FFFDA886761, B80FA1B7F97410CD, D4C50B709583D191
// program: 2E530FFFDA886761, B80FA1B7F97410CD, B20F7E72A7330A13
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 48065A05481CB4B8
// program: 2E530FFFDA886761, B80FA1B7F97410CD, BB80E4A110994B48
// program: 2E530FFFDA886761, B80FA1B7F97410CD, EAAC665924781109
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 0656C780E79F2203
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 31E556E9A7729BF4
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 6C66577708AE1E87
// program: 2E530FFFDA886761, B80FA1B7F97410CD, FC7222C50C6F5038
// program: 2E530FFFDA886761, B80FA1B7F97410CD, D1B1A073730D724F
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 790FB95CC0B11076
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 037898F85F34DE95
// shader: 8B31, 46E991DEB658A5A9

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;
out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define fma_s(x, y, z) (mix(x * y, vec4(0.0), isnan(x * y)) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_76_103();
bool sub_78_83();
bool sub_83_102();
bool sub_86_92();
bool sub_92_101();
bool sub_93_97();
bool sub_97_100();
bool sub_103_127();
bool sub_105_109();
bool sub_109_126();
bool sub_110_124();
bool sub_113_120();
bool sub_120_123();
bool sub_124_125();
bool sub_127_143();
bool sub_129_133();
bool sub_133_142();
bool sub_134_140();
bool sub_140_141();
bool sub_143_151();
bool sub_145_146();
bool sub_146_150();
bool sub_147_148();
bool sub_148_149();
bool sub_151_158();
bool sub_158_166();
bool sub_166_4096();

bool exec_shader() {
    sub_166_4096();
    return true;
}

bool sub_76_103() {
    reg_tmp0.xy = (uniforms.f[0].xxxx).xy;
    if (uniforms.b[2]) {
        sub_78_83();
    } else {
        sub_83_102();
    }
    return false;
}
bool sub_78_83() {
    {
        sub_143_151();
    }
    reg_tmp3.x = dot_s(uniforms.f[1].xywz, reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2].xywz, reg_tmp6);
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_83_102() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_86_92();
    } else {
        sub_92_101();
    }
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_86_92() {
    reg_tmp6 = reg_tmp10;
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    reg_tmp3.z = dot_s(uniforms.f[3], reg_tmp6);
    reg_tmp0.xy = (mul_s(uniforms.f[9].xyyy, reg_tmp3.zzzz)).xy;
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_92_101() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_93_97();
    } else {
        sub_97_100();
    }
    return false;
}
bool sub_93_97() {
    {
        sub_151_158();
    }
    reg_tmp3.x = dot_3(uniforms.f[1].xyz, reg_tmp6.xyz);
    reg_tmp3.y = dot_3(uniforms.f[2].xyz, reg_tmp6.xyz);
    reg_tmp3.z = dot_3(uniforms.f[3].xyz, reg_tmp6.xyz);
    return false;
}
bool sub_97_100() {
    {
        sub_158_166();
    }
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    return false;
}
bool sub_103_127() {
    reg_tmp0.xy = (uniforms.f[0].yyyy).xy;
    if (uniforms.b[3]) {
        sub_105_109();
    } else {
        sub_109_126();
    }
    return false;
}
bool sub_105_109() {
    {
        sub_143_151();
    }
    reg_tmp4.x = dot_s(uniforms.f[4].xywz, reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5].xywz, reg_tmp6);
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_109_126() {
    if (uniforms.b[5]) {
        sub_110_124();
    } else {
        sub_124_125();
    }
    return false;
}
bool sub_110_124() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_113_120();
    } else {
        sub_120_123();
    }
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_113_120() {
    reg_tmp6 = reg_tmp10;
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    reg_tmp4.z = dot_s(uniforms.f[6], reg_tmp6);
    reg_tmp6.w = rcp_s(reg_tmp4.z);
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    reg_tmp4.xy = (uniforms.f[9].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_120_123() {
    {
        sub_158_166();
    }
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    return false;
}
bool sub_124_125() {
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_127_143() {
    reg_tmp0.xy = (uniforms.f[0].zzzz).xy;
    if (uniforms.b[4]) {
        sub_129_133();
    } else {
        sub_133_142();
    }
    return false;
}
bool sub_129_133() {
    {
        sub_143_151();
    }
    reg_tmp5.x = dot_s(uniforms.f[7].xywz, reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8].xywz, reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_133_142() {
    if (uniforms.b[6]) {
        sub_134_140();
    } else {
        sub_140_141();
    }
    return false;
}
bool sub_134_140() {
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    {
        sub_158_166();
    }
    reg_tmp5.x = dot_s(uniforms.f[7], reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8], reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_140_141() {
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
bool sub_143_151() {
    conditional_code = equal(uniforms.f[93].yz, reg_tmp0.xy);
    if (all(not(conditional_code))) {
        sub_145_146();
    } else {
        sub_146_150();
    }
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_145_146() {
    reg_tmp6.xy = (vs_in_reg4.xyyy).xy;
    return false;
}
bool sub_146_150() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_147_148();
    } else {
        sub_148_149();
    }
    return false;
}
bool sub_147_148() {
    reg_tmp6.xy = (vs_in_reg5.xyyy).xy;
    return false;
}
bool sub_148_149() {
    reg_tmp6.xy = (vs_in_reg6.xyyy).xy;
    return false;
}
bool sub_151_158() {
    reg_tmp2 = -reg_tmp15;
    reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
    reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_158_166() {
    {
        sub_151_158();
    }
    reg_tmp1 = reg_tmp6;
    reg_tmp1.z = (uniforms.f[93].yyyy + reg_tmp1.zzzz).z;
    reg_tmp1 = vec4(dot_3(reg_tmp1.xyz, reg_tmp1.xyz));
    reg_tmp2 = vec4(rsq_s(reg_tmp1.x));
    reg_tmp2 = mul_s(uniforms.f[94].xxxx, reg_tmp2);
    reg_tmp6.xy = (mul_s(reg_tmp6.xyyy, reg_tmp2)).xy;
    reg_tmp6.xy = (uniforms.f[94].xxxx + reg_tmp6.xyyy).xy;
    return false;
}
bool sub_166_4096() {
    reg_tmp0 = vs_in_reg0;
    reg_tmp0.z = (uniforms.f[93].xxxx).z;
    reg_tmp0.w = (uniforms.f[93].yyyy).w;
    vs_out_attr0 = reg_tmp0;
    vs_out_attr2 = reg_tmp0;
    vs_out_attr1 = reg_tmp0;
    vs_out_attr3 = uniforms.f[93].yyyy;
    {
        sub_76_103();
    }
    {
        sub_103_127();
    }
    {
        sub_127_143();
    }
    return true;
}
// reference: 050CCFD428673840, 46E991DEB658A5A9
// program: 46E991DEB658A5A9, B80FA1B7F97410CD, 91931D139F54748D
// program: 46E991DEB658A5A9, B80FA1B7F97410CD, 5FACCC9E3E0584D2
// reference: 4B583094C4CF9EF0, 46E991DEB658A5A9
// shader: 8B31, 81B0676B862CF405

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define fma_s(x, y, z) (mix(x * y, vec4(0.0), isnan(x * y)) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_97();
bool sub_5_50();
bool sub_12_13();
bool sub_20_21();
bool sub_22_24();
bool sub_31_32();
bool sub_33_34();
bool sub_40_41();
bool sub_42_43();
bool sub_48_49();
bool sub_52_69();
bool sub_57_60();
bool sub_60_68();
bool sub_62_63();
bool sub_63_64();
bool sub_65_66();
bool sub_66_67();
bool sub_69_96();
bool sub_70_93();
bool sub_74_79();
bool sub_79_92();
bool sub_83_87();
bool sub_84_85();
bool sub_85_86();
bool sub_87_91();
bool sub_88_89();
bool sub_89_90();
bool sub_93_95();
bool sub_97_109();
bool sub_109_4096();
bool sub_125_127();
bool sub_127_149();
bool sub_137_141();
bool sub_158_160();
bool sub_161_162();
bool sub_171_173();
bool sub_174_175();
bool sub_184_186();
bool sub_187_188();
bool sub_198_207();
bool sub_215_223();
bool sub_223_227();

bool exec_shader() {
    sub_109_4096();
    return true;
}

bool sub_0_97() {
    reg_tmp13 = floor(reg_tmp0.xxxx);
    reg_tmp13 = reg_tmp0.xxxx + -reg_tmp13;
    address_registers.y = (ivec2(reg_tmp11.zz)).y;
    conditional_code = lessThanEqual(uniforms.f[5].ww, reg_tmp13.xx);
    if (conditional_code.x) {
        sub_5_50();
    }
    conditional_code = lessThanEqual(uniforms.f[5].yy, reg_tmp11.xy);
    if (!conditional_code.y) {
        sub_52_69();
    } else {
        sub_69_96();
    }
    return false;
}
bool sub_5_50() {
    reg_tmp12.xy = (uniforms.f[5].xyyy + vs_in_reg0.zwww).xy;
    reg_tmp14.xy = (uniforms.f[6].wzzz).xy;
    reg_tmp13.xy = (mul_s(uniforms.f[5].zzzz, reg_tmp0.xxxx)).xy;
    reg_tmp13.y = (floor(reg_tmp13)).y;
    reg_tmp13.x = (reg_tmp13.xxxx + -reg_tmp13.yyyy).x;
    conditional_code = lessThanEqual(uniforms.f[5].ww, reg_tmp13.xx);
    if (conditional_code.x) {
        sub_12_13();
    }
    reg_tmp14.xy = (mul_s(reg_tmp14, reg_tmp2)).xy;
    reg_tmp13.x = (mul_s(uniforms.f[5].zzzz, reg_tmp13.xxxx)).x;
    reg_tmp13 = mul_s(uniforms.f[5].zyzy, reg_tmp13.xxxx);
    reg_tmp13.zw = (floor(reg_tmp13)).zw;
    reg_tmp13.xy = (reg_tmp13.xyyy + -reg_tmp13.zwww).xy;
    conditional_code = lessThanEqual(uniforms.f[5].ww, reg_tmp13.xy);
    if (conditional_code.y) {
        sub_20_21();
    }
    if (conditional_code.x) {
        sub_22_24();
    }
    reg_tmp14.xy = (uniforms.f[5].yyyy + -reg_tmp14.xyyy).xy;
    reg_tmp13.x = (mul_s(uniforms.f[5].zzzz, reg_tmp13.xxxx)).x;
    reg_tmp13 = mul_s(uniforms.f[5].zyzy, reg_tmp13.xxxx);
    reg_tmp13.zw = (floor(reg_tmp13)).zw;
    reg_tmp13.xy = (reg_tmp13.xyyy + -reg_tmp13.zwww).xy;
    conditional_code = lessThanEqual(uniforms.f[5].ww, reg_tmp13.xy);
    if (conditional_code.y) {
        sub_31_32();
    }
    if (conditional_code.x) {
        sub_33_34();
    }
    reg_tmp13.x = (mul_s(uniforms.f[5].zzzz, reg_tmp13.xxxx)).x;
    reg_tmp13 = mul_s(uniforms.f[5].zyzy, reg_tmp13.xxxx);
    reg_tmp13.zw = (floor(reg_tmp13)).zw;
    reg_tmp13.xy = (reg_tmp13.xyyy + -reg_tmp13.zwww).xy;
    conditional_code = lessThanEqual(uniforms.f[5].ww, reg_tmp13.xy);
    if (conditional_code.y) {
        sub_40_41();
    }
    if (conditional_code.x) {
        sub_42_43();
    }
    reg_tmp13.xy = (mul_s(uniforms.f[5].zzzz, reg_tmp0.xxxx)).xy;
    reg_tmp13.y = (floor(reg_tmp13)).y;
    reg_tmp13.x = (reg_tmp13.xxxx + -reg_tmp13.yyyy).x;
    conditional_code = lessThanEqual(uniforms.f[5].ww, reg_tmp13.xx);
    if (conditional_code.x) {
        sub_48_49();
    }
    reg_tmp12.y = (uniforms.f[5].yyyy + -reg_tmp12.yyyy).y;
    return false;
}
bool sub_12_13() {
    reg_tmp14.xy = (reg_tmp14.yxxx).xy;
    return false;
}
bool sub_20_21() {
    reg_tmp12.x = (mul_s(reg_tmp12.xxxx, reg_tmp14.xxxx)).x;
    return false;
}
bool sub_22_24() {
    reg_tmp12.y = (fma_s(reg_tmp12.yyyy, reg_tmp14.yyyy, uniforms.f[5].yyyy)).y;
    reg_tmp12.y = (reg_tmp12.yyyy + -reg_tmp14.yyyy).y;
    return false;
}
bool sub_31_32() {
    reg_tmp12.x = (reg_tmp12.xxxx + reg_tmp14.xxxx).x;
    return false;
}
bool sub_33_34() {
    reg_tmp12.y = (reg_tmp12.yyyy + -reg_tmp14.yyyy).y;
    return false;
}
bool sub_40_41() {
    reg_tmp12.x = (uniforms.f[5].yyyy + -reg_tmp12.xxxx).x;
    return false;
}
bool sub_42_43() {
    reg_tmp12.y = (uniforms.f[5].yyyy + -reg_tmp12.yyyy).y;
    return false;
}
bool sub_48_49() {
    reg_tmp12.xy = (uniforms.f[5].yyyy + -reg_tmp12.yxxx).xy;
    return false;
}
bool sub_52_69() {
    reg_tmp13.x = (floor(reg_tmp0.xxxx)).x;
    reg_tmp13.x = (reg_tmp0.xxxx + -reg_tmp13).x;
    conditional_code = lessThanEqual(uniforms.f[5].ww, reg_tmp13.xx);
    reg_tmp13 = uniforms.f[32 + address_registers.y].wzyx;
    if (conditional_code.x) {
        sub_57_60();
    } else {
        sub_60_68();
    }
    reg_tmp11.z = (uniforms.f[5].yyyy + reg_tmp11.zzzz).z;
    return false;
}
bool sub_57_60() {
    reg_tmp11.xy = (fma_s(reg_tmp12.xyyy, reg_tmp13.xyyy, reg_tmp13.zwww)).xy;
    reg_tmp11.xy = (mul_s(reg_tmp11.xyyy, reg_tmp14.zwww)).xy;
    reg_tmp11.y = (uniforms.f[5].yyyy + -reg_tmp11.yyyy).y;
    return false;
}
bool sub_60_68() {
    conditional_code = notEqual(uniforms.f[5].xx, vs_in_reg0.zw);
    if (!conditional_code.x) {
        sub_62_63();
    } else {
        sub_63_64();
    }
    if (!conditional_code.y) {
        sub_65_66();
    } else {
        sub_66_67();
    }
    return false;
}
bool sub_62_63() {
    reg_tmp11.x = (reg_tmp13.xxxx).x;
    return false;
}
bool sub_63_64() {
    reg_tmp11.x = (reg_tmp13.zzzz).x;
    return false;
}
bool sub_65_66() {
    reg_tmp11.y = (reg_tmp13.yyyy).y;
    return false;
}
bool sub_66_67() {
    reg_tmp11.y = (reg_tmp13.wwww).y;
    return false;
}
bool sub_69_96() {
    if (!conditional_code.x) {
        sub_70_93();
    } else {
        sub_93_95();
    }
    reg_tmp11.z = (uniforms.f[5].zzzz + reg_tmp11.zzzz).z;
    return false;
}
bool sub_70_93() {
    reg_tmp13.x = (floor(reg_tmp0.xxxx)).x;
    reg_tmp13.x = (reg_tmp0.xxxx + -reg_tmp13).x;
    conditional_code = lessThanEqual(uniforms.f[5].ww, reg_tmp13.xx);
    if (conditional_code.x) {
        sub_74_79();
    } else {
        sub_79_92();
    }
    return false;
}
bool sub_74_79() {
    reg_tmp12.zw = (uniforms.f[5].xxxy).zw;
    reg_tmp11.x = dot_s(uniforms.f[32 + address_registers.y].wzyx, reg_tmp12);
    reg_tmp11.y = dot_s(uniforms.f[33 + address_registers.y].wzyx, reg_tmp12);
    reg_tmp11.xy = (mul_s(reg_tmp11.xyyy, reg_tmp14.zwww)).xy;
    reg_tmp11.y = (uniforms.f[5].yyyy + -reg_tmp11.yyyy).y;
    return false;
}
bool sub_79_92() {
    reg_tmp14 = uniforms.f[32 + address_registers.y].wzyx;
    reg_tmp13 = uniforms.f[33 + address_registers.y].wzyx;
    conditional_code = notEqual(uniforms.f[5].xx, vs_in_reg0.zw);
    if (!conditional_code.y) {
        sub_83_87();
    } else {
        sub_87_91();
    }
    return false;
}
bool sub_83_87() {
    if (!conditional_code.x) {
        sub_84_85();
    } else {
        sub_85_86();
    }
    return false;
}
bool sub_84_85() {
    reg_tmp11.xy = (reg_tmp14.xyyy).xy;
    return false;
}
bool sub_85_86() {
    reg_tmp11.xy = (reg_tmp13.zwww).xy;
    return false;
}
bool sub_87_91() {
    if (!conditional_code.x) {
        sub_88_89();
    } else {
        sub_89_90();
    }
    return false;
}
bool sub_88_89() {
    reg_tmp11.xy = (reg_tmp13.xyyy).xy;
    return false;
}
bool sub_89_90() {
    reg_tmp11.xy = (reg_tmp14.zwww).xy;
    return false;
}
bool sub_93_95() {
    reg_tmp11.x = dot_s(uniforms.f[32 + address_registers.y].wzyx, reg_tmp1);
    reg_tmp11.y = dot_s(uniforms.f[33 + address_registers.y].wzyx, reg_tmp1);
    return false;
}
bool sub_97_109() {
    uint jmp_to = 97u;
    while (true) {
        switch (jmp_to) {
        case 97u: {
            reg_tmp3.x = dot_s(uniforms.f[32 + address_registers.x].wzyx, reg_tmp1);
            reg_tmp3.y = dot_s(uniforms.f[33 + address_registers.x].wzyx, reg_tmp1);
            reg_tmp3.z = dot_s(uniforms.f[34 + address_registers.x].wzyx, reg_tmp1);
            reg_tmp3.w = (reg_tmp1.wwww).w;
            reg_tmp11 = uniforms.f[4].wzyx;
            reg_tmp11.z = (-uniforms.f[34 + address_registers.x].xxxx + reg_tmp11.zzzz).z;
            conditional_code.x = uniforms.f[5].xxxx.x != reg_tmp11.xzzz.x;
            conditional_code.y = uniforms.f[5].xxxx.y < reg_tmp11.xzzz.y;
            if (any(not(conditional_code))) {
                { jmp_to = 108u; break; }
            }
            reg_tmp11.z = rcp_s(reg_tmp11.z);
            reg_tmp3.x = (reg_tmp3.xxxx + reg_tmp11.xxxx).x;
            reg_tmp3.x = (fma_s(-reg_tmp11.yyyy, reg_tmp11.zzzz, reg_tmp3.xxxx)).x;
        }
        case 108u: {
        }
        default: return false;
        }
    }
    return false;
}
bool sub_109_4096() {
    uint jmp_to = 109u;
    while (true) {
        switch (jmp_to) {
        case 109u: {
            address_registers.x = (ivec2(vs_in_reg0.xx)).x;
            reg_tmp0 = uniforms.f[9 + address_registers.x].wzyx;
            reg_tmp1.xy = (vs_in_reg0.zwzw).xy;
            reg_tmp1.zw = (uniforms.f[5].xyxy).zw;
            address_registers.xy = ivec2(reg_tmp0.xy);
            reg_tmp2 = uniforms.f[32 + address_registers.y].wzyx;
            if (uniforms.b[0]) {
                { jmp_to = 191u; break; }
            }
            reg_tmp4 = uniforms.f[31 + address_registers.x].wzyx;
            reg_tmp1.xy = (fma_s(reg_tmp1.xyyy, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
            {
                sub_97_109();
            }
            vs_out_attr0.x = dot_s(uniforms.f[0].wzyx, reg_tmp3);
            vs_out_attr0.y = dot_s(uniforms.f[1].wzyx, reg_tmp3);
            vs_out_attr0.z = dot_s(uniforms.f[2].wzyx, reg_tmp3);
            vs_out_attr0.w = dot_s(uniforms.f[3].wzyx, reg_tmp3);
            conditional_code = greaterThanEqual(uniforms.f[5].yy, reg_tmp0.ww);
            if (all(conditional_code)) {
                sub_125_127();
            } else {
                sub_127_149();
            }
            reg_tmp11.z = (reg_tmp0.zzzz).z;
            reg_tmp9 = mul_s(uniforms.f[5].zyzy, reg_tmp0.zzzz);
            reg_tmp9.xy = (floor(reg_tmp9)).xy;
            reg_tmp9.xy = (reg_tmp9.zwww + -reg_tmp9.xyyy).xy;
            reg_tmp9 = mul_s(uniforms.f[5].zzzz, reg_tmp9);
            reg_tmp14 = uniforms.f[6].wzyx;
            reg_tmp11.xy = (reg_tmp9.xyyy).xy;
            {
                sub_0_97();
            }
            if (uniforms.b[1]) {
                sub_158_160();
            }
            if (uniforms.b[2]) {
                sub_161_162();
            }
            vs_out_attr2 = reg_tmp11.xyyy;
            reg_tmp9 = mul_s(uniforms.f[5].zyzy, reg_tmp9.xxxx);
            reg_tmp9.xy = (floor(reg_tmp9)).xy;
            reg_tmp9.xy = (reg_tmp9.zwww + -reg_tmp9.xyyy).xy;
            reg_tmp9 = mul_s(uniforms.f[5].zzzz, reg_tmp9);
            reg_tmp14 = uniforms.f[7].wzyx;
            reg_tmp11.xy = (reg_tmp9.xyyy).xy;
            {
                sub_0_97();
            }
            if (uniforms.b[3]) {
                sub_171_173();
            }
            if (uniforms.b[4]) {
                sub_174_175();
            }
            vs_out_attr3 = reg_tmp11.xyyy;
            reg_tmp9 = mul_s(uniforms.f[5].zyzy, reg_tmp9.xxxx);
            reg_tmp9.xy = (floor(reg_tmp9)).xy;
            reg_tmp9.xy = (reg_tmp9.zwww + -reg_tmp9.xyyy).xy;
            reg_tmp9 = mul_s(uniforms.f[5].zzzz, reg_tmp9);
            reg_tmp14 = uniforms.f[8].wzyx;
            reg_tmp11.xy = (reg_tmp9.xyyy).xy;
            {
                sub_0_97();
            }
            if (uniforms.b[5]) {
                sub_184_186();
            }
            if (uniforms.b[6]) {
                sub_187_188();
            }
            vs_out_attr4 = reg_tmp11.xyyy;
            return true;
        }
        case 191u: {
            reg_tmp2.w = (reg_tmp2.wwww + reg_tmp2.yyyy).w;
            reg_tmp1.y = (-uniforms.f[5].yyyy + -reg_tmp1.yyyy).y;
            reg_tmp13.xy = (mul_s(uniforms.f[36 + address_registers.x].wzzz, reg_tmp2.xyyy)).xy;
            reg_tmp11.x = (mul_s(uniforms.f[35 + address_registers.x].wwww, -reg_tmp1.yyyy)).x;
            reg_tmp1.xy = (mul_s(reg_tmp1.xyyy, reg_tmp13.xyyy)).xy;
            reg_tmp1.x = (reg_tmp1.xxxx + reg_tmp11.xxxx).x;
            if (uniforms.b[1]) {
                sub_198_207();
            }
            reg_tmp1.xy = (reg_tmp1.xyyy + reg_tmp2.zwww).xy;
            reg_tmp1.xy = (uniforms.f[36 + address_registers.x].yxxx + reg_tmp1.xyyy).xy;
            {
                sub_97_109();
            }
            vs_out_attr0.x = dot_s(uniforms.f[0].wzyx, reg_tmp3);
            vs_out_attr0.y = dot_s(uniforms.f[1].wzyx, reg_tmp3);
            vs_out_attr0.z = dot_s(uniforms.f[2].wzyx, reg_tmp3);
            vs_out_attr0.w = dot_s(uniforms.f[3].wzyx, reg_tmp3);
            if (uniforms.b[2]) {
                sub_215_223();
            } else {
                sub_223_227();
            }
            reg_tmp8 = reg_tmp8 + -reg_tmp7;
            vs_out_attr1 = fma_s(reg_tmp8, reg_tmp11.yyyy, reg_tmp7);
            reg_tmp9.xy = (mul_s(uniforms.f[32 + address_registers.x].yxxx, reg_tmp11)).xy;
            reg_tmp11.zw = (vec4(lessThan(reg_tmp11, uniforms.f[5].yyyy))).zw;
            reg_tmp9.xy = (fma_s(reg_tmp11.zwww, uniforms.f[32 + address_registers.x].wzzz, reg_tmp9.xyyy)).xy;
            reg_tmp9.y = (uniforms.f[5].yyyy + -reg_tmp9.yyyy).y;
            vs_out_attr2 = reg_tmp9;
            vs_out_attr3 = reg_tmp9;
            vs_out_attr4 = reg_tmp9;
            return true;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_125_127() {
    vs_out_attr1.xyz = (uniforms.f[5].yyyy).xyz;
    vs_out_attr1.w = (reg_tmp0.wwww).w;
    return false;
}
bool sub_127_149() {
    address_registers.y = (ivec2(reg_tmp0.ww)).y;
    reg_tmp7 = uniforms.f[32 + address_registers.y].wzyx;
    reg_tmp8 = uniforms.f[33 + address_registers.y].wzyx;
    reg_tmp9 = uniforms.f[34 + address_registers.y].wzyx;
    reg_tmp10 = uniforms.f[35 + address_registers.y].wzyx;
    reg_tmp11.xy = (vs_in_reg0.zwww).xy;
    reg_tmp14.x = (floor(reg_tmp0.yyyy)).x;
    reg_tmp14.x = (reg_tmp0.yyyy + -reg_tmp14.xxxx).x;
    conditional_code = lessThanEqual(uniforms.f[5].ww, reg_tmp14.xx);
    if (conditional_code.x) {
        sub_137_141();
    }
    reg_tmp11.xy = (abs(reg_tmp11.xyyy)).xy;
    reg_tmp8 = reg_tmp8 + -reg_tmp7;
    reg_tmp8 = fma_s(reg_tmp8, reg_tmp11.xxxx, reg_tmp7);
    reg_tmp10 = reg_tmp10 + -reg_tmp9;
    reg_tmp10 = fma_s(reg_tmp10, reg_tmp11.xxxx, reg_tmp9);
    reg_tmp10 = reg_tmp10 + -reg_tmp8;
    reg_tmp10 = fma_s(reg_tmp10, reg_tmp11.yyyy, reg_tmp8);
    vs_out_attr1 = reg_tmp10;
    return false;
}
bool sub_137_141() {
    reg_tmp11.z = rcp_s(reg_tmp4.x);
    reg_tmp11.w = rcp_s(reg_tmp4.y);
    reg_tmp11.xy = (reg_tmp1.xyyy + -reg_tmp4.zwww).xy;
    reg_tmp11.xy = (mul_s(reg_tmp11.xyyy, reg_tmp11.zwww)).xy;
    return false;
}
bool sub_158_160() {
    reg_tmp11.xy = (reg_tmp11.yxxx).xy;
    reg_tmp11.y = (uniforms.f[5].yyyy + -reg_tmp11.yyyy).y;
    return false;
}
bool sub_161_162() {
    reg_tmp11.xy = (uniforms.f[5].yyyy + -reg_tmp11.yxxx).xy;
    return false;
}
bool sub_171_173() {
    reg_tmp11.xy = (reg_tmp11.yxxx).xy;
    reg_tmp11.y = (uniforms.f[5].yyyy + -reg_tmp11.yyyy).y;
    return false;
}
bool sub_174_175() {
    reg_tmp11.xy = (uniforms.f[5].yyyy + -reg_tmp11.yxxx).xy;
    return false;
}
bool sub_184_186() {
    reg_tmp11.xy = (reg_tmp11.yxxx).xy;
    reg_tmp11.y = (uniforms.f[5].yyyy + -reg_tmp11.yyyy).y;
    return false;
}
bool sub_187_188() {
    reg_tmp11.xy = (uniforms.f[5].yyyy + -reg_tmp11.yxxx).xy;
    return false;
}
bool sub_198_207() {
    reg_tmp13.xzw = (mul_s(uniforms.f[5].wxxx, reg_tmp13.xxxx)).xzw;
    reg_tmp13.y = (mul_s(uniforms.f[34 + address_registers.y].yyyy, reg_tmp13.yyyy)).y;
    reg_tmp11 = fma_s(reg_tmp1, uniforms.f[5].yyxx, -reg_tmp13);
    reg_tmp14 = uniforms.f[33 + address_registers.y].wzyx;
    reg_tmp1.x = dot_3(reg_tmp11.xyz, reg_tmp14.xyy);
    reg_tmp1.y = dot_3(reg_tmp11.xyz, reg_tmp14.zww);
    reg_tmp14 = uniforms.f[34 + address_registers.y].wzyx;
    reg_tmp1.z = dot_s(vec4(reg_tmp11.xyz, 1.0), reg_tmp14);
    reg_tmp1.xy = (reg_tmp1.xyyy + reg_tmp13.xyyy).xy;
    return false;
}
bool sub_215_223() {
    reg_tmp11 = abs(vs_in_reg0.zwzw);
    reg_tmp14.w = (floor(reg_tmp0.zzzz)).w;
    reg_tmp14.w = (reg_tmp0.zzzz + -reg_tmp14).w;
    address_registers.xy = ivec2(reg_tmp0.zx);
    reg_tmp14.w = (mul_s(uniforms.f[5].zzzz, reg_tmp14.wwww)).w;
    reg_tmp14.xyz = (uniforms.f[5].yyyy).xyz;
    reg_tmp7 = mul_s(uniforms.f[37 + address_registers.y].wzyx, reg_tmp14);
    reg_tmp8 = mul_s(uniforms.f[38 + address_registers.y].wzyx, reg_tmp14);
    return false;
}
bool sub_223_227() {
    reg_tmp11 = abs(vs_in_reg0.zwzw);
    address_registers.xy = ivec2(reg_tmp0.zw);
    reg_tmp7 = uniforms.f[32 + address_registers.y].wzyx;
    reg_tmp8 = uniforms.f[33 + address_registers.y].wzyx;
    return false;
}
// reference: 519CD67DE9BA0C09, 81B0676B862CF405
// program: 81B0676B862CF405, 42937135801BAA7E, F5D54925A6AE705F
// reference: 1FC8293DB1F6CB3C, 81B0676B862CF405
// program: 81B0676B862CF405, 42937135801BAA7E, 835CABE3A4B650D2
// program: 81B0676B862CF405, 42937135801BAA7E, D4C9E99618707555
// program: 81B0676B862CF405, 42937135801BAA7E, 0951EE62DBCF2390
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 7ED2F034E5EB4FC6
// program: 2E530FFFDA886761, B80FA1B7F97410CD, BC32652205728950
// program: 81B0676B862CF405, 42937135801BAA7E, 21786A34D707A069
// program: 81B0676B862CF405, 42937135801BAA7E, 5124AD903EB19D9F
// program: 81B0676B862CF405, 42937135801BAA7E, 886AC14BAA341C33
// program: 81B0676B862CF405, 42937135801BAA7E, 7C14C907B3CCD849
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 10AAC2A3349D1A7E
// program: 81B0676B862CF405, 42937135801BAA7E, 52F5F74AF1B519B6
// program: 81B0676B862CF405, 42937135801BAA7E, 98F0722A788E01FD
// reference: 1FC8293D5ECF587D, 81B0676B862CF405
// program: 81B0676B862CF405, 42937135801BAA7E, 6E5C02D38B9C02DF
// program: 81B0676B862CF405, 42937135801BAA7E, A4E2954DD6C4FB71
// shader: 8B31, FD3DADE0E2BC47C9

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;
out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define fma_s(x, y, z) (mix(x * y, vec4(0.0), isnan(x * y)) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_19();
bool sub_19_55();
bool sub_55_65();
bool sub_65_78();
bool sub_78_128();
bool sub_83_101();
bool sub_101_109();
bool sub_126_127();
bool sub_128_184();
bool sub_133_151();
bool sub_151_162();
bool sub_182_183();
bool sub_184_211();
bool sub_186_191();
bool sub_191_210();
bool sub_194_200();
bool sub_200_209();
bool sub_201_205();
bool sub_205_208();
bool sub_211_235();
bool sub_213_217();
bool sub_217_234();
bool sub_218_232();
bool sub_221_228();
bool sub_228_231();
bool sub_232_233();
bool sub_235_251();
bool sub_237_241();
bool sub_241_250();
bool sub_242_248();
bool sub_248_249();
bool sub_251_259();
bool sub_253_254();
bool sub_254_258();
bool sub_255_256();
bool sub_256_257();
bool sub_259_266();
bool sub_266_272();
bool sub_272_4096();
bool sub_273_275();
bool sub_275_277();
bool sub_278_285();
bool sub_285_286();

bool exec_shader() {
    sub_272_4096();
    return true;
}

bool sub_0_19() {
    uint jmp_to = 0u;
    while (true) {
        switch (jmp_to) {
        case 0u: {
            reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
            reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
            reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
            reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
            reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
            reg_tmp6.x = rsq_s(reg_tmp6.x);
            reg_tmp7.x = rsq_s(reg_tmp7.x);
            reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            reg_tmp0 = uniforms.f[93].yxxx;
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            reg_tmp4 = mul_s(uniforms.f[94].xxxx, reg_tmp4);
            conditional_code = greaterThanEqual(uniforms.f[93].xx, reg_tmp4.xx);
            reg_tmp4 = vec4(rsq_s(reg_tmp4.x));
            reg_tmp5 = mul_s(uniforms.f[94].xxxx, reg_tmp14);
            if (conditional_code.x) {
                { jmp_to = 18u; break; }
            }
            reg_tmp0.z = rcp_s(reg_tmp4.x);
            reg_tmp0.xy = (mul_s(reg_tmp5, reg_tmp4)).xy;
        }
        case 18u: {
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_19_55() {
    uint jmp_to = 19u;
    while (true) {
        switch (jmp_to) {
        case 19u: {
            reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
            reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
            reg_tmp6.x = rsq_s(reg_tmp6.x);
            reg_tmp7.x = rsq_s(reg_tmp7.x);
            reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            reg_tmp13.xyz = (mul_s(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            reg_tmp11.xyz = (mul_s(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            reg_tmp0 = uniforms.f[93].yxxx;
            reg_tmp13.xyz = (mul_s(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            reg_tmp11.xyz = (mul_s(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            reg_tmp5 = mul_s(reg_tmp14.yzxx, reg_tmp13.zxyy);
            reg_tmp5 = fma_s(-reg_tmp13.yzxx, reg_tmp14.zxyy, reg_tmp5);
            reg_tmp5.w = dot_3(reg_tmp5.xyz, reg_tmp5.xyz);
            reg_tmp5.w = rsq_s(reg_tmp5.w);
            reg_tmp5 = mul_s(reg_tmp5, reg_tmp5.wwww);
            reg_tmp6.w = (reg_tmp14.zzzz + reg_tmp5.yyyy).w;
            reg_tmp13 = mul_s(reg_tmp5.yzxx, reg_tmp14.zxyy);
            reg_tmp13 = fma_s(-reg_tmp14.yzxx, reg_tmp5.zxyy, reg_tmp13);
            reg_tmp6.w = (reg_tmp13.xxxx + reg_tmp6).w;
            reg_tmp13.w = (reg_tmp5.zzzz).w;
            reg_tmp5.z = (reg_tmp13.xxxx).z;
            reg_tmp6.w = (uniforms.f[93].yyyy + reg_tmp6).w;
            reg_tmp14.w = (reg_tmp5.xxxx).w;
            reg_tmp5.x = (reg_tmp14.zzzz).x;
            conditional_code = lessThan(uniforms.f[94].zz, reg_tmp6.ww);
            reg_tmp6.x = (uniforms.f[93].yyyy).x;
            reg_tmp6.y = (-uniforms.f[93].yyyy).y;
            if (!conditional_code.x) {
                { jmp_to = 54u; break; }
            }
            reg_tmp7.xz = (reg_tmp13.wwyy + -reg_tmp14.yyww).xz;
            reg_tmp7.y = (reg_tmp14.xxxx + -reg_tmp13.zzzz).y;
            reg_tmp7.w = (reg_tmp6).w;
            reg_tmp6 = vec4(dot_s(reg_tmp7, reg_tmp7));
            reg_tmp6 = vec4(rsq_s(reg_tmp6.x));
            reg_tmp0 = mul_s(reg_tmp7, reg_tmp6);
        }
        case 54u: {
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_55_65() {
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    reg_tmp4.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_65_78() {
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    reg_tmp4.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp5.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp13.xyz);
    reg_tmp5.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp13.xyz);
    reg_tmp5.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp13.xyz);
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    reg_tmp11 = fma_s(reg_tmp1.wwww, reg_tmp5, reg_tmp11);
    return false;
}
bool sub_78_128() {
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    reg_tmp13.xyz = (vs_in_reg2).xyz;
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    if (uniforms.b[0]) {
        sub_83_101();
    } else {
        sub_101_109();
    }
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    {
        sub_0_19();
    }
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    vs_out_attr2 = -reg_tmp15;
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    if (all(conditional_code)) {
        sub_126_127();
    }
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_83_101() {
    reg_tmp7 = uniforms.f[93].xxxx;
    reg_tmp12 = uniforms.f[93].xxxx;
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    {
        sub_55_65();
    }
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    {
        sub_55_65();
    }
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    {
        sub_55_65();
    }
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    {
        sub_55_65();
    }
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    reg_tmp10 = reg_tmp7;
    return false;
}
bool sub_101_109() {
    reg_tmp7 = reg_tmp15;
    reg_tmp10.x = dot_s(uniforms.f[10], reg_tmp7);
    reg_tmp10.y = dot_s(uniforms.f[11], reg_tmp7);
    reg_tmp10.z = dot_s(uniforms.f[12], reg_tmp7);
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    reg_tmp12.x = dot_3(uniforms.f[10].xyz, reg_tmp14.xyz);
    reg_tmp12.y = dot_3(uniforms.f[11].xyz, reg_tmp14.xyz);
    reg_tmp12.z = dot_3(uniforms.f[12].xyz, reg_tmp14.xyz);
    return false;
}
bool sub_126_127() {
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_128_184() {
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    reg_tmp13.xyz = (vs_in_reg2).xyz;
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    if (uniforms.b[0]) {
        sub_133_151();
    } else {
        sub_151_162();
    }
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    reg_tmp13.x = dot_3(uniforms.f[90].xyz, reg_tmp11.xyz);
    reg_tmp13.y = dot_3(uniforms.f[91].xyz, reg_tmp11.xyz);
    reg_tmp13.z = dot_3(uniforms.f[92].xyz, reg_tmp11.xyz);
    {
        sub_19_55();
    }
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    vs_out_attr2 = -reg_tmp15;
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    if (all(conditional_code)) {
        sub_182_183();
    }
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_133_151() {
    reg_tmp7 = uniforms.f[93].xxxx;
    reg_tmp12 = uniforms.f[93].xxxx;
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    {
        sub_65_78();
    }
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    {
        sub_65_78();
    }
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    {
        sub_65_78();
    }
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    {
        sub_65_78();
    }
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    reg_tmp10 = reg_tmp7;
    return false;
}
bool sub_151_162() {
    reg_tmp7 = reg_tmp15;
    reg_tmp10.x = dot_s(uniforms.f[10], reg_tmp7);
    reg_tmp10.y = dot_s(uniforms.f[11], reg_tmp7);
    reg_tmp10.z = dot_s(uniforms.f[12], reg_tmp7);
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    reg_tmp12.x = dot_3(uniforms.f[10].xyz, reg_tmp14.xyz);
    reg_tmp12.y = dot_3(uniforms.f[11].xyz, reg_tmp14.xyz);
    reg_tmp12.z = dot_3(uniforms.f[12].xyz, reg_tmp14.xyz);
    reg_tmp11.x = dot_3(uniforms.f[10].xyz, reg_tmp13.xyz);
    reg_tmp11.y = dot_3(uniforms.f[11].xyz, reg_tmp13.xyz);
    reg_tmp11.z = dot_3(uniforms.f[12].xyz, reg_tmp13.xyz);
    return false;
}
bool sub_182_183() {
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_184_211() {
    reg_tmp0.xy = (uniforms.f[0].xxxx).xy;
    if (uniforms.b[2]) {
        sub_186_191();
    } else {
        sub_191_210();
    }
    return false;
}
bool sub_186_191() {
    {
        sub_251_259();
    }
    reg_tmp3.x = dot_s(uniforms.f[1].xywz, reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2].xywz, reg_tmp6);
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_191_210() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_194_200();
    } else {
        sub_200_209();
    }
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_194_200() {
    reg_tmp6 = reg_tmp10;
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    reg_tmp3.z = dot_s(uniforms.f[3], reg_tmp6);
    reg_tmp0.xy = (mul_s(uniforms.f[9].xyyy, reg_tmp3.zzzz)).xy;
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_200_209() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_201_205();
    } else {
        sub_205_208();
    }
    return false;
}
bool sub_201_205() {
    {
        sub_259_266();
    }
    reg_tmp3.x = dot_3(uniforms.f[1].xyz, reg_tmp6.xyz);
    reg_tmp3.y = dot_3(uniforms.f[2].xyz, reg_tmp6.xyz);
    reg_tmp3.z = dot_3(uniforms.f[3].xyz, reg_tmp6.xyz);
    return false;
}
bool sub_205_208() {
    {
        sub_266_272();
    }
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    return false;
}
bool sub_211_235() {
    reg_tmp0.xy = (uniforms.f[0].yyyy).xy;
    if (uniforms.b[3]) {
        sub_213_217();
    } else {
        sub_217_234();
    }
    return false;
}
bool sub_213_217() {
    {
        sub_251_259();
    }
    reg_tmp4.x = dot_s(uniforms.f[4].xywz, reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5].xywz, reg_tmp6);
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_217_234() {
    if (uniforms.b[5]) {
        sub_218_232();
    } else {
        sub_232_233();
    }
    return false;
}
bool sub_218_232() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_221_228();
    } else {
        sub_228_231();
    }
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_221_228() {
    reg_tmp6 = reg_tmp10;
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    reg_tmp4.z = dot_s(uniforms.f[6], reg_tmp6);
    reg_tmp6.w = rcp_s(reg_tmp4.z);
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    reg_tmp4.xy = (uniforms.f[9].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_228_231() {
    {
        sub_266_272();
    }
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    return false;
}
bool sub_232_233() {
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_235_251() {
    reg_tmp0.xy = (uniforms.f[0].zzzz).xy;
    if (uniforms.b[4]) {
        sub_237_241();
    } else {
        sub_241_250();
    }
    return false;
}
bool sub_237_241() {
    {
        sub_251_259();
    }
    reg_tmp5.x = dot_s(uniforms.f[7].xywz, reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8].xywz, reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_241_250() {
    if (uniforms.b[6]) {
        sub_242_248();
    } else {
        sub_248_249();
    }
    return false;
}
bool sub_242_248() {
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    {
        sub_266_272();
    }
    reg_tmp5.x = dot_s(uniforms.f[7], reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8], reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_248_249() {
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
bool sub_251_259() {
    conditional_code = equal(uniforms.f[93].yz, reg_tmp0.xy);
    if (all(not(conditional_code))) {
        sub_253_254();
    } else {
        sub_254_258();
    }
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_253_254() {
    reg_tmp6.xy = (vs_in_reg4.xyyy).xy;
    return false;
}
bool sub_254_258() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_255_256();
    } else {
        sub_256_257();
    }
    return false;
}
bool sub_255_256() {
    reg_tmp6.xy = (vs_in_reg5.xyyy).xy;
    return false;
}
bool sub_256_257() {
    reg_tmp6.xy = (vs_in_reg6.xyyy).xy;
    return false;
}
bool sub_259_266() {
    reg_tmp2 = -reg_tmp15;
    reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
    reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_266_272() {
    reg_tmp1 = reg_tmp14;
    reg_tmp2.w = dot_3(reg_tmp1.xyz, reg_tmp1.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp1 = mul_s(reg_tmp1, reg_tmp2.wwww);
    reg_tmp1 = mul_s(uniforms.f[94].xxxx, reg_tmp1);
    reg_tmp6.xy = (uniforms.f[94].xxxx + reg_tmp1.xyyy).xy;
    return false;
}
bool sub_272_4096() {
    if (uniforms.b[10]) {
        sub_273_275();
    } else {
        sub_275_277();
    }
    if (uniforms.b[1]) {
        sub_278_285();
    } else {
        sub_285_286();
    }
    vs_out_attr3 = reg_tmp2;
    {
        sub_184_211();
    }
    {
        sub_211_235();
    }
    {
        sub_235_251();
    }
    return true;
}
bool sub_273_275() {
    {
        sub_128_184();
    }
    return false;
}
bool sub_275_277() {
    {
        sub_78_128();
    }
    return false;
}
bool sub_278_285() {
    reg_tmp0 = vec4(dot_3(uniforms.f[83].xyz, reg_tmp12.xyz));
    reg_tmp0 = max(uniforms.f[93].xxxx, reg_tmp0);
    reg_tmp0 = mul_s(uniforms.f[84], reg_tmp0);
    reg_tmp0 = uniforms.f[85] + reg_tmp0;
    reg_tmp0.w = (uniforms.f[93].yyyy).w;
    reg_tmp1 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
    reg_tmp2 = mul_s(reg_tmp0, reg_tmp1);
    return false;
}
bool sub_285_286() {
    reg_tmp2 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
    return false;
}
// reference: 73EE421893A64977, FD3DADE0E2BC47C9
// program: FD3DADE0E2BC47C9, B80FA1B7F97410CD, 19F7816C4117CF8E
// reference: 519CD67D90AEC7EF, 81B0676B862CF405
// program: 81B0676B862CF405, 42937135801BAA7E, 5FBCCF5F27F5A7C1
// reference: 1FC8293D27DB939B, 81B0676B862CF405
// program: 81B0676B862CF405, 42937135801BAA7E, 63B6ADAD25C2A518
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 47E4BEE6B3304AF3
// reference: 3DBABD5841ABFD06, 2E530FFFDA886761
// program: 2E530FFFDA886761, B80FA1B7F97410CD, C580B429ECAF519A
// shader: 8B31, 1934FF8F80653ACB

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;
out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define fma_s(x, y, z) (mix(x * y, vec4(0.0), isnan(x * y)) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_49();
bool sub_25_31();
bool sub_32_39();
bool sub_40_48();
bool sub_175_202();
bool sub_177_182();
bool sub_182_201();
bool sub_185_191();
bool sub_191_200();
bool sub_192_196();
bool sub_196_199();
bool sub_202_226();
bool sub_204_208();
bool sub_208_225();
bool sub_209_223();
bool sub_212_219();
bool sub_219_222();
bool sub_223_224();
bool sub_226_242();
bool sub_228_232();
bool sub_232_241();
bool sub_233_239();
bool sub_239_240();
bool sub_242_250();
bool sub_244_245();
bool sub_245_249();
bool sub_246_247();
bool sub_247_248();
bool sub_343_350();
bool sub_350_354();
bool sub_354_4096();
bool sub_361_363();
bool sub_363_364();

bool exec_shader() {
    sub_354_4096();
    return true;
}

bool sub_0_49() {
    reg_tmp1.xyz = (uniforms.f[93].xxyx).xyz;
    reg_tmp8.x = dot_3(uniforms.f[0].xyz, reg_tmp12.xyz);
    reg_tmp8.y = dot_3(uniforms.f[1].xyz, reg_tmp12.xyz);
    reg_tmp8.z = dot_3(uniforms.f[2].xyz, reg_tmp12.xyz);
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp8.xyz);
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp8.xyz);
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp8.xyz);
    reg_tmp14.w = (uniforms.f[93].xxxx).w;
    reg_tmp8 = reg_tmp14;
    reg_tmp14.x = dot_s(reg_tmp8, reg_tmp8);
    reg_tmp14.x = rsq_s(reg_tmp14.x);
    reg_tmp14 = mul_s(reg_tmp8, reg_tmp14.xxxx);
    reg_tmp0 = uniforms.f[23];
    reg_tmp8.x = dot_3(uniforms.f[0].xyz, reg_tmp0.xyz);
    reg_tmp8.y = dot_3(uniforms.f[1].xyz, reg_tmp0.xyz);
    reg_tmp8.z = dot_3(uniforms.f[2].xyz, reg_tmp0.xyz);
    reg_tmp6.x = dot_3(uniforms.f[90].xyz, reg_tmp8.xyz);
    reg_tmp6.y = dot_3(uniforms.f[91].xyz, reg_tmp8.xyz);
    reg_tmp6.z = dot_3(uniforms.f[92].xyz, reg_tmp8.xyz);
    reg_tmp8.xyz = (reg_tmp6.xyzz + reg_tmp1.xyzz).xyz;
    reg_tmp8.w = (uniforms.f[93].xxxx).w;
    reg_tmp0.x = dot_s(reg_tmp8, reg_tmp8);
    reg_tmp0.x = rsq_s(reg_tmp0.x);
    reg_tmp0 = mul_s(reg_tmp8, reg_tmp0.xxxx);
    if (uniforms.b[5]) {
        sub_25_31();
    }
    if (uniforms.b[3]) {
        sub_32_39();
    }
    if (uniforms.b[4]) {
        sub_40_48();
    }
    vs_out_attr3 = reg_tmp2;
    return false;
}
bool sub_25_31() {
    reg_tmp8.x = dot_3(reg_tmp14.xyz, -reg_tmp6.xyz);
    reg_tmp8.y = dot_3(reg_tmp1.xyz, -reg_tmp6.xyz);
    reg_tmp8 = max(uniforms.f[93].xxxx, reg_tmp8);
    reg_tmp8.y = (mul_s(uniforms.f[94].zzzz, reg_tmp8.yyyy)).y;
    reg_tmp8.y = (uniforms.f[94].zzzz + reg_tmp8.yyyy).y;
    reg_tmp2.y = (mul_s(reg_tmp8.xxxx, reg_tmp8.yyyy)).y;
    return false;
}
bool sub_32_39() {
    reg_tmp9.z = dot_3(reg_tmp14.xyz, reg_tmp0.xyz);
    reg_tmp9.z = (max(uniforms.f[93].xxxx, reg_tmp9.zzzz)).z;
    reg_tmp9.z = (min(uniforms.f[93].yyyy, reg_tmp9.zzzz)).z;
    reg_tmp9.z = log2(reg_tmp9.z);
    reg_tmp9.z = (mul_s(uniforms.f[22].zzzz, reg_tmp9.zzzz)).z;
    reg_tmp9.z = exp2(reg_tmp9.z);
    reg_tmp2.z = (mul_s(uniforms.f[22].wwww, reg_tmp9.zzzz)).z;
    return false;
}
bool sub_40_48() {
    reg_tmp9.x = dot_3(reg_tmp14.xyz, reg_tmp1.xyz);
    reg_tmp9.x = (max(uniforms.f[93].xxxx, reg_tmp9.xxxx)).x;
    reg_tmp9.x = (min(uniforms.f[93].yyyy, reg_tmp9.xxxx)).x;
    reg_tmp9.x = (uniforms.f[93].yyyy + -reg_tmp9.xxxx).x;
    reg_tmp9.x = log2(reg_tmp9.x);
    reg_tmp9.x = (mul_s(uniforms.f[22].xxxx, reg_tmp9.xxxx)).x;
    reg_tmp9.x = exp2(reg_tmp9.x);
    reg_tmp2.w = (mul_s(uniforms.f[22].yyyy, reg_tmp9.xxxx)).w;
    return false;
}
bool sub_175_202() {
    reg_tmp0.xy = (uniforms.f[10].xxxx).xy;
    if (uniforms.b[9]) {
        sub_177_182();
    } else {
        sub_182_201();
    }
    return false;
}
bool sub_177_182() {
    {
        sub_242_250();
    }
    reg_tmp3.x = dot_s(uniforms.f[11].xywz, reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[12].xywz, reg_tmp6);
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_182_201() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_185_191();
    } else {
        sub_191_200();
    }
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_185_191() {
    reg_tmp6 = reg_tmp10;
    reg_tmp3.x = dot_s(uniforms.f[11], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[12], reg_tmp6);
    reg_tmp3.z = dot_s(uniforms.f[13], reg_tmp6);
    reg_tmp0.xy = (mul_s(uniforms.f[19].xyyy, reg_tmp3.zzzz)).xy;
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_191_200() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_192_196();
    } else {
        sub_196_199();
    }
    return false;
}
bool sub_192_196() {
    {
        sub_343_350();
    }
    reg_tmp3.x = dot_3(uniforms.f[11].xyz, reg_tmp6.xyz);
    reg_tmp3.y = dot_3(uniforms.f[12].xyz, reg_tmp6.xyz);
    reg_tmp3.z = dot_3(uniforms.f[13].xyz, reg_tmp6.xyz);
    return false;
}
bool sub_196_199() {
    {
        sub_350_354();
    }
    reg_tmp3.x = dot_s(uniforms.f[11], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[12], reg_tmp6);
    return false;
}
bool sub_202_226() {
    reg_tmp0.xy = (uniforms.f[10].yyyy).xy;
    if (uniforms.b[10]) {
        sub_204_208();
    } else {
        sub_208_225();
    }
    return false;
}
bool sub_204_208() {
    {
        sub_242_250();
    }
    reg_tmp4.x = dot_s(uniforms.f[14].xywz, reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[15].xywz, reg_tmp6);
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_208_225() {
    if (uniforms.b[13]) {
        sub_209_223();
    } else {
        sub_223_224();
    }
    return false;
}
bool sub_209_223() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_212_219();
    } else {
        sub_219_222();
    }
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_212_219() {
    reg_tmp6 = reg_tmp10;
    reg_tmp4.x = dot_s(uniforms.f[14], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[15], reg_tmp6);
    reg_tmp4.z = dot_s(uniforms.f[16], reg_tmp6);
    reg_tmp6.w = rcp_s(reg_tmp4.z);
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    reg_tmp4.xy = (uniforms.f[19].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_219_222() {
    {
        sub_350_354();
    }
    reg_tmp4.x = dot_s(uniforms.f[14], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[15], reg_tmp6);
    return false;
}
bool sub_223_224() {
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_226_242() {
    reg_tmp0.xy = (uniforms.f[10].zzzz).xy;
    if (uniforms.b[11]) {
        sub_228_232();
    } else {
        sub_232_241();
    }
    return false;
}
bool sub_228_232() {
    {
        sub_242_250();
    }
    reg_tmp5.x = dot_s(uniforms.f[17].xywz, reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[18].xywz, reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_232_241() {
    if (uniforms.b[14]) {
        sub_233_239();
    } else {
        sub_239_240();
    }
    return false;
}
bool sub_233_239() {
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    {
        sub_350_354();
    }
    reg_tmp5.x = dot_s(uniforms.f[17], reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[18], reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_239_240() {
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
bool sub_242_250() {
    conditional_code = equal(uniforms.f[93].yz, reg_tmp0.xy);
    if (all(not(conditional_code))) {
        sub_244_245();
    } else {
        sub_245_249();
    }
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_244_245() {
    reg_tmp6.xy = (mul_s(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
    return false;
}
bool sub_245_249() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_246_247();
    } else {
        sub_247_248();
    }
    return false;
}
bool sub_246_247() {
    reg_tmp6.xy = (mul_s(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
    return false;
}
bool sub_247_248() {
    reg_tmp6.xy = (mul_s(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
    return false;
}
bool sub_343_350() {
    reg_tmp2 = -reg_tmp15;
    reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
    reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_350_354() {
    reg_tmp1.xy = (uniforms.f[94].zzzz).xy;
    reg_tmp1.zw = (uniforms.f[93].xxxx).zw;
    reg_tmp6 = fma_s(reg_tmp14, reg_tmp1, reg_tmp1);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_354_4096() {
    reg_tmp0 = vs_in_reg0;
    reg_tmp0.z = (uniforms.f[93].xxxx).z;
    reg_tmp0.w = (uniforms.f[93].yyyy).w;
    vs_out_attr0 = reg_tmp0;
    vs_out_attr2 = reg_tmp0;
    vs_out_attr1 = reg_tmp0;
    if (uniforms.b[6]) {
        sub_361_363();
    } else {
        sub_363_364();
    }
    {
        sub_175_202();
    }
    {
        sub_202_226();
    }
    {
        sub_226_242();
    }
    return true;
}
bool sub_361_363() {
    {
        sub_0_49();
    }
    return false;
}
bool sub_363_364() {
    vs_out_attr3 = uniforms.f[93].yyyy;
    return false;
}
// reference: A572BCB00841965D, 1934FF8F80653ACB
// program: 1934FF8F80653ACB, B80FA1B7F97410CD, 5C250F6C1418BBD3
// reference: E447428B09B4FE0B, 2E530FFFDA886761
// reference: AA13BDCB715FBDB7, 2E530FFFDA886761
// reference: AA13BDCBBEC1AA7F, 2E530FFFDA886761
// reference: E447428BA35209C6, FD3DADE0E2BC47C9
// reference: BF76358EA05A875E, 81B0676B862CF405
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 4BA25B84A31C492A
// reference: BF76358E7FD7C26A, 81B0676B862CF405
// program: 81B0676B862CF405, 42937135801BAA7E, CAB8B665DC444CE4
// reference: F122CACE279B055F, 81B0676B862CF405
// reference: 9D04A1EB09B4FE0B, 2E530FFFDA886761
// reference: D3505EAB715FBDB7, 2E530FFFDA886761
// reference: D3505EABBEC1AA7F, 2E530FFFDA886761
// reference: 9D04A1EBA35209C6, FD3DADE0E2BC47C9
// reference: F122CACE172FD32A, 81B0676B862CF405
// program: 81B0676B862CF405, 42937135801BAA7E, 6B98A4CC666FCBCF
// program: 81B0676B862CF405, 42937135801BAA7E, D1257B6267770D05
// program: 81B0676B862CF405, 42937135801BAA7E, D134C63316570D84
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 40FC95A67F54598B
// program: 2E530FFFDA886761, B80FA1B7F97410CD, D69A3CB52F0E3495
// program: 2E530FFFDA886761, B80FA1B7F97410CD, B5CB613BFC4BC41C
// reference: B67DEEB416EC86DF, 46E991DEB658A5A9
// program: 46E991DEB658A5A9, B80FA1B7F97410CD, 1B4DA8DA884D39A1
// program: 2E530FFFDA886761, B80FA1B7F97410CD, D2BD0C5FAA2AB273
// program: 2E530FFFDA886761, B80FA1B7F97410CD, F8FBCC791CAC22F2
// program: 2E530FFFDA886761, B80FA1B7F97410CD, FEE7FD4C7FD3D731
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 8633243B2123B710
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 39E142A8F1F39B96
// program: 2E530FFFDA886761, B80FA1B7F97410CD, FC9E10BE42F07103
// shader: 8B31, C6410D4382B19655

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define fma_s(x, y, z) (mix(x * y, vec4(0.0), isnan(x * y)) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_8();
bool sub_9_32();
bool sub_33_96();
bool sub_146_166();
bool sub_167_259();
bool sub_190_192();
bool sub_194_195();
bool sub_197_198();
bool sub_200_202();
bool sub_232_234();
bool sub_236_237();
bool sub_239_240();
bool sub_242_244();
bool sub_260_4096();
bool sub_287_288();
bool sub_288_289();

bool exec_shader() {
    sub_260_4096();
    return true;
}

bool sub_0_8() {
    address_registers.x = (ivec2(vs_in_reg0.zz)).x;
    reg_tmp10 = uniforms.f[0].xxxz;
    reg_tmp10.xy = (vs_in_reg0.xyyy).xy;
    reg_tmp11 = uniforms.f[0].xxxx;
    reg_tmp12 = uniforms.f[0].xxxx;
    reg_tmp13 = uniforms.f[0].zzzz;
    reg_tmp4 = uniforms.f[0].xxxx;
    reg_tmp5 = uniforms.f[0].xxxx;
    return false;
}
bool sub_9_32() {
    vs_out_attr0 = reg_tmp10;
    reg_tmp13 = mul_s(uniforms.f[82], reg_tmp13);
    vs_out_attr1 = reg_tmp13;
    reg_tmp11.y = (uniforms.f[0].zzzz + -reg_tmp11.yyyy).y;
    reg_tmp12.y = (uniforms.f[0].zzzz + -reg_tmp12.yyyy).y;
    reg_tmp14.y = (uniforms.f[81].wwww).y;
    reg_tmp14.x = (mul_s(uniforms.f[0].wwww, reg_tmp14.yyyy)).x;
    reg_tmp2.x = rcp_s(reg_tmp14.x);
    reg_tmp14.z = (reg_tmp2.xxxx).z;
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp11.xyyy).xy;
    reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    reg_tmp11.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp12.xyyy).xy;
    reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    reg_tmp12.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    vs_out_attr2 = reg_tmp11;
    vs_out_attr3 = reg_tmp12;
    return false;
}
bool sub_33_96() {
    reg_tmp6.xyz = (-reg_tmp0.xyzz).xyz;
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    reg_tmp7.xyz = vec3(rcp_s(uniforms.f[81].y));
    reg_tmp8.xyz = (fma_s(reg_tmp6.xyzz, reg_tmp7.xyzz, uniforms.f[0].yyyy)).xyz;
    reg_tmp7.xyz = (floor(reg_tmp8.xyzz)).xyz;
    reg_tmp6.xyz = (fma_s(reg_tmp7.xyzz, -uniforms.f[81].yyyy, reg_tmp6.xyzz)).xyz;
    reg_tmp6 = min(uniforms.f[81].xxxx, reg_tmp6);
    reg_tmp6 = max(-uniforms.f[81].xxxx, reg_tmp6);
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp6.xxxx, reg_tmp6.xxxx)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp6.xxxx)).y;
    reg_tmp4.x = (reg_tmp1.xxxx).x;
    reg_tmp5.x = (reg_tmp1.yyyy).x;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp6.yyyy, reg_tmp6.yyyy)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp6.yyyy)).y;
    reg_tmp4.y = (reg_tmp1.xxxx).y;
    reg_tmp5.y = (reg_tmp1.yyyy).y;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp6.zzzz, reg_tmp6.zzzz)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp6.zzzz)).y;
    reg_tmp4.z = (reg_tmp1.xxxx).z;
    reg_tmp5.z = (reg_tmp1.yyyy).z;
    reg_tmp2.x = (mul_s(reg_tmp4.yyyy, reg_tmp5.zzzz)).x;
    reg_tmp2.y = (mul_s(reg_tmp5.yyyy, reg_tmp5.zzzz)).y;
    reg_tmp6.x = (mul_s(reg_tmp4.yyyy, reg_tmp4.zzzz)).x;
    reg_tmp6.y = (reg_tmp5.zzzz).y;
    reg_tmp6.z = (mul_s(-reg_tmp5.yyyy, reg_tmp4.zzzz)).z;
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    reg_tmp7.x = (mul_s(-reg_tmp2.xxxx, reg_tmp4.xxxx)).x;
    reg_tmp7.x = (fma_s(reg_tmp5.yyyy, reg_tmp5.xxxx, reg_tmp7.xxxx)).x;
    reg_tmp7.y = (mul_s(reg_tmp4.zzzz, reg_tmp4.xxxx)).y;
    reg_tmp7.z = (mul_s(reg_tmp2.yyyy, reg_tmp4.xxxx)).z;
    reg_tmp7.z = (fma_s(reg_tmp4.yyyy, reg_tmp5.xxxx, reg_tmp7.zzzz)).z;
    reg_tmp7.w = (uniforms.f[0].xxxx).w;
    reg_tmp8.x = (mul_s(reg_tmp2.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp8.x = (fma_s(reg_tmp5.yyyy, reg_tmp4.xxxx, reg_tmp8.xxxx)).x;
    reg_tmp8.y = (mul_s(-reg_tmp4.zzzz, reg_tmp5.xxxx)).y;
    reg_tmp8.z = (mul_s(-reg_tmp2.yyyy, reg_tmp5.xxxx)).z;
    reg_tmp8.z = (fma_s(reg_tmp4.yyyy, reg_tmp4.xxxx, reg_tmp8.zzzz)).z;
    reg_tmp8.w = (uniforms.f[0].xxxx).w;
    reg_tmp9 = uniforms.f[0].xxxz;
    return false;
}
bool sub_146_166() {
    reg_tmp2 = uniforms.f[90];
    reg_tmp3 = uniforms.f[91];
    reg_tmp4 = uniforms.f[92];
    reg_tmp5 = uniforms.f[0].xxxz;
    reg_tmp6 = mul_s(uniforms.f[86].xxxx, reg_tmp2);
    reg_tmp6 = fma_s(reg_tmp3, uniforms.f[86].yyyy, reg_tmp6);
    reg_tmp6 = fma_s(reg_tmp4, uniforms.f[86].zzzz, reg_tmp6);
    reg_tmp6 = fma_s(reg_tmp5, uniforms.f[86].wwww, reg_tmp6);
    reg_tmp7 = mul_s(uniforms.f[87].xxxx, reg_tmp2);
    reg_tmp7 = fma_s(reg_tmp3, uniforms.f[87].yyyy, reg_tmp7);
    reg_tmp7 = fma_s(reg_tmp4, uniforms.f[87].zzzz, reg_tmp7);
    reg_tmp7 = fma_s(reg_tmp5, uniforms.f[87].wwww, reg_tmp7);
    reg_tmp8 = mul_s(uniforms.f[88].xxxx, reg_tmp2);
    reg_tmp8 = fma_s(reg_tmp3, uniforms.f[88].yyyy, reg_tmp8);
    reg_tmp8 = fma_s(reg_tmp4, uniforms.f[88].zzzz, reg_tmp8);
    reg_tmp8 = fma_s(reg_tmp5, uniforms.f[88].wwww, reg_tmp8);
    reg_tmp9 = mul_s(uniforms.f[89].xxxx, reg_tmp2);
    reg_tmp9 = fma_s(reg_tmp3, uniforms.f[89].yyyy, reg_tmp9);
    reg_tmp9 = fma_s(reg_tmp4, uniforms.f[89].zzzz, reg_tmp9);
    reg_tmp9 = fma_s(reg_tmp5, uniforms.f[89].wwww, reg_tmp9);
    return false;
}
bool sub_167_259() {
    reg_tmp2.x = rcp_s(uniforms.f[81].y);
    reg_tmp2.xy = (mul_s(uniforms.f[2 + address_registers.x].zwww, reg_tmp2.xxxx)).xy;
    reg_tmp2.xy = (uniforms.f[0].yyyy + reg_tmp2.xyyy).xy;
    reg_tmp3.xy = (floor(reg_tmp2.xyyy)).xy;
    reg_tmp2.xy = (mul_s(uniforms.f[81].yyyy, reg_tmp3.xyyy)).xy;
    reg_tmp2.xy = (uniforms.f[2 + address_registers.x].zwww + -reg_tmp2.xyyy).xy;
    reg_tmp0.xy = (min(uniforms.f[81].xxxx, -reg_tmp2.xyyy)).xy;
    reg_tmp0.xy = (max(-uniforms.f[81].xxxx, reg_tmp0.xyyy)).xy;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp0.xxxx, reg_tmp0.xxxx)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.xxxx)).y;
    reg_tmp5.x = (uniforms.f[5 + address_registers.x].wwww).x;
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_190_192();
    }
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_194_195();
    }
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_197_198();
    }
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_200_202();
    }
    reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    reg_tmp4.z = (uniforms.f[83].xxxx).z;
    reg_tmp4.w = (-uniforms.f[83].yyyy).w;
    reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[3 + address_registers.x].xyyy)).xy;
    reg_tmp4.z = (-uniforms.f[3 + address_registers.x].zzzz).z;
    reg_tmp4.w = (-uniforms.f[3 + address_registers.x].wwww).w;
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    reg_tmp11.xy = (reg_tmp5.xyyy).xy;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp0.yyyy, reg_tmp0.yyyy)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.yyyy)).y;
    reg_tmp5.x = (uniforms.f[6 + address_registers.x].wwww).x;
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_232_234();
    }
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_236_237();
    }
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_239_240();
    }
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_242_244();
    }
    reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    reg_tmp4.z = (uniforms.f[83].zzzz).z;
    reg_tmp4.w = (-uniforms.f[83].wwww).w;
    reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[4 + address_registers.x].xyyy)).xy;
    reg_tmp4.z = (-uniforms.f[4 + address_registers.x].zzzz).z;
    reg_tmp4.w = (-uniforms.f[4 + address_registers.x].wwww).w;
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    reg_tmp12.xy = (reg_tmp5.xyyy).xy;
    return false;
}
bool sub_190_192() {
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_194_195() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_197_198() {
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_200_202() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_232_234() {
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_236_237() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_239_240() {
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_242_244() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_260_4096() {
    {
        sub_0_8();
    }
    reg_tmp10.xy = (uniforms.f[84].xyyy + reg_tmp10.xyyy).xy;
    reg_tmp10.xy = (mul_s(uniforms.f[2 + address_registers.x].xyyy, reg_tmp10.xyyy)).xy;
    reg_tmp14 = reg_tmp10;
    reg_tmp0 = uniforms.f[7 + address_registers.x];
    {
        sub_33_96();
    }
    reg_tmp10.x = dot_s(reg_tmp14, reg_tmp6);
    reg_tmp10.y = dot_s(reg_tmp14, reg_tmp7);
    reg_tmp10.z = dot_s(reg_tmp14, reg_tmp8);
    reg_tmp10.w = dot_s(reg_tmp14, reg_tmp9);
    reg_tmp6 = uniforms.f[8 + address_registers.x];
    reg_tmp7 = uniforms.f[9 + address_registers.x];
    reg_tmp8 = uniforms.f[10 + address_registers.x];
    reg_tmp9 = uniforms.f[0].xxxz;
    reg_tmp6.w = (uniforms.f[5 + address_registers.x].xxxx).w;
    reg_tmp7.w = (uniforms.f[5 + address_registers.x].yyyy).w;
    reg_tmp8.w = (uniforms.f[5 + address_registers.x].zzzz).w;
    reg_tmp2.x = dot_s(reg_tmp10, reg_tmp6);
    reg_tmp2.y = dot_s(reg_tmp10, reg_tmp7);
    reg_tmp2.z = dot_s(reg_tmp10, reg_tmp8);
    reg_tmp2.w = dot_s(reg_tmp10, reg_tmp9);
    reg_tmp10 = reg_tmp2;
    reg_tmp3.xyz = (uniforms.f[5 + address_registers.x].xyzz).xyz;
    reg_tmp3.xyz = (uniforms.f[85].xyzz + -reg_tmp3.xyzz).xyz;
    reg_tmp4.x = dot_3(reg_tmp3.xyz, reg_tmp3.xyz);
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
    if (conditional_code.x) {
        sub_287_288();
    } else {
        sub_288_289();
    }
    reg_tmp3.xyz = (mul_s(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
    reg_tmp10.xyz = (fma_s(reg_tmp3.xyzz, uniforms.f[84].zzzz, reg_tmp10.xyzz)).xyz;
    {
        sub_146_166();
    }
    reg_tmp2 = reg_tmp10;
    reg_tmp10.x = dot_s(reg_tmp2, reg_tmp6);
    reg_tmp10.y = dot_s(reg_tmp2, reg_tmp7);
    reg_tmp10.z = dot_s(reg_tmp2, reg_tmp8);
    reg_tmp10.w = dot_s(reg_tmp2, reg_tmp9);
    reg_tmp2 = uniforms.f[1 + address_registers.x];
    reg_tmp3 = max(uniforms.f[0].xxxx, reg_tmp2);
    reg_tmp2 = min(uniforms.f[0].zzzz, reg_tmp3);
    reg_tmp13 = reg_tmp2;
    {
        sub_167_259();
    }
    {
        sub_9_32();
    }
    return true;
}
bool sub_287_288() {
    reg_tmp4.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_288_289() {
    reg_tmp4.x = rsq_s(reg_tmp4.x);
    return false;
}
// reference: E545D24977D2391C, C6410D4382B19655
// program: C6410D4382B19655, 082670B4222015B2, DBA0F8FE46AD8D9B
// reference: 519CD67D0C2ADDEF, 81B0676B862CF405
// program: 81B0676B862CF405, 42937135801BAA7E, 47A8279A60685F27
// reference: 1FC8293D54661ADA, 81B0676B862CF405
// reference: 58970D472618C66E, 46E991DEB658A5A9
// shader: 8B31, 466184E6A05DFF0F

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;
out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define fma_s(x, y, z) (mix(x * y, vec4(0.0), isnan(x * y)) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_6();
bool sub_6_53();
bool sub_21_25();
bool sub_51_52();
bool sub_53_4096();

bool exec_shader() {
    sub_53_4096();
    return true;
}

bool sub_0_6() {
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    return false;
}
bool sub_6_53() {
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    reg_tmp7 = uniforms.f[93].xxxx;
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    {
        sub_0_6();
    }
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    {
        sub_0_6();
    }
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    if (conditional_code.x) {
        sub_0_6();
    }
    if (uniforms.b[11]) {
        sub_21_25();
    }
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    reg_tmp10 = reg_tmp7;
    reg_tmp6.y = (-uniforms.f[83].wwww + reg_tmp10.yyyy).y;
    reg_tmp9.xyz = (uniforms.f[83].xyzz).xyz;
    reg_tmp7.x = dot_s(reg_tmp9.xyzz, reg_tmp9.xyzz);
    reg_tmp7.x = rsq_s(reg_tmp7.x);
    reg_tmp7.xyz = (mul_s(reg_tmp9.xyzz, reg_tmp7.xxxx)).xyz;
    reg_tmp8.y = rcp_s(-reg_tmp7.y);
    reg_tmp8.y = (mul_s(reg_tmp6.yyyy, reg_tmp8.yyyy)).y;
    reg_tmp7.xyz = (mul_s(reg_tmp7.xyzz, reg_tmp8.yyyy)).xyz;
    reg_tmp10.xyz = (reg_tmp10.xyzz + reg_tmp7.xyzz).xyz;
    reg_tmp10.y = (uniforms.f[94].xxxx + reg_tmp10.yyyy).y;
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    vs_out_attr1 = uniforms.f[93].xxxx;
    vs_out_attr2 = reg_tmp15;
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    if (all(conditional_code)) {
        sub_51_52();
    }
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_21_25() {
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    if (conditional_code.y) {
        sub_0_6();
    }
    return false;
}
bool sub_51_52() {
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_53_4096() {
    {
        sub_6_53();
    }
    vs_out_attr4 = uniforms.f[93].xxxx;
    vs_out_attr5 = uniforms.f[93].xxxx;
    vs_out_attr6 = uniforms.f[93].xxxx;
    vs_out_attr3 = uniforms.f[93].yyyy;
    return true;
}
// reference: 9FD258F141B1693F, 466184E6A05DFF0F
// program: 466184E6A05DFF0F, B80FA1B7F97410CD, C2EEBEAE0D7F3560
// shader: 8B31, 45C9694A57480945

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;
out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define fma_s(x, y, z) (mix(x * y, vec4(0.0), isnan(x * y)) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_19_29();
bool sub_143_151();
bool sub_145_146();
bool sub_146_150();
bool sub_147_148();
bool sub_148_149();
bool sub_166_4096();
bool sub_170_192();
bool sub_192_200();
bool sub_212_213();

bool exec_shader() {
    sub_166_4096();
    return true;
}

bool sub_19_29() {
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    reg_tmp4.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_143_151() {
    conditional_code = equal(uniforms.f[93].yz, reg_tmp0.xy);
    if (all(not(conditional_code))) {
        sub_145_146();
    } else {
        sub_146_150();
    }
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_145_146() {
    reg_tmp6.xy = (vs_in_reg4.xyyy).xy;
    return false;
}
bool sub_146_150() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_147_148();
    } else {
        sub_148_149();
    }
    return false;
}
bool sub_147_148() {
    reg_tmp6.xy = (vs_in_reg5.xyyy).xy;
    return false;
}
bool sub_148_149() {
    reg_tmp6.xy = (vs_in_reg6.xyyy).xy;
    return false;
}
bool sub_166_4096() {
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    if (uniforms.b[0]) {
        sub_170_192();
    } else {
        sub_192_200();
    }
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    if (all(conditional_code)) {
        sub_212_213();
    }
    vs_out_attr0 = reg_tmp0;
    vs_out_attr1 = uniforms.f[93].xxxx;
    vs_out_attr2 = uniforms.f[93].xxxx;
    reg_tmp0 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
    vs_out_attr3 = uniforms.f[94].zzzz + reg_tmp0;
    reg_tmp5.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    reg_tmp5.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    reg_tmp5.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    reg_tmp4.x = dot_s(reg_tmp5.xyzz, reg_tmp5.xyzz);
    reg_tmp4.x = rsq_s(reg_tmp4.x);
    reg_tmp4.xyz = (mul_s(reg_tmp5.xyzz, reg_tmp4.xxxx)).xyz;
    reg_tmp4 = mul_s(uniforms.f[94].xxxx, reg_tmp4);
    reg_tmp12 = uniforms.f[94].xxxx + reg_tmp4;
    vs_out_attr4 = reg_tmp12;
    reg_tmp0.xy = (uniforms.f[0].xxxx).xy;
    {
        sub_143_151();
    }
    reg_tmp4.x = dot_s(uniforms.f[4].xywz, reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5].xywz, reg_tmp6);
    vs_out_attr5 = reg_tmp4;
    vs_out_attr6 = reg_tmp4;
    return true;
}
bool sub_170_192() {
    reg_tmp7 = uniforms.f[93].xxxx;
    reg_tmp12 = uniforms.f[93].xxxx;
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    {
        sub_19_29();
    }
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    {
        sub_19_29();
    }
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    if (conditional_code.x) {
        sub_19_29();
    }
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    if (conditional_code.y) {
        sub_19_29();
    }
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    reg_tmp10 = reg_tmp7;
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    return false;
}
bool sub_192_200() {
    reg_tmp7 = reg_tmp15;
    reg_tmp10.x = dot_s(uniforms.f[10], reg_tmp7);
    reg_tmp10.y = dot_s(uniforms.f[11], reg_tmp7);
    reg_tmp10.z = dot_s(uniforms.f[12], reg_tmp7);
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    reg_tmp12.x = dot_s(uniforms.f[10], reg_tmp14);
    reg_tmp12.y = dot_s(uniforms.f[11], reg_tmp14);
    reg_tmp12.z = dot_s(uniforms.f[12], reg_tmp14);
    return false;
}
bool sub_212_213() {
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
// reference: 40A37A2A9D8B60DD, 45C9694A57480945
// program: 45C9694A57480945, B80FA1B7F97410CD, 490CACB848ED440A
// shader: 8B31, D03F0FE4B72A8E86

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;
out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define fma_s(x, y, z) (mix(x * y, vec4(0.0), isnan(x * y)) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_19();
bool sub_19_29();
bool sub_29_51();
bool sub_51_65();
bool sub_65_116();
bool sub_88_92();
bool sub_114_115();
bool sub_116_156();
bool sub_133_137();
bool sub_154_155();
bool sub_156_183();
bool sub_158_163();
bool sub_163_182();
bool sub_166_172();
bool sub_172_181();
bool sub_173_177();
bool sub_177_180();
bool sub_183_207();
bool sub_185_189();
bool sub_189_206();
bool sub_190_204();
bool sub_193_200();
bool sub_200_203();
bool sub_204_205();
bool sub_207_223();
bool sub_209_213();
bool sub_213_222();
bool sub_214_220();
bool sub_220_221();
bool sub_223_231();
bool sub_225_226();
bool sub_226_230();
bool sub_227_228();
bool sub_228_229();
bool sub_231_238();
bool sub_238_244();
bool sub_244_288();
bool sub_264_270();
bool sub_271_278();
bool sub_279_287();
bool sub_288_4096();
bool sub_289_291();
bool sub_291_293();
bool sub_294_296();
bool sub_296_298();

bool exec_shader() {
    sub_288_4096();
    return true;
}

bool sub_0_19() {
    uint jmp_to = 0u;
    while (true) {
        switch (jmp_to) {
        case 0u: {
            reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
            reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
            reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
            reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
            reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
            reg_tmp6.x = rsq_s(reg_tmp6.x);
            reg_tmp7.x = rsq_s(reg_tmp7.x);
            reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            reg_tmp0 = uniforms.f[93].yxxx;
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            reg_tmp4 = mul_s(uniforms.f[94].xxxx, reg_tmp4);
            conditional_code = greaterThanEqual(uniforms.f[93].xx, reg_tmp4.xx);
            reg_tmp4 = vec4(rsq_s(reg_tmp4.x));
            reg_tmp5 = mul_s(uniforms.f[94].xxxx, reg_tmp14);
            if (conditional_code.x) {
                { jmp_to = 18u; break; }
            }
            reg_tmp0.z = rcp_s(reg_tmp4.x);
            reg_tmp0.xy = (mul_s(reg_tmp5, reg_tmp4)).xy;
        }
        case 18u: {
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_19_29() {
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    reg_tmp4.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_29_51() {
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    reg_tmp3.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp3.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp3.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp12);
    reg_tmp3.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp13.xyz);
    reg_tmp3.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp13.xyz);
    reg_tmp3.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp13.xyz);
    reg_tmp11 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp11);
    reg_tmp3.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp5.xyz);
    reg_tmp3.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp5.xyz);
    reg_tmp3.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp5.xyz);
    reg_tmp9 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp9);
    reg_tmp3.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp6.xyz);
    reg_tmp3.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp6.xyz);
    reg_tmp3.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp6.xyz);
    reg_tmp8 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp8);
    return false;
}
bool sub_51_65() {
    reg_tmp0.xyz = (mul_s(reg_tmp9.yzxx, reg_tmp8.zxyy)).xyz;
    reg_tmp0.xyz = (fma_s(-reg_tmp8.yzxx, reg_tmp9.zxyy, reg_tmp0)).xyz;
    reg_tmp1 = uniforms.f[83];
    reg_tmp2.x = dot_s(reg_tmp1.xyzz, reg_tmp1.xyzz);
    reg_tmp2.x = rsq_s(reg_tmp2.x);
    reg_tmp2.xyz = (mul_s(reg_tmp1.xyzz, reg_tmp2.xxxx)).xyz;
    reg_tmp1.x = dot_3(reg_tmp2.xyz, reg_tmp8.xyz);
    reg_tmp1.y = dot_3(reg_tmp2.xyz, reg_tmp0.xyz);
    reg_tmp1.z = dot_3(reg_tmp2.xyz, reg_tmp9.xyz);
    reg_tmp2.x = dot_s(reg_tmp1.xyzz, reg_tmp1.xyzz);
    reg_tmp2.x = rsq_s(reg_tmp2.x);
    reg_tmp2.xyz = (mul_s(reg_tmp1.xyzz, reg_tmp2.xxxx)).xyz;
    reg_tmp2.w = (uniforms.f[93].yyyy).w;
    vs_out_attr2 = reg_tmp2;
    return false;
}
bool sub_65_116() {
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    reg_tmp13.xyz = (vs_in_reg2).xyz;
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    reg_tmp5 = uniforms.f[93].xxyy;
    reg_tmp6 = uniforms.f[93].yxxy;
    reg_tmp7 = uniforms.f[93].xxxx;
    reg_tmp12 = uniforms.f[93].xxxx;
    reg_tmp11 = uniforms.f[93].xxxx;
    reg_tmp9 = uniforms.f[93].xxxx;
    reg_tmp8 = uniforms.f[93].xxxx;
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    {
        sub_29_51();
    }
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    {
        sub_29_51();
    }
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    if (conditional_code.x) {
        sub_29_51();
    }
    if (uniforms.b[11]) {
        sub_88_92();
    }
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    reg_tmp10 = reg_tmp7;
    reg_tmp13.x = dot_3(uniforms.f[90].xyz, reg_tmp11.xyz);
    reg_tmp13.y = dot_3(uniforms.f[91].xyz, reg_tmp11.xyz);
    reg_tmp13.z = dot_3(uniforms.f[92].xyz, reg_tmp11.xyz);
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    {
        sub_51_65();
    }
    vs_out_attr1 = uniforms.f[93].xxxy;
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    if (all(conditional_code)) {
        sub_114_115();
    }
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_88_92() {
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    if (conditional_code.y) {
        sub_29_51();
    }
    return false;
}
bool sub_114_115() {
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_116_156() {
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    reg_tmp7 = uniforms.f[93].xxxx;
    reg_tmp12 = uniforms.f[93].xxxx;
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    {
        sub_19_29();
    }
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    {
        sub_19_29();
    }
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    if (conditional_code.x) {
        sub_19_29();
    }
    if (uniforms.b[11]) {
        sub_133_137();
    }
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    reg_tmp10 = reg_tmp7;
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    {
        sub_0_19();
    }
    vs_out_attr2 = -reg_tmp15;
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    if (all(conditional_code)) {
        sub_154_155();
    }
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_133_137() {
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    if (conditional_code.y) {
        sub_19_29();
    }
    return false;
}
bool sub_154_155() {
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_156_183() {
    reg_tmp0.xy = (uniforms.f[0].xxxx).xy;
    if (uniforms.b[2]) {
        sub_158_163();
    } else {
        sub_163_182();
    }
    return false;
}
bool sub_158_163() {
    {
        sub_223_231();
    }
    reg_tmp3.x = dot_s(uniforms.f[1].xywz, reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2].xywz, reg_tmp6);
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_163_182() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_166_172();
    } else {
        sub_172_181();
    }
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_166_172() {
    reg_tmp6 = reg_tmp10;
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    reg_tmp3.z = dot_s(uniforms.f[3], reg_tmp6);
    reg_tmp0.xy = (mul_s(uniforms.f[9].xyyy, reg_tmp3.zzzz)).xy;
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_172_181() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_173_177();
    } else {
        sub_177_180();
    }
    return false;
}
bool sub_173_177() {
    {
        sub_231_238();
    }
    reg_tmp3.x = dot_3(uniforms.f[1].xyz, reg_tmp6.xyz);
    reg_tmp3.y = dot_3(uniforms.f[2].xyz, reg_tmp6.xyz);
    reg_tmp3.z = dot_3(uniforms.f[3].xyz, reg_tmp6.xyz);
    return false;
}
bool sub_177_180() {
    {
        sub_238_244();
    }
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    return false;
}
bool sub_183_207() {
    reg_tmp0.xy = (uniforms.f[0].yyyy).xy;
    if (uniforms.b[3]) {
        sub_185_189();
    } else {
        sub_189_206();
    }
    return false;
}
bool sub_185_189() {
    {
        sub_223_231();
    }
    reg_tmp4.x = dot_s(uniforms.f[4].xywz, reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5].xywz, reg_tmp6);
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_189_206() {
    if (uniforms.b[5]) {
        sub_190_204();
    } else {
        sub_204_205();
    }
    return false;
}
bool sub_190_204() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_193_200();
    } else {
        sub_200_203();
    }
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_193_200() {
    reg_tmp6 = reg_tmp10;
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    reg_tmp4.z = dot_s(uniforms.f[6], reg_tmp6);
    reg_tmp6.w = rcp_s(reg_tmp4.z);
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    reg_tmp4.xy = (uniforms.f[9].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_200_203() {
    {
        sub_238_244();
    }
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    return false;
}
bool sub_204_205() {
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_207_223() {
    reg_tmp0.xy = (uniforms.f[0].zzzz).xy;
    if (uniforms.b[4]) {
        sub_209_213();
    } else {
        sub_213_222();
    }
    return false;
}
bool sub_209_213() {
    {
        sub_223_231();
    }
    reg_tmp5.x = dot_s(uniforms.f[7].xywz, reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8].xywz, reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_213_222() {
    if (uniforms.b[6]) {
        sub_214_220();
    } else {
        sub_220_221();
    }
    return false;
}
bool sub_214_220() {
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    {
        sub_238_244();
    }
    reg_tmp5.x = dot_s(uniforms.f[7], reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8], reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_220_221() {
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
bool sub_223_231() {
    conditional_code = equal(uniforms.f[93].yz, reg_tmp0.xy);
    if (all(not(conditional_code))) {
        sub_225_226();
    } else {
        sub_226_230();
    }
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_225_226() {
    reg_tmp6.xy = (vs_in_reg4.xyyy).xy;
    return false;
}
bool sub_226_230() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_227_228();
    } else {
        sub_228_229();
    }
    return false;
}
bool sub_227_228() {
    reg_tmp6.xy = (vs_in_reg5.xyyy).xy;
    return false;
}
bool sub_228_229() {
    reg_tmp6.xy = (vs_in_reg6.xyyy).xy;
    return false;
}
bool sub_231_238() {
    reg_tmp2 = -reg_tmp15;
    reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
    reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_238_244() {
    reg_tmp1 = reg_tmp14;
    reg_tmp2.w = dot_3(reg_tmp1.xyz, reg_tmp1.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp1 = mul_s(reg_tmp1, reg_tmp2.wwww);
    reg_tmp1 = mul_s(uniforms.f[94].xxxx, reg_tmp1);
    reg_tmp6.xy = (uniforms.f[94].xxxx + reg_tmp1.xyyy).xy;
    return false;
}
bool sub_244_288() {
    reg_tmp1.xyz = (uniforms.f[93].xxyx).xyz;
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    reg_tmp14.w = (uniforms.f[93].xxxx).w;
    reg_tmp8 = reg_tmp14;
    reg_tmp14.x = dot_s(reg_tmp8, reg_tmp8);
    reg_tmp14.x = rsq_s(reg_tmp14.x);
    reg_tmp14 = mul_s(reg_tmp8, reg_tmp14.xxxx);
    reg_tmp8 = uniforms.f[83];
    reg_tmp6.x = dot_3(uniforms.f[90].xyz, reg_tmp8.xyz);
    reg_tmp6.y = dot_3(uniforms.f[91].xyz, reg_tmp8.xyz);
    reg_tmp6.z = dot_3(uniforms.f[92].xyz, reg_tmp8.xyz);
    reg_tmp8.xyz = (reg_tmp6.xyzz + reg_tmp1.xyzz).xyz;
    reg_tmp8.w = (uniforms.f[93].xxxx).w;
    reg_tmp0.x = dot_s(reg_tmp8, reg_tmp8);
    reg_tmp0.x = rsq_s(reg_tmp0.x);
    reg_tmp0 = mul_s(reg_tmp8, reg_tmp0.xxxx);
    reg_tmp2 = uniforms.f[93].xxxx;
    if (uniforms.b[9]) {
        sub_264_270();
    }
    if (uniforms.b[7]) {
        sub_271_278();
    }
    if (uniforms.b[8]) {
        sub_279_287();
    }
    vs_out_attr3 = reg_tmp2;
    return false;
}
bool sub_264_270() {
    reg_tmp8.x = dot_3(reg_tmp14.xyz, -reg_tmp6.xyz);
    reg_tmp8.y = dot_3(reg_tmp1.xyz, -reg_tmp6.xyz);
    reg_tmp8 = max(uniforms.f[93].xxxx, reg_tmp8);
    reg_tmp8.y = (mul_s(uniforms.f[94].xxxx, reg_tmp8.yyyy)).y;
    reg_tmp8.y = (uniforms.f[94].xxxx + reg_tmp8.yyyy).y;
    reg_tmp2.y = (mul_s(reg_tmp8.xxxx, reg_tmp8.yyyy)).y;
    return false;
}
bool sub_271_278() {
    reg_tmp9.z = dot_3(reg_tmp14.xyz, reg_tmp0.xyz);
    reg_tmp9.z = (max(uniforms.f[93].xxxx, reg_tmp9.zzzz)).z;
    reg_tmp9.z = (min(uniforms.f[93].yyyy, reg_tmp9.zzzz)).z;
    reg_tmp9.z = log2(reg_tmp9.z);
    reg_tmp9.z = (mul_s(uniforms.f[82].zzzz, reg_tmp9.zzzz)).z;
    reg_tmp9.z = exp2(reg_tmp9.z);
    reg_tmp2.z = (mul_s(uniforms.f[82].wwww, reg_tmp9.zzzz)).z;
    return false;
}
bool sub_279_287() {
    reg_tmp9.x = dot_3(reg_tmp14.xyz, reg_tmp1.xyz);
    reg_tmp9.x = (max(uniforms.f[93].xxxx, reg_tmp9.xxxx)).x;
    reg_tmp9.x = (min(uniforms.f[93].yyyy, reg_tmp9.xxxx)).x;
    reg_tmp9.x = (uniforms.f[93].yyyy + -reg_tmp9.xxxx).x;
    reg_tmp9.x = log2(reg_tmp9.x);
    reg_tmp9.x = (mul_s(uniforms.f[82].xxxx, reg_tmp9.xxxx)).x;
    reg_tmp9.x = exp2(reg_tmp9.x);
    reg_tmp2.w = (mul_s(uniforms.f[82].yyyy, reg_tmp9.xxxx)).w;
    return false;
}
bool sub_288_4096() {
    if (uniforms.b[10]) {
        sub_289_291();
    } else {
        sub_291_293();
    }
    if (uniforms.b[1]) {
        sub_294_296();
    } else {
        sub_296_298();
    }
    {
        sub_156_183();
    }
    {
        sub_183_207();
    }
    {
        sub_207_223();
    }
    return true;
}
bool sub_289_291() {
    {
        sub_65_116();
    }
    return false;
}
bool sub_291_293() {
    {
        sub_116_156();
    }
    return false;
}
bool sub_294_296() {
    {
        sub_244_288();
    }
    return false;
}
bool sub_296_298() {
    vs_out_attr3 = uniforms.f[93].yyyy;
    return false;
}
// reference: 7189F77351681156, D03F0FE4B72A8E86
// program: D03F0FE4B72A8E86, B80FA1B7F97410CD, 1CBA1DD1EAE2F663
// reference: 3FDD0833E61D4522, D03F0FE4B72A8E86
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 6A08A79BE3FAC39D
// reference: AA13BDCB51F8393E, 2E530FFFDA886761
// program: FD3DADE0E2BC47C9, B80FA1B7F97410CD, 10AAC2A3349D1A7E
// reference: AA13BDCB14275DB2, FD3DADE0E2BC47C9
// shader: 8B31, 949D68475595512F

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define fma_s(x, y, z) (mix(x * y, vec4(0.0), isnan(x * y)) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_8();
bool sub_9_32();
bool sub_33_96();
bool sub_97_113();
bool sub_146_166();
bool sub_167_259();
bool sub_190_192();
bool sub_194_195();
bool sub_197_198();
bool sub_200_202();
bool sub_232_234();
bool sub_236_237();
bool sub_239_240();
bool sub_242_244();
bool sub_260_4096();
bool sub_280_281();
bool sub_281_282();

bool exec_shader() {
    sub_260_4096();
    return true;
}

bool sub_0_8() {
    address_registers.x = (ivec2(vs_in_reg0.zz)).x;
    reg_tmp10 = uniforms.f[0].xxxz;
    reg_tmp10.xy = (vs_in_reg0.xyyy).xy;
    reg_tmp11 = uniforms.f[0].xxxx;
    reg_tmp12 = uniforms.f[0].xxxx;
    reg_tmp13 = uniforms.f[0].zzzz;
    reg_tmp4 = uniforms.f[0].xxxx;
    reg_tmp5 = uniforms.f[0].xxxx;
    return false;
}
bool sub_9_32() {
    vs_out_attr0 = reg_tmp10;
    reg_tmp13 = mul_s(uniforms.f[82], reg_tmp13);
    vs_out_attr1 = reg_tmp13;
    reg_tmp11.y = (uniforms.f[0].zzzz + -reg_tmp11.yyyy).y;
    reg_tmp12.y = (uniforms.f[0].zzzz + -reg_tmp12.yyyy).y;
    reg_tmp14.y = (uniforms.f[81].wwww).y;
    reg_tmp14.x = (mul_s(uniforms.f[0].wwww, reg_tmp14.yyyy)).x;
    reg_tmp2.x = rcp_s(reg_tmp14.x);
    reg_tmp14.z = (reg_tmp2.xxxx).z;
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp11.xyyy).xy;
    reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    reg_tmp11.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp12.xyyy).xy;
    reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    reg_tmp12.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    vs_out_attr2 = reg_tmp11;
    vs_out_attr3 = reg_tmp12;
    return false;
}
bool sub_33_96() {
    reg_tmp6.xyz = (-reg_tmp0.xyzz).xyz;
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    reg_tmp7.xyz = vec3(rcp_s(uniforms.f[81].y));
    reg_tmp8.xyz = (fma_s(reg_tmp6.xyzz, reg_tmp7.xyzz, uniforms.f[0].yyyy)).xyz;
    reg_tmp7.xyz = (floor(reg_tmp8.xyzz)).xyz;
    reg_tmp6.xyz = (fma_s(reg_tmp7.xyzz, -uniforms.f[81].yyyy, reg_tmp6.xyzz)).xyz;
    reg_tmp6 = min(uniforms.f[81].xxxx, reg_tmp6);
    reg_tmp6 = max(-uniforms.f[81].xxxx, reg_tmp6);
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp6.xxxx, reg_tmp6.xxxx)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp6.xxxx)).y;
    reg_tmp4.x = (reg_tmp1.xxxx).x;
    reg_tmp5.x = (reg_tmp1.yyyy).x;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp6.yyyy, reg_tmp6.yyyy)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp6.yyyy)).y;
    reg_tmp4.y = (reg_tmp1.xxxx).y;
    reg_tmp5.y = (reg_tmp1.yyyy).y;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp6.zzzz, reg_tmp6.zzzz)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp6.zzzz)).y;
    reg_tmp4.z = (reg_tmp1.xxxx).z;
    reg_tmp5.z = (reg_tmp1.yyyy).z;
    reg_tmp2.x = (mul_s(reg_tmp4.yyyy, reg_tmp5.zzzz)).x;
    reg_tmp2.y = (mul_s(reg_tmp5.yyyy, reg_tmp5.zzzz)).y;
    reg_tmp6.x = (mul_s(reg_tmp4.yyyy, reg_tmp4.zzzz)).x;
    reg_tmp6.y = (reg_tmp5.zzzz).y;
    reg_tmp6.z = (mul_s(-reg_tmp5.yyyy, reg_tmp4.zzzz)).z;
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    reg_tmp7.x = (mul_s(-reg_tmp2.xxxx, reg_tmp4.xxxx)).x;
    reg_tmp7.x = (fma_s(reg_tmp5.yyyy, reg_tmp5.xxxx, reg_tmp7.xxxx)).x;
    reg_tmp7.y = (mul_s(reg_tmp4.zzzz, reg_tmp4.xxxx)).y;
    reg_tmp7.z = (mul_s(reg_tmp2.yyyy, reg_tmp4.xxxx)).z;
    reg_tmp7.z = (fma_s(reg_tmp4.yyyy, reg_tmp5.xxxx, reg_tmp7.zzzz)).z;
    reg_tmp7.w = (uniforms.f[0].xxxx).w;
    reg_tmp8.x = (mul_s(reg_tmp2.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp8.x = (fma_s(reg_tmp5.yyyy, reg_tmp4.xxxx, reg_tmp8.xxxx)).x;
    reg_tmp8.y = (mul_s(-reg_tmp4.zzzz, reg_tmp5.xxxx)).y;
    reg_tmp8.z = (mul_s(-reg_tmp2.yyyy, reg_tmp5.xxxx)).z;
    reg_tmp8.z = (fma_s(reg_tmp4.yyyy, reg_tmp4.xxxx, reg_tmp8.zzzz)).z;
    reg_tmp8.w = (uniforms.f[0].xxxx).w;
    reg_tmp9 = uniforms.f[0].xxxz;
    return false;
}
bool sub_97_113() {
    reg_tmp6.x = (uniforms.f[90].xxxx).x;
    reg_tmp6.y = (uniforms.f[91].xxxx).y;
    reg_tmp6.z = (uniforms.f[92].xxxx).z;
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    reg_tmp7.x = (uniforms.f[90].yyyy).x;
    reg_tmp7.y = (uniforms.f[91].yyyy).y;
    reg_tmp7.z = (uniforms.f[92].yyyy).z;
    reg_tmp7.w = (uniforms.f[0].xxxx).w;
    reg_tmp8.x = (uniforms.f[90].zzzz).x;
    reg_tmp8.y = (uniforms.f[91].zzzz).y;
    reg_tmp8.z = (uniforms.f[92].zzzz).z;
    reg_tmp8.w = (uniforms.f[0].xxxx).w;
    reg_tmp9.x = (uniforms.f[90].wwww).x;
    reg_tmp9.y = (uniforms.f[91].wwww).y;
    reg_tmp9.z = (uniforms.f[92].wwww).z;
    reg_tmp9.w = (uniforms.f[0].zzzz).w;
    return false;
}
bool sub_146_166() {
    reg_tmp2 = uniforms.f[90];
    reg_tmp3 = uniforms.f[91];
    reg_tmp4 = uniforms.f[92];
    reg_tmp5 = uniforms.f[0].xxxz;
    reg_tmp6 = mul_s(uniforms.f[86].xxxx, reg_tmp2);
    reg_tmp6 = fma_s(reg_tmp3, uniforms.f[86].yyyy, reg_tmp6);
    reg_tmp6 = fma_s(reg_tmp4, uniforms.f[86].zzzz, reg_tmp6);
    reg_tmp6 = fma_s(reg_tmp5, uniforms.f[86].wwww, reg_tmp6);
    reg_tmp7 = mul_s(uniforms.f[87].xxxx, reg_tmp2);
    reg_tmp7 = fma_s(reg_tmp3, uniforms.f[87].yyyy, reg_tmp7);
    reg_tmp7 = fma_s(reg_tmp4, uniforms.f[87].zzzz, reg_tmp7);
    reg_tmp7 = fma_s(reg_tmp5, uniforms.f[87].wwww, reg_tmp7);
    reg_tmp8 = mul_s(uniforms.f[88].xxxx, reg_tmp2);
    reg_tmp8 = fma_s(reg_tmp3, uniforms.f[88].yyyy, reg_tmp8);
    reg_tmp8 = fma_s(reg_tmp4, uniforms.f[88].zzzz, reg_tmp8);
    reg_tmp8 = fma_s(reg_tmp5, uniforms.f[88].wwww, reg_tmp8);
    reg_tmp9 = mul_s(uniforms.f[89].xxxx, reg_tmp2);
    reg_tmp9 = fma_s(reg_tmp3, uniforms.f[89].yyyy, reg_tmp9);
    reg_tmp9 = fma_s(reg_tmp4, uniforms.f[89].zzzz, reg_tmp9);
    reg_tmp9 = fma_s(reg_tmp5, uniforms.f[89].wwww, reg_tmp9);
    return false;
}
bool sub_167_259() {
    reg_tmp2.x = rcp_s(uniforms.f[81].y);
    reg_tmp2.xy = (mul_s(uniforms.f[2 + address_registers.x].zwww, reg_tmp2.xxxx)).xy;
    reg_tmp2.xy = (uniforms.f[0].yyyy + reg_tmp2.xyyy).xy;
    reg_tmp3.xy = (floor(reg_tmp2.xyyy)).xy;
    reg_tmp2.xy = (mul_s(uniforms.f[81].yyyy, reg_tmp3.xyyy)).xy;
    reg_tmp2.xy = (uniforms.f[2 + address_registers.x].zwww + -reg_tmp2.xyyy).xy;
    reg_tmp0.xy = (min(uniforms.f[81].xxxx, -reg_tmp2.xyyy)).xy;
    reg_tmp0.xy = (max(-uniforms.f[81].xxxx, reg_tmp0.xyyy)).xy;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp0.xxxx, reg_tmp0.xxxx)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.xxxx)).y;
    reg_tmp5.x = (uniforms.f[5 + address_registers.x].wwww).x;
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_190_192();
    }
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_194_195();
    }
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_197_198();
    }
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_200_202();
    }
    reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    reg_tmp4.z = (uniforms.f[83].xxxx).z;
    reg_tmp4.w = (-uniforms.f[83].yyyy).w;
    reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[3 + address_registers.x].xyyy)).xy;
    reg_tmp4.z = (-uniforms.f[3 + address_registers.x].zzzz).z;
    reg_tmp4.w = (-uniforms.f[3 + address_registers.x].wwww).w;
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    reg_tmp11.xy = (reg_tmp5.xyyy).xy;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp0.yyyy, reg_tmp0.yyyy)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.yyyy)).y;
    reg_tmp5.x = (uniforms.f[6 + address_registers.x].wwww).x;
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_232_234();
    }
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_236_237();
    }
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_239_240();
    }
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_242_244();
    }
    reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    reg_tmp4.z = (uniforms.f[83].zzzz).z;
    reg_tmp4.w = (-uniforms.f[83].wwww).w;
    reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[4 + address_registers.x].xyyy)).xy;
    reg_tmp4.z = (-uniforms.f[4 + address_registers.x].zzzz).z;
    reg_tmp4.w = (-uniforms.f[4 + address_registers.x].wwww).w;
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    reg_tmp12.xy = (reg_tmp5.xyyy).xy;
    return false;
}
bool sub_190_192() {
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_194_195() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_197_198() {
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_200_202() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_232_234() {
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_236_237() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_239_240() {
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_242_244() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_260_4096() {
    {
        sub_0_8();
    }
    reg_tmp10.xy = (uniforms.f[84].xyyy + reg_tmp10.xyyy).xy;
    reg_tmp10.xy = (mul_s(uniforms.f[2 + address_registers.x].xyyy, reg_tmp10.xyyy)).xy;
    reg_tmp0 = uniforms.f[7 + address_registers.x];
    {
        sub_33_96();
    }
    reg_tmp2.x = dot_s(reg_tmp10, reg_tmp6);
    reg_tmp2.y = dot_s(reg_tmp10, reg_tmp7);
    reg_tmp2.z = dot_s(reg_tmp10, reg_tmp8);
    reg_tmp2.w = dot_s(reg_tmp10, reg_tmp9);
    reg_tmp10 = reg_tmp2;
    {
        sub_97_113();
    }
    reg_tmp2.x = dot_s(reg_tmp10, reg_tmp6);
    reg_tmp2.y = dot_s(reg_tmp10, reg_tmp7);
    reg_tmp2.z = dot_s(reg_tmp10, reg_tmp8);
    reg_tmp2.w = dot_s(uniforms.f[0].xxxz, reg_tmp10);
    reg_tmp3.xyz = (uniforms.f[5 + address_registers.x].xyzz).xyz;
    reg_tmp3.xyz = (uniforms.f[85].xyzz + -reg_tmp3.xyzz).xyz;
    reg_tmp4.x = dot_3(reg_tmp3.xyz, reg_tmp3.xyz);
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
    if (conditional_code.x) {
        sub_280_281();
    } else {
        sub_281_282();
    }
    reg_tmp3.xyz = (mul_s(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
    reg_tmp10.xyz = (uniforms.f[5 + address_registers.x].xyzz + reg_tmp2.xyzz).xyz;
    reg_tmp10.xyz = (fma_s(reg_tmp3.xyzz, uniforms.f[84].zzzz, reg_tmp10.xyzz)).xyz;
    {
        sub_146_166();
    }
    reg_tmp2 = reg_tmp10;
    reg_tmp10.x = dot_s(reg_tmp2, reg_tmp6);
    reg_tmp10.y = dot_s(reg_tmp2, reg_tmp7);
    reg_tmp10.z = dot_s(reg_tmp2, reg_tmp8);
    reg_tmp10.w = dot_s(reg_tmp2, reg_tmp9);
    reg_tmp2 = uniforms.f[1 + address_registers.x];
    reg_tmp3 = max(uniforms.f[0].xxxx, reg_tmp2);
    reg_tmp2 = min(uniforms.f[0].zzzz, reg_tmp3);
    reg_tmp13 = reg_tmp2;
    {
        sub_167_259();
    }
    {
        sub_9_32();
    }
    return true;
}
bool sub_280_281() {
    reg_tmp4.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_281_282() {
    reg_tmp4.x = rsq_s(reg_tmp4.x);
    return false;
}
// reference: 54C62F0A5269B400, 949D68475595512F
// program: 949D68475595512F, 082670B4222015B2, 0D19D21B46AD8D9B
// reference: AE4BD47E9EE40487, 81B0676B862CF405
// reference: E01F2B3E299150F3, 81B0676B862CF405
// reference: 8C39401B8C9B3800, 2E530FFFDA886761
// reference: C26DBF5BF4707BBC, 2E530FFFDA886761
// reference: C26DBF5B3BEE6C74, 2E530FFFDA886761
// reference: 8C39401B267DCFCD, FD3DADE0E2BC47C9
// reference: AE4BD47E25754155, 81B0676B862CF405
// reference: E01F2B3E92001521, 81B0676B862CF405
// reference: A7400F4493C340D4, 46E991DEB658A5A9
// reference: 60055AF2F46AEF85, 466184E6A05DFF0F
// reference: BF7478292850E667, 45C9694A57480945
// reference: 8E5EF57051681156, D03F0FE4B72A8E86
// reference: C00A0A30E61D4522, D03F0FE4B72A8E86
// reference: AE4BD47E5C618AB3, 81B0676B862CF405
// reference: E01F2B3E248AC90F, 81B0676B862CF405
// reference: A7400F44EAD78B32, 46E991DEB658A5A9
// reference: E01F2B3EEB14DEC7, 81B0676B862CF405
// program: 81B0676B862CF405, 42937135801BAA7E, 29CD3EBE51FAA42A
// program: 81B0676B862CF405, 42937135801BAA7E, B2E64CFB9744D892
// program: 81B0676B862CF405, 42937135801BAA7E, 98647FD3CF93B689
// reference: A7400F4428520506, 46E991DEB658A5A9
// reference: 54C62F0ABD502741, 949D68475595512F
// reference: E01F2B3EC6A8C3B2, 81B0676B862CF405
// reference: C26DBF5BD4D7FF35, 2E530FFFDA886761
// program: 949D68475595512F, 082670B4222015B2, DBA0F8FE46AD8D9B
// shader: 8B31, 2FBE2E4ED1D9324C

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define fma_s(x, y, z) (mix(x * y, vec4(0.0), isnan(x * y)) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_8();
bool sub_9_32();
bool sub_97_113();
bool sub_146_166();
bool sub_167_259();
bool sub_190_192();
bool sub_194_195();
bool sub_197_198();
bool sub_200_202();
bool sub_232_234();
bool sub_236_237();
bool sub_239_240();
bool sub_242_244();
bool sub_260_4096();
bool sub_273_274();
bool sub_274_275();

bool exec_shader() {
    sub_260_4096();
    return true;
}

bool sub_0_8() {
    address_registers.x = (ivec2(vs_in_reg0.zz)).x;
    reg_tmp10 = uniforms.f[0].xxxz;
    reg_tmp10.xy = (vs_in_reg0.xyyy).xy;
    reg_tmp11 = uniforms.f[0].xxxx;
    reg_tmp12 = uniforms.f[0].xxxx;
    reg_tmp13 = uniforms.f[0].zzzz;
    reg_tmp4 = uniforms.f[0].xxxx;
    reg_tmp5 = uniforms.f[0].xxxx;
    return false;
}
bool sub_9_32() {
    vs_out_attr0 = reg_tmp10;
    reg_tmp13 = mul_s(uniforms.f[82], reg_tmp13);
    vs_out_attr1 = reg_tmp13;
    reg_tmp11.y = (uniforms.f[0].zzzz + -reg_tmp11.yyyy).y;
    reg_tmp12.y = (uniforms.f[0].zzzz + -reg_tmp12.yyyy).y;
    reg_tmp14.y = (uniforms.f[81].wwww).y;
    reg_tmp14.x = (mul_s(uniforms.f[0].wwww, reg_tmp14.yyyy)).x;
    reg_tmp2.x = rcp_s(reg_tmp14.x);
    reg_tmp14.z = (reg_tmp2.xxxx).z;
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp11.xyyy).xy;
    reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    reg_tmp11.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp12.xyyy).xy;
    reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    reg_tmp12.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    vs_out_attr2 = reg_tmp11;
    vs_out_attr3 = reg_tmp12;
    return false;
}
bool sub_97_113() {
    reg_tmp6.x = (uniforms.f[90].xxxx).x;
    reg_tmp6.y = (uniforms.f[91].xxxx).y;
    reg_tmp6.z = (uniforms.f[92].xxxx).z;
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    reg_tmp7.x = (uniforms.f[90].yyyy).x;
    reg_tmp7.y = (uniforms.f[91].yyyy).y;
    reg_tmp7.z = (uniforms.f[92].yyyy).z;
    reg_tmp7.w = (uniforms.f[0].xxxx).w;
    reg_tmp8.x = (uniforms.f[90].zzzz).x;
    reg_tmp8.y = (uniforms.f[91].zzzz).y;
    reg_tmp8.z = (uniforms.f[92].zzzz).z;
    reg_tmp8.w = (uniforms.f[0].xxxx).w;
    reg_tmp9.x = (uniforms.f[90].wwww).x;
    reg_tmp9.y = (uniforms.f[91].wwww).y;
    reg_tmp9.z = (uniforms.f[92].wwww).z;
    reg_tmp9.w = (uniforms.f[0].zzzz).w;
    return false;
}
bool sub_146_166() {
    reg_tmp2 = uniforms.f[90];
    reg_tmp3 = uniforms.f[91];
    reg_tmp4 = uniforms.f[92];
    reg_tmp5 = uniforms.f[0].xxxz;
    reg_tmp6 = mul_s(uniforms.f[86].xxxx, reg_tmp2);
    reg_tmp6 = fma_s(reg_tmp3, uniforms.f[86].yyyy, reg_tmp6);
    reg_tmp6 = fma_s(reg_tmp4, uniforms.f[86].zzzz, reg_tmp6);
    reg_tmp6 = fma_s(reg_tmp5, uniforms.f[86].wwww, reg_tmp6);
    reg_tmp7 = mul_s(uniforms.f[87].xxxx, reg_tmp2);
    reg_tmp7 = fma_s(reg_tmp3, uniforms.f[87].yyyy, reg_tmp7);
    reg_tmp7 = fma_s(reg_tmp4, uniforms.f[87].zzzz, reg_tmp7);
    reg_tmp7 = fma_s(reg_tmp5, uniforms.f[87].wwww, reg_tmp7);
    reg_tmp8 = mul_s(uniforms.f[88].xxxx, reg_tmp2);
    reg_tmp8 = fma_s(reg_tmp3, uniforms.f[88].yyyy, reg_tmp8);
    reg_tmp8 = fma_s(reg_tmp4, uniforms.f[88].zzzz, reg_tmp8);
    reg_tmp8 = fma_s(reg_tmp5, uniforms.f[88].wwww, reg_tmp8);
    reg_tmp9 = mul_s(uniforms.f[89].xxxx, reg_tmp2);
    reg_tmp9 = fma_s(reg_tmp3, uniforms.f[89].yyyy, reg_tmp9);
    reg_tmp9 = fma_s(reg_tmp4, uniforms.f[89].zzzz, reg_tmp9);
    reg_tmp9 = fma_s(reg_tmp5, uniforms.f[89].wwww, reg_tmp9);
    return false;
}
bool sub_167_259() {
    reg_tmp2.x = rcp_s(uniforms.f[81].y);
    reg_tmp2.xy = (mul_s(uniforms.f[2 + address_registers.x].zwww, reg_tmp2.xxxx)).xy;
    reg_tmp2.xy = (uniforms.f[0].yyyy + reg_tmp2.xyyy).xy;
    reg_tmp3.xy = (floor(reg_tmp2.xyyy)).xy;
    reg_tmp2.xy = (mul_s(uniforms.f[81].yyyy, reg_tmp3.xyyy)).xy;
    reg_tmp2.xy = (uniforms.f[2 + address_registers.x].zwww + -reg_tmp2.xyyy).xy;
    reg_tmp0.xy = (min(uniforms.f[81].xxxx, -reg_tmp2.xyyy)).xy;
    reg_tmp0.xy = (max(-uniforms.f[81].xxxx, reg_tmp0.xyyy)).xy;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp0.xxxx, reg_tmp0.xxxx)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.xxxx)).y;
    reg_tmp5.x = (uniforms.f[5 + address_registers.x].wwww).x;
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_190_192();
    }
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_194_195();
    }
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_197_198();
    }
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_200_202();
    }
    reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    reg_tmp4.z = (uniforms.f[83].xxxx).z;
    reg_tmp4.w = (-uniforms.f[83].yyyy).w;
    reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[3 + address_registers.x].xyyy)).xy;
    reg_tmp4.z = (-uniforms.f[3 + address_registers.x].zzzz).z;
    reg_tmp4.w = (-uniforms.f[3 + address_registers.x].wwww).w;
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    reg_tmp11.xy = (reg_tmp5.xyyy).xy;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp0.yyyy, reg_tmp0.yyyy)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.yyyy)).y;
    reg_tmp5.x = (uniforms.f[6 + address_registers.x].wwww).x;
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_232_234();
    }
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_236_237();
    }
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_239_240();
    }
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_242_244();
    }
    reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    reg_tmp4.z = (uniforms.f[83].zzzz).z;
    reg_tmp4.w = (-uniforms.f[83].wwww).w;
    reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[4 + address_registers.x].xyyy)).xy;
    reg_tmp4.z = (-uniforms.f[4 + address_registers.x].zzzz).z;
    reg_tmp4.w = (-uniforms.f[4 + address_registers.x].wwww).w;
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    reg_tmp12.xy = (reg_tmp5.xyyy).xy;
    return false;
}
bool sub_190_192() {
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_194_195() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_197_198() {
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_200_202() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_232_234() {
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_236_237() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_239_240() {
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_242_244() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_260_4096() {
    {
        sub_0_8();
    }
    reg_tmp10.xy = (uniforms.f[84].xyyy + reg_tmp10.xyyy).xy;
    reg_tmp10.xy = (mul_s(uniforms.f[2 + address_registers.x].xyyy, reg_tmp10.xyyy)).xy;
    {
        sub_97_113();
    }
    reg_tmp2.x = dot_s(reg_tmp10, reg_tmp6);
    reg_tmp2.y = dot_s(reg_tmp10, reg_tmp7);
    reg_tmp2.z = dot_s(reg_tmp10, reg_tmp8);
    reg_tmp2.w = dot_s(uniforms.f[0].xxxz, reg_tmp10);
    reg_tmp3.xyz = (uniforms.f[5 + address_registers.x].xyzz).xyz;
    reg_tmp3.xyz = (uniforms.f[85].xyzz + -reg_tmp3.xyzz).xyz;
    reg_tmp4.x = dot_3(reg_tmp3.xyz, reg_tmp3.xyz);
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
    if (conditional_code.x) {
        sub_273_274();
    } else {
        sub_274_275();
    }
    reg_tmp3.xyz = (mul_s(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
    reg_tmp10.xyz = (uniforms.f[5 + address_registers.x].xyzz + reg_tmp2.xyzz).xyz;
    reg_tmp10.xyz = (fma_s(reg_tmp3.xyzz, uniforms.f[84].zzzz, reg_tmp10.xyzz)).xyz;
    {
        sub_146_166();
    }
    reg_tmp2 = reg_tmp10;
    reg_tmp10.x = dot_s(reg_tmp2, reg_tmp6);
    reg_tmp10.y = dot_s(reg_tmp2, reg_tmp7);
    reg_tmp10.z = dot_s(reg_tmp2, reg_tmp8);
    reg_tmp10.w = dot_s(reg_tmp2, reg_tmp9);
    reg_tmp2 = uniforms.f[1 + address_registers.x];
    reg_tmp3 = max(uniforms.f[0].xxxx, reg_tmp2);
    reg_tmp2 = min(uniforms.f[0].zzzz, reg_tmp3);
    reg_tmp13 = reg_tmp2;
    {
        sub_167_259();
    }
    {
        sub_9_32();
    }
    return true;
}
bool sub_273_274() {
    reg_tmp4.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_274_275() {
    reg_tmp4.x = rsq_s(reg_tmp4.x);
    return false;
}
// reference: 9A2ECF1DBB6D136E, 2FBE2E4ED1D9324C
// program: 2FBE2E4ED1D9324C, 082670B4222015B2, DBA0F8FE46AD8D9B
// program: 2FBE2E4ED1D9324C, 082670B4222015B2, F4A415D97E9B6ED6
// program: 81B0676B862CF405, 42937135801BAA7E, AB0D786CFAD777F8
// reference: 58970D47BA9CDC6E, 46E991DEB658A5A9
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 6A44D3E672630106
// program: 45C9694A57480945, B80FA1B7F97410CD, 0AC00F84117E7EFC
// shader: 8B31, 1B722ADD909A7B2D

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;
out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define fma_s(x, y, z) (mix(x * y, vec4(0.0), isnan(x * y)) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_19();
bool sub_19_29();
bool sub_29_79();
bool sub_34_52();
bool sub_52_60();
bool sub_77_78();
bool sub_79_106();
bool sub_81_86();
bool sub_86_105();
bool sub_89_95();
bool sub_95_104();
bool sub_96_100();
bool sub_100_103();
bool sub_106_130();
bool sub_108_112();
bool sub_112_129();
bool sub_113_127();
bool sub_116_123();
bool sub_123_126();
bool sub_127_128();
bool sub_130_146();
bool sub_132_136();
bool sub_136_145();
bool sub_137_143();
bool sub_143_144();
bool sub_146_154();
bool sub_148_149();
bool sub_149_153();
bool sub_150_151();
bool sub_151_152();
bool sub_154_161();
bool sub_161_167();
bool sub_167_4096();

bool exec_shader() {
    sub_167_4096();
    return true;
}

bool sub_0_19() {
    uint jmp_to = 0u;
    while (true) {
        switch (jmp_to) {
        case 0u: {
            reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
            reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
            reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
            reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
            reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
            reg_tmp6.x = rsq_s(reg_tmp6.x);
            reg_tmp7.x = rsq_s(reg_tmp7.x);
            reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            reg_tmp0 = uniforms.f[93].yxxx;
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            reg_tmp4 = mul_s(uniforms.f[94].xxxx, reg_tmp4);
            conditional_code = greaterThanEqual(uniforms.f[93].xx, reg_tmp4.xx);
            reg_tmp4 = vec4(rsq_s(reg_tmp4.x));
            reg_tmp5 = mul_s(uniforms.f[94].xxxx, reg_tmp14);
            if (conditional_code.x) {
                { jmp_to = 18u; break; }
            }
            reg_tmp0.z = rcp_s(reg_tmp4.x);
            reg_tmp0.xy = (mul_s(reg_tmp5, reg_tmp4)).xy;
        }
        case 18u: {
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_19_29() {
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    reg_tmp4.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_29_79() {
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    reg_tmp13.xyz = (vs_in_reg2).xyz;
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    if (uniforms.b[0]) {
        sub_34_52();
    } else {
        sub_52_60();
    }
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    {
        sub_0_19();
    }
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    vs_out_attr2 = -reg_tmp15;
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    if (all(conditional_code)) {
        sub_77_78();
    }
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_34_52() {
    reg_tmp7 = uniforms.f[93].xxxx;
    reg_tmp12 = uniforms.f[93].xxxx;
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    {
        sub_19_29();
    }
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    {
        sub_19_29();
    }
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    {
        sub_19_29();
    }
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    {
        sub_19_29();
    }
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    reg_tmp10 = reg_tmp7;
    return false;
}
bool sub_52_60() {
    reg_tmp7 = reg_tmp15;
    reg_tmp10.x = dot_s(uniforms.f[10], reg_tmp7);
    reg_tmp10.y = dot_s(uniforms.f[11], reg_tmp7);
    reg_tmp10.z = dot_s(uniforms.f[12], reg_tmp7);
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    reg_tmp12.x = dot_3(uniforms.f[10].xyz, reg_tmp14.xyz);
    reg_tmp12.y = dot_3(uniforms.f[11].xyz, reg_tmp14.xyz);
    reg_tmp12.z = dot_3(uniforms.f[12].xyz, reg_tmp14.xyz);
    return false;
}
bool sub_77_78() {
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_79_106() {
    reg_tmp0.xy = (uniforms.f[0].xxxx).xy;
    if (uniforms.b[2]) {
        sub_81_86();
    } else {
        sub_86_105();
    }
    return false;
}
bool sub_81_86() {
    {
        sub_146_154();
    }
    reg_tmp3.x = dot_s(uniforms.f[1].xywz, reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2].xywz, reg_tmp6);
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_86_105() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_89_95();
    } else {
        sub_95_104();
    }
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_89_95() {
    reg_tmp6 = reg_tmp10;
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    reg_tmp3.z = dot_s(uniforms.f[3], reg_tmp6);
    reg_tmp0.xy = (mul_s(uniforms.f[9].xyyy, reg_tmp3.zzzz)).xy;
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_95_104() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_96_100();
    } else {
        sub_100_103();
    }
    return false;
}
bool sub_96_100() {
    {
        sub_154_161();
    }
    reg_tmp3.x = dot_3(uniforms.f[1].xyz, reg_tmp6.xyz);
    reg_tmp3.y = dot_3(uniforms.f[2].xyz, reg_tmp6.xyz);
    reg_tmp3.z = dot_3(uniforms.f[3].xyz, reg_tmp6.xyz);
    return false;
}
bool sub_100_103() {
    {
        sub_161_167();
    }
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    return false;
}
bool sub_106_130() {
    reg_tmp0.xy = (uniforms.f[0].yyyy).xy;
    if (uniforms.b[3]) {
        sub_108_112();
    } else {
        sub_112_129();
    }
    return false;
}
bool sub_108_112() {
    {
        sub_146_154();
    }
    reg_tmp4.x = dot_s(uniforms.f[4].xywz, reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5].xywz, reg_tmp6);
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_112_129() {
    if (uniforms.b[5]) {
        sub_113_127();
    } else {
        sub_127_128();
    }
    return false;
}
bool sub_113_127() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_116_123();
    } else {
        sub_123_126();
    }
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_116_123() {
    reg_tmp6 = reg_tmp10;
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    reg_tmp4.z = dot_s(uniforms.f[6], reg_tmp6);
    reg_tmp6.w = rcp_s(reg_tmp4.z);
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    reg_tmp4.xy = (uniforms.f[9].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_123_126() {
    {
        sub_161_167();
    }
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    return false;
}
bool sub_127_128() {
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_130_146() {
    reg_tmp0.xy = (uniforms.f[0].zzzz).xy;
    if (uniforms.b[4]) {
        sub_132_136();
    } else {
        sub_136_145();
    }
    return false;
}
bool sub_132_136() {
    {
        sub_146_154();
    }
    reg_tmp5.x = dot_s(uniforms.f[7].xywz, reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8].xywz, reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_136_145() {
    if (uniforms.b[6]) {
        sub_137_143();
    } else {
        sub_143_144();
    }
    return false;
}
bool sub_137_143() {
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    {
        sub_161_167();
    }
    reg_tmp5.x = dot_s(uniforms.f[7], reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8], reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_143_144() {
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
bool sub_146_154() {
    conditional_code = equal(uniforms.f[93].yz, reg_tmp0.xy);
    if (all(not(conditional_code))) {
        sub_148_149();
    } else {
        sub_149_153();
    }
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_148_149() {
    reg_tmp6.xy = (vs_in_reg4.xyyy).xy;
    return false;
}
bool sub_149_153() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_150_151();
    } else {
        sub_151_152();
    }
    return false;
}
bool sub_150_151() {
    reg_tmp6.xy = (vs_in_reg5.xyyy).xy;
    return false;
}
bool sub_151_152() {
    reg_tmp6.xy = (vs_in_reg6.xyyy).xy;
    return false;
}
bool sub_154_161() {
    reg_tmp2 = -reg_tmp15;
    reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
    reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_161_167() {
    reg_tmp1 = reg_tmp14;
    reg_tmp2.w = dot_3(reg_tmp1.xyz, reg_tmp1.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp1 = mul_s(reg_tmp1, reg_tmp2.wwww);
    reg_tmp1 = mul_s(uniforms.f[94].xxxx, reg_tmp1);
    reg_tmp6.xy = (uniforms.f[94].xxxx + reg_tmp1.xyyy).xy;
    return false;
}
bool sub_167_4096() {
    {
        sub_29_79();
    }
    reg_tmp2 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
    reg_tmp1.xyz = (uniforms.f[93].xxyx).xyz;
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    reg_tmp14.w = (uniforms.f[93].xxxx).w;
    reg_tmp8 = reg_tmp14;
    reg_tmp14.x = dot_s(reg_tmp8, reg_tmp8);
    reg_tmp14.x = rsq_s(reg_tmp14.x);
    reg_tmp14 = mul_s(reg_tmp8, reg_tmp14.xxxx);
    reg_tmp9.x = dot_3(reg_tmp14.xyz, reg_tmp1.xyz);
    reg_tmp9.x = (max(uniforms.f[93].xxxx, reg_tmp9.xxxx)).x;
    reg_tmp9.x = (min(uniforms.f[93].yyyy, reg_tmp9.xxxx)).x;
    reg_tmp9.x = (uniforms.f[93].yyyy + -reg_tmp9.xxxx).x;
    reg_tmp9.x = log2(reg_tmp9.x);
    reg_tmp9.x = (mul_s(uniforms.f[82].xxxx, reg_tmp9.xxxx)).x;
    reg_tmp9.x = exp2(reg_tmp9.x);
    reg_tmp2.w = (mul_s(uniforms.f[82].yyyy, reg_tmp9.xxxx)).w;
    vs_out_attr3 = reg_tmp2;
    {
        sub_79_106();
    }
    {
        sub_106_130();
    }
    {
        sub_130_146();
    }
    return true;
}
// reference: 36C80D5267275274, 1B722ADD909A7B2D
// program: 1B722ADD909A7B2D, B80FA1B7F97410CD, B3C2F6056AADCF6F
// reference: 789CF212D0520600, 1B722ADD909A7B2D
// reference: 9790BAAFCFB73553, 1B722ADD909A7B2D
// program: 1B722ADD909A7B2D, B80FA1B7F97410CD, A36D1D6BA424DB28
// reference: D9C445EF78C26127, 1B722ADD909A7B2D
// program: 1B722ADD909A7B2D, B80FA1B7F97410CD, 641FDB3E9E36B758
// reference: 1A92D04AD9F5BF4F, 949D68475595512F
// program: 949D68475595512F, 082670B4222015B2, 1430EF96EBF7840F
// reference: 54C62F0A81B9787A, 949D68475595512F
// shader: 8B31, B0CCAE4F9AB69CDA

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;
out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define fma_s(x, y, z) (mix(x * y, vec4(0.0), isnan(x * y)) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_6();
bool sub_6_53();
bool sub_21_25();
bool sub_51_52();
bool sub_53_4096();

bool exec_shader() {
    sub_53_4096();
    return true;
}

bool sub_0_6() {
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    return false;
}
bool sub_6_53() {
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    reg_tmp7 = uniforms.f[93].xxxx;
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    {
        sub_0_6();
    }
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    {
        sub_0_6();
    }
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    if (conditional_code.x) {
        sub_0_6();
    }
    if (uniforms.b[11]) {
        sub_21_25();
    }
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    reg_tmp10 = reg_tmp7;
    reg_tmp6.y = (-uniforms.f[83].wwww + reg_tmp10.yyyy).y;
    reg_tmp9.xyz = (uniforms.f[83].xyzz).xyz;
    reg_tmp7.x = dot_s(reg_tmp9.xyzz, reg_tmp9.xyzz);
    reg_tmp7.x = rsq_s(reg_tmp7.x);
    reg_tmp7.xyz = (mul_s(reg_tmp9.xyzz, reg_tmp7.xxxx)).xyz;
    reg_tmp8.y = rcp_s(-reg_tmp7.y);
    reg_tmp8.y = (mul_s(reg_tmp6.yyyy, reg_tmp8.yyyy)).y;
    reg_tmp7.xyz = (mul_s(reg_tmp7.xyzz, reg_tmp8.yyyy)).xyz;
    reg_tmp10.xyz = (reg_tmp10.xyzz + reg_tmp7.xyzz).xyz;
    reg_tmp10.y = (uniforms.f[94].xxxx + reg_tmp10.yyyy).y;
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    vs_out_attr1 = uniforms.f[93].xxxx;
    vs_out_attr2 = -reg_tmp15;
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    if (all(conditional_code)) {
        sub_51_52();
    }
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_21_25() {
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    if (conditional_code.y) {
        sub_0_6();
    }
    return false;
}
bool sub_51_52() {
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_53_4096() {
    {
        sub_6_53();
    }
    vs_out_attr4 = uniforms.f[93].xxxx;
    vs_out_attr5 = uniforms.f[93].xxxx;
    vs_out_attr6 = uniforms.f[93].xxxx;
    vs_out_attr3 = uniforms.f[93].xxxx;
    return true;
}
// reference: 88E78CBE02CBE470, B0CCAE4F9AB69CDA
// program: B0CCAE4F9AB69CDA, B80FA1B7F97410CD, C2EEBEAE0D7F3560
// program: D03F0FE4B72A8E86, B80FA1B7F97410CD, 9D0535C6802495CB
// reference: 9A2ECF1D87844C55, 2FBE2E4ED1D9324C
// program: 949D68475595512F, 082670B4222015B2, 63A5270519B4AE20
// reference: D47A305DDFC88B60, 2FBE2E4ED1D9324C
// reference: D47A305DD620EB65, 2FBE2E4ED1D9324C
// reference: 9A2ECF1D8E6C2C50, 2FBE2E4ED1D9324C
// reference: D186A7B1F6C43D4B, 466184E6A05DFF0F
// program: 81B0676B862CF405, 42937135801BAA7E, 49F399BDFAD777F8
// program: 81B0676B862CF405, 42937135801BAA7E, 00F9BB7ACF93B689
// shader: 8B31, A214E3C9645157AE

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;
out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define fma_s(x, y, z) (mix(x * y, vec4(0.0), isnan(x * y)) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_19();
bool sub_19_29();
bool sub_29_76();
bool sub_33_51();
bool sub_51_59();
bool sub_74_75();
bool sub_76_103();
bool sub_78_83();
bool sub_83_102();
bool sub_86_92();
bool sub_92_101();
bool sub_93_97();
bool sub_97_100();
bool sub_103_127();
bool sub_105_109();
bool sub_109_126();
bool sub_110_124();
bool sub_113_120();
bool sub_120_123();
bool sub_124_125();
bool sub_127_143();
bool sub_129_133();
bool sub_133_142();
bool sub_134_140();
bool sub_140_141();
bool sub_143_151();
bool sub_145_146();
bool sub_146_150();
bool sub_147_148();
bool sub_148_149();
bool sub_151_158();
bool sub_158_164();
bool sub_164_4096();
bool sub_166_173();
bool sub_173_174();

bool exec_shader() {
    sub_164_4096();
    return true;
}

bool sub_0_19() {
    uint jmp_to = 0u;
    while (true) {
        switch (jmp_to) {
        case 0u: {
            reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
            reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
            reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
            reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
            reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
            reg_tmp6.x = rsq_s(reg_tmp6.x);
            reg_tmp7.x = rsq_s(reg_tmp7.x);
            reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            reg_tmp0 = uniforms.f[93].yxxx;
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            reg_tmp4 = mul_s(uniforms.f[94].xxxx, reg_tmp4);
            conditional_code = greaterThanEqual(uniforms.f[93].xx, reg_tmp4.xx);
            reg_tmp4 = vec4(rsq_s(reg_tmp4.x));
            reg_tmp5 = mul_s(uniforms.f[94].xxxx, reg_tmp14);
            if (conditional_code.x) {
                { jmp_to = 18u; break; }
            }
            reg_tmp0.z = rcp_s(reg_tmp4.x);
            reg_tmp0.xy = (mul_s(reg_tmp5, reg_tmp4)).xy;
        }
        case 18u: {
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_19_29() {
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    reg_tmp4.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_29_76() {
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    if (uniforms.b[0]) {
        sub_33_51();
    } else {
        sub_51_59();
    }
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    {
        sub_0_19();
    }
    vs_out_attr2 = reg_tmp15;
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    if (all(conditional_code)) {
        sub_74_75();
    }
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_33_51() {
    reg_tmp7 = uniforms.f[93].xxxx;
    reg_tmp12 = uniforms.f[93].xxxx;
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    {
        sub_19_29();
    }
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    {
        sub_19_29();
    }
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    {
        sub_19_29();
    }
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    {
        sub_19_29();
    }
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    reg_tmp10 = reg_tmp7;
    return false;
}
bool sub_51_59() {
    reg_tmp7 = reg_tmp15;
    reg_tmp10.x = dot_s(uniforms.f[10], reg_tmp7);
    reg_tmp10.y = dot_s(uniforms.f[11], reg_tmp7);
    reg_tmp10.z = dot_s(uniforms.f[12], reg_tmp7);
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    reg_tmp12.x = dot_3(uniforms.f[10].xyz, reg_tmp14.xyz);
    reg_tmp12.y = dot_3(uniforms.f[11].xyz, reg_tmp14.xyz);
    reg_tmp12.z = dot_3(uniforms.f[12].xyz, reg_tmp14.xyz);
    return false;
}
bool sub_74_75() {
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_76_103() {
    reg_tmp0.xy = (uniforms.f[0].xxxx).xy;
    if (uniforms.b[2]) {
        sub_78_83();
    } else {
        sub_83_102();
    }
    return false;
}
bool sub_78_83() {
    {
        sub_143_151();
    }
    reg_tmp3.x = dot_s(uniforms.f[1].xywz, reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2].xywz, reg_tmp6);
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_83_102() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_86_92();
    } else {
        sub_92_101();
    }
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_86_92() {
    reg_tmp6 = reg_tmp10;
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    reg_tmp3.z = dot_s(uniforms.f[3], reg_tmp6);
    reg_tmp0.xy = (mul_s(uniforms.f[9].xyyy, reg_tmp3.zzzz)).xy;
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_92_101() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_93_97();
    } else {
        sub_97_100();
    }
    return false;
}
bool sub_93_97() {
    {
        sub_151_158();
    }
    reg_tmp3.x = dot_3(uniforms.f[1].xyz, reg_tmp6.xyz);
    reg_tmp3.y = dot_3(uniforms.f[2].xyz, reg_tmp6.xyz);
    reg_tmp3.z = dot_3(uniforms.f[3].xyz, reg_tmp6.xyz);
    return false;
}
bool sub_97_100() {
    {
        sub_158_164();
    }
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    return false;
}
bool sub_103_127() {
    reg_tmp0.xy = (uniforms.f[0].yyyy).xy;
    if (uniforms.b[3]) {
        sub_105_109();
    } else {
        sub_109_126();
    }
    return false;
}
bool sub_105_109() {
    {
        sub_143_151();
    }
    reg_tmp4.x = dot_s(uniforms.f[4].xywz, reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5].xywz, reg_tmp6);
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_109_126() {
    if (uniforms.b[5]) {
        sub_110_124();
    } else {
        sub_124_125();
    }
    return false;
}
bool sub_110_124() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_113_120();
    } else {
        sub_120_123();
    }
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_113_120() {
    reg_tmp6 = reg_tmp10;
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    reg_tmp4.z = dot_s(uniforms.f[6], reg_tmp6);
    reg_tmp6.w = rcp_s(reg_tmp4.z);
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    reg_tmp4.xy = (uniforms.f[9].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_120_123() {
    {
        sub_158_164();
    }
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    return false;
}
bool sub_124_125() {
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_127_143() {
    reg_tmp0.xy = (uniforms.f[0].zzzz).xy;
    if (uniforms.b[4]) {
        sub_129_133();
    } else {
        sub_133_142();
    }
    return false;
}
bool sub_129_133() {
    {
        sub_143_151();
    }
    reg_tmp5.x = dot_s(uniforms.f[7].xywz, reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8].xywz, reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_133_142() {
    if (uniforms.b[6]) {
        sub_134_140();
    } else {
        sub_140_141();
    }
    return false;
}
bool sub_134_140() {
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    {
        sub_158_164();
    }
    reg_tmp5.x = dot_s(uniforms.f[7], reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8], reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_140_141() {
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
bool sub_143_151() {
    conditional_code = equal(uniforms.f[93].yz, reg_tmp0.xy);
    if (all(not(conditional_code))) {
        sub_145_146();
    } else {
        sub_146_150();
    }
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_145_146() {
    reg_tmp6.xy = (vs_in_reg4.xyyy).xy;
    return false;
}
bool sub_146_150() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_147_148();
    } else {
        sub_148_149();
    }
    return false;
}
bool sub_147_148() {
    reg_tmp6.xy = (vs_in_reg5.xyyy).xy;
    return false;
}
bool sub_148_149() {
    reg_tmp6.xy = (vs_in_reg6.xyyy).xy;
    return false;
}
bool sub_151_158() {
    reg_tmp2 = -reg_tmp15;
    reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
    reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_158_164() {
    reg_tmp1 = reg_tmp14;
    reg_tmp2.w = dot_3(reg_tmp1.xyz, reg_tmp1.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp1 = mul_s(reg_tmp1, reg_tmp2.wwww);
    reg_tmp1 = mul_s(uniforms.f[94].xxxx, reg_tmp1);
    reg_tmp6.xy = (uniforms.f[94].xxxx + reg_tmp1.xyyy).xy;
    return false;
}
bool sub_164_4096() {
    {
        sub_29_76();
    }
    if (uniforms.b[1]) {
        sub_166_173();
    } else {
        sub_173_174();
    }
    vs_out_attr3 = reg_tmp2;
    {
        sub_76_103();
    }
    {
        sub_103_127();
    }
    {
        sub_127_143();
    }
    return true;
}
bool sub_166_173() {
    reg_tmp0 = vec4(dot_3(uniforms.f[83].xyz, reg_tmp12.xyz));
    reg_tmp0 = max(uniforms.f[93].xxxx, reg_tmp0);
    reg_tmp0 = mul_s(uniforms.f[84], reg_tmp0);
    reg_tmp0 = uniforms.f[85] + reg_tmp0;
    reg_tmp0.w = (uniforms.f[93].yyyy).w;
    reg_tmp1 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
    reg_tmp2 = mul_s(reg_tmp0, reg_tmp1);
    return false;
}
bool sub_173_174() {
    reg_tmp2 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
    return false;
}
// reference: 9E522B37E3A8DA57, A214E3C9645157AE
// program: A214E3C9645157AE, B80FA1B7F97410CD, B766CBB102E471E4
// reference: 2589AD90A3E7455D, 466184E6A05DFF0F
// reference: 32BC79DFE09DC812, B0CCAE4F9AB69CDA
// shader: 8B31, 493A89E34FC6D4B5

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define fma_s(x, y, z) (mix(x * y, vec4(0.0), isnan(x * y)) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_8();
bool sub_9_32();
bool sub_143_145();
bool sub_146_166();
bool sub_167_259();
bool sub_190_192();
bool sub_194_195();
bool sub_197_198();
bool sub_200_202();
bool sub_232_234();
bool sub_236_237();
bool sub_239_240();
bool sub_242_244();
bool sub_260_4096();
bool sub_269_270();
bool sub_270_271();
bool sub_277_278();
bool sub_278_279();
bool sub_304_305();
bool sub_305_306();

bool exec_shader() {
    sub_260_4096();
    return true;
}

bool sub_0_8() {
    address_registers.x = (ivec2(vs_in_reg0.zz)).x;
    reg_tmp10 = uniforms.f[0].xxxz;
    reg_tmp10.xy = (vs_in_reg0.xyyy).xy;
    reg_tmp11 = uniforms.f[0].xxxx;
    reg_tmp12 = uniforms.f[0].xxxx;
    reg_tmp13 = uniforms.f[0].zzzz;
    reg_tmp4 = uniforms.f[0].xxxx;
    reg_tmp5 = uniforms.f[0].xxxx;
    return false;
}
bool sub_9_32() {
    vs_out_attr0 = reg_tmp10;
    reg_tmp13 = mul_s(uniforms.f[82], reg_tmp13);
    vs_out_attr1 = reg_tmp13;
    reg_tmp11.y = (uniforms.f[0].zzzz + -reg_tmp11.yyyy).y;
    reg_tmp12.y = (uniforms.f[0].zzzz + -reg_tmp12.yyyy).y;
    reg_tmp14.y = (uniforms.f[81].wwww).y;
    reg_tmp14.x = (mul_s(uniforms.f[0].wwww, reg_tmp14.yyyy)).x;
    reg_tmp2.x = rcp_s(reg_tmp14.x);
    reg_tmp14.z = (reg_tmp2.xxxx).z;
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp11.xyyy).xy;
    reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    reg_tmp11.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp12.xyyy).xy;
    reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    reg_tmp12.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    vs_out_attr2 = reg_tmp11;
    vs_out_attr3 = reg_tmp12;
    return false;
}
bool sub_143_145() {
    reg_tmp1.xyz = (uniforms.f[92].xyzz).xyz;
    reg_tmp1.w = (uniforms.f[0].xxxx).w;
    return false;
}
bool sub_146_166() {
    reg_tmp2 = uniforms.f[90];
    reg_tmp3 = uniforms.f[91];
    reg_tmp4 = uniforms.f[92];
    reg_tmp5 = uniforms.f[0].xxxz;
    reg_tmp6 = mul_s(uniforms.f[86].xxxx, reg_tmp2);
    reg_tmp6 = fma_s(reg_tmp3, uniforms.f[86].yyyy, reg_tmp6);
    reg_tmp6 = fma_s(reg_tmp4, uniforms.f[86].zzzz, reg_tmp6);
    reg_tmp6 = fma_s(reg_tmp5, uniforms.f[86].wwww, reg_tmp6);
    reg_tmp7 = mul_s(uniforms.f[87].xxxx, reg_tmp2);
    reg_tmp7 = fma_s(reg_tmp3, uniforms.f[87].yyyy, reg_tmp7);
    reg_tmp7 = fma_s(reg_tmp4, uniforms.f[87].zzzz, reg_tmp7);
    reg_tmp7 = fma_s(reg_tmp5, uniforms.f[87].wwww, reg_tmp7);
    reg_tmp8 = mul_s(uniforms.f[88].xxxx, reg_tmp2);
    reg_tmp8 = fma_s(reg_tmp3, uniforms.f[88].yyyy, reg_tmp8);
    reg_tmp8 = fma_s(reg_tmp4, uniforms.f[88].zzzz, reg_tmp8);
    reg_tmp8 = fma_s(reg_tmp5, uniforms.f[88].wwww, reg_tmp8);
    reg_tmp9 = mul_s(uniforms.f[89].xxxx, reg_tmp2);
    reg_tmp9 = fma_s(reg_tmp3, uniforms.f[89].yyyy, reg_tmp9);
    reg_tmp9 = fma_s(reg_tmp4, uniforms.f[89].zzzz, reg_tmp9);
    reg_tmp9 = fma_s(reg_tmp5, uniforms.f[89].wwww, reg_tmp9);
    return false;
}
bool sub_167_259() {
    reg_tmp2.x = rcp_s(uniforms.f[81].y);
    reg_tmp2.xy = (mul_s(uniforms.f[2 + address_registers.x].zwww, reg_tmp2.xxxx)).xy;
    reg_tmp2.xy = (uniforms.f[0].yyyy + reg_tmp2.xyyy).xy;
    reg_tmp3.xy = (floor(reg_tmp2.xyyy)).xy;
    reg_tmp2.xy = (mul_s(uniforms.f[81].yyyy, reg_tmp3.xyyy)).xy;
    reg_tmp2.xy = (uniforms.f[2 + address_registers.x].zwww + -reg_tmp2.xyyy).xy;
    reg_tmp0.xy = (min(uniforms.f[81].xxxx, -reg_tmp2.xyyy)).xy;
    reg_tmp0.xy = (max(-uniforms.f[81].xxxx, reg_tmp0.xyyy)).xy;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp0.xxxx, reg_tmp0.xxxx)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.xxxx)).y;
    reg_tmp5.x = (uniforms.f[5 + address_registers.x].wwww).x;
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_190_192();
    }
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_194_195();
    }
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_197_198();
    }
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_200_202();
    }
    reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    reg_tmp4.z = (uniforms.f[83].xxxx).z;
    reg_tmp4.w = (-uniforms.f[83].yyyy).w;
    reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[3 + address_registers.x].xyyy)).xy;
    reg_tmp4.z = (-uniforms.f[3 + address_registers.x].zzzz).z;
    reg_tmp4.w = (-uniforms.f[3 + address_registers.x].wwww).w;
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    reg_tmp11.xy = (reg_tmp5.xyyy).xy;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp0.yyyy, reg_tmp0.yyyy)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.yyyy)).y;
    reg_tmp5.x = (uniforms.f[6 + address_registers.x].wwww).x;
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_232_234();
    }
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_236_237();
    }
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_239_240();
    }
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_242_244();
    }
    reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    reg_tmp4.z = (uniforms.f[83].zzzz).z;
    reg_tmp4.w = (-uniforms.f[83].wwww).w;
    reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[4 + address_registers.x].xyyy)).xy;
    reg_tmp4.z = (-uniforms.f[4 + address_registers.x].zzzz).z;
    reg_tmp4.w = (-uniforms.f[4 + address_registers.x].wwww).w;
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    reg_tmp12.xy = (reg_tmp5.xyyy).xy;
    return false;
}
bool sub_190_192() {
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_194_195() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_197_198() {
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_200_202() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_232_234() {
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_236_237() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_239_240() {
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_242_244() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_260_4096() {
    {
        sub_0_8();
    }
    reg_tmp10.xy = (uniforms.f[84].xyyy + reg_tmp10.xyyy).xy;
    reg_tmp10.xy = (mul_s(uniforms.f[2 + address_registers.x].xyyy, reg_tmp10.xyyy)).xy;
    {
        sub_143_145();
    }
    reg_tmp2.xyz = (reg_tmp1.xyzz).xyz;
    reg_tmp3.xyz = (uniforms.f[6 + address_registers.x].xyzz).xyz;
    reg_tmp4.x = dot_3(reg_tmp3.xyz, reg_tmp3.xyz);
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
    if (conditional_code.x) {
        sub_269_270();
    } else {
        sub_270_271();
    }
    reg_tmp3.xyz = (mul_s(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
    reg_tmp4.xyz = (mul_s(reg_tmp3.yzxx, reg_tmp2.zxyy)).xyz;
    reg_tmp4.xyz = (fma_s(-reg_tmp2.yzxx, reg_tmp3.zxyy, reg_tmp4)).xyz;
    reg_tmp5.x = dot_3(reg_tmp4.xyz, reg_tmp4.xyz);
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp5.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp5.y;
    if (conditional_code.x) {
        sub_277_278();
    } else {
        sub_278_279();
    }
    reg_tmp4.xyz = (mul_s(reg_tmp4.xyzz, reg_tmp5.xxxx)).xyz;
    reg_tmp5.xyz = (mul_s(reg_tmp3.yzxx, reg_tmp4.zxyy)).xyz;
    reg_tmp5.xyz = (fma_s(-reg_tmp4.yzxx, reg_tmp3.zxyy, reg_tmp5)).xyz;
    reg_tmp6.x = (reg_tmp4.xxxx).x;
    reg_tmp6.y = (reg_tmp3.xxxx).y;
    reg_tmp6.z = (reg_tmp5.xxxx).z;
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    reg_tmp7.x = (reg_tmp4.yyyy).x;
    reg_tmp7.y = (reg_tmp3.yyyy).y;
    reg_tmp7.z = (reg_tmp5.yyyy).z;
    reg_tmp7.w = (uniforms.f[0].xxxx).w;
    reg_tmp8.x = (reg_tmp4.zzzz).x;
    reg_tmp8.y = (reg_tmp3.zzzz).y;
    reg_tmp8.z = (reg_tmp5.zzzz).z;
    reg_tmp8.w = (uniforms.f[0].xxxx).w;
    reg_tmp9 = uniforms.f[0].xxxz;
    reg_tmp2.x = dot_s(reg_tmp10, reg_tmp6);
    reg_tmp2.y = dot_s(reg_tmp10, reg_tmp7);
    reg_tmp2.z = dot_s(reg_tmp10, reg_tmp8);
    reg_tmp2.w = dot_s(reg_tmp10, reg_tmp9);
    reg_tmp3.xyz = (uniforms.f[5 + address_registers.x].xyzz).xyz;
    reg_tmp3.xyz = (-uniforms.f[85].xyzz + reg_tmp3.xyzz).xyz;
    reg_tmp4.x = dot_3(reg_tmp3.xyz, reg_tmp3.xyz);
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
    if (conditional_code.x) {
        sub_304_305();
    } else {
        sub_305_306();
    }
    reg_tmp3.xyz = (mul_s(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
    reg_tmp10.xyz = (uniforms.f[5 + address_registers.x].xyzz + reg_tmp2.xyzz).xyz;
    reg_tmp10.xyz = (fma_s(reg_tmp3.xyzz, -uniforms.f[84].zzzz, reg_tmp10.xyzz)).xyz;
    {
        sub_146_166();
    }
    reg_tmp2 = reg_tmp10;
    reg_tmp10.x = dot_s(reg_tmp2, reg_tmp6);
    reg_tmp10.y = dot_s(reg_tmp2, reg_tmp7);
    reg_tmp10.z = dot_s(reg_tmp2, reg_tmp8);
    reg_tmp10.w = dot_s(reg_tmp2, reg_tmp9);
    reg_tmp2 = uniforms.f[1 + address_registers.x];
    reg_tmp3 = max(uniforms.f[0].xxxx, reg_tmp2);
    reg_tmp2 = min(uniforms.f[0].zzzz, reg_tmp3);
    reg_tmp13 = reg_tmp2;
    {
        sub_167_259();
    }
    {
        sub_9_32();
    }
    return true;
}
bool sub_269_270() {
    reg_tmp4.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_270_271() {
    reg_tmp4.x = rsq_s(reg_tmp4.x);
    return false;
}
bool sub_277_278() {
    reg_tmp5.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_278_279() {
    reg_tmp5.x = rsq_s(reg_tmp5.x);
    return false;
}
bool sub_304_305() {
    reg_tmp4.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_305_306() {
    reg_tmp4.x = rsq_s(reg_tmp4.x);
    return false;
}
// reference: 15AC41869466B309, 493A89E34FC6D4B5
// program: 493A89E34FC6D4B5, 082670B4222015B2, DBA0F8FE46AD8D9B
// reference: E545D2498E052322, C6410D4382B19655
// reference: 519CD67DF5FDC7D1, 81B0676B862CF405
// reference: 1FC8293DADB100E4, 81B0676B862CF405
// reference: 58970D47434BC650, 46E991DEB658A5A9
// reference: 73EE4218C097A484, 2E530FFFDA886761
// reference: 3DBABD5898DB63B1, 2E530FFFDA886761
// reference: 3DBABD5877E2F0F0, 2E530FFFDA886761
// reference: 9E522B371A7FC069, A214E3C9645157AE
// reference: 2589AD905A305F63, 466184E6A05DFF0F
// reference: 32BC79DF194AD22C, B0CCAE4F9AB69CDA
// reference: 40A37A2A645C7AE3, 45C9694A57480945
// reference: 7189F773A8BF0B68, D03F0FE4B72A8E86
// reference: 3FDD08331FCA5F1C, D03F0FE4B72A8E86
// reference: D186A7B10F132775, 466184E6A05DFF0F
// reference: 88E78CBEFB1CFE4E, B0CCAE4F9AB69CDA
// program: 493A89E34FC6D4B5, 082670B4222015B2, 558A6C807844C0F3
// reference: 5BF8BEC6CC2A743C, 493A89E34FC6D4B5
// reference: 54C62F0AC28D55DA, 949D68475595512F
// reference: 73EE42186A715349, FD3DADE0E2BC47C9
// program: FD3DADE0E2BC47C9, B80FA1B7F97410CD, 5741FC947D667CFB
// reference: 3DBABD5899492EEC, FD3DADE0E2BC47C9
// program: FD3DADE0E2BC47C9, B80FA1B7F97410CD, 5FF3DF19FAD860D6
// reference: 95072FBCCC2A743C, 493A89E34FC6D4B5
// program: 493A89E34FC6D4B5, 082670B4222015B2, 1430EF96707A019C
// reference: 1A92D04A9AC192EF, 949D68475595512F
// reference: EDE38F43F0C46484, FD3DADE0E2BC47C9
// reference: EDE38F43B4894D55, FD3DADE0E2BC47C9
// reference: 9A2ECF1DC4B061F5, 2FBE2E4ED1D9324C
// program: 2FBE2E4ED1D9324C, 082670B4222015B2, 63A5270519B4AE20
// reference: F7394D2DCC2A743C, 493A89E34FC6D4B5
// reference: 9FD258F1B8667301, 466184E6A05DFF0F
// reference: C6B373FEB5BEB004, B0CCAE4F9AB69CDA
// program: 2E530FFFDA886761, B80FA1B7F97410CD, FFE5F81052CAA889
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 3013FC5CF83A846B
// program: 46E991DEB658A5A9, B80FA1B7F97410CD, FC9E10BE42F07103
// program: 81B0676B862CF405, 42937135801BAA7E, 9978311FA4F16C3C
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 01575BADBADD21EF
// program: 2E530FFFDA886761, B80FA1B7F97410CD, ABC97C54A7BF4D60
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 26BBC1E6E0D6F7FF
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 7337CC71AC06DD60
// program: 2E530FFFDA886761, B80FA1B7F97410CD, CF7B55EB749B1745
// program: 2E530FFFDA886761, B80FA1B7F97410CD, F2989B699B9A67E9
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 64E77DF66C1C7766
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 3D2F05F592BCAC45
// program: 81B0676B862CF405, 42937135801BAA7E, DBAEBC3C69195AAA
// program: 81B0676B862CF405, 42937135801BAA7E, 62CB16D7F16FAC9B
// program: 81B0676B862CF405, 42937135801BAA7E, 31DB35D8B8E9549F
// program: 81B0676B862CF405, 42937135801BAA7E, EB5CA625F01267FB
// shader: 8B31, 01B0CF4127F43ED8

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;
out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define mul_3(x, y) mix(x * y, vec3(0.0), isnan(x * y))
#define fma_s(x, y, z) (mul_s(x, y) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(mul_3(x, y), vec3(1.0))

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_19();
bool sub_19_55();
bool sub_55_65();
bool sub_65_79();
bool sub_79_129();
bool sub_84_102();
bool sub_102_110();
bool sub_127_128();
bool sub_129_185();
bool sub_134_152();
bool sub_152_163();
bool sub_183_184();
bool sub_185_212();
bool sub_187_192();
bool sub_192_211();
bool sub_195_201();
bool sub_201_210();
bool sub_202_206();
bool sub_206_209();
bool sub_212_236();
bool sub_214_218();
bool sub_218_235();
bool sub_219_233();
bool sub_222_229();
bool sub_229_232();
bool sub_233_234();
bool sub_236_252();
bool sub_238_242();
bool sub_242_251();
bool sub_243_249();
bool sub_249_250();
bool sub_252_260();
bool sub_254_255();
bool sub_255_259();
bool sub_256_257();
bool sub_257_258();
bool sub_260_267();
bool sub_267_273();
bool sub_273_4096();
bool sub_274_276();
bool sub_276_278();
bool sub_279_286();
bool sub_286_287();

bool exec_shader() {
    sub_273_4096();
    return true;
}

bool sub_0_19() {
    uint jmp_to = 0u;
    while (true) {
        switch (jmp_to) {
        case 0u: {
            reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
            reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
            reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
            reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
            reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
            reg_tmp6.x = rsq_s(reg_tmp6.x);
            reg_tmp7.x = rsq_s(reg_tmp7.x);
            reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            reg_tmp0 = uniforms.f[93].yxxx;
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            reg_tmp4 = mul_s(uniforms.f[94].xxxx, reg_tmp4);
            conditional_code = greaterThanEqual(uniforms.f[93].xx, reg_tmp4.xx);
            reg_tmp4 = vec4(rsq_s(reg_tmp4.x));
            reg_tmp5 = mul_s(uniforms.f[94].xxxx, reg_tmp14);
            if (conditional_code.x) {
                { jmp_to = 18u; break; }
            }
            reg_tmp0.z = rcp_s(reg_tmp4.x);
            reg_tmp0.xy = (mul_s(reg_tmp5, reg_tmp4)).xy;
        }
        case 18u: {
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_19_55() {
    uint jmp_to = 19u;
    while (true) {
        switch (jmp_to) {
        case 19u: {
            reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
            reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
            reg_tmp6.x = rsq_s(reg_tmp6.x);
            reg_tmp7.x = rsq_s(reg_tmp7.x);
            reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            reg_tmp13.xyz = (mul_s(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            reg_tmp11.xyz = (mul_s(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            reg_tmp0 = uniforms.f[93].yxxx;
            reg_tmp13.xyz = (mul_s(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            reg_tmp11.xyz = (mul_s(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            reg_tmp5 = mul_s(reg_tmp14.yzxx, reg_tmp13.zxyy);
            reg_tmp5 = fma_s(-reg_tmp13.yzxx, reg_tmp14.zxyy, reg_tmp5);
            reg_tmp5.w = dot_3(reg_tmp5.xyz, reg_tmp5.xyz);
            reg_tmp5.w = rsq_s(reg_tmp5.w);
            reg_tmp5 = mul_s(reg_tmp5, reg_tmp5.wwww);
            reg_tmp6.w = (reg_tmp14.zzzz + reg_tmp5.yyyy).w;
            reg_tmp13 = mul_s(reg_tmp5.yzxx, reg_tmp14.zxyy);
            reg_tmp13 = fma_s(-reg_tmp14.yzxx, reg_tmp5.zxyy, reg_tmp13);
            reg_tmp6.w = (reg_tmp13.xxxx + reg_tmp6).w;
            reg_tmp13.w = (reg_tmp5.zzzz).w;
            reg_tmp5.z = (reg_tmp13.xxxx).z;
            reg_tmp6.w = (uniforms.f[93].yyyy + reg_tmp6).w;
            reg_tmp14.w = (reg_tmp5.xxxx).w;
            reg_tmp5.x = (reg_tmp14.zzzz).x;
            conditional_code = lessThan(uniforms.f[94].zz, reg_tmp6.ww);
            reg_tmp6.x = (uniforms.f[93].yyyy).x;
            reg_tmp6.y = (-uniforms.f[93].yyyy).y;
            if (!conditional_code.x) {
                { jmp_to = 54u; break; }
            }
            reg_tmp7.xz = (reg_tmp13.wwyy + -reg_tmp14.yyww).xz;
            reg_tmp7.y = (reg_tmp14.xxxx + -reg_tmp13.zzzz).y;
            reg_tmp7.w = (reg_tmp6).w;
            reg_tmp6 = vec4(dot_s(reg_tmp7, reg_tmp7));
            reg_tmp6 = vec4(rsq_s(reg_tmp6.x));
            reg_tmp0 = mul_s(reg_tmp7, reg_tmp6);
        }
        case 54u: {
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_55_65() {
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    reg_tmp4.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_65_79() {
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    reg_tmp4.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp5.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp13.xyz);
    reg_tmp5.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp13.xyz);
    reg_tmp5.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp13.xyz);
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    reg_tmp11 = fma_s(reg_tmp1.wwww, reg_tmp5, reg_tmp11);
    return false;
}
bool sub_79_129() {
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    reg_tmp13.xyz = (vs_in_reg2).xyz;
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    if (uniforms.b[0]) {
        sub_84_102();
    } else {
        sub_102_110();
    }
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    {
        sub_0_19();
    }
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    vs_out_attr2 = -reg_tmp15;
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    if (all(conditional_code)) {
        sub_127_128();
    }
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_84_102() {
    reg_tmp7 = uniforms.f[93].xxxx;
    reg_tmp12 = uniforms.f[93].xxxx;
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    {
        sub_55_65();
    }
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    {
        sub_55_65();
    }
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    {
        sub_55_65();
    }
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    {
        sub_55_65();
    }
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    reg_tmp10 = reg_tmp7;
    return false;
}
bool sub_102_110() {
    reg_tmp7 = reg_tmp15;
    reg_tmp10.x = dot_s(uniforms.f[10], reg_tmp7);
    reg_tmp10.y = dot_s(uniforms.f[11], reg_tmp7);
    reg_tmp10.z = dot_s(uniforms.f[12], reg_tmp7);
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    reg_tmp12.x = dot_3(uniforms.f[10].xyz, reg_tmp14.xyz);
    reg_tmp12.y = dot_3(uniforms.f[11].xyz, reg_tmp14.xyz);
    reg_tmp12.z = dot_3(uniforms.f[12].xyz, reg_tmp14.xyz);
    return false;
}
bool sub_127_128() {
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_129_185() {
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    reg_tmp13.xyz = (vs_in_reg2).xyz;
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    if (uniforms.b[0]) {
        sub_134_152();
    } else {
        sub_152_163();
    }
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    reg_tmp13.x = dot_3(uniforms.f[90].xyz, reg_tmp11.xyz);
    reg_tmp13.y = dot_3(uniforms.f[91].xyz, reg_tmp11.xyz);
    reg_tmp13.z = dot_3(uniforms.f[92].xyz, reg_tmp11.xyz);
    {
        sub_19_55();
    }
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    vs_out_attr2 = -reg_tmp15;
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    if (all(conditional_code)) {
        sub_183_184();
    }
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_134_152() {
    reg_tmp7 = uniforms.f[93].xxxx;
    reg_tmp12 = uniforms.f[93].xxxx;
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    {
        sub_65_79();
    }
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    {
        sub_65_79();
    }
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    {
        sub_65_79();
    }
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    {
        sub_65_79();
    }
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    reg_tmp10 = reg_tmp7;
    return false;
}
bool sub_152_163() {
    reg_tmp7 = reg_tmp15;
    reg_tmp10.x = dot_s(uniforms.f[10], reg_tmp7);
    reg_tmp10.y = dot_s(uniforms.f[11], reg_tmp7);
    reg_tmp10.z = dot_s(uniforms.f[12], reg_tmp7);
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    reg_tmp12.x = dot_3(uniforms.f[10].xyz, reg_tmp14.xyz);
    reg_tmp12.y = dot_3(uniforms.f[11].xyz, reg_tmp14.xyz);
    reg_tmp12.z = dot_3(uniforms.f[12].xyz, reg_tmp14.xyz);
    reg_tmp11.x = dot_3(uniforms.f[10].xyz, reg_tmp13.xyz);
    reg_tmp11.y = dot_3(uniforms.f[11].xyz, reg_tmp13.xyz);
    reg_tmp11.z = dot_3(uniforms.f[12].xyz, reg_tmp13.xyz);
    return false;
}
bool sub_183_184() {
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_185_212() {
    reg_tmp0.xy = (uniforms.f[0].xxxx).xy;
    if (uniforms.b[2]) {
        sub_187_192();
    } else {
        sub_192_211();
    }
    return false;
}
bool sub_187_192() {
    {
        sub_252_260();
    }
    reg_tmp3.x = dot_s(uniforms.f[1].xywz, reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2].xywz, reg_tmp6);
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_192_211() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_195_201();
    } else {
        sub_201_210();
    }
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_195_201() {
    reg_tmp6 = reg_tmp10;
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    reg_tmp3.z = dot_s(uniforms.f[3], reg_tmp6);
    reg_tmp0.xy = (mul_s(uniforms.f[9].xyyy, reg_tmp3.zzzz)).xy;
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_201_210() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_202_206();
    } else {
        sub_206_209();
    }
    return false;
}
bool sub_202_206() {
    {
        sub_260_267();
    }
    reg_tmp3.x = dot_3(uniforms.f[1].xyz, reg_tmp6.xyz);
    reg_tmp3.y = dot_3(uniforms.f[2].xyz, reg_tmp6.xyz);
    reg_tmp3.z = dot_3(uniforms.f[3].xyz, reg_tmp6.xyz);
    return false;
}
bool sub_206_209() {
    {
        sub_267_273();
    }
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    return false;
}
bool sub_212_236() {
    reg_tmp0.xy = (uniforms.f[0].yyyy).xy;
    if (uniforms.b[3]) {
        sub_214_218();
    } else {
        sub_218_235();
    }
    return false;
}
bool sub_214_218() {
    {
        sub_252_260();
    }
    reg_tmp4.x = dot_s(uniforms.f[4].xywz, reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5].xywz, reg_tmp6);
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_218_235() {
    if (uniforms.b[5]) {
        sub_219_233();
    } else {
        sub_233_234();
    }
    return false;
}
bool sub_219_233() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_222_229();
    } else {
        sub_229_232();
    }
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_222_229() {
    reg_tmp6 = reg_tmp10;
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    reg_tmp4.z = dot_s(uniforms.f[6], reg_tmp6);
    reg_tmp6.w = rcp_s(reg_tmp4.z);
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    reg_tmp4.xy = (uniforms.f[9].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_229_232() {
    {
        sub_267_273();
    }
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    return false;
}
bool sub_233_234() {
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_236_252() {
    reg_tmp0.xy = (uniforms.f[0].zzzz).xy;
    if (uniforms.b[4]) {
        sub_238_242();
    } else {
        sub_242_251();
    }
    return false;
}
bool sub_238_242() {
    {
        sub_252_260();
    }
    reg_tmp5.x = dot_s(uniforms.f[7].xywz, reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8].xywz, reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_242_251() {
    if (uniforms.b[6]) {
        sub_243_249();
    } else {
        sub_249_250();
    }
    return false;
}
bool sub_243_249() {
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    {
        sub_267_273();
    }
    reg_tmp5.x = dot_s(uniforms.f[7], reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8], reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_249_250() {
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
bool sub_252_260() {
    conditional_code = equal(uniforms.f[93].yz, reg_tmp0.xy);
    if (all(not(conditional_code))) {
        sub_254_255();
    } else {
        sub_255_259();
    }
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_254_255() {
    reg_tmp6.xy = (vs_in_reg4.xyyy).xy;
    return false;
}
bool sub_255_259() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_256_257();
    } else {
        sub_257_258();
    }
    return false;
}
bool sub_256_257() {
    reg_tmp6.xy = (vs_in_reg5.xyyy).xy;
    return false;
}
bool sub_257_258() {
    reg_tmp6.xy = (vs_in_reg6.xyyy).xy;
    return false;
}
bool sub_260_267() {
    reg_tmp2 = -reg_tmp15;
    reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
    reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_267_273() {
    reg_tmp1 = reg_tmp14;
    reg_tmp2.w = dot_3(reg_tmp1.xyz, reg_tmp1.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp1 = mul_s(reg_tmp1, reg_tmp2.wwww);
    reg_tmp1 = mul_s(uniforms.f[94].xxxx, reg_tmp1);
    reg_tmp6.xy = (uniforms.f[94].xxxx + reg_tmp1.xyyy).xy;
    return false;
}
bool sub_273_4096() {
    if (uniforms.b[10]) {
        sub_274_276();
    } else {
        sub_276_278();
    }
    if (uniforms.b[1]) {
        sub_279_286();
    } else {
        sub_286_287();
    }
    vs_out_attr3 = reg_tmp2;
    {
        sub_185_212();
    }
    {
        sub_212_236();
    }
    {
        sub_236_252();
    }
    return true;
}
bool sub_274_276() {
    {
        sub_129_185();
    }
    return false;
}
bool sub_276_278() {
    {
        sub_79_129();
    }
    return false;
}
bool sub_279_286() {
    reg_tmp0 = vec4(dot_3(uniforms.f[83].xyz, reg_tmp12.xyz));
    reg_tmp0 = max(uniforms.f[93].xxxx, reg_tmp0);
    reg_tmp0 = mul_s(uniforms.f[84], reg_tmp0);
    reg_tmp0 = uniforms.f[85] + reg_tmp0;
    reg_tmp0.w = (uniforms.f[93].yyyy).w;
    reg_tmp1 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
    reg_tmp2 = mul_s(reg_tmp0, reg_tmp1);
    return false;
}
bool sub_286_287() {
    reg_tmp2 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
    return false;
}
// reference: 73EE42185DA0C544, 01B0CF4127F43ED8
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, 26CF8128A3DDBB83
// reference: 3DBABD5805EC0271, 01B0CF4127F43ED8
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, 953385FED82E0FD1
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, E52C4E220978C964
// reference: 3DBABD58EAD59130, 01B0CF4127F43ED8
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, 378438FF70532E82
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, 9F25A997909124C1
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, 01575BADBADD21EF
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, ABC97C54A7BF4D60
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, 26BBC1E6E0D6F7FF
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, 7337CC71AC06DD60
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, CF7B55EB749B1745
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, F2989B699B9A67E9
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, 64E77DF66C1C7766
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, 6A44D3E672630106
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, 3D2F05F592BCAC45
// shader: 8B31, CDD7AB422818C224

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define mul_3(x, y) mix(x * y, vec3(0.0), isnan(x * y))
#define fma_s(x, y, z) (mul_s(x, y) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(mul_3(x, y), vec3(1.0))

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_97();
bool sub_5_50();
bool sub_12_13();
bool sub_20_21();
bool sub_22_24();
bool sub_31_32();
bool sub_33_34();
bool sub_40_41();
bool sub_42_43();
bool sub_48_49();
bool sub_52_69();
bool sub_57_60();
bool sub_60_68();
bool sub_62_63();
bool sub_63_64();
bool sub_65_66();
bool sub_66_67();
bool sub_69_96();
bool sub_70_93();
bool sub_74_79();
bool sub_79_92();
bool sub_83_87();
bool sub_84_85();
bool sub_85_86();
bool sub_87_91();
bool sub_88_89();
bool sub_89_90();
bool sub_93_95();
bool sub_97_109();
bool sub_109_4096();
bool sub_125_127();
bool sub_127_149();
bool sub_137_141();
bool sub_158_160();
bool sub_161_162();
bool sub_171_173();
bool sub_174_175();
bool sub_184_186();
bool sub_187_188();
bool sub_198_207();
bool sub_215_223();
bool sub_223_227();

bool exec_shader() {
    sub_109_4096();
    return true;
}

bool sub_0_97() {
    reg_tmp13 = floor(reg_tmp0.xxxx);
    reg_tmp13 = reg_tmp0.xxxx + -reg_tmp13;
    address_registers.y = (ivec2(reg_tmp11.zz)).y;
    conditional_code = lessThanEqual(uniforms.f[5].ww, reg_tmp13.xx);
    if (conditional_code.x) {
        sub_5_50();
    }
    conditional_code = lessThanEqual(uniforms.f[5].yy, reg_tmp11.xy);
    if (!conditional_code.y) {
        sub_52_69();
    } else {
        sub_69_96();
    }
    return false;
}
bool sub_5_50() {
    reg_tmp12.xy = (uniforms.f[5].xyyy + vs_in_reg0.zwww).xy;
    reg_tmp14.xy = (uniforms.f[6].wzzz).xy;
    reg_tmp13.xy = (mul_s(uniforms.f[5].zzzz, reg_tmp0.xxxx)).xy;
    reg_tmp13.y = (floor(reg_tmp13)).y;
    reg_tmp13.x = (reg_tmp13.xxxx + -reg_tmp13.yyyy).x;
    conditional_code = lessThanEqual(uniforms.f[5].ww, reg_tmp13.xx);
    if (conditional_code.x) {
        sub_12_13();
    }
    reg_tmp14.xy = (mul_s(reg_tmp14, reg_tmp2)).xy;
    reg_tmp13.x = (mul_s(uniforms.f[5].zzzz, reg_tmp13.xxxx)).x;
    reg_tmp13 = mul_s(uniforms.f[5].zyzy, reg_tmp13.xxxx);
    reg_tmp13.zw = (floor(reg_tmp13)).zw;
    reg_tmp13.xy = (reg_tmp13.xyyy + -reg_tmp13.zwww).xy;
    conditional_code = lessThanEqual(uniforms.f[5].ww, reg_tmp13.xy);
    if (conditional_code.y) {
        sub_20_21();
    }
    if (conditional_code.x) {
        sub_22_24();
    }
    reg_tmp14.xy = (uniforms.f[5].yyyy + -reg_tmp14.xyyy).xy;
    reg_tmp13.x = (mul_s(uniforms.f[5].zzzz, reg_tmp13.xxxx)).x;
    reg_tmp13 = mul_s(uniforms.f[5].zyzy, reg_tmp13.xxxx);
    reg_tmp13.zw = (floor(reg_tmp13)).zw;
    reg_tmp13.xy = (reg_tmp13.xyyy + -reg_tmp13.zwww).xy;
    conditional_code = lessThanEqual(uniforms.f[5].ww, reg_tmp13.xy);
    if (conditional_code.y) {
        sub_31_32();
    }
    if (conditional_code.x) {
        sub_33_34();
    }
    reg_tmp13.x = (mul_s(uniforms.f[5].zzzz, reg_tmp13.xxxx)).x;
    reg_tmp13 = mul_s(uniforms.f[5].zyzy, reg_tmp13.xxxx);
    reg_tmp13.zw = (floor(reg_tmp13)).zw;
    reg_tmp13.xy = (reg_tmp13.xyyy + -reg_tmp13.zwww).xy;
    conditional_code = lessThanEqual(uniforms.f[5].ww, reg_tmp13.xy);
    if (conditional_code.y) {
        sub_40_41();
    }
    if (conditional_code.x) {
        sub_42_43();
    }
    reg_tmp13.xy = (mul_s(uniforms.f[5].zzzz, reg_tmp0.xxxx)).xy;
    reg_tmp13.y = (floor(reg_tmp13)).y;
    reg_tmp13.x = (reg_tmp13.xxxx + -reg_tmp13.yyyy).x;
    conditional_code = lessThanEqual(uniforms.f[5].ww, reg_tmp13.xx);
    if (conditional_code.x) {
        sub_48_49();
    }
    reg_tmp12.y = (uniforms.f[5].yyyy + -reg_tmp12.yyyy).y;
    return false;
}
bool sub_12_13() {
    reg_tmp14.xy = (reg_tmp14.yxxx).xy;
    return false;
}
bool sub_20_21() {
    reg_tmp12.x = (mul_s(reg_tmp12.xxxx, reg_tmp14.xxxx)).x;
    return false;
}
bool sub_22_24() {
    reg_tmp12.y = (fma_s(reg_tmp12.yyyy, reg_tmp14.yyyy, uniforms.f[5].yyyy)).y;
    reg_tmp12.y = (reg_tmp12.yyyy + -reg_tmp14.yyyy).y;
    return false;
}
bool sub_31_32() {
    reg_tmp12.x = (reg_tmp12.xxxx + reg_tmp14.xxxx).x;
    return false;
}
bool sub_33_34() {
    reg_tmp12.y = (reg_tmp12.yyyy + -reg_tmp14.yyyy).y;
    return false;
}
bool sub_40_41() {
    reg_tmp12.x = (uniforms.f[5].yyyy + -reg_tmp12.xxxx).x;
    return false;
}
bool sub_42_43() {
    reg_tmp12.y = (uniforms.f[5].yyyy + -reg_tmp12.yyyy).y;
    return false;
}
bool sub_48_49() {
    reg_tmp12.xy = (uniforms.f[5].yyyy + -reg_tmp12.yxxx).xy;
    return false;
}
bool sub_52_69() {
    reg_tmp13.x = (floor(reg_tmp0.xxxx)).x;
    reg_tmp13.x = (reg_tmp0.xxxx + -reg_tmp13).x;
    conditional_code = lessThanEqual(uniforms.f[5].ww, reg_tmp13.xx);
    reg_tmp13 = uniforms.f[32 + address_registers.y].wzyx;
    if (conditional_code.x) {
        sub_57_60();
    } else {
        sub_60_68();
    }
    reg_tmp11.z = (uniforms.f[5].yyyy + reg_tmp11.zzzz).z;
    return false;
}
bool sub_57_60() {
    reg_tmp11.xy = (fma_s(reg_tmp12.xyyy, reg_tmp13.xyyy, reg_tmp13.zwww)).xy;
    reg_tmp11.xy = (mul_s(reg_tmp11.xyyy, reg_tmp14.zwww)).xy;
    reg_tmp11.y = (uniforms.f[5].yyyy + -reg_tmp11.yyyy).y;
    return false;
}
bool sub_60_68() {
    conditional_code = notEqual(uniforms.f[5].xx, vs_in_reg0.zw);
    if (!conditional_code.x) {
        sub_62_63();
    } else {
        sub_63_64();
    }
    if (!conditional_code.y) {
        sub_65_66();
    } else {
        sub_66_67();
    }
    return false;
}
bool sub_62_63() {
    reg_tmp11.x = (reg_tmp13.xxxx).x;
    return false;
}
bool sub_63_64() {
    reg_tmp11.x = (reg_tmp13.zzzz).x;
    return false;
}
bool sub_65_66() {
    reg_tmp11.y = (reg_tmp13.yyyy).y;
    return false;
}
bool sub_66_67() {
    reg_tmp11.y = (reg_tmp13.wwww).y;
    return false;
}
bool sub_69_96() {
    if (!conditional_code.x) {
        sub_70_93();
    } else {
        sub_93_95();
    }
    reg_tmp11.z = (uniforms.f[5].zzzz + reg_tmp11.zzzz).z;
    return false;
}
bool sub_70_93() {
    reg_tmp13.x = (floor(reg_tmp0.xxxx)).x;
    reg_tmp13.x = (reg_tmp0.xxxx + -reg_tmp13).x;
    conditional_code = lessThanEqual(uniforms.f[5].ww, reg_tmp13.xx);
    if (conditional_code.x) {
        sub_74_79();
    } else {
        sub_79_92();
    }
    return false;
}
bool sub_74_79() {
    reg_tmp12.zw = (uniforms.f[5].xxxy).zw;
    reg_tmp11.x = dot_s(uniforms.f[32 + address_registers.y].wzyx, reg_tmp12);
    reg_tmp11.y = dot_s(uniforms.f[33 + address_registers.y].wzyx, reg_tmp12);
    reg_tmp11.xy = (mul_s(reg_tmp11.xyyy, reg_tmp14.zwww)).xy;
    reg_tmp11.y = (uniforms.f[5].yyyy + -reg_tmp11.yyyy).y;
    return false;
}
bool sub_79_92() {
    reg_tmp14 = uniforms.f[32 + address_registers.y].wzyx;
    reg_tmp13 = uniforms.f[33 + address_registers.y].wzyx;
    conditional_code = notEqual(uniforms.f[5].xx, vs_in_reg0.zw);
    if (!conditional_code.y) {
        sub_83_87();
    } else {
        sub_87_91();
    }
    return false;
}
bool sub_83_87() {
    if (!conditional_code.x) {
        sub_84_85();
    } else {
        sub_85_86();
    }
    return false;
}
bool sub_84_85() {
    reg_tmp11.xy = (reg_tmp14.xyyy).xy;
    return false;
}
bool sub_85_86() {
    reg_tmp11.xy = (reg_tmp13.zwww).xy;
    return false;
}
bool sub_87_91() {
    if (!conditional_code.x) {
        sub_88_89();
    } else {
        sub_89_90();
    }
    return false;
}
bool sub_88_89() {
    reg_tmp11.xy = (reg_tmp13.xyyy).xy;
    return false;
}
bool sub_89_90() {
    reg_tmp11.xy = (reg_tmp14.zwww).xy;
    return false;
}
bool sub_93_95() {
    reg_tmp11.x = dot_s(uniforms.f[32 + address_registers.y].wzyx, reg_tmp1);
    reg_tmp11.y = dot_s(uniforms.f[33 + address_registers.y].wzyx, reg_tmp1);
    return false;
}
bool sub_97_109() {
    uint jmp_to = 97u;
    while (true) {
        switch (jmp_to) {
        case 97u: {
            reg_tmp3.x = dot_s(uniforms.f[32 + address_registers.x].wzyx, reg_tmp1);
            reg_tmp3.y = dot_s(uniforms.f[33 + address_registers.x].wzyx, reg_tmp1);
            reg_tmp3.z = dot_s(uniforms.f[34 + address_registers.x].wzyx, reg_tmp1);
            reg_tmp3.w = (reg_tmp1.wwww).w;
            reg_tmp11 = uniforms.f[4].wzyx;
            reg_tmp11.z = (-uniforms.f[34 + address_registers.x].xxxx + reg_tmp11.zzzz).z;
            conditional_code.x = uniforms.f[5].xxxx.x != reg_tmp11.xzzz.x;
            conditional_code.y = uniforms.f[5].xxxx.y < reg_tmp11.xzzz.y;
            if (any(not(conditional_code))) {
                { jmp_to = 108u; break; }
            }
            reg_tmp11.z = rcp_s(reg_tmp11.z);
            reg_tmp3.x = (reg_tmp3.xxxx + reg_tmp11.xxxx).x;
            reg_tmp3.x = (fma_s(-reg_tmp11.yyyy, reg_tmp11.zzzz, reg_tmp3.xxxx)).x;
        }
        case 108u: {
        }
        default: return false;
        }
    }
    return false;
}
bool sub_109_4096() {
    uint jmp_to = 109u;
    while (true) {
        switch (jmp_to) {
        case 109u: {
            address_registers.x = (ivec2(vs_in_reg0.xx)).x;
            reg_tmp0 = uniforms.f[9 + address_registers.x].wzyx;
            reg_tmp1.xy = (vs_in_reg0.zwzw).xy;
            reg_tmp1.zw = (uniforms.f[5].xyxy).zw;
            address_registers.xy = ivec2(reg_tmp0.xy);
            reg_tmp2 = uniforms.f[32 + address_registers.y].wzyx;
            if (uniforms.b[0]) {
                { jmp_to = 191u; break; }
            }
            reg_tmp4 = uniforms.f[31 + address_registers.x].wzyx;
            reg_tmp1.xy = (fma_s(reg_tmp1.xyyy, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
            {
                sub_97_109();
            }
            vs_out_attr0.x = dot_s(uniforms.f[0].wzyx, reg_tmp3);
            vs_out_attr0.y = dot_s(uniforms.f[1].wzyx, reg_tmp3);
            vs_out_attr0.z = dot_s(uniforms.f[2].wzyx, reg_tmp3);
            vs_out_attr0.w = dot_s(uniforms.f[3].wzyx, reg_tmp3);
            conditional_code = greaterThanEqual(uniforms.f[5].yy, reg_tmp0.ww);
            if (all(conditional_code)) {
                sub_125_127();
            } else {
                sub_127_149();
            }
            reg_tmp11.z = (reg_tmp0.zzzz).z;
            reg_tmp9 = mul_s(uniforms.f[5].zyzy, reg_tmp0.zzzz);
            reg_tmp9.xy = (floor(reg_tmp9)).xy;
            reg_tmp9.xy = (reg_tmp9.zwww + -reg_tmp9.xyyy).xy;
            reg_tmp9 = mul_s(uniforms.f[5].zzzz, reg_tmp9);
            reg_tmp14 = uniforms.f[6].wzyx;
            reg_tmp11.xy = (reg_tmp9.xyyy).xy;
            {
                sub_0_97();
            }
            if (uniforms.b[1]) {
                sub_158_160();
            }
            if (uniforms.b[2]) {
                sub_161_162();
            }
            vs_out_attr2 = reg_tmp11.xyyy;
            reg_tmp9 = mul_s(uniforms.f[5].zyzy, reg_tmp9.xxxx);
            reg_tmp9.xy = (floor(reg_tmp9)).xy;
            reg_tmp9.xy = (reg_tmp9.zwww + -reg_tmp9.xyyy).xy;
            reg_tmp9 = mul_s(uniforms.f[5].zzzz, reg_tmp9);
            reg_tmp14 = uniforms.f[7].wzyx;
            reg_tmp11.xy = (reg_tmp9.xyyy).xy;
            {
                sub_0_97();
            }
            if (uniforms.b[3]) {
                sub_171_173();
            }
            if (uniforms.b[4]) {
                sub_174_175();
            }
            vs_out_attr3 = reg_tmp11.xyyy;
            reg_tmp9 = mul_s(uniforms.f[5].zyzy, reg_tmp9.xxxx);
            reg_tmp9.xy = (floor(reg_tmp9)).xy;
            reg_tmp9.xy = (reg_tmp9.zwww + -reg_tmp9.xyyy).xy;
            reg_tmp9 = mul_s(uniforms.f[5].zzzz, reg_tmp9);
            reg_tmp14 = uniforms.f[8].wzyx;
            reg_tmp11.xy = (reg_tmp9.xyyy).xy;
            {
                sub_0_97();
            }
            if (uniforms.b[5]) {
                sub_184_186();
            }
            if (uniforms.b[6]) {
                sub_187_188();
            }
            vs_out_attr4 = reg_tmp11.xyyy;
            return true;
        }
        case 191u: {
            reg_tmp2.w = (reg_tmp2.wwww + reg_tmp2.yyyy).w;
            reg_tmp1.y = (-uniforms.f[5].yyyy + -reg_tmp1.yyyy).y;
            reg_tmp13.xy = (mul_s(uniforms.f[36 + address_registers.x].wzzz, reg_tmp2.xyyy)).xy;
            reg_tmp11.x = (mul_s(uniforms.f[35 + address_registers.x].wwww, -reg_tmp1.yyyy)).x;
            reg_tmp1.xy = (mul_s(reg_tmp1.xyyy, reg_tmp13.xyyy)).xy;
            reg_tmp1.x = (reg_tmp1.xxxx + reg_tmp11.xxxx).x;
            if (uniforms.b[1]) {
                sub_198_207();
            }
            reg_tmp1.xy = (reg_tmp1.xyyy + reg_tmp2.zwww).xy;
            reg_tmp1.xy = (uniforms.f[36 + address_registers.x].yxxx + reg_tmp1.xyyy).xy;
            {
                sub_97_109();
            }
            vs_out_attr0.x = dot_s(uniforms.f[0].wzyx, reg_tmp3);
            vs_out_attr0.y = dot_s(uniforms.f[1].wzyx, reg_tmp3);
            vs_out_attr0.z = dot_s(uniforms.f[2].wzyx, reg_tmp3);
            vs_out_attr0.w = dot_s(uniforms.f[3].wzyx, reg_tmp3);
            if (uniforms.b[2]) {
                sub_215_223();
            } else {
                sub_223_227();
            }
            reg_tmp8 = reg_tmp8 + -reg_tmp7;
            vs_out_attr1 = fma_s(reg_tmp8, reg_tmp11.yyyy, reg_tmp7);
            reg_tmp9.xy = (mul_s(uniforms.f[32 + address_registers.x].yxxx, reg_tmp11)).xy;
            reg_tmp11.zw = (vec4(lessThan(reg_tmp11, uniforms.f[5].yyyy))).zw;
            reg_tmp9.xy = (fma_s(reg_tmp11.zwww, uniforms.f[32 + address_registers.x].wzzz, reg_tmp9.xyyy)).xy;
            reg_tmp9.y = (uniforms.f[5].yyyy + -reg_tmp9.yyyy).y;
            vs_out_attr2 = reg_tmp9;
            vs_out_attr3 = reg_tmp9;
            vs_out_attr4 = reg_tmp9;
            return true;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_125_127() {
    vs_out_attr1.xyz = (uniforms.f[5].yyyy).xyz;
    vs_out_attr1.w = (reg_tmp0.wwww).w;
    return false;
}
bool sub_127_149() {
    address_registers.y = (ivec2(reg_tmp0.ww)).y;
    reg_tmp7 = uniforms.f[32 + address_registers.y].wzyx;
    reg_tmp8 = uniforms.f[33 + address_registers.y].wzyx;
    reg_tmp9 = uniforms.f[34 + address_registers.y].wzyx;
    reg_tmp10 = uniforms.f[35 + address_registers.y].wzyx;
    reg_tmp11.xy = (vs_in_reg0.zwww).xy;
    reg_tmp14.x = (floor(reg_tmp0.yyyy)).x;
    reg_tmp14.x = (reg_tmp0.yyyy + -reg_tmp14.xxxx).x;
    conditional_code = lessThanEqual(uniforms.f[5].ww, reg_tmp14.xx);
    if (conditional_code.x) {
        sub_137_141();
    }
    reg_tmp11.xy = (abs(reg_tmp11.xyyy)).xy;
    reg_tmp8 = reg_tmp8 + -reg_tmp7;
    reg_tmp8 = fma_s(reg_tmp8, reg_tmp11.xxxx, reg_tmp7);
    reg_tmp10 = reg_tmp10 + -reg_tmp9;
    reg_tmp10 = fma_s(reg_tmp10, reg_tmp11.xxxx, reg_tmp9);
    reg_tmp10 = reg_tmp10 + -reg_tmp8;
    reg_tmp10 = fma_s(reg_tmp10, reg_tmp11.yyyy, reg_tmp8);
    vs_out_attr1 = reg_tmp10;
    return false;
}
bool sub_137_141() {
    reg_tmp11.z = rcp_s(reg_tmp4.x);
    reg_tmp11.w = rcp_s(reg_tmp4.y);
    reg_tmp11.xy = (reg_tmp1.xyyy + -reg_tmp4.zwww).xy;
    reg_tmp11.xy = (mul_s(reg_tmp11.xyyy, reg_tmp11.zwww)).xy;
    return false;
}
bool sub_158_160() {
    reg_tmp11.xy = (reg_tmp11.yxxx).xy;
    reg_tmp11.y = (uniforms.f[5].yyyy + -reg_tmp11.yyyy).y;
    return false;
}
bool sub_161_162() {
    reg_tmp11.xy = (uniforms.f[5].yyyy + -reg_tmp11.yxxx).xy;
    return false;
}
bool sub_171_173() {
    reg_tmp11.xy = (reg_tmp11.yxxx).xy;
    reg_tmp11.y = (uniforms.f[5].yyyy + -reg_tmp11.yyyy).y;
    return false;
}
bool sub_174_175() {
    reg_tmp11.xy = (uniforms.f[5].yyyy + -reg_tmp11.yxxx).xy;
    return false;
}
bool sub_184_186() {
    reg_tmp11.xy = (reg_tmp11.yxxx).xy;
    reg_tmp11.y = (uniforms.f[5].yyyy + -reg_tmp11.yyyy).y;
    return false;
}
bool sub_187_188() {
    reg_tmp11.xy = (uniforms.f[5].yyyy + -reg_tmp11.yxxx).xy;
    return false;
}
bool sub_198_207() {
    reg_tmp13.xzw = (mul_s(uniforms.f[5].wxxx, reg_tmp13.xxxx)).xzw;
    reg_tmp13.y = (mul_s(uniforms.f[34 + address_registers.y].yyyy, reg_tmp13.yyyy)).y;
    reg_tmp11 = fma_s(reg_tmp1, uniforms.f[5].yyxx, -reg_tmp13);
    reg_tmp14 = uniforms.f[33 + address_registers.y].wzyx;
    reg_tmp1.x = dot_3(reg_tmp11.xyz, reg_tmp14.xyy);
    reg_tmp1.y = dot_3(reg_tmp11.xyz, reg_tmp14.zww);
    reg_tmp14 = uniforms.f[34 + address_registers.y].wzyx;
    reg_tmp1.z = dot_s(vec4(reg_tmp11.xyz, 1.0), reg_tmp14);
    reg_tmp1.xy = (reg_tmp1.xyyy + reg_tmp13.xyyy).xy;
    return false;
}
bool sub_215_223() {
    reg_tmp11 = abs(vs_in_reg0.zwzw);
    reg_tmp14.w = (floor(reg_tmp0.zzzz)).w;
    reg_tmp14.w = (reg_tmp0.zzzz + -reg_tmp14).w;
    address_registers.xy = ivec2(reg_tmp0.zx);
    reg_tmp14.w = (mul_s(uniforms.f[5].zzzz, reg_tmp14.wwww)).w;
    reg_tmp14.xyz = (uniforms.f[5].yyyy).xyz;
    reg_tmp7 = mul_s(uniforms.f[37 + address_registers.y].wzyx, reg_tmp14);
    reg_tmp8 = mul_s(uniforms.f[38 + address_registers.y].wzyx, reg_tmp14);
    return false;
}
bool sub_223_227() {
    reg_tmp11 = abs(vs_in_reg0.zwzw);
    address_registers.xy = ivec2(reg_tmp0.zw);
    reg_tmp7 = uniforms.f[32 + address_registers.y].wzyx;
    reg_tmp8 = uniforms.f[33 + address_registers.y].wzyx;
    return false;
}
// reference: 519CD67D8D5A77F7, CDD7AB422818C224
// program: CDD7AB422818C224, 42937135801BAA7E, 62CB16D7F16FAC9B
// reference: 1FC8293DD516B0C2, CDD7AB422818C224
// program: CDD7AB422818C224, 42937135801BAA7E, DBAEBC3C69195AAA
// program: CDD7AB422818C224, 42937135801BAA7E, 31DB35D8B8E9549F
// program: CDD7AB422818C224, 42937135801BAA7E, EB5CA625F01267FB
// shader: 8B31, C1B15B379433D4E8

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;
out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define mul_3(x, y) mix(x * y, vec3(0.0), isnan(x * y))
#define fma_s(x, y, z) (mul_s(x, y) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(mul_3(x, y), vec3(1.0))

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_76_103();
bool sub_78_83();
bool sub_83_102();
bool sub_86_92();
bool sub_92_101();
bool sub_93_97();
bool sub_97_100();
bool sub_103_127();
bool sub_105_109();
bool sub_109_126();
bool sub_110_124();
bool sub_113_120();
bool sub_120_123();
bool sub_124_125();
bool sub_127_143();
bool sub_129_133();
bool sub_133_142();
bool sub_134_140();
bool sub_140_141();
bool sub_143_151();
bool sub_145_146();
bool sub_146_150();
bool sub_147_148();
bool sub_148_149();
bool sub_151_158();
bool sub_158_166();
bool sub_166_4096();

bool exec_shader() {
    sub_166_4096();
    return true;
}

bool sub_76_103() {
    reg_tmp0.xy = (uniforms.f[0].xxxx).xy;
    if (uniforms.b[2]) {
        sub_78_83();
    } else {
        sub_83_102();
    }
    return false;
}
bool sub_78_83() {
    {
        sub_143_151();
    }
    reg_tmp3.x = dot_s(uniforms.f[1].xywz, reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2].xywz, reg_tmp6);
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_83_102() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_86_92();
    } else {
        sub_92_101();
    }
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_86_92() {
    reg_tmp6 = reg_tmp10;
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    reg_tmp3.z = dot_s(uniforms.f[3], reg_tmp6);
    reg_tmp0.xy = (mul_s(uniforms.f[9].xyyy, reg_tmp3.zzzz)).xy;
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_92_101() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_93_97();
    } else {
        sub_97_100();
    }
    return false;
}
bool sub_93_97() {
    {
        sub_151_158();
    }
    reg_tmp3.x = dot_3(uniforms.f[1].xyz, reg_tmp6.xyz);
    reg_tmp3.y = dot_3(uniforms.f[2].xyz, reg_tmp6.xyz);
    reg_tmp3.z = dot_3(uniforms.f[3].xyz, reg_tmp6.xyz);
    return false;
}
bool sub_97_100() {
    {
        sub_158_166();
    }
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    return false;
}
bool sub_103_127() {
    reg_tmp0.xy = (uniforms.f[0].yyyy).xy;
    if (uniforms.b[3]) {
        sub_105_109();
    } else {
        sub_109_126();
    }
    return false;
}
bool sub_105_109() {
    {
        sub_143_151();
    }
    reg_tmp4.x = dot_s(uniforms.f[4].xywz, reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5].xywz, reg_tmp6);
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_109_126() {
    if (uniforms.b[5]) {
        sub_110_124();
    } else {
        sub_124_125();
    }
    return false;
}
bool sub_110_124() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_113_120();
    } else {
        sub_120_123();
    }
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_113_120() {
    reg_tmp6 = reg_tmp10;
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    reg_tmp4.z = dot_s(uniforms.f[6], reg_tmp6);
    reg_tmp6.w = rcp_s(reg_tmp4.z);
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    reg_tmp4.xy = (uniforms.f[9].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_120_123() {
    {
        sub_158_166();
    }
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    return false;
}
bool sub_124_125() {
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_127_143() {
    reg_tmp0.xy = (uniforms.f[0].zzzz).xy;
    if (uniforms.b[4]) {
        sub_129_133();
    } else {
        sub_133_142();
    }
    return false;
}
bool sub_129_133() {
    {
        sub_143_151();
    }
    reg_tmp5.x = dot_s(uniforms.f[7].xywz, reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8].xywz, reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_133_142() {
    if (uniforms.b[6]) {
        sub_134_140();
    } else {
        sub_140_141();
    }
    return false;
}
bool sub_134_140() {
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    {
        sub_158_166();
    }
    reg_tmp5.x = dot_s(uniforms.f[7], reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8], reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_140_141() {
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
bool sub_143_151() {
    conditional_code = equal(uniforms.f[93].yz, reg_tmp0.xy);
    if (all(not(conditional_code))) {
        sub_145_146();
    } else {
        sub_146_150();
    }
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_145_146() {
    reg_tmp6.xy = (vs_in_reg4.xyyy).xy;
    return false;
}
bool sub_146_150() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_147_148();
    } else {
        sub_148_149();
    }
    return false;
}
bool sub_147_148() {
    reg_tmp6.xy = (vs_in_reg5.xyyy).xy;
    return false;
}
bool sub_148_149() {
    reg_tmp6.xy = (vs_in_reg6.xyyy).xy;
    return false;
}
bool sub_151_158() {
    reg_tmp2 = -reg_tmp15;
    reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
    reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_158_166() {
    {
        sub_151_158();
    }
    reg_tmp1 = reg_tmp6;
    reg_tmp1.z = (uniforms.f[93].yyyy + reg_tmp1.zzzz).z;
    reg_tmp1 = vec4(dot_3(reg_tmp1.xyz, reg_tmp1.xyz));
    reg_tmp2 = vec4(rsq_s(reg_tmp1.x));
    reg_tmp2 = mul_s(uniforms.f[94].xxxx, reg_tmp2);
    reg_tmp6.xy = (mul_s(reg_tmp6.xyyy, reg_tmp2)).xy;
    reg_tmp6.xy = (uniforms.f[94].xxxx + reg_tmp6.xyyy).xy;
    return false;
}
bool sub_166_4096() {
    reg_tmp0 = vs_in_reg0;
    reg_tmp0.z = (uniforms.f[93].xxxx).z;
    reg_tmp0.w = (uniforms.f[93].yyyy).w;
    vs_out_attr0 = reg_tmp0;
    vs_out_attr2 = reg_tmp0;
    vs_out_attr1 = reg_tmp0;
    vs_out_attr3 = uniforms.f[93].yyyy;
    {
        sub_76_103();
    }
    {
        sub_103_127();
    }
    {
        sub_127_143();
    }
    return true;
}
// reference: 050CCFD44C8743BE, C1B15B379433D4E8
// program: C1B15B379433D4E8, B80FA1B7F97410CD, FC9E10BE42F07103
// program: CDD7AB422818C224, 42937135801BAA7E, 21786A34D707A069
// program: CDD7AB422818C224, 42937135801BAA7E, 5124AD903EB19D9F
// program: CDD7AB422818C224, 42937135801BAA7E, 886AC14BAA341C33
// program: CDD7AB422818C224, 42937135801BAA7E, 7C14C907B3CCD849
// program: CDD7AB422818C224, 42937135801BAA7E, F2C7CEFD4FAFF562
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, F35E8CA2CAC182F7
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, 168DA83A29634DCC
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, 576E786439C2EA2F
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, FFE5F81052CAA889
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, 1471721266F6CFF3
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, 90EA57FA2E348842
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, 1212B53523129C17
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, C9A23B908E5F8ABB
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, 7E2D94A79BE7422B
// shader: 8B31, 0350F8532B3DBD74

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;
out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define mul_3(x, y) mix(x * y, vec3(0.0), isnan(x * y))
#define fma_s(x, y, z) (mul_s(x, y) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(mul_3(x, y), vec3(1.0))

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_19();
bool sub_19_29();
bool sub_29_90();
bool sub_33_51();
bool sub_51_59();
bool sub_88_89();
bool sub_90_117();
bool sub_92_97();
bool sub_97_116();
bool sub_100_106();
bool sub_106_115();
bool sub_107_111();
bool sub_111_114();
bool sub_117_141();
bool sub_119_123();
bool sub_123_140();
bool sub_124_138();
bool sub_127_134();
bool sub_134_137();
bool sub_138_139();
bool sub_141_157();
bool sub_143_147();
bool sub_147_156();
bool sub_148_154();
bool sub_154_155();
bool sub_157_165();
bool sub_159_160();
bool sub_160_164();
bool sub_161_162();
bool sub_162_163();
bool sub_165_172();
bool sub_172_178();
bool sub_178_4096();
bool sub_180_187();
bool sub_187_188();

bool exec_shader() {
    sub_178_4096();
    return true;
}

bool sub_0_19() {
    uint jmp_to = 0u;
    while (true) {
        switch (jmp_to) {
        case 0u: {
            reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
            reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
            reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
            reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
            reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
            reg_tmp6.x = rsq_s(reg_tmp6.x);
            reg_tmp7.x = rsq_s(reg_tmp7.x);
            reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            reg_tmp0 = uniforms.f[93].yxxx;
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            reg_tmp4 = mul_s(uniforms.f[94].xxxx, reg_tmp4);
            conditional_code = greaterThanEqual(uniforms.f[93].xx, reg_tmp4.xx);
            reg_tmp4 = vec4(rsq_s(reg_tmp4.x));
            reg_tmp5 = mul_s(uniforms.f[94].xxxx, reg_tmp14);
            if (conditional_code.x) {
                { jmp_to = 18u; break; }
            }
            reg_tmp0.z = rcp_s(reg_tmp4.x);
            reg_tmp0.xy = (mul_s(reg_tmp5, reg_tmp4)).xy;
        }
        case 18u: {
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_19_29() {
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    reg_tmp4.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_29_90() {
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    if (uniforms.b[0]) {
        sub_33_51();
    } else {
        sub_51_59();
    }
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    {
        sub_0_19();
    }
    vs_out_attr2 = -reg_tmp15;
    reg_tmp0.x = (uniforms.f[93].yyyy).x;
    address_registers.x = (ivec2(vs_in_reg3.xx)).x;
    reg_tmp0.x = (mul_s(uniforms.f[13 + address_registers.x].xxxx, reg_tmp0.xxxx)).x;
    address_registers.x = (ivec2(vs_in_reg3.yy)).x;
    reg_tmp0.x = (mul_s(uniforms.f[13 + address_registers.x].yyyy, reg_tmp0.xxxx)).x;
    address_registers.x = (ivec2(vs_in_reg3.zz)).x;
    reg_tmp0.x = (mul_s(uniforms.f[13 + address_registers.x].zzzz, reg_tmp0.xxxx)).x;
    address_registers.x = (ivec2(vs_in_reg3.ww)).x;
    reg_tmp0.x = (mul_s(uniforms.f[13 + address_registers.x].wwww, reg_tmp0.xxxx)).x;
    reg_tmp15.xyz = (mul_s(reg_tmp15.xyzz, reg_tmp0.xxxx)).xyz;
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    if (all(conditional_code)) {
        sub_88_89();
    }
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_33_51() {
    reg_tmp7 = uniforms.f[93].xxxx;
    reg_tmp12 = uniforms.f[93].xxxx;
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    {
        sub_19_29();
    }
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    {
        sub_19_29();
    }
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    {
        sub_19_29();
    }
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    {
        sub_19_29();
    }
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    reg_tmp10 = reg_tmp7;
    return false;
}
bool sub_51_59() {
    reg_tmp7 = reg_tmp15;
    reg_tmp10.x = dot_s(uniforms.f[10], reg_tmp7);
    reg_tmp10.y = dot_s(uniforms.f[11], reg_tmp7);
    reg_tmp10.z = dot_s(uniforms.f[12], reg_tmp7);
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    reg_tmp12.x = dot_3(uniforms.f[10].xyz, reg_tmp14.xyz);
    reg_tmp12.y = dot_3(uniforms.f[11].xyz, reg_tmp14.xyz);
    reg_tmp12.z = dot_3(uniforms.f[12].xyz, reg_tmp14.xyz);
    return false;
}
bool sub_88_89() {
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_90_117() {
    reg_tmp0.xy = (uniforms.f[0].xxxx).xy;
    if (uniforms.b[2]) {
        sub_92_97();
    } else {
        sub_97_116();
    }
    return false;
}
bool sub_92_97() {
    {
        sub_157_165();
    }
    reg_tmp3.x = dot_s(uniforms.f[1].xywz, reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2].xywz, reg_tmp6);
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_97_116() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_100_106();
    } else {
        sub_106_115();
    }
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_100_106() {
    reg_tmp6 = reg_tmp10;
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    reg_tmp3.z = dot_s(uniforms.f[3], reg_tmp6);
    reg_tmp0.xy = (mul_s(uniforms.f[9].xyyy, reg_tmp3.zzzz)).xy;
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_106_115() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_107_111();
    } else {
        sub_111_114();
    }
    return false;
}
bool sub_107_111() {
    {
        sub_165_172();
    }
    reg_tmp3.x = dot_3(uniforms.f[1].xyz, reg_tmp6.xyz);
    reg_tmp3.y = dot_3(uniforms.f[2].xyz, reg_tmp6.xyz);
    reg_tmp3.z = dot_3(uniforms.f[3].xyz, reg_tmp6.xyz);
    return false;
}
bool sub_111_114() {
    {
        sub_172_178();
    }
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    return false;
}
bool sub_117_141() {
    reg_tmp0.xy = (uniforms.f[0].yyyy).xy;
    if (uniforms.b[3]) {
        sub_119_123();
    } else {
        sub_123_140();
    }
    return false;
}
bool sub_119_123() {
    {
        sub_157_165();
    }
    reg_tmp4.x = dot_s(uniforms.f[4].xywz, reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5].xywz, reg_tmp6);
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_123_140() {
    if (uniforms.b[5]) {
        sub_124_138();
    } else {
        sub_138_139();
    }
    return false;
}
bool sub_124_138() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_127_134();
    } else {
        sub_134_137();
    }
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_127_134() {
    reg_tmp6 = reg_tmp10;
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    reg_tmp4.z = dot_s(uniforms.f[6], reg_tmp6);
    reg_tmp6.w = rcp_s(reg_tmp4.z);
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    reg_tmp4.xy = (uniforms.f[9].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_134_137() {
    {
        sub_172_178();
    }
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    return false;
}
bool sub_138_139() {
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_141_157() {
    reg_tmp0.xy = (uniforms.f[0].zzzz).xy;
    if (uniforms.b[4]) {
        sub_143_147();
    } else {
        sub_147_156();
    }
    return false;
}
bool sub_143_147() {
    {
        sub_157_165();
    }
    reg_tmp5.x = dot_s(uniforms.f[7].xywz, reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8].xywz, reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_147_156() {
    if (uniforms.b[6]) {
        sub_148_154();
    } else {
        sub_154_155();
    }
    return false;
}
bool sub_148_154() {
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    {
        sub_172_178();
    }
    reg_tmp5.x = dot_s(uniforms.f[7], reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8], reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_154_155() {
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
bool sub_157_165() {
    conditional_code = equal(uniforms.f[93].yz, reg_tmp0.xy);
    if (all(not(conditional_code))) {
        sub_159_160();
    } else {
        sub_160_164();
    }
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_159_160() {
    reg_tmp6.xy = (vs_in_reg4.xyyy).xy;
    return false;
}
bool sub_160_164() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_161_162();
    } else {
        sub_162_163();
    }
    return false;
}
bool sub_161_162() {
    reg_tmp6.xy = (vs_in_reg5.xyyy).xy;
    return false;
}
bool sub_162_163() {
    reg_tmp6.xy = (vs_in_reg6.xyyy).xy;
    return false;
}
bool sub_165_172() {
    reg_tmp2 = -reg_tmp15;
    reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
    reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_172_178() {
    reg_tmp1 = reg_tmp14;
    reg_tmp2.w = dot_3(reg_tmp1.xyz, reg_tmp1.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp1 = mul_s(reg_tmp1, reg_tmp2.wwww);
    reg_tmp1 = mul_s(uniforms.f[94].xxxx, reg_tmp1);
    reg_tmp6.xy = (uniforms.f[94].xxxx + reg_tmp1.xyyy).xy;
    return false;
}
bool sub_178_4096() {
    {
        sub_29_90();
    }
    if (uniforms.b[1]) {
        sub_180_187();
    } else {
        sub_187_188();
    }
    vs_out_attr3 = reg_tmp2;
    {
        sub_90_117();
    }
    {
        sub_117_141();
    }
    {
        sub_141_157();
    }
    return true;
}
bool sub_180_187() {
    reg_tmp0 = vec4(dot_3(uniforms.f[83].xyz, reg_tmp12.xyz));
    reg_tmp0 = max(uniforms.f[93].xxxx, reg_tmp0);
    reg_tmp0 = mul_s(uniforms.f[84], reg_tmp0);
    reg_tmp0 = uniforms.f[85] + reg_tmp0;
    reg_tmp0.w = (uniforms.f[93].yyyy).w;
    reg_tmp1 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
    reg_tmp2 = mul_s(reg_tmp0, reg_tmp1);
    return false;
}
bool sub_187_188() {
    reg_tmp2 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
    return false;
}
// reference: 50B2C7E2F90F3F96, 0350F8532B3DBD74
// program: 0350F8532B3DBD74, B80FA1B7F97410CD, 9342C6596F83F706
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, D02B1E1378BD97CF
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, B78314A585D12D9C
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, DEC6EAEA57FA4325
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, D4C50B709583D191
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, B20F7E72A7330A13
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, 48065A05481CB4B8
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, BB80E4A110994B48
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, EAAC665924781109
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, 0656C780E79F2203
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, 31E556E9A7729BF4
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, 6C66577708AE1E87
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, FC7222C50C6F5038
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, D1B1A073730D724F
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, 790FB95CC0B11076
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, 037898F85F34DE95
// program: C1B15B379433D4E8, B80FA1B7F97410CD, 91931D139F54748D
// program: C1B15B379433D4E8, B80FA1B7F97410CD, 5FACCC9E3E0584D2
// reference: 4B583094A02FE50E, C1B15B379433D4E8
// program: CDD7AB422818C224, 42937135801BAA7E, 835CABE3A4B650D2
// program: CDD7AB422818C224, 42937135801BAA7E, F5D54925A6AE705F
// program: CDD7AB422818C224, 42937135801BAA7E, D4C9E99618707555
// program: CDD7AB422818C224, 42937135801BAA7E, 0951EE62DBCF2390
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, 3013FC5CF83A846B
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, 7ED2F034E5EB4FC6
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, BC32652205728950
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, 10AAC2A3349D1A7E
// program: CDD7AB422818C224, 42937135801BAA7E, 52F5F74AF1B519B6
// program: CDD7AB422818C224, 42937135801BAA7E, 98F0722A788E01FD
// reference: 1FC8293D3A2F2383, CDD7AB422818C224
// program: CDD7AB422818C224, 42937135801BAA7E, 6E5C02D38B9C02DF
// program: CDD7AB422818C224, 42937135801BAA7E, A4E2954DD6C4FB71
// shader: 8B31, 15E048F2F07F2E01

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;
out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define mul_3(x, y) mix(x * y, vec3(0.0), isnan(x * y))
#define fma_s(x, y, z) (mul_s(x, y) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(mul_3(x, y), vec3(1.0))

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_19();
bool sub_19_55();
bool sub_55_65();
bool sub_65_78();
bool sub_78_128();
bool sub_83_101();
bool sub_101_109();
bool sub_126_127();
bool sub_128_184();
bool sub_133_151();
bool sub_151_162();
bool sub_182_183();
bool sub_184_211();
bool sub_186_191();
bool sub_191_210();
bool sub_194_200();
bool sub_200_209();
bool sub_201_205();
bool sub_205_208();
bool sub_211_235();
bool sub_213_217();
bool sub_217_234();
bool sub_218_232();
bool sub_221_228();
bool sub_228_231();
bool sub_232_233();
bool sub_235_251();
bool sub_237_241();
bool sub_241_250();
bool sub_242_248();
bool sub_248_249();
bool sub_251_259();
bool sub_253_254();
bool sub_254_258();
bool sub_255_256();
bool sub_256_257();
bool sub_259_266();
bool sub_266_272();
bool sub_272_4096();
bool sub_273_275();
bool sub_275_277();
bool sub_278_285();
bool sub_285_286();

bool exec_shader() {
    sub_272_4096();
    return true;
}

bool sub_0_19() {
    uint jmp_to = 0u;
    while (true) {
        switch (jmp_to) {
        case 0u: {
            reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
            reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
            reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
            reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
            reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
            reg_tmp6.x = rsq_s(reg_tmp6.x);
            reg_tmp7.x = rsq_s(reg_tmp7.x);
            reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            reg_tmp0 = uniforms.f[93].yxxx;
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            reg_tmp4 = mul_s(uniforms.f[94].xxxx, reg_tmp4);
            conditional_code = greaterThanEqual(uniforms.f[93].xx, reg_tmp4.xx);
            reg_tmp4 = vec4(rsq_s(reg_tmp4.x));
            reg_tmp5 = mul_s(uniforms.f[94].xxxx, reg_tmp14);
            if (conditional_code.x) {
                { jmp_to = 18u; break; }
            }
            reg_tmp0.z = rcp_s(reg_tmp4.x);
            reg_tmp0.xy = (mul_s(reg_tmp5, reg_tmp4)).xy;
        }
        case 18u: {
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_19_55() {
    uint jmp_to = 19u;
    while (true) {
        switch (jmp_to) {
        case 19u: {
            reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
            reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
            reg_tmp6.x = rsq_s(reg_tmp6.x);
            reg_tmp7.x = rsq_s(reg_tmp7.x);
            reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            reg_tmp13.xyz = (mul_s(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            reg_tmp11.xyz = (mul_s(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            reg_tmp0 = uniforms.f[93].yxxx;
            reg_tmp13.xyz = (mul_s(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            reg_tmp11.xyz = (mul_s(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            reg_tmp5 = mul_s(reg_tmp14.yzxx, reg_tmp13.zxyy);
            reg_tmp5 = fma_s(-reg_tmp13.yzxx, reg_tmp14.zxyy, reg_tmp5);
            reg_tmp5.w = dot_3(reg_tmp5.xyz, reg_tmp5.xyz);
            reg_tmp5.w = rsq_s(reg_tmp5.w);
            reg_tmp5 = mul_s(reg_tmp5, reg_tmp5.wwww);
            reg_tmp6.w = (reg_tmp14.zzzz + reg_tmp5.yyyy).w;
            reg_tmp13 = mul_s(reg_tmp5.yzxx, reg_tmp14.zxyy);
            reg_tmp13 = fma_s(-reg_tmp14.yzxx, reg_tmp5.zxyy, reg_tmp13);
            reg_tmp6.w = (reg_tmp13.xxxx + reg_tmp6).w;
            reg_tmp13.w = (reg_tmp5.zzzz).w;
            reg_tmp5.z = (reg_tmp13.xxxx).z;
            reg_tmp6.w = (uniforms.f[93].yyyy + reg_tmp6).w;
            reg_tmp14.w = (reg_tmp5.xxxx).w;
            reg_tmp5.x = (reg_tmp14.zzzz).x;
            conditional_code = lessThan(uniforms.f[94].zz, reg_tmp6.ww);
            reg_tmp6.x = (uniforms.f[93].yyyy).x;
            reg_tmp6.y = (-uniforms.f[93].yyyy).y;
            if (!conditional_code.x) {
                { jmp_to = 54u; break; }
            }
            reg_tmp7.xz = (reg_tmp13.wwyy + -reg_tmp14.yyww).xz;
            reg_tmp7.y = (reg_tmp14.xxxx + -reg_tmp13.zzzz).y;
            reg_tmp7.w = (reg_tmp6).w;
            reg_tmp6 = vec4(dot_s(reg_tmp7, reg_tmp7));
            reg_tmp6 = vec4(rsq_s(reg_tmp6.x));
            reg_tmp0 = mul_s(reg_tmp7, reg_tmp6);
        }
        case 54u: {
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_55_65() {
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    reg_tmp4.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_65_78() {
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    reg_tmp4.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp5.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp13.xyz);
    reg_tmp5.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp13.xyz);
    reg_tmp5.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp13.xyz);
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    reg_tmp11 = fma_s(reg_tmp1.wwww, reg_tmp5, reg_tmp11);
    return false;
}
bool sub_78_128() {
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    reg_tmp13.xyz = (vs_in_reg2).xyz;
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    if (uniforms.b[0]) {
        sub_83_101();
    } else {
        sub_101_109();
    }
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    {
        sub_0_19();
    }
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    vs_out_attr2 = -reg_tmp15;
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    if (all(conditional_code)) {
        sub_126_127();
    }
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_83_101() {
    reg_tmp7 = uniforms.f[93].xxxx;
    reg_tmp12 = uniforms.f[93].xxxx;
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    {
        sub_55_65();
    }
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    {
        sub_55_65();
    }
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    {
        sub_55_65();
    }
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    {
        sub_55_65();
    }
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    reg_tmp10 = reg_tmp7;
    return false;
}
bool sub_101_109() {
    reg_tmp7 = reg_tmp15;
    reg_tmp10.x = dot_s(uniforms.f[10], reg_tmp7);
    reg_tmp10.y = dot_s(uniforms.f[11], reg_tmp7);
    reg_tmp10.z = dot_s(uniforms.f[12], reg_tmp7);
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    reg_tmp12.x = dot_3(uniforms.f[10].xyz, reg_tmp14.xyz);
    reg_tmp12.y = dot_3(uniforms.f[11].xyz, reg_tmp14.xyz);
    reg_tmp12.z = dot_3(uniforms.f[12].xyz, reg_tmp14.xyz);
    return false;
}
bool sub_126_127() {
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_128_184() {
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    reg_tmp13.xyz = (vs_in_reg2).xyz;
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    if (uniforms.b[0]) {
        sub_133_151();
    } else {
        sub_151_162();
    }
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    reg_tmp13.x = dot_3(uniforms.f[90].xyz, reg_tmp11.xyz);
    reg_tmp13.y = dot_3(uniforms.f[91].xyz, reg_tmp11.xyz);
    reg_tmp13.z = dot_3(uniforms.f[92].xyz, reg_tmp11.xyz);
    {
        sub_19_55();
    }
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    vs_out_attr2 = -reg_tmp15;
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    if (all(conditional_code)) {
        sub_182_183();
    }
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_133_151() {
    reg_tmp7 = uniforms.f[93].xxxx;
    reg_tmp12 = uniforms.f[93].xxxx;
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    {
        sub_65_78();
    }
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    {
        sub_65_78();
    }
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    {
        sub_65_78();
    }
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    {
        sub_65_78();
    }
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    reg_tmp10 = reg_tmp7;
    return false;
}
bool sub_151_162() {
    reg_tmp7 = reg_tmp15;
    reg_tmp10.x = dot_s(uniforms.f[10], reg_tmp7);
    reg_tmp10.y = dot_s(uniforms.f[11], reg_tmp7);
    reg_tmp10.z = dot_s(uniforms.f[12], reg_tmp7);
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    reg_tmp12.x = dot_3(uniforms.f[10].xyz, reg_tmp14.xyz);
    reg_tmp12.y = dot_3(uniforms.f[11].xyz, reg_tmp14.xyz);
    reg_tmp12.z = dot_3(uniforms.f[12].xyz, reg_tmp14.xyz);
    reg_tmp11.x = dot_3(uniforms.f[10].xyz, reg_tmp13.xyz);
    reg_tmp11.y = dot_3(uniforms.f[11].xyz, reg_tmp13.xyz);
    reg_tmp11.z = dot_3(uniforms.f[12].xyz, reg_tmp13.xyz);
    return false;
}
bool sub_182_183() {
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_184_211() {
    reg_tmp0.xy = (uniforms.f[0].xxxx).xy;
    if (uniforms.b[2]) {
        sub_186_191();
    } else {
        sub_191_210();
    }
    return false;
}
bool sub_186_191() {
    {
        sub_251_259();
    }
    reg_tmp3.x = dot_s(uniforms.f[1].xywz, reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2].xywz, reg_tmp6);
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_191_210() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_194_200();
    } else {
        sub_200_209();
    }
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_194_200() {
    reg_tmp6 = reg_tmp10;
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    reg_tmp3.z = dot_s(uniforms.f[3], reg_tmp6);
    reg_tmp0.xy = (mul_s(uniforms.f[9].xyyy, reg_tmp3.zzzz)).xy;
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_200_209() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_201_205();
    } else {
        sub_205_208();
    }
    return false;
}
bool sub_201_205() {
    {
        sub_259_266();
    }
    reg_tmp3.x = dot_3(uniforms.f[1].xyz, reg_tmp6.xyz);
    reg_tmp3.y = dot_3(uniforms.f[2].xyz, reg_tmp6.xyz);
    reg_tmp3.z = dot_3(uniforms.f[3].xyz, reg_tmp6.xyz);
    return false;
}
bool sub_205_208() {
    {
        sub_266_272();
    }
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    return false;
}
bool sub_211_235() {
    reg_tmp0.xy = (uniforms.f[0].yyyy).xy;
    if (uniforms.b[3]) {
        sub_213_217();
    } else {
        sub_217_234();
    }
    return false;
}
bool sub_213_217() {
    {
        sub_251_259();
    }
    reg_tmp4.x = dot_s(uniforms.f[4].xywz, reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5].xywz, reg_tmp6);
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_217_234() {
    if (uniforms.b[5]) {
        sub_218_232();
    } else {
        sub_232_233();
    }
    return false;
}
bool sub_218_232() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_221_228();
    } else {
        sub_228_231();
    }
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_221_228() {
    reg_tmp6 = reg_tmp10;
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    reg_tmp4.z = dot_s(uniforms.f[6], reg_tmp6);
    reg_tmp6.w = rcp_s(reg_tmp4.z);
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    reg_tmp4.xy = (uniforms.f[9].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_228_231() {
    {
        sub_266_272();
    }
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    return false;
}
bool sub_232_233() {
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_235_251() {
    reg_tmp0.xy = (uniforms.f[0].zzzz).xy;
    if (uniforms.b[4]) {
        sub_237_241();
    } else {
        sub_241_250();
    }
    return false;
}
bool sub_237_241() {
    {
        sub_251_259();
    }
    reg_tmp5.x = dot_s(uniforms.f[7].xywz, reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8].xywz, reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_241_250() {
    if (uniforms.b[6]) {
        sub_242_248();
    } else {
        sub_248_249();
    }
    return false;
}
bool sub_242_248() {
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    {
        sub_266_272();
    }
    reg_tmp5.x = dot_s(uniforms.f[7], reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8], reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_248_249() {
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
bool sub_251_259() {
    conditional_code = equal(uniforms.f[93].yz, reg_tmp0.xy);
    if (all(not(conditional_code))) {
        sub_253_254();
    } else {
        sub_254_258();
    }
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_253_254() {
    reg_tmp6.xy = (vs_in_reg4.xyyy).xy;
    return false;
}
bool sub_254_258() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_255_256();
    } else {
        sub_256_257();
    }
    return false;
}
bool sub_255_256() {
    reg_tmp6.xy = (vs_in_reg5.xyyy).xy;
    return false;
}
bool sub_256_257() {
    reg_tmp6.xy = (vs_in_reg6.xyyy).xy;
    return false;
}
bool sub_259_266() {
    reg_tmp2 = -reg_tmp15;
    reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
    reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_266_272() {
    reg_tmp1 = reg_tmp14;
    reg_tmp2.w = dot_3(reg_tmp1.xyz, reg_tmp1.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp1 = mul_s(reg_tmp1, reg_tmp2.wwww);
    reg_tmp1 = mul_s(uniforms.f[94].xxxx, reg_tmp1);
    reg_tmp6.xy = (uniforms.f[94].xxxx + reg_tmp1.xyyy).xy;
    return false;
}
bool sub_272_4096() {
    if (uniforms.b[10]) {
        sub_273_275();
    } else {
        sub_275_277();
    }
    if (uniforms.b[1]) {
        sub_278_285();
    } else {
        sub_285_286();
    }
    vs_out_attr3 = reg_tmp2;
    {
        sub_184_211();
    }
    {
        sub_211_235();
    }
    {
        sub_235_251();
    }
    return true;
}
bool sub_273_275() {
    {
        sub_128_184();
    }
    return false;
}
bool sub_275_277() {
    {
        sub_78_128();
    }
    return false;
}
bool sub_278_285() {
    reg_tmp0 = vec4(dot_3(uniforms.f[83].xyz, reg_tmp12.xyz));
    reg_tmp0 = max(uniforms.f[93].xxxx, reg_tmp0);
    reg_tmp0 = mul_s(uniforms.f[84], reg_tmp0);
    reg_tmp0 = uniforms.f[85] + reg_tmp0;
    reg_tmp0.w = (uniforms.f[93].yyyy).w;
    reg_tmp1 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
    reg_tmp2 = mul_s(reg_tmp0, reg_tmp1);
    return false;
}
bool sub_285_286() {
    reg_tmp2 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
    return false;
}
// reference: 73EE4218F7463289, 15E048F2F07F2E01
// program: 15E048F2F07F2E01, B80FA1B7F97410CD, 19F7816C4117CF8E
// reference: 519CD67DF44EBC11, CDD7AB422818C224
// program: CDD7AB422818C224, 42937135801BAA7E, 5FBCCF5F27F5A7C1
// reference: 1FC8293D433BE865, CDD7AB422818C224
// program: CDD7AB422818C224, 42937135801BAA7E, 63B6ADAD25C2A518
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, 47E4BEE6B3304AF3
// reference: 3DBABD58254B86F8, 01B0CF4127F43ED8
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, C580B429ECAF519A
// shader: 8B31, 40D5333E0804E8E0

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;
out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define mul_3(x, y) mix(x * y, vec3(0.0), isnan(x * y))
#define fma_s(x, y, z) (mul_s(x, y) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(mul_3(x, y), vec3(1.0))

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_49();
bool sub_25_31();
bool sub_32_39();
bool sub_40_48();
bool sub_175_202();
bool sub_177_182();
bool sub_182_201();
bool sub_185_191();
bool sub_191_200();
bool sub_192_196();
bool sub_196_199();
bool sub_202_226();
bool sub_204_208();
bool sub_208_225();
bool sub_209_223();
bool sub_212_219();
bool sub_219_222();
bool sub_223_224();
bool sub_226_242();
bool sub_228_232();
bool sub_232_241();
bool sub_233_239();
bool sub_239_240();
bool sub_242_250();
bool sub_244_245();
bool sub_245_249();
bool sub_246_247();
bool sub_247_248();
bool sub_343_350();
bool sub_350_354();
bool sub_354_4096();
bool sub_361_363();
bool sub_363_364();

bool exec_shader() {
    sub_354_4096();
    return true;
}

bool sub_0_49() {
    reg_tmp1.xyz = (uniforms.f[93].xxyx).xyz;
    reg_tmp8.x = dot_3(uniforms.f[0].xyz, reg_tmp12.xyz);
    reg_tmp8.y = dot_3(uniforms.f[1].xyz, reg_tmp12.xyz);
    reg_tmp8.z = dot_3(uniforms.f[2].xyz, reg_tmp12.xyz);
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp8.xyz);
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp8.xyz);
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp8.xyz);
    reg_tmp14.w = (uniforms.f[93].xxxx).w;
    reg_tmp8 = reg_tmp14;
    reg_tmp14.x = dot_s(reg_tmp8, reg_tmp8);
    reg_tmp14.x = rsq_s(reg_tmp14.x);
    reg_tmp14 = mul_s(reg_tmp8, reg_tmp14.xxxx);
    reg_tmp0 = uniforms.f[23];
    reg_tmp8.x = dot_3(uniforms.f[0].xyz, reg_tmp0.xyz);
    reg_tmp8.y = dot_3(uniforms.f[1].xyz, reg_tmp0.xyz);
    reg_tmp8.z = dot_3(uniforms.f[2].xyz, reg_tmp0.xyz);
    reg_tmp6.x = dot_3(uniforms.f[90].xyz, reg_tmp8.xyz);
    reg_tmp6.y = dot_3(uniforms.f[91].xyz, reg_tmp8.xyz);
    reg_tmp6.z = dot_3(uniforms.f[92].xyz, reg_tmp8.xyz);
    reg_tmp8.xyz = (reg_tmp6.xyzz + reg_tmp1.xyzz).xyz;
    reg_tmp8.w = (uniforms.f[93].xxxx).w;
    reg_tmp0.x = dot_s(reg_tmp8, reg_tmp8);
    reg_tmp0.x = rsq_s(reg_tmp0.x);
    reg_tmp0 = mul_s(reg_tmp8, reg_tmp0.xxxx);
    if (uniforms.b[5]) {
        sub_25_31();
    }
    if (uniforms.b[3]) {
        sub_32_39();
    }
    if (uniforms.b[4]) {
        sub_40_48();
    }
    vs_out_attr3 = reg_tmp2;
    return false;
}
bool sub_25_31() {
    reg_tmp8.x = dot_3(reg_tmp14.xyz, -reg_tmp6.xyz);
    reg_tmp8.y = dot_3(reg_tmp1.xyz, -reg_tmp6.xyz);
    reg_tmp8 = max(uniforms.f[93].xxxx, reg_tmp8);
    reg_tmp8.y = (mul_s(uniforms.f[94].zzzz, reg_tmp8.yyyy)).y;
    reg_tmp8.y = (uniforms.f[94].zzzz + reg_tmp8.yyyy).y;
    reg_tmp2.y = (mul_s(reg_tmp8.xxxx, reg_tmp8.yyyy)).y;
    return false;
}
bool sub_32_39() {
    reg_tmp9.z = dot_3(reg_tmp14.xyz, reg_tmp0.xyz);
    reg_tmp9.z = (max(uniforms.f[93].xxxx, reg_tmp9.zzzz)).z;
    reg_tmp9.z = (min(uniforms.f[93].yyyy, reg_tmp9.zzzz)).z;
    reg_tmp9.z = log2(reg_tmp9.z);
    reg_tmp9.z = (mul_s(uniforms.f[22].zzzz, reg_tmp9.zzzz)).z;
    reg_tmp9.z = exp2(reg_tmp9.z);
    reg_tmp2.z = (mul_s(uniforms.f[22].wwww, reg_tmp9.zzzz)).z;
    return false;
}
bool sub_40_48() {
    reg_tmp9.x = dot_3(reg_tmp14.xyz, reg_tmp1.xyz);
    reg_tmp9.x = (max(uniforms.f[93].xxxx, reg_tmp9.xxxx)).x;
    reg_tmp9.x = (min(uniforms.f[93].yyyy, reg_tmp9.xxxx)).x;
    reg_tmp9.x = (uniforms.f[93].yyyy + -reg_tmp9.xxxx).x;
    reg_tmp9.x = log2(reg_tmp9.x);
    reg_tmp9.x = (mul_s(uniforms.f[22].xxxx, reg_tmp9.xxxx)).x;
    reg_tmp9.x = exp2(reg_tmp9.x);
    reg_tmp2.w = (mul_s(uniforms.f[22].yyyy, reg_tmp9.xxxx)).w;
    return false;
}
bool sub_175_202() {
    reg_tmp0.xy = (uniforms.f[10].xxxx).xy;
    if (uniforms.b[9]) {
        sub_177_182();
    } else {
        sub_182_201();
    }
    return false;
}
bool sub_177_182() {
    {
        sub_242_250();
    }
    reg_tmp3.x = dot_s(uniforms.f[11].xywz, reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[12].xywz, reg_tmp6);
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_182_201() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_185_191();
    } else {
        sub_191_200();
    }
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_185_191() {
    reg_tmp6 = reg_tmp10;
    reg_tmp3.x = dot_s(uniforms.f[11], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[12], reg_tmp6);
    reg_tmp3.z = dot_s(uniforms.f[13], reg_tmp6);
    reg_tmp0.xy = (mul_s(uniforms.f[19].xyyy, reg_tmp3.zzzz)).xy;
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_191_200() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_192_196();
    } else {
        sub_196_199();
    }
    return false;
}
bool sub_192_196() {
    {
        sub_343_350();
    }
    reg_tmp3.x = dot_3(uniforms.f[11].xyz, reg_tmp6.xyz);
    reg_tmp3.y = dot_3(uniforms.f[12].xyz, reg_tmp6.xyz);
    reg_tmp3.z = dot_3(uniforms.f[13].xyz, reg_tmp6.xyz);
    return false;
}
bool sub_196_199() {
    {
        sub_350_354();
    }
    reg_tmp3.x = dot_s(uniforms.f[11], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[12], reg_tmp6);
    return false;
}
bool sub_202_226() {
    reg_tmp0.xy = (uniforms.f[10].yyyy).xy;
    if (uniforms.b[10]) {
        sub_204_208();
    } else {
        sub_208_225();
    }
    return false;
}
bool sub_204_208() {
    {
        sub_242_250();
    }
    reg_tmp4.x = dot_s(uniforms.f[14].xywz, reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[15].xywz, reg_tmp6);
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_208_225() {
    if (uniforms.b[13]) {
        sub_209_223();
    } else {
        sub_223_224();
    }
    return false;
}
bool sub_209_223() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_212_219();
    } else {
        sub_219_222();
    }
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_212_219() {
    reg_tmp6 = reg_tmp10;
    reg_tmp4.x = dot_s(uniforms.f[14], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[15], reg_tmp6);
    reg_tmp4.z = dot_s(uniforms.f[16], reg_tmp6);
    reg_tmp6.w = rcp_s(reg_tmp4.z);
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    reg_tmp4.xy = (uniforms.f[19].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_219_222() {
    {
        sub_350_354();
    }
    reg_tmp4.x = dot_s(uniforms.f[14], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[15], reg_tmp6);
    return false;
}
bool sub_223_224() {
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_226_242() {
    reg_tmp0.xy = (uniforms.f[10].zzzz).xy;
    if (uniforms.b[11]) {
        sub_228_232();
    } else {
        sub_232_241();
    }
    return false;
}
bool sub_228_232() {
    {
        sub_242_250();
    }
    reg_tmp5.x = dot_s(uniforms.f[17].xywz, reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[18].xywz, reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_232_241() {
    if (uniforms.b[14]) {
        sub_233_239();
    } else {
        sub_239_240();
    }
    return false;
}
bool sub_233_239() {
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    {
        sub_350_354();
    }
    reg_tmp5.x = dot_s(uniforms.f[17], reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[18], reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_239_240() {
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
bool sub_242_250() {
    conditional_code = equal(uniforms.f[93].yz, reg_tmp0.xy);
    if (all(not(conditional_code))) {
        sub_244_245();
    } else {
        sub_245_249();
    }
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_244_245() {
    reg_tmp6.xy = (mul_s(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
    return false;
}
bool sub_245_249() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_246_247();
    } else {
        sub_247_248();
    }
    return false;
}
bool sub_246_247() {
    reg_tmp6.xy = (mul_s(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
    return false;
}
bool sub_247_248() {
    reg_tmp6.xy = (mul_s(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
    return false;
}
bool sub_343_350() {
    reg_tmp2 = -reg_tmp15;
    reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
    reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_350_354() {
    reg_tmp1.xy = (uniforms.f[94].zzzz).xy;
    reg_tmp1.zw = (uniforms.f[93].xxxx).zw;
    reg_tmp6 = fma_s(reg_tmp14, reg_tmp1, reg_tmp1);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_354_4096() {
    reg_tmp0 = vs_in_reg0;
    reg_tmp0.z = (uniforms.f[93].xxxx).z;
    reg_tmp0.w = (uniforms.f[93].yyyy).w;
    vs_out_attr0 = reg_tmp0;
    vs_out_attr2 = reg_tmp0;
    vs_out_attr1 = reg_tmp0;
    if (uniforms.b[6]) {
        sub_361_363();
    } else {
        sub_363_364();
    }
    {
        sub_175_202();
    }
    {
        sub_202_226();
    }
    {
        sub_226_242();
    }
    return true;
}
bool sub_361_363() {
    {
        sub_0_49();
    }
    return false;
}
bool sub_363_364() {
    vs_out_attr3 = uniforms.f[93].yyyy;
    return false;
}
// reference: A572BCB06CA1EDA3, 40D5333E0804E8E0
// program: 40D5333E0804E8E0, B80FA1B7F97410CD, 5C250F6C1418BBD3
// reference: E447428B6D5485F5, 01B0CF4127F43ED8
// reference: AA13BDCB15BFC649, 01B0CF4127F43ED8
// reference: AA13BDCBDA21D181, 01B0CF4127F43ED8
// reference: E447428BC7B27238, 15E048F2F07F2E01
// reference: BF76358EC4BAFCA0, CDD7AB422818C224
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, 4BA25B84A31C492A
// reference: BF76358E1B37B994, CDD7AB422818C224
// program: CDD7AB422818C224, 42937135801BAA7E, CAB8B665DC444CE4
// reference: F122CACE437B7EA1, CDD7AB422818C224
// reference: 9D04A1EB6D5485F5, 01B0CF4127F43ED8
// reference: D3505EAB15BFC649, 01B0CF4127F43ED8
// reference: D3505EABDA21D181, 01B0CF4127F43ED8
// reference: 9D04A1EBC7B27238, 15E048F2F07F2E01
// reference: F122CACE73CFA8D4, CDD7AB422818C224
// program: CDD7AB422818C224, 42937135801BAA7E, 6B98A4CC666FCBCF
// program: CDD7AB422818C224, 42937135801BAA7E, D1257B6267770D05
// program: CDD7AB422818C224, 42937135801BAA7E, D134C63316570D84
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, 40FC95A67F54598B
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, D69A3CB52F0E3495
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, B5CB613BFC4BC41C
// reference: B67DEEB4720CFD21, C1B15B379433D4E8
// program: C1B15B379433D4E8, B80FA1B7F97410CD, 1B4DA8DA884D39A1
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, D2BD0C5FAA2AB273
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, F8FBCC791CAC22F2
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, FEE7FD4C7FD3D731
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, 8633243B2123B710
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, 39E142A8F1F39B96
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, FC9E10BE42F07103
// shader: 8B31, 2943A920476E1E56

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define mul_3(x, y) mix(x * y, vec3(0.0), isnan(x * y))
#define fma_s(x, y, z) (mul_s(x, y) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(mul_3(x, y), vec3(1.0))

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_8();
bool sub_9_32();
bool sub_33_96();
bool sub_146_166();
bool sub_167_259();
bool sub_190_192();
bool sub_194_195();
bool sub_197_198();
bool sub_200_202();
bool sub_232_234();
bool sub_236_237();
bool sub_239_240();
bool sub_242_244();
bool sub_260_4096();
bool sub_287_288();
bool sub_288_289();

bool exec_shader() {
    sub_260_4096();
    return true;
}

bool sub_0_8() {
    address_registers.x = (ivec2(vs_in_reg0.zz)).x;
    reg_tmp10 = uniforms.f[0].xxxz;
    reg_tmp10.xy = (vs_in_reg0.xyyy).xy;
    reg_tmp11 = uniforms.f[0].xxxx;
    reg_tmp12 = uniforms.f[0].xxxx;
    reg_tmp13 = uniforms.f[0].zzzz;
    reg_tmp4 = uniforms.f[0].xxxx;
    reg_tmp5 = uniforms.f[0].xxxx;
    return false;
}
bool sub_9_32() {
    vs_out_attr0 = reg_tmp10;
    reg_tmp13 = mul_s(uniforms.f[82], reg_tmp13);
    vs_out_attr1 = reg_tmp13;
    reg_tmp11.y = (uniforms.f[0].zzzz + -reg_tmp11.yyyy).y;
    reg_tmp12.y = (uniforms.f[0].zzzz + -reg_tmp12.yyyy).y;
    reg_tmp14.y = (uniforms.f[81].wwww).y;
    reg_tmp14.x = (mul_s(uniforms.f[0].wwww, reg_tmp14.yyyy)).x;
    reg_tmp2.x = rcp_s(reg_tmp14.x);
    reg_tmp14.z = (reg_tmp2.xxxx).z;
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp11.xyyy).xy;
    reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    reg_tmp11.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp12.xyyy).xy;
    reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    reg_tmp12.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    vs_out_attr2 = reg_tmp11;
    vs_out_attr3 = reg_tmp12;
    return false;
}
bool sub_33_96() {
    reg_tmp6.xyz = (-reg_tmp0.xyzz).xyz;
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    reg_tmp7.xyz = vec3(rcp_s(uniforms.f[81].y));
    reg_tmp8.xyz = (fma_s(reg_tmp6.xyzz, reg_tmp7.xyzz, uniforms.f[0].yyyy)).xyz;
    reg_tmp7.xyz = (floor(reg_tmp8.xyzz)).xyz;
    reg_tmp6.xyz = (fma_s(reg_tmp7.xyzz, -uniforms.f[81].yyyy, reg_tmp6.xyzz)).xyz;
    reg_tmp6 = min(uniforms.f[81].xxxx, reg_tmp6);
    reg_tmp6 = max(-uniforms.f[81].xxxx, reg_tmp6);
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp6.xxxx, reg_tmp6.xxxx)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp6.xxxx)).y;
    reg_tmp4.x = (reg_tmp1.xxxx).x;
    reg_tmp5.x = (reg_tmp1.yyyy).x;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp6.yyyy, reg_tmp6.yyyy)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp6.yyyy)).y;
    reg_tmp4.y = (reg_tmp1.xxxx).y;
    reg_tmp5.y = (reg_tmp1.yyyy).y;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp6.zzzz, reg_tmp6.zzzz)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp6.zzzz)).y;
    reg_tmp4.z = (reg_tmp1.xxxx).z;
    reg_tmp5.z = (reg_tmp1.yyyy).z;
    reg_tmp2.x = (mul_s(reg_tmp4.yyyy, reg_tmp5.zzzz)).x;
    reg_tmp2.y = (mul_s(reg_tmp5.yyyy, reg_tmp5.zzzz)).y;
    reg_tmp6.x = (mul_s(reg_tmp4.yyyy, reg_tmp4.zzzz)).x;
    reg_tmp6.y = (reg_tmp5.zzzz).y;
    reg_tmp6.z = (mul_s(-reg_tmp5.yyyy, reg_tmp4.zzzz)).z;
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    reg_tmp7.x = (mul_s(-reg_tmp2.xxxx, reg_tmp4.xxxx)).x;
    reg_tmp7.x = (fma_s(reg_tmp5.yyyy, reg_tmp5.xxxx, reg_tmp7.xxxx)).x;
    reg_tmp7.y = (mul_s(reg_tmp4.zzzz, reg_tmp4.xxxx)).y;
    reg_tmp7.z = (mul_s(reg_tmp2.yyyy, reg_tmp4.xxxx)).z;
    reg_tmp7.z = (fma_s(reg_tmp4.yyyy, reg_tmp5.xxxx, reg_tmp7.zzzz)).z;
    reg_tmp7.w = (uniforms.f[0].xxxx).w;
    reg_tmp8.x = (mul_s(reg_tmp2.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp8.x = (fma_s(reg_tmp5.yyyy, reg_tmp4.xxxx, reg_tmp8.xxxx)).x;
    reg_tmp8.y = (mul_s(-reg_tmp4.zzzz, reg_tmp5.xxxx)).y;
    reg_tmp8.z = (mul_s(-reg_tmp2.yyyy, reg_tmp5.xxxx)).z;
    reg_tmp8.z = (fma_s(reg_tmp4.yyyy, reg_tmp4.xxxx, reg_tmp8.zzzz)).z;
    reg_tmp8.w = (uniforms.f[0].xxxx).w;
    reg_tmp9 = uniforms.f[0].xxxz;
    return false;
}
bool sub_146_166() {
    reg_tmp2 = uniforms.f[90];
    reg_tmp3 = uniforms.f[91];
    reg_tmp4 = uniforms.f[92];
    reg_tmp5 = uniforms.f[0].xxxz;
    reg_tmp6 = mul_s(uniforms.f[86].xxxx, reg_tmp2);
    reg_tmp6 = fma_s(reg_tmp3, uniforms.f[86].yyyy, reg_tmp6);
    reg_tmp6 = fma_s(reg_tmp4, uniforms.f[86].zzzz, reg_tmp6);
    reg_tmp6 = fma_s(reg_tmp5, uniforms.f[86].wwww, reg_tmp6);
    reg_tmp7 = mul_s(uniforms.f[87].xxxx, reg_tmp2);
    reg_tmp7 = fma_s(reg_tmp3, uniforms.f[87].yyyy, reg_tmp7);
    reg_tmp7 = fma_s(reg_tmp4, uniforms.f[87].zzzz, reg_tmp7);
    reg_tmp7 = fma_s(reg_tmp5, uniforms.f[87].wwww, reg_tmp7);
    reg_tmp8 = mul_s(uniforms.f[88].xxxx, reg_tmp2);
    reg_tmp8 = fma_s(reg_tmp3, uniforms.f[88].yyyy, reg_tmp8);
    reg_tmp8 = fma_s(reg_tmp4, uniforms.f[88].zzzz, reg_tmp8);
    reg_tmp8 = fma_s(reg_tmp5, uniforms.f[88].wwww, reg_tmp8);
    reg_tmp9 = mul_s(uniforms.f[89].xxxx, reg_tmp2);
    reg_tmp9 = fma_s(reg_tmp3, uniforms.f[89].yyyy, reg_tmp9);
    reg_tmp9 = fma_s(reg_tmp4, uniforms.f[89].zzzz, reg_tmp9);
    reg_tmp9 = fma_s(reg_tmp5, uniforms.f[89].wwww, reg_tmp9);
    return false;
}
bool sub_167_259() {
    reg_tmp2.x = rcp_s(uniforms.f[81].y);
    reg_tmp2.xy = (mul_s(uniforms.f[2 + address_registers.x].zwww, reg_tmp2.xxxx)).xy;
    reg_tmp2.xy = (uniforms.f[0].yyyy + reg_tmp2.xyyy).xy;
    reg_tmp3.xy = (floor(reg_tmp2.xyyy)).xy;
    reg_tmp2.xy = (mul_s(uniforms.f[81].yyyy, reg_tmp3.xyyy)).xy;
    reg_tmp2.xy = (uniforms.f[2 + address_registers.x].zwww + -reg_tmp2.xyyy).xy;
    reg_tmp0.xy = (min(uniforms.f[81].xxxx, -reg_tmp2.xyyy)).xy;
    reg_tmp0.xy = (max(-uniforms.f[81].xxxx, reg_tmp0.xyyy)).xy;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp0.xxxx, reg_tmp0.xxxx)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.xxxx)).y;
    reg_tmp5.x = (uniforms.f[5 + address_registers.x].wwww).x;
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_190_192();
    }
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_194_195();
    }
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_197_198();
    }
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_200_202();
    }
    reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    reg_tmp4.z = (uniforms.f[83].xxxx).z;
    reg_tmp4.w = (-uniforms.f[83].yyyy).w;
    reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[3 + address_registers.x].xyyy)).xy;
    reg_tmp4.z = (-uniforms.f[3 + address_registers.x].zzzz).z;
    reg_tmp4.w = (-uniforms.f[3 + address_registers.x].wwww).w;
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    reg_tmp11.xy = (reg_tmp5.xyyy).xy;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp0.yyyy, reg_tmp0.yyyy)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.yyyy)).y;
    reg_tmp5.x = (uniforms.f[6 + address_registers.x].wwww).x;
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_232_234();
    }
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_236_237();
    }
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_239_240();
    }
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_242_244();
    }
    reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    reg_tmp4.z = (uniforms.f[83].zzzz).z;
    reg_tmp4.w = (-uniforms.f[83].wwww).w;
    reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[4 + address_registers.x].xyyy)).xy;
    reg_tmp4.z = (-uniforms.f[4 + address_registers.x].zzzz).z;
    reg_tmp4.w = (-uniforms.f[4 + address_registers.x].wwww).w;
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    reg_tmp12.xy = (reg_tmp5.xyyy).xy;
    return false;
}
bool sub_190_192() {
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_194_195() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_197_198() {
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_200_202() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_232_234() {
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_236_237() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_239_240() {
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_242_244() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_260_4096() {
    {
        sub_0_8();
    }
    reg_tmp10.xy = (uniforms.f[84].xyyy + reg_tmp10.xyyy).xy;
    reg_tmp10.xy = (mul_s(uniforms.f[2 + address_registers.x].xyyy, reg_tmp10.xyyy)).xy;
    reg_tmp14 = reg_tmp10;
    reg_tmp0 = uniforms.f[7 + address_registers.x];
    {
        sub_33_96();
    }
    reg_tmp10.x = dot_s(reg_tmp14, reg_tmp6);
    reg_tmp10.y = dot_s(reg_tmp14, reg_tmp7);
    reg_tmp10.z = dot_s(reg_tmp14, reg_tmp8);
    reg_tmp10.w = dot_s(reg_tmp14, reg_tmp9);
    reg_tmp6 = uniforms.f[8 + address_registers.x];
    reg_tmp7 = uniforms.f[9 + address_registers.x];
    reg_tmp8 = uniforms.f[10 + address_registers.x];
    reg_tmp9 = uniforms.f[0].xxxz;
    reg_tmp6.w = (uniforms.f[5 + address_registers.x].xxxx).w;
    reg_tmp7.w = (uniforms.f[5 + address_registers.x].yyyy).w;
    reg_tmp8.w = (uniforms.f[5 + address_registers.x].zzzz).w;
    reg_tmp2.x = dot_s(reg_tmp10, reg_tmp6);
    reg_tmp2.y = dot_s(reg_tmp10, reg_tmp7);
    reg_tmp2.z = dot_s(reg_tmp10, reg_tmp8);
    reg_tmp2.w = dot_s(reg_tmp10, reg_tmp9);
    reg_tmp10 = reg_tmp2;
    reg_tmp3.xyz = (uniforms.f[5 + address_registers.x].xyzz).xyz;
    reg_tmp3.xyz = (uniforms.f[85].xyzz + -reg_tmp3.xyzz).xyz;
    reg_tmp4.x = dot_3(reg_tmp3.xyz, reg_tmp3.xyz);
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
    if (conditional_code.x) {
        sub_287_288();
    } else {
        sub_288_289();
    }
    reg_tmp3.xyz = (mul_s(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
    reg_tmp10.xyz = (fma_s(reg_tmp3.xyzz, uniforms.f[84].zzzz, reg_tmp10.xyzz)).xyz;
    {
        sub_146_166();
    }
    reg_tmp2 = reg_tmp10;
    reg_tmp10.x = dot_s(reg_tmp2, reg_tmp6);
    reg_tmp10.y = dot_s(reg_tmp2, reg_tmp7);
    reg_tmp10.z = dot_s(reg_tmp2, reg_tmp8);
    reg_tmp10.w = dot_s(reg_tmp2, reg_tmp9);
    reg_tmp2 = uniforms.f[1 + address_registers.x];
    reg_tmp3 = max(uniforms.f[0].xxxx, reg_tmp2);
    reg_tmp2 = min(uniforms.f[0].zzzz, reg_tmp3);
    reg_tmp13 = reg_tmp2;
    {
        sub_167_259();
    }
    {
        sub_9_32();
    }
    return true;
}
bool sub_287_288() {
    reg_tmp4.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_288_289() {
    reg_tmp4.x = rsq_s(reg_tmp4.x);
    return false;
}
// reference: E545D249133242E2, 2943A920476E1E56
// program: 2943A920476E1E56, 082670B4222015B2, DBA0F8FE46AD8D9B
// reference: 519CD67D68CAA611, CDD7AB422818C224
// program: CDD7AB422818C224, 42937135801BAA7E, 47A8279A60685F27
// reference: 1FC8293D30866124, CDD7AB422818C224
// reference: 58970D4742F8BD90, C1B15B379433D4E8
// shader: 8B31, 2BD70906436FAF24

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;
out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define mul_3(x, y) mix(x * y, vec3(0.0), isnan(x * y))
#define fma_s(x, y, z) (mul_s(x, y) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(mul_3(x, y), vec3(1.0))

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_6();
bool sub_6_53();
bool sub_21_25();
bool sub_51_52();
bool sub_53_4096();

bool exec_shader() {
    sub_53_4096();
    return true;
}

bool sub_0_6() {
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    return false;
}
bool sub_6_53() {
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    reg_tmp7 = uniforms.f[93].xxxx;
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    {
        sub_0_6();
    }
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    {
        sub_0_6();
    }
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    if (conditional_code.x) {
        sub_0_6();
    }
    if (uniforms.b[11]) {
        sub_21_25();
    }
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    reg_tmp10 = reg_tmp7;
    reg_tmp6.y = (-uniforms.f[83].wwww + reg_tmp10.yyyy).y;
    reg_tmp9.xyz = (uniforms.f[83].xyzz).xyz;
    reg_tmp7.x = dot_s(reg_tmp9.xyzz, reg_tmp9.xyzz);
    reg_tmp7.x = rsq_s(reg_tmp7.x);
    reg_tmp7.xyz = (mul_s(reg_tmp9.xyzz, reg_tmp7.xxxx)).xyz;
    reg_tmp8.y = rcp_s(-reg_tmp7.y);
    reg_tmp8.y = (mul_s(reg_tmp6.yyyy, reg_tmp8.yyyy)).y;
    reg_tmp7.xyz = (mul_s(reg_tmp7.xyzz, reg_tmp8.yyyy)).xyz;
    reg_tmp10.xyz = (reg_tmp10.xyzz + reg_tmp7.xyzz).xyz;
    reg_tmp10.y = (uniforms.f[94].xxxx + reg_tmp10.yyyy).y;
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    vs_out_attr1 = uniforms.f[93].xxxx;
    vs_out_attr2 = -reg_tmp15;
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    if (all(conditional_code)) {
        sub_51_52();
    }
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_21_25() {
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    if (conditional_code.y) {
        sub_0_6();
    }
    return false;
}
bool sub_51_52() {
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_53_4096() {
    {
        sub_6_53();
    }
    vs_out_attr4 = uniforms.f[93].xxxx;
    vs_out_attr5 = uniforms.f[93].xxxx;
    vs_out_attr6 = uniforms.f[93].xxxx;
    vs_out_attr3 = uniforms.f[93].xxxx;
    return true;
}
// reference: C6B373FED15ECBFA, 2BD70906436FAF24
// program: 2BD70906436FAF24, B80FA1B7F97410CD, C2EEBEAE0D7F3560
// reference: 88E78CBE662B9F8E, 2BD70906436FAF24
// shader: 8B31, 2C776115811B5DFC

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;
out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define mul_3(x, y) mix(x * y, vec3(0.0), isnan(x * y))
#define fma_s(x, y, z) (mul_s(x, y) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(mul_3(x, y), vec3(1.0))

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_19_29();
bool sub_143_151();
bool sub_145_146();
bool sub_146_150();
bool sub_147_148();
bool sub_148_149();
bool sub_166_4096();
bool sub_170_192();
bool sub_192_200();
bool sub_212_213();

bool exec_shader() {
    sub_166_4096();
    return true;
}

bool sub_19_29() {
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    reg_tmp4.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_143_151() {
    conditional_code = equal(uniforms.f[93].yz, reg_tmp0.xy);
    if (all(not(conditional_code))) {
        sub_145_146();
    } else {
        sub_146_150();
    }
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_145_146() {
    reg_tmp6.xy = (vs_in_reg4.xyyy).xy;
    return false;
}
bool sub_146_150() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_147_148();
    } else {
        sub_148_149();
    }
    return false;
}
bool sub_147_148() {
    reg_tmp6.xy = (vs_in_reg5.xyyy).xy;
    return false;
}
bool sub_148_149() {
    reg_tmp6.xy = (vs_in_reg6.xyyy).xy;
    return false;
}
bool sub_166_4096() {
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    if (uniforms.b[0]) {
        sub_170_192();
    } else {
        sub_192_200();
    }
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    if (all(conditional_code)) {
        sub_212_213();
    }
    vs_out_attr0 = reg_tmp0;
    vs_out_attr1 = uniforms.f[93].xxxx;
    vs_out_attr2 = uniforms.f[93].xxxx;
    reg_tmp0 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
    vs_out_attr3 = uniforms.f[94].zzzz + reg_tmp0;
    reg_tmp5.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    reg_tmp5.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    reg_tmp5.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    reg_tmp4.x = dot_s(reg_tmp5.xyzz, reg_tmp5.xyzz);
    reg_tmp4.x = rsq_s(reg_tmp4.x);
    reg_tmp4.xyz = (mul_s(reg_tmp5.xyzz, reg_tmp4.xxxx)).xyz;
    reg_tmp4 = mul_s(uniforms.f[94].xxxx, reg_tmp4);
    reg_tmp12 = uniforms.f[94].xxxx + reg_tmp4;
    vs_out_attr4 = reg_tmp12;
    reg_tmp0.xy = (uniforms.f[0].xxxx).xy;
    {
        sub_143_151();
    }
    reg_tmp4.x = dot_s(uniforms.f[4].xywz, reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5].xywz, reg_tmp6);
    vs_out_attr5 = reg_tmp4;
    vs_out_attr6 = reg_tmp4;
    return true;
}
bool sub_170_192() {
    reg_tmp7 = uniforms.f[93].xxxx;
    reg_tmp12 = uniforms.f[93].xxxx;
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    {
        sub_19_29();
    }
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    {
        sub_19_29();
    }
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    if (conditional_code.x) {
        sub_19_29();
    }
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    if (conditional_code.y) {
        sub_19_29();
    }
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    reg_tmp10 = reg_tmp7;
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    return false;
}
bool sub_192_200() {
    reg_tmp7 = reg_tmp15;
    reg_tmp10.x = dot_s(uniforms.f[10], reg_tmp7);
    reg_tmp10.y = dot_s(uniforms.f[11], reg_tmp7);
    reg_tmp10.z = dot_s(uniforms.f[12], reg_tmp7);
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    reg_tmp12.x = dot_s(uniforms.f[10], reg_tmp14);
    reg_tmp12.y = dot_s(uniforms.f[11], reg_tmp14);
    reg_tmp12.z = dot_s(uniforms.f[12], reg_tmp14);
    return false;
}
bool sub_212_213() {
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
// reference: 40A37A2AF96B1B23, 2C776115811B5DFC
// program: 2C776115811B5DFC, B80FA1B7F97410CD, 490CACB848ED440A
// program: 2C776115811B5DFC, B80FA1B7F97410CD, 0AC00F84117E7EFC
// shader: 8B31, 36FBAA27E5920598

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;
out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define mul_3(x, y) mix(x * y, vec3(0.0), isnan(x * y))
#define fma_s(x, y, z) (mul_s(x, y) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(mul_3(x, y), vec3(1.0))

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_19();
bool sub_19_29();
bool sub_29_51();
bool sub_51_65();
bool sub_65_116();
bool sub_88_92();
bool sub_114_115();
bool sub_116_156();
bool sub_133_137();
bool sub_154_155();
bool sub_156_183();
bool sub_158_163();
bool sub_163_182();
bool sub_166_172();
bool sub_172_181();
bool sub_173_177();
bool sub_177_180();
bool sub_183_207();
bool sub_185_189();
bool sub_189_206();
bool sub_190_204();
bool sub_193_200();
bool sub_200_203();
bool sub_204_205();
bool sub_207_223();
bool sub_209_213();
bool sub_213_222();
bool sub_214_220();
bool sub_220_221();
bool sub_223_231();
bool sub_225_226();
bool sub_226_230();
bool sub_227_228();
bool sub_228_229();
bool sub_231_238();
bool sub_238_244();
bool sub_244_288();
bool sub_264_270();
bool sub_271_278();
bool sub_279_287();
bool sub_288_4096();
bool sub_289_291();
bool sub_291_293();
bool sub_294_296();
bool sub_296_298();

bool exec_shader() {
    sub_288_4096();
    return true;
}

bool sub_0_19() {
    uint jmp_to = 0u;
    while (true) {
        switch (jmp_to) {
        case 0u: {
            reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
            reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
            reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
            reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
            reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
            reg_tmp6.x = rsq_s(reg_tmp6.x);
            reg_tmp7.x = rsq_s(reg_tmp7.x);
            reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            reg_tmp0 = uniforms.f[93].yxxx;
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            reg_tmp4 = mul_s(uniforms.f[94].xxxx, reg_tmp4);
            conditional_code = greaterThanEqual(uniforms.f[93].xx, reg_tmp4.xx);
            reg_tmp4 = vec4(rsq_s(reg_tmp4.x));
            reg_tmp5 = mul_s(uniforms.f[94].xxxx, reg_tmp14);
            if (conditional_code.x) {
                { jmp_to = 18u; break; }
            }
            reg_tmp0.z = rcp_s(reg_tmp4.x);
            reg_tmp0.xy = (mul_s(reg_tmp5, reg_tmp4)).xy;
        }
        case 18u: {
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_19_29() {
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    reg_tmp4.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_29_51() {
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    reg_tmp3.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp3.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp3.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp12);
    reg_tmp3.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp13.xyz);
    reg_tmp3.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp13.xyz);
    reg_tmp3.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp13.xyz);
    reg_tmp11 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp11);
    reg_tmp3.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp5.xyz);
    reg_tmp3.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp5.xyz);
    reg_tmp3.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp5.xyz);
    reg_tmp9 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp9);
    reg_tmp3.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp6.xyz);
    reg_tmp3.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp6.xyz);
    reg_tmp3.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp6.xyz);
    reg_tmp8 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp8);
    return false;
}
bool sub_51_65() {
    reg_tmp0.xyz = (mul_s(reg_tmp9.yzxx, reg_tmp8.zxyy)).xyz;
    reg_tmp0.xyz = (fma_s(-reg_tmp8.yzxx, reg_tmp9.zxyy, reg_tmp0)).xyz;
    reg_tmp1 = uniforms.f[83];
    reg_tmp2.x = dot_s(reg_tmp1.xyzz, reg_tmp1.xyzz);
    reg_tmp2.x = rsq_s(reg_tmp2.x);
    reg_tmp2.xyz = (mul_s(reg_tmp1.xyzz, reg_tmp2.xxxx)).xyz;
    reg_tmp1.x = dot_3(reg_tmp2.xyz, reg_tmp8.xyz);
    reg_tmp1.y = dot_3(reg_tmp2.xyz, reg_tmp0.xyz);
    reg_tmp1.z = dot_3(reg_tmp2.xyz, reg_tmp9.xyz);
    reg_tmp2.x = dot_s(reg_tmp1.xyzz, reg_tmp1.xyzz);
    reg_tmp2.x = rsq_s(reg_tmp2.x);
    reg_tmp2.xyz = (mul_s(reg_tmp1.xyzz, reg_tmp2.xxxx)).xyz;
    reg_tmp2.w = (uniforms.f[93].yyyy).w;
    vs_out_attr2 = reg_tmp2;
    return false;
}
bool sub_65_116() {
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    reg_tmp13.xyz = (vs_in_reg2).xyz;
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    reg_tmp5 = uniforms.f[93].xxyy;
    reg_tmp6 = uniforms.f[93].yxxy;
    reg_tmp7 = uniforms.f[93].xxxx;
    reg_tmp12 = uniforms.f[93].xxxx;
    reg_tmp11 = uniforms.f[93].xxxx;
    reg_tmp9 = uniforms.f[93].xxxx;
    reg_tmp8 = uniforms.f[93].xxxx;
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    {
        sub_29_51();
    }
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    {
        sub_29_51();
    }
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    if (conditional_code.x) {
        sub_29_51();
    }
    if (uniforms.b[11]) {
        sub_88_92();
    }
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    reg_tmp10 = reg_tmp7;
    reg_tmp13.x = dot_3(uniforms.f[90].xyz, reg_tmp11.xyz);
    reg_tmp13.y = dot_3(uniforms.f[91].xyz, reg_tmp11.xyz);
    reg_tmp13.z = dot_3(uniforms.f[92].xyz, reg_tmp11.xyz);
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    {
        sub_51_65();
    }
    vs_out_attr1 = uniforms.f[93].xxxy;
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    if (all(conditional_code)) {
        sub_114_115();
    }
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_88_92() {
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    if (conditional_code.y) {
        sub_29_51();
    }
    return false;
}
bool sub_114_115() {
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_116_156() {
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    reg_tmp7 = uniforms.f[93].xxxx;
    reg_tmp12 = uniforms.f[93].xxxx;
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    {
        sub_19_29();
    }
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    {
        sub_19_29();
    }
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    if (conditional_code.x) {
        sub_19_29();
    }
    if (uniforms.b[11]) {
        sub_133_137();
    }
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    reg_tmp10 = reg_tmp7;
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    {
        sub_0_19();
    }
    vs_out_attr2 = -reg_tmp15;
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    if (all(conditional_code)) {
        sub_154_155();
    }
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_133_137() {
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    if (conditional_code.y) {
        sub_19_29();
    }
    return false;
}
bool sub_154_155() {
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_156_183() {
    reg_tmp0.xy = (uniforms.f[0].xxxx).xy;
    if (uniforms.b[2]) {
        sub_158_163();
    } else {
        sub_163_182();
    }
    return false;
}
bool sub_158_163() {
    {
        sub_223_231();
    }
    reg_tmp3.x = dot_s(uniforms.f[1].xywz, reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2].xywz, reg_tmp6);
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_163_182() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_166_172();
    } else {
        sub_172_181();
    }
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_166_172() {
    reg_tmp6 = reg_tmp10;
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    reg_tmp3.z = dot_s(uniforms.f[3], reg_tmp6);
    reg_tmp0.xy = (mul_s(uniforms.f[9].xyyy, reg_tmp3.zzzz)).xy;
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_172_181() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_173_177();
    } else {
        sub_177_180();
    }
    return false;
}
bool sub_173_177() {
    {
        sub_231_238();
    }
    reg_tmp3.x = dot_3(uniforms.f[1].xyz, reg_tmp6.xyz);
    reg_tmp3.y = dot_3(uniforms.f[2].xyz, reg_tmp6.xyz);
    reg_tmp3.z = dot_3(uniforms.f[3].xyz, reg_tmp6.xyz);
    return false;
}
bool sub_177_180() {
    {
        sub_238_244();
    }
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    return false;
}
bool sub_183_207() {
    reg_tmp0.xy = (uniforms.f[0].yyyy).xy;
    if (uniforms.b[3]) {
        sub_185_189();
    } else {
        sub_189_206();
    }
    return false;
}
bool sub_185_189() {
    {
        sub_223_231();
    }
    reg_tmp4.x = dot_s(uniforms.f[4].xywz, reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5].xywz, reg_tmp6);
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_189_206() {
    if (uniforms.b[5]) {
        sub_190_204();
    } else {
        sub_204_205();
    }
    return false;
}
bool sub_190_204() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_193_200();
    } else {
        sub_200_203();
    }
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_193_200() {
    reg_tmp6 = reg_tmp10;
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    reg_tmp4.z = dot_s(uniforms.f[6], reg_tmp6);
    reg_tmp6.w = rcp_s(reg_tmp4.z);
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    reg_tmp4.xy = (uniforms.f[9].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_200_203() {
    {
        sub_238_244();
    }
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    return false;
}
bool sub_204_205() {
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_207_223() {
    reg_tmp0.xy = (uniforms.f[0].zzzz).xy;
    if (uniforms.b[4]) {
        sub_209_213();
    } else {
        sub_213_222();
    }
    return false;
}
bool sub_209_213() {
    {
        sub_223_231();
    }
    reg_tmp5.x = dot_s(uniforms.f[7].xywz, reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8].xywz, reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_213_222() {
    if (uniforms.b[6]) {
        sub_214_220();
    } else {
        sub_220_221();
    }
    return false;
}
bool sub_214_220() {
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    {
        sub_238_244();
    }
    reg_tmp5.x = dot_s(uniforms.f[7], reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8], reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_220_221() {
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
bool sub_223_231() {
    conditional_code = equal(uniforms.f[93].yz, reg_tmp0.xy);
    if (all(not(conditional_code))) {
        sub_225_226();
    } else {
        sub_226_230();
    }
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_225_226() {
    reg_tmp6.xy = (vs_in_reg4.xyyy).xy;
    return false;
}
bool sub_226_230() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_227_228();
    } else {
        sub_228_229();
    }
    return false;
}
bool sub_227_228() {
    reg_tmp6.xy = (vs_in_reg5.xyyy).xy;
    return false;
}
bool sub_228_229() {
    reg_tmp6.xy = (vs_in_reg6.xyyy).xy;
    return false;
}
bool sub_231_238() {
    reg_tmp2 = -reg_tmp15;
    reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
    reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_238_244() {
    reg_tmp1 = reg_tmp14;
    reg_tmp2.w = dot_3(reg_tmp1.xyz, reg_tmp1.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp1 = mul_s(reg_tmp1, reg_tmp2.wwww);
    reg_tmp1 = mul_s(uniforms.f[94].xxxx, reg_tmp1);
    reg_tmp6.xy = (uniforms.f[94].xxxx + reg_tmp1.xyyy).xy;
    return false;
}
bool sub_244_288() {
    reg_tmp1.xyz = (uniforms.f[93].xxyx).xyz;
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    reg_tmp14.w = (uniforms.f[93].xxxx).w;
    reg_tmp8 = reg_tmp14;
    reg_tmp14.x = dot_s(reg_tmp8, reg_tmp8);
    reg_tmp14.x = rsq_s(reg_tmp14.x);
    reg_tmp14 = mul_s(reg_tmp8, reg_tmp14.xxxx);
    reg_tmp8 = uniforms.f[83];
    reg_tmp6.x = dot_3(uniforms.f[90].xyz, reg_tmp8.xyz);
    reg_tmp6.y = dot_3(uniforms.f[91].xyz, reg_tmp8.xyz);
    reg_tmp6.z = dot_3(uniforms.f[92].xyz, reg_tmp8.xyz);
    reg_tmp8.xyz = (reg_tmp6.xyzz + reg_tmp1.xyzz).xyz;
    reg_tmp8.w = (uniforms.f[93].xxxx).w;
    reg_tmp0.x = dot_s(reg_tmp8, reg_tmp8);
    reg_tmp0.x = rsq_s(reg_tmp0.x);
    reg_tmp0 = mul_s(reg_tmp8, reg_tmp0.xxxx);
    reg_tmp2 = uniforms.f[93].xxxx;
    if (uniforms.b[9]) {
        sub_264_270();
    }
    if (uniforms.b[7]) {
        sub_271_278();
    }
    if (uniforms.b[8]) {
        sub_279_287();
    }
    vs_out_attr3 = reg_tmp2;
    return false;
}
bool sub_264_270() {
    reg_tmp8.x = dot_3(reg_tmp14.xyz, -reg_tmp6.xyz);
    reg_tmp8.y = dot_3(reg_tmp1.xyz, -reg_tmp6.xyz);
    reg_tmp8 = max(uniforms.f[93].xxxx, reg_tmp8);
    reg_tmp8.y = (mul_s(uniforms.f[94].xxxx, reg_tmp8.yyyy)).y;
    reg_tmp8.y = (uniforms.f[94].xxxx + reg_tmp8.yyyy).y;
    reg_tmp2.y = (mul_s(reg_tmp8.xxxx, reg_tmp8.yyyy)).y;
    return false;
}
bool sub_271_278() {
    reg_tmp9.z = dot_3(reg_tmp14.xyz, reg_tmp0.xyz);
    reg_tmp9.z = (max(uniforms.f[93].xxxx, reg_tmp9.zzzz)).z;
    reg_tmp9.z = (min(uniforms.f[93].yyyy, reg_tmp9.zzzz)).z;
    reg_tmp9.z = log2(reg_tmp9.z);
    reg_tmp9.z = (mul_s(uniforms.f[82].zzzz, reg_tmp9.zzzz)).z;
    reg_tmp9.z = exp2(reg_tmp9.z);
    reg_tmp2.z = (mul_s(uniforms.f[82].wwww, reg_tmp9.zzzz)).z;
    return false;
}
bool sub_279_287() {
    reg_tmp9.x = dot_3(reg_tmp14.xyz, reg_tmp1.xyz);
    reg_tmp9.x = (max(uniforms.f[93].xxxx, reg_tmp9.xxxx)).x;
    reg_tmp9.x = (min(uniforms.f[93].yyyy, reg_tmp9.xxxx)).x;
    reg_tmp9.x = (uniforms.f[93].yyyy + -reg_tmp9.xxxx).x;
    reg_tmp9.x = log2(reg_tmp9.x);
    reg_tmp9.x = (mul_s(uniforms.f[82].xxxx, reg_tmp9.xxxx)).x;
    reg_tmp9.x = exp2(reg_tmp9.x);
    reg_tmp2.w = (mul_s(uniforms.f[82].yyyy, reg_tmp9.xxxx)).w;
    return false;
}
bool sub_288_4096() {
    if (uniforms.b[10]) {
        sub_289_291();
    } else {
        sub_291_293();
    }
    if (uniforms.b[1]) {
        sub_294_296();
    } else {
        sub_296_298();
    }
    {
        sub_156_183();
    }
    {
        sub_183_207();
    }
    {
        sub_207_223();
    }
    return true;
}
bool sub_289_291() {
    {
        sub_65_116();
    }
    return false;
}
bool sub_291_293() {
    {
        sub_116_156();
    }
    return false;
}
bool sub_294_296() {
    {
        sub_244_288();
    }
    return false;
}
bool sub_296_298() {
    vs_out_attr3 = uniforms.f[93].yyyy;
    return false;
}
// reference: 7189F77335886AA8, 36FBAA27E5920598
// program: 36FBAA27E5920598, B80FA1B7F97410CD, 9D0535C6802495CB
// reference: 3FDD083382FD3EDC, 36FBAA27E5920598
// shader: 8B30, 429F87F8D3AE0B36

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = 2.0 * (texcolor2).rgb - 1.0;
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(normal, normalize(view))));
refl_value.g = (lut_scale_rg * LookupLightingLUTSigned(5, dot(normal, normalize(view))));
refl_value.b = (lut_scale_rb * LookupLightingLUTSigned(4, dot(normal, normalize(view))));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((secondary_fragment_color.r) * (1.0 - const_color[0].a) + (secondary_fragment_color.b) * (1.0 - (1.0 - const_color[0].a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (texcolor0.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((secondary_fragment_color.ggg) * (const_color[2].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((rounded_primary_color.aaa) * (const_color[3].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = (texcolor1.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: FE0F5D31E87D96D8, 429F87F8D3AE0B36
// program: 36FBAA27E5920598, B80FA1B7F97410CD, 429F87F8D3AE0B36
// shader: 8B30, 40BF4FB85B0B5330

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = 2.0 * (texcolor2).rgb - 1.0;
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(normal, normalize(view))));
refl_value.g = (lut_scale_rg * LookupLightingLUTSigned(5, dot(normal, normalize(view))));
refl_value.b = (lut_scale_rb * LookupLightingLUTSigned(4, dot(normal, normalize(view))));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((secondary_fragment_color.r) * (1.0 - const_color[0].a) + (secondary_fragment_color.b) * (1.0 - (1.0 - const_color[0].a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (texcolor0.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((secondary_fragment_color.ggg) * (const_color[2].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor2.a) * (const_color[2].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_3 = byteround(clamp((texcolor1.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((rounded_primary_color.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((rounded_primary_color.aaa) * (const_color[4].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp(min((combiner_buffer.aaa) + (const_color[5].rgb), vec3(1.0)) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: B83DE5C9FA1DA930, 40BF4FB85B0B5330
// program: 36FBAA27E5920598, B80FA1B7F97410CD, 40BF4FB85B0B5330
// shader: 8B30, EE82356499D9033F

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = 2.0 * (texcolor2).rgb - 1.0;
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(normal, normalize(view))));
refl_value.g = (lut_scale_rg * LookupLightingLUTSigned(5, dot(normal, normalize(view))));
refl_value.b = (lut_scale_rb * LookupLightingLUTSigned(4, dot(normal, normalize(view))));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((secondary_fragment_color.r) * (1.0 - const_color[0].a) + (secondary_fragment_color.b) * (1.0 - (1.0 - const_color[0].a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (texcolor0.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((secondary_fragment_color.ggg) * (last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((rounded_primary_color.g) * (const_color[2].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (texcolor1.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.aaa) * (const_color[4].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 4B64D36FDA37B8DB, EE82356499D9033F
// program: 36FBAA27E5920598, B80FA1B7F97410CD, EE82356499D9033F
// shader: 8B30, 5F16273C5032C0B2

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = 2.0 * (texcolor2).rgb - 1.0;
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(normal, normalize(view))));
refl_value.g = (lut_scale_rg * LookupLightingLUTSigned(5, dot(normal, normalize(view))));
refl_value.b = (lut_scale_rb * LookupLightingLUTSigned(4, dot(normal, normalize(view))));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((secondary_fragment_color.r) * (1.0 - const_color[0].a) + (secondary_fragment_color.b) * (1.0 - (1.0 - const_color[0].a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (texcolor0.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((secondary_fragment_color.ggg) * (last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((texcolor1.a) * (texcolor2.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 025F771450084C5D, 5F16273C5032C0B2
// program: 36FBAA27E5920598, B80FA1B7F97410CD, 5F16273C5032C0B2
// shader: 8B30, BC8FFFD904DA352D

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = 2.0 * (texcolor2).rgb - 1.0;
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(normal, normalize(view))));
refl_value.g = (lut_scale_rg * LookupLightingLUTSigned(5, dot(normal, normalize(view))));
refl_value.b = (lut_scale_rb * LookupLightingLUTSigned(4, dot(normal, normalize(view))));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((secondary_fragment_color.r) * (1.0 - const_color[0].a) + (secondary_fragment_color.b) * (1.0 - (1.0 - const_color[0].a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (texcolor0.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((secondary_fragment_color.ggg) * (const_color[2].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((rounded_primary_color.b) + (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((texcolor1.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = (last_tex_env_out.rgb);
float alpha_output_4 = byteround(clamp((last_tex_env_out.a) + (secondary_fragment_color.g), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 6122AFA083698865, BC8FFFD904DA352D
// program: 36FBAA27E5920598, B80FA1B7F97410CD, BC8FFFD904DA352D
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, 6A08A79BE3FAC39D
// reference: AA13BDCB351842C0, 01B0CF4127F43ED8
// program: 15E048F2F07F2E01, B80FA1B7F97410CD, 10AAC2A3349D1A7E
// reference: AA13BDCB70C7264C, 15E048F2F07F2E01
// shader: 8B31, 27B560CBF361F4CF

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define mul_3(x, y) mix(x * y, vec3(0.0), isnan(x * y))
#define fma_s(x, y, z) (mul_s(x, y) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(mul_3(x, y), vec3(1.0))

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_8();
bool sub_9_32();
bool sub_33_96();
bool sub_97_113();
bool sub_146_166();
bool sub_167_259();
bool sub_190_192();
bool sub_194_195();
bool sub_197_198();
bool sub_200_202();
bool sub_232_234();
bool sub_236_237();
bool sub_239_240();
bool sub_242_244();
bool sub_260_4096();
bool sub_280_281();
bool sub_281_282();

bool exec_shader() {
    sub_260_4096();
    return true;
}

bool sub_0_8() {
    address_registers.x = (ivec2(vs_in_reg0.zz)).x;
    reg_tmp10 = uniforms.f[0].xxxz;
    reg_tmp10.xy = (vs_in_reg0.xyyy).xy;
    reg_tmp11 = uniforms.f[0].xxxx;
    reg_tmp12 = uniforms.f[0].xxxx;
    reg_tmp13 = uniforms.f[0].zzzz;
    reg_tmp4 = uniforms.f[0].xxxx;
    reg_tmp5 = uniforms.f[0].xxxx;
    return false;
}
bool sub_9_32() {
    vs_out_attr0 = reg_tmp10;
    reg_tmp13 = mul_s(uniforms.f[82], reg_tmp13);
    vs_out_attr1 = reg_tmp13;
    reg_tmp11.y = (uniforms.f[0].zzzz + -reg_tmp11.yyyy).y;
    reg_tmp12.y = (uniforms.f[0].zzzz + -reg_tmp12.yyyy).y;
    reg_tmp14.y = (uniforms.f[81].wwww).y;
    reg_tmp14.x = (mul_s(uniforms.f[0].wwww, reg_tmp14.yyyy)).x;
    reg_tmp2.x = rcp_s(reg_tmp14.x);
    reg_tmp14.z = (reg_tmp2.xxxx).z;
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp11.xyyy).xy;
    reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    reg_tmp11.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp12.xyyy).xy;
    reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    reg_tmp12.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    vs_out_attr2 = reg_tmp11;
    vs_out_attr3 = reg_tmp12;
    return false;
}
bool sub_33_96() {
    reg_tmp6.xyz = (-reg_tmp0.xyzz).xyz;
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    reg_tmp7.xyz = vec3(rcp_s(uniforms.f[81].y));
    reg_tmp8.xyz = (fma_s(reg_tmp6.xyzz, reg_tmp7.xyzz, uniforms.f[0].yyyy)).xyz;
    reg_tmp7.xyz = (floor(reg_tmp8.xyzz)).xyz;
    reg_tmp6.xyz = (fma_s(reg_tmp7.xyzz, -uniforms.f[81].yyyy, reg_tmp6.xyzz)).xyz;
    reg_tmp6 = min(uniforms.f[81].xxxx, reg_tmp6);
    reg_tmp6 = max(-uniforms.f[81].xxxx, reg_tmp6);
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp6.xxxx, reg_tmp6.xxxx)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp6.xxxx)).y;
    reg_tmp4.x = (reg_tmp1.xxxx).x;
    reg_tmp5.x = (reg_tmp1.yyyy).x;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp6.yyyy, reg_tmp6.yyyy)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp6.yyyy)).y;
    reg_tmp4.y = (reg_tmp1.xxxx).y;
    reg_tmp5.y = (reg_tmp1.yyyy).y;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp6.zzzz, reg_tmp6.zzzz)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp6.zzzz)).y;
    reg_tmp4.z = (reg_tmp1.xxxx).z;
    reg_tmp5.z = (reg_tmp1.yyyy).z;
    reg_tmp2.x = (mul_s(reg_tmp4.yyyy, reg_tmp5.zzzz)).x;
    reg_tmp2.y = (mul_s(reg_tmp5.yyyy, reg_tmp5.zzzz)).y;
    reg_tmp6.x = (mul_s(reg_tmp4.yyyy, reg_tmp4.zzzz)).x;
    reg_tmp6.y = (reg_tmp5.zzzz).y;
    reg_tmp6.z = (mul_s(-reg_tmp5.yyyy, reg_tmp4.zzzz)).z;
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    reg_tmp7.x = (mul_s(-reg_tmp2.xxxx, reg_tmp4.xxxx)).x;
    reg_tmp7.x = (fma_s(reg_tmp5.yyyy, reg_tmp5.xxxx, reg_tmp7.xxxx)).x;
    reg_tmp7.y = (mul_s(reg_tmp4.zzzz, reg_tmp4.xxxx)).y;
    reg_tmp7.z = (mul_s(reg_tmp2.yyyy, reg_tmp4.xxxx)).z;
    reg_tmp7.z = (fma_s(reg_tmp4.yyyy, reg_tmp5.xxxx, reg_tmp7.zzzz)).z;
    reg_tmp7.w = (uniforms.f[0].xxxx).w;
    reg_tmp8.x = (mul_s(reg_tmp2.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp8.x = (fma_s(reg_tmp5.yyyy, reg_tmp4.xxxx, reg_tmp8.xxxx)).x;
    reg_tmp8.y = (mul_s(-reg_tmp4.zzzz, reg_tmp5.xxxx)).y;
    reg_tmp8.z = (mul_s(-reg_tmp2.yyyy, reg_tmp5.xxxx)).z;
    reg_tmp8.z = (fma_s(reg_tmp4.yyyy, reg_tmp4.xxxx, reg_tmp8.zzzz)).z;
    reg_tmp8.w = (uniforms.f[0].xxxx).w;
    reg_tmp9 = uniforms.f[0].xxxz;
    return false;
}
bool sub_97_113() {
    reg_tmp6.x = (uniforms.f[90].xxxx).x;
    reg_tmp6.y = (uniforms.f[91].xxxx).y;
    reg_tmp6.z = (uniforms.f[92].xxxx).z;
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    reg_tmp7.x = (uniforms.f[90].yyyy).x;
    reg_tmp7.y = (uniforms.f[91].yyyy).y;
    reg_tmp7.z = (uniforms.f[92].yyyy).z;
    reg_tmp7.w = (uniforms.f[0].xxxx).w;
    reg_tmp8.x = (uniforms.f[90].zzzz).x;
    reg_tmp8.y = (uniforms.f[91].zzzz).y;
    reg_tmp8.z = (uniforms.f[92].zzzz).z;
    reg_tmp8.w = (uniforms.f[0].xxxx).w;
    reg_tmp9.x = (uniforms.f[90].wwww).x;
    reg_tmp9.y = (uniforms.f[91].wwww).y;
    reg_tmp9.z = (uniforms.f[92].wwww).z;
    reg_tmp9.w = (uniforms.f[0].zzzz).w;
    return false;
}
bool sub_146_166() {
    reg_tmp2 = uniforms.f[90];
    reg_tmp3 = uniforms.f[91];
    reg_tmp4 = uniforms.f[92];
    reg_tmp5 = uniforms.f[0].xxxz;
    reg_tmp6 = mul_s(uniforms.f[86].xxxx, reg_tmp2);
    reg_tmp6 = fma_s(reg_tmp3, uniforms.f[86].yyyy, reg_tmp6);
    reg_tmp6 = fma_s(reg_tmp4, uniforms.f[86].zzzz, reg_tmp6);
    reg_tmp6 = fma_s(reg_tmp5, uniforms.f[86].wwww, reg_tmp6);
    reg_tmp7 = mul_s(uniforms.f[87].xxxx, reg_tmp2);
    reg_tmp7 = fma_s(reg_tmp3, uniforms.f[87].yyyy, reg_tmp7);
    reg_tmp7 = fma_s(reg_tmp4, uniforms.f[87].zzzz, reg_tmp7);
    reg_tmp7 = fma_s(reg_tmp5, uniforms.f[87].wwww, reg_tmp7);
    reg_tmp8 = mul_s(uniforms.f[88].xxxx, reg_tmp2);
    reg_tmp8 = fma_s(reg_tmp3, uniforms.f[88].yyyy, reg_tmp8);
    reg_tmp8 = fma_s(reg_tmp4, uniforms.f[88].zzzz, reg_tmp8);
    reg_tmp8 = fma_s(reg_tmp5, uniforms.f[88].wwww, reg_tmp8);
    reg_tmp9 = mul_s(uniforms.f[89].xxxx, reg_tmp2);
    reg_tmp9 = fma_s(reg_tmp3, uniforms.f[89].yyyy, reg_tmp9);
    reg_tmp9 = fma_s(reg_tmp4, uniforms.f[89].zzzz, reg_tmp9);
    reg_tmp9 = fma_s(reg_tmp5, uniforms.f[89].wwww, reg_tmp9);
    return false;
}
bool sub_167_259() {
    reg_tmp2.x = rcp_s(uniforms.f[81].y);
    reg_tmp2.xy = (mul_s(uniforms.f[2 + address_registers.x].zwww, reg_tmp2.xxxx)).xy;
    reg_tmp2.xy = (uniforms.f[0].yyyy + reg_tmp2.xyyy).xy;
    reg_tmp3.xy = (floor(reg_tmp2.xyyy)).xy;
    reg_tmp2.xy = (mul_s(uniforms.f[81].yyyy, reg_tmp3.xyyy)).xy;
    reg_tmp2.xy = (uniforms.f[2 + address_registers.x].zwww + -reg_tmp2.xyyy).xy;
    reg_tmp0.xy = (min(uniforms.f[81].xxxx, -reg_tmp2.xyyy)).xy;
    reg_tmp0.xy = (max(-uniforms.f[81].xxxx, reg_tmp0.xyyy)).xy;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp0.xxxx, reg_tmp0.xxxx)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.xxxx)).y;
    reg_tmp5.x = (uniforms.f[5 + address_registers.x].wwww).x;
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_190_192();
    }
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_194_195();
    }
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_197_198();
    }
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_200_202();
    }
    reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    reg_tmp4.z = (uniforms.f[83].xxxx).z;
    reg_tmp4.w = (-uniforms.f[83].yyyy).w;
    reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[3 + address_registers.x].xyyy)).xy;
    reg_tmp4.z = (-uniforms.f[3 + address_registers.x].zzzz).z;
    reg_tmp4.w = (-uniforms.f[3 + address_registers.x].wwww).w;
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    reg_tmp11.xy = (reg_tmp5.xyyy).xy;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp0.yyyy, reg_tmp0.yyyy)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.yyyy)).y;
    reg_tmp5.x = (uniforms.f[6 + address_registers.x].wwww).x;
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_232_234();
    }
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_236_237();
    }
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_239_240();
    }
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_242_244();
    }
    reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    reg_tmp4.z = (uniforms.f[83].zzzz).z;
    reg_tmp4.w = (-uniforms.f[83].wwww).w;
    reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[4 + address_registers.x].xyyy)).xy;
    reg_tmp4.z = (-uniforms.f[4 + address_registers.x].zzzz).z;
    reg_tmp4.w = (-uniforms.f[4 + address_registers.x].wwww).w;
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    reg_tmp12.xy = (reg_tmp5.xyyy).xy;
    return false;
}
bool sub_190_192() {
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_194_195() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_197_198() {
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_200_202() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_232_234() {
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_236_237() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_239_240() {
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_242_244() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_260_4096() {
    {
        sub_0_8();
    }
    reg_tmp10.xy = (uniforms.f[84].xyyy + reg_tmp10.xyyy).xy;
    reg_tmp10.xy = (mul_s(uniforms.f[2 + address_registers.x].xyyy, reg_tmp10.xyyy)).xy;
    reg_tmp0 = uniforms.f[7 + address_registers.x];
    {
        sub_33_96();
    }
    reg_tmp2.x = dot_s(reg_tmp10, reg_tmp6);
    reg_tmp2.y = dot_s(reg_tmp10, reg_tmp7);
    reg_tmp2.z = dot_s(reg_tmp10, reg_tmp8);
    reg_tmp2.w = dot_s(reg_tmp10, reg_tmp9);
    reg_tmp10 = reg_tmp2;
    {
        sub_97_113();
    }
    reg_tmp2.x = dot_s(reg_tmp10, reg_tmp6);
    reg_tmp2.y = dot_s(reg_tmp10, reg_tmp7);
    reg_tmp2.z = dot_s(reg_tmp10, reg_tmp8);
    reg_tmp2.w = dot_s(uniforms.f[0].xxxz, reg_tmp10);
    reg_tmp3.xyz = (uniforms.f[5 + address_registers.x].xyzz).xyz;
    reg_tmp3.xyz = (uniforms.f[85].xyzz + -reg_tmp3.xyzz).xyz;
    reg_tmp4.x = dot_3(reg_tmp3.xyz, reg_tmp3.xyz);
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
    if (conditional_code.x) {
        sub_280_281();
    } else {
        sub_281_282();
    }
    reg_tmp3.xyz = (mul_s(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
    reg_tmp10.xyz = (uniforms.f[5 + address_registers.x].xyzz + reg_tmp2.xyzz).xyz;
    reg_tmp10.xyz = (fma_s(reg_tmp3.xyzz, uniforms.f[84].zzzz, reg_tmp10.xyzz)).xyz;
    {
        sub_146_166();
    }
    reg_tmp2 = reg_tmp10;
    reg_tmp10.x = dot_s(reg_tmp2, reg_tmp6);
    reg_tmp10.y = dot_s(reg_tmp2, reg_tmp7);
    reg_tmp10.z = dot_s(reg_tmp2, reg_tmp8);
    reg_tmp10.w = dot_s(reg_tmp2, reg_tmp9);
    reg_tmp2 = uniforms.f[1 + address_registers.x];
    reg_tmp3 = max(uniforms.f[0].xxxx, reg_tmp2);
    reg_tmp2 = min(uniforms.f[0].zzzz, reg_tmp3);
    reg_tmp13 = reg_tmp2;
    {
        sub_167_259();
    }
    {
        sub_9_32();
    }
    return true;
}
bool sub_280_281() {
    reg_tmp4.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_281_282() {
    reg_tmp4.x = rsq_s(reg_tmp4.x);
    return false;
}
// reference: 54C62F0A3689CFFE, 27B560CBF361F4CF
// program: 27B560CBF361F4CF, 082670B4222015B2, 0D19D21B46AD8D9B
// reference: AE4BD47EFA047F79, CDD7AB422818C224
// reference: E01F2B3E4D712B0D, CDD7AB422818C224
// reference: 8C39401BE87B43FE, 01B0CF4127F43ED8
// reference: C26DBF5B90900042, 01B0CF4127F43ED8
// reference: C26DBF5B5F0E178A, 01B0CF4127F43ED8
// reference: 8C39401B429DB433, 15E048F2F07F2E01
// reference: AE4BD47E41953AAB, CDD7AB422818C224
// reference: E01F2B3EF6E06EDF, CDD7AB422818C224
// reference: A7400F44F7233B2A, C1B15B379433D4E8
// reference: 396471FD64854D40, 2BD70906436FAF24
// reference: 77308EBDD3F01934, 2BD70906436FAF24
// reference: BF7478294CB09D99, 2C776115811B5DFC
// reference: 8E5EF57035886AA8, 36FBAA27E5920598
// reference: C00A0A3082FD3EDC, 36FBAA27E5920598
// reference: AE4BD47E3881F14D, CDD7AB422818C224
// reference: E01F2B3E406AB2F1, CDD7AB422818C224
// reference: A7400F448E37F0CC, C1B15B379433D4E8
// reference: E01F2B3E8FF4A539, CDD7AB422818C224
// program: CDD7AB422818C224, 42937135801BAA7E, 29CD3EBE51FAA42A
// program: CDD7AB422818C224, 42937135801BAA7E, B2E64CFB9744D892
// program: CDD7AB422818C224, 42937135801BAA7E, 98647FD3CF93B689
// reference: A7400F444CB27EF8, C1B15B379433D4E8
// reference: 54C62F0AD9B05CBF, 27B560CBF361F4CF
// reference: E01F2B3EA248B84C, CDD7AB422818C224
// reference: C26DBF5BB03784CB, 01B0CF4127F43ED8
// program: 27B560CBF361F4CF, 082670B4222015B2, DBA0F8FE46AD8D9B
// shader: 8B31, A147DA9530FE3B39

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define mul_3(x, y) mix(x * y, vec3(0.0), isnan(x * y))
#define fma_s(x, y, z) (mul_s(x, y) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(mul_3(x, y), vec3(1.0))

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_8();
bool sub_9_32();
bool sub_97_113();
bool sub_146_166();
bool sub_167_259();
bool sub_190_192();
bool sub_194_195();
bool sub_197_198();
bool sub_200_202();
bool sub_232_234();
bool sub_236_237();
bool sub_239_240();
bool sub_242_244();
bool sub_260_4096();
bool sub_273_274();
bool sub_274_275();

bool exec_shader() {
    sub_260_4096();
    return true;
}

bool sub_0_8() {
    address_registers.x = (ivec2(vs_in_reg0.zz)).x;
    reg_tmp10 = uniforms.f[0].xxxz;
    reg_tmp10.xy = (vs_in_reg0.xyyy).xy;
    reg_tmp11 = uniforms.f[0].xxxx;
    reg_tmp12 = uniforms.f[0].xxxx;
    reg_tmp13 = uniforms.f[0].zzzz;
    reg_tmp4 = uniforms.f[0].xxxx;
    reg_tmp5 = uniforms.f[0].xxxx;
    return false;
}
bool sub_9_32() {
    vs_out_attr0 = reg_tmp10;
    reg_tmp13 = mul_s(uniforms.f[82], reg_tmp13);
    vs_out_attr1 = reg_tmp13;
    reg_tmp11.y = (uniforms.f[0].zzzz + -reg_tmp11.yyyy).y;
    reg_tmp12.y = (uniforms.f[0].zzzz + -reg_tmp12.yyyy).y;
    reg_tmp14.y = (uniforms.f[81].wwww).y;
    reg_tmp14.x = (mul_s(uniforms.f[0].wwww, reg_tmp14.yyyy)).x;
    reg_tmp2.x = rcp_s(reg_tmp14.x);
    reg_tmp14.z = (reg_tmp2.xxxx).z;
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp11.xyyy).xy;
    reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    reg_tmp11.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp12.xyyy).xy;
    reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    reg_tmp12.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    vs_out_attr2 = reg_tmp11;
    vs_out_attr3 = reg_tmp12;
    return false;
}
bool sub_97_113() {
    reg_tmp6.x = (uniforms.f[90].xxxx).x;
    reg_tmp6.y = (uniforms.f[91].xxxx).y;
    reg_tmp6.z = (uniforms.f[92].xxxx).z;
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    reg_tmp7.x = (uniforms.f[90].yyyy).x;
    reg_tmp7.y = (uniforms.f[91].yyyy).y;
    reg_tmp7.z = (uniforms.f[92].yyyy).z;
    reg_tmp7.w = (uniforms.f[0].xxxx).w;
    reg_tmp8.x = (uniforms.f[90].zzzz).x;
    reg_tmp8.y = (uniforms.f[91].zzzz).y;
    reg_tmp8.z = (uniforms.f[92].zzzz).z;
    reg_tmp8.w = (uniforms.f[0].xxxx).w;
    reg_tmp9.x = (uniforms.f[90].wwww).x;
    reg_tmp9.y = (uniforms.f[91].wwww).y;
    reg_tmp9.z = (uniforms.f[92].wwww).z;
    reg_tmp9.w = (uniforms.f[0].zzzz).w;
    return false;
}
bool sub_146_166() {
    reg_tmp2 = uniforms.f[90];
    reg_tmp3 = uniforms.f[91];
    reg_tmp4 = uniforms.f[92];
    reg_tmp5 = uniforms.f[0].xxxz;
    reg_tmp6 = mul_s(uniforms.f[86].xxxx, reg_tmp2);
    reg_tmp6 = fma_s(reg_tmp3, uniforms.f[86].yyyy, reg_tmp6);
    reg_tmp6 = fma_s(reg_tmp4, uniforms.f[86].zzzz, reg_tmp6);
    reg_tmp6 = fma_s(reg_tmp5, uniforms.f[86].wwww, reg_tmp6);
    reg_tmp7 = mul_s(uniforms.f[87].xxxx, reg_tmp2);
    reg_tmp7 = fma_s(reg_tmp3, uniforms.f[87].yyyy, reg_tmp7);
    reg_tmp7 = fma_s(reg_tmp4, uniforms.f[87].zzzz, reg_tmp7);
    reg_tmp7 = fma_s(reg_tmp5, uniforms.f[87].wwww, reg_tmp7);
    reg_tmp8 = mul_s(uniforms.f[88].xxxx, reg_tmp2);
    reg_tmp8 = fma_s(reg_tmp3, uniforms.f[88].yyyy, reg_tmp8);
    reg_tmp8 = fma_s(reg_tmp4, uniforms.f[88].zzzz, reg_tmp8);
    reg_tmp8 = fma_s(reg_tmp5, uniforms.f[88].wwww, reg_tmp8);
    reg_tmp9 = mul_s(uniforms.f[89].xxxx, reg_tmp2);
    reg_tmp9 = fma_s(reg_tmp3, uniforms.f[89].yyyy, reg_tmp9);
    reg_tmp9 = fma_s(reg_tmp4, uniforms.f[89].zzzz, reg_tmp9);
    reg_tmp9 = fma_s(reg_tmp5, uniforms.f[89].wwww, reg_tmp9);
    return false;
}
bool sub_167_259() {
    reg_tmp2.x = rcp_s(uniforms.f[81].y);
    reg_tmp2.xy = (mul_s(uniforms.f[2 + address_registers.x].zwww, reg_tmp2.xxxx)).xy;
    reg_tmp2.xy = (uniforms.f[0].yyyy + reg_tmp2.xyyy).xy;
    reg_tmp3.xy = (floor(reg_tmp2.xyyy)).xy;
    reg_tmp2.xy = (mul_s(uniforms.f[81].yyyy, reg_tmp3.xyyy)).xy;
    reg_tmp2.xy = (uniforms.f[2 + address_registers.x].zwww + -reg_tmp2.xyyy).xy;
    reg_tmp0.xy = (min(uniforms.f[81].xxxx, -reg_tmp2.xyyy)).xy;
    reg_tmp0.xy = (max(-uniforms.f[81].xxxx, reg_tmp0.xyyy)).xy;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp0.xxxx, reg_tmp0.xxxx)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.xxxx)).y;
    reg_tmp5.x = (uniforms.f[5 + address_registers.x].wwww).x;
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_190_192();
    }
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_194_195();
    }
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_197_198();
    }
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_200_202();
    }
    reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    reg_tmp4.z = (uniforms.f[83].xxxx).z;
    reg_tmp4.w = (-uniforms.f[83].yyyy).w;
    reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[3 + address_registers.x].xyyy)).xy;
    reg_tmp4.z = (-uniforms.f[3 + address_registers.x].zzzz).z;
    reg_tmp4.w = (-uniforms.f[3 + address_registers.x].wwww).w;
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    reg_tmp11.xy = (reg_tmp5.xyyy).xy;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp0.yyyy, reg_tmp0.yyyy)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.yyyy)).y;
    reg_tmp5.x = (uniforms.f[6 + address_registers.x].wwww).x;
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_232_234();
    }
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_236_237();
    }
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_239_240();
    }
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_242_244();
    }
    reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    reg_tmp4.z = (uniforms.f[83].zzzz).z;
    reg_tmp4.w = (-uniforms.f[83].wwww).w;
    reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[4 + address_registers.x].xyyy)).xy;
    reg_tmp4.z = (-uniforms.f[4 + address_registers.x].zzzz).z;
    reg_tmp4.w = (-uniforms.f[4 + address_registers.x].wwww).w;
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    reg_tmp12.xy = (reg_tmp5.xyyy).xy;
    return false;
}
bool sub_190_192() {
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_194_195() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_197_198() {
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_200_202() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_232_234() {
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_236_237() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_239_240() {
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_242_244() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_260_4096() {
    {
        sub_0_8();
    }
    reg_tmp10.xy = (uniforms.f[84].xyyy + reg_tmp10.xyyy).xy;
    reg_tmp10.xy = (mul_s(uniforms.f[2 + address_registers.x].xyyy, reg_tmp10.xyyy)).xy;
    {
        sub_97_113();
    }
    reg_tmp2.x = dot_s(reg_tmp10, reg_tmp6);
    reg_tmp2.y = dot_s(reg_tmp10, reg_tmp7);
    reg_tmp2.z = dot_s(reg_tmp10, reg_tmp8);
    reg_tmp2.w = dot_s(uniforms.f[0].xxxz, reg_tmp10);
    reg_tmp3.xyz = (uniforms.f[5 + address_registers.x].xyzz).xyz;
    reg_tmp3.xyz = (uniforms.f[85].xyzz + -reg_tmp3.xyzz).xyz;
    reg_tmp4.x = dot_3(reg_tmp3.xyz, reg_tmp3.xyz);
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
    if (conditional_code.x) {
        sub_273_274();
    } else {
        sub_274_275();
    }
    reg_tmp3.xyz = (mul_s(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
    reg_tmp10.xyz = (uniforms.f[5 + address_registers.x].xyzz + reg_tmp2.xyzz).xyz;
    reg_tmp10.xyz = (fma_s(reg_tmp3.xyzz, uniforms.f[84].zzzz, reg_tmp10.xyzz)).xyz;
    {
        sub_146_166();
    }
    reg_tmp2 = reg_tmp10;
    reg_tmp10.x = dot_s(reg_tmp2, reg_tmp6);
    reg_tmp10.y = dot_s(reg_tmp2, reg_tmp7);
    reg_tmp10.z = dot_s(reg_tmp2, reg_tmp8);
    reg_tmp10.w = dot_s(reg_tmp2, reg_tmp9);
    reg_tmp2 = uniforms.f[1 + address_registers.x];
    reg_tmp3 = max(uniforms.f[0].xxxx, reg_tmp2);
    reg_tmp2 = min(uniforms.f[0].zzzz, reg_tmp3);
    reg_tmp13 = reg_tmp2;
    {
        sub_167_259();
    }
    {
        sub_9_32();
    }
    return true;
}
bool sub_273_274() {
    reg_tmp4.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_274_275() {
    reg_tmp4.x = rsq_s(reg_tmp4.x);
    return false;
}
// reference: 9A2ECF1DDF8D6890, A147DA9530FE3B39
// program: A147DA9530FE3B39, 082670B4222015B2, DBA0F8FE46AD8D9B
// program: A147DA9530FE3B39, 082670B4222015B2, F4A415D97E9B6ED6
// program: CDD7AB422818C224, 42937135801BAA7E, AB0D786CFAD777F8
// reference: 58970D47DE7CA790, C1B15B379433D4E8
// shader: 8B31, A16B0AB362B8E38B

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;
out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define mul_3(x, y) mix(x * y, vec3(0.0), isnan(x * y))
#define fma_s(x, y, z) (mul_s(x, y) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(mul_3(x, y), vec3(1.0))

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_19();
bool sub_19_29();
bool sub_29_79();
bool sub_34_52();
bool sub_52_60();
bool sub_77_78();
bool sub_79_106();
bool sub_81_86();
bool sub_86_105();
bool sub_89_95();
bool sub_95_104();
bool sub_96_100();
bool sub_100_103();
bool sub_106_130();
bool sub_108_112();
bool sub_112_129();
bool sub_113_127();
bool sub_116_123();
bool sub_123_126();
bool sub_127_128();
bool sub_130_146();
bool sub_132_136();
bool sub_136_145();
bool sub_137_143();
bool sub_143_144();
bool sub_146_154();
bool sub_148_149();
bool sub_149_153();
bool sub_150_151();
bool sub_151_152();
bool sub_154_161();
bool sub_161_167();
bool sub_167_4096();

bool exec_shader() {
    sub_167_4096();
    return true;
}

bool sub_0_19() {
    uint jmp_to = 0u;
    while (true) {
        switch (jmp_to) {
        case 0u: {
            reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
            reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
            reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
            reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
            reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
            reg_tmp6.x = rsq_s(reg_tmp6.x);
            reg_tmp7.x = rsq_s(reg_tmp7.x);
            reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            reg_tmp0 = uniforms.f[93].yxxx;
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            reg_tmp4 = mul_s(uniforms.f[94].xxxx, reg_tmp4);
            conditional_code = greaterThanEqual(uniforms.f[93].xx, reg_tmp4.xx);
            reg_tmp4 = vec4(rsq_s(reg_tmp4.x));
            reg_tmp5 = mul_s(uniforms.f[94].xxxx, reg_tmp14);
            if (conditional_code.x) {
                { jmp_to = 18u; break; }
            }
            reg_tmp0.z = rcp_s(reg_tmp4.x);
            reg_tmp0.xy = (mul_s(reg_tmp5, reg_tmp4)).xy;
        }
        case 18u: {
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_19_29() {
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    reg_tmp4.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_29_79() {
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    reg_tmp13.xyz = (vs_in_reg2).xyz;
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    if (uniforms.b[0]) {
        sub_34_52();
    } else {
        sub_52_60();
    }
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    {
        sub_0_19();
    }
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    vs_out_attr2 = -reg_tmp15;
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    if (all(conditional_code)) {
        sub_77_78();
    }
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_34_52() {
    reg_tmp7 = uniforms.f[93].xxxx;
    reg_tmp12 = uniforms.f[93].xxxx;
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    {
        sub_19_29();
    }
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    {
        sub_19_29();
    }
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    {
        sub_19_29();
    }
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    {
        sub_19_29();
    }
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    reg_tmp10 = reg_tmp7;
    return false;
}
bool sub_52_60() {
    reg_tmp7 = reg_tmp15;
    reg_tmp10.x = dot_s(uniforms.f[10], reg_tmp7);
    reg_tmp10.y = dot_s(uniforms.f[11], reg_tmp7);
    reg_tmp10.z = dot_s(uniforms.f[12], reg_tmp7);
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    reg_tmp12.x = dot_3(uniforms.f[10].xyz, reg_tmp14.xyz);
    reg_tmp12.y = dot_3(uniforms.f[11].xyz, reg_tmp14.xyz);
    reg_tmp12.z = dot_3(uniforms.f[12].xyz, reg_tmp14.xyz);
    return false;
}
bool sub_77_78() {
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_79_106() {
    reg_tmp0.xy = (uniforms.f[0].xxxx).xy;
    if (uniforms.b[2]) {
        sub_81_86();
    } else {
        sub_86_105();
    }
    return false;
}
bool sub_81_86() {
    {
        sub_146_154();
    }
    reg_tmp3.x = dot_s(uniforms.f[1].xywz, reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2].xywz, reg_tmp6);
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_86_105() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_89_95();
    } else {
        sub_95_104();
    }
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_89_95() {
    reg_tmp6 = reg_tmp10;
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    reg_tmp3.z = dot_s(uniforms.f[3], reg_tmp6);
    reg_tmp0.xy = (mul_s(uniforms.f[9].xyyy, reg_tmp3.zzzz)).xy;
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_95_104() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_96_100();
    } else {
        sub_100_103();
    }
    return false;
}
bool sub_96_100() {
    {
        sub_154_161();
    }
    reg_tmp3.x = dot_3(uniforms.f[1].xyz, reg_tmp6.xyz);
    reg_tmp3.y = dot_3(uniforms.f[2].xyz, reg_tmp6.xyz);
    reg_tmp3.z = dot_3(uniforms.f[3].xyz, reg_tmp6.xyz);
    return false;
}
bool sub_100_103() {
    {
        sub_161_167();
    }
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    return false;
}
bool sub_106_130() {
    reg_tmp0.xy = (uniforms.f[0].yyyy).xy;
    if (uniforms.b[3]) {
        sub_108_112();
    } else {
        sub_112_129();
    }
    return false;
}
bool sub_108_112() {
    {
        sub_146_154();
    }
    reg_tmp4.x = dot_s(uniforms.f[4].xywz, reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5].xywz, reg_tmp6);
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_112_129() {
    if (uniforms.b[5]) {
        sub_113_127();
    } else {
        sub_127_128();
    }
    return false;
}
bool sub_113_127() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_116_123();
    } else {
        sub_123_126();
    }
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_116_123() {
    reg_tmp6 = reg_tmp10;
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    reg_tmp4.z = dot_s(uniforms.f[6], reg_tmp6);
    reg_tmp6.w = rcp_s(reg_tmp4.z);
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    reg_tmp4.xy = (uniforms.f[9].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_123_126() {
    {
        sub_161_167();
    }
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    return false;
}
bool sub_127_128() {
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_130_146() {
    reg_tmp0.xy = (uniforms.f[0].zzzz).xy;
    if (uniforms.b[4]) {
        sub_132_136();
    } else {
        sub_136_145();
    }
    return false;
}
bool sub_132_136() {
    {
        sub_146_154();
    }
    reg_tmp5.x = dot_s(uniforms.f[7].xywz, reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8].xywz, reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_136_145() {
    if (uniforms.b[6]) {
        sub_137_143();
    } else {
        sub_143_144();
    }
    return false;
}
bool sub_137_143() {
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    {
        sub_161_167();
    }
    reg_tmp5.x = dot_s(uniforms.f[7], reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8], reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_143_144() {
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
bool sub_146_154() {
    conditional_code = equal(uniforms.f[93].yz, reg_tmp0.xy);
    if (all(not(conditional_code))) {
        sub_148_149();
    } else {
        sub_149_153();
    }
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_148_149() {
    reg_tmp6.xy = (vs_in_reg4.xyyy).xy;
    return false;
}
bool sub_149_153() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_150_151();
    } else {
        sub_151_152();
    }
    return false;
}
bool sub_150_151() {
    reg_tmp6.xy = (vs_in_reg5.xyyy).xy;
    return false;
}
bool sub_151_152() {
    reg_tmp6.xy = (vs_in_reg6.xyyy).xy;
    return false;
}
bool sub_154_161() {
    reg_tmp2 = -reg_tmp15;
    reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
    reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_161_167() {
    reg_tmp1 = reg_tmp14;
    reg_tmp2.w = dot_3(reg_tmp1.xyz, reg_tmp1.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp1 = mul_s(reg_tmp1, reg_tmp2.wwww);
    reg_tmp1 = mul_s(uniforms.f[94].xxxx, reg_tmp1);
    reg_tmp6.xy = (uniforms.f[94].xxxx + reg_tmp1.xyyy).xy;
    return false;
}
bool sub_167_4096() {
    {
        sub_29_79();
    }
    reg_tmp2 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
    reg_tmp1.xyz = (uniforms.f[93].xxyx).xyz;
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    reg_tmp14.w = (uniforms.f[93].xxxx).w;
    reg_tmp8 = reg_tmp14;
    reg_tmp14.x = dot_s(reg_tmp8, reg_tmp8);
    reg_tmp14.x = rsq_s(reg_tmp14.x);
    reg_tmp14 = mul_s(reg_tmp8, reg_tmp14.xxxx);
    reg_tmp9.x = dot_3(reg_tmp14.xyz, reg_tmp1.xyz);
    reg_tmp9.x = (max(uniforms.f[93].xxxx, reg_tmp9.xxxx)).x;
    reg_tmp9.x = (min(uniforms.f[93].yyyy, reg_tmp9.xxxx)).x;
    reg_tmp9.x = (uniforms.f[93].yyyy + -reg_tmp9.xxxx).x;
    reg_tmp9.x = log2(reg_tmp9.x);
    reg_tmp9.x = (mul_s(uniforms.f[82].xxxx, reg_tmp9.xxxx)).x;
    reg_tmp9.x = exp2(reg_tmp9.x);
    reg_tmp2.w = (mul_s(uniforms.f[82].yyyy, reg_tmp9.xxxx)).w;
    vs_out_attr3 = reg_tmp2;
    {
        sub_79_106();
    }
    {
        sub_106_130();
    }
    {
        sub_130_146();
    }
    return true;
}
// reference: 36C80D5203C7298A, A16B0AB362B8E38B
// program: A16B0AB362B8E38B, B80FA1B7F97410CD, B3C2F6056AADCF6F
// reference: 789CF212B4B27DFE, A16B0AB362B8E38B
// reference: 9790BAAFAB574EAD, A16B0AB362B8E38B
// program: A16B0AB362B8E38B, B80FA1B7F97410CD, A36D1D6BA424DB28
// reference: D9C445EF1C221AD9, A16B0AB362B8E38B
// program: A16B0AB362B8E38B, B80FA1B7F97410CD, 641FDB3E9E36B758
// reference: 1A92D04ABD15C4B1, 27B560CBF361F4CF
// program: 27B560CBF361F4CF, 082670B4222015B2, 1430EF96EBF7840F
// reference: 54C62F0AE5590384, 27B560CBF361F4CF
// reference: 9A2ECF1DE36437AB, A147DA9530FE3B39
// program: 27B560CBF361F4CF, 082670B4222015B2, 63A5270519B4AE20
// reference: D47A305DBB28F09E, A147DA9530FE3B39
// reference: D47A305DB2C0909B, A147DA9530FE3B39
// reference: 9A2ECF1DEA8C57AE, A147DA9530FE3B39
// program: CDD7AB422818C224, 42937135801BAA7E, 49F399BDFAD777F8
// program: CDD7AB422818C224, 42937135801BAA7E, 00F9BB7ACF93B689
// shader: 8B31, 0C474BA5D3CDF544

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;
out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define mul_3(x, y) mix(x * y, vec3(0.0), isnan(x * y))
#define fma_s(x, y, z) (mul_s(x, y) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(mul_3(x, y), vec3(1.0))

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_19();
bool sub_19_29();
bool sub_29_76();
bool sub_33_51();
bool sub_51_59();
bool sub_74_75();
bool sub_76_103();
bool sub_78_83();
bool sub_83_102();
bool sub_86_92();
bool sub_92_101();
bool sub_93_97();
bool sub_97_100();
bool sub_103_127();
bool sub_105_109();
bool sub_109_126();
bool sub_110_124();
bool sub_113_120();
bool sub_120_123();
bool sub_124_125();
bool sub_127_143();
bool sub_129_133();
bool sub_133_142();
bool sub_134_140();
bool sub_140_141();
bool sub_143_151();
bool sub_145_146();
bool sub_146_150();
bool sub_147_148();
bool sub_148_149();
bool sub_151_158();
bool sub_158_164();
bool sub_164_4096();
bool sub_166_173();
bool sub_173_174();

bool exec_shader() {
    sub_164_4096();
    return true;
}

bool sub_0_19() {
    uint jmp_to = 0u;
    while (true) {
        switch (jmp_to) {
        case 0u: {
            reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
            reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
            reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
            reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
            reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
            reg_tmp6.x = rsq_s(reg_tmp6.x);
            reg_tmp7.x = rsq_s(reg_tmp7.x);
            reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            reg_tmp0 = uniforms.f[93].yxxx;
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            reg_tmp4 = mul_s(uniforms.f[94].xxxx, reg_tmp4);
            conditional_code = greaterThanEqual(uniforms.f[93].xx, reg_tmp4.xx);
            reg_tmp4 = vec4(rsq_s(reg_tmp4.x));
            reg_tmp5 = mul_s(uniforms.f[94].xxxx, reg_tmp14);
            if (conditional_code.x) {
                { jmp_to = 18u; break; }
            }
            reg_tmp0.z = rcp_s(reg_tmp4.x);
            reg_tmp0.xy = (mul_s(reg_tmp5, reg_tmp4)).xy;
        }
        case 18u: {
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_19_29() {
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    reg_tmp4.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_29_76() {
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    if (uniforms.b[0]) {
        sub_33_51();
    } else {
        sub_51_59();
    }
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    {
        sub_0_19();
    }
    vs_out_attr2 = reg_tmp15;
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    if (all(conditional_code)) {
        sub_74_75();
    }
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_33_51() {
    reg_tmp7 = uniforms.f[93].xxxx;
    reg_tmp12 = uniforms.f[93].xxxx;
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    {
        sub_19_29();
    }
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    {
        sub_19_29();
    }
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    {
        sub_19_29();
    }
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    {
        sub_19_29();
    }
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    reg_tmp10 = reg_tmp7;
    return false;
}
bool sub_51_59() {
    reg_tmp7 = reg_tmp15;
    reg_tmp10.x = dot_s(uniforms.f[10], reg_tmp7);
    reg_tmp10.y = dot_s(uniforms.f[11], reg_tmp7);
    reg_tmp10.z = dot_s(uniforms.f[12], reg_tmp7);
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    reg_tmp12.x = dot_3(uniforms.f[10].xyz, reg_tmp14.xyz);
    reg_tmp12.y = dot_3(uniforms.f[11].xyz, reg_tmp14.xyz);
    reg_tmp12.z = dot_3(uniforms.f[12].xyz, reg_tmp14.xyz);
    return false;
}
bool sub_74_75() {
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_76_103() {
    reg_tmp0.xy = (uniforms.f[0].xxxx).xy;
    if (uniforms.b[2]) {
        sub_78_83();
    } else {
        sub_83_102();
    }
    return false;
}
bool sub_78_83() {
    {
        sub_143_151();
    }
    reg_tmp3.x = dot_s(uniforms.f[1].xywz, reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2].xywz, reg_tmp6);
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_83_102() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_86_92();
    } else {
        sub_92_101();
    }
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_86_92() {
    reg_tmp6 = reg_tmp10;
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    reg_tmp3.z = dot_s(uniforms.f[3], reg_tmp6);
    reg_tmp0.xy = (mul_s(uniforms.f[9].xyyy, reg_tmp3.zzzz)).xy;
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_92_101() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_93_97();
    } else {
        sub_97_100();
    }
    return false;
}
bool sub_93_97() {
    {
        sub_151_158();
    }
    reg_tmp3.x = dot_3(uniforms.f[1].xyz, reg_tmp6.xyz);
    reg_tmp3.y = dot_3(uniforms.f[2].xyz, reg_tmp6.xyz);
    reg_tmp3.z = dot_3(uniforms.f[3].xyz, reg_tmp6.xyz);
    return false;
}
bool sub_97_100() {
    {
        sub_158_164();
    }
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    return false;
}
bool sub_103_127() {
    reg_tmp0.xy = (uniforms.f[0].yyyy).xy;
    if (uniforms.b[3]) {
        sub_105_109();
    } else {
        sub_109_126();
    }
    return false;
}
bool sub_105_109() {
    {
        sub_143_151();
    }
    reg_tmp4.x = dot_s(uniforms.f[4].xywz, reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5].xywz, reg_tmp6);
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_109_126() {
    if (uniforms.b[5]) {
        sub_110_124();
    } else {
        sub_124_125();
    }
    return false;
}
bool sub_110_124() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_113_120();
    } else {
        sub_120_123();
    }
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_113_120() {
    reg_tmp6 = reg_tmp10;
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    reg_tmp4.z = dot_s(uniforms.f[6], reg_tmp6);
    reg_tmp6.w = rcp_s(reg_tmp4.z);
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    reg_tmp4.xy = (uniforms.f[9].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_120_123() {
    {
        sub_158_164();
    }
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    return false;
}
bool sub_124_125() {
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_127_143() {
    reg_tmp0.xy = (uniforms.f[0].zzzz).xy;
    if (uniforms.b[4]) {
        sub_129_133();
    } else {
        sub_133_142();
    }
    return false;
}
bool sub_129_133() {
    {
        sub_143_151();
    }
    reg_tmp5.x = dot_s(uniforms.f[7].xywz, reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8].xywz, reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_133_142() {
    if (uniforms.b[6]) {
        sub_134_140();
    } else {
        sub_140_141();
    }
    return false;
}
bool sub_134_140() {
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    {
        sub_158_164();
    }
    reg_tmp5.x = dot_s(uniforms.f[7], reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8], reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_140_141() {
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
bool sub_143_151() {
    conditional_code = equal(uniforms.f[93].yz, reg_tmp0.xy);
    if (all(not(conditional_code))) {
        sub_145_146();
    } else {
        sub_146_150();
    }
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_145_146() {
    reg_tmp6.xy = (vs_in_reg4.xyyy).xy;
    return false;
}
bool sub_146_150() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_147_148();
    } else {
        sub_148_149();
    }
    return false;
}
bool sub_147_148() {
    reg_tmp6.xy = (vs_in_reg5.xyyy).xy;
    return false;
}
bool sub_148_149() {
    reg_tmp6.xy = (vs_in_reg6.xyyy).xy;
    return false;
}
bool sub_151_158() {
    reg_tmp2 = -reg_tmp15;
    reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
    reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_158_164() {
    reg_tmp1 = reg_tmp14;
    reg_tmp2.w = dot_3(reg_tmp1.xyz, reg_tmp1.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp1 = mul_s(reg_tmp1, reg_tmp2.wwww);
    reg_tmp1 = mul_s(uniforms.f[94].xxxx, reg_tmp1);
    reg_tmp6.xy = (uniforms.f[94].xxxx + reg_tmp1.xyyy).xy;
    return false;
}
bool sub_164_4096() {
    {
        sub_29_76();
    }
    if (uniforms.b[1]) {
        sub_166_173();
    } else {
        sub_173_174();
    }
    vs_out_attr3 = reg_tmp2;
    {
        sub_76_103();
    }
    {
        sub_103_127();
    }
    {
        sub_127_143();
    }
    return true;
}
bool sub_166_173() {
    reg_tmp0 = vec4(dot_3(uniforms.f[83].xyz, reg_tmp12.xyz));
    reg_tmp0 = max(uniforms.f[93].xxxx, reg_tmp0);
    reg_tmp0 = mul_s(uniforms.f[84], reg_tmp0);
    reg_tmp0 = uniforms.f[85] + reg_tmp0;
    reg_tmp0.w = (uniforms.f[93].yyyy).w;
    reg_tmp1 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
    reg_tmp2 = mul_s(reg_tmp0, reg_tmp1);
    return false;
}
bool sub_173_174() {
    reg_tmp2 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
    return false;
}
// reference: 9E522B378748A1A9, 0C474BA5D3CDF544
// program: 0C474BA5D3CDF544, B80FA1B7F97410CD, B766CBB102E471E4
// reference: 7CE8869F3308E798, 2BD70906436FAF24
// reference: 32BC79DF847DB3EC, 2BD70906436FAF24
// shader: 8B31, 628B798B65C30A4B

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define mul_3(x, y) mix(x * y, vec3(0.0), isnan(x * y))
#define fma_s(x, y, z) (mul_s(x, y) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(mul_3(x, y), vec3(1.0))

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_8();
bool sub_9_32();
bool sub_143_145();
bool sub_146_166();
bool sub_167_259();
bool sub_190_192();
bool sub_194_195();
bool sub_197_198();
bool sub_200_202();
bool sub_232_234();
bool sub_236_237();
bool sub_239_240();
bool sub_242_244();
bool sub_260_4096();
bool sub_269_270();
bool sub_270_271();
bool sub_277_278();
bool sub_278_279();
bool sub_304_305();
bool sub_305_306();

bool exec_shader() {
    sub_260_4096();
    return true;
}

bool sub_0_8() {
    address_registers.x = (ivec2(vs_in_reg0.zz)).x;
    reg_tmp10 = uniforms.f[0].xxxz;
    reg_tmp10.xy = (vs_in_reg0.xyyy).xy;
    reg_tmp11 = uniforms.f[0].xxxx;
    reg_tmp12 = uniforms.f[0].xxxx;
    reg_tmp13 = uniforms.f[0].zzzz;
    reg_tmp4 = uniforms.f[0].xxxx;
    reg_tmp5 = uniforms.f[0].xxxx;
    return false;
}
bool sub_9_32() {
    vs_out_attr0 = reg_tmp10;
    reg_tmp13 = mul_s(uniforms.f[82], reg_tmp13);
    vs_out_attr1 = reg_tmp13;
    reg_tmp11.y = (uniforms.f[0].zzzz + -reg_tmp11.yyyy).y;
    reg_tmp12.y = (uniforms.f[0].zzzz + -reg_tmp12.yyyy).y;
    reg_tmp14.y = (uniforms.f[81].wwww).y;
    reg_tmp14.x = (mul_s(uniforms.f[0].wwww, reg_tmp14.yyyy)).x;
    reg_tmp2.x = rcp_s(reg_tmp14.x);
    reg_tmp14.z = (reg_tmp2.xxxx).z;
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp11.xyyy).xy;
    reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    reg_tmp11.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp12.xyyy).xy;
    reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    reg_tmp12.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    vs_out_attr2 = reg_tmp11;
    vs_out_attr3 = reg_tmp12;
    return false;
}
bool sub_143_145() {
    reg_tmp1.xyz = (uniforms.f[92].xyzz).xyz;
    reg_tmp1.w = (uniforms.f[0].xxxx).w;
    return false;
}
bool sub_146_166() {
    reg_tmp2 = uniforms.f[90];
    reg_tmp3 = uniforms.f[91];
    reg_tmp4 = uniforms.f[92];
    reg_tmp5 = uniforms.f[0].xxxz;
    reg_tmp6 = mul_s(uniforms.f[86].xxxx, reg_tmp2);
    reg_tmp6 = fma_s(reg_tmp3, uniforms.f[86].yyyy, reg_tmp6);
    reg_tmp6 = fma_s(reg_tmp4, uniforms.f[86].zzzz, reg_tmp6);
    reg_tmp6 = fma_s(reg_tmp5, uniforms.f[86].wwww, reg_tmp6);
    reg_tmp7 = mul_s(uniforms.f[87].xxxx, reg_tmp2);
    reg_tmp7 = fma_s(reg_tmp3, uniforms.f[87].yyyy, reg_tmp7);
    reg_tmp7 = fma_s(reg_tmp4, uniforms.f[87].zzzz, reg_tmp7);
    reg_tmp7 = fma_s(reg_tmp5, uniforms.f[87].wwww, reg_tmp7);
    reg_tmp8 = mul_s(uniforms.f[88].xxxx, reg_tmp2);
    reg_tmp8 = fma_s(reg_tmp3, uniforms.f[88].yyyy, reg_tmp8);
    reg_tmp8 = fma_s(reg_tmp4, uniforms.f[88].zzzz, reg_tmp8);
    reg_tmp8 = fma_s(reg_tmp5, uniforms.f[88].wwww, reg_tmp8);
    reg_tmp9 = mul_s(uniforms.f[89].xxxx, reg_tmp2);
    reg_tmp9 = fma_s(reg_tmp3, uniforms.f[89].yyyy, reg_tmp9);
    reg_tmp9 = fma_s(reg_tmp4, uniforms.f[89].zzzz, reg_tmp9);
    reg_tmp9 = fma_s(reg_tmp5, uniforms.f[89].wwww, reg_tmp9);
    return false;
}
bool sub_167_259() {
    reg_tmp2.x = rcp_s(uniforms.f[81].y);
    reg_tmp2.xy = (mul_s(uniforms.f[2 + address_registers.x].zwww, reg_tmp2.xxxx)).xy;
    reg_tmp2.xy = (uniforms.f[0].yyyy + reg_tmp2.xyyy).xy;
    reg_tmp3.xy = (floor(reg_tmp2.xyyy)).xy;
    reg_tmp2.xy = (mul_s(uniforms.f[81].yyyy, reg_tmp3.xyyy)).xy;
    reg_tmp2.xy = (uniforms.f[2 + address_registers.x].zwww + -reg_tmp2.xyyy).xy;
    reg_tmp0.xy = (min(uniforms.f[81].xxxx, -reg_tmp2.xyyy)).xy;
    reg_tmp0.xy = (max(-uniforms.f[81].xxxx, reg_tmp0.xyyy)).xy;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp0.xxxx, reg_tmp0.xxxx)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.xxxx)).y;
    reg_tmp5.x = (uniforms.f[5 + address_registers.x].wwww).x;
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_190_192();
    }
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_194_195();
    }
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_197_198();
    }
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_200_202();
    }
    reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    reg_tmp4.z = (uniforms.f[83].xxxx).z;
    reg_tmp4.w = (-uniforms.f[83].yyyy).w;
    reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[3 + address_registers.x].xyyy)).xy;
    reg_tmp4.z = (-uniforms.f[3 + address_registers.x].zzzz).z;
    reg_tmp4.w = (-uniforms.f[3 + address_registers.x].wwww).w;
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    reg_tmp11.xy = (reg_tmp5.xyyy).xy;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp0.yyyy, reg_tmp0.yyyy)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.yyyy)).y;
    reg_tmp5.x = (uniforms.f[6 + address_registers.x].wwww).x;
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_232_234();
    }
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_236_237();
    }
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_239_240();
    }
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_242_244();
    }
    reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    reg_tmp4.z = (uniforms.f[83].zzzz).z;
    reg_tmp4.w = (-uniforms.f[83].wwww).w;
    reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[4 + address_registers.x].xyyy)).xy;
    reg_tmp4.z = (-uniforms.f[4 + address_registers.x].zzzz).z;
    reg_tmp4.w = (-uniforms.f[4 + address_registers.x].wwww).w;
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    reg_tmp12.xy = (reg_tmp5.xyyy).xy;
    return false;
}
bool sub_190_192() {
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_194_195() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_197_198() {
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_200_202() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_232_234() {
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_236_237() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_239_240() {
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_242_244() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_260_4096() {
    {
        sub_0_8();
    }
    reg_tmp10.xy = (uniforms.f[84].xyyy + reg_tmp10.xyyy).xy;
    reg_tmp10.xy = (mul_s(uniforms.f[2 + address_registers.x].xyyy, reg_tmp10.xyyy)).xy;
    {
        sub_143_145();
    }
    reg_tmp2.xyz = (reg_tmp1.xyzz).xyz;
    reg_tmp3.xyz = (uniforms.f[6 + address_registers.x].xyzz).xyz;
    reg_tmp4.x = dot_3(reg_tmp3.xyz, reg_tmp3.xyz);
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
    if (conditional_code.x) {
        sub_269_270();
    } else {
        sub_270_271();
    }
    reg_tmp3.xyz = (mul_s(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
    reg_tmp4.xyz = (mul_s(reg_tmp3.yzxx, reg_tmp2.zxyy)).xyz;
    reg_tmp4.xyz = (fma_s(-reg_tmp2.yzxx, reg_tmp3.zxyy, reg_tmp4)).xyz;
    reg_tmp5.x = dot_3(reg_tmp4.xyz, reg_tmp4.xyz);
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp5.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp5.y;
    if (conditional_code.x) {
        sub_277_278();
    } else {
        sub_278_279();
    }
    reg_tmp4.xyz = (mul_s(reg_tmp4.xyzz, reg_tmp5.xxxx)).xyz;
    reg_tmp5.xyz = (mul_s(reg_tmp3.yzxx, reg_tmp4.zxyy)).xyz;
    reg_tmp5.xyz = (fma_s(-reg_tmp4.yzxx, reg_tmp3.zxyy, reg_tmp5)).xyz;
    reg_tmp6.x = (reg_tmp4.xxxx).x;
    reg_tmp6.y = (reg_tmp3.xxxx).y;
    reg_tmp6.z = (reg_tmp5.xxxx).z;
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    reg_tmp7.x = (reg_tmp4.yyyy).x;
    reg_tmp7.y = (reg_tmp3.yyyy).y;
    reg_tmp7.z = (reg_tmp5.yyyy).z;
    reg_tmp7.w = (uniforms.f[0].xxxx).w;
    reg_tmp8.x = (reg_tmp4.zzzz).x;
    reg_tmp8.y = (reg_tmp3.zzzz).y;
    reg_tmp8.z = (reg_tmp5.zzzz).z;
    reg_tmp8.w = (uniforms.f[0].xxxx).w;
    reg_tmp9 = uniforms.f[0].xxxz;
    reg_tmp2.x = dot_s(reg_tmp10, reg_tmp6);
    reg_tmp2.y = dot_s(reg_tmp10, reg_tmp7);
    reg_tmp2.z = dot_s(reg_tmp10, reg_tmp8);
    reg_tmp2.w = dot_s(reg_tmp10, reg_tmp9);
    reg_tmp3.xyz = (uniforms.f[5 + address_registers.x].xyzz).xyz;
    reg_tmp3.xyz = (-uniforms.f[85].xyzz + reg_tmp3.xyzz).xyz;
    reg_tmp4.x = dot_3(reg_tmp3.xyz, reg_tmp3.xyz);
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
    if (conditional_code.x) {
        sub_304_305();
    } else {
        sub_305_306();
    }
    reg_tmp3.xyz = (mul_s(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
    reg_tmp10.xyz = (uniforms.f[5 + address_registers.x].xyzz + reg_tmp2.xyzz).xyz;
    reg_tmp10.xyz = (fma_s(reg_tmp3.xyzz, -uniforms.f[84].zzzz, reg_tmp10.xyzz)).xyz;
    {
        sub_146_166();
    }
    reg_tmp2 = reg_tmp10;
    reg_tmp10.x = dot_s(reg_tmp2, reg_tmp6);
    reg_tmp10.y = dot_s(reg_tmp2, reg_tmp7);
    reg_tmp10.z = dot_s(reg_tmp2, reg_tmp8);
    reg_tmp10.w = dot_s(reg_tmp2, reg_tmp9);
    reg_tmp2 = uniforms.f[1 + address_registers.x];
    reg_tmp3 = max(uniforms.f[0].xxxx, reg_tmp2);
    reg_tmp2 = min(uniforms.f[0].zzzz, reg_tmp3);
    reg_tmp13 = reg_tmp2;
    {
        sub_167_259();
    }
    {
        sub_9_32();
    }
    return true;
}
bool sub_269_270() {
    reg_tmp4.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_270_271() {
    reg_tmp4.x = rsq_s(reg_tmp4.x);
    return false;
}
bool sub_277_278() {
    reg_tmp5.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_278_279() {
    reg_tmp5.x = rsq_s(reg_tmp5.x);
    return false;
}
bool sub_304_305() {
    reg_tmp4.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_305_306() {
    reg_tmp4.x = rsq_s(reg_tmp4.x);
    return false;
}
// reference: 15AC4186F086C8F7, 628B798B65C30A4B
// program: 628B798B65C30A4B, 082670B4222015B2, DBA0F8FE46AD8D9B
// reference: E545D249EAE558DC, 2943A920476E1E56
// reference: 519CD67D911DBC2F, CDD7AB422818C224
// reference: 1FC8293DC9517B1A, CDD7AB422818C224
// reference: 58970D4727ABBDAE, C1B15B379433D4E8
// reference: 73EE4218A477DF7A, 01B0CF4127F43ED8
// reference: 3DBABD58FC3B184F, 01B0CF4127F43ED8
// reference: 3DBABD5813028B0E, 01B0CF4127F43ED8
// reference: 9E522B377E9FBB97, 0C474BA5D3CDF544
// reference: 7CE8869FCADFFDA6, 2BD70906436FAF24
// reference: 32BC79DF7DAAA9D2, 2BD70906436FAF24
// reference: 88E78CBE9FFC85B0, 2BD70906436FAF24
// reference: 40A37A2A00BC011D, 2C776115811B5DFC
// reference: 7189F773CC5F7096, 36FBAA27E5920598
// reference: 3FDD08337B2A24E2, 36FBAA27E5920598
// program: 628B798B65C30A4B, 082670B4222015B2, 558A6C807844C0F3
// reference: 5BF8BEC6A8CA0FC2, 628B798B65C30A4B
// reference: 54C62F0AA66D2E24, 27B560CBF361F4CF
// reference: 73EE42180E9128B7, 15E048F2F07F2E01
// program: 15E048F2F07F2E01, B80FA1B7F97410CD, 5741FC947D667CFB
// reference: 3DBABD58FDA95512, 15E048F2F07F2E01
// program: 15E048F2F07F2E01, B80FA1B7F97410CD, 5FF3DF19FAD860D6
// reference: 95072FBCA8CA0FC2, 628B798B65C30A4B
// program: 628B798B65C30A4B, 082670B4222015B2, 1430EF96707A019C
// reference: 1A92D04AFE21E911, 27B560CBF361F4CF
// reference: EDE38F4394241F7A, 15E048F2F07F2E01
// reference: EDE38F43D06936AB, 15E048F2F07F2E01
// reference: 9A2ECF1DA0501A0B, A147DA9530FE3B39
// program: A147DA9530FE3B39, 082670B4222015B2, 63A5270519B4AE20
// reference: F7394D2DA8CA0FC2, 628B798B65C30A4B
// reference: C6B373FE2889D1C4, 2BD70906436FAF24
// program: CDD7AB422818C224, 42937135801BAA7E, 233D9A25E7282666
// reference: CCA8F3B1314B486A, 502AB780D80D09C1
// reference: 7A574159B99C7E94, D9C174A4A54356AC
// reference: 735C9A630F2A7F15, 502AB780D80D09C1
// reference: F993EC1E1EC424BA, D2A401390BA8C9C0
// reference: E39765206952708D, D9C174A4A54356AC
// reference: DBC5922032DA6F21, 35CCCCDE75E2FF83
// reference: 00855AAB7F0309FC, 4CDB2C6E0A14815D
// reference: C1E5F1451F314CEC, E81D148B6EF003F8
// reference: B7077C890E16CA16, 502AB780D80D09C1
// reference: E3976520CFCBFE5F, D9C174A4A54356AC
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 7ED2F034E5EB4FC6
// program: E81D148B6EF003F8, B80FA1B7F97410CD, BC32652205728950
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 10AAC2A3349D1A7E
// program: D9C174A4A54356AC, 42937135801BAA7E, 52F5F74AF1B519B6
// program: D9C174A4A54356AC, 42937135801BAA7E, 98F0722A788E01FD
// program: D9C174A4A54356AC, 42937135801BAA7E, 6E5C02D38B9C02DF
// program: D9C174A4A54356AC, 42937135801BAA7E, A4E2954DD6C4FB71
// reference: C1E5F145B5D7BB21, D0293423BD9EA1E7
// program: D0293423BD9EA1E7, B80FA1B7F97410CD, 19F7816C4117CF8E
// reference: E3976520B6DF35B9, D9C174A4A54356AC
// program: D9C174A4A54356AC, 42937135801BAA7E, 5FBCCF5F27F5A7C1
// program: D9C174A4A54356AC, 42937135801BAA7E, 63B6ADAD25C2A518
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 47E4BEE6B3304AF3
// program: E81D148B6EF003F8, B80FA1B7F97410CD, C580B429ECAF519A
// reference: B8A612251F314CEC, E81D148B6EF003F8
// reference: B8A61225B5D7BB21, D0293423BD9EA1E7
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 4BA25B84A31C492A
// program: D9C174A4A54356AC, 42937135801BAA7E, 6B98A4CC666FCBCF
// program: D9C174A4A54356AC, 42937135801BAA7E, D1257B6267770D05
// program: D9C174A4A54356AC, 42937135801BAA7E, D134C63316570D84
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 40FC95A67F54598B
// program: E81D148B6EF003F8, B80FA1B7F97410CD, D69A3CB52F0E3495
// program: E81D148B6EF003F8, B80FA1B7F97410CD, B5CB613BFC4BC41C
// reference: EA9CBE1A00693438, 502AB780D80D09C1
// program: 502AB780D80D09C1, B80FA1B7F97410CD, 1B4DA8DA884D39A1
// program: E81D148B6EF003F8, B80FA1B7F97410CD, D2BD0C5FAA2AB273
// program: E81D148B6EF003F8, B80FA1B7F97410CD, F8FBCC791CAC22F2
// program: E81D148B6EF003F8, B80FA1B7F97410CD, FEE7FD4C7FD3D731
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 8633243B2123B710
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 39E142A8F1F39B96
// program: E81D148B6EF003F8, B80FA1B7F97410CD, FC9E10BE42F07103
// reference: B9A482E761578BFB, 1BDE5ABD20055F26
// program: 1BDE5ABD20055F26, 082670B4222015B2, DBA0F8FE46AD8D9B
// reference: 0D7D86D31AAF6F08, D9C174A4A54356AC
// program: D9C174A4A54356AC, 42937135801BAA7E, 47A8279A60685F27
// reference: 2F0F12B62FC50C5D, E81D148B6EF003F8
// reference: 2F0F12B68523FB90, D0293423BD9EA1E7
// reference: 0D7D86D3862B7508, D9C174A4A54356AC
// reference: 04765DE9309D7489, 502AB780D80D09C1
// reference: C333085F5734DBD8, 5E28DB645EED49B7
// program: 5E28DB645EED49B7, B80FA1B7F97410CD, C2EEBEAE0D7F3560
// reference: 2D68A7DD47EDA3B1, A40B5D829674D1F8
// program: A40B5D829674D1F8, B80FA1B7F97410CD, 1CBA1DD1EAE2F663
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 6A08A79BE3FAC39D
// program: D0293423BD9EA1E7, B80FA1B7F97410CD, 10AAC2A3349D1A7E
// program: 49AB6B882020674A, 082670B4222015B2, 0D19D21B46AD8D9B
// reference: F2AA84D08861B660, D9C174A4A54356AC
// reference: D0D810B59A1E8AE7, E81D148B6EF003F8
// reference: D0D810B530F87D2A, D0293423BD9EA1E7
// reference: F2AA84D033F0F3B2, D9C174A4A54356AC
// reference: FBA15FEA8546F233, 502AB780D80D09C1
// reference: 3CE40A5CE2EF5D62, 5E28DB645EED49B7
// reference: D2BFA5DE47EDA3B1, A40B5D829674D1F8
// reference: F2AA84D04AE43854, D9C174A4A54356AC
// reference: FBA15FEAFC5239D5, 502AB780D80D09C1
// program: D9C174A4A54356AC, 42937135801BAA7E, 29CD3EBE51FAA42A
// program: D9C174A4A54356AC, 42937135801BAA7E, B2E64CFB9744D892
// program: D9C174A4A54356AC, 42937135801BAA7E, 98647FD3CF93B689
// reference: FBA15FEA3ED7B7E1, 502AB780D80D09C1
// program: 49AB6B882020674A, 082670B4222015B2, DBA0F8FE46AD8D9B
// program: 70A370D21404144E, 082670B4222015B2, DBA0F8FE46AD8D9B
// program: 70A370D21404144E, 082670B4222015B2, F4A415D97E9B6ED6
// program: D9C174A4A54356AC, 42937135801BAA7E, AB0D786CFAD777F8
// reference: 04765DE9AC196E89, 502AB780D80D09C1
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 6A44D3E672630106
// program: 35CCCCDE75E2FF83, B80FA1B7F97410CD, 0AC00F84117E7EFC
// reference: 6A295DFC71A2E093, 4CDB2C6E0A14815D
// reference: CB71EA01D93287B4, 4CDB2C6E0A14815D
// program: 4CDB2C6E0A14815D, B80FA1B7F97410CD, A36D1D6BA424DB28
// program: 4CDB2C6E0A14815D, B80FA1B7F97410CD, 641FDB3E9E36B758
// reference: 467380E4CF700DA8, 49AB6B882020674A
// program: 49AB6B882020674A, 082670B4222015B2, 1430EF96EBF7840F
// program: 4028512EA840631E, B80FA1B7F97410CD, C2EEBEAE0D7F3560
// program: A40B5D829674D1F8, B80FA1B7F97410CD, 9D0535C6802495CB
// program: 49AB6B882020674A, 082670B4222015B2, 63A5270519B4AE20
// reference: 889B60F3C94D3987, 70A370D21404144E
// reference: 889B60F3C0A55982, 70A370D21404144E
// program: D9C174A4A54356AC, 42937135801BAA7E, 49F399BDFAD777F8
// program: D9C174A4A54356AC, 42937135801BAA7E, 00F9BB7ACF93B689
// reference: C2B37B99F52D68B0, 3526EFD6EA584B4A
// program: 3526EFD6EA584B4A, B80FA1B7F97410CD, B766CBB102E471E4
// reference: 7968FD3EB562F7BA, 5E28DB645EED49B7
// reference: 494D112882E301EE, 8AA3B6DF4767940E
// program: 8AA3B6DF4767940E, 082670B4222015B2, DBA0F8FE46AD8D9B
// reference: B9A482E7988091C5, 1BDE5ABD20055F26
// reference: 0D7D86D3E3787536, D9C174A4A54356AC
// reference: 04765DE955CE74B7, 502AB780D80D09C1
// reference: 2F0F12B6D6121663, E81D148B6EF003F8
// reference: C2B37B990CFA728E, 3526EFD6EA584B4A
// reference: 7968FD3E4CB5ED84, 5E28DB645EED49B7
// reference: 2D68A7DDBE3AB98F, A40B5D829674D1F8
// program: 8AA3B6DF4767940E, 082670B4222015B2, 558A6C807844C0F3
// reference: 2F0F12B67CF4E1AE, D0293423BD9EA1E7
// program: D0293423BD9EA1E7, B80FA1B7F97410CD, 5741FC947D667CFB
// program: D0293423BD9EA1E7, B80FA1B7F97410CD, 5FF3DF19FAD860D6
// program: 8AA3B6DF4767940E, 082670B4222015B2, 1430EF96707A019C
// reference: 467380E48C442008, 49AB6B882020674A
// program: 70A370D21404144E, 082670B4222015B2, 63A5270519B4AE20
// reference: C333085FAEE3C1E6, 5E28DB645EED49B7
// reference: 9A522350A33B02E3, 4028512EA840631E
// reference: 59ED9F7A3EE28AA7, 502AB780D80D09C1
// reference: 0D7D86D3FF3FBEEE, D9C174A4A54356AC
// reference: 59ED9F7AAB925E32, 46E991DEB658A5A9
// program: 46E991DEB658A5A9, B80FA1B7F97410CD, 91931D139F54748D
// program: 46E991DEB658A5A9, B80FA1B7F97410CD, 5FACCC9E3E0584D2
// reference: 0D7D86D36A4F6A7B, 81B0676B862CF405
// program: 81B0676B862CF405, 42937135801BAA7E, F5D54925A6AE705F
// program: 81B0676B862CF405, 42937135801BAA7E, 835CABE3A4B650D2
// program: 81B0676B862CF405, 42937135801BAA7E, D4C9E99618707555
// program: 81B0676B862CF405, 42937135801BAA7E, 0951EE62DBCF2390
// reference: 2F0F12B6BAB5D8C8, 2E530FFFDA886761
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 26CF8128A3DDBB83
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 953385FED82E0FD1
// program: 2E530FFFDA886761, B80FA1B7F97410CD, E52C4E220978C964
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 378438FF70532E82
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 9F25A997909124C1
// program: 2E530FFFDA886761, B80FA1B7F97410CD, F35E8CA2CAC182F7
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 576E786439C2EA2F
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 1471721266F6CFF3
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 90EA57FA2E348842
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 1212B53523129C17
// program: 2E530FFFDA886761, B80FA1B7F97410CD, C9A23B908E5F8ABB
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 7E2D94A79BE7422B
// program: 91D55C04BB07EE32, B80FA1B7F97410CD, 9342C6596F83F706
// program: 2E530FFFDA886761, B80FA1B7F97410CD, D02B1E1378BD97CF
// program: 2E530FFFDA886761, B80FA1B7F97410CD, B78314A585D12D9C
// program: 2E530FFFDA886761, B80FA1B7F97410CD, DEC6EAEA57FA4325
// program: 2E530FFFDA886761, B80FA1B7F97410CD, D4C50B709583D191
// program: 2E530FFFDA886761, B80FA1B7F97410CD, B20F7E72A7330A13
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 48065A05481CB4B8
// program: 2E530FFFDA886761, B80FA1B7F97410CD, BB80E4A110994B48
// program: 2E530FFFDA886761, B80FA1B7F97410CD, EAAC665924781109
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 0656C780E79F2203
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 31E556E9A7729BF4
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 6C66577708AE1E87
// program: 2E530FFFDA886761, B80FA1B7F97410CD, FC7222C50C6F5038
// program: 2E530FFFDA886761, B80FA1B7F97410CD, D1B1A073730D724F
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 790FB95CC0B11076
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 037898F85F34DE95
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 3013FC5CF83A846B
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 168DA83A29634DCC
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 7ED2F034E5EB4FC6
// program: 2E530FFFDA886761, B80FA1B7F97410CD, BC32652205728950
// program: 81B0676B862CF405, 42937135801BAA7E, 21786A34D707A069
// program: 81B0676B862CF405, 42937135801BAA7E, 5124AD903EB19D9F
// program: 81B0676B862CF405, 42937135801BAA7E, 886AC14BAA341C33
// program: 81B0676B862CF405, 42937135801BAA7E, 7C14C907B3CCD849
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 10AAC2A3349D1A7E
// program: 81B0676B862CF405, 42937135801BAA7E, 52F5F74AF1B519B6
// program: 81B0676B862CF405, 42937135801BAA7E, 98F0722A788E01FD
// program: 81B0676B862CF405, 42937135801BAA7E, 6E5C02D38B9C02DF
// program: 81B0676B862CF405, 42937135801BAA7E, A4E2954DD6C4FB71
// reference: 2F0F12B610532F05, FD3DADE0E2BC47C9
// program: FD3DADE0E2BC47C9, B80FA1B7F97410CD, 19F7816C4117CF8E
// reference: 0D7D86D3135BA19D, 81B0676B862CF405
// program: 81B0676B862CF405, 42937135801BAA7E, 5FBCCF5F27F5A7C1
// program: 81B0676B862CF405, 42937135801BAA7E, 63B6ADAD25C2A518
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 47E4BEE6B3304AF3
// program: 2E530FFFDA886761, B80FA1B7F97410CD, C580B429ECAF519A
// reference: F993EC1E8BB4F02F, 1934FF8F80653ACB
// program: 1934FF8F80653ACB, B80FA1B7F97410CD, 5C250F6C1418BBD3
// reference: B8A612258A419879, 2E530FFFDA886761
// reference: B8A6122520A76FB4, FD3DADE0E2BC47C9
// reference: E397652023AFE12C, 81B0676B862CF405
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 4BA25B84A31C492A
// reference: E3976520FC22A418, 81B0676B862CF405
// program: 81B0676B862CF405, 42937135801BAA7E, CAB8B665DC444CE4
// reference: C1E5F1458A419879, 2E530FFFDA886761
// reference: C1E5F14520A76FB4, FD3DADE0E2BC47C9
// program: 81B0676B862CF405, 42937135801BAA7E, 6B98A4CC666FCBCF
// program: 81B0676B862CF405, 42937135801BAA7E, D1257B6267770D05
// program: 81B0676B862CF405, 42937135801BAA7E, D134C63316570D84
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 40FC95A67F54598B
// program: 2E530FFFDA886761, B80FA1B7F97410CD, D69A3CB52F0E3495
// program: 2E530FFFDA886761, B80FA1B7F97410CD, B5CB613BFC4BC41C
// reference: EA9CBE1A9519E0AD, 46E991DEB658A5A9
// program: 46E991DEB658A5A9, B80FA1B7F97410CD, 1B4DA8DA884D39A1
// program: 2E530FFFDA886761, B80FA1B7F97410CD, D2BD0C5FAA2AB273
// program: 2E530FFFDA886761, B80FA1B7F97410CD, F8FBCC791CAC22F2
// program: 2E530FFFDA886761, B80FA1B7F97410CD, FEE7FD4C7FD3D731
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 8633243B2123B710
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 39E142A8F1F39B96
// program: 2E530FFFDA886761, B80FA1B7F97410CD, FC9E10BE42F07103
// reference: B9A482E7F4275F6E, C6410D4382B19655
// program: C6410D4382B19655, 082670B4222015B2, DBA0F8FE46AD8D9B
// reference: 0D7D86D38FDFBB9D, 81B0676B862CF405
// program: 81B0676B862CF405, 42937135801BAA7E, 47A8279A60685F27
// reference: 04765DE9A5EDA01C, 46E991DEB658A5A9
// reference: 9A522350364BD676, B0CCAE4F9AB69CDA
// program: B0CCAE4F9AB69CDA, B80FA1B7F97410CD, C2EEBEAE0D7F3560
// program: 45C9694A57480945, B80FA1B7F97410CD, 490CACB848ED440A
// program: 45C9694A57480945, B80FA1B7F97410CD, 0AC00F84117E7EFC
// reference: 2D68A7DDD29D7724, D03F0FE4B72A8E86
// program: D03F0FE4B72A8E86, B80FA1B7F97410CD, 9D0535C6802495CB
// program: D03F0FE4B72A8E86, B80FA1B7F97410CD, 429F87F8D3AE0B36
// program: D03F0FE4B72A8E86, B80FA1B7F97410CD, 40BF4FB85B0B5330
// program: D03F0FE4B72A8E86, B80FA1B7F97410CD, EE82356499D9033F
// program: D03F0FE4B72A8E86, B80FA1B7F97410CD, 5F16273C5032C0B2
// program: D03F0FE4B72A8E86, B80FA1B7F97410CD, BC8FFFD904DA352D
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 6A08A79BE3FAC39D
// program: FD3DADE0E2BC47C9, B80FA1B7F97410CD, 10AAC2A3349D1A7E
// program: 949D68475595512F, 082670B4222015B2, 0D19D21B46AD8D9B
// reference: F2AA84D01D1162F5, 81B0676B862CF405
// reference: D0D810B50F6E5E72, 2E530FFFDA886761
// reference: D0D810B5A588A9BF, FD3DADE0E2BC47C9
// reference: F2AA84D0A6802727, 81B0676B862CF405
// reference: FBA15FEA103626A6, 46E991DEB658A5A9
// reference: 65852153839050CC, B0CCAE4F9AB69CDA
// reference: 77308EBDB71062CA, B0CCAE4F9AB69CDA
// reference: D2BFA5DED29D7724, D03F0FE4B72A8E86
// reference: F2AA84D0DF94ECC1, 81B0676B862CF405
// reference: FBA15FEA6922ED40, 46E991DEB658A5A9
// program: 81B0676B862CF405, 42937135801BAA7E, 29CD3EBE51FAA42A
// program: 81B0676B862CF405, 42937135801BAA7E, B2E64CFB9744D892
// program: 81B0676B862CF405, 42937135801BAA7E, 98647FD3CF93B689
// reference: FBA15FEAABA76374, 46E991DEB658A5A9
// program: 949D68475595512F, 082670B4222015B2, DBA0F8FE46AD8D9B
// program: 2FBE2E4ED1D9324C, 082670B4222015B2, DBA0F8FE46AD8D9B
// program: 2FBE2E4ED1D9324C, 082670B4222015B2, F4A415D97E9B6ED6
// program: 81B0676B862CF405, 42937135801BAA7E, AB0D786CFAD777F8
// reference: 04765DE93969BA1C, 46E991DEB658A5A9
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 6A44D3E672630106
// reference: 6A295DFCE4D23406, 1B722ADD909A7B2D
// program: 1B722ADD909A7B2D, B80FA1B7F97410CD, B3C2F6056AADCF6F
// reference: CB71EA014C425321, 1B722ADD909A7B2D
// program: 1B722ADD909A7B2D, B80FA1B7F97410CD, A36D1D6BA424DB28
// program: 1B722ADD909A7B2D, B80FA1B7F97410CD, 641FDB3E9E36B758
// reference: 467380E45A00D93D, 949D68475595512F
// program: 949D68475595512F, 082670B4222015B2, 1430EF96EBF7840F
// program: 949D68475595512F, 082670B4222015B2, 63A5270519B4AE20
// reference: 889B60F35C3DED12, 2FBE2E4ED1D9324C
// reference: 889B60F355D58D17, 2FBE2E4ED1D9324C
// program: 81B0676B862CF405, 42937135801BAA7E, 49F399BDFAD777F8
// program: 81B0676B862CF405, 42937135801BAA7E, 00F9BB7ACF93B689
// reference: C2B37B99605DBC25, A214E3C9645157AE
// program: A214E3C9645157AE, B80FA1B7F97410CD, B766CBB102E471E4
// reference: 2009D631D41DFA14, B0CCAE4F9AB69CDA
// reference: 494D11281793D57B, 493A89E34FC6D4B5
// program: 493A89E34FC6D4B5, 082670B4222015B2, DBA0F8FE46AD8D9B
// reference: B9A482E70DF04550, C6410D4382B19655
// reference: 0D7D86D37608A1A3, 81B0676B862CF405
// reference: 04765DE9C0BEA022, 46E991DEB658A5A9
// reference: 2F0F12B64362C2F6, 2E530FFFDA886761
// reference: C2B37B99998AA61B, A214E3C9645157AE
// reference: 2009D6312DCAE02A, B0CCAE4F9AB69CDA
// reference: 2D68A7DD2B4A6D1A, D03F0FE4B72A8E86
// program: 493A89E34FC6D4B5, 082670B4222015B2, 558A6C807844C0F3
// reference: 2F0F12B6E984353B, FD3DADE0E2BC47C9
// program: FD3DADE0E2BC47C9, B80FA1B7F97410CD, 5741FC947D667CFB
// program: FD3DADE0E2BC47C9, B80FA1B7F97410CD, 5FF3DF19FAD860D6
// program: 493A89E34FC6D4B5, 082670B4222015B2, 1430EF96707A019C
// reference: 467380E41934F49D, 949D68475595512F
// program: 2FBE2E4ED1D9324C, 082670B4222015B2, 63A5270519B4AE20
// reference: 9A522350CF9CCC48, B0CCAE4F9AB69CDA
// program: 2E530FFFDA886761, B80FA1B7F97410CD, FFE5F81052CAA889
// reference: 2F0F12B6DE55A336, 01B0CF4127F43ED8
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, 26CF8128A3DDBB83
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, 953385FED82E0FD1
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, E52C4E220978C964
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, 378438FF70532E82
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, 9F25A997909124C1
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, F35E8CA2CAC182F7
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, 576E786439C2EA2F
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, 1471721266F6CFF3
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, 90EA57FA2E348842
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, 1212B53523129C17
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, C9A23B908E5F8ABB
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, 7E2D94A79BE7422B
// program: 0350F8532B3DBD74, B80FA1B7F97410CD, 9342C6596F83F706
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, D02B1E1378BD97CF
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, B78314A585D12D9C
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, DEC6EAEA57FA4325
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, D4C50B709583D191
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, B20F7E72A7330A13
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, 48065A05481CB4B8
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, BB80E4A110994B48
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, EAAC665924781109
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, 0656C780E79F2203
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, 31E556E9A7729BF4
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, 6C66577708AE1E87
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, FC7222C50C6F5038
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, D1B1A073730D724F
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, 790FB95CC0B11076
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, 037898F85F34DE95
// reference: 59ED9F7ACF7225CC, C1B15B379433D4E8
// program: C1B15B379433D4E8, B80FA1B7F97410CD, 91931D139F54748D
// program: C1B15B379433D4E8, B80FA1B7F97410CD, 5FACCC9E3E0584D2
// reference: 0D7D86D30EAF1185, CDD7AB422818C224
// program: CDD7AB422818C224, 42937135801BAA7E, F5D54925A6AE705F
// program: CDD7AB422818C224, 42937135801BAA7E, 835CABE3A4B650D2
// program: CDD7AB422818C224, 42937135801BAA7E, D4C9E99618707555
// program: CDD7AB422818C224, 42937135801BAA7E, 0951EE62DBCF2390
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, 3013FC5CF83A846B
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, 168DA83A29634DCC
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, 7ED2F034E5EB4FC6
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, BC32652205728950
// program: CDD7AB422818C224, 42937135801BAA7E, 21786A34D707A069
// program: CDD7AB422818C224, 42937135801BAA7E, 5124AD903EB19D9F
// program: CDD7AB422818C224, 42937135801BAA7E, 886AC14BAA341C33
// program: CDD7AB422818C224, 42937135801BAA7E, 7C14C907B3CCD849
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, 10AAC2A3349D1A7E
// program: CDD7AB422818C224, 42937135801BAA7E, 52F5F74AF1B519B6
// program: CDD7AB422818C224, 42937135801BAA7E, 98F0722A788E01FD
// program: CDD7AB422818C224, 42937135801BAA7E, 6E5C02D38B9C02DF
// program: CDD7AB422818C224, 42937135801BAA7E, A4E2954DD6C4FB71
// reference: 2F0F12B674B354FB, 15E048F2F07F2E01
// program: 15E048F2F07F2E01, B80FA1B7F97410CD, 19F7816C4117CF8E
// reference: 0D7D86D377BBDA63, CDD7AB422818C224
// program: CDD7AB422818C224, 42937135801BAA7E, 5FBCCF5F27F5A7C1
// program: CDD7AB422818C224, 42937135801BAA7E, 63B6ADAD25C2A518
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, 47E4BEE6B3304AF3
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, C580B429ECAF519A
// reference: F993EC1EEF548BD1, 40D5333E0804E8E0
// program: 40D5333E0804E8E0, B80FA1B7F97410CD, 5C250F6C1418BBD3
// reference: B8A61225EEA1E387, 01B0CF4127F43ED8
// reference: B8A612254447144A, 15E048F2F07F2E01
// reference: E3976520474F9AD2, CDD7AB422818C224
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, 4BA25B84A31C492A
// reference: E397652098C2DFE6, CDD7AB422818C224
// program: CDD7AB422818C224, 42937135801BAA7E, CAB8B665DC444CE4
// reference: C1E5F145EEA1E387, 01B0CF4127F43ED8
// reference: C1E5F1454447144A, 15E048F2F07F2E01
// program: CDD7AB422818C224, 42937135801BAA7E, 6B98A4CC666FCBCF
// program: CDD7AB422818C224, 42937135801BAA7E, D1257B6267770D05
// program: CDD7AB422818C224, 42937135801BAA7E, D134C63316570D84
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, 40FC95A67F54598B
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, D69A3CB52F0E3495
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, B5CB613BFC4BC41C
// reference: EA9CBE1AF1F99B53, C1B15B379433D4E8
// program: C1B15B379433D4E8, B80FA1B7F97410CD, 1B4DA8DA884D39A1
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, D2BD0C5FAA2AB273
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, F8FBCC791CAC22F2
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, FEE7FD4C7FD3D731
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, 8633243B2123B710
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, 39E142A8F1F39B96
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, FC9E10BE42F07103
// reference: B9A482E790C72490, 2943A920476E1E56
// program: 2943A920476E1E56, 082670B4222015B2, DBA0F8FE46AD8D9B
// reference: 0D7D86D3EB3FC063, CDD7AB422818C224
// program: CDD7AB422818C224, 42937135801BAA7E, 47A8279A60685F27
// reference: 04765DE9C10DDBE2, C1B15B379433D4E8
// shader: 8B31, 62C70CD03ED10B4A

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;
out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define mul_3(x, y) mix(x * y, vec3(0.0), isnan(x * y))
#define fma_s(x, y, z) (mul_s(x, y) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(mul_3(x, y), vec3(1.0))

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_6();
bool sub_6_53();
bool sub_21_25();
bool sub_51_52();
bool sub_53_4096();

bool exec_shader() {
    sub_53_4096();
    return true;
}

bool sub_0_6() {
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    return false;
}
bool sub_6_53() {
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    reg_tmp7 = uniforms.f[93].xxxx;
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    {
        sub_0_6();
    }
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    {
        sub_0_6();
    }
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    if (conditional_code.x) {
        sub_0_6();
    }
    if (uniforms.b[11]) {
        sub_21_25();
    }
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    reg_tmp10 = reg_tmp7;
    reg_tmp6.y = (-uniforms.f[83].wwww + reg_tmp10.yyyy).y;
    reg_tmp9.xyz = (uniforms.f[83].xyzz).xyz;
    reg_tmp7.x = dot_s(reg_tmp9.xyzz, reg_tmp9.xyzz);
    reg_tmp7.x = rsq_s(reg_tmp7.x);
    reg_tmp7.xyz = (mul_s(reg_tmp9.xyzz, reg_tmp7.xxxx)).xyz;
    reg_tmp8.y = rcp_s(-reg_tmp7.y);
    reg_tmp8.y = (mul_s(reg_tmp6.yyyy, reg_tmp8.yyyy)).y;
    reg_tmp7.xyz = (mul_s(reg_tmp7.xyzz, reg_tmp8.yyyy)).xyz;
    reg_tmp10.xyz = (reg_tmp10.xyzz + reg_tmp7.xyzz).xyz;
    reg_tmp10.y = (uniforms.f[94].xxxx + reg_tmp10.yyyy).y;
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    vs_out_attr1 = uniforms.f[93].xxxx;
    vs_out_attr2 = reg_tmp15;
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    if (all(conditional_code)) {
        sub_51_52();
    }
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_21_25() {
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    if (conditional_code.y) {
        sub_0_6();
    }
    return false;
}
bool sub_51_52() {
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_53_4096() {
    {
        sub_6_53();
    }
    vs_out_attr4 = uniforms.f[93].xxxx;
    vs_out_attr5 = uniforms.f[93].xxxx;
    vs_out_attr6 = uniforms.f[93].xxxx;
    vs_out_attr3 = uniforms.f[93].yyyy;
    return true;
}
// reference: C333085FA6A474B3, 62C70CD03ED10B4A
// program: 62C70CD03ED10B4A, B80FA1B7F97410CD, C2EEBEAE0D7F3560
// reference: D186A7B1922446B5, 62C70CD03ED10B4A
// program: 2C776115811B5DFC, B80FA1B7F97410CD, 490CACB848ED440A
// reference: 2D68A7DDB67D0CDA, 36FBAA27E5920598
// program: 36FBAA27E5920598, B80FA1B7F97410CD, 1CBA1DD1EAE2F663
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, 6A08A79BE3FAC39D
// program: 15E048F2F07F2E01, B80FA1B7F97410CD, 10AAC2A3349D1A7E
// program: 27B560CBF361F4CF, 082670B4222015B2, 0D19D21B46AD8D9B
// reference: F2AA84D079F1190B, CDD7AB422818C224
// reference: D0D810B56B8E258C, 01B0CF4127F43ED8
// reference: D0D810B5C168D241, 15E048F2F07F2E01
// reference: F2AA84D0C2605CD9, CDD7AB422818C224
// reference: FBA15FEA74D65D58, C1B15B379433D4E8
// reference: 3CE40A5C137FF209, 62C70CD03ED10B4A
// reference: 2E51A5B227FFC00F, 62C70CD03ED10B4A
// reference: D2BFA5DEB67D0CDA, 36FBAA27E5920598
// reference: F2AA84D0BB74973F, CDD7AB422818C224
// reference: FBA15FEA0DC296BE, C1B15B379433D4E8
// program: CDD7AB422818C224, 42937135801BAA7E, 29CD3EBE51FAA42A
// program: CDD7AB422818C224, 42937135801BAA7E, B2E64CFB9744D892
// program: CDD7AB422818C224, 42937135801BAA7E, 98647FD3CF93B689
// reference: FBA15FEACF47188A, C1B15B379433D4E8
// program: 27B560CBF361F4CF, 082670B4222015B2, DBA0F8FE46AD8D9B
// program: A147DA9530FE3B39, 082670B4222015B2, DBA0F8FE46AD8D9B
// program: A147DA9530FE3B39, 082670B4222015B2, F4A415D97E9B6ED6
// program: CDD7AB422818C224, 42937135801BAA7E, AB0D786CFAD777F8
// reference: 04765DE95D89C1E2, C1B15B379433D4E8
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, 6A44D3E672630106
// program: 2C776115811B5DFC, B80FA1B7F97410CD, 0AC00F84117E7EFC
// reference: 6A295DFC80324FF8, A16B0AB362B8E38B
// program: A16B0AB362B8E38B, B80FA1B7F97410CD, B3C2F6056AADCF6F
// reference: CB71EA0128A228DF, A16B0AB362B8E38B
// program: A16B0AB362B8E38B, B80FA1B7F97410CD, A36D1D6BA424DB28
// program: A16B0AB362B8E38B, B80FA1B7F97410CD, 641FDB3E9E36B758
// reference: 467380E43EE0A2C3, 27B560CBF361F4CF
// program: 27B560CBF361F4CF, 082670B4222015B2, 1430EF96EBF7840F
// program: 2BD70906436FAF24, B80FA1B7F97410CD, C2EEBEAE0D7F3560
// program: 36FBAA27E5920598, B80FA1B7F97410CD, 9D0535C6802495CB
// program: 27B560CBF361F4CF, 082670B4222015B2, 63A5270519B4AE20
// reference: 889B60F338DD96EC, A147DA9530FE3B39
// reference: 889B60F33135F6E9, A147DA9530FE3B39
// program: CDD7AB422818C224, 42937135801BAA7E, 49F399BDFAD777F8
// program: CDD7AB422818C224, 42937135801BAA7E, 00F9BB7ACF93B689
// reference: C2B37B9904BDC7DB, 0C474BA5D3CDF544
// program: 0C474BA5D3CDF544, B80FA1B7F97410CD, B766CBB102E471E4
// reference: 7968FD3E44F258D1, 62C70CD03ED10B4A
// reference: 6BDD52D070726AD7, 62C70CD03ED10B4A
// reference: 494D11287373AE85, 628B798B65C30A4B
// program: 628B798B65C30A4B, 082670B4222015B2, DBA0F8FE46AD8D9B
// reference: B9A482E769103EAE, 2943A920476E1E56
// reference: 0D7D86D312E8DA5D, CDD7AB422818C224
// reference: 04765DE9A45EDBDC, C1B15B379433D4E8
// reference: 2F0F12B62782B908, 01B0CF4127F43ED8
// reference: C2B37B99FD6ADDE5, 0C474BA5D3CDF544
// reference: 7968FD3EBD2542EF, 62C70CD03ED10B4A
// reference: 6BDD52D089A570E9, 62C70CD03ED10B4A
// reference: 2D68A7DD4FAA16E4, 36FBAA27E5920598
// program: 628B798B65C30A4B, 082670B4222015B2, 558A6C807844C0F3
// reference: D186A7B16BF35C8B, 62C70CD03ED10B4A
// reference: 2F0F12B68D644EC5, 15E048F2F07F2E01
// program: 15E048F2F07F2E01, B80FA1B7F97410CD, 5741FC947D667CFB
// program: 15E048F2F07F2E01, B80FA1B7F97410CD, 5FF3DF19FAD860D6
// program: 628B798B65C30A4B, 082670B4222015B2, 1430EF96707A019C
// reference: 467380E47DD48F63, 27B560CBF361F4CF
// program: A147DA9530FE3B39, 082670B4222015B2, 63A5270519B4AE20
// reference: C333085F5F736E8D, 62C70CD03ED10B4A
// reference: 9A52235052ABAD88, 2BD70906436FAF24
// shader: 8B30, 074DEDECEBF7840F

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) + (texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.r) * (texcolor1.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_2 = byteround(clamp((vec3(1.0) - combiner_buffer.rgb) * (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D25071E8B26CD5C1, 074DEDECEBF7840F
// program: 628B798B65C30A4B, 082670B4222015B2, 074DEDECEBF7840F
// reference: 9A522350AB7CB7B6, 2BD70906436FAF24
// program: 628B798B65C30A4B, 082670B4222015B2, 63A5270519B4AE20
// shader: 8B30, B51C0DE019B4AE20

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_2 = byteround(clamp((vec3(1.0) - combiner_buffer.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: AE3D27E908602FB1, B51C0DE019B4AE20
// program: A147DA9530FE3B39, 082670B4222015B2, B51C0DE019B4AE20
// reference: AB112D094B7E85D7, 2943A920476E1E56
// shader: 8B30, 1EF23692707A019C

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.r) + (texcolor1.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_2 = byteround(clamp((vec3(1.0) - combiner_buffer.rgb) * (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 70D611D1B26CD5C1, 1EF23692707A019C
// program: 2943A920476E1E56, 082670B4222015B2, 1EF23692707A019C
// shader: 8B30, 0D8F34E8707A019C

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) + (texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.r) + (texcolor1.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_2 = byteround(clamp((vec3(1.0) - combiner_buffer.rgb) * (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: C874F9B1B26CD5C1, 0D8F34E8707A019C
// program: 2943A920476E1E56, 082670B4222015B2, 0D8F34E8707A019C
// reference: 9A2ECF1D6824286A, A147DA9530FE3B39
// program: 01B0CF4127F43ED8, B80FA1B7F97410CD, FFE5F81052CAA889
// reference: DE1D5C5F314B486A, 502AB780D80D09C1
// reference: 61E9358D0F2A7F15, 502AB780D80D09C1
// reference: 7A574159CB23C7B6, D9C174A4A54356AC
// reference: EB2643F01EC424BA, D2A401390BA8C9C0
// reference: F122CACE6952708D, D9C174A4A54356AC
// reference: E3976520B2EBD1CA, D9C174A4A54356AC
// reference: E39765201BEDC9AF, D9C174A4A54356AC
// reference: C9703DCE32DA6F21, 35CCCCDE75E2FF83
// reference: DBC592204065D603, 35CCCCDE75E2FF83
// reference: 1230F5457F0309FC, 4CDB2C6E0A14815D
// reference: 00855AAB0DBCB0DE, 4CDB2C6E0A14815D
// reference: D3505EAB1F314CEC, E81D148B6EF003F8
// reference: C1E5F1456D8EF5CE, E81D148B6EF003F8
// reference: C1E5F1452BB17EEA, E81D148B6EF003F8
// reference: ACED8BFF386BD04C, 87E005DC9696CDE3
// reference: A5B2D3670E16CA16, 502AB780D80D09C1
// reference: B7077C89614B0AD4, 502AB780D80D09C1
// reference: F122CACECFCBFE5F, D9C174A4A54356AC
// reference: E397652014725F18, D9C174A4A54356AC
// reference: C1E5F145C488EDAB, E81D148B6EF003F8
// reference: DE1D5C5F314B486A, 502AB780D80D09C1
// reference: 61E9358D0F2A7F15, 502AB780D80D09C1
// reference: DE1D5C5F314B486A, 502AB780D80D09C1
// reference: 61E9358D0F2A7F15, 502AB780D80D09C1
// reference: 4A907AD2E6683D40, E81D148B6EF003F8
// reference: 5825D53C94D78462, E81D148B6EF003F8
// reference: 5825D53CD2E80F46, E81D148B6EF003F8
// reference: 352DAF86C132A1E0, 87E005DC9696CDE3
// reference: 3C72F71EF74FBBBA, 502AB780D80D09C1
// reference: 2EC758F098127B78, 502AB780D80D09C1
// reference: 68E2EEB736928FF3, D9C174A4A54356AC
// reference: 7A574159ED2B2EB4, D9C174A4A54356AC
// reference: 5825D53C3DD19C07, E81D148B6EF003F8
// reference: CCA8F3B1314B486A, 502AB780D80D09C1
// reference: 7A574159B99C7E94, D9C174A4A54356AC
// reference: 735C9A630F2A7F15, 502AB780D80D09C1
// reference: 5825D53CE6683D40, E81D148B6EF003F8
// reference: 2EC758F0F74FBBBA, 502AB780D80D09C1
// reference: 7A57415936928FF3, D9C174A4A54356AC
// reference: DE1D5C5F314B486A, 502AB780D80D09C1
// reference: 61E9358D0F2A7F15, 502AB780D80D09C1
// reference: CCA8F3B1314B486A, 502AB780D80D09C1
// reference: 7A574159B99C7E94, D9C174A4A54356AC
// reference: 735C9A630F2A7F15, 502AB780D80D09C1
// reference: BE5824110CEBE24A, 87E005DC9696CDE3
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 7ED2F034E5EB4FC6
// program: E81D148B6EF003F8, B80FA1B7F97410CD, BC32652205728950
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 10AAC2A3349D1A7E
// program: D9C174A4A54356AC, 42937135801BAA7E, 52F5F74AF1B519B6
// program: D9C174A4A54356AC, 42937135801BAA7E, 98F0722A788E01FD
// program: D9C174A4A54356AC, 42937135801BAA7E, 6E5C02D38B9C02DF
// program: D9C174A4A54356AC, 42937135801BAA7E, A4E2954DD6C4FB71
// program: D0293423BD9EA1E7, B80FA1B7F97410CD, 19F7816C4117CF8E
// program: D9C174A4A54356AC, 42937135801BAA7E, 5FBCCF5F27F5A7C1
// reference: F122CACEB6DF35B9, D9C174A4A54356AC
// program: D9C174A4A54356AC, 42937135801BAA7E, 63B6ADAD25C2A518
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 47E4BEE6B3304AF3
// program: E81D148B6EF003F8, B80FA1B7F97410CD, C580B429ECAF519A
// reference: AA13BDCB1F314CEC, E81D148B6EF003F8
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 4BA25B84A31C492A
// program: D9C174A4A54356AC, 42937135801BAA7E, 6B98A4CC666FCBCF
// program: D9C174A4A54356AC, 42937135801BAA7E, D1257B6267770D05
// program: D9C174A4A54356AC, 42937135801BAA7E, D134C63316570D84
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 40FC95A67F54598B
// program: E81D148B6EF003F8, B80FA1B7F97410CD, D69A3CB52F0E3495
// program: E81D148B6EF003F8, B80FA1B7F97410CD, B5CB613BFC4BC41C
// program: 502AB780D80D09C1, B80FA1B7F97410CD, 1B4DA8DA884D39A1
// program: E81D148B6EF003F8, B80FA1B7F97410CD, D2BD0C5FAA2AB273
// program: E81D148B6EF003F8, B80FA1B7F97410CD, F8FBCC791CAC22F2
// program: E81D148B6EF003F8, B80FA1B7F97410CD, FEE7FD4C7FD3D731
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 8633243B2123B710
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 39E142A8F1F39B96
// program: E81D148B6EF003F8, B80FA1B7F97410CD, FC9E10BE42F07103
// program: 1BDE5ABD20055F26, 082670B4222015B2, DBA0F8FE46AD8D9B
// program: D9C174A4A54356AC, 42937135801BAA7E, 47A8279A60685F27
// reference: 1FC8293D1AAF6F08, D9C174A4A54356AC
// reference: 3DBABD582FC50C5D, E81D148B6EF003F8
// reference: 1FC8293D862B7508, D9C174A4A54356AC
// program: 5E28DB645EED49B7, B80FA1B7F97410CD, C2EEBEAE0D7F3560
// reference: D186A7B15734DBD8, 5E28DB645EED49B7
// reference: 40A37A2A3C7B864E, 35CCCCDE75E2FF83
// program: A40B5D829674D1F8, B80FA1B7F97410CD, 1CBA1DD1EAE2F663
// reference: 3FDD083347EDA3B1, A40B5D829674D1F8
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 6A08A79BE3FAC39D
// program: D0293423BD9EA1E7, B80FA1B7F97410CD, 10AAC2A3349D1A7E
// reference: AA13BDCBB5D7BB21, D0293423BD9EA1E7
// reference: 54C62F0AF3995293, 49AB6B882020674A
// program: 49AB6B882020674A, 082670B4222015B2, 0D19D21B46AD8D9B
// reference: E01F2B3E8861B660, D9C174A4A54356AC
// reference: C26DBF5B9A1E8AE7, E81D148B6EF003F8
// reference: E01F2B3E33F0F3B2, D9C174A4A54356AC
// reference: 2E51A5B2E2EF5D62, 5E28DB645EED49B7
// reference: BF74782989A000F4, 35CCCCDE75E2FF83
// reference: C00A0A3047EDA3B1, A40B5D829674D1F8
// reference: E01F2B3E4AE43854, D9C174A4A54356AC
// program: D9C174A4A54356AC, 42937135801BAA7E, 29CD3EBE51FAA42A
// program: D9C174A4A54356AC, 42937135801BAA7E, B2E64CFB9744D892
// program: D9C174A4A54356AC, 42937135801BAA7E, 98647FD3CF93B689
// program: 49AB6B882020674A, 082670B4222015B2, DBA0F8FE46AD8D9B
// reference: 9A2ECF1DF5A466BC, 70A370D21404144E
// program: 70A370D21404144E, 082670B4222015B2, DBA0F8FE46AD8D9B
// program: 70A370D21404144E, 082670B4222015B2, F4A415D97E9B6ED6
// program: D9C174A4A54356AC, 42937135801BAA7E, AB0D786CFAD777F8
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 6A44D3E672630106
// program: 35CCCCDE75E2FF83, B80FA1B7F97410CD, 0AC00F84117E7EFC
// reference: 789CF21271A2E093, 4CDB2C6E0A14815D
// program: 4CDB2C6E0A14815D, B80FA1B7F97410CD, A36D1D6BA424DB28
// reference: D9C445EFD93287B4, 4CDB2C6E0A14815D
// program: 4CDB2C6E0A14815D, B80FA1B7F97410CD, 641FDB3E9E36B758
// program: 49AB6B882020674A, 082670B4222015B2, 1430EF96EBF7840F
// reference: 54C62F0ACF700DA8, 49AB6B882020674A
// reference: 88E78CBEA33B02E3, 4028512EA840631E
// program: 4028512EA840631E, B80FA1B7F97410CD, C2EEBEAE0D7F3560
// program: A40B5D829674D1F8, B80FA1B7F97410CD, 9D0535C6802495CB
// reference: 9A2ECF1DC94D3987, 70A370D21404144E
// program: 49AB6B882020674A, 082670B4222015B2, 63A5270519B4AE20
// reference: 9A2ECF1DC0A55982, 70A370D21404144E
// program: D9C174A4A54356AC, 42937135801BAA7E, 49F399BDFAD777F8
// program: D9C174A4A54356AC, 42937135801BAA7E, 00F9BB7ACF93B689
// program: 3526EFD6EA584B4A, B80FA1B7F97410CD, B766CBB102E471E4
// reference: 6BDD52D0B562F7BA, 5E28DB645EED49B7
// reference: 32BC79DF416D2E81, 4028512EA840631E
// program: 70A370D21404144E, 082670B4222015B2, B51C0DE019B4AE20
// reference: AB112D0961578BFB, 1BDE5ABD20055F26
// program: 1BDE5ABD20055F26, 082670B4222015B2, 1EF23692707A019C
// program: 1BDE5ABD20055F26, 082670B4222015B2, 0D8F34E8707A019C
// reference: 9A2ECF1D420D2646, 70A370D21404144E
// program: 70A370D21404144E, 082670B4222015B2, 63A5270519B4AE20
// reference: 50B2C7E23C1FA2FB, 87E005DC9696CDE3
// reference: 4B5830943EE28AA7, 502AB780D80D09C1
// reference: 1FC8293DFF3FBEEE, D9C174A4A54356AC
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 7ED2F034E5EB4FC6
// program: E81D148B6EF003F8, B80FA1B7F97410CD, BC32652205728950
// shader: 8B30, 3018EA11DFB984D3

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].aaa);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: A7F8FF28BFCAF14E, 3018EA11DFB984D3
// program: D9C174A4A54356AC, 42937135801BAA7E, 3018EA11DFB984D3
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 10AAC2A3349D1A7E
// program: D9C174A4A54356AC, 42937135801BAA7E, 52F5F74AF1B519B6
// program: D9C174A4A54356AC, 42937135801BAA7E, 98F0722A788E01FD
// program: D9C174A4A54356AC, 42937135801BAA7E, 6E5C02D38B9C02DF
// program: D9C174A4A54356AC, 42937135801BAA7E, A4E2954DD6C4FB71
// shader: 8B30, 5F0787304B8A0BD1

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].aaa);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (const_color[2].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 488D06B4582FC4CA, 5F0787304B8A0BD1
// program: D9C174A4A54356AC, 42937135801BAA7E, 5F0787304B8A0BD1
// program: D0293423BD9EA1E7, B80FA1B7F97410CD, 19F7816C4117CF8E
// program: D9C174A4A54356AC, 42937135801BAA7E, 5FBCCF5F27F5A7C1
// program: D9C174A4A54356AC, 42937135801BAA7E, 63B6ADAD25C2A518
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 47E4BEE6B3304AF3
// program: E81D148B6EF003F8, B80FA1B7F97410CD, C580B429ECAF519A
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 4BA25B84A31C492A
// program: D9C174A4A54356AC, 42937135801BAA7E, 6B98A4CC666FCBCF
// program: D9C174A4A54356AC, 42937135801BAA7E, D1257B6267770D05
// program: D9C174A4A54356AC, 42937135801BAA7E, D134C63316570D84
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 40FC95A67F54598B
// program: E81D148B6EF003F8, B80FA1B7F97410CD, D69A3CB52F0E3495
// program: E81D148B6EF003F8, B80FA1B7F97410CD, B5CB613BFC4BC41C
// program: 502AB780D80D09C1, B80FA1B7F97410CD, 1B4DA8DA884D39A1
// program: E81D148B6EF003F8, B80FA1B7F97410CD, D2BD0C5FAA2AB273
// program: E81D148B6EF003F8, B80FA1B7F97410CD, F8FBCC791CAC22F2
// program: E81D148B6EF003F8, B80FA1B7F97410CD, FEE7FD4C7FD3D731
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 8633243B2123B710
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 39E142A8F1F39B96
// program: E81D148B6EF003F8, B80FA1B7F97410CD, FC9E10BE42F07103
// program: 1BDE5ABD20055F26, 082670B4222015B2, DBA0F8FE46AD8D9B
// program: D9C174A4A54356AC, 42937135801BAA7E, 47A8279A60685F27
// program: 4028512EA840631E, B80FA1B7F97410CD, C2EEBEAE0D7F3560
// program: 35CCCCDE75E2FF83, B80FA1B7F97410CD, 0AC00F84117E7EFC
// program: A40B5D829674D1F8, B80FA1B7F97410CD, 9D0535C6802495CB
// program: A40B5D829674D1F8, B80FA1B7F97410CD, 429F87F8D3AE0B36
// program: A40B5D829674D1F8, B80FA1B7F97410CD, 40BF4FB85B0B5330
// program: A40B5D829674D1F8, B80FA1B7F97410CD, EE82356499D9033F
// program: A40B5D829674D1F8, B80FA1B7F97410CD, 5F16273C5032C0B2
// program: A40B5D829674D1F8, B80FA1B7F97410CD, BC8FFFD904DA352D
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 6A08A79BE3FAC39D
// program: D0293423BD9EA1E7, B80FA1B7F97410CD, 10AAC2A3349D1A7E
// program: 49AB6B882020674A, 082670B4222015B2, 0D19D21B46AD8D9B
// reference: 396471FD9515E22B, 4028512EA840631E
// reference: 77308EBD16E08459, 4028512EA840631E
// program: D9C174A4A54356AC, 42937135801BAA7E, 29CD3EBE51FAA42A
// program: D9C174A4A54356AC, 42937135801BAA7E, B2E64CFB9744D892
// program: D9C174A4A54356AC, 42937135801BAA7E, 98647FD3CF93B689
// program: 49AB6B882020674A, 082670B4222015B2, DBA0F8FE46AD8D9B
// program: 70A370D21404144E, 082670B4222015B2, DBA0F8FE46AD8D9B
// program: 70A370D21404144E, 082670B4222015B2, F4A415D97E9B6ED6
// program: D9C174A4A54356AC, 42937135801BAA7E, AB0D786CFAD777F8
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 6A44D3E672630106
// program: 4CDB2C6E0A14815D, B80FA1B7F97410CD, A36D1D6BA424DB28
// program: 4CDB2C6E0A14815D, B80FA1B7F97410CD, 641FDB3E9E36B758
// program: 49AB6B882020674A, 082670B4222015B2, 1430EF96EBF7840F
// program: 49AB6B882020674A, 082670B4222015B2, 63A5270519B4AE20
// program: D9C174A4A54356AC, 42937135801BAA7E, 49F399BDFAD777F8
// program: D9C174A4A54356AC, 42937135801BAA7E, 00F9BB7ACF93B689
// program: 3526EFD6EA584B4A, B80FA1B7F97410CD, B766CBB102E471E4
// reference: 7CE8869FC29848F3, 4028512EA840631E
// program: 8AA3B6DF4767940E, 082670B4222015B2, DBA0F8FE46AD8D9B
// reference: 1FC8293DE3787536, D9C174A4A54356AC
// reference: 3DBABD58D6121663, E81D148B6EF003F8
// reference: 7CE8869F3B4F52CD, 4028512EA840631E
// reference: 32BC79DFB8BA34BF, 4028512EA840631E
// reference: 88E78CBE5AEC18DD, 4028512EA840631E
// reference: 40A37A2AC5AC9C70, 35CCCCDE75E2FF83
// reference: 3FDD0833BE3AB98F, A40B5D829674D1F8
// program: 8AA3B6DF4767940E, 082670B4222015B2, 558A6C807844C0F3
// reference: 5BF8BEC682E301EE, 8AA3B6DF4767940E
// reference: 54C62F0A8C442008, 49AB6B882020674A
// program: D0293423BD9EA1E7, B80FA1B7F97410CD, 5741FC947D667CFB
// reference: 3DBABD587CF4E1AE, D0293423BD9EA1E7
// program: D0293423BD9EA1E7, B80FA1B7F97410CD, 5FF3DF19FAD860D6
// reference: 95072FBC82E301EE, 8AA3B6DF4767940E
// program: 8AA3B6DF4767940E, 082670B4222015B2, 1430EF96707A019C
// reference: EDE38F4351348217, D0293423BD9EA1E7
// reference: 9A2ECF1D8A791427, 70A370D21404144E
// program: 70A370D21404144E, 082670B4222015B2, 63A5270519B4AE20
// reference: F7394D2D82E301EE, 8AA3B6DF4767940E
// reference: C6B373FED9197EAF, 4028512EA840631E
// program: 5E28DB645EED49B7, B80FA1B7F97410CD, C2EEBEAE0D7F3560
// program: A40B5D829674D1F8, B80FA1B7F97410CD, 1CBA1DD1EAE2F663
// program: 70A370D21404144E, 082670B4222015B2, B51C0DE019B4AE20
// program: 1BDE5ABD20055F26, 082670B4222015B2, 1EF23692707A019C
// program: 1BDE5ABD20055F26, 082670B4222015B2, 0D8F34E8707A019C
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 7ED2F034E5EB4FC6
// program: E81D148B6EF003F8, B80FA1B7F97410CD, BC32652205728950
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 10AAC2A3349D1A7E
// program: D9C174A4A54356AC, 42937135801BAA7E, 52F5F74AF1B519B6
// program: D9C174A4A54356AC, 42937135801BAA7E, 98F0722A788E01FD
// program: D9C174A4A54356AC, 42937135801BAA7E, 6E5C02D38B9C02DF
// program: D9C174A4A54356AC, 42937135801BAA7E, A4E2954DD6C4FB71
// program: D0293423BD9EA1E7, B80FA1B7F97410CD, 19F7816C4117CF8E
// program: D9C174A4A54356AC, 42937135801BAA7E, 5FBCCF5F27F5A7C1
// program: D9C174A4A54356AC, 42937135801BAA7E, 63B6ADAD25C2A518
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 47E4BEE6B3304AF3
// program: E81D148B6EF003F8, B80FA1B7F97410CD, C580B429ECAF519A
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 4BA25B84A31C492A
// program: D9C174A4A54356AC, 42937135801BAA7E, 6B98A4CC666FCBCF
// program: D9C174A4A54356AC, 42937135801BAA7E, D1257B6267770D05
// program: D9C174A4A54356AC, 42937135801BAA7E, D134C63316570D84
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 40FC95A67F54598B
// program: E81D148B6EF003F8, B80FA1B7F97410CD, D69A3CB52F0E3495
// program: E81D148B6EF003F8, B80FA1B7F97410CD, B5CB613BFC4BC41C
// program: 502AB780D80D09C1, B80FA1B7F97410CD, 1B4DA8DA884D39A1
// program: E81D148B6EF003F8, B80FA1B7F97410CD, D2BD0C5FAA2AB273
// program: E81D148B6EF003F8, B80FA1B7F97410CD, F8FBCC791CAC22F2
// program: E81D148B6EF003F8, B80FA1B7F97410CD, FEE7FD4C7FD3D731
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 8633243B2123B710
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 39E142A8F1F39B96
// program: E81D148B6EF003F8, B80FA1B7F97410CD, FC9E10BE42F07103
// program: 1BDE5ABD20055F26, 082670B4222015B2, DBA0F8FE46AD8D9B
// program: D9C174A4A54356AC, 42937135801BAA7E, 47A8279A60685F27
// program: 5E28DB645EED49B7, B80FA1B7F97410CD, C2EEBEAE0D7F3560
// program: A40B5D829674D1F8, B80FA1B7F97410CD, 1CBA1DD1EAE2F663
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 6A08A79BE3FAC39D
// program: D0293423BD9EA1E7, B80FA1B7F97410CD, 10AAC2A3349D1A7E
// program: 49AB6B882020674A, 082670B4222015B2, 0D19D21B46AD8D9B
// program: D9C174A4A54356AC, 42937135801BAA7E, 29CD3EBE51FAA42A
// program: D9C174A4A54356AC, 42937135801BAA7E, B2E64CFB9744D892
// program: D9C174A4A54356AC, 42937135801BAA7E, 98647FD3CF93B689
// program: 49AB6B882020674A, 082670B4222015B2, DBA0F8FE46AD8D9B
// program: 70A370D21404144E, 082670B4222015B2, DBA0F8FE46AD8D9B
// program: 70A370D21404144E, 082670B4222015B2, F4A415D97E9B6ED6
// program: D9C174A4A54356AC, 42937135801BAA7E, AB0D786CFAD777F8
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 6A44D3E672630106
// program: 35CCCCDE75E2FF83, B80FA1B7F97410CD, 0AC00F84117E7EFC
// program: 4CDB2C6E0A14815D, B80FA1B7F97410CD, A36D1D6BA424DB28
// program: 4CDB2C6E0A14815D, B80FA1B7F97410CD, 641FDB3E9E36B758
// program: 49AB6B882020674A, 082670B4222015B2, 1430EF96EBF7840F
// program: 4028512EA840631E, B80FA1B7F97410CD, C2EEBEAE0D7F3560
// program: A40B5D829674D1F8, B80FA1B7F97410CD, 9D0535C6802495CB
// program: 49AB6B882020674A, 082670B4222015B2, 63A5270519B4AE20
// program: D9C174A4A54356AC, 42937135801BAA7E, 49F399BDFAD777F8
// program: D9C174A4A54356AC, 42937135801BAA7E, 00F9BB7ACF93B689
// program: 3526EFD6EA584B4A, B80FA1B7F97410CD, B766CBB102E471E4
// program: 70A370D21404144E, 082670B4222015B2, B51C0DE019B4AE20
// program: 1BDE5ABD20055F26, 082670B4222015B2, 1EF23692707A019C
// program: 1BDE5ABD20055F26, 082670B4222015B2, 0D8F34E8707A019C
// program: 70A370D21404144E, 082670B4222015B2, 63A5270519B4AE20
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 7ED2F034E5EB4FC6
// program: E81D148B6EF003F8, B80FA1B7F97410CD, BC32652205728950
// program: D9C174A4A54356AC, 42937135801BAA7E, 3018EA11DFB984D3
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 10AAC2A3349D1A7E
// program: D9C174A4A54356AC, 42937135801BAA7E, 52F5F74AF1B519B6
// program: D9C174A4A54356AC, 42937135801BAA7E, 98F0722A788E01FD
// program: D9C174A4A54356AC, 42937135801BAA7E, 6E5C02D38B9C02DF
// program: D9C174A4A54356AC, 42937135801BAA7E, A4E2954DD6C4FB71
// program: D9C174A4A54356AC, 42937135801BAA7E, 5F0787304B8A0BD1
// program: D0293423BD9EA1E7, B80FA1B7F97410CD, 19F7816C4117CF8E
// program: D9C174A4A54356AC, 42937135801BAA7E, 5FBCCF5F27F5A7C1
// program: D9C174A4A54356AC, 42937135801BAA7E, 63B6ADAD25C2A518
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 47E4BEE6B3304AF3
// program: E81D148B6EF003F8, B80FA1B7F97410CD, C580B429ECAF519A
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 4BA25B84A31C492A
// program: D9C174A4A54356AC, 42937135801BAA7E, 6B98A4CC666FCBCF
// program: D9C174A4A54356AC, 42937135801BAA7E, D1257B6267770D05
// program: D9C174A4A54356AC, 42937135801BAA7E, D134C63316570D84
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 40FC95A67F54598B
// program: E81D148B6EF003F8, B80FA1B7F97410CD, D69A3CB52F0E3495
// program: E81D148B6EF003F8, B80FA1B7F97410CD, B5CB613BFC4BC41C
// program: 502AB780D80D09C1, B80FA1B7F97410CD, 1B4DA8DA884D39A1
// program: E81D148B6EF003F8, B80FA1B7F97410CD, D2BD0C5FAA2AB273
// program: E81D148B6EF003F8, B80FA1B7F97410CD, F8FBCC791CAC22F2
// program: E81D148B6EF003F8, B80FA1B7F97410CD, FEE7FD4C7FD3D731
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 8633243B2123B710
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 39E142A8F1F39B96
// program: E81D148B6EF003F8, B80FA1B7F97410CD, FC9E10BE42F07103
// program: 1BDE5ABD20055F26, 082670B4222015B2, DBA0F8FE46AD8D9B
// program: D9C174A4A54356AC, 42937135801BAA7E, 47A8279A60685F27
// program: 5E28DB645EED49B7, B80FA1B7F97410CD, C2EEBEAE0D7F3560
// program: A40B5D829674D1F8, B80FA1B7F97410CD, 1CBA1DD1EAE2F663
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 6A08A79BE3FAC39D
// program: D0293423BD9EA1E7, B80FA1B7F97410CD, 10AAC2A3349D1A7E
// program: 49AB6B882020674A, 082670B4222015B2, 0D19D21B46AD8D9B
// program: D9C174A4A54356AC, 42937135801BAA7E, 29CD3EBE51FAA42A
// program: D9C174A4A54356AC, 42937135801BAA7E, B2E64CFB9744D892
// program: D9C174A4A54356AC, 42937135801BAA7E, 98647FD3CF93B689
// program: 49AB6B882020674A, 082670B4222015B2, DBA0F8FE46AD8D9B
// program: 70A370D21404144E, 082670B4222015B2, DBA0F8FE46AD8D9B
// program: 70A370D21404144E, 082670B4222015B2, F4A415D97E9B6ED6
// program: D9C174A4A54356AC, 42937135801BAA7E, AB0D786CFAD777F8
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 6A44D3E672630106
// program: 35CCCCDE75E2FF83, B80FA1B7F97410CD, 0AC00F84117E7EFC
// program: 4CDB2C6E0A14815D, B80FA1B7F97410CD, A36D1D6BA424DB28
// program: 4CDB2C6E0A14815D, B80FA1B7F97410CD, 641FDB3E9E36B758
// program: 49AB6B882020674A, 082670B4222015B2, 1430EF96EBF7840F
// program: 4028512EA840631E, B80FA1B7F97410CD, C2EEBEAE0D7F3560
// program: A40B5D829674D1F8, B80FA1B7F97410CD, 9D0535C6802495CB
// program: 49AB6B882020674A, 082670B4222015B2, 63A5270519B4AE20
// program: D9C174A4A54356AC, 42937135801BAA7E, 49F399BDFAD777F8
// program: D9C174A4A54356AC, 42937135801BAA7E, 00F9BB7ACF93B689
// program: 3526EFD6EA584B4A, B80FA1B7F97410CD, B766CBB102E471E4
// program: 8AA3B6DF4767940E, 082670B4222015B2, DBA0F8FE46AD8D9B
// reference: D186A7B1AEE3C1E6, 5E28DB645EED49B7
// program: 8AA3B6DF4767940E, 082670B4222015B2, 558A6C807844C0F3
// program: D0293423BD9EA1E7, B80FA1B7F97410CD, 5741FC947D667CFB
// program: D0293423BD9EA1E7, B80FA1B7F97410CD, 5FF3DF19FAD860D6
// program: 8AA3B6DF4767940E, 082670B4222015B2, 1430EF96707A019C
// program: 70A370D21404144E, 082670B4222015B2, 63A5270519B4AE20
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 7337CC71AC06DD60
// program: E81D148B6EF003F8, B80FA1B7F97410CD, CF7B55EB749B1745
// program: E81D148B6EF003F8, B80FA1B7F97410CD, F2989B699B9A67E9
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 64E77DF66C1C7766
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 3D2F05F592BCAC45
// program: D9C174A4A54356AC, 42937135801BAA7E, DBAEBC3C69195AAA
// program: D9C174A4A54356AC, 42937135801BAA7E, 62CB16D7F16FAC9B
// program: D9C174A4A54356AC, 42937135801BAA7E, 31DB35D8B8E9549F
// program: D9C174A4A54356AC, 42937135801BAA7E, EB5CA625F01267FB
// program: D9C174A4A54356AC, 42937135801BAA7E, F2C7CEFD4FAFF562
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 7ED2F034E5EB4FC6
// program: E81D148B6EF003F8, B80FA1B7F97410CD, BC32652205728950
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 10AAC2A3349D1A7E
// program: D9C174A4A54356AC, 42937135801BAA7E, 52F5F74AF1B519B6
// program: D9C174A4A54356AC, 42937135801BAA7E, 98F0722A788E01FD
// program: D9C174A4A54356AC, 42937135801BAA7E, 6E5C02D38B9C02DF
// program: D9C174A4A54356AC, 42937135801BAA7E, A4E2954DD6C4FB71
// program: D0293423BD9EA1E7, B80FA1B7F97410CD, 19F7816C4117CF8E
// program: D9C174A4A54356AC, 42937135801BAA7E, 5FBCCF5F27F5A7C1
// program: D9C174A4A54356AC, 42937135801BAA7E, 63B6ADAD25C2A518
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 47E4BEE6B3304AF3
// program: E81D148B6EF003F8, B80FA1B7F97410CD, C580B429ECAF519A
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 4BA25B84A31C492A
// program: D9C174A4A54356AC, 42937135801BAA7E, 6B98A4CC666FCBCF
// program: D9C174A4A54356AC, 42937135801BAA7E, D1257B6267770D05
// program: D9C174A4A54356AC, 42937135801BAA7E, D134C63316570D84
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 40FC95A67F54598B
// program: E81D148B6EF003F8, B80FA1B7F97410CD, D69A3CB52F0E3495
// program: E81D148B6EF003F8, B80FA1B7F97410CD, B5CB613BFC4BC41C
// program: 502AB780D80D09C1, B80FA1B7F97410CD, 1B4DA8DA884D39A1
// program: E81D148B6EF003F8, B80FA1B7F97410CD, D2BD0C5FAA2AB273
// program: E81D148B6EF003F8, B80FA1B7F97410CD, F8FBCC791CAC22F2
// program: E81D148B6EF003F8, B80FA1B7F97410CD, FEE7FD4C7FD3D731
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 8633243B2123B710
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 39E142A8F1F39B96
// program: E81D148B6EF003F8, B80FA1B7F97410CD, FC9E10BE42F07103
// program: 1BDE5ABD20055F26, 082670B4222015B2, DBA0F8FE46AD8D9B
// program: D9C174A4A54356AC, 42937135801BAA7E, 47A8279A60685F27
// program: 5E28DB645EED49B7, B80FA1B7F97410CD, C2EEBEAE0D7F3560
// program: A40B5D829674D1F8, B80FA1B7F97410CD, 1CBA1DD1EAE2F663
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 6A08A79BE3FAC39D
// program: D0293423BD9EA1E7, B80FA1B7F97410CD, 10AAC2A3349D1A7E
// program: 49AB6B882020674A, 082670B4222015B2, 0D19D21B46AD8D9B
// program: D9C174A4A54356AC, 42937135801BAA7E, 29CD3EBE51FAA42A
// program: D9C174A4A54356AC, 42937135801BAA7E, B2E64CFB9744D892
// program: D9C174A4A54356AC, 42937135801BAA7E, 98647FD3CF93B689
// program: 49AB6B882020674A, 082670B4222015B2, DBA0F8FE46AD8D9B
// program: 70A370D21404144E, 082670B4222015B2, DBA0F8FE46AD8D9B
// program: 70A370D21404144E, 082670B4222015B2, F4A415D97E9B6ED6
// program: D9C174A4A54356AC, 42937135801BAA7E, AB0D786CFAD777F8
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 6A44D3E672630106
// program: 35CCCCDE75E2FF83, B80FA1B7F97410CD, 0AC00F84117E7EFC
// program: 4CDB2C6E0A14815D, B80FA1B7F97410CD, A36D1D6BA424DB28
// program: 4CDB2C6E0A14815D, B80FA1B7F97410CD, 641FDB3E9E36B758
// program: 49AB6B882020674A, 082670B4222015B2, 1430EF96EBF7840F
// program: 4028512EA840631E, B80FA1B7F97410CD, C2EEBEAE0D7F3560
// program: A40B5D829674D1F8, B80FA1B7F97410CD, 9D0535C6802495CB
// program: 49AB6B882020674A, 082670B4222015B2, 63A5270519B4AE20
// program: D9C174A4A54356AC, 42937135801BAA7E, 49F399BDFAD777F8
// program: D9C174A4A54356AC, 42937135801BAA7E, 00F9BB7ACF93B689
// program: 3526EFD6EA584B4A, B80FA1B7F97410CD, B766CBB102E471E4
// program: 70A370D21404144E, 082670B4222015B2, B51C0DE019B4AE20
// program: 1BDE5ABD20055F26, 082670B4222015B2, 1EF23692707A019C
// program: 1BDE5ABD20055F26, 082670B4222015B2, 0D8F34E8707A019C
// program: 70A370D21404144E, 082670B4222015B2, 63A5270519B4AE20
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 7ED2F034E5EB4FC6
// program: E81D148B6EF003F8, B80FA1B7F97410CD, BC32652205728950
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 10AAC2A3349D1A7E
// program: D9C174A4A54356AC, 42937135801BAA7E, 52F5F74AF1B519B6
// program: D9C174A4A54356AC, 42937135801BAA7E, 98F0722A788E01FD
// program: D9C174A4A54356AC, 42937135801BAA7E, 6E5C02D38B9C02DF
// program: D9C174A4A54356AC, 42937135801BAA7E, A4E2954DD6C4FB71
// program: D0293423BD9EA1E7, B80FA1B7F97410CD, 19F7816C4117CF8E
// program: D9C174A4A54356AC, 42937135801BAA7E, 5FBCCF5F27F5A7C1
// program: D9C174A4A54356AC, 42937135801BAA7E, 63B6ADAD25C2A518
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 47E4BEE6B3304AF3
// program: E81D148B6EF003F8, B80FA1B7F97410CD, C580B429ECAF519A
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 4BA25B84A31C492A
// program: D9C174A4A54356AC, 42937135801BAA7E, 6B98A4CC666FCBCF
// program: D9C174A4A54356AC, 42937135801BAA7E, D1257B6267770D05
// program: D9C174A4A54356AC, 42937135801BAA7E, D134C63316570D84
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 40FC95A67F54598B
// program: E81D148B6EF003F8, B80FA1B7F97410CD, D69A3CB52F0E3495
// program: E81D148B6EF003F8, B80FA1B7F97410CD, B5CB613BFC4BC41C
// program: 502AB780D80D09C1, B80FA1B7F97410CD, 1B4DA8DA884D39A1
// program: E81D148B6EF003F8, B80FA1B7F97410CD, D2BD0C5FAA2AB273
// program: E81D148B6EF003F8, B80FA1B7F97410CD, F8FBCC791CAC22F2
// program: E81D148B6EF003F8, B80FA1B7F97410CD, FEE7FD4C7FD3D731
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 8633243B2123B710
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 39E142A8F1F39B96
// program: E81D148B6EF003F8, B80FA1B7F97410CD, FC9E10BE42F07103
// program: 1BDE5ABD20055F26, 082670B4222015B2, DBA0F8FE46AD8D9B
// program: D9C174A4A54356AC, 42937135801BAA7E, 47A8279A60685F27
// program: 5E28DB645EED49B7, B80FA1B7F97410CD, C2EEBEAE0D7F3560
// program: A40B5D829674D1F8, B80FA1B7F97410CD, 1CBA1DD1EAE2F663
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 6A08A79BE3FAC39D
// program: D0293423BD9EA1E7, B80FA1B7F97410CD, 10AAC2A3349D1A7E
// program: 49AB6B882020674A, 082670B4222015B2, 0D19D21B46AD8D9B
// program: D9C174A4A54356AC, 42937135801BAA7E, 29CD3EBE51FAA42A
// program: D9C174A4A54356AC, 42937135801BAA7E, B2E64CFB9744D892
// program: D9C174A4A54356AC, 42937135801BAA7E, 98647FD3CF93B689
// program: 49AB6B882020674A, 082670B4222015B2, DBA0F8FE46AD8D9B
// program: 70A370D21404144E, 082670B4222015B2, DBA0F8FE46AD8D9B
// program: 70A370D21404144E, 082670B4222015B2, F4A415D97E9B6ED6
// program: D9C174A4A54356AC, 42937135801BAA7E, AB0D786CFAD777F8
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 6A44D3E672630106
// program: 35CCCCDE75E2FF83, B80FA1B7F97410CD, 0AC00F84117E7EFC
// program: 4CDB2C6E0A14815D, B80FA1B7F97410CD, A36D1D6BA424DB28
// program: 4CDB2C6E0A14815D, B80FA1B7F97410CD, 641FDB3E9E36B758
// program: 49AB6B882020674A, 082670B4222015B2, 1430EF96EBF7840F
// program: 4028512EA840631E, B80FA1B7F97410CD, C2EEBEAE0D7F3560
// program: A40B5D829674D1F8, B80FA1B7F97410CD, 9D0535C6802495CB
// program: 49AB6B882020674A, 082670B4222015B2, 63A5270519B4AE20
// program: D9C174A4A54356AC, 42937135801BAA7E, 49F399BDFAD777F8
// program: D9C174A4A54356AC, 42937135801BAA7E, 00F9BB7ACF93B689
// program: 3526EFD6EA584B4A, B80FA1B7F97410CD, B766CBB102E471E4
// program: 8AA3B6DF4767940E, 082670B4222015B2, DBA0F8FE46AD8D9B
// program: 8AA3B6DF4767940E, 082670B4222015B2, 558A6C807844C0F3
// program: D0293423BD9EA1E7, B80FA1B7F97410CD, 5741FC947D667CFB
// program: D0293423BD9EA1E7, B80FA1B7F97410CD, 5FF3DF19FAD860D6
// program: 8AA3B6DF4767940E, 082670B4222015B2, 1430EF96707A019C
// program: 70A370D21404144E, 082670B4222015B2, 63A5270519B4AE20
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 7337CC71AC06DD60
// program: E81D148B6EF003F8, B80FA1B7F97410CD, CF7B55EB749B1745
// program: E81D148B6EF003F8, B80FA1B7F97410CD, F2989B699B9A67E9
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 64E77DF66C1C7766
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 3D2F05F592BCAC45
// program: D9C174A4A54356AC, 42937135801BAA7E, DBAEBC3C69195AAA
// program: D9C174A4A54356AC, 42937135801BAA7E, 62CB16D7F16FAC9B
// program: D9C174A4A54356AC, 42937135801BAA7E, 31DB35D8B8E9549F
// program: D9C174A4A54356AC, 42937135801BAA7E, EB5CA625F01267FB
// program: D9C174A4A54356AC, 42937135801BAA7E, F2C7CEFD4FAFF562
// program: A40B5D829674D1F8, B80FA1B7F97410CD, 429F87F8D3AE0B36
// program: A40B5D829674D1F8, B80FA1B7F97410CD, 40BF4FB85B0B5330
// program: A40B5D829674D1F8, B80FA1B7F97410CD, EE82356499D9033F
// program: A40B5D829674D1F8, B80FA1B7F97410CD, 5F16273C5032C0B2
// program: A40B5D829674D1F8, B80FA1B7F97410CD, BC8FFFD904DA352D
// reference: 3DBABD58BAB5D8C8, 2E530FFFDA886761
// program: 2E530FFFDA886761, B80FA1B7F97410CD, FEE7FD4C7FD3D731
// program: B0CCAE4F9AB69CDA, B80FA1B7F97410CD, C2EEBEAE0D7F3560
// reference: 88E78CBE364BD676, B0CCAE4F9AB69CDA
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 6A44D3E672630106
// program: 2E530FFFDA886761, B80FA1B7F97410CD, FC9E10BE42F07103
// reference: 40A37A2AA90B52DB, 45C9694A57480945
// program: 45C9694A57480945, B80FA1B7F97410CD, 490CACB848ED440A
// program: 45C9694A57480945, B80FA1B7F97410CD, 0AC00F84117E7EFC
// program: D03F0FE4B72A8E86, B80FA1B7F97410CD, 9D0535C6802495CB
// reference: 3FDD0833D29D7724, D03F0FE4B72A8E86
// program: D03F0FE4B72A8E86, B80FA1B7F97410CD, 429F87F8D3AE0B36
// program: D03F0FE4B72A8E86, B80FA1B7F97410CD, 40BF4FB85B0B5330
// program: D03F0FE4B72A8E86, B80FA1B7F97410CD, EE82356499D9033F
// program: D03F0FE4B72A8E86, B80FA1B7F97410CD, 5F16273C5032C0B2
// program: D03F0FE4B72A8E86, B80FA1B7F97410CD, BC8FFFD904DA352D
// program: 1934FF8F80653ACB, B80FA1B7F97410CD, 5C250F6C1418BBD3
// program: C6410D4382B19655, 082670B4222015B2, DBA0F8FE46AD8D9B
// program: 81B0676B862CF405, 42937135801BAA7E, 47A8279A60685F27
// reference: 1FC8293D8FDFBB9D, 81B0676B862CF405
// program: 81B0676B862CF405, 42937135801BAA7E, 49F399BDFAD777F8
// program: 81B0676B862CF405, 42937135801BAA7E, AB0D786CFAD777F8
// program: 81B0676B862CF405, 42937135801BAA7E, 29CD3EBE51FAA42A
// program: 81B0676B862CF405, 42937135801BAA7E, B2E64CFB9744D892
// program: 81B0676B862CF405, 42937135801BAA7E, 98647FD3CF93B689
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 26CF8128A3DDBB83
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 953385FED82E0FD1
// program: 2E530FFFDA886761, B80FA1B7F97410CD, E52C4E220978C964
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 378438FF70532E82
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 9F25A997909124C1
// program: 2E530FFFDA886761, B80FA1B7F97410CD, D2BD0C5FAA2AB273
// program: 2E530FFFDA886761, B80FA1B7F97410CD, F8FBCC791CAC22F2
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 8633243B2123B710
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 39E142A8F1F39B96
// program: 81B0676B862CF405, 42937135801BAA7E, 00F9BB7ACF93B689
// program: 2E530FFFDA886761, B80FA1B7F97410CD, F35E8CA2CAC182F7
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 168DA83A29634DCC
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 576E786439C2EA2F
// program: 2E530FFFDA886761, B80FA1B7F97410CD, FFE5F81052CAA889
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 1471721266F6CFF3
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 90EA57FA2E348842
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 1212B53523129C17
// program: 2E530FFFDA886761, B80FA1B7F97410CD, C9A23B908E5F8ABB
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 7E2D94A79BE7422B
// reference: 50B2C7E2A96F766E, 91D55C04BB07EE32
// program: 91D55C04BB07EE32, B80FA1B7F97410CD, 9342C6596F83F706
// program: 2E530FFFDA886761, B80FA1B7F97410CD, D02B1E1378BD97CF
// program: 2E530FFFDA886761, B80FA1B7F97410CD, B78314A585D12D9C
// program: 2E530FFFDA886761, B80FA1B7F97410CD, DEC6EAEA57FA4325
// program: 2E530FFFDA886761, B80FA1B7F97410CD, D4C50B709583D191
// program: 2E530FFFDA886761, B80FA1B7F97410CD, B20F7E72A7330A13
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 48065A05481CB4B8
// program: 2E530FFFDA886761, B80FA1B7F97410CD, BB80E4A110994B48
// program: 2E530FFFDA886761, B80FA1B7F97410CD, EAAC665924781109
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 0656C780E79F2203
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 31E556E9A7729BF4
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 6C66577708AE1E87
// program: 2E530FFFDA886761, B80FA1B7F97410CD, FC7222C50C6F5038
// program: 2E530FFFDA886761, B80FA1B7F97410CD, D1B1A073730D724F
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 790FB95CC0B11076
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 037898F85F34DE95
// program: 46E991DEB658A5A9, B80FA1B7F97410CD, 91931D139F54748D
// program: 46E991DEB658A5A9, B80FA1B7F97410CD, 5FACCC9E3E0584D2
// reference: 4B583094AB925E32, 46E991DEB658A5A9
// program: 81B0676B862CF405, 42937135801BAA7E, 835CABE3A4B650D2
// program: 81B0676B862CF405, 42937135801BAA7E, F5D54925A6AE705F
// reference: 1FC8293D6A4F6A7B, 81B0676B862CF405
// program: 81B0676B862CF405, 42937135801BAA7E, D4C9E99618707555
// program: 81B0676B862CF405, 42937135801BAA7E, 0951EE62DBCF2390
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 7ED2F034E5EB4FC6
// program: 2E530FFFDA886761, B80FA1B7F97410CD, BC32652205728950
// program: 81B0676B862CF405, 42937135801BAA7E, 21786A34D707A069
// program: 81B0676B862CF405, 42937135801BAA7E, 5124AD903EB19D9F
// program: 81B0676B862CF405, 42937135801BAA7E, 886AC14BAA341C33
// program: 81B0676B862CF405, 42937135801BAA7E, 7C14C907B3CCD849
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 10AAC2A3349D1A7E
// program: 81B0676B862CF405, 42937135801BAA7E, 52F5F74AF1B519B6
// program: 81B0676B862CF405, 42937135801BAA7E, 98F0722A788E01FD
// program: 81B0676B862CF405, 42937135801BAA7E, 6E5C02D38B9C02DF
// program: 81B0676B862CF405, 42937135801BAA7E, A4E2954DD6C4FB71
// program: FD3DADE0E2BC47C9, B80FA1B7F97410CD, 19F7816C4117CF8E
// program: 81B0676B862CF405, 42937135801BAA7E, 5FBCCF5F27F5A7C1
// reference: 1FC8293D135BA19D, 81B0676B862CF405
// program: 81B0676B862CF405, 42937135801BAA7E, 63B6ADAD25C2A518
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 47E4BEE6B3304AF3
// program: 2E530FFFDA886761, B80FA1B7F97410CD, C580B429ECAF519A
// reference: AA13BDCB8A419879, 2E530FFFDA886761
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 4BA25B84A31C492A
// program: 81B0676B862CF405, 42937135801BAA7E, CAB8B665DC444CE4
// reference: F122CACEFC22A418, 81B0676B862CF405
// reference: D3505EAB8A419879, 2E530FFFDA886761
// reference: F122CACE23AFE12C, 81B0676B862CF405
// program: 81B0676B862CF405, 42937135801BAA7E, 6B98A4CC666FCBCF
// program: 81B0676B862CF405, 42937135801BAA7E, D1257B6267770D05
// program: 81B0676B862CF405, 42937135801BAA7E, D134C63316570D84
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 40FC95A67F54598B
// program: 2E530FFFDA886761, B80FA1B7F97410CD, D69A3CB52F0E3495
// program: 2E530FFFDA886761, B80FA1B7F97410CD, B5CB613BFC4BC41C
// program: 46E991DEB658A5A9, B80FA1B7F97410CD, 1B4DA8DA884D39A1
// program: 466184E6A05DFF0F, B80FA1B7F97410CD, C2EEBEAE0D7F3560
// reference: D186A7B1C2440F4D, 466184E6A05DFF0F
// program: D03F0FE4B72A8E86, B80FA1B7F97410CD, 1CBA1DD1EAE2F663
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 6A08A79BE3FAC39D
// program: FD3DADE0E2BC47C9, B80FA1B7F97410CD, 10AAC2A3349D1A7E
// reference: AA13BDCB20A76FB4, FD3DADE0E2BC47C9
// reference: 54C62F0A66E98606, 949D68475595512F
// program: 949D68475595512F, 082670B4222015B2, 0D19D21B46AD8D9B
// reference: E01F2B3E1D1162F5, 81B0676B862CF405
// reference: C26DBF5B0F6E5E72, 2E530FFFDA886761
// reference: E01F2B3EA6802727, 81B0676B862CF405
// reference: 2E51A5B2779F89F7, 466184E6A05DFF0F
// reference: BF7478291CD0D461, 45C9694A57480945
// reference: C00A0A30D29D7724, D03F0FE4B72A8E86
// reference: E01F2B3EDF94ECC1, 81B0676B862CF405
// program: 949D68475595512F, 082670B4222015B2, DBA0F8FE46AD8D9B
// reference: 9A2ECF1D60D4B229, 2FBE2E4ED1D9324C
// program: 2FBE2E4ED1D9324C, 082670B4222015B2, DBA0F8FE46AD8D9B
// program: 2FBE2E4ED1D9324C, 082670B4222015B2, F4A415D97E9B6ED6
// program: 1B722ADD909A7B2D, B80FA1B7F97410CD, B3C2F6056AADCF6F
// reference: 789CF212E4D23406, 1B722ADD909A7B2D
// program: 1B722ADD909A7B2D, B80FA1B7F97410CD, A36D1D6BA424DB28
// reference: D9C445EF4C425321, 1B722ADD909A7B2D
// program: 1B722ADD909A7B2D, B80FA1B7F97410CD, 641FDB3E9E36B758
// program: 949D68475595512F, 082670B4222015B2, 1430EF96EBF7840F
// reference: 54C62F0A5A00D93D, 949D68475595512F
// reference: 9A2ECF1D5C3DED12, 2FBE2E4ED1D9324C
// program: 949D68475595512F, 082670B4222015B2, 63A5270519B4AE20
// reference: 9A2ECF1D55D58D17, 2FBE2E4ED1D9324C
// program: A214E3C9645157AE, B80FA1B7F97410CD, B766CBB102E471E4
// reference: 6BDD52D02012232F, 466184E6A05DFF0F
// reference: 32BC79DFD41DFA14, B0CCAE4F9AB69CDA
// program: 2FBE2E4ED1D9324C, 082670B4222015B2, B51C0DE019B4AE20
// reference: AB112D09F4275F6E, C6410D4382B19655
// program: C6410D4382B19655, 082670B4222015B2, 1EF23692707A019C
// program: C6410D4382B19655, 082670B4222015B2, 0D8F34E8707A019C
// reference: 9A2ECF1DD77DF2D3, 2FBE2E4ED1D9324C
// program: 2FBE2E4ED1D9324C, 082670B4222015B2, 63A5270519B4AE20
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 3013FC5CF83A846B
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 7ED2F034E5EB4FC6
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 26CF8128A3DDBB83
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 953385FED82E0FD1
// program: 2E530FFFDA886761, B80FA1B7F97410CD, E52C4E220978C964
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 378438FF70532E82
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 9F25A997909124C1
// program: 2E530FFFDA886761, B80FA1B7F97410CD, F35E8CA2CAC182F7
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 168DA83A29634DCC
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 576E786439C2EA2F
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 1471721266F6CFF3
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 90EA57FA2E348842
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 1212B53523129C17
// program: 2E530FFFDA886761, B80FA1B7F97410CD, C9A23B908E5F8ABB
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 7E2D94A79BE7422B
// reference: BE582411999B36DF, 91D55C04BB07EE32
// program: 91D55C04BB07EE32, B80FA1B7F97410CD, 9342C6596F83F706
// program: 2E530FFFDA886761, B80FA1B7F97410CD, D02B1E1378BD97CF
// program: 2E530FFFDA886761, B80FA1B7F97410CD, B78314A585D12D9C
// program: 2E530FFFDA886761, B80FA1B7F97410CD, DEC6EAEA57FA4325
// program: 2E530FFFDA886761, B80FA1B7F97410CD, D4C50B709583D191
// program: 2E530FFFDA886761, B80FA1B7F97410CD, B20F7E72A7330A13
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 48065A05481CB4B8
// program: 2E530FFFDA886761, B80FA1B7F97410CD, BB80E4A110994B48
// program: 2E530FFFDA886761, B80FA1B7F97410CD, EAAC665924781109
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 0656C780E79F2203
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 31E556E9A7729BF4
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 6C66577708AE1E87
// program: 2E530FFFDA886761, B80FA1B7F97410CD, FC7222C50C6F5038
// program: 2E530FFFDA886761, B80FA1B7F97410CD, D1B1A073730D724F
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 790FB95CC0B11076
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 037898F85F34DE95
// reference: EBE62C27189378F1, 46E991DEB658A5A9
// program: 46E991DEB658A5A9, B80FA1B7F97410CD, 91931D139F54748D
// program: 46E991DEB658A5A9, B80FA1B7F97410CD, 5FACCC9E3E0584D2
// reference: A5B2D3679B661E83, 46E991DEB658A5A9
// reference: BF76358ED94E4CB8, 81B0676B862CF405
// program: 81B0676B862CF405, 42937135801BAA7E, F5D54925A6AE705F
// reference: F122CACE5ABB2ACA, 81B0676B862CF405
// program: 81B0676B862CF405, 42937135801BAA7E, 835CABE3A4B650D2
// program: 81B0676B862CF405, 42937135801BAA7E, D4C9E99618707555
// program: 81B0676B862CF405, 42937135801BAA7E, 0951EE62DBCF2390
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 7ED2F034E5EB4FC6
// program: 2E530FFFDA886761, B80FA1B7F97410CD, BC32652205728950
// program: 81B0676B862CF405, 42937135801BAA7E, 21786A34D707A069
// program: 81B0676B862CF405, 42937135801BAA7E, 5124AD903EB19D9F
// program: 81B0676B862CF405, 42937135801BAA7E, 886AC14BAA341C33
// program: 81B0676B862CF405, 42937135801BAA7E, 7C14C907B3CCD849
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 10AAC2A3349D1A7E
// program: 81B0676B862CF405, 42937135801BAA7E, 52F5F74AF1B519B6
// program: 81B0676B862CF405, 42937135801BAA7E, 98F0722A788E01FD
// program: 81B0676B862CF405, 42937135801BAA7E, 6E5C02D38B9C02DF
// program: 81B0676B862CF405, 42937135801BAA7E, A4E2954DD6C4FB71
// program: FD3DADE0E2BC47C9, B80FA1B7F97410CD, 19F7816C4117CF8E
// program: 81B0676B862CF405, 42937135801BAA7E, 5FBCCF5F27F5A7C1
// program: 81B0676B862CF405, 42937135801BAA7E, 63B6ADAD25C2A518
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 47E4BEE6B3304AF3
// program: 2E530FFFDA886761, B80FA1B7F97410CD, C580B429ECAF519A
// program: 1934FF8F80653ACB, B80FA1B7F97410CD, 5C250F6C1418BBD3
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 4BA25B84A31C492A
// program: 81B0676B862CF405, 42937135801BAA7E, CAB8B665DC444CE4
// program: 81B0676B862CF405, 42937135801BAA7E, 6B98A4CC666FCBCF
// program: 81B0676B862CF405, 42937135801BAA7E, D1257B6267770D05
// program: 81B0676B862CF405, 42937135801BAA7E, D134C63316570D84
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 40FC95A67F54598B
// program: 2E530FFFDA886761, B80FA1B7F97410CD, D69A3CB52F0E3495
// program: 2E530FFFDA886761, B80FA1B7F97410CD, B5CB613BFC4BC41C
// program: 46E991DEB658A5A9, B80FA1B7F97410CD, 1B4DA8DA884D39A1
// program: 2E530FFFDA886761, B80FA1B7F97410CD, D2BD0C5FAA2AB273
// program: 2E530FFFDA886761, B80FA1B7F97410CD, F8FBCC791CAC22F2
// program: 2E530FFFDA886761, B80FA1B7F97410CD, FEE7FD4C7FD3D731
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 8633243B2123B710
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 39E142A8F1F39B96
// program: 2E530FFFDA886761, B80FA1B7F97410CD, FC9E10BE42F07103
// program: C6410D4382B19655, 082670B4222015B2, DBA0F8FE46AD8D9B
// program: 81B0676B862CF405, 42937135801BAA7E, 47A8279A60685F27
// program: B0CCAE4F9AB69CDA, B80FA1B7F97410CD, C2EEBEAE0D7F3560
// program: 45C9694A57480945, B80FA1B7F97410CD, 490CACB848ED440A
// program: 45C9694A57480945, B80FA1B7F97410CD, 0AC00F84117E7EFC
// program: D03F0FE4B72A8E86, B80FA1B7F97410CD, 9D0535C6802495CB
// program: D03F0FE4B72A8E86, B80FA1B7F97410CD, 429F87F8D3AE0B36
// program: D03F0FE4B72A8E86, B80FA1B7F97410CD, 40BF4FB85B0B5330
// program: D03F0FE4B72A8E86, B80FA1B7F97410CD, EE82356499D9033F
// program: D03F0FE4B72A8E86, B80FA1B7F97410CD, 5F16273C5032C0B2
// program: D03F0FE4B72A8E86, B80FA1B7F97410CD, BC8FFFD904DA352D
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 6A08A79BE3FAC39D
// program: FD3DADE0E2BC47C9, B80FA1B7F97410CD, 10AAC2A3349D1A7E
// program: 949D68475595512F, 082670B4222015B2, 0D19D21B46AD8D9B
// reference: 396471FD006536BE, B0CCAE4F9AB69CDA
// reference: 77308EBD839050CC, B0CCAE4F9AB69CDA
// program: 81B0676B862CF405, 42937135801BAA7E, 29CD3EBE51FAA42A
// program: 81B0676B862CF405, 42937135801BAA7E, B2E64CFB9744D892
// program: 81B0676B862CF405, 42937135801BAA7E, 98647FD3CF93B689
// program: 949D68475595512F, 082670B4222015B2, DBA0F8FE46AD8D9B
// program: 2FBE2E4ED1D9324C, 082670B4222015B2, DBA0F8FE46AD8D9B
// program: 2FBE2E4ED1D9324C, 082670B4222015B2, F4A415D97E9B6ED6
// program: 81B0676B862CF405, 42937135801BAA7E, AB0D786CFAD777F8
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 6A44D3E672630106
// program: 1B722ADD909A7B2D, B80FA1B7F97410CD, B3C2F6056AADCF6F
// program: 1B722ADD909A7B2D, B80FA1B7F97410CD, A36D1D6BA424DB28
// program: 1B722ADD909A7B2D, B80FA1B7F97410CD, 641FDB3E9E36B758
// program: 949D68475595512F, 082670B4222015B2, 1430EF96EBF7840F
// program: 949D68475595512F, 082670B4222015B2, 63A5270519B4AE20
// program: 81B0676B862CF405, 42937135801BAA7E, 49F399BDFAD777F8
// program: 81B0676B862CF405, 42937135801BAA7E, 00F9BB7ACF93B689
// program: A214E3C9645157AE, B80FA1B7F97410CD, B766CBB102E471E4
// reference: 7CE8869F57E89C66, B0CCAE4F9AB69CDA
// program: 493A89E34FC6D4B5, 082670B4222015B2, DBA0F8FE46AD8D9B
// reference: 1FC8293D7608A1A3, 81B0676B862CF405
// reference: 3DBABD584362C2F6, 2E530FFFDA886761
// reference: 7CE8869FAE3F8658, B0CCAE4F9AB69CDA
// reference: 32BC79DF2DCAE02A, B0CCAE4F9AB69CDA
// reference: 88E78CBECF9CCC48, B0CCAE4F9AB69CDA
// reference: 40A37A2A50DC48E5, 45C9694A57480945
// reference: 3FDD08332B4A6D1A, D03F0FE4B72A8E86
// program: 493A89E34FC6D4B5, 082670B4222015B2, 558A6C807844C0F3
// reference: 5BF8BEC61793D57B, 493A89E34FC6D4B5
// reference: 54C62F0A1934F49D, 949D68475595512F
// program: FD3DADE0E2BC47C9, B80FA1B7F97410CD, 5741FC947D667CFB
// reference: 3DBABD58E984353B, FD3DADE0E2BC47C9
// program: FD3DADE0E2BC47C9, B80FA1B7F97410CD, 5FF3DF19FAD860D6
// reference: 95072FBC1793D57B, 493A89E34FC6D4B5
// program: 493A89E34FC6D4B5, 082670B4222015B2, 1430EF96707A019C
// reference: EDE38F43C4445682, FD3DADE0E2BC47C9
// reference: 9A2ECF1D1F09C0B2, 2FBE2E4ED1D9324C
// program: 2FBE2E4ED1D9324C, 082670B4222015B2, 63A5270519B4AE20
// reference: F7394D2D1793D57B, 493A89E34FC6D4B5
// reference: C6B373FE4C69AA3A, B0CCAE4F9AB69CDA
// program: 2E530FFFDA886761, B80FA1B7F97410CD, FFE5F81052CAA889
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 7ED2F034E5EB4FC6
// program: E81D148B6EF003F8, B80FA1B7F97410CD, BC32652205728950
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 10AAC2A3349D1A7E
// program: D9C174A4A54356AC, 42937135801BAA7E, 52F5F74AF1B519B6
// program: D9C174A4A54356AC, 42937135801BAA7E, 98F0722A788E01FD
// program: D9C174A4A54356AC, 42937135801BAA7E, 6E5C02D38B9C02DF
// program: D9C174A4A54356AC, 42937135801BAA7E, A4E2954DD6C4FB71
// program: D0293423BD9EA1E7, B80FA1B7F97410CD, 19F7816C4117CF8E
// program: D9C174A4A54356AC, 42937135801BAA7E, 5FBCCF5F27F5A7C1
// program: D9C174A4A54356AC, 42937135801BAA7E, 63B6ADAD25C2A518
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 47E4BEE6B3304AF3
// program: E81D148B6EF003F8, B80FA1B7F97410CD, C580B429ECAF519A
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 4BA25B84A31C492A
// program: D9C174A4A54356AC, 42937135801BAA7E, 6B98A4CC666FCBCF
// program: D9C174A4A54356AC, 42937135801BAA7E, D1257B6267770D05
// program: D9C174A4A54356AC, 42937135801BAA7E, D134C63316570D84
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 40FC95A67F54598B
// program: E81D148B6EF003F8, B80FA1B7F97410CD, D69A3CB52F0E3495
// program: E81D148B6EF003F8, B80FA1B7F97410CD, B5CB613BFC4BC41C
// program: 502AB780D80D09C1, B80FA1B7F97410CD, 1B4DA8DA884D39A1
// program: E81D148B6EF003F8, B80FA1B7F97410CD, D2BD0C5FAA2AB273
// program: E81D148B6EF003F8, B80FA1B7F97410CD, F8FBCC791CAC22F2
// program: E81D148B6EF003F8, B80FA1B7F97410CD, FEE7FD4C7FD3D731
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 8633243B2123B710
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 39E142A8F1F39B96
// program: E81D148B6EF003F8, B80FA1B7F97410CD, FC9E10BE42F07103
// program: 1BDE5ABD20055F26, 082670B4222015B2, DBA0F8FE46AD8D9B
// program: D9C174A4A54356AC, 42937135801BAA7E, 47A8279A60685F27
// program: 5E28DB645EED49B7, B80FA1B7F97410CD, C2EEBEAE0D7F3560
// program: A40B5D829674D1F8, B80FA1B7F97410CD, 1CBA1DD1EAE2F663
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 6A08A79BE3FAC39D
// program: D0293423BD9EA1E7, B80FA1B7F97410CD, 10AAC2A3349D1A7E
// program: 49AB6B882020674A, 082670B4222015B2, 0D19D21B46AD8D9B
// program: D9C174A4A54356AC, 42937135801BAA7E, 29CD3EBE51FAA42A
// program: D9C174A4A54356AC, 42937135801BAA7E, B2E64CFB9744D892
// program: D9C174A4A54356AC, 42937135801BAA7E, 98647FD3CF93B689
// program: 49AB6B882020674A, 082670B4222015B2, DBA0F8FE46AD8D9B
// program: 70A370D21404144E, 082670B4222015B2, DBA0F8FE46AD8D9B
// program: 70A370D21404144E, 082670B4222015B2, F4A415D97E9B6ED6
// program: D9C174A4A54356AC, 42937135801BAA7E, AB0D786CFAD777F8
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 6A44D3E672630106
// program: 35CCCCDE75E2FF83, B80FA1B7F97410CD, 0AC00F84117E7EFC
// program: 4CDB2C6E0A14815D, B80FA1B7F97410CD, A36D1D6BA424DB28
// program: 4CDB2C6E0A14815D, B80FA1B7F97410CD, 641FDB3E9E36B758
// program: 49AB6B882020674A, 082670B4222015B2, 1430EF96EBF7840F
// program: 4028512EA840631E, B80FA1B7F97410CD, C2EEBEAE0D7F3560
// program: A40B5D829674D1F8, B80FA1B7F97410CD, 9D0535C6802495CB
// program: 49AB6B882020674A, 082670B4222015B2, 63A5270519B4AE20
// program: D9C174A4A54356AC, 42937135801BAA7E, 49F399BDFAD777F8
// program: D9C174A4A54356AC, 42937135801BAA7E, 00F9BB7ACF93B689
// program: 3526EFD6EA584B4A, B80FA1B7F97410CD, B766CBB102E471E4
// program: 8AA3B6DF4767940E, 082670B4222015B2, DBA0F8FE46AD8D9B
// program: 8AA3B6DF4767940E, 082670B4222015B2, 558A6C807844C0F3
// program: D0293423BD9EA1E7, B80FA1B7F97410CD, 5741FC947D667CFB
// program: D0293423BD9EA1E7, B80FA1B7F97410CD, 5FF3DF19FAD860D6
// program: 8AA3B6DF4767940E, 082670B4222015B2, 1430EF96707A019C
// program: 70A370D21404144E, 082670B4222015B2, 63A5270519B4AE20
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 26CF8128A3DDBB83
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 953385FED82E0FD1
// program: 2E530FFFDA886761, B80FA1B7F97410CD, E52C4E220978C964
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 378438FF70532E82
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 9F25A997909124C1
// program: 2E530FFFDA886761, B80FA1B7F97410CD, F35E8CA2CAC182F7
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 168DA83A29634DCC
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 576E786439C2EA2F
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 1471721266F6CFF3
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 90EA57FA2E348842
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 1212B53523129C17
// program: 2E530FFFDA886761, B80FA1B7F97410CD, C9A23B908E5F8ABB
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 7E2D94A79BE7422B
// program: 91D55C04BB07EE32, B80FA1B7F97410CD, 9342C6596F83F706
// program: 2E530FFFDA886761, B80FA1B7F97410CD, D02B1E1378BD97CF
// program: 2E530FFFDA886761, B80FA1B7F97410CD, B78314A585D12D9C
// program: 2E530FFFDA886761, B80FA1B7F97410CD, DEC6EAEA57FA4325
// program: 2E530FFFDA886761, B80FA1B7F97410CD, D4C50B709583D191
// program: 2E530FFFDA886761, B80FA1B7F97410CD, B20F7E72A7330A13
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 48065A05481CB4B8
// program: 2E530FFFDA886761, B80FA1B7F97410CD, BB80E4A110994B48
// program: 2E530FFFDA886761, B80FA1B7F97410CD, EAAC665924781109
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 0656C780E79F2203
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 31E556E9A7729BF4
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 6C66577708AE1E87
// program: 2E530FFFDA886761, B80FA1B7F97410CD, FC7222C50C6F5038
// program: 2E530FFFDA886761, B80FA1B7F97410CD, D1B1A073730D724F
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 790FB95CC0B11076
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 037898F85F34DE95
// program: 46E991DEB658A5A9, B80FA1B7F97410CD, 91931D139F54748D
// program: 46E991DEB658A5A9, B80FA1B7F97410CD, 5FACCC9E3E0584D2
// program: 81B0676B862CF405, 42937135801BAA7E, F5D54925A6AE705F
// program: 81B0676B862CF405, 42937135801BAA7E, 835CABE3A4B650D2
// program: 81B0676B862CF405, 42937135801BAA7E, D4C9E99618707555
// program: 81B0676B862CF405, 42937135801BAA7E, 0951EE62DBCF2390
// program: 81B0676B862CF405, 42937135801BAA7E, 233D9A25E7282666
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 7ED2F034E5EB4FC6
// program: 2E530FFFDA886761, B80FA1B7F97410CD, BC32652205728950
// program: 81B0676B862CF405, 42937135801BAA7E, 21786A34D707A069
// program: 81B0676B862CF405, 42937135801BAA7E, 5124AD903EB19D9F
// program: 81B0676B862CF405, 42937135801BAA7E, 886AC14BAA341C33
// program: 81B0676B862CF405, 42937135801BAA7E, 7C14C907B3CCD849
// program: 81B0676B862CF405, 42937135801BAA7E, 3018EA11DFB984D3
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 10AAC2A3349D1A7E
// program: 81B0676B862CF405, 42937135801BAA7E, 52F5F74AF1B519B6
// program: 81B0676B862CF405, 42937135801BAA7E, 98F0722A788E01FD
// program: 81B0676B862CF405, 42937135801BAA7E, 6E5C02D38B9C02DF
// program: 81B0676B862CF405, 42937135801BAA7E, A4E2954DD6C4FB71
// program: 81B0676B862CF405, 42937135801BAA7E, 5F0787304B8A0BD1
// program: FD3DADE0E2BC47C9, B80FA1B7F97410CD, 19F7816C4117CF8E
// program: 81B0676B862CF405, 42937135801BAA7E, 5FBCCF5F27F5A7C1
// program: 81B0676B862CF405, 42937135801BAA7E, 63B6ADAD25C2A518
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 47E4BEE6B3304AF3
// program: 2E530FFFDA886761, B80FA1B7F97410CD, C580B429ECAF519A
// program: 1934FF8F80653ACB, B80FA1B7F97410CD, 5C250F6C1418BBD3
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 4BA25B84A31C492A
// program: 81B0676B862CF405, 42937135801BAA7E, CAB8B665DC444CE4
// program: 81B0676B862CF405, 42937135801BAA7E, 6B98A4CC666FCBCF
// program: 81B0676B862CF405, 42937135801BAA7E, D1257B6267770D05
// program: 81B0676B862CF405, 42937135801BAA7E, D134C63316570D84
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 40FC95A67F54598B
// program: 2E530FFFDA886761, B80FA1B7F97410CD, D69A3CB52F0E3495
// program: 2E530FFFDA886761, B80FA1B7F97410CD, B5CB613BFC4BC41C
// program: 46E991DEB658A5A9, B80FA1B7F97410CD, 1B4DA8DA884D39A1
// program: 2E530FFFDA886761, B80FA1B7F97410CD, D2BD0C5FAA2AB273
// program: 2E530FFFDA886761, B80FA1B7F97410CD, F8FBCC791CAC22F2
// program: 2E530FFFDA886761, B80FA1B7F97410CD, FEE7FD4C7FD3D731
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 8633243B2123B710
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 39E142A8F1F39B96
// program: 2E530FFFDA886761, B80FA1B7F97410CD, FC9E10BE42F07103
// program: C6410D4382B19655, 082670B4222015B2, DBA0F8FE46AD8D9B
// program: 81B0676B862CF405, 42937135801BAA7E, 47A8279A60685F27
// program: 466184E6A05DFF0F, B80FA1B7F97410CD, C2EEBEAE0D7F3560
// program: 45C9694A57480945, B80FA1B7F97410CD, 490CACB848ED440A
// program: D03F0FE4B72A8E86, B80FA1B7F97410CD, 1CBA1DD1EAE2F663
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 6A08A79BE3FAC39D
// program: FD3DADE0E2BC47C9, B80FA1B7F97410CD, 10AAC2A3349D1A7E
// program: 949D68475595512F, 082670B4222015B2, 0D19D21B46AD8D9B
// program: 81B0676B862CF405, 42937135801BAA7E, 29CD3EBE51FAA42A
// program: 81B0676B862CF405, 42937135801BAA7E, B2E64CFB9744D892
// program: 81B0676B862CF405, 42937135801BAA7E, 98647FD3CF93B689
// program: 949D68475595512F, 082670B4222015B2, DBA0F8FE46AD8D9B
// program: 2FBE2E4ED1D9324C, 082670B4222015B2, DBA0F8FE46AD8D9B
// program: 2FBE2E4ED1D9324C, 082670B4222015B2, F4A415D97E9B6ED6
// program: 81B0676B862CF405, 42937135801BAA7E, AB0D786CFAD777F8
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 6A44D3E672630106
// program: 45C9694A57480945, B80FA1B7F97410CD, 0AC00F84117E7EFC
// program: 1B722ADD909A7B2D, B80FA1B7F97410CD, B3C2F6056AADCF6F
// program: 1B722ADD909A7B2D, B80FA1B7F97410CD, A36D1D6BA424DB28
// program: 1B722ADD909A7B2D, B80FA1B7F97410CD, 641FDB3E9E36B758
// program: 949D68475595512F, 082670B4222015B2, 1430EF96EBF7840F
// program: B0CCAE4F9AB69CDA, B80FA1B7F97410CD, C2EEBEAE0D7F3560
// program: D03F0FE4B72A8E86, B80FA1B7F97410CD, 9D0535C6802495CB
// program: 949D68475595512F, 082670B4222015B2, 63A5270519B4AE20
// program: 81B0676B862CF405, 42937135801BAA7E, 49F399BDFAD777F8
// program: 81B0676B862CF405, 42937135801BAA7E, 00F9BB7ACF93B689
// program: A214E3C9645157AE, B80FA1B7F97410CD, B766CBB102E471E4
// program: 493A89E34FC6D4B5, 082670B4222015B2, DBA0F8FE46AD8D9B
// reference: D186A7B13B931573, 466184E6A05DFF0F
// program: 493A89E34FC6D4B5, 082670B4222015B2, 558A6C807844C0F3
// program: FD3DADE0E2BC47C9, B80FA1B7F97410CD, 5741FC947D667CFB
// program: FD3DADE0E2BC47C9, B80FA1B7F97410CD, 5FF3DF19FAD860D6
// program: 493A89E34FC6D4B5, 082670B4222015B2, 1430EF96707A019C
// program: 2FBE2E4ED1D9324C, 082670B4222015B2, 63A5270519B4AE20
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 26CF8128A3DDBB83
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 953385FED82E0FD1
// program: 2E530FFFDA886761, B80FA1B7F97410CD, E52C4E220978C964
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 378438FF70532E82
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 9F25A997909124C1
// program: 2E530FFFDA886761, B80FA1B7F97410CD, F35E8CA2CAC182F7
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 168DA83A29634DCC
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 576E786439C2EA2F
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 1471721266F6CFF3
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 90EA57FA2E348842
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 1212B53523129C17
// program: 2E530FFFDA886761, B80FA1B7F97410CD, C9A23B908E5F8ABB
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 7E2D94A79BE7422B
// program: 91D55C04BB07EE32, B80FA1B7F97410CD, 9342C6596F83F706
// program: 2E530FFFDA886761, B80FA1B7F97410CD, D02B1E1378BD97CF
// program: 2E530FFFDA886761, B80FA1B7F97410CD, B78314A585D12D9C
// program: 2E530FFFDA886761, B80FA1B7F97410CD, DEC6EAEA57FA4325
// program: 2E530FFFDA886761, B80FA1B7F97410CD, D4C50B709583D191
// program: 2E530FFFDA886761, B80FA1B7F97410CD, B20F7E72A7330A13
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 48065A05481CB4B8
// program: 2E530FFFDA886761, B80FA1B7F97410CD, BB80E4A110994B48
// program: 2E530FFFDA886761, B80FA1B7F97410CD, EAAC665924781109
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 0656C780E79F2203
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 31E556E9A7729BF4
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 6C66577708AE1E87
// program: 2E530FFFDA886761, B80FA1B7F97410CD, FC7222C50C6F5038
// program: 2E530FFFDA886761, B80FA1B7F97410CD, D1B1A073730D724F
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 790FB95CC0B11076
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 037898F85F34DE95
// program: 46E991DEB658A5A9, B80FA1B7F97410CD, 91931D139F54748D
// program: 46E991DEB658A5A9, B80FA1B7F97410CD, 5FACCC9E3E0584D2
// program: 81B0676B862CF405, 42937135801BAA7E, F5D54925A6AE705F
// program: 81B0676B862CF405, 42937135801BAA7E, 835CABE3A4B650D2
// program: 81B0676B862CF405, 42937135801BAA7E, D4C9E99618707555
// program: 81B0676B862CF405, 42937135801BAA7E, 0951EE62DBCF2390
// program: 81B0676B862CF405, 42937135801BAA7E, 233D9A25E7282666
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 7ED2F034E5EB4FC6
// program: 2E530FFFDA886761, B80FA1B7F97410CD, BC32652205728950
// program: 81B0676B862CF405, 42937135801BAA7E, 21786A34D707A069
// program: 81B0676B862CF405, 42937135801BAA7E, 5124AD903EB19D9F
// program: 81B0676B862CF405, 42937135801BAA7E, 886AC14BAA341C33
// program: 81B0676B862CF405, 42937135801BAA7E, 7C14C907B3CCD849
// program: 81B0676B862CF405, 42937135801BAA7E, 3018EA11DFB984D3
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 10AAC2A3349D1A7E
// program: 81B0676B862CF405, 42937135801BAA7E, 52F5F74AF1B519B6
// program: 81B0676B862CF405, 42937135801BAA7E, 98F0722A788E01FD
// program: 81B0676B862CF405, 42937135801BAA7E, 6E5C02D38B9C02DF
// program: 81B0676B862CF405, 42937135801BAA7E, A4E2954DD6C4FB71
// program: 81B0676B862CF405, 42937135801BAA7E, 5F0787304B8A0BD1
// program: FD3DADE0E2BC47C9, B80FA1B7F97410CD, 19F7816C4117CF8E
// program: 81B0676B862CF405, 42937135801BAA7E, 5FBCCF5F27F5A7C1
// program: 81B0676B862CF405, 42937135801BAA7E, 63B6ADAD25C2A518
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 47E4BEE6B3304AF3
// program: 2E530FFFDA886761, B80FA1B7F97410CD, C580B429ECAF519A
// program: 1934FF8F80653ACB, B80FA1B7F97410CD, 5C250F6C1418BBD3
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 4BA25B84A31C492A
// program: 81B0676B862CF405, 42937135801BAA7E, CAB8B665DC444CE4
// program: 81B0676B862CF405, 42937135801BAA7E, 6B98A4CC666FCBCF
// program: 81B0676B862CF405, 42937135801BAA7E, D1257B6267770D05
// program: 81B0676B862CF405, 42937135801BAA7E, D134C63316570D84
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 40FC95A67F54598B
// program: 2E530FFFDA886761, B80FA1B7F97410CD, D69A3CB52F0E3495
// program: 2E530FFFDA886761, B80FA1B7F97410CD, B5CB613BFC4BC41C
// program: 46E991DEB658A5A9, B80FA1B7F97410CD, 1B4DA8DA884D39A1
// program: 2E530FFFDA886761, B80FA1B7F97410CD, D2BD0C5FAA2AB273
// program: 2E530FFFDA886761, B80FA1B7F97410CD, F8FBCC791CAC22F2
// program: 2E530FFFDA886761, B80FA1B7F97410CD, FEE7FD4C7FD3D731
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 8633243B2123B710
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 39E142A8F1F39B96
// program: 2E530FFFDA886761, B80FA1B7F97410CD, FC9E10BE42F07103
// program: C6410D4382B19655, 082670B4222015B2, DBA0F8FE46AD8D9B
// program: 81B0676B862CF405, 42937135801BAA7E, 47A8279A60685F27
// program: 466184E6A05DFF0F, B80FA1B7F97410CD, C2EEBEAE0D7F3560
// program: 45C9694A57480945, B80FA1B7F97410CD, 490CACB848ED440A
// program: D03F0FE4B72A8E86, B80FA1B7F97410CD, 1CBA1DD1EAE2F663
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 6A08A79BE3FAC39D
// program: FD3DADE0E2BC47C9, B80FA1B7F97410CD, 10AAC2A3349D1A7E
// program: 949D68475595512F, 082670B4222015B2, 0D19D21B46AD8D9B
// program: 81B0676B862CF405, 42937135801BAA7E, 29CD3EBE51FAA42A
// program: 81B0676B862CF405, 42937135801BAA7E, B2E64CFB9744D892
// program: 81B0676B862CF405, 42937135801BAA7E, 98647FD3CF93B689
// program: 949D68475595512F, 082670B4222015B2, DBA0F8FE46AD8D9B
// program: 2FBE2E4ED1D9324C, 082670B4222015B2, DBA0F8FE46AD8D9B
// program: 2FBE2E4ED1D9324C, 082670B4222015B2, F4A415D97E9B6ED6
// program: 81B0676B862CF405, 42937135801BAA7E, AB0D786CFAD777F8
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 6A44D3E672630106
// program: 45C9694A57480945, B80FA1B7F97410CD, 0AC00F84117E7EFC
// program: 1B722ADD909A7B2D, B80FA1B7F97410CD, B3C2F6056AADCF6F
// program: 1B722ADD909A7B2D, B80FA1B7F97410CD, A36D1D6BA424DB28
// program: 1B722ADD909A7B2D, B80FA1B7F97410CD, 641FDB3E9E36B758
// program: 949D68475595512F, 082670B4222015B2, 1430EF96EBF7840F
// program: B0CCAE4F9AB69CDA, B80FA1B7F97410CD, C2EEBEAE0D7F3560
// program: D03F0FE4B72A8E86, B80FA1B7F97410CD, 9D0535C6802495CB
// program: 949D68475595512F, 082670B4222015B2, 63A5270519B4AE20
// program: 81B0676B862CF405, 42937135801BAA7E, 49F399BDFAD777F8
// program: 81B0676B862CF405, 42937135801BAA7E, 00F9BB7ACF93B689
// program: A214E3C9645157AE, B80FA1B7F97410CD, B766CBB102E471E4
// program: 493A89E34FC6D4B5, 082670B4222015B2, DBA0F8FE46AD8D9B
// program: 493A89E34FC6D4B5, 082670B4222015B2, 558A6C807844C0F3
// program: FD3DADE0E2BC47C9, B80FA1B7F97410CD, 5741FC947D667CFB
// program: FD3DADE0E2BC47C9, B80FA1B7F97410CD, 5FF3DF19FAD860D6
// program: 493A89E34FC6D4B5, 082670B4222015B2, 1430EF96707A019C
// program: 2FBE2E4ED1D9324C, 082670B4222015B2, 63A5270519B4AE20
// program: 2E530FFFDA886761, B80FA1B7F97410CD, FFE5F81052CAA889
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 7ED2F034E5EB4FC6
// program: E81D148B6EF003F8, B80FA1B7F97410CD, BC32652205728950
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 10AAC2A3349D1A7E
// program: D9C174A4A54356AC, 42937135801BAA7E, 52F5F74AF1B519B6
// program: D9C174A4A54356AC, 42937135801BAA7E, 98F0722A788E01FD
// program: D9C174A4A54356AC, 42937135801BAA7E, 6E5C02D38B9C02DF
// program: D9C174A4A54356AC, 42937135801BAA7E, A4E2954DD6C4FB71
// program: D0293423BD9EA1E7, B80FA1B7F97410CD, 19F7816C4117CF8E
// program: D9C174A4A54356AC, 42937135801BAA7E, 5FBCCF5F27F5A7C1
// program: D9C174A4A54356AC, 42937135801BAA7E, 63B6ADAD25C2A518
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 47E4BEE6B3304AF3
// program: E81D148B6EF003F8, B80FA1B7F97410CD, C580B429ECAF519A
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 4BA25B84A31C492A
// program: D9C174A4A54356AC, 42937135801BAA7E, 6B98A4CC666FCBCF
// program: D9C174A4A54356AC, 42937135801BAA7E, D1257B6267770D05
// program: D9C174A4A54356AC, 42937135801BAA7E, D134C63316570D84
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 40FC95A67F54598B
// program: E81D148B6EF003F8, B80FA1B7F97410CD, D69A3CB52F0E3495
// program: E81D148B6EF003F8, B80FA1B7F97410CD, B5CB613BFC4BC41C
// program: 502AB780D80D09C1, B80FA1B7F97410CD, 1B4DA8DA884D39A1
// program: E81D148B6EF003F8, B80FA1B7F97410CD, D2BD0C5FAA2AB273
// program: E81D148B6EF003F8, B80FA1B7F97410CD, F8FBCC791CAC22F2
// program: E81D148B6EF003F8, B80FA1B7F97410CD, FEE7FD4C7FD3D731
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 8633243B2123B710
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 39E142A8F1F39B96
// program: E81D148B6EF003F8, B80FA1B7F97410CD, FC9E10BE42F07103
// program: 1BDE5ABD20055F26, 082670B4222015B2, DBA0F8FE46AD8D9B
// program: D9C174A4A54356AC, 42937135801BAA7E, 47A8279A60685F27
// program: 4028512EA840631E, B80FA1B7F97410CD, C2EEBEAE0D7F3560
// program: 35CCCCDE75E2FF83, B80FA1B7F97410CD, 0AC00F84117E7EFC
// program: A40B5D829674D1F8, B80FA1B7F97410CD, 9D0535C6802495CB
// program: A40B5D829674D1F8, B80FA1B7F97410CD, 429F87F8D3AE0B36
// program: A40B5D829674D1F8, B80FA1B7F97410CD, 40BF4FB85B0B5330
// program: A40B5D829674D1F8, B80FA1B7F97410CD, EE82356499D9033F
// program: A40B5D829674D1F8, B80FA1B7F97410CD, 5F16273C5032C0B2
// program: A40B5D829674D1F8, B80FA1B7F97410CD, BC8FFFD904DA352D
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 6A08A79BE3FAC39D
// program: D0293423BD9EA1E7, B80FA1B7F97410CD, 10AAC2A3349D1A7E
// program: 49AB6B882020674A, 082670B4222015B2, 0D19D21B46AD8D9B
// program: D9C174A4A54356AC, 42937135801BAA7E, 29CD3EBE51FAA42A
// program: D9C174A4A54356AC, 42937135801BAA7E, B2E64CFB9744D892
// program: D9C174A4A54356AC, 42937135801BAA7E, 98647FD3CF93B689
// program: 49AB6B882020674A, 082670B4222015B2, DBA0F8FE46AD8D9B
// program: 70A370D21404144E, 082670B4222015B2, DBA0F8FE46AD8D9B
// program: 70A370D21404144E, 082670B4222015B2, F4A415D97E9B6ED6
// program: D9C174A4A54356AC, 42937135801BAA7E, AB0D786CFAD777F8
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 6A44D3E672630106
// program: 4CDB2C6E0A14815D, B80FA1B7F97410CD, A36D1D6BA424DB28
// program: 4CDB2C6E0A14815D, B80FA1B7F97410CD, 641FDB3E9E36B758
// program: 49AB6B882020674A, 082670B4222015B2, 1430EF96EBF7840F
// program: 49AB6B882020674A, 082670B4222015B2, 63A5270519B4AE20
// program: D9C174A4A54356AC, 42937135801BAA7E, 49F399BDFAD777F8
// program: D9C174A4A54356AC, 42937135801BAA7E, 00F9BB7ACF93B689
// program: 3526EFD6EA584B4A, B80FA1B7F97410CD, B766CBB102E471E4
// program: 8AA3B6DF4767940E, 082670B4222015B2, DBA0F8FE46AD8D9B
// program: 8AA3B6DF4767940E, 082670B4222015B2, 558A6C807844C0F3
// program: D0293423BD9EA1E7, B80FA1B7F97410CD, 5741FC947D667CFB
// program: D0293423BD9EA1E7, B80FA1B7F97410CD, 5FF3DF19FAD860D6
// program: 8AA3B6DF4767940E, 082670B4222015B2, 1430EF96707A019C
// program: 70A370D21404144E, 082670B4222015B2, 63A5270519B4AE20
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 7ED2F034E5EB4FC6
// program: E81D148B6EF003F8, B80FA1B7F97410CD, BC32652205728950
// program: D9C174A4A54356AC, 42937135801BAA7E, 3018EA11DFB984D3
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 10AAC2A3349D1A7E
// program: D9C174A4A54356AC, 42937135801BAA7E, 52F5F74AF1B519B6
// program: D9C174A4A54356AC, 42937135801BAA7E, 98F0722A788E01FD
// program: D9C174A4A54356AC, 42937135801BAA7E, 6E5C02D38B9C02DF
// program: D9C174A4A54356AC, 42937135801BAA7E, A4E2954DD6C4FB71
// program: D9C174A4A54356AC, 42937135801BAA7E, 5F0787304B8A0BD1
// program: D0293423BD9EA1E7, B80FA1B7F97410CD, 19F7816C4117CF8E
// program: D9C174A4A54356AC, 42937135801BAA7E, 5FBCCF5F27F5A7C1
// program: D9C174A4A54356AC, 42937135801BAA7E, 63B6ADAD25C2A518
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 47E4BEE6B3304AF3
// program: E81D148B6EF003F8, B80FA1B7F97410CD, C580B429ECAF519A
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 4BA25B84A31C492A
// program: D9C174A4A54356AC, 42937135801BAA7E, 6B98A4CC666FCBCF
// program: D9C174A4A54356AC, 42937135801BAA7E, D1257B6267770D05
// program: D9C174A4A54356AC, 42937135801BAA7E, D134C63316570D84
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 40FC95A67F54598B
// program: E81D148B6EF003F8, B80FA1B7F97410CD, D69A3CB52F0E3495
// program: E81D148B6EF003F8, B80FA1B7F97410CD, B5CB613BFC4BC41C
// program: 502AB780D80D09C1, B80FA1B7F97410CD, 1B4DA8DA884D39A1
// program: E81D148B6EF003F8, B80FA1B7F97410CD, D2BD0C5FAA2AB273
// program: E81D148B6EF003F8, B80FA1B7F97410CD, F8FBCC791CAC22F2
// program: E81D148B6EF003F8, B80FA1B7F97410CD, FEE7FD4C7FD3D731
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 8633243B2123B710
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 39E142A8F1F39B96
// program: E81D148B6EF003F8, B80FA1B7F97410CD, FC9E10BE42F07103
// program: 1BDE5ABD20055F26, 082670B4222015B2, DBA0F8FE46AD8D9B
// program: D9C174A4A54356AC, 42937135801BAA7E, 47A8279A60685F27
// program: 5E28DB645EED49B7, B80FA1B7F97410CD, C2EEBEAE0D7F3560
// program: A40B5D829674D1F8, B80FA1B7F97410CD, 1CBA1DD1EAE2F663
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 6A08A79BE3FAC39D
// program: D0293423BD9EA1E7, B80FA1B7F97410CD, 10AAC2A3349D1A7E
// program: 49AB6B882020674A, 082670B4222015B2, 0D19D21B46AD8D9B
// program: D9C174A4A54356AC, 42937135801BAA7E, 29CD3EBE51FAA42A
// program: D9C174A4A54356AC, 42937135801BAA7E, B2E64CFB9744D892
// program: D9C174A4A54356AC, 42937135801BAA7E, 98647FD3CF93B689
// program: 49AB6B882020674A, 082670B4222015B2, DBA0F8FE46AD8D9B
// program: 70A370D21404144E, 082670B4222015B2, DBA0F8FE46AD8D9B
// program: 70A370D21404144E, 082670B4222015B2, F4A415D97E9B6ED6
// program: D9C174A4A54356AC, 42937135801BAA7E, AB0D786CFAD777F8
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 6A44D3E672630106
// program: 35CCCCDE75E2FF83, B80FA1B7F97410CD, 0AC00F84117E7EFC
// program: 4CDB2C6E0A14815D, B80FA1B7F97410CD, A36D1D6BA424DB28
// program: 4CDB2C6E0A14815D, B80FA1B7F97410CD, 641FDB3E9E36B758
// program: 49AB6B882020674A, 082670B4222015B2, 1430EF96EBF7840F
// program: 4028512EA840631E, B80FA1B7F97410CD, C2EEBEAE0D7F3560
// program: A40B5D829674D1F8, B80FA1B7F97410CD, 9D0535C6802495CB
// program: 49AB6B882020674A, 082670B4222015B2, 63A5270519B4AE20
// program: D9C174A4A54356AC, 42937135801BAA7E, 49F399BDFAD777F8
// program: D9C174A4A54356AC, 42937135801BAA7E, 00F9BB7ACF93B689
// program: 3526EFD6EA584B4A, B80FA1B7F97410CD, B766CBB102E471E4
// program: 8AA3B6DF4767940E, 082670B4222015B2, DBA0F8FE46AD8D9B
// reference: 6BDD52D04CB5ED84, 5E28DB645EED49B7
// program: 8AA3B6DF4767940E, 082670B4222015B2, 558A6C807844C0F3
// program: D0293423BD9EA1E7, B80FA1B7F97410CD, 5741FC947D667CFB
// program: D0293423BD9EA1E7, B80FA1B7F97410CD, 5FF3DF19FAD860D6
// program: 8AA3B6DF4767940E, 082670B4222015B2, 1430EF96707A019C
// program: 70A370D21404144E, 082670B4222015B2, 63A5270519B4AE20
// reference: 60A33469BA00A4C7, D9C174A4A54356AC
// reference: 2EF7CB2939F5C2B5, D9C174A4A54356AC
// reference: 42D1A00CAC306A2F, E81D148B6EF003F8
// reference: 0C855F4C2FC50C5D, E81D148B6EF003F8
// reference: AF6DC92376D80EC2, 3526EFD6EA584B4A
// reference: 14B64F84369791C8, 5E28DB645EED49B7
// reference: 5AE2B0C4B562F7BA, 5E28DB645EED49B7
// reference: 03839BCB416D2E81, 4028512EA840631E
// reference: 719C983E3C7B864E, 35CCCCDE75E2FF83
// reference: 40B61567C418C5C3, A40B5D829674D1F8
// reference: 0EE2EA2747EDA3B1, A40B5D829674D1F8
// reference: B9D86EAAA33B02E3, 4028512EA840631E
// shader: 8B31, 3D0468462F93E852

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_8();
bool sub_9_32();
bool sub_146_166();
bool sub_167_259();
bool sub_190_192();
bool sub_194_195();
bool sub_197_198();
bool sub_200_202();
bool sub_232_234();
bool sub_236_237();
bool sub_239_240();
bool sub_242_244();
bool sub_260_4096();
bool sub_281_282();
bool sub_282_283();

bool exec_shader() {
    sub_260_4096();
    return true;
}

bool sub_0_8() {
    address_registers.x = (ivec2(vs_in_reg0.zz)).x;
    reg_tmp10 = uniforms.f[0].xxxz;
    reg_tmp10.xy = (vs_in_reg0.xyyy).xy;
    reg_tmp11 = uniforms.f[0].xxxx;
    reg_tmp12 = uniforms.f[0].xxxx;
    reg_tmp13 = uniforms.f[0].zzzz;
    reg_tmp4 = uniforms.f[0].xxxx;
    reg_tmp5 = uniforms.f[0].xxxx;
    return false;
}
bool sub_9_32() {
    vs_out_attr0 = reg_tmp10;
    reg_tmp13 = mul_s(uniforms.f[82], reg_tmp13);
    vs_out_attr1 = reg_tmp13;
    reg_tmp11.y = (uniforms.f[0].zzzz + -reg_tmp11.yyyy).y;
    reg_tmp12.y = (uniforms.f[0].zzzz + -reg_tmp12.yyyy).y;
    reg_tmp14.y = (uniforms.f[81].wwww).y;
    reg_tmp14.x = (mul_s(uniforms.f[0].wwww, reg_tmp14.yyyy)).x;
    reg_tmp2.x = rcp_s(reg_tmp14.x);
    reg_tmp14.z = (reg_tmp2.xxxx).z;
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp11.xyyy).xy;
    reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    reg_tmp11.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp12.xyyy).xy;
    reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    reg_tmp12.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    vs_out_attr2 = reg_tmp11;
    vs_out_attr3 = reg_tmp12;
    return false;
}
bool sub_146_166() {
    reg_tmp2 = uniforms.f[90];
    reg_tmp3 = uniforms.f[91];
    reg_tmp4 = uniforms.f[92];
    reg_tmp5 = uniforms.f[0].xxxz;
    reg_tmp6 = mul_s(uniforms.f[86].xxxx, reg_tmp2);
    reg_tmp6 = fma_s(reg_tmp3, uniforms.f[86].yyyy, reg_tmp6);
    reg_tmp6 = fma_s(reg_tmp4, uniforms.f[86].zzzz, reg_tmp6);
    reg_tmp6 = fma_s(reg_tmp5, uniforms.f[86].wwww, reg_tmp6);
    reg_tmp7 = mul_s(uniforms.f[87].xxxx, reg_tmp2);
    reg_tmp7 = fma_s(reg_tmp3, uniforms.f[87].yyyy, reg_tmp7);
    reg_tmp7 = fma_s(reg_tmp4, uniforms.f[87].zzzz, reg_tmp7);
    reg_tmp7 = fma_s(reg_tmp5, uniforms.f[87].wwww, reg_tmp7);
    reg_tmp8 = mul_s(uniforms.f[88].xxxx, reg_tmp2);
    reg_tmp8 = fma_s(reg_tmp3, uniforms.f[88].yyyy, reg_tmp8);
    reg_tmp8 = fma_s(reg_tmp4, uniforms.f[88].zzzz, reg_tmp8);
    reg_tmp8 = fma_s(reg_tmp5, uniforms.f[88].wwww, reg_tmp8);
    reg_tmp9 = mul_s(uniforms.f[89].xxxx, reg_tmp2);
    reg_tmp9 = fma_s(reg_tmp3, uniforms.f[89].yyyy, reg_tmp9);
    reg_tmp9 = fma_s(reg_tmp4, uniforms.f[89].zzzz, reg_tmp9);
    reg_tmp9 = fma_s(reg_tmp5, uniforms.f[89].wwww, reg_tmp9);
    return false;
}
bool sub_167_259() {
    reg_tmp2.x = rcp_s(uniforms.f[81].y);
    reg_tmp2.xy = (mul_s(uniforms.f[2 + address_registers.x].zwww, reg_tmp2.xxxx)).xy;
    reg_tmp2.xy = (uniforms.f[0].yyyy + reg_tmp2.xyyy).xy;
    reg_tmp3.xy = (floor(reg_tmp2.xyyy)).xy;
    reg_tmp2.xy = (mul_s(uniforms.f[81].yyyy, reg_tmp3.xyyy)).xy;
    reg_tmp2.xy = (uniforms.f[2 + address_registers.x].zwww + -reg_tmp2.xyyy).xy;
    reg_tmp0.xy = (min(uniforms.f[81].xxxx, -reg_tmp2.xyyy)).xy;
    reg_tmp0.xy = (max(-uniforms.f[81].xxxx, reg_tmp0.xyyy)).xy;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp0.xxxx, reg_tmp0.xxxx)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.xxxx)).y;
    reg_tmp5.x = (uniforms.f[5 + address_registers.x].wwww).x;
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_190_192();
    }
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_194_195();
    }
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_197_198();
    }
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_200_202();
    }
    reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    reg_tmp4.z = (uniforms.f[83].xxxx).z;
    reg_tmp4.w = (-uniforms.f[83].yyyy).w;
    reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[3 + address_registers.x].xyyy)).xy;
    reg_tmp4.z = (-uniforms.f[3 + address_registers.x].zzzz).z;
    reg_tmp4.w = (-uniforms.f[3 + address_registers.x].wwww).w;
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    reg_tmp11.xy = (reg_tmp5.xyyy).xy;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp0.yyyy, reg_tmp0.yyyy)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.yyyy)).y;
    reg_tmp5.x = (uniforms.f[6 + address_registers.x].wwww).x;
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_232_234();
    }
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_236_237();
    }
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_239_240();
    }
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_242_244();
    }
    reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    reg_tmp4.z = (uniforms.f[83].zzzz).z;
    reg_tmp4.w = (-uniforms.f[83].wwww).w;
    reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[4 + address_registers.x].xyyy)).xy;
    reg_tmp4.z = (-uniforms.f[4 + address_registers.x].zzzz).z;
    reg_tmp4.w = (-uniforms.f[4 + address_registers.x].wwww).w;
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    reg_tmp12.xy = (reg_tmp5.xyyy).xy;
    return false;
}
bool sub_190_192() {
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_194_195() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_197_198() {
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_200_202() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_232_234() {
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_236_237() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_239_240() {
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_242_244() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_260_4096() {
    {
        sub_0_8();
    }
    reg_tmp10.xy = (uniforms.f[84].xyyy + reg_tmp10.xyyy).xy;
    reg_tmp10.xy = (mul_s(uniforms.f[2 + address_registers.x].xyyy, reg_tmp10.xyyy)).xy;
    reg_tmp2 = reg_tmp10.xzyw;
    reg_tmp2.z = (-reg_tmp2.zzzz).z;
    reg_tmp6 = uniforms.f[8 + address_registers.x];
    reg_tmp7 = uniforms.f[9 + address_registers.x];
    reg_tmp8 = uniforms.f[10 + address_registers.x];
    reg_tmp9 = uniforms.f[0].xxxz;
    reg_tmp6.w = (uniforms.f[5 + address_registers.x].xxxx).w;
    reg_tmp7.w = (uniforms.f[5 + address_registers.x].yyyy).w;
    reg_tmp8.w = (uniforms.f[5 + address_registers.x].zzzz).w;
    reg_tmp10.x = dot_s(reg_tmp2, reg_tmp6);
    reg_tmp10.y = dot_s(reg_tmp2, reg_tmp7);
    reg_tmp10.z = dot_s(reg_tmp2, reg_tmp8);
    reg_tmp10.w = dot_s(reg_tmp2, reg_tmp9);
    reg_tmp3.xyz = (uniforms.f[5 + address_registers.x].xyzz).xyz;
    reg_tmp3.xyz = (uniforms.f[85].xyzz + -reg_tmp3.xyzz).xyz;
    reg_tmp4.x = dot_3(reg_tmp3.xyz, reg_tmp3.xyz);
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
    if (conditional_code.x) {
        sub_281_282();
    } else {
        sub_282_283();
    }
    reg_tmp3.xyz = (mul_s(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
    reg_tmp10.xyz = (fma_s(reg_tmp3.xyzz, uniforms.f[84].zzzz, reg_tmp10.xyzz)).xyz;
    {
        sub_146_166();
    }
    reg_tmp2 = reg_tmp10;
    reg_tmp10.x = dot_s(reg_tmp2, reg_tmp6);
    reg_tmp10.y = dot_s(reg_tmp2, reg_tmp7);
    reg_tmp10.z = dot_s(reg_tmp2, reg_tmp8);
    reg_tmp10.w = dot_s(reg_tmp2, reg_tmp9);
    reg_tmp2 = uniforms.f[1 + address_registers.x];
    reg_tmp3 = max(uniforms.f[0].xxxx, reg_tmp2);
    reg_tmp2 = min(uniforms.f[0].zzzz, reg_tmp3);
    reg_tmp13 = reg_tmp2;
    {
        sub_167_259();
    }
    {
        sub_9_32();
    }
    return true;
}
bool sub_281_282() {
    reg_tmp4.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_282_283() {
    reg_tmp4.x = rsq_s(reg_tmp4.x);
    return false;
}
// reference: 93839FAD2821709D, 3D0468462F93E852
// program: 3D0468462F93E852, 082670B4222015B2, DBA0F8FE46AD8D9B
// reference: DDD760EDABD416EF, 3D0468462F93E852
// shader: 8B31, 3D44FD78671E7A32

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_8();
bool sub_9_32();
bool sub_114_142();
bool sub_146_166();
bool sub_167_259();
bool sub_190_192();
bool sub_194_195();
bool sub_197_198();
bool sub_200_202();
bool sub_232_234();
bool sub_236_237();
bool sub_239_240();
bool sub_242_244();
bool sub_260_4096();
bool sub_274_275();
bool sub_275_276();

bool exec_shader() {
    sub_260_4096();
    return true;
}

bool sub_0_8() {
    address_registers.x = (ivec2(vs_in_reg0.zz)).x;
    reg_tmp10 = uniforms.f[0].xxxz;
    reg_tmp10.xy = (vs_in_reg0.xyyy).xy;
    reg_tmp11 = uniforms.f[0].xxxx;
    reg_tmp12 = uniforms.f[0].xxxx;
    reg_tmp13 = uniforms.f[0].zzzz;
    reg_tmp4 = uniforms.f[0].xxxx;
    reg_tmp5 = uniforms.f[0].xxxx;
    return false;
}
bool sub_9_32() {
    vs_out_attr0 = reg_tmp10;
    reg_tmp13 = mul_s(uniforms.f[82], reg_tmp13);
    vs_out_attr1 = reg_tmp13;
    reg_tmp11.y = (uniforms.f[0].zzzz + -reg_tmp11.yyyy).y;
    reg_tmp12.y = (uniforms.f[0].zzzz + -reg_tmp12.yyyy).y;
    reg_tmp14.y = (uniforms.f[81].wwww).y;
    reg_tmp14.x = (mul_s(uniforms.f[0].wwww, reg_tmp14.yyyy)).x;
    reg_tmp2.x = rcp_s(reg_tmp14.x);
    reg_tmp14.z = (reg_tmp2.xxxx).z;
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp11.xyyy).xy;
    reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    reg_tmp11.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp12.xyyy).xy;
    reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    reg_tmp12.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    vs_out_attr2 = reg_tmp11;
    vs_out_attr3 = reg_tmp12;
    return false;
}
bool sub_114_142() {
    reg_tmp2 = uniforms.f[85];
    reg_tmp2.xz = (-uniforms.f[5 + address_registers.x].xzzz + reg_tmp2.xzzz).xz;
    reg_tmp2.yw = (uniforms.f[0].xxxx).yw;
    reg_tmp3.x = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
    reg_tmp3.x = rsq_s(reg_tmp3.x);
    reg_tmp2.xyz = (mul_s(reg_tmp2.xyzz, reg_tmp3.xxxx)).xyz;
    reg_tmp4 = uniforms.f[0].xzxx;
    reg_tmp5.xyz = (mul_s(reg_tmp2.yzxx, reg_tmp4.zxyy)).xyz;
    reg_tmp5.xyz = (fma_s(-reg_tmp4.yzxx, reg_tmp2.zxyy, reg_tmp5)).xyz;
    reg_tmp3.x = dot_3(reg_tmp5.xyz, reg_tmp5.xyz);
    reg_tmp3.x = rsq_s(reg_tmp3.x);
    reg_tmp5.xyz = (mul_s(reg_tmp5.xyzz, reg_tmp3.xxxx)).xyz;
    reg_tmp6.x = (-reg_tmp5.xxxx).x;
    reg_tmp6.y = (-reg_tmp5.yyyy).y;
    reg_tmp6.z = (-reg_tmp5.zzzz).z;
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    reg_tmp7.x = (reg_tmp4.xxxx).x;
    reg_tmp7.y = (reg_tmp4.yyyy).y;
    reg_tmp7.z = (reg_tmp4.zzzz).z;
    reg_tmp7.w = (uniforms.f[0].xxxx).w;
    reg_tmp8.x = (-reg_tmp2.xxxx).x;
    reg_tmp8.y = (-reg_tmp2.yyyy).y;
    reg_tmp8.z = (-reg_tmp2.zzzz).z;
    reg_tmp8.w = (uniforms.f[0].xxxx).w;
    reg_tmp9.x = (uniforms.f[90].wwww).x;
    reg_tmp9.y = (uniforms.f[91].wwww).y;
    reg_tmp9.z = (uniforms.f[92].wwww).z;
    reg_tmp9.w = (uniforms.f[0].zzzz).w;
    return false;
}
bool sub_146_166() {
    reg_tmp2 = uniforms.f[90];
    reg_tmp3 = uniforms.f[91];
    reg_tmp4 = uniforms.f[92];
    reg_tmp5 = uniforms.f[0].xxxz;
    reg_tmp6 = mul_s(uniforms.f[86].xxxx, reg_tmp2);
    reg_tmp6 = fma_s(reg_tmp3, uniforms.f[86].yyyy, reg_tmp6);
    reg_tmp6 = fma_s(reg_tmp4, uniforms.f[86].zzzz, reg_tmp6);
    reg_tmp6 = fma_s(reg_tmp5, uniforms.f[86].wwww, reg_tmp6);
    reg_tmp7 = mul_s(uniforms.f[87].xxxx, reg_tmp2);
    reg_tmp7 = fma_s(reg_tmp3, uniforms.f[87].yyyy, reg_tmp7);
    reg_tmp7 = fma_s(reg_tmp4, uniforms.f[87].zzzz, reg_tmp7);
    reg_tmp7 = fma_s(reg_tmp5, uniforms.f[87].wwww, reg_tmp7);
    reg_tmp8 = mul_s(uniforms.f[88].xxxx, reg_tmp2);
    reg_tmp8 = fma_s(reg_tmp3, uniforms.f[88].yyyy, reg_tmp8);
    reg_tmp8 = fma_s(reg_tmp4, uniforms.f[88].zzzz, reg_tmp8);
    reg_tmp8 = fma_s(reg_tmp5, uniforms.f[88].wwww, reg_tmp8);
    reg_tmp9 = mul_s(uniforms.f[89].xxxx, reg_tmp2);
    reg_tmp9 = fma_s(reg_tmp3, uniforms.f[89].yyyy, reg_tmp9);
    reg_tmp9 = fma_s(reg_tmp4, uniforms.f[89].zzzz, reg_tmp9);
    reg_tmp9 = fma_s(reg_tmp5, uniforms.f[89].wwww, reg_tmp9);
    return false;
}
bool sub_167_259() {
    reg_tmp2.x = rcp_s(uniforms.f[81].y);
    reg_tmp2.xy = (mul_s(uniforms.f[2 + address_registers.x].zwww, reg_tmp2.xxxx)).xy;
    reg_tmp2.xy = (uniforms.f[0].yyyy + reg_tmp2.xyyy).xy;
    reg_tmp3.xy = (floor(reg_tmp2.xyyy)).xy;
    reg_tmp2.xy = (mul_s(uniforms.f[81].yyyy, reg_tmp3.xyyy)).xy;
    reg_tmp2.xy = (uniforms.f[2 + address_registers.x].zwww + -reg_tmp2.xyyy).xy;
    reg_tmp0.xy = (min(uniforms.f[81].xxxx, -reg_tmp2.xyyy)).xy;
    reg_tmp0.xy = (max(-uniforms.f[81].xxxx, reg_tmp0.xyyy)).xy;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp0.xxxx, reg_tmp0.xxxx)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.xxxx)).y;
    reg_tmp5.x = (uniforms.f[5 + address_registers.x].wwww).x;
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_190_192();
    }
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_194_195();
    }
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_197_198();
    }
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_200_202();
    }
    reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    reg_tmp4.z = (uniforms.f[83].xxxx).z;
    reg_tmp4.w = (-uniforms.f[83].yyyy).w;
    reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[3 + address_registers.x].xyyy)).xy;
    reg_tmp4.z = (-uniforms.f[3 + address_registers.x].zzzz).z;
    reg_tmp4.w = (-uniforms.f[3 + address_registers.x].wwww).w;
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    reg_tmp11.xy = (reg_tmp5.xyyy).xy;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp0.yyyy, reg_tmp0.yyyy)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.yyyy)).y;
    reg_tmp5.x = (uniforms.f[6 + address_registers.x].wwww).x;
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_232_234();
    }
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_236_237();
    }
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_239_240();
    }
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_242_244();
    }
    reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    reg_tmp4.z = (uniforms.f[83].zzzz).z;
    reg_tmp4.w = (-uniforms.f[83].wwww).w;
    reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[4 + address_registers.x].xyyy)).xy;
    reg_tmp4.z = (-uniforms.f[4 + address_registers.x].zzzz).z;
    reg_tmp4.w = (-uniforms.f[4 + address_registers.x].wwww).w;
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    reg_tmp12.xy = (reg_tmp5.xyyy).xy;
    return false;
}
bool sub_190_192() {
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_194_195() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_197_198() {
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_200_202() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_232_234() {
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_236_237() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_239_240() {
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_242_244() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_260_4096() {
    {
        sub_0_8();
    }
    reg_tmp10.xy = (uniforms.f[84].xyyy + reg_tmp10.xyyy).xy;
    reg_tmp10.xy = (mul_s(uniforms.f[2 + address_registers.x].xyyy, reg_tmp10.xyyy)).xy;
    {
        sub_114_142();
    }
    reg_tmp14.x = dot_s(reg_tmp10, reg_tmp6);
    reg_tmp14.y = dot_s(reg_tmp10, reg_tmp7);
    reg_tmp14.z = dot_s(reg_tmp10, reg_tmp8);
    reg_tmp14.w = dot_s(uniforms.f[0].xxxz, reg_tmp10);
    reg_tmp2 = reg_tmp14;
    reg_tmp3.xyz = (uniforms.f[5 + address_registers.x].xyzz).xyz;
    reg_tmp3.xyz = (uniforms.f[85].xyzz + -reg_tmp3.xyzz).xyz;
    reg_tmp4.x = dot_3(reg_tmp3.xyz, reg_tmp3.xyz);
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
    if (conditional_code.x) {
        sub_274_275();
    } else {
        sub_275_276();
    }
    reg_tmp3.xyz = (mul_s(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
    reg_tmp10.xyz = (uniforms.f[5 + address_registers.x].xyzz + reg_tmp2.xyzz).xyz;
    reg_tmp10.xyz = (fma_s(reg_tmp3.xyzz, uniforms.f[84].zzzz, reg_tmp10.xyzz)).xyz;
    {
        sub_146_166();
    }
    reg_tmp2 = reg_tmp10;
    reg_tmp10.x = dot_s(reg_tmp2, reg_tmp6);
    reg_tmp10.y = dot_s(reg_tmp2, reg_tmp7);
    reg_tmp10.z = dot_s(reg_tmp2, reg_tmp8);
    reg_tmp10.w = dot_s(reg_tmp2, reg_tmp9);
    reg_tmp2 = uniforms.f[1 + address_registers.x];
    reg_tmp3 = max(uniforms.f[0].xxxx, reg_tmp2);
    reg_tmp2 = min(uniforms.f[0].zzzz, reg_tmp3);
    reg_tmp13 = reg_tmp2;
    {
        sub_167_259();
    }
    {
        sub_9_32();
    }
    return true;
}
bool sub_274_275() {
    reg_tmp4.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_275_276() {
    reg_tmp4.x = rsq_s(reg_tmp4.x);
    return false;
}
// reference: EB88C665EC92F4CE, 3D44FD78671E7A32
// program: 3D44FD78671E7A32, 082670B4222015B2, 1430EF96707A019C
// reference: 94E3DB31E2A2ED89, 1BDE5ABD20055F26
// reference: EB88C665420D2646, 70A370D21404144E
// reference: 11053D11BA00A4C7, D9C174A4A54356AC
// reference: 5F51C25139F5C2B5, D9C174A4A54356AC
// reference: 3377A974AC306A2F, E81D148B6EF003F8
// reference: 7D2356342FC50C5D, E81D148B6EF003F8
// reference: DECBC05B76D80EC2, 3526EFD6EA584B4A
// reference: 651046FC369791C8, 5E28DB645EED49B7
// reference: 2B44B9BCB562F7BA, 5E28DB645EED49B7
// reference: 722592B3416D2E81, 4028512EA840631E
// reference: 003A91463C7B864E, 35CCCCDE75E2FF83
// reference: 31101C1FC418C5C3, A40B5D829674D1F8
// reference: 7F44E35F47EDA3B1, A40B5D829674D1F8
// reference: 25602672CF700DA8, 49AB6B882020674A
// reference: EB88C665C94D3987, 70A370D21404144E
// reference: 203ADF05995A097A, D9C174A4A54356AC
// reference: 6E6E20451AAF6F08, D9C174A4A54356AC
// reference: 02484B60AC306A2F, E81D148B6EF003F8
// reference: 4C1CB4202FC50C5D, E81D148B6EF003F8
// reference: EFF4224F76D80EC2, 3526EFD6EA584B4A
// reference: 542FA4E8369791C8, 5E28DB645EED49B7
// reference: 1A7B5BA8B562F7BA, 5E28DB645EED49B7
// reference: 431A70A7416D2E81, 4028512EA840631E
// reference: 310573523C7B864E, 35CCCCDE75E2FF83
// reference: 002FFE0BC418C5C3, A40B5D829674D1F8
// reference: 4E7B014B47EDA3B1, A40B5D829674D1F8
// reference: 23CC035F58EDEE64, 3526EFD6EA584B4A
// shader: 8B30, 1ACA1B6676BF3978

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb) * (texcolor0.rgb) + (const_color[0].rgb) * (vec3(1.0) - (texcolor0.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.r) + (texcolor1.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_1 = byteround(clamp((rounded_primary_color.rgb) * (texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1 * 2.0, alpha_output_1 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D141038E2E2869DE, 1ACA1B6676BF3978
// program: 3526EFD6EA584B4A, B80FA1B7F97410CD, 1ACA1B6676BF3978
// reference: 9A2ECF1D9FCDD923, 70A370D21404144E
// reference: 23CC035FA13AF45A, 3526EFD6EA584B4A
// shader: 8B31, 85A04404A2A0D3E5

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_8();
bool sub_9_32();
bool sub_33_96();
bool sub_146_166();
bool sub_167_259();
bool sub_190_192();
bool sub_194_195();
bool sub_197_198();
bool sub_200_202();
bool sub_232_234();
bool sub_236_237();
bool sub_239_240();
bool sub_242_244();
bool sub_260_4096();
bool sub_288_289();
bool sub_289_290();

bool exec_shader() {
    sub_260_4096();
    return true;
}

bool sub_0_8() {
    address_registers.x = (ivec2(vs_in_reg0.zz)).x;
    reg_tmp10 = uniforms.f[0].xxxz;
    reg_tmp10.xy = (vs_in_reg0.xyyy).xy;
    reg_tmp11 = uniforms.f[0].xxxx;
    reg_tmp12 = uniforms.f[0].xxxx;
    reg_tmp13 = uniforms.f[0].zzzz;
    reg_tmp4 = uniforms.f[0].xxxx;
    reg_tmp5 = uniforms.f[0].xxxx;
    return false;
}
bool sub_9_32() {
    vs_out_attr0 = reg_tmp10;
    reg_tmp13 = mul_s(uniforms.f[82], reg_tmp13);
    vs_out_attr1 = reg_tmp13;
    reg_tmp11.y = (uniforms.f[0].zzzz + -reg_tmp11.yyyy).y;
    reg_tmp12.y = (uniforms.f[0].zzzz + -reg_tmp12.yyyy).y;
    reg_tmp14.y = (uniforms.f[81].wwww).y;
    reg_tmp14.x = (mul_s(uniforms.f[0].wwww, reg_tmp14.yyyy)).x;
    reg_tmp2.x = rcp_s(reg_tmp14.x);
    reg_tmp14.z = (reg_tmp2.xxxx).z;
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp11.xyyy).xy;
    reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    reg_tmp11.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp12.xyyy).xy;
    reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    reg_tmp12.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    vs_out_attr2 = reg_tmp11;
    vs_out_attr3 = reg_tmp12;
    return false;
}
bool sub_33_96() {
    reg_tmp6.xyz = (-reg_tmp0.xyzz).xyz;
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    reg_tmp7.xyz = vec3(rcp_s(uniforms.f[81].y));
    reg_tmp8.xyz = (fma_s(reg_tmp6.xyzz, reg_tmp7.xyzz, uniforms.f[0].yyyy)).xyz;
    reg_tmp7.xyz = (floor(reg_tmp8.xyzz)).xyz;
    reg_tmp6.xyz = (fma_s(reg_tmp7.xyzz, -uniforms.f[81].yyyy, reg_tmp6.xyzz)).xyz;
    reg_tmp6 = min(uniforms.f[81].xxxx, reg_tmp6);
    reg_tmp6 = max(-uniforms.f[81].xxxx, reg_tmp6);
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp6.xxxx, reg_tmp6.xxxx)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp6.xxxx)).y;
    reg_tmp4.x = (reg_tmp1.xxxx).x;
    reg_tmp5.x = (reg_tmp1.yyyy).x;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp6.yyyy, reg_tmp6.yyyy)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp6.yyyy)).y;
    reg_tmp4.y = (reg_tmp1.xxxx).y;
    reg_tmp5.y = (reg_tmp1.yyyy).y;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp6.zzzz, reg_tmp6.zzzz)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp6.zzzz)).y;
    reg_tmp4.z = (reg_tmp1.xxxx).z;
    reg_tmp5.z = (reg_tmp1.yyyy).z;
    reg_tmp2.x = (mul_s(reg_tmp4.yyyy, reg_tmp5.zzzz)).x;
    reg_tmp2.y = (mul_s(reg_tmp5.yyyy, reg_tmp5.zzzz)).y;
    reg_tmp6.x = (mul_s(reg_tmp4.yyyy, reg_tmp4.zzzz)).x;
    reg_tmp6.y = (reg_tmp5.zzzz).y;
    reg_tmp6.z = (mul_s(-reg_tmp5.yyyy, reg_tmp4.zzzz)).z;
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    reg_tmp7.x = (mul_s(-reg_tmp2.xxxx, reg_tmp4.xxxx)).x;
    reg_tmp7.x = (fma_s(reg_tmp5.yyyy, reg_tmp5.xxxx, reg_tmp7.xxxx)).x;
    reg_tmp7.y = (mul_s(reg_tmp4.zzzz, reg_tmp4.xxxx)).y;
    reg_tmp7.z = (mul_s(reg_tmp2.yyyy, reg_tmp4.xxxx)).z;
    reg_tmp7.z = (fma_s(reg_tmp4.yyyy, reg_tmp5.xxxx, reg_tmp7.zzzz)).z;
    reg_tmp7.w = (uniforms.f[0].xxxx).w;
    reg_tmp8.x = (mul_s(reg_tmp2.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp8.x = (fma_s(reg_tmp5.yyyy, reg_tmp4.xxxx, reg_tmp8.xxxx)).x;
    reg_tmp8.y = (mul_s(-reg_tmp4.zzzz, reg_tmp5.xxxx)).y;
    reg_tmp8.z = (mul_s(-reg_tmp2.yyyy, reg_tmp5.xxxx)).z;
    reg_tmp8.z = (fma_s(reg_tmp4.yyyy, reg_tmp4.xxxx, reg_tmp8.zzzz)).z;
    reg_tmp8.w = (uniforms.f[0].xxxx).w;
    reg_tmp9 = uniforms.f[0].xxxz;
    return false;
}
bool sub_146_166() {
    reg_tmp2 = uniforms.f[90];
    reg_tmp3 = uniforms.f[91];
    reg_tmp4 = uniforms.f[92];
    reg_tmp5 = uniforms.f[0].xxxz;
    reg_tmp6 = mul_s(uniforms.f[86].xxxx, reg_tmp2);
    reg_tmp6 = fma_s(reg_tmp3, uniforms.f[86].yyyy, reg_tmp6);
    reg_tmp6 = fma_s(reg_tmp4, uniforms.f[86].zzzz, reg_tmp6);
    reg_tmp6 = fma_s(reg_tmp5, uniforms.f[86].wwww, reg_tmp6);
    reg_tmp7 = mul_s(uniforms.f[87].xxxx, reg_tmp2);
    reg_tmp7 = fma_s(reg_tmp3, uniforms.f[87].yyyy, reg_tmp7);
    reg_tmp7 = fma_s(reg_tmp4, uniforms.f[87].zzzz, reg_tmp7);
    reg_tmp7 = fma_s(reg_tmp5, uniforms.f[87].wwww, reg_tmp7);
    reg_tmp8 = mul_s(uniforms.f[88].xxxx, reg_tmp2);
    reg_tmp8 = fma_s(reg_tmp3, uniforms.f[88].yyyy, reg_tmp8);
    reg_tmp8 = fma_s(reg_tmp4, uniforms.f[88].zzzz, reg_tmp8);
    reg_tmp8 = fma_s(reg_tmp5, uniforms.f[88].wwww, reg_tmp8);
    reg_tmp9 = mul_s(uniforms.f[89].xxxx, reg_tmp2);
    reg_tmp9 = fma_s(reg_tmp3, uniforms.f[89].yyyy, reg_tmp9);
    reg_tmp9 = fma_s(reg_tmp4, uniforms.f[89].zzzz, reg_tmp9);
    reg_tmp9 = fma_s(reg_tmp5, uniforms.f[89].wwww, reg_tmp9);
    return false;
}
bool sub_167_259() {
    reg_tmp2.x = rcp_s(uniforms.f[81].y);
    reg_tmp2.xy = (mul_s(uniforms.f[2 + address_registers.x].zwww, reg_tmp2.xxxx)).xy;
    reg_tmp2.xy = (uniforms.f[0].yyyy + reg_tmp2.xyyy).xy;
    reg_tmp3.xy = (floor(reg_tmp2.xyyy)).xy;
    reg_tmp2.xy = (mul_s(uniforms.f[81].yyyy, reg_tmp3.xyyy)).xy;
    reg_tmp2.xy = (uniforms.f[2 + address_registers.x].zwww + -reg_tmp2.xyyy).xy;
    reg_tmp0.xy = (min(uniforms.f[81].xxxx, -reg_tmp2.xyyy)).xy;
    reg_tmp0.xy = (max(-uniforms.f[81].xxxx, reg_tmp0.xyyy)).xy;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp0.xxxx, reg_tmp0.xxxx)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.xxxx)).y;
    reg_tmp5.x = (uniforms.f[5 + address_registers.x].wwww).x;
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_190_192();
    }
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_194_195();
    }
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_197_198();
    }
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_200_202();
    }
    reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    reg_tmp4.z = (uniforms.f[83].xxxx).z;
    reg_tmp4.w = (-uniforms.f[83].yyyy).w;
    reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[3 + address_registers.x].xyyy)).xy;
    reg_tmp4.z = (-uniforms.f[3 + address_registers.x].zzzz).z;
    reg_tmp4.w = (-uniforms.f[3 + address_registers.x].wwww).w;
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    reg_tmp11.xy = (reg_tmp5.xyyy).xy;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp0.yyyy, reg_tmp0.yyyy)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.yyyy)).y;
    reg_tmp5.x = (uniforms.f[6 + address_registers.x].wwww).x;
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_232_234();
    }
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_236_237();
    }
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_239_240();
    }
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_242_244();
    }
    reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    reg_tmp4.z = (uniforms.f[83].zzzz).z;
    reg_tmp4.w = (-uniforms.f[83].wwww).w;
    reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[4 + address_registers.x].xyyy)).xy;
    reg_tmp4.z = (-uniforms.f[4 + address_registers.x].zzzz).z;
    reg_tmp4.w = (-uniforms.f[4 + address_registers.x].wwww).w;
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    reg_tmp12.xy = (reg_tmp5.xyyy).xy;
    return false;
}
bool sub_190_192() {
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_194_195() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_197_198() {
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_200_202() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_232_234() {
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_236_237() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_239_240() {
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_242_244() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_260_4096() {
    {
        sub_0_8();
    }
    reg_tmp10.xy = (uniforms.f[84].xyyy + reg_tmp10.xyyy).xy;
    reg_tmp10.xy = (mul_s(uniforms.f[2 + address_registers.x].xyyy, reg_tmp10.xyyy)).xy;
    reg_tmp2 = reg_tmp10.xzyw;
    reg_tmp2.z = (-reg_tmp2.zzzz).z;
    reg_tmp14 = reg_tmp2;
    reg_tmp0 = uniforms.f[7 + address_registers.x];
    {
        sub_33_96();
    }
    reg_tmp2.x = dot_s(reg_tmp14, reg_tmp6);
    reg_tmp2.y = dot_s(reg_tmp14, reg_tmp7);
    reg_tmp2.z = dot_s(reg_tmp14, reg_tmp8);
    reg_tmp2.w = dot_s(reg_tmp14, reg_tmp9);
    reg_tmp6 = uniforms.f[8 + address_registers.x];
    reg_tmp7 = uniforms.f[9 + address_registers.x];
    reg_tmp8 = uniforms.f[10 + address_registers.x];
    reg_tmp9 = uniforms.f[0].xxxz;
    reg_tmp6.w = (uniforms.f[5 + address_registers.x].xxxx).w;
    reg_tmp7.w = (uniforms.f[5 + address_registers.x].yyyy).w;
    reg_tmp8.w = (uniforms.f[5 + address_registers.x].zzzz).w;
    reg_tmp10.x = dot_s(reg_tmp2, reg_tmp6);
    reg_tmp10.y = dot_s(reg_tmp2, reg_tmp7);
    reg_tmp10.z = dot_s(reg_tmp2, reg_tmp8);
    reg_tmp10.w = dot_s(reg_tmp2, reg_tmp9);
    reg_tmp3.xyz = (uniforms.f[5 + address_registers.x].xyzz).xyz;
    reg_tmp3.xyz = (uniforms.f[85].xyzz + -reg_tmp3.xyzz).xyz;
    reg_tmp4.x = dot_3(reg_tmp3.xyz, reg_tmp3.xyz);
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
    if (conditional_code.x) {
        sub_288_289();
    } else {
        sub_289_290();
    }
    reg_tmp3.xyz = (mul_s(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
    reg_tmp10.xyz = (fma_s(reg_tmp3.xyzz, uniforms.f[84].zzzz, reg_tmp10.xyzz)).xyz;
    {
        sub_146_166();
    }
    reg_tmp2 = reg_tmp10;
    reg_tmp10.x = dot_s(reg_tmp2, reg_tmp6);
    reg_tmp10.y = dot_s(reg_tmp2, reg_tmp7);
    reg_tmp10.z = dot_s(reg_tmp2, reg_tmp8);
    reg_tmp10.w = dot_s(reg_tmp2, reg_tmp9);
    reg_tmp2 = uniforms.f[1 + address_registers.x];
    reg_tmp3 = max(uniforms.f[0].xxxx, reg_tmp2);
    reg_tmp2 = min(uniforms.f[0].zzzz, reg_tmp3);
    reg_tmp13 = reg_tmp2;
    {
        sub_167_259();
    }
    {
        sub_9_32();
    }
    return true;
}
bool sub_288_289() {
    reg_tmp4.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_289_290() {
    reg_tmp4.x = rsq_s(reg_tmp4.x);
    return false;
}
// reference: 9575143077AC3530, 85A04404A2A0D3E5
// program: 85A04404A2A0D3E5, 082670B4222015B2, DBA0F8FE46AD8D9B
// reference: 207EC0E582E301EE, 8AA3B6DF4767940E
// reference: EB88C6659FCDD923, 70A370D21404144E
// reference: 94E3DB311B75F7B7, 1BDE5ABD20055F26
// reference: 203ADF05608D1344, D9C174A4A54356AC
// reference: 6E6E2045E3787536, D9C174A4A54356AC
// reference: 02484B6055E77011, E81D148B6EF003F8
// reference: 4C1CB420D6121663, E81D148B6EF003F8
// reference: EE7451892D16A794, 5E28DB645EED49B7
// reference: A020AEC9AEE3C1E6, 5E28DB645EED49B7
// reference: F94185C65AEC18DD, 4028512EA840631E
// reference: 31057352C5AC9C70, 35CCCCDE75E2FF83
// reference: 002FFE0B3DCFDFFD, A40B5D829674D1F8
// reference: 4E7B014BBE3AB98F, A40B5D829674D1F8
// reference: 526A0A27A13AF45A, 3526EFD6EA584B4A
// reference: EB88C6652742D363, 70A370D21404144E
// reference: 94E3DB31030ADEEA, 1BDE5ABD20055F26
// reference: 203ADF0578F23A19, D9C174A4A54356AC
// reference: 6E6E2045FB075C6B, D9C174A4A54356AC
// reference: 02484B604D98594C, E81D148B6EF003F8
// reference: 4C1CB420CE6D3F3E, E81D148B6EF003F8
// reference: EE74518935698EC9, 5E28DB645EED49B7
// reference: A020AEC9B69CE8BB, 5E28DB645EED49B7
// reference: F94185C642933180, 4028512EA840631E
// reference: 31057352DDD3B52D, 35CCCCDE75E2FF83
// reference: 002FFE0B25B0F6A0, A40B5D829674D1F8
// reference: 4E7B014BA64590D2, A40B5D829674D1F8
// reference: 526A0A27B945DD07, 3526EFD6EA584B4A
// program: 70A370D21404144E, 082670B4222015B2, B51C0DE019B4AE20
// program: 1BDE5ABD20055F26, 082670B4222015B2, 1EF23692707A019C
// program: 1BDE5ABD20055F26, 082670B4222015B2, 0D8F34E8707A019C
// program: A40B5D829674D1F8, B80FA1B7F97410CD, 429F87F8D3AE0B36
// program: A40B5D829674D1F8, B80FA1B7F97410CD, 40BF4FB85B0B5330
// program: A40B5D829674D1F8, B80FA1B7F97410CD, EE82356499D9033F
// program: A40B5D829674D1F8, B80FA1B7F97410CD, 5F16273C5032C0B2
// program: A40B5D829674D1F8, B80FA1B7F97410CD, BC8FFFD904DA352D
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 7337CC71AC06DD60
// program: E81D148B6EF003F8, B80FA1B7F97410CD, CF7B55EB749B1745
// program: E81D148B6EF003F8, B80FA1B7F97410CD, F2989B699B9A67E9
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 64E77DF66C1C7766
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 3D2F05F592BCAC45
// program: D9C174A4A54356AC, 42937135801BAA7E, DBAEBC3C69195AAA
// program: D9C174A4A54356AC, 42937135801BAA7E, 62CB16D7F16FAC9B
// program: D9C174A4A54356AC, 42937135801BAA7E, 31DB35D8B8E9549F
// program: D9C174A4A54356AC, 42937135801BAA7E, EB5CA625F01267FB
// program: D9C174A4A54356AC, 42937135801BAA7E, F2C7CEFD4FAFF562
// shader: 8B30, 72AEE74A87B55733

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(normal, normalize(view))));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb) * (secondary_fragment_color.rrr) + (texcolor0.rgb) * (vec3(1.0) - (secondary_fragment_color.rrr)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 0EB02BAC89C8D99A, 72AEE74A87B55733
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 72AEE74A87B55733
// shader: 8B30, EF6E6A305FC7B5A1

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 00970B37A52CB7E1, EF6E6A305FC7B5A1
// program: D9C174A4A54356AC, 42937135801BAA7E, EF6E6A305FC7B5A1
// shader: 8B30, ADBF67247E14A994

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 00970B375ECCC658, ADBF67247E14A994
// program: D9C174A4A54356AC, 42937135801BAA7E, ADBF67247E14A994
// shader: 8B30, C6BAD9CE0AEB9402

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 783519FF9F954008, C6BAD9CE0AEB9402
// program: D9C174A4A54356AC, 42937135801BAA7E, C6BAD9CE0AEB9402
// shader: 8B30, 0C044E501EE62795

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 783519FF94A2BA1C, 0C044E501EE62795
// program: D9C174A4A54356AC, 42937135801BAA7E, 0C044E501EE62795
// shader: 8B30, AEB1A86E7E14A994

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].aaa);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 302F147C0681CBC8, AEB1A86E7E14A994
// program: D9C174A4A54356AC, 42937135801BAA7E, AEB1A86E7E14A994
// shader: 8B30, 244B48F0C67C62A2

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 783519FF6F42CBA5, 244B48F0C67C62A2
// program: D9C174A4A54356AC, 42937135801BAA7E, 244B48F0C67C62A2
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 790FB95CC0B11076
// program: 2E530FFFDA886761, B80FA1B7F97410CD, F35E8CA2CAC182F7
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 037898F85F34DE95
// program: 46E991DEB658A5A9, B80FA1B7F97410CD, 91931D139F54748D
// program: 46E991DEB658A5A9, B80FA1B7F97410CD, 5FACCC9E3E0584D2
// program: 81B0676B862CF405, 42937135801BAA7E, F5D54925A6AE705F
// program: 81B0676B862CF405, 42937135801BAA7E, 835CABE3A4B650D2
// program: 81B0676B862CF405, 42937135801BAA7E, D4C9E99618707555
// program: 81B0676B862CF405, 42937135801BAA7E, 0951EE62DBCF2390
// program: 81B0676B862CF405, 42937135801BAA7E, 233D9A25E7282666
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 26CF8128A3DDBB83
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 953385FED82E0FD1
// program: 2E530FFFDA886761, B80FA1B7F97410CD, E52C4E220978C964
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 378438FF70532E82
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 9F25A997909124C1
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 168DA83A29634DCC
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 576E786439C2EA2F
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 1471721266F6CFF3
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 90EA57FA2E348842
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 1212B53523129C17
// program: 2E530FFFDA886761, B80FA1B7F97410CD, C9A23B908E5F8ABB
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 7E2D94A79BE7422B
// program: 91D55C04BB07EE32, B80FA1B7F97410CD, 9342C6596F83F706
// program: 2E530FFFDA886761, B80FA1B7F97410CD, D02B1E1378BD97CF
// program: 2E530FFFDA886761, B80FA1B7F97410CD, B78314A585D12D9C
// program: 2E530FFFDA886761, B80FA1B7F97410CD, DEC6EAEA57FA4325
// program: 2E530FFFDA886761, B80FA1B7F97410CD, D4C50B709583D191
// program: 2E530FFFDA886761, B80FA1B7F97410CD, B20F7E72A7330A13
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 48065A05481CB4B8
// program: 2E530FFFDA886761, B80FA1B7F97410CD, BB80E4A110994B48
// program: 2E530FFFDA886761, B80FA1B7F97410CD, EAAC665924781109
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 0656C780E79F2203
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 31E556E9A7729BF4
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 6C66577708AE1E87
// program: 2E530FFFDA886761, B80FA1B7F97410CD, FC7222C50C6F5038
// program: 2E530FFFDA886761, B80FA1B7F97410CD, D1B1A073730D724F
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 7ED2F034E5EB4FC6
// reference: 2FBDCACD19AFCDF2, 46E991DEB658A5A9
// program: 46E991DEB658A5A9, B80FA1B7F97410CD, 8B9E362C16D3C52E
// reference: 26B611F7AF19CC73, 81B0676B862CF405
// program: 81B0676B862CF405, 42937135801BAA7E, 21786A34D707A069
// reference: 68E2EEB72CECAA01, 81B0676B862CF405
// program: 81B0676B862CF405, 42937135801BAA7E, 5124AD903EB19D9F
// program: 81B0676B862CF405, 42937135801BAA7E, DFCB363A2A0B3CC5
// program: 81B0676B862CF405, 42937135801BAA7E, F560208BD4D2027B
// program: 81B0676B862CF405, 42937135801BAA7E, 0027CEC45E8FAB67
// program: 81B0676B862CF405, 42937135801BAA7E, 143AFBD072626A3C
// program: 81B0676B862CF405, 42937135801BAA7E, 29C64432F3BC1BED
// program: 81B0676B862CF405, 42937135801BAA7E, DF3F131ABF324C64
// program: 81B0676B862CF405, 42937135801BAA7E, 1213C240BC74F0A4
// program: 81B0676B862CF405, 42937135801BAA7E, C8E2E0613F536B3E
// program: 81B0676B862CF405, 42937135801BAA7E, AA3A46EC91E54F18
// reference: 04C48592F0ED8FA7, 2E530FFFDA886761
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 26CF8128A3DDBB83
// reference: 4A907AD27318E9D5, 2E530FFFDA886761
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 953385FED82E0FD1
// program: 2E530FFFDA886761, B80FA1B7F97410CD, E52C4E220978C964
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 378438FF70532E82
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 9F25A997909124C1
// program: 2E530FFFDA886761, B80FA1B7F97410CD, F35E8CA2CAC182F7
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 168DA83A29634DCC
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 576E786439C2EA2F
// program: 2E530FFFDA886761, B80FA1B7F97410CD, FFE5F81052CAA889
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 1471721266F6CFF3
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 90EA57FA2E348842
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 1212B53523129C17
// program: 2E530FFFDA886761, B80FA1B7F97410CD, C9A23B908E5F8ABB
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 7E2D94A79BE7422B
// reference: 2798006860C24773, 91D55C04BB07EE32
// program: 91D55C04BB07EE32, B80FA1B7F97410CD, 9342C6596F83F706
// program: 2E530FFFDA886761, B80FA1B7F97410CD, D02B1E1378BD97CF
// program: 2E530FFFDA886761, B80FA1B7F97410CD, B78314A585D12D9C
// program: 2E530FFFDA886761, B80FA1B7F97410CD, DEC6EAEA57FA4325
// program: 2E530FFFDA886761, B80FA1B7F97410CD, D4C50B709583D191
// program: 2E530FFFDA886761, B80FA1B7F97410CD, B20F7E72A7330A13
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 48065A05481CB4B8
// program: 2E530FFFDA886761, B80FA1B7F97410CD, BB80E4A110994B48
// program: 2E530FFFDA886761, B80FA1B7F97410CD, EAAC665924781109
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 0656C780E79F2203
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 31E556E9A7729BF4
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 6C66577708AE1E87
// program: 2E530FFFDA886761, B80FA1B7F97410CD, FC7222C50C6F5038
// program: 2E530FFFDA886761, B80FA1B7F97410CD, D1B1A073730D724F
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 790FB95CC0B11076
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 037898F85F34DE95
// reference: 7226085EE1CA095D, 46E991DEB658A5A9
// program: 46E991DEB658A5A9, B80FA1B7F97410CD, 91931D139F54748D
// program: 46E991DEB658A5A9, B80FA1B7F97410CD, 5FACCC9E3E0584D2
// reference: 3C72F71E623F6F2F, 46E991DEB658A5A9
// reference: 26B611F720173D14, 81B0676B862CF405
// program: 81B0676B862CF405, 42937135801BAA7E, 835CABE3A4B650D2
// program: 81B0676B862CF405, 42937135801BAA7E, F5D54925A6AE705F
// reference: 68E2EEB7A3E25B66, 81B0676B862CF405
// program: 81B0676B862CF405, 42937135801BAA7E, D4C9E99618707555
// program: 81B0676B862CF405, 42937135801BAA7E, 0951EE62DBCF2390
// program: 81B0676B862CF405, 42937135801BAA7E, 233D9A25E7282666
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 7ED2F034E5EB4FC6
// program: 2E530FFFDA886761, B80FA1B7F97410CD, BC32652205728950
// program: 81B0676B862CF405, 42937135801BAA7E, 886AC14BAA341C33
// program: 81B0676B862CF405, 42937135801BAA7E, 7C14C907B3CCD849
// program: 81B0676B862CF405, 42937135801BAA7E, 3018EA11DFB984D3
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 10AAC2A3349D1A7E
// program: 81B0676B862CF405, 42937135801BAA7E, 52F5F74AF1B519B6
// program: 81B0676B862CF405, 42937135801BAA7E, 98F0722A788E01FD
// program: 81B0676B862CF405, 42937135801BAA7E, 6E5C02D38B9C02DF
// program: 81B0676B862CF405, 42937135801BAA7E, A4E2954DD6C4FB71
// program: 81B0676B862CF405, 42937135801BAA7E, 5F0787304B8A0BD1
// reference: 04C485925A0B786A, FD3DADE0E2BC47C9
// program: FD3DADE0E2BC47C9, B80FA1B7F97410CD, 19F7816C4117CF8E
// reference: 26B611F75903F6F2, 81B0676B862CF405
// program: 81B0676B862CF405, 42937135801BAA7E, 5FBCCF5F27F5A7C1
// reference: 68E2EEB7DAF69080, 81B0676B862CF405
// program: 81B0676B862CF405, 42937135801BAA7E, 63B6ADAD25C2A518
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 47E4BEE6B3304AF3
// program: 2E530FFFDA886761, B80FA1B7F97410CD, C580B429ECAF519A
// program: 1934FF8F80653ACB, B80FA1B7F97410CD, 5C250F6C1418BBD3
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 4BA25B84A31C492A
// program: 81B0676B862CF405, 42937135801BAA7E, CAB8B665DC444CE4
// program: 81B0676B862CF405, 42937135801BAA7E, 6B98A4CC666FCBCF
// program: 81B0676B862CF405, 42937135801BAA7E, D1257B6267770D05
// program: 81B0676B862CF405, 42937135801BAA7E, D134C63316570D84
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 40FC95A67F54598B
// program: 2E530FFFDA886761, B80FA1B7F97410CD, D69A3CB52F0E3495
// program: 2E530FFFDA886761, B80FA1B7F97410CD, B5CB613BFC4BC41C
// program: 46E991DEB658A5A9, B80FA1B7F97410CD, 1B4DA8DA884D39A1
// program: 2E530FFFDA886761, B80FA1B7F97410CD, D2BD0C5FAA2AB273
// program: 2E530FFFDA886761, B80FA1B7F97410CD, F8FBCC791CAC22F2
// program: 2E530FFFDA886761, B80FA1B7F97410CD, FEE7FD4C7FD3D731
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 8633243B2123B710
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 39E142A8F1F39B96
// program: 2E530FFFDA886761, B80FA1B7F97410CD, FC9E10BE42F07103
// program: C6410D4382B19655, 082670B4222015B2, DBA0F8FE46AD8D9B
// program: 81B0676B862CF405, 42937135801BAA7E, 47A8279A60685F27
// program: 466184E6A05DFF0F, B80FA1B7F97410CD, C2EEBEAE0D7F3560
// program: 45C9694A57480945, B80FA1B7F97410CD, 490CACB848ED440A
// program: D03F0FE4B72A8E86, B80FA1B7F97410CD, 1CBA1DD1EAE2F663
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 6A08A79BE3FAC39D
// program: FD3DADE0E2BC47C9, B80FA1B7F97410CD, 10AAC2A3349D1A7E
// program: 949D68475595512F, 082670B4222015B2, 0D19D21B46AD8D9B
// program: 81B0676B862CF405, 42937135801BAA7E, 29CD3EBE51FAA42A
// program: 81B0676B862CF405, 42937135801BAA7E, B2E64CFB9744D892
// program: 81B0676B862CF405, 42937135801BAA7E, 98647FD3CF93B689
// program: 949D68475595512F, 082670B4222015B2, DBA0F8FE46AD8D9B
// program: 2FBE2E4ED1D9324C, 082670B4222015B2, DBA0F8FE46AD8D9B
// program: 2FBE2E4ED1D9324C, 082670B4222015B2, F4A415D97E9B6ED6
// program: 81B0676B862CF405, 42937135801BAA7E, AB0D786CFAD777F8
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 6A44D3E672630106
// program: 45C9694A57480945, B80FA1B7F97410CD, 0AC00F84117E7EFC
// program: 1B722ADD909A7B2D, B80FA1B7F97410CD, B3C2F6056AADCF6F
// program: 1B722ADD909A7B2D, B80FA1B7F97410CD, A36D1D6BA424DB28
// program: 1B722ADD909A7B2D, B80FA1B7F97410CD, 641FDB3E9E36B758
// program: 949D68475595512F, 082670B4222015B2, 1430EF96EBF7840F
// program: B0CCAE4F9AB69CDA, B80FA1B7F97410CD, C2EEBEAE0D7F3560
// program: D03F0FE4B72A8E86, B80FA1B7F97410CD, 9D0535C6802495CB
// program: 949D68475595512F, 082670B4222015B2, 63A5270519B4AE20
// program: 81B0676B862CF405, 42937135801BAA7E, 49F399BDFAD777F8
// program: 81B0676B862CF405, 42937135801BAA7E, 00F9BB7ACF93B689
// program: A214E3C9645157AE, B80FA1B7F97410CD, B766CBB102E471E4
// program: 2FBE2E4ED1D9324C, 082670B4222015B2, B51C0DE019B4AE20
// program: C6410D4382B19655, 082670B4222015B2, 1EF23692707A019C
// program: C6410D4382B19655, 082670B4222015B2, 0D8F34E8707A019C
// program: 2FBE2E4ED1D9324C, 082670B4222015B2, 63A5270519B4AE20
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 3013FC5CF83A846B
// program: 46E991DEB658A5A9, B80FA1B7F97410CD, FC9E10BE42F07103
// program: 81B0676B862CF405, 42937135801BAA7E, 9978311FA4F16C3C
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 01575BADBADD21EF
// program: 2E530FFFDA886761, B80FA1B7F97410CD, ABC97C54A7BF4D60
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 26BBC1E6E0D6F7FF
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 7337CC71AC06DD60
// program: 2E530FFFDA886761, B80FA1B7F97410CD, CF7B55EB749B1745
// program: 2E530FFFDA886761, B80FA1B7F97410CD, F2989B699B9A67E9
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 64E77DF66C1C7766
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 3D2F05F592BCAC45
// program: 81B0676B862CF405, 42937135801BAA7E, DBAEBC3C69195AAA
// program: 81B0676B862CF405, 42937135801BAA7E, 62CB16D7F16FAC9B
// program: 81B0676B862CF405, 42937135801BAA7E, 31DB35D8B8E9549F
// program: 81B0676B862CF405, 42937135801BAA7E, EB5CA625F01267FB
// program: 81B0676B862CF405, 42937135801BAA7E, F2C7CEFD4FAFF562
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 72AEE74A87B55733
// program: 81B0676B862CF405, 42937135801BAA7E, EF6E6A305FC7B5A1
// program: 81B0676B862CF405, 42937135801BAA7E, ADBF67247E14A994
// program: 81B0676B862CF405, 42937135801BAA7E, C6BAD9CE0AEB9402
// program: 81B0676B862CF405, 42937135801BAA7E, 0C044E501EE62795
// program: 81B0676B862CF405, 42937135801BAA7E, 244B48F0C67C62A2
// shader: 8B30, 845BE22385985D0D

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].aaa);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (const_color[1].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) * (const_color[2].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 0A7D03F062908828, 845BE22385985D0D
// program: 81B0676B862CF405, 42937135801BAA7E, 845BE22385985D0D
// shader: 8B30, 0CF4F1A3F0CD23DE

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) * (const_color[2].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: E32461D938807D48, 0CF4F1A3F0CD23DE
// program: 81B0676B862CF405, 42937135801BAA7E, 0CF4F1A3F0CD23DE
// shader: 8B30, C6E631A4341619F7

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) * (const_color[2].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: E32461D91DAC008A, C6E631A4341619F7
// program: 81B0676B862CF405, 42937135801BAA7E, C6E631A4341619F7
// shader: 8B30, 871EEEDAA5BF33BF

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) * (const_color[2].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: E32461D9ED7B8B27, 871EEEDAA5BF33BF
// program: 81B0676B862CF405, 42937135801BAA7E, 871EEEDAA5BF33BF
// shader: 8B30, 94FD04EAF8930EBD

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].aaa);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) * (const_color[2].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D39C7E924ED6F70E, 94FD04EAF8930EBD
// program: 81B0676B862CF405, 42937135801BAA7E, 94FD04EAF8930EBD
// shader: 8B30, DE28FACD4F3757E0

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) * (const_color[2].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: E32461D9169BFA9E, DE28FACD4F3757E0
// program: 81B0676B862CF405, 42937135801BAA7E, DE28FACD4F3757E0
// shader: 8B30, 633530313DBD6C5F

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) * (const_color[2].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: E32461D9C857F6E5, 633530313DBD6C5F
// program: 81B0676B862CF405, 42937135801BAA7E, 633530313DBD6C5F
// reference: 2484D2FF9466B309, 493A89E34FC6D4B5
// program: 493A89E34FC6D4B5, 082670B4222015B2, DBA0F8FE46AD8D9B
// shader: 8B31, DDF9B003B681BCE8

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define fma_s(x, y, z) (mix(x * y, vec4(0.0), isnan(x * y)) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_8();
bool sub_9_32();
bool sub_33_96();
bool sub_146_166();
bool sub_167_259();
bool sub_190_192();
bool sub_194_195();
bool sub_197_198();
bool sub_200_202();
bool sub_232_234();
bool sub_236_237();
bool sub_239_240();
bool sub_242_244();
bool sub_260_4096();
bool sub_288_289();
bool sub_289_290();

bool exec_shader() {
    sub_260_4096();
    return true;
}

bool sub_0_8() {
    address_registers.x = (ivec2(vs_in_reg0.zz)).x;
    reg_tmp10 = uniforms.f[0].xxxz;
    reg_tmp10.xy = (vs_in_reg0.xyyy).xy;
    reg_tmp11 = uniforms.f[0].xxxx;
    reg_tmp12 = uniforms.f[0].xxxx;
    reg_tmp13 = uniforms.f[0].zzzz;
    reg_tmp4 = uniforms.f[0].xxxx;
    reg_tmp5 = uniforms.f[0].xxxx;
    return false;
}
bool sub_9_32() {
    vs_out_attr0 = reg_tmp10;
    reg_tmp13 = mul_s(uniforms.f[82], reg_tmp13);
    vs_out_attr1 = reg_tmp13;
    reg_tmp11.y = (uniforms.f[0].zzzz + -reg_tmp11.yyyy).y;
    reg_tmp12.y = (uniforms.f[0].zzzz + -reg_tmp12.yyyy).y;
    reg_tmp14.y = (uniforms.f[81].wwww).y;
    reg_tmp14.x = (mul_s(uniforms.f[0].wwww, reg_tmp14.yyyy)).x;
    reg_tmp2.x = rcp_s(reg_tmp14.x);
    reg_tmp14.z = (reg_tmp2.xxxx).z;
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp11.xyyy).xy;
    reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    reg_tmp11.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp12.xyyy).xy;
    reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    reg_tmp12.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    vs_out_attr2 = reg_tmp11;
    vs_out_attr3 = reg_tmp12;
    return false;
}
bool sub_33_96() {
    reg_tmp6.xyz = (-reg_tmp0.xyzz).xyz;
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    reg_tmp7.xyz = vec3(rcp_s(uniforms.f[81].y));
    reg_tmp8.xyz = (fma_s(reg_tmp6.xyzz, reg_tmp7.xyzz, uniforms.f[0].yyyy)).xyz;
    reg_tmp7.xyz = (floor(reg_tmp8.xyzz)).xyz;
    reg_tmp6.xyz = (fma_s(reg_tmp7.xyzz, -uniforms.f[81].yyyy, reg_tmp6.xyzz)).xyz;
    reg_tmp6 = min(uniforms.f[81].xxxx, reg_tmp6);
    reg_tmp6 = max(-uniforms.f[81].xxxx, reg_tmp6);
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp6.xxxx, reg_tmp6.xxxx)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp6.xxxx)).y;
    reg_tmp4.x = (reg_tmp1.xxxx).x;
    reg_tmp5.x = (reg_tmp1.yyyy).x;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp6.yyyy, reg_tmp6.yyyy)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp6.yyyy)).y;
    reg_tmp4.y = (reg_tmp1.xxxx).y;
    reg_tmp5.y = (reg_tmp1.yyyy).y;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp6.zzzz, reg_tmp6.zzzz)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp6.zzzz)).y;
    reg_tmp4.z = (reg_tmp1.xxxx).z;
    reg_tmp5.z = (reg_tmp1.yyyy).z;
    reg_tmp2.x = (mul_s(reg_tmp4.yyyy, reg_tmp5.zzzz)).x;
    reg_tmp2.y = (mul_s(reg_tmp5.yyyy, reg_tmp5.zzzz)).y;
    reg_tmp6.x = (mul_s(reg_tmp4.yyyy, reg_tmp4.zzzz)).x;
    reg_tmp6.y = (reg_tmp5.zzzz).y;
    reg_tmp6.z = (mul_s(-reg_tmp5.yyyy, reg_tmp4.zzzz)).z;
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    reg_tmp7.x = (mul_s(-reg_tmp2.xxxx, reg_tmp4.xxxx)).x;
    reg_tmp7.x = (fma_s(reg_tmp5.yyyy, reg_tmp5.xxxx, reg_tmp7.xxxx)).x;
    reg_tmp7.y = (mul_s(reg_tmp4.zzzz, reg_tmp4.xxxx)).y;
    reg_tmp7.z = (mul_s(reg_tmp2.yyyy, reg_tmp4.xxxx)).z;
    reg_tmp7.z = (fma_s(reg_tmp4.yyyy, reg_tmp5.xxxx, reg_tmp7.zzzz)).z;
    reg_tmp7.w = (uniforms.f[0].xxxx).w;
    reg_tmp8.x = (mul_s(reg_tmp2.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp8.x = (fma_s(reg_tmp5.yyyy, reg_tmp4.xxxx, reg_tmp8.xxxx)).x;
    reg_tmp8.y = (mul_s(-reg_tmp4.zzzz, reg_tmp5.xxxx)).y;
    reg_tmp8.z = (mul_s(-reg_tmp2.yyyy, reg_tmp5.xxxx)).z;
    reg_tmp8.z = (fma_s(reg_tmp4.yyyy, reg_tmp4.xxxx, reg_tmp8.zzzz)).z;
    reg_tmp8.w = (uniforms.f[0].xxxx).w;
    reg_tmp9 = uniforms.f[0].xxxz;
    return false;
}
bool sub_146_166() {
    reg_tmp2 = uniforms.f[90];
    reg_tmp3 = uniforms.f[91];
    reg_tmp4 = uniforms.f[92];
    reg_tmp5 = uniforms.f[0].xxxz;
    reg_tmp6 = mul_s(uniforms.f[86].xxxx, reg_tmp2);
    reg_tmp6 = fma_s(reg_tmp3, uniforms.f[86].yyyy, reg_tmp6);
    reg_tmp6 = fma_s(reg_tmp4, uniforms.f[86].zzzz, reg_tmp6);
    reg_tmp6 = fma_s(reg_tmp5, uniforms.f[86].wwww, reg_tmp6);
    reg_tmp7 = mul_s(uniforms.f[87].xxxx, reg_tmp2);
    reg_tmp7 = fma_s(reg_tmp3, uniforms.f[87].yyyy, reg_tmp7);
    reg_tmp7 = fma_s(reg_tmp4, uniforms.f[87].zzzz, reg_tmp7);
    reg_tmp7 = fma_s(reg_tmp5, uniforms.f[87].wwww, reg_tmp7);
    reg_tmp8 = mul_s(uniforms.f[88].xxxx, reg_tmp2);
    reg_tmp8 = fma_s(reg_tmp3, uniforms.f[88].yyyy, reg_tmp8);
    reg_tmp8 = fma_s(reg_tmp4, uniforms.f[88].zzzz, reg_tmp8);
    reg_tmp8 = fma_s(reg_tmp5, uniforms.f[88].wwww, reg_tmp8);
    reg_tmp9 = mul_s(uniforms.f[89].xxxx, reg_tmp2);
    reg_tmp9 = fma_s(reg_tmp3, uniforms.f[89].yyyy, reg_tmp9);
    reg_tmp9 = fma_s(reg_tmp4, uniforms.f[89].zzzz, reg_tmp9);
    reg_tmp9 = fma_s(reg_tmp5, uniforms.f[89].wwww, reg_tmp9);
    return false;
}
bool sub_167_259() {
    reg_tmp2.x = rcp_s(uniforms.f[81].y);
    reg_tmp2.xy = (mul_s(uniforms.f[2 + address_registers.x].zwww, reg_tmp2.xxxx)).xy;
    reg_tmp2.xy = (uniforms.f[0].yyyy + reg_tmp2.xyyy).xy;
    reg_tmp3.xy = (floor(reg_tmp2.xyyy)).xy;
    reg_tmp2.xy = (mul_s(uniforms.f[81].yyyy, reg_tmp3.xyyy)).xy;
    reg_tmp2.xy = (uniforms.f[2 + address_registers.x].zwww + -reg_tmp2.xyyy).xy;
    reg_tmp0.xy = (min(uniforms.f[81].xxxx, -reg_tmp2.xyyy)).xy;
    reg_tmp0.xy = (max(-uniforms.f[81].xxxx, reg_tmp0.xyyy)).xy;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp0.xxxx, reg_tmp0.xxxx)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.xxxx)).y;
    reg_tmp5.x = (uniforms.f[5 + address_registers.x].wwww).x;
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_190_192();
    }
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_194_195();
    }
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_197_198();
    }
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_200_202();
    }
    reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    reg_tmp4.z = (uniforms.f[83].xxxx).z;
    reg_tmp4.w = (-uniforms.f[83].yyyy).w;
    reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[3 + address_registers.x].xyyy)).xy;
    reg_tmp4.z = (-uniforms.f[3 + address_registers.x].zzzz).z;
    reg_tmp4.w = (-uniforms.f[3 + address_registers.x].wwww).w;
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    reg_tmp11.xy = (reg_tmp5.xyyy).xy;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp0.yyyy, reg_tmp0.yyyy)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.yyyy)).y;
    reg_tmp5.x = (uniforms.f[6 + address_registers.x].wwww).x;
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_232_234();
    }
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_236_237();
    }
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_239_240();
    }
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_242_244();
    }
    reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    reg_tmp4.z = (uniforms.f[83].zzzz).z;
    reg_tmp4.w = (-uniforms.f[83].wwww).w;
    reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[4 + address_registers.x].xyyy)).xy;
    reg_tmp4.z = (-uniforms.f[4 + address_registers.x].zzzz).z;
    reg_tmp4.w = (-uniforms.f[4 + address_registers.x].wwww).w;
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    reg_tmp12.xy = (reg_tmp5.xyyy).xy;
    return false;
}
bool sub_190_192() {
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_194_195() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_197_198() {
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_200_202() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_232_234() {
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_236_237() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_239_240() {
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_242_244() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_260_4096() {
    {
        sub_0_8();
    }
    reg_tmp10.xy = (uniforms.f[84].xyyy + reg_tmp10.xyyy).xy;
    reg_tmp10.xy = (mul_s(uniforms.f[2 + address_registers.x].xyyy, reg_tmp10.xyyy)).xy;
    reg_tmp2 = reg_tmp10.xzyw;
    reg_tmp2.z = (-reg_tmp2.zzzz).z;
    reg_tmp14 = reg_tmp2;
    reg_tmp0 = uniforms.f[7 + address_registers.x];
    {
        sub_33_96();
    }
    reg_tmp2.x = dot_s(reg_tmp14, reg_tmp6);
    reg_tmp2.y = dot_s(reg_tmp14, reg_tmp7);
    reg_tmp2.z = dot_s(reg_tmp14, reg_tmp8);
    reg_tmp2.w = dot_s(reg_tmp14, reg_tmp9);
    reg_tmp6 = uniforms.f[8 + address_registers.x];
    reg_tmp7 = uniforms.f[9 + address_registers.x];
    reg_tmp8 = uniforms.f[10 + address_registers.x];
    reg_tmp9 = uniforms.f[0].xxxz;
    reg_tmp6.w = (uniforms.f[5 + address_registers.x].xxxx).w;
    reg_tmp7.w = (uniforms.f[5 + address_registers.x].yyyy).w;
    reg_tmp8.w = (uniforms.f[5 + address_registers.x].zzzz).w;
    reg_tmp10.x = dot_s(reg_tmp2, reg_tmp6);
    reg_tmp10.y = dot_s(reg_tmp2, reg_tmp7);
    reg_tmp10.z = dot_s(reg_tmp2, reg_tmp8);
    reg_tmp10.w = dot_s(reg_tmp2, reg_tmp9);
    reg_tmp3.xyz = (uniforms.f[5 + address_registers.x].xyzz).xyz;
    reg_tmp3.xyz = (uniforms.f[85].xyzz + -reg_tmp3.xyzz).xyz;
    reg_tmp4.x = dot_3(reg_tmp3.xyz, reg_tmp3.xyz);
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
    if (conditional_code.x) {
        sub_288_289();
    } else {
        sub_289_290();
    }
    reg_tmp3.xyz = (mul_s(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
    reg_tmp10.xyz = (fma_s(reg_tmp3.xyzz, uniforms.f[84].zzzz, reg_tmp10.xyzz)).xyz;
    {
        sub_146_166();
    }
    reg_tmp2 = reg_tmp10;
    reg_tmp10.x = dot_s(reg_tmp2, reg_tmp6);
    reg_tmp10.y = dot_s(reg_tmp2, reg_tmp7);
    reg_tmp10.z = dot_s(reg_tmp2, reg_tmp8);
    reg_tmp10.w = dot_s(reg_tmp2, reg_tmp9);
    reg_tmp2 = uniforms.f[1 + address_registers.x];
    reg_tmp3 = max(uniforms.f[0].xxxx, reg_tmp2);
    reg_tmp2 = min(uniforms.f[0].zzzz, reg_tmp3);
    reg_tmp13 = reg_tmp2;
    {
        sub_167_259();
    }
    {
        sub_9_32();
    }
    return true;
}
bool sub_288_289() {
    reg_tmp4.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_289_290() {
    reg_tmp4.x = rsq_s(reg_tmp4.x);
    return false;
}
// reference: DB21EB70184260BE, DDF9B003B681BCE8
// program: DDF9B003B681BCE8, 082670B4222015B2, DBA0F8FE46AD8D9B
// reference: 256026724BB2C265, 949D68475595512F
// reference: 3B5774B2E6CBDB31, 46E991DEB658A5A9
// reference: 75038BF2653EBD43, 46E991DEB658A5A9
// reference: DFEDDD06B3BF40E4, 81B0676B862CF405
// reference: 91B92246304A2696, 81B0676B862CF405
// reference: FD9F4963A1C07C63, 2E530FFFDA886761
// reference: B3CBB62322351A11, 2E530FFFDA886761
// reference: DEC3CC9931EFB4B7, 91D55C04BB07EE32
// reference: AAF5D9849466B309, 493A89E34FC6D4B5
// reference: 256026721934F49D, 949D68475595512F
// shader: 8B31, D172C14891C0D4D7

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define fma_s(x, y, z) (mix(x * y, vec4(0.0), isnan(x * y)) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_8();
bool sub_9_32();
bool sub_146_166();
bool sub_167_259();
bool sub_190_192();
bool sub_194_195();
bool sub_197_198();
bool sub_200_202();
bool sub_232_234();
bool sub_236_237();
bool sub_239_240();
bool sub_242_244();
bool sub_260_4096();
bool sub_270_271();
bool sub_271_272();
bool sub_278_279();
bool sub_279_280();
bool sub_305_306();
bool sub_306_307();

bool exec_shader() {
    sub_260_4096();
    return true;
}

bool sub_0_8() {
    address_registers.x = (ivec2(vs_in_reg0.zz)).x;
    reg_tmp10 = uniforms.f[0].xxxz;
    reg_tmp10.xy = (vs_in_reg0.xyyy).xy;
    reg_tmp11 = uniforms.f[0].xxxx;
    reg_tmp12 = uniforms.f[0].xxxx;
    reg_tmp13 = uniforms.f[0].zzzz;
    reg_tmp4 = uniforms.f[0].xxxx;
    reg_tmp5 = uniforms.f[0].xxxx;
    return false;
}
bool sub_9_32() {
    vs_out_attr0 = reg_tmp10;
    reg_tmp13 = mul_s(uniforms.f[82], reg_tmp13);
    vs_out_attr1 = reg_tmp13;
    reg_tmp11.y = (uniforms.f[0].zzzz + -reg_tmp11.yyyy).y;
    reg_tmp12.y = (uniforms.f[0].zzzz + -reg_tmp12.yyyy).y;
    reg_tmp14.y = (uniforms.f[81].wwww).y;
    reg_tmp14.x = (mul_s(uniforms.f[0].wwww, reg_tmp14.yyyy)).x;
    reg_tmp2.x = rcp_s(reg_tmp14.x);
    reg_tmp14.z = (reg_tmp2.xxxx).z;
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp11.xyyy).xy;
    reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    reg_tmp11.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp12.xyyy).xy;
    reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    reg_tmp12.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    vs_out_attr2 = reg_tmp11;
    vs_out_attr3 = reg_tmp12;
    return false;
}
bool sub_146_166() {
    reg_tmp2 = uniforms.f[90];
    reg_tmp3 = uniforms.f[91];
    reg_tmp4 = uniforms.f[92];
    reg_tmp5 = uniforms.f[0].xxxz;
    reg_tmp6 = mul_s(uniforms.f[86].xxxx, reg_tmp2);
    reg_tmp6 = fma_s(reg_tmp3, uniforms.f[86].yyyy, reg_tmp6);
    reg_tmp6 = fma_s(reg_tmp4, uniforms.f[86].zzzz, reg_tmp6);
    reg_tmp6 = fma_s(reg_tmp5, uniforms.f[86].wwww, reg_tmp6);
    reg_tmp7 = mul_s(uniforms.f[87].xxxx, reg_tmp2);
    reg_tmp7 = fma_s(reg_tmp3, uniforms.f[87].yyyy, reg_tmp7);
    reg_tmp7 = fma_s(reg_tmp4, uniforms.f[87].zzzz, reg_tmp7);
    reg_tmp7 = fma_s(reg_tmp5, uniforms.f[87].wwww, reg_tmp7);
    reg_tmp8 = mul_s(uniforms.f[88].xxxx, reg_tmp2);
    reg_tmp8 = fma_s(reg_tmp3, uniforms.f[88].yyyy, reg_tmp8);
    reg_tmp8 = fma_s(reg_tmp4, uniforms.f[88].zzzz, reg_tmp8);
    reg_tmp8 = fma_s(reg_tmp5, uniforms.f[88].wwww, reg_tmp8);
    reg_tmp9 = mul_s(uniforms.f[89].xxxx, reg_tmp2);
    reg_tmp9 = fma_s(reg_tmp3, uniforms.f[89].yyyy, reg_tmp9);
    reg_tmp9 = fma_s(reg_tmp4, uniforms.f[89].zzzz, reg_tmp9);
    reg_tmp9 = fma_s(reg_tmp5, uniforms.f[89].wwww, reg_tmp9);
    return false;
}
bool sub_167_259() {
    reg_tmp2.x = rcp_s(uniforms.f[81].y);
    reg_tmp2.xy = (mul_s(uniforms.f[2 + address_registers.x].zwww, reg_tmp2.xxxx)).xy;
    reg_tmp2.xy = (uniforms.f[0].yyyy + reg_tmp2.xyyy).xy;
    reg_tmp3.xy = (floor(reg_tmp2.xyyy)).xy;
    reg_tmp2.xy = (mul_s(uniforms.f[81].yyyy, reg_tmp3.xyyy)).xy;
    reg_tmp2.xy = (uniforms.f[2 + address_registers.x].zwww + -reg_tmp2.xyyy).xy;
    reg_tmp0.xy = (min(uniforms.f[81].xxxx, -reg_tmp2.xyyy)).xy;
    reg_tmp0.xy = (max(-uniforms.f[81].xxxx, reg_tmp0.xyyy)).xy;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp0.xxxx, reg_tmp0.xxxx)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.xxxx)).y;
    reg_tmp5.x = (uniforms.f[5 + address_registers.x].wwww).x;
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_190_192();
    }
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_194_195();
    }
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_197_198();
    }
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_200_202();
    }
    reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    reg_tmp4.z = (uniforms.f[83].xxxx).z;
    reg_tmp4.w = (-uniforms.f[83].yyyy).w;
    reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[3 + address_registers.x].xyyy)).xy;
    reg_tmp4.z = (-uniforms.f[3 + address_registers.x].zzzz).z;
    reg_tmp4.w = (-uniforms.f[3 + address_registers.x].wwww).w;
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    reg_tmp11.xy = (reg_tmp5.xyyy).xy;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp0.yyyy, reg_tmp0.yyyy)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.yyyy)).y;
    reg_tmp5.x = (uniforms.f[6 + address_registers.x].wwww).x;
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_232_234();
    }
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_236_237();
    }
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_239_240();
    }
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_242_244();
    }
    reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    reg_tmp4.z = (uniforms.f[83].zzzz).z;
    reg_tmp4.w = (-uniforms.f[83].wwww).w;
    reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[4 + address_registers.x].xyyy)).xy;
    reg_tmp4.z = (-uniforms.f[4 + address_registers.x].zzzz).z;
    reg_tmp4.w = (-uniforms.f[4 + address_registers.x].wwww).w;
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    reg_tmp12.xy = (reg_tmp5.xyyy).xy;
    return false;
}
bool sub_190_192() {
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_194_195() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_197_198() {
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_200_202() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_232_234() {
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_236_237() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_239_240() {
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_242_244() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_260_4096() {
    {
        sub_0_8();
    }
    reg_tmp10.xy = (uniforms.f[84].xyyy + reg_tmp10.xyyy).xy;
    reg_tmp10.xy = (mul_s(uniforms.f[2 + address_registers.x].xyyy, reg_tmp10.xyyy)).xy;
    reg_tmp2.x = (uniforms.f[8 + address_registers.x].yyyy).x;
    reg_tmp2.y = (uniforms.f[9 + address_registers.x].yyyy).y;
    reg_tmp2.z = (uniforms.f[10 + address_registers.x].yyyy).z;
    reg_tmp3.xyz = (uniforms.f[6 + address_registers.x].xyzz).xyz;
    reg_tmp4.x = dot_3(reg_tmp3.xyz, reg_tmp3.xyz);
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
    if (conditional_code.x) {
        sub_270_271();
    } else {
        sub_271_272();
    }
    reg_tmp3.xyz = (mul_s(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
    reg_tmp4.xyz = (mul_s(reg_tmp2.yzxx, reg_tmp3.zxyy)).xyz;
    reg_tmp4.xyz = (fma_s(-reg_tmp3.yzxx, reg_tmp2.zxyy, reg_tmp4)).xyz;
    reg_tmp5.x = dot_3(reg_tmp4.xyz, reg_tmp4.xyz);
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp5.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp5.y;
    if (conditional_code.x) {
        sub_278_279();
    } else {
        sub_279_280();
    }
    reg_tmp4.xyz = (mul_s(reg_tmp4.xyzz, reg_tmp5.xxxx)).xyz;
    reg_tmp5.xyz = (mul_s(reg_tmp4.yzxx, reg_tmp3.zxyy)).xyz;
    reg_tmp5.xyz = (fma_s(-reg_tmp3.yzxx, reg_tmp4.zxyy, reg_tmp5)).xyz;
    reg_tmp6.x = (reg_tmp4.xxxx).x;
    reg_tmp6.y = (reg_tmp3.xxxx).y;
    reg_tmp6.z = (reg_tmp5.xxxx).z;
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    reg_tmp7.x = (reg_tmp4.yyyy).x;
    reg_tmp7.y = (reg_tmp3.yyyy).y;
    reg_tmp7.z = (reg_tmp5.yyyy).z;
    reg_tmp7.w = (uniforms.f[0].xxxx).w;
    reg_tmp8.x = (reg_tmp4.zzzz).x;
    reg_tmp8.y = (reg_tmp3.zzzz).y;
    reg_tmp8.z = (reg_tmp5.zzzz).z;
    reg_tmp8.w = (uniforms.f[0].xxxx).w;
    reg_tmp9 = uniforms.f[0].xxxz;
    reg_tmp2.x = dot_s(reg_tmp10, reg_tmp6);
    reg_tmp2.y = dot_s(reg_tmp10, reg_tmp7);
    reg_tmp2.z = dot_s(reg_tmp10, reg_tmp8);
    reg_tmp2.w = dot_s(reg_tmp10, reg_tmp9);
    reg_tmp3.xyz = (uniforms.f[5 + address_registers.x].xyzz).xyz;
    reg_tmp3.xyz = (uniforms.f[85].xyzz + -reg_tmp3.xyzz).xyz;
    reg_tmp4.x = dot_3(reg_tmp3.xyz, reg_tmp3.xyz);
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
    if (conditional_code.x) {
        sub_305_306();
    } else {
        sub_306_307();
    }
    reg_tmp3.xyz = (mul_s(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
    reg_tmp10.xyz = (uniforms.f[5 + address_registers.x].xyzz + reg_tmp2.xyzz).xyz;
    reg_tmp10.xyz = (fma_s(reg_tmp3.xyzz, uniforms.f[84].zzzz, reg_tmp10.xyzz)).xyz;
    {
        sub_146_166();
    }
    reg_tmp2 = reg_tmp10;
    reg_tmp10.x = dot_s(reg_tmp2, reg_tmp6);
    reg_tmp10.y = dot_s(reg_tmp2, reg_tmp7);
    reg_tmp10.z = dot_s(reg_tmp2, reg_tmp8);
    reg_tmp10.w = dot_s(reg_tmp2, reg_tmp9);
    reg_tmp2 = uniforms.f[1 + address_registers.x];
    reg_tmp3 = max(uniforms.f[0].xxxx, reg_tmp2);
    reg_tmp2 = min(uniforms.f[0].zzzz, reg_tmp3);
    reg_tmp13 = reg_tmp2;
    {
        sub_167_259();
    }
    {
        sub_9_32();
    }
    return true;
}
bool sub_270_271() {
    reg_tmp4.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_271_272() {
    reg_tmp4.x = rsq_s(reg_tmp4.x);
    return false;
}
bool sub_278_279() {
    reg_tmp5.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_279_280() {
    reg_tmp5.x = rsq_s(reg_tmp5.x);
    return false;
}
bool sub_305_306() {
    reg_tmp4.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_306_307() {
    reg_tmp4.x = rsq_s(reg_tmp4.x);
    return false;
}
// reference: 7C56A0C1AA25DFEE, D172C14891C0D4D7
// program: D172C14891C0D4D7, 082670B4222015B2, 558A6C807844C0F3
// reference: BD97A077A20D7EB1, 493A89E34FC6D4B5
// program: 493A89E34FC6D4B5, 082670B4222015B2, 0D19D21B46AD8D9B
// reference: 25602672ACAA5F57, 949D68475595512F
// reference: DB21EB70ADDCCB74, DDF9B003B681BCE8
// reference: 25602672FE2C69AF, 949D68475595512F
// reference: 3B5774B2535570FB, 46E991DEB658A5A9
// reference: 75038BF2D0A01689, 46E991DEB658A5A9
// reference: DFEDDD060621EB2E, 81B0676B862CF405
// reference: 91B9224685D48D5C, 81B0676B862CF405
// reference: FD9F4963145ED7A9, 2E530FFFDA886761
// reference: B3CBB62397ABB1DB, 2E530FFFDA886761
// reference: DEC3CC9984711F7D, 91D55C04BB07EE32
// reference: AAF5D98421F818C3, 493A89E34FC6D4B5
// reference: 6B34D9322F5F3925, 949D68475595512F
// reference: 6B34D9327DD90FDD, 949D68475595512F
// reference: E4A126C4A20D7EB1, 493A89E34FC6D4B5
// reference: 3B5774B201D34603, 46E991DEB658A5A9
// reference: 75038BF282262071, 46E991DEB658A5A9
// reference: DFEDDD0654A7DDD6, 81B0676B862CF405
// reference: 91B92246D752BBA4, 81B0676B862CF405
// reference: FD9F496346D8E151, 2E530FFFDA886761
// reference: B3CBB623C52D8723, 2E530FFFDA886761
// reference: DEC3CC99D6F72985, 91D55C04BB07EE32
// reference: 3B5774B20F7467E5, 46E991DEB658A5A9
// reference: 75038BF28C810197, 46E991DEB658A5A9
// reference: DFEDDD065A00FC30, 81B0676B862CF405
// reference: 91B92246D9F59A42, 81B0676B862CF405
// reference: FD9F4963A87985FE, 2E530FFFDA886761
// reference: B3CBB6232B8CE38C, 2E530FFFDA886761
// reference: DEC3CC9938564D2A, 91D55C04BB07EE32
// reference: 8B7DC4AFB95E0304, 46E991DEB658A5A9
// reference: C5293BEF3AAB6576, 46E991DEB658A5A9
// reference: DFEDDD067883374D, 81B0676B862CF405
// reference: 91B92246FB76513F, 81B0676B862CF405
// reference: B3CBB623816A1441, FD3DADE0E2BC47C9
// shader: 8B30, 47C275FDFA7C7BA4

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb) * (texcolor0.rgb) + (rounded_primary_color.rgb) * (vec3(1.0) - (texcolor0.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.r) + (texcolor1.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = (last_tex_env_out.rgb);
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) - (const_color[1].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: BDC03991ADBFECD6, 47C275FDFA7C7BA4
// program: FD3DADE0E2BC47C9, B80FA1B7F97410CD, 47C275FDFA7C7BA4
// shader: 8B30, 47C275FDB236B1F5

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb) * (texcolor0.rgb) + (rounded_primary_color.rgb) * (vec3(1.0) - (texcolor0.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.r) * (texcolor1.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = (last_tex_env_out.rgb);
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) - (const_color[1].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 2A2C6042ADBFECD6, 47C275FDB236B1F5
// program: FD3DADE0E2BC47C9, B80FA1B7F97410CD, 47C275FDB236B1F5
// reference: B3CBB6236FCB70EE, FD3DADE0E2BC47C9
// program: 493A89E34FC6D4B5, 082670B4222015B2, 558A6C807844C0F3
// reference: 8B7DC4AF57FF67AB, 46E991DEB658A5A9
// reference: C5293BEFD40A01D9, 46E991DEB658A5A9
// reference: DFEDDD06962253E2, 81B0676B862CF405
// reference: 91B9224615D73590, 81B0676B862CF405
// reference: FD9F4963EC3E169C, FD3DADE0E2BC47C9
// reference: DFEDDD06EF369804, 81B0676B862CF405
// reference: 91B922466CC3FE76, 81B0676B862CF405
// reference: 3DBABD5810532F05, FD3DADE0E2BC47C9
// reference: 1A92D04AE51CE074, 949D68475595512F
// reference: 4AF17DCACB909F52, 46E991DEB658A5A9
// reference: 04A5828A4865F920, 46E991DEB658A5A9
// reference: AF65C5E11CB4F0D4, 91D55C04BB07EE32
// reference: C26DBF5BA588A9BF, FD3DADE0E2BC47C9
// reference: DB53D0FC9466B309, 493A89E34FC6D4B5
// reference: 4AF17DCABAEACC2F, 46E991DEB658A5A9
// reference: 04A5828A391FAA5D, 46E991DEB658A5A9
// reference: AE4BD47EEF9E57FA, 81B0676B862CF405
// reference: E01F2B3E6C6B3188, 81B0676B862CF405
// reference: 8C39401B1DE72E34, 2E530FFFDA886761
// reference: C26DBF5B9E124846, 2E530FFFDA886761
// reference: AF65C5E18DC8E6E0, 91D55C04BB07EE32
// reference: C26DBF5B34F4BF8B, FD3DADE0E2BC47C9
// reference: 4AF17DCAB44DEDC9, 46E991DEB658A5A9
// reference: 04A5828A37B88BBB, 46E991DEB658A5A9
// reference: AE4BD47EE139761C, 81B0676B862CF405
// reference: E01F2B3E62CC106E, 81B0676B862CF405
// reference: 8C39401BF3464A9B, 2E530FFFDA886761
// reference: C26DBF5B70B32CE9, 2E530FFFDA886761
// reference: FADBCDD7E261CC61, 46E991DEB658A5A9
// reference: B48F32976194AA13, 46E991DEB658A5A9
// reference: AE4BD47E23BCF828, 81B0676B862CF405
// reference: E01F2B3EA0499E5A, 81B0676B862CF405
// reference: AF65C5E16369824F, 91D55C04BB07EE32
// reference: C26DBF5BDA55DB24, FD3DADE0E2BC47C9
// shader: 8B30, EFD413C8B4DB6124

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: BB75403C724884F8, EFD413C8B4DB6124
// program: 2E530FFFDA886761, B80FA1B7F97410CD, EFD413C8B4DB6124
// shader: 8B30, 13A8229A5C3731AF

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (texcolor2.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor2.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor2.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: E7C087E1C769AE32, 13A8229A5C3731AF
// program: 81B0676B862CF405, 42937135801BAA7E, 13A8229A5C3731AF
// shader: 8B30, 0CC791BC8EEF1EB3

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].aaa);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (texcolor2.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor2.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor2.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D77898AA827CAD9E, 0CC791BC8EEF1EB3
// program: 81B0676B862CF405, 42937135801BAA7E, 0CC791BC8EEF1EB3
// shader: 8B30, E2F2D85C0BDC5A88

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (texcolor2.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor2.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor2.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: E7C087E1DA31A00E, E2F2D85C0BDC5A88
// program: 81B0676B862CF405, 42937135801BAA7E, E2F2D85C0BDC5A88
// shader: 8B30, EDE16E89EA7F24D1

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (texcolor2.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor2.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor2.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: E7C087E121D1D1B7, EDE16E89EA7F24D1
// program: 81B0676B862CF405, 42937135801BAA7E, EDE16E89EA7F24D1
// shader: 8B30, C3AE9AE90938C480

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (texcolor2.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor2.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor2.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D6E937DB01F54017, C3AE9AE90938C480
// program: 81B0676B862CF405, 42937135801BAA7E, C3AE9AE90938C480
// shader: 8B30, 3830749B62D82C55

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (texcolor2.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor2.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor2.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D6E937DB0AC2BA03, 3830749B62D82C55
// program: 81B0676B862CF405, 42937135801BAA7E, 3830749B62D82C55
// shader: 8B30, 09E32F20E9B51EAB

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 1FAADF151342D67C, 09E32F20E9B51EAB
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 09E32F20E9B51EAB
// shader: 8B30, 9DC075E5CBADCA00

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (primary_fragment_color.rgb);
float alpha_output_0 = byteround(clamp((const_color[0].a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = (last_tex_env_out.rgb);
float alpha_output_1 = byteround(clamp((const_color[1].a) * (texcolor1.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((1.0 - combiner_buffer.a) * (last_tex_env_out.a) + (combiner_buffer.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 9F8336A162583A39, 9DC075E5CBADCA00
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 9DC075E5CBADCA00
// shader: 8B30, 663AF78598DBEB1B

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp(min((texcolor0.rgb) + (texcolor1.rgb), vec3(1.0)) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (const_color[2].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: EAB8C6DED05ADD6E, 663AF78598DBEB1B
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 663AF78598DBEB1B
// shader: 8B30, F111F0C390A4C280

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (texcolor1.r);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: B89EC499A8FF3B18, F111F0C390A4C280
// program: 2E530FFFDA886761, B80FA1B7F97410CD, F111F0C390A4C280
// shader: 8B30, 319CD4F046F7B169

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: DC1A4A0F4245A1AF, 319CD4F046F7B169
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 319CD4F046F7B169
// reference: 8C39401B59A0BD56, FD3DADE0E2BC47C9
// reference: AE4BD47E5AA833CE, 81B0676B862CF405
// reference: E01F2B3ED95D55BC, 81B0676B862CF405
// shader: 8B31, 17795221670D57B4

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;
out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define fma_s(x, y, z) (mix(x * y, vec4(0.0), isnan(x * y)) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_19();
bool sub_19_29();
bool sub_29_51();
bool sub_51_65();
bool sub_65_116();
bool sub_88_92();
bool sub_114_115();
bool sub_116_156();
bool sub_133_137();
bool sub_154_155();
bool sub_156_183();
bool sub_158_163();
bool sub_163_182();
bool sub_166_172();
bool sub_172_181();
bool sub_173_177();
bool sub_177_180();
bool sub_183_207();
bool sub_185_189();
bool sub_189_206();
bool sub_190_204();
bool sub_193_200();
bool sub_200_203();
bool sub_204_205();
bool sub_207_223();
bool sub_209_213();
bool sub_213_222();
bool sub_214_220();
bool sub_220_221();
bool sub_223_231();
bool sub_225_226();
bool sub_226_230();
bool sub_227_228();
bool sub_228_229();
bool sub_231_238();
bool sub_238_242();
bool sub_242_286();
bool sub_262_268();
bool sub_269_276();
bool sub_277_285();
bool sub_286_4096();
bool sub_287_289();
bool sub_289_291();
bool sub_292_294();
bool sub_294_296();

bool exec_shader() {
    sub_286_4096();
    return true;
}

bool sub_0_19() {
    uint jmp_to = 0u;
    while (true) {
        switch (jmp_to) {
        case 0u: {
            reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
            reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
            reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
            reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
            reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
            reg_tmp6.x = rsq_s(reg_tmp6.x);
            reg_tmp7.x = rsq_s(reg_tmp7.x);
            reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            reg_tmp0 = uniforms.f[93].yxxx;
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            reg_tmp4 = mul_s(uniforms.f[94].xxxx, reg_tmp4);
            conditional_code = greaterThanEqual(uniforms.f[93].xx, reg_tmp4.xx);
            reg_tmp4 = vec4(rsq_s(reg_tmp4.x));
            reg_tmp5 = mul_s(uniforms.f[94].xxxx, reg_tmp14);
            if (conditional_code.x) {
                { jmp_to = 18u; break; }
            }
            reg_tmp0.z = rcp_s(reg_tmp4.x);
            reg_tmp0.xy = (mul_s(reg_tmp5, reg_tmp4)).xy;
        }
        case 18u: {
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_19_29() {
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    reg_tmp4.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_29_51() {
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    reg_tmp3.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp3.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp3.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp12);
    reg_tmp3.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp13.xyz);
    reg_tmp3.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp13.xyz);
    reg_tmp3.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp13.xyz);
    reg_tmp11 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp11);
    reg_tmp3.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp5.xyz);
    reg_tmp3.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp5.xyz);
    reg_tmp3.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp5.xyz);
    reg_tmp9 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp9);
    reg_tmp3.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp6.xyz);
    reg_tmp3.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp6.xyz);
    reg_tmp3.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp6.xyz);
    reg_tmp8 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp8);
    return false;
}
bool sub_51_65() {
    reg_tmp0.xyz = (mul_s(reg_tmp9.yzxx, reg_tmp8.zxyy)).xyz;
    reg_tmp0.xyz = (fma_s(-reg_tmp8.yzxx, reg_tmp9.zxyy, reg_tmp0)).xyz;
    reg_tmp1 = uniforms.f[83];
    reg_tmp2.x = dot_s(reg_tmp1.xyzz, reg_tmp1.xyzz);
    reg_tmp2.x = rsq_s(reg_tmp2.x);
    reg_tmp2.xyz = (mul_s(reg_tmp1.xyzz, reg_tmp2.xxxx)).xyz;
    reg_tmp1.x = dot_3(reg_tmp2.xyz, reg_tmp8.xyz);
    reg_tmp1.y = dot_3(reg_tmp2.xyz, reg_tmp0.xyz);
    reg_tmp1.z = dot_3(reg_tmp2.xyz, reg_tmp9.xyz);
    reg_tmp2.x = dot_s(reg_tmp1.xyzz, reg_tmp1.xyzz);
    reg_tmp2.x = rsq_s(reg_tmp2.x);
    reg_tmp2.xyz = (mul_s(reg_tmp1.xyzz, reg_tmp2.xxxx)).xyz;
    reg_tmp2.w = (uniforms.f[93].yyyy).w;
    vs_out_attr2 = reg_tmp2;
    return false;
}
bool sub_65_116() {
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    reg_tmp13.xyz = (vs_in_reg2).xyz;
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    reg_tmp5 = uniforms.f[93].xxyy;
    reg_tmp6 = uniforms.f[93].yxxy;
    reg_tmp7 = uniforms.f[93].xxxx;
    reg_tmp12 = uniforms.f[93].xxxx;
    reg_tmp11 = uniforms.f[93].xxxx;
    reg_tmp9 = uniforms.f[93].xxxx;
    reg_tmp8 = uniforms.f[93].xxxx;
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    {
        sub_29_51();
    }
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    {
        sub_29_51();
    }
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    if (conditional_code.x) {
        sub_29_51();
    }
    if (uniforms.b[11]) {
        sub_88_92();
    }
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    reg_tmp10 = reg_tmp7;
    reg_tmp13.x = dot_3(uniforms.f[90].xyz, reg_tmp11.xyz);
    reg_tmp13.y = dot_3(uniforms.f[91].xyz, reg_tmp11.xyz);
    reg_tmp13.z = dot_3(uniforms.f[92].xyz, reg_tmp11.xyz);
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    {
        sub_51_65();
    }
    vs_out_attr1 = uniforms.f[93].xxxy;
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    if (all(conditional_code)) {
        sub_114_115();
    }
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_88_92() {
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    if (conditional_code.y) {
        sub_29_51();
    }
    return false;
}
bool sub_114_115() {
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_116_156() {
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    reg_tmp7 = uniforms.f[93].xxxx;
    reg_tmp12 = uniforms.f[93].xxxx;
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    {
        sub_19_29();
    }
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    {
        sub_19_29();
    }
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    if (conditional_code.x) {
        sub_19_29();
    }
    if (uniforms.b[11]) {
        sub_133_137();
    }
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    reg_tmp10 = reg_tmp7;
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    {
        sub_0_19();
    }
    vs_out_attr2 = reg_tmp15;
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    if (all(conditional_code)) {
        sub_154_155();
    }
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_133_137() {
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    if (conditional_code.y) {
        sub_19_29();
    }
    return false;
}
bool sub_154_155() {
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_156_183() {
    reg_tmp0.xy = (uniforms.f[0].xxxx).xy;
    if (uniforms.b[2]) {
        sub_158_163();
    } else {
        sub_163_182();
    }
    return false;
}
bool sub_158_163() {
    {
        sub_223_231();
    }
    reg_tmp3.x = dot_s(uniforms.f[1].xywz, reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2].xywz, reg_tmp6);
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_163_182() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_166_172();
    } else {
        sub_172_181();
    }
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_166_172() {
    reg_tmp6 = reg_tmp10;
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    reg_tmp3.z = dot_s(uniforms.f[3], reg_tmp6);
    reg_tmp0.xy = (mul_s(uniforms.f[9].xyyy, reg_tmp3.zzzz)).xy;
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_172_181() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_173_177();
    } else {
        sub_177_180();
    }
    return false;
}
bool sub_173_177() {
    {
        sub_231_238();
    }
    reg_tmp3.x = dot_3(uniforms.f[1].xyz, reg_tmp6.xyz);
    reg_tmp3.y = dot_3(uniforms.f[2].xyz, reg_tmp6.xyz);
    reg_tmp3.z = dot_3(uniforms.f[3].xyz, reg_tmp6.xyz);
    return false;
}
bool sub_177_180() {
    {
        sub_238_242();
    }
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    return false;
}
bool sub_183_207() {
    reg_tmp0.xy = (uniforms.f[0].yyyy).xy;
    if (uniforms.b[3]) {
        sub_185_189();
    } else {
        sub_189_206();
    }
    return false;
}
bool sub_185_189() {
    {
        sub_223_231();
    }
    reg_tmp4.x = dot_s(uniforms.f[4].xywz, reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5].xywz, reg_tmp6);
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_189_206() {
    if (uniforms.b[5]) {
        sub_190_204();
    } else {
        sub_204_205();
    }
    return false;
}
bool sub_190_204() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_193_200();
    } else {
        sub_200_203();
    }
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_193_200() {
    reg_tmp6 = reg_tmp10;
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    reg_tmp4.z = dot_s(uniforms.f[6], reg_tmp6);
    reg_tmp6.w = rcp_s(reg_tmp4.z);
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    reg_tmp4.xy = (uniforms.f[9].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_200_203() {
    {
        sub_238_242();
    }
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    return false;
}
bool sub_204_205() {
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_207_223() {
    reg_tmp0.xy = (uniforms.f[0].zzzz).xy;
    if (uniforms.b[4]) {
        sub_209_213();
    } else {
        sub_213_222();
    }
    return false;
}
bool sub_209_213() {
    {
        sub_223_231();
    }
    reg_tmp5.x = dot_s(uniforms.f[7].xywz, reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8].xywz, reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_213_222() {
    if (uniforms.b[6]) {
        sub_214_220();
    } else {
        sub_220_221();
    }
    return false;
}
bool sub_214_220() {
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    {
        sub_238_242();
    }
    reg_tmp5.x = dot_s(uniforms.f[7], reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8], reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_220_221() {
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
bool sub_223_231() {
    conditional_code = equal(uniforms.f[93].yz, reg_tmp0.xy);
    if (all(not(conditional_code))) {
        sub_225_226();
    } else {
        sub_226_230();
    }
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_225_226() {
    reg_tmp6.xy = (vs_in_reg4.xyyy).xy;
    return false;
}
bool sub_226_230() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_227_228();
    } else {
        sub_228_229();
    }
    return false;
}
bool sub_227_228() {
    reg_tmp6.xy = (vs_in_reg5.xyyy).xy;
    return false;
}
bool sub_228_229() {
    reg_tmp6.xy = (vs_in_reg6.xyyy).xy;
    return false;
}
bool sub_231_238() {
    reg_tmp2 = -reg_tmp15;
    reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
    reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_238_242() {
    reg_tmp1.xy = (uniforms.f[94].xxxx).xy;
    reg_tmp1.zw = (uniforms.f[93].xxxx).zw;
    reg_tmp6 = fma_s(reg_tmp14, reg_tmp1, reg_tmp1);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_242_286() {
    reg_tmp1.xyz = (uniforms.f[93].xxyx).xyz;
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    reg_tmp14.w = (uniforms.f[93].xxxx).w;
    reg_tmp8 = reg_tmp14;
    reg_tmp14.x = dot_s(reg_tmp8, reg_tmp8);
    reg_tmp14.x = rsq_s(reg_tmp14.x);
    reg_tmp14 = mul_s(reg_tmp8, reg_tmp14.xxxx);
    reg_tmp8 = uniforms.f[83];
    reg_tmp6.x = dot_3(uniforms.f[90].xyz, reg_tmp8.xyz);
    reg_tmp6.y = dot_3(uniforms.f[91].xyz, reg_tmp8.xyz);
    reg_tmp6.z = dot_3(uniforms.f[92].xyz, reg_tmp8.xyz);
    reg_tmp8.xyz = (reg_tmp6.xyzz + reg_tmp1.xyzz).xyz;
    reg_tmp8.w = (uniforms.f[93].xxxx).w;
    reg_tmp0.x = dot_s(reg_tmp8, reg_tmp8);
    reg_tmp0.x = rsq_s(reg_tmp0.x);
    reg_tmp0 = mul_s(reg_tmp8, reg_tmp0.xxxx);
    reg_tmp2 = uniforms.f[93].xxxx;
    if (uniforms.b[9]) {
        sub_262_268();
    }
    if (uniforms.b[7]) {
        sub_269_276();
    }
    if (uniforms.b[8]) {
        sub_277_285();
    }
    vs_out_attr3 = reg_tmp2;
    return false;
}
bool sub_262_268() {
    reg_tmp8.x = dot_3(reg_tmp14.xyz, -reg_tmp6.xyz);
    reg_tmp8.y = dot_3(reg_tmp1.xyz, -reg_tmp6.xyz);
    reg_tmp8 = max(uniforms.f[93].xxxx, reg_tmp8);
    reg_tmp8.y = (mul_s(uniforms.f[94].xxxx, reg_tmp8.yyyy)).y;
    reg_tmp8.y = (uniforms.f[94].xxxx + reg_tmp8.yyyy).y;
    reg_tmp2.y = (mul_s(reg_tmp8.xxxx, reg_tmp8.yyyy)).y;
    return false;
}
bool sub_269_276() {
    reg_tmp9.z = dot_3(reg_tmp14.xyz, reg_tmp0.xyz);
    reg_tmp9.z = (max(uniforms.f[93].xxxx, reg_tmp9.zzzz)).z;
    reg_tmp9.z = (min(uniforms.f[93].yyyy, reg_tmp9.zzzz)).z;
    reg_tmp9.z = log2(reg_tmp9.z);
    reg_tmp9.z = (mul_s(uniforms.f[82].zzzz, reg_tmp9.zzzz)).z;
    reg_tmp9.z = exp2(reg_tmp9.z);
    reg_tmp2.z = (mul_s(uniforms.f[82].wwww, reg_tmp9.zzzz)).z;
    return false;
}
bool sub_277_285() {
    reg_tmp9.x = dot_3(reg_tmp14.xyz, reg_tmp1.xyz);
    reg_tmp9.x = (max(uniforms.f[93].xxxx, reg_tmp9.xxxx)).x;
    reg_tmp9.x = (min(uniforms.f[93].yyyy, reg_tmp9.xxxx)).x;
    reg_tmp9.x = (uniforms.f[93].yyyy + -reg_tmp9.xxxx).x;
    reg_tmp9.x = log2(reg_tmp9.x);
    reg_tmp9.x = (mul_s(uniforms.f[82].xxxx, reg_tmp9.xxxx)).x;
    reg_tmp9.x = exp2(reg_tmp9.x);
    reg_tmp2.w = (mul_s(uniforms.f[82].yyyy, reg_tmp9.xxxx)).w;
    return false;
}
bool sub_286_4096() {
    if (uniforms.b[10]) {
        sub_287_289();
    } else {
        sub_289_291();
    }
    if (uniforms.b[1]) {
        sub_292_294();
    } else {
        sub_294_296();
    }
    {
        sub_156_183();
    }
    {
        sub_183_207();
    }
    {
        sub_207_223();
    }
    return true;
}
bool sub_287_289() {
    {
        sub_65_116();
    }
    return false;
}
bool sub_289_291() {
    {
        sub_116_156();
    }
    return false;
}
bool sub_292_294() {
    {
        sub_242_286();
    }
    return false;
}
bool sub_294_296() {
    vs_out_attr3 = uniforms.f[93].yyyy;
    return false;
}
// reference: 6E353BBA11E465F2, 17795221670D57B4
// shader: 8B30, 76A638004F01220B

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = 2.0 * (texcolor2).rgb - 1.0;
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(normal, normalize(view))));
refl_value.g = (lut_scale_rg * LookupLightingLUTSigned(5, dot(normal, normalize(view))));
refl_value.b = (lut_scale_rb * LookupLightingLUTSigned(4, dot(normal, normalize(view))));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor1.rgb) * (vec3(1.0) - const_color[0].aaa) + (const_color[0].rgb) * (vec3(1.0) - (vec3(1.0) - const_color[0].aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (texcolor1.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_1 = byteround(clamp((texcolor0.rgb) + (last_tex_env_out.rgb) - vec3(0.5), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (combiner_buffer.rgb) - vec3(0.5), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((secondary_fragment_color.r) * (1.0 - const_color[2].a) + (secondary_fragment_color.b) * (1.0 - (1.0 - const_color[2].a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_3 = (texcolor1.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((secondary_fragment_color.ggg) * (const_color[4].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 00F48736BAF0A252, 76A638004F01220B
// program: 17795221670D57B4, B80FA1B7F97410CD, 76A638004F01220B
// reference: 2061C4FA92110380, 17795221670D57B4
// program: 17795221670D57B4, B80FA1B7F97410CD, 1CBA1DD1EAE2F663
// reference: 58970D475F0C0D88, 46E991DEB658A5A9
// reference: 6AD02DBF1793D57B, 493A89E34FC6D4B5
// reference: 519CD67DEF9E57FA, 81B0676B862CF405
// reference: 1FC8293D6C6B3188, 81B0676B862CF405
// reference: 73EE42181DE72E34, 2E530FFFDA886761
// reference: 3DBABD589E124846, 2E530FFFDA886761
// reference: C6B373FE9119208A, B0CCAE4F9AB69CDA
// reference: 88E78CBE12EC46F8, B0CCAE4F9AB69CDA
// reference: 40A37A2A8DACC255, 45C9694A57480945
// reference: 6E353BBA9A780E6A, 17795221670D57B4
// reference: 2061C4FA198D6818, 17795221670D57B4
// reference: 945B0A3E1EAA02E0, 1B722ADD909A7B2D
// reference: DA0FF57E9D5F6492, 1B722ADD909A7B2D
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 7ED2F034E5EB4FC6
// program: E81D148B6EF003F8, B80FA1B7F97410CD, BC32652205728950
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 10AAC2A3349D1A7E
// program: D9C174A4A54356AC, 42937135801BAA7E, 52F5F74AF1B519B6
// program: D9C174A4A54356AC, 42937135801BAA7E, 98F0722A788E01FD
// program: D9C174A4A54356AC, 42937135801BAA7E, 6E5C02D38B9C02DF
// program: D9C174A4A54356AC, 42937135801BAA7E, A4E2954DD6C4FB71
// program: D0293423BD9EA1E7, B80FA1B7F97410CD, 19F7816C4117CF8E
// program: D9C174A4A54356AC, 42937135801BAA7E, 5FBCCF5F27F5A7C1
// program: D9C174A4A54356AC, 42937135801BAA7E, 63B6ADAD25C2A518
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 47E4BEE6B3304AF3
// program: E81D148B6EF003F8, B80FA1B7F97410CD, C580B429ECAF519A
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 4BA25B84A31C492A
// program: D9C174A4A54356AC, 42937135801BAA7E, 6B98A4CC666FCBCF
// program: D9C174A4A54356AC, 42937135801BAA7E, D1257B6267770D05
// program: D9C174A4A54356AC, 42937135801BAA7E, D134C63316570D84
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 40FC95A67F54598B
// program: E81D148B6EF003F8, B80FA1B7F97410CD, D69A3CB52F0E3495
// program: E81D148B6EF003F8, B80FA1B7F97410CD, B5CB613BFC4BC41C
// program: 502AB780D80D09C1, B80FA1B7F97410CD, 1B4DA8DA884D39A1
// program: E81D148B6EF003F8, B80FA1B7F97410CD, D2BD0C5FAA2AB273
// program: E81D148B6EF003F8, B80FA1B7F97410CD, F8FBCC791CAC22F2
// program: E81D148B6EF003F8, B80FA1B7F97410CD, FEE7FD4C7FD3D731
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 8633243B2123B710
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 39E142A8F1F39B96
// program: E81D148B6EF003F8, B80FA1B7F97410CD, FC9E10BE42F07103
// program: 1BDE5ABD20055F26, 082670B4222015B2, DBA0F8FE46AD8D9B
// program: D9C174A4A54356AC, 42937135801BAA7E, 47A8279A60685F27
// program: 5E28DB645EED49B7, B80FA1B7F97410CD, C2EEBEAE0D7F3560
// program: A40B5D829674D1F8, B80FA1B7F97410CD, 1CBA1DD1EAE2F663
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 6A08A79BE3FAC39D
// program: D0293423BD9EA1E7, B80FA1B7F97410CD, 10AAC2A3349D1A7E
// program: 49AB6B882020674A, 082670B4222015B2, 0D19D21B46AD8D9B
// program: D9C174A4A54356AC, 42937135801BAA7E, 29CD3EBE51FAA42A
// program: D9C174A4A54356AC, 42937135801BAA7E, B2E64CFB9744D892
// program: D9C174A4A54356AC, 42937135801BAA7E, 98647FD3CF93B689
// program: 49AB6B882020674A, 082670B4222015B2, DBA0F8FE46AD8D9B
// program: 70A370D21404144E, 082670B4222015B2, DBA0F8FE46AD8D9B
// program: 70A370D21404144E, 082670B4222015B2, F4A415D97E9B6ED6
// program: D9C174A4A54356AC, 42937135801BAA7E, AB0D786CFAD777F8
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 6A44D3E672630106
// program: 35CCCCDE75E2FF83, B80FA1B7F97410CD, 0AC00F84117E7EFC
// program: 4CDB2C6E0A14815D, B80FA1B7F97410CD, A36D1D6BA424DB28
// program: 4CDB2C6E0A14815D, B80FA1B7F97410CD, 641FDB3E9E36B758
// program: 49AB6B882020674A, 082670B4222015B2, 1430EF96EBF7840F
// program: 4028512EA840631E, B80FA1B7F97410CD, C2EEBEAE0D7F3560
// program: A40B5D829674D1F8, B80FA1B7F97410CD, 9D0535C6802495CB
// program: 49AB6B882020674A, 082670B4222015B2, 63A5270519B4AE20
// program: D9C174A4A54356AC, 42937135801BAA7E, 49F399BDFAD777F8
// program: D9C174A4A54356AC, 42937135801BAA7E, 00F9BB7ACF93B689
// program: 3526EFD6EA584B4A, B80FA1B7F97410CD, B766CBB102E471E4
// program: 70A370D21404144E, 082670B4222015B2, B51C0DE019B4AE20
// program: 1BDE5ABD20055F26, 082670B4222015B2, 1EF23692707A019C
// program: 1BDE5ABD20055F26, 082670B4222015B2, 0D8F34E8707A019C
// program: 70A370D21404144E, 082670B4222015B2, 63A5270519B4AE20
// program: A40B5D829674D1F8, B80FA1B7F97410CD, 429F87F8D3AE0B36
// program: A40B5D829674D1F8, B80FA1B7F97410CD, 40BF4FB85B0B5330
// program: A40B5D829674D1F8, B80FA1B7F97410CD, EE82356499D9033F
// program: A40B5D829674D1F8, B80FA1B7F97410CD, 5F16273C5032C0B2
// program: A40B5D829674D1F8, B80FA1B7F97410CD, BC8FFFD904DA352D
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 7ED2F034E5EB4FC6
// program: E81D148B6EF003F8, B80FA1B7F97410CD, BC32652205728950
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 10AAC2A3349D1A7E
// program: D9C174A4A54356AC, 42937135801BAA7E, 52F5F74AF1B519B6
// program: D9C174A4A54356AC, 42937135801BAA7E, 98F0722A788E01FD
// program: D9C174A4A54356AC, 42937135801BAA7E, 6E5C02D38B9C02DF
// program: D9C174A4A54356AC, 42937135801BAA7E, A4E2954DD6C4FB71
// program: D0293423BD9EA1E7, B80FA1B7F97410CD, 19F7816C4117CF8E
// program: D9C174A4A54356AC, 42937135801BAA7E, 5FBCCF5F27F5A7C1
// program: D9C174A4A54356AC, 42937135801BAA7E, 63B6ADAD25C2A518
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 47E4BEE6B3304AF3
// program: E81D148B6EF003F8, B80FA1B7F97410CD, C580B429ECAF519A
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 4BA25B84A31C492A
// program: D9C174A4A54356AC, 42937135801BAA7E, 6B98A4CC666FCBCF
// program: D9C174A4A54356AC, 42937135801BAA7E, D1257B6267770D05
// program: D9C174A4A54356AC, 42937135801BAA7E, D134C63316570D84
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 40FC95A67F54598B
// program: E81D148B6EF003F8, B80FA1B7F97410CD, D69A3CB52F0E3495
// program: E81D148B6EF003F8, B80FA1B7F97410CD, B5CB613BFC4BC41C
// program: 502AB780D80D09C1, B80FA1B7F97410CD, 1B4DA8DA884D39A1
// program: E81D148B6EF003F8, B80FA1B7F97410CD, D2BD0C5FAA2AB273
// program: E81D148B6EF003F8, B80FA1B7F97410CD, F8FBCC791CAC22F2
// program: E81D148B6EF003F8, B80FA1B7F97410CD, FEE7FD4C7FD3D731
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 8633243B2123B710
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 39E142A8F1F39B96
// program: E81D148B6EF003F8, B80FA1B7F97410CD, FC9E10BE42F07103
// program: 1BDE5ABD20055F26, 082670B4222015B2, DBA0F8FE46AD8D9B
// program: D9C174A4A54356AC, 42937135801BAA7E, 47A8279A60685F27
// program: 5E28DB645EED49B7, B80FA1B7F97410CD, C2EEBEAE0D7F3560
// program: A40B5D829674D1F8, B80FA1B7F97410CD, 1CBA1DD1EAE2F663
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 6A08A79BE3FAC39D
// program: D0293423BD9EA1E7, B80FA1B7F97410CD, 10AAC2A3349D1A7E
// program: 49AB6B882020674A, 082670B4222015B2, 0D19D21B46AD8D9B
// program: D9C174A4A54356AC, 42937135801BAA7E, 29CD3EBE51FAA42A
// program: D9C174A4A54356AC, 42937135801BAA7E, B2E64CFB9744D892
// program: D9C174A4A54356AC, 42937135801BAA7E, 98647FD3CF93B689
// program: 49AB6B882020674A, 082670B4222015B2, DBA0F8FE46AD8D9B
// program: 70A370D21404144E, 082670B4222015B2, DBA0F8FE46AD8D9B
// program: 70A370D21404144E, 082670B4222015B2, F4A415D97E9B6ED6
// program: D9C174A4A54356AC, 42937135801BAA7E, AB0D786CFAD777F8
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 6A44D3E672630106
// program: 35CCCCDE75E2FF83, B80FA1B7F97410CD, 0AC00F84117E7EFC
// program: 4CDB2C6E0A14815D, B80FA1B7F97410CD, A36D1D6BA424DB28
// program: 4CDB2C6E0A14815D, B80FA1B7F97410CD, 641FDB3E9E36B758
// program: 49AB6B882020674A, 082670B4222015B2, 1430EF96EBF7840F
// program: 4028512EA840631E, B80FA1B7F97410CD, C2EEBEAE0D7F3560
// program: A40B5D829674D1F8, B80FA1B7F97410CD, 9D0535C6802495CB
// program: 49AB6B882020674A, 082670B4222015B2, 63A5270519B4AE20
// program: D9C174A4A54356AC, 42937135801BAA7E, 49F399BDFAD777F8
// program: D9C174A4A54356AC, 42937135801BAA7E, 00F9BB7ACF93B689
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 7ED2F034E5EB4FC6
// program: E81D148B6EF003F8, B80FA1B7F97410CD, BC32652205728950
// program: D9C174A4A54356AC, 42937135801BAA7E, 3018EA11DFB984D3
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 10AAC2A3349D1A7E
// program: D9C174A4A54356AC, 42937135801BAA7E, 52F5F74AF1B519B6
// program: D9C174A4A54356AC, 42937135801BAA7E, 98F0722A788E01FD
// program: D9C174A4A54356AC, 42937135801BAA7E, 6E5C02D38B9C02DF
// program: D9C174A4A54356AC, 42937135801BAA7E, A4E2954DD6C4FB71
// program: D9C174A4A54356AC, 42937135801BAA7E, 5F0787304B8A0BD1
// program: D0293423BD9EA1E7, B80FA1B7F97410CD, 19F7816C4117CF8E
// program: D9C174A4A54356AC, 42937135801BAA7E, 5FBCCF5F27F5A7C1
// program: D9C174A4A54356AC, 42937135801BAA7E, 63B6ADAD25C2A518
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 47E4BEE6B3304AF3
// program: E81D148B6EF003F8, B80FA1B7F97410CD, C580B429ECAF519A
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 4BA25B84A31C492A
// program: D9C174A4A54356AC, 42937135801BAA7E, 6B98A4CC666FCBCF
// program: D9C174A4A54356AC, 42937135801BAA7E, D1257B6267770D05
// program: D9C174A4A54356AC, 42937135801BAA7E, D134C63316570D84
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 40FC95A67F54598B
// program: E81D148B6EF003F8, B80FA1B7F97410CD, D69A3CB52F0E3495
// program: E81D148B6EF003F8, B80FA1B7F97410CD, B5CB613BFC4BC41C
// program: 502AB780D80D09C1, B80FA1B7F97410CD, 1B4DA8DA884D39A1
// program: E81D148B6EF003F8, B80FA1B7F97410CD, D2BD0C5FAA2AB273
// program: E81D148B6EF003F8, B80FA1B7F97410CD, F8FBCC791CAC22F2
// program: E81D148B6EF003F8, B80FA1B7F97410CD, FEE7FD4C7FD3D731
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 8633243B2123B710
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 39E142A8F1F39B96
// program: E81D148B6EF003F8, B80FA1B7F97410CD, FC9E10BE42F07103
// program: 1BDE5ABD20055F26, 082670B4222015B2, DBA0F8FE46AD8D9B
// program: D9C174A4A54356AC, 42937135801BAA7E, 47A8279A60685F27
// program: 4028512EA840631E, B80FA1B7F97410CD, C2EEBEAE0D7F3560
// program: 35CCCCDE75E2FF83, B80FA1B7F97410CD, 0AC00F84117E7EFC
// program: A40B5D829674D1F8, B80FA1B7F97410CD, 9D0535C6802495CB
// program: A40B5D829674D1F8, B80FA1B7F97410CD, 429F87F8D3AE0B36
// program: A40B5D829674D1F8, B80FA1B7F97410CD, 40BF4FB85B0B5330
// program: A40B5D829674D1F8, B80FA1B7F97410CD, EE82356499D9033F
// program: A40B5D829674D1F8, B80FA1B7F97410CD, 5F16273C5032C0B2
// program: A40B5D829674D1F8, B80FA1B7F97410CD, BC8FFFD904DA352D
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 6A08A79BE3FAC39D
// program: D0293423BD9EA1E7, B80FA1B7F97410CD, 10AAC2A3349D1A7E
// program: 49AB6B882020674A, 082670B4222015B2, 0D19D21B46AD8D9B
// program: D9C174A4A54356AC, 42937135801BAA7E, 29CD3EBE51FAA42A
// program: D9C174A4A54356AC, 42937135801BAA7E, B2E64CFB9744D892
// program: D9C174A4A54356AC, 42937135801BAA7E, 98647FD3CF93B689
// program: 49AB6B882020674A, 082670B4222015B2, DBA0F8FE46AD8D9B
// program: 70A370D21404144E, 082670B4222015B2, DBA0F8FE46AD8D9B
// program: 70A370D21404144E, 082670B4222015B2, F4A415D97E9B6ED6
// program: D9C174A4A54356AC, 42937135801BAA7E, AB0D786CFAD777F8
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 6A44D3E672630106
// program: 4CDB2C6E0A14815D, B80FA1B7F97410CD, A36D1D6BA424DB28
// program: 4CDB2C6E0A14815D, B80FA1B7F97410CD, 641FDB3E9E36B758
// program: 49AB6B882020674A, 082670B4222015B2, 1430EF96EBF7840F
// program: 49AB6B882020674A, 082670B4222015B2, 63A5270519B4AE20
// program: D9C174A4A54356AC, 42937135801BAA7E, 49F399BDFAD777F8
// program: D9C174A4A54356AC, 42937135801BAA7E, 00F9BB7ACF93B689
// program: 3526EFD6EA584B4A, B80FA1B7F97410CD, B766CBB102E471E4
// program: 8AA3B6DF4767940E, 082670B4222015B2, DBA0F8FE46AD8D9B
// program: 8AA3B6DF4767940E, 082670B4222015B2, 558A6C807844C0F3
// program: D0293423BD9EA1E7, B80FA1B7F97410CD, 5741FC947D667CFB
// program: D0293423BD9EA1E7, B80FA1B7F97410CD, 5FF3DF19FAD860D6
// program: 8AA3B6DF4767940E, 082670B4222015B2, 1430EF96707A019C
// program: 70A370D21404144E, 082670B4222015B2, 63A5270519B4AE20
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 7337CC71AC06DD60
// program: E81D148B6EF003F8, B80FA1B7F97410CD, CF7B55EB749B1745
// program: E81D148B6EF003F8, B80FA1B7F97410CD, F2989B699B9A67E9
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 64E77DF66C1C7766
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 3D2F05F592BCAC45
// program: D9C174A4A54356AC, 42937135801BAA7E, DBAEBC3C69195AAA
// program: D9C174A4A54356AC, 42937135801BAA7E, 62CB16D7F16FAC9B
// program: D9C174A4A54356AC, 42937135801BAA7E, 31DB35D8B8E9549F
// program: D9C174A4A54356AC, 42937135801BAA7E, EB5CA625F01267FB
// program: D9C174A4A54356AC, 42937135801BAA7E, F2C7CEFD4FAFF562
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 72AEE74A87B55733
// program: D9C174A4A54356AC, 42937135801BAA7E, EF6E6A305FC7B5A1
// program: D9C174A4A54356AC, 42937135801BAA7E, ADBF67247E14A994
// program: D9C174A4A54356AC, 42937135801BAA7E, C6BAD9CE0AEB9402
// program: D9C174A4A54356AC, 42937135801BAA7E, 0C044E501EE62795
// program: D9C174A4A54356AC, 42937135801BAA7E, 244B48F0C67C62A2
// program: 5E28DB645EED49B7, B80FA1B7F97410CD, C2EEBEAE0D7F3560
// program: A40B5D829674D1F8, B80FA1B7F97410CD, 1CBA1DD1EAE2F663
// program: 70A370D21404144E, 082670B4222015B2, B51C0DE019B4AE20
// program: 1BDE5ABD20055F26, 082670B4222015B2, 1EF23692707A019C
// program: 1BDE5ABD20055F26, 082670B4222015B2, 0D8F34E8707A019C
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 7ED2F034E5EB4FC6
// program: E81D148B6EF003F8, B80FA1B7F97410CD, BC32652205728950
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 10AAC2A3349D1A7E
// program: D9C174A4A54356AC, 42937135801BAA7E, 52F5F74AF1B519B6
// program: D9C174A4A54356AC, 42937135801BAA7E, 98F0722A788E01FD
// program: D9C174A4A54356AC, 42937135801BAA7E, 6E5C02D38B9C02DF
// program: D9C174A4A54356AC, 42937135801BAA7E, A4E2954DD6C4FB71
// program: D0293423BD9EA1E7, B80FA1B7F97410CD, 19F7816C4117CF8E
// program: D9C174A4A54356AC, 42937135801BAA7E, 5FBCCF5F27F5A7C1
// program: D9C174A4A54356AC, 42937135801BAA7E, 63B6ADAD25C2A518
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 47E4BEE6B3304AF3
// program: E81D148B6EF003F8, B80FA1B7F97410CD, C580B429ECAF519A
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 4BA25B84A31C492A
// program: D9C174A4A54356AC, 42937135801BAA7E, 6B98A4CC666FCBCF
// program: D9C174A4A54356AC, 42937135801BAA7E, D1257B6267770D05
// program: D9C174A4A54356AC, 42937135801BAA7E, D134C63316570D84
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 40FC95A67F54598B
// program: E81D148B6EF003F8, B80FA1B7F97410CD, D69A3CB52F0E3495
// program: E81D148B6EF003F8, B80FA1B7F97410CD, B5CB613BFC4BC41C
// program: 502AB780D80D09C1, B80FA1B7F97410CD, 1B4DA8DA884D39A1
// program: E81D148B6EF003F8, B80FA1B7F97410CD, D2BD0C5FAA2AB273
// program: E81D148B6EF003F8, B80FA1B7F97410CD, F8FBCC791CAC22F2
// program: E81D148B6EF003F8, B80FA1B7F97410CD, FEE7FD4C7FD3D731
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 8633243B2123B710
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 39E142A8F1F39B96
// program: E81D148B6EF003F8, B80FA1B7F97410CD, FC9E10BE42F07103
// reference: 7138BB02E435FD1B, 5E28DB645EED49B7
// program: 5E28DB645EED49B7, B80FA1B7F97410CD, C2EEBEAE0D7F3560
// reference: AE4999D90C8FC6FF, 35CCCCDE75E2FF83
// reference: 2DED4C7F53F1DFBA, A40B5D829674D1F8
// program: A40B5D829674D1F8, B80FA1B7F97410CD, 1CBA1DD1EAE2F663
// reference: 63B9B33FD004B9C8, A40B5D829674D1F8
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 6A08A79BE3FAC39D
// program: D0293423BD9EA1E7, B80FA1B7F97410CD, 10AAC2A3349D1A7E
// program: 49AB6B882020674A, 082670B4222015B2, 0D19D21B46AD8D9B
// reference: AE4BD47E377D8F29, D9C174A4A54356AC
// program: D9C174A4A54356AC, 42937135801BAA7E, 47A8279A60685F27
// reference: E01F2B3EB488E95B, D9C174A4A54356AC
// reference: 8C39401B2502B3AE, E81D148B6EF003F8
// reference: C26DBF5BA6F7D5DC, E81D148B6EF003F8
// reference: 8C39401B8FE44463, D0293423BD9EA1E7
// reference: AE4BD47E8CECCAFB, D9C174A4A54356AC
// reference: E01F2B3E0F19AC89, D9C174A4A54356AC
// reference: A7400F443A5ACB7A, 502AB780D80D09C1
// reference: 60055AF25DF3642B, 5E28DB645EED49B7
// reference: BF747829B5495FCF, 35CCCCDE75E2FF83
// reference: 8E5EF57053F1DFBA, A40B5D829674D1F8
// reference: C00A0A30D004B9C8, A40B5D829674D1F8
// reference: AE4BD47EF5F8011D, D9C174A4A54356AC
// reference: E01F2B3E760D676F, D9C174A4A54356AC
// reference: A7400F44434E009C, 502AB780D80D09C1
// program: D9C174A4A54356AC, 42937135801BAA7E, 29CD3EBE51FAA42A
// program: D9C174A4A54356AC, 42937135801BAA7E, B2E64CFB9744D892
// program: D9C174A4A54356AC, 42937135801BAA7E, 98647FD3CF93B689
// reference: A7400F4481CB8EA8, 502AB780D80D09C1
// program: 49AB6B882020674A, 082670B4222015B2, DBA0F8FE46AD8D9B
// program: 70A370D21404144E, 082670B4222015B2, DBA0F8FE46AD8D9B
// program: 70A370D21404144E, 082670B4222015B2, F4A415D97E9B6ED6
// reference: 1F78A6073E9D2CC2, 21786A34D707A069
// shader: 8B30, BB6BC4A53EB19D9F

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].aaa);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 2FC0B94CC57D5D7B, BB6BC4A53EB19D9F
// program: D9C174A4A54356AC, 42937135801BAA7E, BB6BC4A53EB19D9F
// reference: B67DEEB4FA8899AC, 502AB780D80D09C1
// shader: 8B30, 2627D2B8F88F7670

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].aaa);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp(vec3(dot((texcolor0.rgb) - vec3(0.5), (texcolor2.rgb) - vec3(0.5)) * 4.0), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp(min((texcolor1.a) + (1.0 - texcolor0.a), 1.0) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (combiner_buffer.rgb) + (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp(min((texcolor0.a) + (1.0 - texcolor2.a), 1.0) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 1E2118466828FC03, 2627D2B8F88F7670
// program: D9C174A4A54356AC, 42937135801BAA7E, 2627D2B8F88F7670
// shader: 8B30, D4B9928BAAFC3CA8

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (combiner_buffer.rgb) + (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp(min((texcolor0.a) + (1.0 - texcolor2.a), 1.0) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 354429B869AD0AF0, D4B9928BAAFC3CA8
// program: D9C174A4A54356AC, 42937135801BAA7E, D4B9928BAAFC3CA8
// shader: 8B30, 78BB7F60DBBDB3F4

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (combiner_buffer.rgb) + (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp(min((texcolor0.a) + (1.0 - texcolor2.a), 1.0) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 354429B8997A815D, 78BB7F60DBBDB3F4
// program: D9C174A4A54356AC, 42937135801BAA7E, 78BB7F60DBBDB3F4
// shader: 8B30, 8B5FABB7E824CB5C

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].aaa);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (combiner_buffer.rgb) + (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp(min((texcolor0.a) + (1.0 - texcolor2.a), 1.0) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 05FC36F33AD7FD74, 8B5FABB7E824CB5C
// program: D9C174A4A54356AC, 42937135801BAA7E, 8B5FABB7E824CB5C
// reference: B67DEEB45C11177E, 502AB780D80D09C1
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 6A44D3E672630106
// program: 35CCCCDE75E2FF83, B80FA1B7F97410CD, 0AC00F84117E7EFC
// reference: D822EEA1C2A3C650, 4CDB2C6E0A14815D
// reference: 967611E14156A022, 4CDB2C6E0A14815D
// reference: CBF401A3CD2EFBBF, 4CDB2C6E0A14815D
// program: 4CDB2C6E0A14815D, B80FA1B7F97410CD, A36D1D6BA424DB28
// reference: 85A0FEE34EDB9DCD, 4CDB2C6E0A14815D
// program: 4CDB2C6E0A14815D, B80FA1B7F97410CD, 641FDB3E9E36B758
// program: 49AB6B882020674A, 082670B4222015B2, 1430EF96EBF7840F
// program: D9C174A4A54356AC, 42937135801BAA7E, AB0D786CFAD777F8
// reference: C91F0F517B655F60, 4CDB2C6E0A14815D
// reference: 874BF011F8903912, 4CDB2C6E0A14815D
// reference: 77308EBD2A09DB62, 4028512EA840631E
// program: 4028512EA840631E, B80FA1B7F97410CD, C2EEBEAE0D7F3560
// program: A40B5D829674D1F8, B80FA1B7F97410CD, 9D0535C6802495CB
// program: 49AB6B882020674A, 082670B4222015B2, 63A5270519B4AE20
// shader: 8B30, EE647EB091A30762

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((vec3(1.0) - combiner_buffer.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 5F0AA39F0B52A89A, EE647EB091A30762
// program: D9C174A4A54356AC, 42937135801BAA7E, EE647EB091A30762
// reference: 5F0AA39F531FA50A, EE647EB091A30762
// shader: 8B30, B9FEFD2332073A0F

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_2 = byteround(clamp((vec3(1.0) - combiner_buffer.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: E7C524FDACBC3252, B9FEFD2332073A0F
// program: D9C174A4A54356AC, 42937135801BAA7E, B9FEFD2332073A0F
// shader: 8B30, AEA290122A6555AF

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((vec3(1.0) - combiner_buffer.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: E7C524FD5C6BB9FF, AEA290122A6555AF
// program: D9C174A4A54356AC, 42937135801BAA7E, AEA290122A6555AF
// shader: 8B30, D083889144943A04

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].aaa);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((vec3(1.0) - combiner_buffer.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D77D3BB6FFC6C5D6, D083889144943A04
// program: D9C174A4A54356AC, 42937135801BAA7E, D083889144943A04
// reference: 60A3346938A8DB03, D9C174A4A54356AC
// reference: 2EF7CB29BB5DBD71, D9C174A4A54356AC
// reference: 42D1A00C9CC42A9E, E81D148B6EF003F8
// reference: 0C855F4C1F314CEC, E81D148B6EF003F8
// reference: AEEDBAE5E435FD1B, 5E28DB645EED49B7
// reference: B9D86EAA93CF4252, 4028512EA840631E
// reference: 719C983E0C8FC6FF, 35CCCCDE75E2FF83
// reference: 40B6156753F1DFBA, A40B5D829674D1F8
// reference: 0EE2EA27D004B9C8, A40B5D829674D1F8
// reference: 660D6F4D93CF4252, 4028512EA840631E
// reference: 3F6C444267C09B69, 5E28DB645EED49B7
// shader: 8B30, 2BBB7C866D178F67

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (combiner_buffer.rgb) + (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp(min((texcolor0.a) + (1.0 - texcolor2.a), 1.0) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 354429B8629AF0E4, 2BBB7C866D178F67
// program: D9C174A4A54356AC, 42937135801BAA7E, 2BBB7C866D178F67
// reference: 70B8C8C4462C4E73, 3526EFD6EA584B4A
// program: 3526EFD6EA584B4A, B80FA1B7F97410CD, B766CBB102E471E4
// reference: CB634E630663D179, 5E28DB645EED49B7
// reference: DC569A2C71996E30, 4028512EA840631E
// program: 70A370D21404144E, 082670B4222015B2, B51C0DE019B4AE20
// program: 1BDE5ABD20055F26, 082670B4222015B2, 1EF23692707A019C
// program: 1BDE5ABD20055F26, 082670B4222015B2, 0D8F34E8707A019C
// program: 70A370D21404144E, 082670B4222015B2, 63A5270519B4AE20
// program: D9C174A4A54356AC, 42937135801BAA7E, 49F399BDFAD777F8
// program: 1BDE5ABD20055F26, 082670B4222015B2, DBA0F8FE46AD8D9B
// shader: 8B30, 1C8824D71CA6B238

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((vec3(1.0) - combiner_buffer.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 5F0AA39FF0B2D923, 1C8824D71CA6B238
// program: D9C174A4A54356AC, 42937135801BAA7E, 1C8824D71CA6B238
// reference: AF6DC923462C4E73, 3526EFD6EA584B4A
// reference: 14B64F840663D179, 5E28DB645EED49B7
// reference: 03839BCB71996E30, 4028512EA840631E
// reference: 2859900D103A2420, 4028512EA840631E
// program: D9C174A4A54356AC, 42937135801BAA7E, 3018EA11DFB984D3
// program: D9C174A4A54356AC, 42937135801BAA7E, 5F0787304B8A0BD1
// program: A40B5D829674D1F8, B80FA1B7F97410CD, 429F87F8D3AE0B36
// program: A40B5D829674D1F8, B80FA1B7F97410CD, 40BF4FB85B0B5330
// program: A40B5D829674D1F8, B80FA1B7F97410CD, EE82356499D9033F
// program: A40B5D829674D1F8, B80FA1B7F97410CD, 5F16273C5032C0B2
// program: A40B5D829674D1F8, B80FA1B7F97410CD, BC8FFFD904DA352D
// reference: 396471FDA9FCBD10, 4028512EA840631E
// reference: F78C91EA103A2420, 4028512EA840631E
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 7ED2F034E5EB4FC6
// program: E81D148B6EF003F8, B80FA1B7F97410CD, BC32652205728950
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 10AAC2A3349D1A7E
// program: D9C174A4A54356AC, 42937135801BAA7E, 52F5F74AF1B519B6
// program: D9C174A4A54356AC, 42937135801BAA7E, 98F0722A788E01FD
// program: D9C174A4A54356AC, 42937135801BAA7E, 6E5C02D38B9C02DF
// program: D9C174A4A54356AC, 42937135801BAA7E, A4E2954DD6C4FB71
// program: D0293423BD9EA1E7, B80FA1B7F97410CD, 19F7816C4117CF8E
// program: D9C174A4A54356AC, 42937135801BAA7E, 5FBCCF5F27F5A7C1
// program: D9C174A4A54356AC, 42937135801BAA7E, 63B6ADAD25C2A518
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 47E4BEE6B3304AF3
// program: E81D148B6EF003F8, B80FA1B7F97410CD, C580B429ECAF519A
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 4BA25B84A31C492A
// program: D9C174A4A54356AC, 42937135801BAA7E, 6B98A4CC666FCBCF
// program: D9C174A4A54356AC, 42937135801BAA7E, D1257B6267770D05
// program: D9C174A4A54356AC, 42937135801BAA7E, D134C63316570D84
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 40FC95A67F54598B
// program: E81D148B6EF003F8, B80FA1B7F97410CD, D69A3CB52F0E3495
// program: E81D148B6EF003F8, B80FA1B7F97410CD, B5CB613BFC4BC41C
// program: 502AB780D80D09C1, B80FA1B7F97410CD, 1B4DA8DA884D39A1
// program: E81D148B6EF003F8, B80FA1B7F97410CD, D2BD0C5FAA2AB273
// program: E81D148B6EF003F8, B80FA1B7F97410CD, F8FBCC791CAC22F2
// program: E81D148B6EF003F8, B80FA1B7F97410CD, FEE7FD4C7FD3D731
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 8633243B2123B710
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 39E142A8F1F39B96
// program: E81D148B6EF003F8, B80FA1B7F97410CD, FC9E10BE42F07103
// program: 5E28DB645EED49B7, B80FA1B7F97410CD, C2EEBEAE0D7F3560
// program: A40B5D829674D1F8, B80FA1B7F97410CD, 1CBA1DD1EAE2F663
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 6A08A79BE3FAC39D
// program: D0293423BD9EA1E7, B80FA1B7F97410CD, 10AAC2A3349D1A7E
// program: 49AB6B882020674A, 082670B4222015B2, 0D19D21B46AD8D9B
// program: D9C174A4A54356AC, 42937135801BAA7E, 47A8279A60685F27
// program: D9C174A4A54356AC, 42937135801BAA7E, 29CD3EBE51FAA42A
// program: D9C174A4A54356AC, 42937135801BAA7E, B2E64CFB9744D892
// program: D9C174A4A54356AC, 42937135801BAA7E, 98647FD3CF93B689
// program: 49AB6B882020674A, 082670B4222015B2, DBA0F8FE46AD8D9B
// program: 70A370D21404144E, 082670B4222015B2, DBA0F8FE46AD8D9B
// program: 70A370D21404144E, 082670B4222015B2, F4A415D97E9B6ED6
// program: D9C174A4A54356AC, 42937135801BAA7E, BB6BC4A53EB19D9F
// program: D9C174A4A54356AC, 42937135801BAA7E, 2627D2B8F88F7670
// program: D9C174A4A54356AC, 42937135801BAA7E, D4B9928BAAFC3CA8
// program: D9C174A4A54356AC, 42937135801BAA7E, 78BB7F60DBBDB3F4
// program: D9C174A4A54356AC, 42937135801BAA7E, 8B5FABB7E824CB5C
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 6A44D3E672630106
// program: 35CCCCDE75E2FF83, B80FA1B7F97410CD, 0AC00F84117E7EFC
// program: 4CDB2C6E0A14815D, B80FA1B7F97410CD, A36D1D6BA424DB28
// program: 4CDB2C6E0A14815D, B80FA1B7F97410CD, 641FDB3E9E36B758
// program: 49AB6B882020674A, 082670B4222015B2, 1430EF96EBF7840F
// program: D9C174A4A54356AC, 42937135801BAA7E, AB0D786CFAD777F8
// program: 4028512EA840631E, B80FA1B7F97410CD, C2EEBEAE0D7F3560
// program: A40B5D829674D1F8, B80FA1B7F97410CD, 9D0535C6802495CB
// program: 49AB6B882020674A, 082670B4222015B2, 63A5270519B4AE20
// program: D9C174A4A54356AC, 42937135801BAA7E, EE647EB091A30762
// program: D9C174A4A54356AC, 42937135801BAA7E, B9FEFD2332073A0F
// program: D9C174A4A54356AC, 42937135801BAA7E, AEA290122A6555AF
// program: D9C174A4A54356AC, 42937135801BAA7E, D083889144943A04
// program: D9C174A4A54356AC, 42937135801BAA7E, 2BBB7C866D178F67
// program: 3526EFD6EA584B4A, B80FA1B7F97410CD, B766CBB102E471E4
// program: 70A370D21404144E, 082670B4222015B2, B51C0DE019B4AE20
// program: 1BDE5ABD20055F26, 082670B4222015B2, 1EF23692707A019C
// program: 1BDE5ABD20055F26, 082670B4222015B2, 0D8F34E8707A019C
// program: 70A370D21404144E, 082670B4222015B2, 63A5270519B4AE20
// program: D9C174A4A54356AC, 42937135801BAA7E, 49F399BDFAD777F8
// program: 1BDE5ABD20055F26, 082670B4222015B2, DBA0F8FE46AD8D9B
// program: D9C174A4A54356AC, 42937135801BAA7E, 1C8824D71CA6B238
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 7ED2F034E5EB4FC6
// program: E81D148B6EF003F8, B80FA1B7F97410CD, BC32652205728950
// program: D9C174A4A54356AC, 42937135801BAA7E, 3018EA11DFB984D3
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 10AAC2A3349D1A7E
// program: D9C174A4A54356AC, 42937135801BAA7E, 52F5F74AF1B519B6
// program: D9C174A4A54356AC, 42937135801BAA7E, 98F0722A788E01FD
// program: D9C174A4A54356AC, 42937135801BAA7E, 6E5C02D38B9C02DF
// program: D9C174A4A54356AC, 42937135801BAA7E, A4E2954DD6C4FB71
// program: D9C174A4A54356AC, 42937135801BAA7E, 5F0787304B8A0BD1
// program: D0293423BD9EA1E7, B80FA1B7F97410CD, 19F7816C4117CF8E
// program: D9C174A4A54356AC, 42937135801BAA7E, 5FBCCF5F27F5A7C1
// program: D9C174A4A54356AC, 42937135801BAA7E, 63B6ADAD25C2A518
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 47E4BEE6B3304AF3
// program: E81D148B6EF003F8, B80FA1B7F97410CD, C580B429ECAF519A
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 4BA25B84A31C492A
// program: D9C174A4A54356AC, 42937135801BAA7E, 6B98A4CC666FCBCF
// program: D9C174A4A54356AC, 42937135801BAA7E, D1257B6267770D05
// program: D9C174A4A54356AC, 42937135801BAA7E, D134C63316570D84
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 40FC95A67F54598B
// program: E81D148B6EF003F8, B80FA1B7F97410CD, D69A3CB52F0E3495
// program: E81D148B6EF003F8, B80FA1B7F97410CD, B5CB613BFC4BC41C
// program: 502AB780D80D09C1, B80FA1B7F97410CD, 1B4DA8DA884D39A1
// program: E81D148B6EF003F8, B80FA1B7F97410CD, D2BD0C5FAA2AB273
// program: E81D148B6EF003F8, B80FA1B7F97410CD, F8FBCC791CAC22F2
// program: E81D148B6EF003F8, B80FA1B7F97410CD, FEE7FD4C7FD3D731
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 8633243B2123B710
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 39E142A8F1F39B96
// program: E81D148B6EF003F8, B80FA1B7F97410CD, FC9E10BE42F07103
// program: 1BDE5ABD20055F26, 082670B4222015B2, DBA0F8FE46AD8D9B
// program: D9C174A4A54356AC, 42937135801BAA7E, 47A8279A60685F27
// program: 5E28DB645EED49B7, B80FA1B7F97410CD, C2EEBEAE0D7F3560
// program: A40B5D829674D1F8, B80FA1B7F97410CD, 1CBA1DD1EAE2F663
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 6A08A79BE3FAC39D
// program: D0293423BD9EA1E7, B80FA1B7F97410CD, 10AAC2A3349D1A7E
// program: 49AB6B882020674A, 082670B4222015B2, 0D19D21B46AD8D9B
// program: D9C174A4A54356AC, 42937135801BAA7E, 29CD3EBE51FAA42A
// program: D9C174A4A54356AC, 42937135801BAA7E, B2E64CFB9744D892
// program: D9C174A4A54356AC, 42937135801BAA7E, 98647FD3CF93B689
// program: 49AB6B882020674A, 082670B4222015B2, DBA0F8FE46AD8D9B
// program: 70A370D21404144E, 082670B4222015B2, DBA0F8FE46AD8D9B
// program: 70A370D21404144E, 082670B4222015B2, F4A415D97E9B6ED6
// program: D9C174A4A54356AC, 42937135801BAA7E, AB0D786CFAD777F8
// program: E81D148B6EF003F8, B80FA1B7F97410CD, 6A44D3E672630106
// program: 35CCCCDE75E2FF83, B80FA1B7F97410CD, 0AC00F84117E7EFC
// program: 4CDB2C6E0A14815D, B80FA1B7F97410CD, A36D1D6BA424DB28
// program: 4CDB2C6E0A14815D, B80FA1B7F97410CD, 641FDB3E9E36B758
// program: 49AB6B882020674A, 082670B4222015B2, 1430EF96EBF7840F
// program: 4028512EA840631E, B80FA1B7F97410CD, C2EEBEAE0D7F3560
// program: A40B5D829674D1F8, B80FA1B7F97410CD, 9D0535C6802495CB
// program: 49AB6B882020674A, 082670B4222015B2, 63A5270519B4AE20
// program: D9C174A4A54356AC, 42937135801BAA7E, 49F399BDFAD777F8
// program: D9C174A4A54356AC, 42937135801BAA7E, 00F9BB7ACF93B689
// program: 3526EFD6EA584B4A, B80FA1B7F97410CD, B766CBB102E471E4
// program: 70A370D21404144E, 082670B4222015B2, B51C0DE019B4AE20
// program: 1BDE5ABD20055F26, 082670B4222015B2, 1EF23692707A019C
// program: 1BDE5ABD20055F26, 082670B4222015B2, 0D8F34E8707A019C
// program: 70A370D21404144E, 082670B4222015B2, 63A5270519B4AE20
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 26CF8128A3DDBB83
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 953385FED82E0FD1
// program: 2E530FFFDA886761, B80FA1B7F97410CD, E52C4E220978C964
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 378438FF70532E82
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 9F25A997909124C1
// program: 2E530FFFDA886761, B80FA1B7F97410CD, F35E8CA2CAC182F7
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 168DA83A29634DCC
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 576E786439C2EA2F
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 1471721266F6CFF3
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 90EA57FA2E348842
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 1212B53523129C17
// program: 2E530FFFDA886761, B80FA1B7F97410CD, C9A23B908E5F8ABB
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 7E2D94A79BE7422B
// program: 91D55C04BB07EE32, B80FA1B7F97410CD, 9342C6596F83F706
// program: 2E530FFFDA886761, B80FA1B7F97410CD, D02B1E1378BD97CF
// program: 2E530FFFDA886761, B80FA1B7F97410CD, B78314A585D12D9C
// program: 2E530FFFDA886761, B80FA1B7F97410CD, DEC6EAEA57FA4325
// program: 2E530FFFDA886761, B80FA1B7F97410CD, D4C50B709583D191
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 48065A05481CB4B8
// program: 2E530FFFDA886761, B80FA1B7F97410CD, B20F7E72A7330A13
// program: 2E530FFFDA886761, B80FA1B7F97410CD, BB80E4A110994B48
// program: 2E530FFFDA886761, B80FA1B7F97410CD, EAAC665924781109
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 0656C780E79F2203
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 31E556E9A7729BF4
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 6C66577708AE1E87
// program: 2E530FFFDA886761, B80FA1B7F97410CD, FC7222C50C6F5038
// program: 2E530FFFDA886761, B80FA1B7F97410CD, D1B1A073730D724F
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 790FB95CC0B11076
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 037898F85F34DE95
// program: 46E991DEB658A5A9, B80FA1B7F97410CD, 91931D139F54748D
// program: 46E991DEB658A5A9, B80FA1B7F97410CD, 5FACCC9E3E0584D2
// program: 81B0676B862CF405, 42937135801BAA7E, F5D54925A6AE705F
// program: 81B0676B862CF405, 42937135801BAA7E, 835CABE3A4B650D2
// program: 81B0676B862CF405, 42937135801BAA7E, D4C9E99618707555
// program: 81B0676B862CF405, 42937135801BAA7E, 0951EE62DBCF2390
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 7ED2F034E5EB4FC6
// program: 2E530FFFDA886761, B80FA1B7F97410CD, BC32652205728950
// program: 81B0676B862CF405, 42937135801BAA7E, 21786A34D707A069
// program: 81B0676B862CF405, 42937135801BAA7E, 5124AD903EB19D9F
// program: 81B0676B862CF405, 42937135801BAA7E, 886AC14BAA341C33
// program: 81B0676B862CF405, 42937135801BAA7E, 7C14C907B3CCD849
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 10AAC2A3349D1A7E
// program: 81B0676B862CF405, 42937135801BAA7E, 52F5F74AF1B519B6
// program: 81B0676B862CF405, 42937135801BAA7E, 98F0722A788E01FD
// program: 81B0676B862CF405, 42937135801BAA7E, 6E5C02D38B9C02DF
// program: 81B0676B862CF405, 42937135801BAA7E, A4E2954DD6C4FB71
// program: FD3DADE0E2BC47C9, B80FA1B7F97410CD, 19F7816C4117CF8E
// program: 81B0676B862CF405, 42937135801BAA7E, 5FBCCF5F27F5A7C1
// program: 81B0676B862CF405, 42937135801BAA7E, 63B6ADAD25C2A518
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 47E4BEE6B3304AF3
// program: 2E530FFFDA886761, B80FA1B7F97410CD, C580B429ECAF519A
// program: 1934FF8F80653ACB, B80FA1B7F97410CD, 5C250F6C1418BBD3
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 4BA25B84A31C492A
// program: 81B0676B862CF405, 42937135801BAA7E, CAB8B665DC444CE4
// program: 81B0676B862CF405, 42937135801BAA7E, 6B98A4CC666FCBCF
// program: 81B0676B862CF405, 42937135801BAA7E, D1257B6267770D05
// program: 81B0676B862CF405, 42937135801BAA7E, D134C63316570D84
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 40FC95A67F54598B
// program: 2E530FFFDA886761, B80FA1B7F97410CD, D69A3CB52F0E3495
// program: 2E530FFFDA886761, B80FA1B7F97410CD, B5CB613BFC4BC41C
// program: 46E991DEB658A5A9, B80FA1B7F97410CD, 1B4DA8DA884D39A1
// program: 2E530FFFDA886761, B80FA1B7F97410CD, D2BD0C5FAA2AB273
// program: 2E530FFFDA886761, B80FA1B7F97410CD, F8FBCC791CAC22F2
// program: 2E530FFFDA886761, B80FA1B7F97410CD, FEE7FD4C7FD3D731
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 8633243B2123B710
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 39E142A8F1F39B96
// program: 2E530FFFDA886761, B80FA1B7F97410CD, FC9E10BE42F07103
// program: C6410D4382B19655, 082670B4222015B2, DBA0F8FE46AD8D9B
// program: 81B0676B862CF405, 42937135801BAA7E, 47A8279A60685F27
// program: 466184E6A05DFF0F, B80FA1B7F97410CD, C2EEBEAE0D7F3560
// program: 45C9694A57480945, B80FA1B7F97410CD, 490CACB848ED440A
// program: D03F0FE4B72A8E86, B80FA1B7F97410CD, 1CBA1DD1EAE2F663
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 6A08A79BE3FAC39D
// program: FD3DADE0E2BC47C9, B80FA1B7F97410CD, 10AAC2A3349D1A7E
// program: 949D68475595512F, 082670B4222015B2, 0D19D21B46AD8D9B
// program: 81B0676B862CF405, 42937135801BAA7E, 29CD3EBE51FAA42A
// program: 81B0676B862CF405, 42937135801BAA7E, B2E64CFB9744D892
// program: 81B0676B862CF405, 42937135801BAA7E, 98647FD3CF93B689
// program: 949D68475595512F, 082670B4222015B2, DBA0F8FE46AD8D9B
// program: 2FBE2E4ED1D9324C, 082670B4222015B2, DBA0F8FE46AD8D9B
// program: 2FBE2E4ED1D9324C, 082670B4222015B2, F4A415D97E9B6ED6
// program: 81B0676B862CF405, 42937135801BAA7E, AB0D786CFAD777F8
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 6A44D3E672630106
// program: 45C9694A57480945, B80FA1B7F97410CD, 0AC00F84117E7EFC
// program: 1B722ADD909A7B2D, B80FA1B7F97410CD, B3C2F6056AADCF6F
// program: 1B722ADD909A7B2D, B80FA1B7F97410CD, A36D1D6BA424DB28
// program: 1B722ADD909A7B2D, B80FA1B7F97410CD, 641FDB3E9E36B758
// program: 949D68475595512F, 082670B4222015B2, 1430EF96EBF7840F
// program: B0CCAE4F9AB69CDA, B80FA1B7F97410CD, C2EEBEAE0D7F3560
// program: D03F0FE4B72A8E86, B80FA1B7F97410CD, 9D0535C6802495CB
// program: 949D68475595512F, 082670B4222015B2, 63A5270519B4AE20
// program: 81B0676B862CF405, 42937135801BAA7E, 49F399BDFAD777F8
// program: 81B0676B862CF405, 42937135801BAA7E, 00F9BB7ACF93B689
// program: A214E3C9645157AE, B80FA1B7F97410CD, B766CBB102E471E4
// program: 2FBE2E4ED1D9324C, 082670B4222015B2, B51C0DE019B4AE20
// program: C6410D4382B19655, 082670B4222015B2, 1EF23692707A019C
// program: C6410D4382B19655, 082670B4222015B2, 0D8F34E8707A019C
// program: 2FBE2E4ED1D9324C, 082670B4222015B2, 63A5270519B4AE20
// program: 2E530FFFDA886761, B80FA1B7F97410CD, FFE5F81052CAA889
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 3013FC5CF83A846B
// program: 46E991DEB658A5A9, B80FA1B7F97410CD, FC9E10BE42F07103
// program: 81B0676B862CF405, 42937135801BAA7E, 9978311FA4F16C3C
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 01575BADBADD21EF
// program: 2E530FFFDA886761, B80FA1B7F97410CD, ABC97C54A7BF4D60
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 26BBC1E6E0D6F7FF
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 7337CC71AC06DD60
// program: 2E530FFFDA886761, B80FA1B7F97410CD, CF7B55EB749B1745
// program: 2E530FFFDA886761, B80FA1B7F97410CD, F2989B699B9A67E9
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 64E77DF66C1C7766
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 3D2F05F592BCAC45
// program: 81B0676B862CF405, 42937135801BAA7E, DBAEBC3C69195AAA
// program: 81B0676B862CF405, 42937135801BAA7E, 62CB16D7F16FAC9B
// program: 81B0676B862CF405, 42937135801BAA7E, 31DB35D8B8E9549F
// program: 81B0676B862CF405, 42937135801BAA7E, EB5CA625F01267FB
// program: 81B0676B862CF405, 42937135801BAA7E, F2C7CEFD4FAFF562
// program: 2E530FFFDA886761, B80FA1B7F97410CD, 72AEE74A87B55733
// program: 81B0676B862CF405, 42937135801BAA7E, EF6E6A305FC7B5A1
// program: 81B0676B862CF405, 42937135801BAA7E, ADBF67247E14A994
// program: 81B0676B862CF405, 42937135801BAA7E, C6BAD9CE0AEB9402
// program: 81B0676B862CF405, 42937135801BAA7E, 0C044E501EE62795
// program: 81B0676B862CF405, 42937135801BAA7E, 244B48F0C67C62A2
