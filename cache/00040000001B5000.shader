// shader: 8B31, 4FC2B4EDFF8D2FB4

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location = 0) in vec4 vs_in_reg0;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;
out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_1();
bool sub_2();
bool sub_8();
bool sub_9();
bool sub_10();
bool sub_11();
bool sub_13();
bool sub_15();
bool sub_16();
bool sub_17();
bool sub_18();
bool sub_19();
bool sub_20();
bool sub_21();
bool sub_22();
bool sub_23();
bool sub_24();
bool sub_25();
bool sub_26();
bool sub_3();
bool sub_4();
bool sub_5();
bool sub_6();
bool sub_7();
bool sub_12();
bool sub_14();
bool sub_0();

bool exec_shader() {
    sub_0();
    return true;
}

bool sub_1() {
    reg_tmp0.xy = (uniforms.f[0].xxxx).xy;
    if (uniforms.b[2]) {
        sub_2();
    } else {
        sub_8();
    }
    return false;
}
bool sub_2() {
    {
        sub_3();
    }
    reg_tmp3.x = dot_s(uniforms.f[1].xywz, reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2].xywz, reg_tmp6);
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_8() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_9();
    } else {
        sub_10();
    }
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_9() {
    reg_tmp6 = reg_tmp10;
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    reg_tmp3.z = dot_s(uniforms.f[3], reg_tmp6);
    reg_tmp0.xy = (mul_s(uniforms.f[9].xyyy, reg_tmp3.zzzz)).xy;
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_10() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_11();
    } else {
        sub_13();
    }
    return false;
}
bool sub_11() {
    {
        sub_12();
    }
    reg_tmp3.x = dot_3(uniforms.f[1].xyz, reg_tmp6.xyz);
    reg_tmp3.y = dot_3(uniforms.f[2].xyz, reg_tmp6.xyz);
    reg_tmp3.z = dot_3(uniforms.f[3].xyz, reg_tmp6.xyz);
    return false;
}
bool sub_13() {
    {
        sub_14();
    }
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    return false;
}
bool sub_15() {
    reg_tmp0.xy = (uniforms.f[0].yyyy).xy;
    if (uniforms.b[3]) {
        sub_16();
    } else {
        sub_17();
    }
    return false;
}
bool sub_16() {
    {
        sub_3();
    }
    reg_tmp4.x = dot_s(uniforms.f[4].xywz, reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5].xywz, reg_tmp6);
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_17() {
    if (uniforms.b[5]) {
        sub_18();
    } else {
        sub_21();
    }
    return false;
}
bool sub_18() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_19();
    } else {
        sub_20();
    }
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_19() {
    reg_tmp6 = reg_tmp10;
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    reg_tmp4.z = dot_s(uniforms.f[6], reg_tmp6);
    reg_tmp6.w = rcp_s(reg_tmp4.z);
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    reg_tmp4.xy = (uniforms.f[9].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_20() {
    {
        sub_14();
    }
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    return false;
}
bool sub_21() {
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_22() {
    reg_tmp0.xy = (uniforms.f[0].zzzz).xy;
    if (uniforms.b[4]) {
        sub_23();
    } else {
        sub_24();
    }
    return false;
}
bool sub_23() {
    {
        sub_3();
    }
    reg_tmp5.x = dot_s(uniforms.f[7].xywz, reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8].xywz, reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_24() {
    if (uniforms.b[6]) {
        sub_25();
    } else {
        sub_26();
    }
    return false;
}
bool sub_25() {
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    {
        sub_14();
    }
    reg_tmp5.x = dot_s(uniforms.f[7], reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8], reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_26() {
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
bool sub_3() {
    conditional_code = equal(uniforms.f[93].yz, reg_tmp0.xy);
    if (all(not(conditional_code))) {
        sub_4();
    } else {
        sub_5();
    }
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_4() {
    reg_tmp6.xy = (vs_in_reg4.xyyy).xy;
    return false;
}
bool sub_5() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_6();
    } else {
        sub_7();
    }
    return false;
}
bool sub_6() {
    reg_tmp6.xy = (vs_in_reg5.xyyy).xy;
    return false;
}
bool sub_7() {
    reg_tmp6.xy = (vs_in_reg6.xyyy).xy;
    return false;
}
bool sub_12() {
    reg_tmp2 = -reg_tmp15;
    reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
    reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_14() {
    {
        sub_12();
    }
    reg_tmp1 = reg_tmp6;
    reg_tmp1.z = (uniforms.f[93].yyyy + reg_tmp1.zzzz).z;
    reg_tmp1 = vec4(dot_3(reg_tmp1.xyz, reg_tmp1.xyz));
    reg_tmp2 = vec4(rsq_s(reg_tmp1.x));
    reg_tmp2 = mul_s(uniforms.f[94].xxxx, reg_tmp2);
    reg_tmp6.xy = (mul_s(reg_tmp6.xyyy, reg_tmp2)).xy;
    reg_tmp6.xy = (uniforms.f[94].xxxx + reg_tmp6.xyyy).xy;
    return false;
}
bool sub_0() {
    reg_tmp0 = vs_in_reg0;
    reg_tmp0.z = (uniforms.f[93].xxxx).z;
    reg_tmp0.w = (uniforms.f[93].yyyy).w;
    vs_out_attr0 = reg_tmp0;
    vs_out_attr2 = reg_tmp0;
    vs_out_attr1 = reg_tmp0;
    vs_out_attr3 = uniforms.f[93].yyyy;
    {
        sub_1();
    }
    {
        sub_15();
    }
    {
        sub_22();
    }
    return true;
}
// reference: 9D22F5C4B9D96E0A, 4FC2B4EDFF8D2FB4
// shader: 8DD9, 0D30074279C2FEED

layout(triangles) in;
layout(triangle_strip, max_vertices = 3) out;

out vec4 primary_color;
out vec2 texcoord0;
out vec2 texcoord1;
out vec2 texcoord2;
out float texcoord0_w;
out vec4 normquat;
out vec3 view;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

in vec4 vs_out_attr0[];
in vec4 vs_out_attr1[];
in vec4 vs_out_attr2[];
in vec4 vs_out_attr3[];
in vec4 vs_out_attr4[];
in vec4 vs_out_attr5[];
in vec4 vs_out_attr6[];
struct Vertex {
    vec4 attributes[7];
};

vec4 GetVertexQuaternion(Vertex vtx) {
    return vec4(vtx.attributes[1].x, vtx.attributes[1].y, vtx.attributes[1].z, vtx.attributes[1].w);
}

void EmitVtx(Vertex vtx, bool quats_opposite) {
    vec4 vtx_pos = vec4(vtx.attributes[0].x, vtx.attributes[0].y, vtx.attributes[0].z, vtx.attributes[0].w);
    gl_Position = vtx_pos;
#if !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)
    gl_ClipDistance[0] = -vtx_pos.z;
    gl_ClipDistance[1] = dot(clip_coef, vtx_pos);
#endif // !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)

    vec4 vtx_quat = GetVertexQuaternion(vtx);
    normquat = mix(vtx_quat, -vtx_quat, bvec4(quats_opposite));

    vec4 vtx_color = vec4(vtx.attributes[3].x, vtx.attributes[3].y, vtx.attributes[3].z, vtx.attributes[3].w);
    primary_color = min(abs(vtx_color), vec4(1.0));

    texcoord0 = vec2(vtx.attributes[4].x, vtx.attributes[4].y);
    texcoord1 = vec2(vtx.attributes[5].x, vtx.attributes[5].y);

    texcoord0_w = vtx.attributes[4].z;
    view = vec3(vtx.attributes[2].x, vtx.attributes[2].y, vtx.attributes[2].z);
    texcoord2 = vec2(vtx.attributes[6].x, vtx.attributes[6].y);

    EmitVertex();
}

bool AreQuaternionsOpposite(vec4 qa, vec4 qb) {
    return (dot(qa, qb) < 0.0);
}

void EmitPrim(Vertex vtx0, Vertex vtx1, Vertex vtx2) {
    EmitVtx(vtx0, false);
    EmitVtx(vtx1, AreQuaternionsOpposite(GetVertexQuaternion(vtx0), GetVertexQuaternion(vtx1)));
    EmitVtx(vtx2, AreQuaternionsOpposite(GetVertexQuaternion(vtx0), GetVertexQuaternion(vtx2)));
    EndPrimitive();
}

void main() {
    Vertex prim_buffer[3];
    prim_buffer[0].attributes = vec4[7](vs_out_attr0[0], vs_out_attr1[0], vs_out_attr2[0], vs_out_attr3[0], vs_out_attr4[0], vs_out_attr5[0], vs_out_attr6[0]);
    prim_buffer[1].attributes = vec4[7](vs_out_attr0[1], vs_out_attr1[1], vs_out_attr2[1], vs_out_attr3[1], vs_out_attr4[1], vs_out_attr5[1], vs_out_attr6[1]);
    prim_buffer[2].attributes = vec4[7](vs_out_attr0[2], vs_out_attr1[2], vs_out_attr2[2], vs_out_attr3[2], vs_out_attr4[2], vs_out_attr5[2], vs_out_attr6[2]);
    EmitPrim(prim_buffer[0], prim_buffer[1], prim_buffer[2]);
}
// reference: FC74FA4ACA1C8C74, 0D30074279C2FEED
// shader: 8B30, B876854F52934B46
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = (last_tex_env_out.r);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 845FF0BC87927CCD, B876854F52934B46
// program: 4FC2B4EDFF8D2FB4, 0D30074279C2FEED, B876854F52934B46
// shader: 8B31, 7C96EBECB346C618

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location = 0) in vec4 vs_in_reg0;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_5();
bool sub_6();
bool sub_7();
bool sub_8();
bool sub_9();
bool sub_10();
bool sub_11();
bool sub_12();
bool sub_13();
bool sub_14();
bool sub_15();
bool sub_16();
bool sub_17();
bool sub_18();
bool sub_19();
bool sub_20();
bool sub_21();
bool sub_22();
bool sub_23();
bool sub_24();
bool sub_25();
bool sub_26();
bool sub_27();
bool sub_28();
bool sub_29();
bool sub_30();
bool sub_31();
bool sub_32();
bool sub_1();
bool sub_0();
bool sub_2();
bool sub_3();
bool sub_4();
bool sub_33();
bool sub_34();
bool sub_35();
bool sub_36();
bool sub_37();
bool sub_38();
bool sub_39();
bool sub_40();
bool sub_41();

bool exec_shader() {
    sub_0();
    return true;
}

bool sub_5() {
    reg_tmp13 = floor(reg_tmp0.xxxx);
    reg_tmp13 = reg_tmp0.xxxx + -reg_tmp13;
    address_registers.y = (ivec2(reg_tmp11.zz)).y;
    conditional_code = lessThanEqual(uniforms.f[5].ww, reg_tmp13.xx);
    if (conditional_code.x) {
        sub_6();
    }
    conditional_code = lessThanEqual(uniforms.f[5].yy, reg_tmp11.xy);
    if (!conditional_code.y) {
        sub_15();
    } else {
        sub_22();
    }
    return false;
}
bool sub_6() {
    reg_tmp12.xy = (uniforms.f[5].xyyy + vs_in_reg0.zwww).xy;
    reg_tmp14.xy = (uniforms.f[6].wzzz).xy;
    reg_tmp13.xy = (mul_s(uniforms.f[5].zzzz, reg_tmp0.xxxx)).xy;
    reg_tmp13.y = (floor(reg_tmp13)).y;
    reg_tmp13.x = (reg_tmp13.xxxx + -reg_tmp13.yyyy).x;
    conditional_code = lessThanEqual(uniforms.f[5].ww, reg_tmp13.xx);
    if (conditional_code.x) {
        sub_7();
    }
    reg_tmp14.xy = (mul_s(reg_tmp14, reg_tmp2)).xy;
    reg_tmp13.x = (mul_s(uniforms.f[5].zzzz, reg_tmp13.xxxx)).x;
    reg_tmp13 = mul_s(uniforms.f[5].zyzy, reg_tmp13.xxxx);
    reg_tmp13.zw = (floor(reg_tmp13)).zw;
    reg_tmp13.xy = (reg_tmp13.xyyy + -reg_tmp13.zwww).xy;
    conditional_code = lessThanEqual(uniforms.f[5].ww, reg_tmp13.xy);
    if (conditional_code.y) {
        sub_8();
    }
    if (conditional_code.x) {
        sub_9();
    }
    reg_tmp14.xy = (uniforms.f[5].yyyy + -reg_tmp14.xyyy).xy;
    reg_tmp13.x = (mul_s(uniforms.f[5].zzzz, reg_tmp13.xxxx)).x;
    reg_tmp13 = mul_s(uniforms.f[5].zyzy, reg_tmp13.xxxx);
    reg_tmp13.zw = (floor(reg_tmp13)).zw;
    reg_tmp13.xy = (reg_tmp13.xyyy + -reg_tmp13.zwww).xy;
    conditional_code = lessThanEqual(uniforms.f[5].ww, reg_tmp13.xy);
    if (conditional_code.y) {
        sub_10();
    }
    if (conditional_code.x) {
        sub_11();
    }
    reg_tmp13.x = (mul_s(uniforms.f[5].zzzz, reg_tmp13.xxxx)).x;
    reg_tmp13 = mul_s(uniforms.f[5].zyzy, reg_tmp13.xxxx);
    reg_tmp13.zw = (floor(reg_tmp13)).zw;
    reg_tmp13.xy = (reg_tmp13.xyyy + -reg_tmp13.zwww).xy;
    conditional_code = lessThanEqual(uniforms.f[5].ww, reg_tmp13.xy);
    if (conditional_code.y) {
        sub_12();
    }
    if (conditional_code.x) {
        sub_13();
    }
    reg_tmp13.xy = (mul_s(uniforms.f[5].zzzz, reg_tmp0.xxxx)).xy;
    reg_tmp13.y = (floor(reg_tmp13)).y;
    reg_tmp13.x = (reg_tmp13.xxxx + -reg_tmp13.yyyy).x;
    conditional_code = lessThanEqual(uniforms.f[5].ww, reg_tmp13.xx);
    if (conditional_code.x) {
        sub_14();
    }
    reg_tmp12.y = (uniforms.f[5].yyyy + -reg_tmp12.yyyy).y;
    return false;
}
bool sub_7() {
    reg_tmp14.xy = (reg_tmp14.yxxx).xy;
    return false;
}
bool sub_8() {
    reg_tmp12.x = (mul_s(reg_tmp12.xxxx, reg_tmp14.xxxx)).x;
    return false;
}
bool sub_9() {
    reg_tmp12.y = (fma_s(reg_tmp12.yyyy, reg_tmp14.yyyy, uniforms.f[5].yyyy)).y;
    reg_tmp12.y = (reg_tmp12.yyyy + -reg_tmp14.yyyy).y;
    return false;
}
bool sub_10() {
    reg_tmp12.x = (reg_tmp12.xxxx + reg_tmp14.xxxx).x;
    return false;
}
bool sub_11() {
    reg_tmp12.y = (reg_tmp12.yyyy + -reg_tmp14.yyyy).y;
    return false;
}
bool sub_12() {
    reg_tmp12.x = (uniforms.f[5].yyyy + -reg_tmp12.xxxx).x;
    return false;
}
bool sub_13() {
    reg_tmp12.y = (uniforms.f[5].yyyy + -reg_tmp12.yyyy).y;
    return false;
}
bool sub_14() {
    reg_tmp12.xy = (uniforms.f[5].yyyy + -reg_tmp12.yxxx).xy;
    return false;
}
bool sub_15() {
    reg_tmp13.x = (floor(reg_tmp0.xxxx)).x;
    reg_tmp13.x = (reg_tmp0.xxxx + -reg_tmp13).x;
    conditional_code = lessThanEqual(uniforms.f[5].ww, reg_tmp13.xx);
    reg_tmp13 = uniforms.f[32 + address_registers.y].wzyx;
    if (conditional_code.x) {
        sub_16();
    } else {
        sub_17();
    }
    reg_tmp11.z = (uniforms.f[5].yyyy + reg_tmp11.zzzz).z;
    return false;
}
bool sub_16() {
    reg_tmp11.xy = (fma_s(reg_tmp12.xyyy, reg_tmp13.xyyy, reg_tmp13.zwww)).xy;
    reg_tmp11.xy = (mul_s(reg_tmp11.xyyy, reg_tmp14.zwww)).xy;
    reg_tmp11.y = (uniforms.f[5].yyyy + -reg_tmp11.yyyy).y;
    return false;
}
bool sub_17() {
    conditional_code = notEqual(uniforms.f[5].xx, vs_in_reg0.zw);
    if (!conditional_code.x) {
        sub_18();
    } else {
        sub_19();
    }
    if (!conditional_code.y) {
        sub_20();
    } else {
        sub_21();
    }
    return false;
}
bool sub_18() {
    reg_tmp11.x = (reg_tmp13.xxxx).x;
    return false;
}
bool sub_19() {
    reg_tmp11.x = (reg_tmp13.zzzz).x;
    return false;
}
bool sub_20() {
    reg_tmp11.y = (reg_tmp13.yyyy).y;
    return false;
}
bool sub_21() {
    reg_tmp11.y = (reg_tmp13.wwww).y;
    return false;
}
bool sub_22() {
    if (!conditional_code.x) {
        sub_23();
    } else {
        sub_32();
    }
    reg_tmp11.z = (uniforms.f[5].zzzz + reg_tmp11.zzzz).z;
    return false;
}
bool sub_23() {
    reg_tmp13.x = (floor(reg_tmp0.xxxx)).x;
    reg_tmp13.x = (reg_tmp0.xxxx + -reg_tmp13).x;
    conditional_code = lessThanEqual(uniforms.f[5].ww, reg_tmp13.xx);
    if (conditional_code.x) {
        sub_24();
    } else {
        sub_25();
    }
    return false;
}
bool sub_24() {
    reg_tmp12.zw = (uniforms.f[5].xxxy).zw;
    reg_tmp11.x = dot_s(uniforms.f[32 + address_registers.y].wzyx, reg_tmp12);
    reg_tmp11.y = dot_s(uniforms.f[33 + address_registers.y].wzyx, reg_tmp12);
    reg_tmp11.xy = (mul_s(reg_tmp11.xyyy, reg_tmp14.zwww)).xy;
    reg_tmp11.y = (uniforms.f[5].yyyy + -reg_tmp11.yyyy).y;
    return false;
}
bool sub_25() {
    reg_tmp14 = uniforms.f[32 + address_registers.y].wzyx;
    reg_tmp13 = uniforms.f[33 + address_registers.y].wzyx;
    conditional_code = notEqual(uniforms.f[5].xx, vs_in_reg0.zw);
    if (!conditional_code.y) {
        sub_26();
    } else {
        sub_29();
    }
    return false;
}
bool sub_26() {
    if (!conditional_code.x) {
        sub_27();
    } else {
        sub_28();
    }
    return false;
}
bool sub_27() {
    reg_tmp11.xy = (reg_tmp14.xyyy).xy;
    return false;
}
bool sub_28() {
    reg_tmp11.xy = (reg_tmp13.zwww).xy;
    return false;
}
bool sub_29() {
    if (!conditional_code.x) {
        sub_30();
    } else {
        sub_31();
    }
    return false;
}
bool sub_30() {
    reg_tmp11.xy = (reg_tmp13.xyyy).xy;
    return false;
}
bool sub_31() {
    reg_tmp11.xy = (reg_tmp14.zwww).xy;
    return false;
}
bool sub_32() {
    reg_tmp11.x = dot_s(uniforms.f[32 + address_registers.y].wzyx, reg_tmp1);
    reg_tmp11.y = dot_s(uniforms.f[33 + address_registers.y].wzyx, reg_tmp1);
    return false;
}
bool sub_1() {
    uint jmp_to = 97u;
    while (true) {
        switch (jmp_to) {
        case 97u: {
            reg_tmp3.x = dot_s(uniforms.f[32 + address_registers.x].wzyx, reg_tmp1);
            reg_tmp3.y = dot_s(uniforms.f[33 + address_registers.x].wzyx, reg_tmp1);
            reg_tmp3.z = dot_s(uniforms.f[34 + address_registers.x].wzyx, reg_tmp1);
            reg_tmp3.w = (reg_tmp1.wwww).w;
            reg_tmp11 = uniforms.f[4].wzyx;
            reg_tmp11.z = (-uniforms.f[34 + address_registers.x].xxxx + reg_tmp11.zzzz).z;
            conditional_code.x = uniforms.f[5].xxxx.x != reg_tmp11.xzzz.x;
            conditional_code.y = uniforms.f[5].xxxx.y < reg_tmp11.xzzz.y;
            if (any(not(conditional_code))) {
                { jmp_to = 108u; break; }
            }
            reg_tmp11.z = rcp_s(reg_tmp11.z);
            reg_tmp3.x = (reg_tmp3.xxxx + reg_tmp11.xxxx).x;
            reg_tmp3.x = (fma_s(-reg_tmp11.yyyy, reg_tmp11.zzzz, reg_tmp3.xxxx)).x;
        }
        case 108u: {
        }
        default: return false;
        }
    }
    return false;
}
bool sub_0() {
    uint jmp_to = 109u;
    while (true) {
        switch (jmp_to) {
        case 109u: {
            address_registers.x = (ivec2(vs_in_reg0.xx)).x;
            reg_tmp0 = uniforms.f[9 + address_registers.x].wzyx;
            reg_tmp1.xy = (vs_in_reg0.zwzw).xy;
            reg_tmp1.zw = (uniforms.f[5].xyxy).zw;
            address_registers.xy = ivec2(reg_tmp0.xy);
            reg_tmp2 = uniforms.f[32 + address_registers.y].wzyx;
            if (uniforms.b[0]) {
                { jmp_to = 191u; break; }
            }
            reg_tmp4 = uniforms.f[31 + address_registers.x].wzyx;
            reg_tmp1.xy = (fma_s(reg_tmp1.xyyy, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
            {
                sub_1();
            }
            vs_out_attr0.x = dot_s(uniforms.f[0].wzyx, reg_tmp3);
            vs_out_attr0.y = dot_s(uniforms.f[1].wzyx, reg_tmp3);
            vs_out_attr0.z = dot_s(uniforms.f[2].wzyx, reg_tmp3);
            vs_out_attr0.w = dot_s(uniforms.f[3].wzyx, reg_tmp3);
            conditional_code = greaterThanEqual(uniforms.f[5].yy, reg_tmp0.ww);
            if (all(conditional_code)) {
                sub_2();
            } else {
                sub_3();
            }
            reg_tmp11.z = (reg_tmp0.zzzz).z;
            reg_tmp9 = mul_s(uniforms.f[5].zyzy, reg_tmp0.zzzz);
            reg_tmp9.xy = (floor(reg_tmp9)).xy;
            reg_tmp9.xy = (reg_tmp9.zwww + -reg_tmp9.xyyy).xy;
            reg_tmp9 = mul_s(uniforms.f[5].zzzz, reg_tmp9);
            reg_tmp14 = uniforms.f[6].wzyx;
            reg_tmp11.xy = (reg_tmp9.xyyy).xy;
            {
                sub_5();
            }
            if (uniforms.b[1]) {
                sub_33();
            }
            if (uniforms.b[2]) {
                sub_34();
            }
            vs_out_attr2 = reg_tmp11.xyyy;
            reg_tmp9 = mul_s(uniforms.f[5].zyzy, reg_tmp9.xxxx);
            reg_tmp9.xy = (floor(reg_tmp9)).xy;
            reg_tmp9.xy = (reg_tmp9.zwww + -reg_tmp9.xyyy).xy;
            reg_tmp9 = mul_s(uniforms.f[5].zzzz, reg_tmp9);
            reg_tmp14 = uniforms.f[7].wzyx;
            reg_tmp11.xy = (reg_tmp9.xyyy).xy;
            {
                sub_5();
            }
            if (uniforms.b[3]) {
                sub_35();
            }
            if (uniforms.b[4]) {
                sub_36();
            }
            vs_out_attr3 = reg_tmp11.xyyy;
            reg_tmp9 = mul_s(uniforms.f[5].zyzy, reg_tmp9.xxxx);
            reg_tmp9.xy = (floor(reg_tmp9)).xy;
            reg_tmp9.xy = (reg_tmp9.zwww + -reg_tmp9.xyyy).xy;
            reg_tmp9 = mul_s(uniforms.f[5].zzzz, reg_tmp9);
            reg_tmp14 = uniforms.f[8].wzyx;
            reg_tmp11.xy = (reg_tmp9.xyyy).xy;
            {
                sub_5();
            }
            if (uniforms.b[5]) {
                sub_37();
            }
            if (uniforms.b[6]) {
                sub_38();
            }
            vs_out_attr4 = reg_tmp11.xyyy;
            return true;
        }
        case 191u: {
            reg_tmp2.w = (reg_tmp2.wwww + reg_tmp2.yyyy).w;
            reg_tmp1.y = (-uniforms.f[5].yyyy + -reg_tmp1.yyyy).y;
            reg_tmp13.xy = (mul_s(uniforms.f[36 + address_registers.x].wzzz, reg_tmp2.xyyy)).xy;
            reg_tmp11.x = (mul_s(uniforms.f[35 + address_registers.x].wwww, -reg_tmp1.yyyy)).x;
            reg_tmp1.xy = (mul_s(reg_tmp1.xyyy, reg_tmp13.xyyy)).xy;
            reg_tmp1.x = (reg_tmp1.xxxx + reg_tmp11.xxxx).x;
            if (uniforms.b[1]) {
                sub_39();
            }
            reg_tmp1.xy = (reg_tmp1.xyyy + reg_tmp2.zwww).xy;
            reg_tmp1.xy = (uniforms.f[36 + address_registers.x].yxxx + reg_tmp1.xyyy).xy;
            {
                sub_1();
            }
            vs_out_attr0.x = dot_s(uniforms.f[0].wzyx, reg_tmp3);
            vs_out_attr0.y = dot_s(uniforms.f[1].wzyx, reg_tmp3);
            vs_out_attr0.z = dot_s(uniforms.f[2].wzyx, reg_tmp3);
            vs_out_attr0.w = dot_s(uniforms.f[3].wzyx, reg_tmp3);
            if (uniforms.b[2]) {
                sub_40();
            } else {
                sub_41();
            }
            reg_tmp8 = reg_tmp8 + -reg_tmp7;
            vs_out_attr1 = fma_s(reg_tmp8, reg_tmp11.yyyy, reg_tmp7);
            reg_tmp9.xy = (mul_s(uniforms.f[32 + address_registers.x].yxxx, reg_tmp11)).xy;
            reg_tmp11.zw = (vec4(lessThan(reg_tmp11, uniforms.f[5].yyyy))).zw;
            reg_tmp9.xy = (fma_s(reg_tmp11.zwww, uniforms.f[32 + address_registers.x].wzzz, reg_tmp9.xyyy)).xy;
            reg_tmp9.y = (uniforms.f[5].yyyy + -reg_tmp9.yyyy).y;
            vs_out_attr2 = reg_tmp9;
            vs_out_attr3 = reg_tmp9;
            vs_out_attr4 = reg_tmp9;
            return true;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_2() {
    vs_out_attr1.xyz = (uniforms.f[5].yyyy).xyz;
    vs_out_attr1.w = (reg_tmp0.wwww).w;
    return false;
}
bool sub_3() {
    address_registers.y = (ivec2(reg_tmp0.ww)).y;
    reg_tmp7 = uniforms.f[32 + address_registers.y].wzyx;
    reg_tmp8 = uniforms.f[33 + address_registers.y].wzyx;
    reg_tmp9 = uniforms.f[34 + address_registers.y].wzyx;
    reg_tmp10 = uniforms.f[35 + address_registers.y].wzyx;
    reg_tmp11.xy = (vs_in_reg0.zwww).xy;
    reg_tmp14.x = (floor(reg_tmp0.yyyy)).x;
    reg_tmp14.x = (reg_tmp0.yyyy + -reg_tmp14.xxxx).x;
    conditional_code = lessThanEqual(uniforms.f[5].ww, reg_tmp14.xx);
    if (conditional_code.x) {
        sub_4();
    }
    reg_tmp11.xy = (abs(reg_tmp11.xyyy)).xy;
    reg_tmp8 = reg_tmp8 + -reg_tmp7;
    reg_tmp8 = fma_s(reg_tmp8, reg_tmp11.xxxx, reg_tmp7);
    reg_tmp10 = reg_tmp10 + -reg_tmp9;
    reg_tmp10 = fma_s(reg_tmp10, reg_tmp11.xxxx, reg_tmp9);
    reg_tmp10 = reg_tmp10 + -reg_tmp8;
    reg_tmp10 = fma_s(reg_tmp10, reg_tmp11.yyyy, reg_tmp8);
    vs_out_attr1 = reg_tmp10;
    return false;
}
bool sub_4() {
    reg_tmp11.z = rcp_s(reg_tmp4.x);
    reg_tmp11.w = rcp_s(reg_tmp4.y);
    reg_tmp11.xy = (reg_tmp1.xyyy + -reg_tmp4.zwww).xy;
    reg_tmp11.xy = (mul_s(reg_tmp11.xyyy, reg_tmp11.zwww)).xy;
    return false;
}
bool sub_33() {
    reg_tmp11.xy = (reg_tmp11.yxxx).xy;
    reg_tmp11.y = (uniforms.f[5].yyyy + -reg_tmp11.yyyy).y;
    return false;
}
bool sub_34() {
    reg_tmp11.xy = (uniforms.f[5].yyyy + -reg_tmp11.yxxx).xy;
    return false;
}
bool sub_35() {
    reg_tmp11.xy = (reg_tmp11.yxxx).xy;
    reg_tmp11.y = (uniforms.f[5].yyyy + -reg_tmp11.yyyy).y;
    return false;
}
bool sub_36() {
    reg_tmp11.xy = (uniforms.f[5].yyyy + -reg_tmp11.yxxx).xy;
    return false;
}
bool sub_37() {
    reg_tmp11.xy = (reg_tmp11.yxxx).xy;
    reg_tmp11.y = (uniforms.f[5].yyyy + -reg_tmp11.yyyy).y;
    return false;
}
bool sub_38() {
    reg_tmp11.xy = (uniforms.f[5].yyyy + -reg_tmp11.yxxx).xy;
    return false;
}
bool sub_39() {
    reg_tmp13.xzw = (mul_s(uniforms.f[5].wxxx, reg_tmp13.xxxx)).xzw;
    reg_tmp13.y = (mul_s(uniforms.f[34 + address_registers.y].yyyy, reg_tmp13.yyyy)).y;
    reg_tmp11 = fma_s(reg_tmp1, uniforms.f[5].yyxx, -reg_tmp13);
    reg_tmp14 = uniforms.f[33 + address_registers.y].wzyx;
    reg_tmp1.x = dot_3(reg_tmp11.xyz, reg_tmp14.xyy);
    reg_tmp1.y = dot_3(reg_tmp11.xyz, reg_tmp14.zww);
    reg_tmp14 = uniforms.f[34 + address_registers.y].wzyx;
    reg_tmp1.z = dot_s(vec4(reg_tmp11.xyz, 1.0), reg_tmp14);
    reg_tmp1.xy = (reg_tmp1.xyyy + reg_tmp13.xyyy).xy;
    return false;
}
bool sub_40() {
    reg_tmp11 = abs(vs_in_reg0.zwzw);
    reg_tmp14.w = (floor(reg_tmp0.zzzz)).w;
    reg_tmp14.w = (reg_tmp0.zzzz + -reg_tmp14).w;
    address_registers.xy = ivec2(reg_tmp0.zx);
    reg_tmp14.w = (mul_s(uniforms.f[5].zzzz, reg_tmp14.wwww)).w;
    reg_tmp14.xyz = (uniforms.f[5].yyyy).xyz;
    reg_tmp7 = mul_s(uniforms.f[37 + address_registers.y].wzyx, reg_tmp14);
    reg_tmp8 = mul_s(uniforms.f[38 + address_registers.y].wzyx, reg_tmp14);
    return false;
}
bool sub_41() {
    reg_tmp11 = abs(vs_in_reg0.zwzw);
    address_registers.xy = ivec2(reg_tmp0.zw);
    reg_tmp7 = uniforms.f[32 + address_registers.y].wzyx;
    reg_tmp8 = uniforms.f[33 + address_registers.y].wzyx;
    return false;
}
// reference: 31D3563606806F06, 7C96EBECB346C618
// shader: 8DD9, 1C4CBC8096EA16CD

layout(triangles) in;
layout(triangle_strip, max_vertices = 3) out;

out vec4 primary_color;
out vec2 texcoord0;
out vec2 texcoord1;
out vec2 texcoord2;
out float texcoord0_w;
out vec4 normquat;
out vec3 view;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

in vec4 vs_out_attr0[];
in vec4 vs_out_attr1[];
in vec4 vs_out_attr2[];
in vec4 vs_out_attr3[];
in vec4 vs_out_attr4[];
struct Vertex {
    vec4 attributes[5];
};

vec4 GetVertexQuaternion(Vertex vtx) {
    return vec4(0.0, 0.0, 0.0, 0.0);
}

void EmitVtx(Vertex vtx, bool quats_opposite) {
    vec4 vtx_pos = vec4(vtx.attributes[0].x, vtx.attributes[0].y, vtx.attributes[0].z, vtx.attributes[0].w);
    gl_Position = vtx_pos;
#if !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)
    gl_ClipDistance[0] = -vtx_pos.z;
    gl_ClipDistance[1] = dot(clip_coef, vtx_pos);
#endif // !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)

    vec4 vtx_quat = GetVertexQuaternion(vtx);
    normquat = mix(vtx_quat, -vtx_quat, bvec4(quats_opposite));

    vec4 vtx_color = vec4(vtx.attributes[1].x, vtx.attributes[1].y, vtx.attributes[1].z, vtx.attributes[1].w);
    primary_color = min(abs(vtx_color), vec4(1.0));

    texcoord0 = vec2(vtx.attributes[2].x, vtx.attributes[2].y);
    texcoord1 = vec2(vtx.attributes[3].x, vtx.attributes[3].y);

    texcoord0_w = 0.0;
    view = vec3(0.0, 0.0, 0.0);
    texcoord2 = vec2(vtx.attributes[4].x, vtx.attributes[4].y);

    EmitVertex();
}

bool AreQuaternionsOpposite(vec4 qa, vec4 qb) {
    return (dot(qa, qb) < 0.0);
}

void EmitPrim(Vertex vtx0, Vertex vtx1, Vertex vtx2) {
    EmitVtx(vtx0, false);
    EmitVtx(vtx1, AreQuaternionsOpposite(GetVertexQuaternion(vtx0), GetVertexQuaternion(vtx1)));
    EmitVtx(vtx2, AreQuaternionsOpposite(GetVertexQuaternion(vtx0), GetVertexQuaternion(vtx2)));
    EndPrimitive();
}

void main() {
    Vertex prim_buffer[3];
    prim_buffer[0].attributes = vec4[5](vs_out_attr0[0], vs_out_attr1[0], vs_out_attr2[0], vs_out_attr3[0], vs_out_attr4[0]);
    prim_buffer[1].attributes = vec4[5](vs_out_attr0[1], vs_out_attr1[1], vs_out_attr2[1], vs_out_attr3[1], vs_out_attr4[1]);
    prim_buffer[2].attributes = vec4[5](vs_out_attr0[2], vs_out_attr1[2], vs_out_attr2[2], vs_out_attr3[2], vs_out_attr4[2]);
    EmitPrim(prim_buffer[0], prim_buffer[1], prim_buffer[2]);
}
// reference: 5DAD5699F59B3586, 1C4CBC8096EA16CD
// shader: 8B30, 2B730240EE2A8461
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 1F78A607E9F3C0A1, 2B730240EE2A8461
// program: 7C96EBECB346C618, 1C4CBC8096EA16CD, 2B730240EE2A8461
// reference: 845FF0BC865016FA, B876854F52934B46
// reference: 7F87A97685750974, 7C96EBECB346C618
// shader: 8B30, 61C2DBAB611E2111
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 1F78A6071213B118, 61C2DBAB611E2111
// program: 7C96EBECB346C618, 1C4CBC8096EA16CD, 61C2DBAB611E2111
// shader: 8B30, 8CDEE3527B40AD89
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor2.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 61A079249DFD89EE, 8CDEE3527B40AD89
// program: 7C96EBECB346C618, 1C4CBC8096EA16CD, 8CDEE3527B40AD89
// shader: 8B30, D817DBC6DF308E49
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor2.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 61A079247B45F66B, D817DBC6DF308E49
// program: 7C96EBECB346C618, 1C4CBC8096EA16CD, D817DBC6DF308E49
// shader: 8B30, E0FFED93747D186B
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor2.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 61A0792480A587D2, E0FFED93747D186B
// program: 7C96EBECB346C618, 1C4CBC8096EA16CD, E0FFED93747D186B
// shader: 8B30, 493C9995DF308E49
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].aaa);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor2.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 5118666F2308FBFB, 493C9995DF308E49
// program: 7C96EBECB346C618, 1C4CBC8096EA16CD, 493C9995DF308E49
// shader: 8B30, D66A0721A170DF23
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor2.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D96FFE465B6167CB, D66A0721A170DF23
// program: 7C96EBECB346C618, 1C4CBC8096EA16CD, D66A0721A170DF23
// shader: 8B30, 08579E29FC7BD6B2
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor2.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D96FFE467E4D1A09, 08579E29FC7BD6B2
// program: 7C96EBECB346C618, 1C4CBC8096EA16CD, 08579E29FC7BD6B2
// shader: 8B30, 9CD17F850A019CF4
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].aaa);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor2.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: E9D7E10D2D37ED8D, 9CD17F850A019CF4
// program: 7C96EBECB346C618, 1C4CBC8096EA16CD, 9CD17F850A019CF4
// shader: 8B30, E811802E711441A8
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor2.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D96FFE468E9A91A4, E811802E711441A8
// program: 7C96EBECB346C618, 1C4CBC8096EA16CD, E811802E711441A8
// shader: 8B30, 75C1824A0A019CF4
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor2.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D96FFE46757AE01D, 75C1824A0A019CF4
// program: 7C96EBECB346C618, 1C4CBC8096EA16CD, 75C1824A0A019CF4
// shader: 8B31, FA3EDE76D7190AC4

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location = 0) in vec4 vs_in_reg0;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;
out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_2();
bool sub_3();
bool sub_4();
bool sub_5();
bool sub_7();
bool sub_8();
bool sub_14();
bool sub_15();
bool sub_16();
bool sub_17();
bool sub_19();
bool sub_21();
bool sub_22();
bool sub_23();
bool sub_24();
bool sub_25();
bool sub_26();
bool sub_27();
bool sub_28();
bool sub_29();
bool sub_30();
bool sub_31();
bool sub_32();
bool sub_9();
bool sub_10();
bool sub_11();
bool sub_12();
bool sub_13();
bool sub_18();
bool sub_20();
bool sub_0();
bool sub_1();
bool sub_6();

bool exec_shader() {
    sub_0();
    return true;
}

bool sub_2() {
    reg_tmp1.xyz = (uniforms.f[93].xxyx).xyz;
    reg_tmp8.x = dot_3(uniforms.f[0].xyz, reg_tmp12.xyz);
    reg_tmp8.y = dot_3(uniforms.f[1].xyz, reg_tmp12.xyz);
    reg_tmp8.z = dot_3(uniforms.f[2].xyz, reg_tmp12.xyz);
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp8.xyz);
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp8.xyz);
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp8.xyz);
    reg_tmp14.w = (uniforms.f[93].xxxx).w;
    reg_tmp8 = reg_tmp14;
    reg_tmp14.x = dot_s(reg_tmp8, reg_tmp8);
    reg_tmp14.x = rsq_s(reg_tmp14.x);
    reg_tmp14 = mul_s(reg_tmp8, reg_tmp14.xxxx);
    reg_tmp0 = uniforms.f[23];
    reg_tmp8.x = dot_3(uniforms.f[0].xyz, reg_tmp0.xyz);
    reg_tmp8.y = dot_3(uniforms.f[1].xyz, reg_tmp0.xyz);
    reg_tmp8.z = dot_3(uniforms.f[2].xyz, reg_tmp0.xyz);
    reg_tmp6.x = dot_3(uniforms.f[90].xyz, reg_tmp8.xyz);
    reg_tmp6.y = dot_3(uniforms.f[91].xyz, reg_tmp8.xyz);
    reg_tmp6.z = dot_3(uniforms.f[92].xyz, reg_tmp8.xyz);
    reg_tmp8.xyz = (reg_tmp6.xyzz + reg_tmp1.xyzz).xyz;
    reg_tmp8.w = (uniforms.f[93].xxxx).w;
    reg_tmp0.x = dot_s(reg_tmp8, reg_tmp8);
    reg_tmp0.x = rsq_s(reg_tmp0.x);
    reg_tmp0 = mul_s(reg_tmp8, reg_tmp0.xxxx);
    if (uniforms.b[5]) {
        sub_3();
    }
    if (uniforms.b[3]) {
        sub_4();
    }
    if (uniforms.b[4]) {
        sub_5();
    }
    vs_out_attr3 = reg_tmp2;
    return false;
}
bool sub_3() {
    reg_tmp8.x = dot_3(reg_tmp14.xyz, -reg_tmp6.xyz);
    reg_tmp8.y = dot_3(reg_tmp1.xyz, -reg_tmp6.xyz);
    reg_tmp8 = max(uniforms.f[93].xxxx, reg_tmp8);
    reg_tmp8.y = (mul_s(uniforms.f[94].zzzz, reg_tmp8.yyyy)).y;
    reg_tmp8.y = (uniforms.f[94].zzzz + reg_tmp8.yyyy).y;
    reg_tmp2.y = (mul_s(reg_tmp8.xxxx, reg_tmp8.yyyy)).y;
    return false;
}
bool sub_4() {
    reg_tmp9.z = dot_3(reg_tmp14.xyz, reg_tmp0.xyz);
    reg_tmp9.z = (max(uniforms.f[93].xxxx, reg_tmp9.zzzz)).z;
    reg_tmp9.z = (min(uniforms.f[93].yyyy, reg_tmp9.zzzz)).z;
    reg_tmp9.z = log2(reg_tmp9.z);
    reg_tmp9.z = (mul_s(uniforms.f[22].zzzz, reg_tmp9.zzzz)).z;
    reg_tmp9.z = exp2(reg_tmp9.z);
    reg_tmp2.z = (mul_s(uniforms.f[22].wwww, reg_tmp9.zzzz)).z;
    return false;
}
bool sub_5() {
    reg_tmp9.x = dot_3(reg_tmp14.xyz, reg_tmp1.xyz);
    reg_tmp9.x = (max(uniforms.f[93].xxxx, reg_tmp9.xxxx)).x;
    reg_tmp9.x = (min(uniforms.f[93].yyyy, reg_tmp9.xxxx)).x;
    reg_tmp9.x = (uniforms.f[93].yyyy + -reg_tmp9.xxxx).x;
    reg_tmp9.x = log2(reg_tmp9.x);
    reg_tmp9.x = (mul_s(uniforms.f[22].xxxx, reg_tmp9.xxxx)).x;
    reg_tmp9.x = exp2(reg_tmp9.x);
    reg_tmp2.w = (mul_s(uniforms.f[22].yyyy, reg_tmp9.xxxx)).w;
    return false;
}
bool sub_7() {
    reg_tmp0.xy = (uniforms.f[10].xxxx).xy;
    if (uniforms.b[9]) {
        sub_8();
    } else {
        sub_14();
    }
    return false;
}
bool sub_8() {
    {
        sub_9();
    }
    reg_tmp3.x = dot_s(uniforms.f[11].xywz, reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[12].xywz, reg_tmp6);
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_14() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_15();
    } else {
        sub_16();
    }
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_15() {
    reg_tmp6 = reg_tmp10;
    reg_tmp3.x = dot_s(uniforms.f[11], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[12], reg_tmp6);
    reg_tmp3.z = dot_s(uniforms.f[13], reg_tmp6);
    reg_tmp0.xy = (mul_s(uniforms.f[19].xyyy, reg_tmp3.zzzz)).xy;
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_16() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_17();
    } else {
        sub_19();
    }
    return false;
}
bool sub_17() {
    {
        sub_18();
    }
    reg_tmp3.x = dot_3(uniforms.f[11].xyz, reg_tmp6.xyz);
    reg_tmp3.y = dot_3(uniforms.f[12].xyz, reg_tmp6.xyz);
    reg_tmp3.z = dot_3(uniforms.f[13].xyz, reg_tmp6.xyz);
    return false;
}
bool sub_19() {
    {
        sub_20();
    }
    reg_tmp3.x = dot_s(uniforms.f[11], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[12], reg_tmp6);
    return false;
}
bool sub_21() {
    reg_tmp0.xy = (uniforms.f[10].yyyy).xy;
    if (uniforms.b[10]) {
        sub_22();
    } else {
        sub_23();
    }
    return false;
}
bool sub_22() {
    {
        sub_9();
    }
    reg_tmp4.x = dot_s(uniforms.f[14].xywz, reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[15].xywz, reg_tmp6);
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_23() {
    if (uniforms.b[13]) {
        sub_24();
    } else {
        sub_27();
    }
    return false;
}
bool sub_24() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_25();
    } else {
        sub_26();
    }
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_25() {
    reg_tmp6 = reg_tmp10;
    reg_tmp4.x = dot_s(uniforms.f[14], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[15], reg_tmp6);
    reg_tmp4.z = dot_s(uniforms.f[16], reg_tmp6);
    reg_tmp6.w = rcp_s(reg_tmp4.z);
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    reg_tmp4.xy = (uniforms.f[19].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_26() {
    {
        sub_20();
    }
    reg_tmp4.x = dot_s(uniforms.f[14], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[15], reg_tmp6);
    return false;
}
bool sub_27() {
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_28() {
    reg_tmp0.xy = (uniforms.f[10].zzzz).xy;
    if (uniforms.b[11]) {
        sub_29();
    } else {
        sub_30();
    }
    return false;
}
bool sub_29() {
    {
        sub_9();
    }
    reg_tmp5.x = dot_s(uniforms.f[17].xywz, reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[18].xywz, reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_30() {
    if (uniforms.b[14]) {
        sub_31();
    } else {
        sub_32();
    }
    return false;
}
bool sub_31() {
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    {
        sub_20();
    }
    reg_tmp5.x = dot_s(uniforms.f[17], reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[18], reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_32() {
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
bool sub_9() {
    conditional_code = equal(uniforms.f[93].yz, reg_tmp0.xy);
    if (all(not(conditional_code))) {
        sub_10();
    } else {
        sub_11();
    }
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_10() {
    reg_tmp6.xy = (mul_s(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
    return false;
}
bool sub_11() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_12();
    } else {
        sub_13();
    }
    return false;
}
bool sub_12() {
    reg_tmp6.xy = (mul_s(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
    return false;
}
bool sub_13() {
    reg_tmp6.xy = (mul_s(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
    return false;
}
bool sub_18() {
    reg_tmp2 = -reg_tmp15;
    reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
    reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_20() {
    reg_tmp1.xy = (uniforms.f[94].zzzz).xy;
    reg_tmp1.zw = (uniforms.f[93].xxxx).zw;
    reg_tmp6 = fma_s(reg_tmp14, reg_tmp1, reg_tmp1);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_0() {
    reg_tmp0 = vs_in_reg0;
    reg_tmp0.z = (uniforms.f[93].xxxx).z;
    reg_tmp0.w = (uniforms.f[93].yyyy).w;
    vs_out_attr0 = reg_tmp0;
    vs_out_attr2 = reg_tmp0;
    vs_out_attr1 = reg_tmp0;
    if (uniforms.b[6]) {
        sub_1();
    } else {
        sub_6();
    }
    {
        sub_7();
    }
    {
        sub_21();
    }
    {
        sub_28();
    }
    return true;
}
bool sub_1() {
    {
        sub_2();
    }
    return false;
}
bool sub_6() {
    vs_out_attr3 = uniforms.f[93].yyyy;
    return false;
}
// reference: D2E2F11128B5F225, FA3EDE76D7190AC4
// shader: 8B30, 4F0C86E8EDDB4D45
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp(vec3(dot((texcolor0.rgb) - vec3(0.5), (texcolor1.rgb) - vec3(0.5)) * 4.0), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) + (1.0 - texcolor1.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_1 = byteround(clamp(vec3(dot((texcolor0.rgb) - vec3(0.5), (texcolor2.rgb) - vec3(0.5)) * 4.0), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp(min((texcolor1.a) + (1.0 - texcolor0.a), 1.0) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (combiner_buffer.rgb) + (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp(min((texcolor0.a) + (1.0 - texcolor2.a), 1.0) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp(min((texcolor2.a) + (1.0 - texcolor0.a), 1.0) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a) - (const_color[4].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4 * 1.0, alpha_output_4 * 4.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (last_tex_env_out.aaa) + (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a) - (primary_fragment_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5 * 1.0, alpha_output_5 * 4.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: BAE480A51A8FC20E, 4F0C86E8EDDB4D45
// program: FA3EDE76D7190AC4, 0D30074279C2FEED, 4F0C86E8EDDB4D45
// shader: 8B30, F7CE14589569CE00
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp(vec3(dot((texcolor0.rgb) - vec3(0.5), (texcolor2.rgb) - vec3(0.5)) * 4.0), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp(min((texcolor1.a) + (1.0 - texcolor0.a), 1.0) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (combiner_buffer.rgb) + (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp(min((texcolor0.a) + (1.0 - texcolor2.a), 1.0) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 2E99070DCB85802A, F7CE14589569CE00
// program: 7C96EBECB346C618, 1C4CBC8096EA16CD, F7CE14589569CE00
// shader: 8B30, 4059552DC5DDBCE1
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp(vec3(dot((texcolor0.rgb) - vec3(0.5), (texcolor2.rgb) - vec3(0.5)) * 4.0), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp(min((texcolor1.a) + (1.0 - texcolor0.a), 1.0) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (combiner_buffer.rgb) + (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp(min((texcolor0.a) + (1.0 - texcolor2.a), 1.0) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 2E99070D3065F193, 4059552DC5DDBCE1
// program: 7C96EBECB346C618, 1C4CBC8096EA16CD, 4059552DC5DDBCE1
// shader: 8B31, AAA8EB839E9F5CC6

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;
out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_2();
bool sub_5();
bool sub_6();
bool sub_7();
bool sub_8();
bool sub_9();
bool sub_0();
bool sub_1();
bool sub_3();
bool sub_4();

bool exec_shader() {
    sub_0();
    return true;
}

bool sub_2() {
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    reg_tmp4.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_5() {
    conditional_code = equal(uniforms.f[93].yz, reg_tmp0.xy);
    if (all(not(conditional_code))) {
        sub_6();
    } else {
        sub_7();
    }
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_6() {
    reg_tmp6.xy = (vs_in_reg4.xyyy).xy;
    return false;
}
bool sub_7() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_8();
    } else {
        sub_9();
    }
    return false;
}
bool sub_8() {
    reg_tmp6.xy = (vs_in_reg5.xyyy).xy;
    return false;
}
bool sub_9() {
    reg_tmp6.xy = (vs_in_reg6.xyyy).xy;
    return false;
}
bool sub_0() {
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    if (uniforms.b[0]) {
        sub_1();
    } else {
        sub_3();
    }
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    if (all(conditional_code)) {
        sub_4();
    }
    vs_out_attr0 = reg_tmp0;
    vs_out_attr1 = uniforms.f[93].xxxx;
    vs_out_attr2 = uniforms.f[93].xxxx;
    reg_tmp0 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
    vs_out_attr3 = uniforms.f[94].zzzz + reg_tmp0;
    reg_tmp5.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    reg_tmp5.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    reg_tmp5.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    reg_tmp4.x = dot_s(reg_tmp5.xyzz, reg_tmp5.xyzz);
    reg_tmp4.x = rsq_s(reg_tmp4.x);
    reg_tmp4.xyz = (mul_s(reg_tmp5.xyzz, reg_tmp4.xxxx)).xyz;
    reg_tmp4 = mul_s(uniforms.f[94].xxxx, reg_tmp4);
    reg_tmp12 = uniforms.f[94].xxxx + reg_tmp4;
    vs_out_attr4 = reg_tmp12;
    reg_tmp0.xy = (uniforms.f[0].xxxx).xy;
    {
        sub_5();
    }
    reg_tmp4.x = dot_s(uniforms.f[4].xywz, reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5].xywz, reg_tmp6);
    vs_out_attr5 = reg_tmp4;
    vs_out_attr6 = reg_tmp4;
    return true;
}
bool sub_1() {
    reg_tmp7 = uniforms.f[93].xxxx;
    reg_tmp12 = uniforms.f[93].xxxx;
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    {
        sub_2();
    }
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    {
        sub_2();
    }
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    if (conditional_code.x) {
        sub_2();
    }
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    if (conditional_code.y) {
        sub_2();
    }
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    reg_tmp10 = reg_tmp7;
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    return false;
}
bool sub_3() {
    reg_tmp7 = reg_tmp15;
    reg_tmp10.x = dot_s(uniforms.f[10], reg_tmp7);
    reg_tmp10.y = dot_s(uniforms.f[11], reg_tmp7);
    reg_tmp10.z = dot_s(uniforms.f[12], reg_tmp7);
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    reg_tmp12.x = dot_s(uniforms.f[10], reg_tmp14);
    reg_tmp12.y = dot_s(uniforms.f[11], reg_tmp14);
    reg_tmp12.z = dot_s(uniforms.f[12], reg_tmp14);
    return false;
}
bool sub_4() {
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
// reference: C8A7F8CE30A3FAC4, AAA8EB839E9F5CC6
// shader: 8B30, 36A2BF4DC040E4A7
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) + (const_color[0].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].aaa) + (const_color[1].rgb) * (vec3(1.0) - (const_color[1].aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (const_color[2].a) + (const_color[2].r) * (1.0 - (const_color[2].a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((texcolor1.a) * (const_color[3].a) + (texcolor1.r) * (1.0 - (const_color[3].a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = (last_tex_env_out.rgb);
float alpha_output_4 = byteround(clamp((last_tex_env_out.a) * (combiner_buffer.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D3310DE0F23CD476, 36A2BF4DC040E4A7
// program: AAA8EB839E9F5CC6, 0D30074279C2FEED, 36A2BF4DC040E4A7
// reference: 86F3078EB3569CB6, AAA8EB839E9F5CC6
// shader: 8B31, F611EDC1B656F4E7

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;
out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_5();
bool sub_3();
bool sub_1();
bool sub_2();
bool sub_4();
bool sub_6();
bool sub_7();
bool sub_8();
bool sub_14();
bool sub_15();
bool sub_16();
bool sub_17();
bool sub_19();
bool sub_21();
bool sub_22();
bool sub_23();
bool sub_24();
bool sub_25();
bool sub_26();
bool sub_27();
bool sub_28();
bool sub_29();
bool sub_30();
bool sub_31();
bool sub_32();
bool sub_9();
bool sub_10();
bool sub_11();
bool sub_12();
bool sub_13();
bool sub_18();
bool sub_20();
bool sub_0();

bool exec_shader() {
    sub_0();
    return true;
}

bool sub_5() {
    uint jmp_to = 0u;
    while (true) {
        switch (jmp_to) {
        case 0u: {
            reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
            reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
            reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
            reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
            reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
            reg_tmp6.x = rsq_s(reg_tmp6.x);
            reg_tmp7.x = rsq_s(reg_tmp7.x);
            reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            reg_tmp0 = uniforms.f[93].yxxx;
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            reg_tmp4 = mul_s(uniforms.f[94].xxxx, reg_tmp4);
            conditional_code = greaterThanEqual(uniforms.f[93].xx, reg_tmp4.xx);
            reg_tmp4 = vec4(rsq_s(reg_tmp4.x));
            reg_tmp5 = mul_s(uniforms.f[94].xxxx, reg_tmp14);
            if (conditional_code.x) {
                { jmp_to = 18u; break; }
            }
            reg_tmp0.z = rcp_s(reg_tmp4.x);
            reg_tmp0.xy = (mul_s(reg_tmp5, reg_tmp4)).xy;
        }
        case 18u: {
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_3() {
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    reg_tmp4.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_1() {
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    reg_tmp13.xyz = (vs_in_reg2).xyz;
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    if (uniforms.b[0]) {
        sub_2();
    } else {
        sub_4();
    }
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    {
        sub_5();
    }
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    vs_out_attr2 = -reg_tmp15;
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    if (all(conditional_code)) {
        sub_6();
    }
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_2() {
    reg_tmp7 = uniforms.f[93].xxxx;
    reg_tmp12 = uniforms.f[93].xxxx;
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    {
        sub_3();
    }
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    {
        sub_3();
    }
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    {
        sub_3();
    }
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    {
        sub_3();
    }
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    reg_tmp10 = reg_tmp7;
    return false;
}
bool sub_4() {
    reg_tmp7 = reg_tmp15;
    reg_tmp10.x = dot_s(uniforms.f[10], reg_tmp7);
    reg_tmp10.y = dot_s(uniforms.f[11], reg_tmp7);
    reg_tmp10.z = dot_s(uniforms.f[12], reg_tmp7);
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    reg_tmp12.x = dot_3(uniforms.f[10].xyz, reg_tmp14.xyz);
    reg_tmp12.y = dot_3(uniforms.f[11].xyz, reg_tmp14.xyz);
    reg_tmp12.z = dot_3(uniforms.f[12].xyz, reg_tmp14.xyz);
    return false;
}
bool sub_6() {
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_7() {
    reg_tmp0.xy = (uniforms.f[0].xxxx).xy;
    if (uniforms.b[2]) {
        sub_8();
    } else {
        sub_14();
    }
    return false;
}
bool sub_8() {
    {
        sub_9();
    }
    reg_tmp3.x = dot_s(uniforms.f[1].xywz, reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2].xywz, reg_tmp6);
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_14() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_15();
    } else {
        sub_16();
    }
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_15() {
    reg_tmp6 = reg_tmp10;
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    reg_tmp3.z = dot_s(uniforms.f[3], reg_tmp6);
    reg_tmp0.xy = (mul_s(uniforms.f[9].xyyy, reg_tmp3.zzzz)).xy;
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_16() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_17();
    } else {
        sub_19();
    }
    return false;
}
bool sub_17() {
    {
        sub_18();
    }
    reg_tmp3.x = dot_3(uniforms.f[1].xyz, reg_tmp6.xyz);
    reg_tmp3.y = dot_3(uniforms.f[2].xyz, reg_tmp6.xyz);
    reg_tmp3.z = dot_3(uniforms.f[3].xyz, reg_tmp6.xyz);
    return false;
}
bool sub_19() {
    {
        sub_20();
    }
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    return false;
}
bool sub_21() {
    reg_tmp0.xy = (uniforms.f[0].yyyy).xy;
    if (uniforms.b[3]) {
        sub_22();
    } else {
        sub_23();
    }
    return false;
}
bool sub_22() {
    {
        sub_9();
    }
    reg_tmp4.x = dot_s(uniforms.f[4].xywz, reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5].xywz, reg_tmp6);
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_23() {
    if (uniforms.b[5]) {
        sub_24();
    } else {
        sub_27();
    }
    return false;
}
bool sub_24() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_25();
    } else {
        sub_26();
    }
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_25() {
    reg_tmp6 = reg_tmp10;
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    reg_tmp4.z = dot_s(uniforms.f[6], reg_tmp6);
    reg_tmp6.w = rcp_s(reg_tmp4.z);
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    reg_tmp4.xy = (uniforms.f[9].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_26() {
    {
        sub_20();
    }
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    return false;
}
bool sub_27() {
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_28() {
    reg_tmp0.xy = (uniforms.f[0].zzzz).xy;
    if (uniforms.b[4]) {
        sub_29();
    } else {
        sub_30();
    }
    return false;
}
bool sub_29() {
    {
        sub_9();
    }
    reg_tmp5.x = dot_s(uniforms.f[7].xywz, reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8].xywz, reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_30() {
    if (uniforms.b[6]) {
        sub_31();
    } else {
        sub_32();
    }
    return false;
}
bool sub_31() {
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    {
        sub_20();
    }
    reg_tmp5.x = dot_s(uniforms.f[7], reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8], reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_32() {
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
bool sub_9() {
    conditional_code = equal(uniforms.f[93].yz, reg_tmp0.xy);
    if (all(not(conditional_code))) {
        sub_10();
    } else {
        sub_11();
    }
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_10() {
    reg_tmp6.xy = (vs_in_reg4.xyyy).xy;
    return false;
}
bool sub_11() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_12();
    } else {
        sub_13();
    }
    return false;
}
bool sub_12() {
    reg_tmp6.xy = (vs_in_reg5.xyyy).xy;
    return false;
}
bool sub_13() {
    reg_tmp6.xy = (vs_in_reg6.xyyy).xy;
    return false;
}
bool sub_18() {
    reg_tmp2 = -reg_tmp15;
    reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
    reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_20() {
    reg_tmp1 = reg_tmp14;
    reg_tmp2.w = dot_3(reg_tmp1.xyz, reg_tmp1.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp1 = mul_s(reg_tmp1, reg_tmp2.wwww);
    reg_tmp1 = mul_s(uniforms.f[94].xxxx, reg_tmp1);
    reg_tmp6.xy = (uniforms.f[94].xxxx + reg_tmp1.xyyy).xy;
    return false;
}
bool sub_0() {
    {
        sub_1();
    }
    reg_tmp2 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
    reg_tmp1.xyz = (uniforms.f[93].xxyx).xyz;
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    reg_tmp14.w = (uniforms.f[93].xxxx).w;
    reg_tmp8 = reg_tmp14;
    reg_tmp14.x = dot_s(reg_tmp8, reg_tmp8);
    reg_tmp14.x = rsq_s(reg_tmp14.x);
    reg_tmp14 = mul_s(reg_tmp8, reg_tmp14.xxxx);
    reg_tmp9.x = dot_3(reg_tmp14.xyz, reg_tmp1.xyz);
    reg_tmp9.x = (max(uniforms.f[93].xxxx, reg_tmp9.xxxx)).x;
    reg_tmp9.x = (min(uniforms.f[93].yyyy, reg_tmp9.xxxx)).x;
    reg_tmp9.x = (uniforms.f[93].yyyy + -reg_tmp9.xxxx).x;
    reg_tmp9.x = log2(reg_tmp9.x);
    reg_tmp9.x = (mul_s(uniforms.f[82].xxxx, reg_tmp9.xxxx)).x;
    reg_tmp9.x = exp2(reg_tmp9.x);
    reg_tmp2.w = (mul_s(uniforms.f[82].yyyy, reg_tmp9.xxxx)).w;
    vs_out_attr3 = reg_tmp2;
    {
        sub_7();
    }
    {
        sub_21();
    }
    {
        sub_28();
    }
    return true;
}
// reference: 188084E6CB157031, F611EDC1B656F4E7
// shader: 8B30, C7969C7985C3CB70
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(light_vector, normal)));
refl_value.g = (lut_scale_rg * LookupLightingLUTSigned(5, dot(light_vector, normal)));
refl_value.b = (lut_scale_rb * LookupLightingLUTSigned(4, dot(light_vector, normal)));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (secondary_fragment_color.r);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (texcolor0.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((secondary_fragment_color.ggg) * (last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) + (texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 5000F68D161C7DA9, C7969C7985C3CB70
// program: F611EDC1B656F4E7, 0D30074279C2FEED, C7969C7985C3CB70
// reference: 56D47BA648E01643, F611EDC1B656F4E7
// shader: 8B31, BEC1B215F99385B9

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;
out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_13();
bool sub_6();
bool sub_11();
bool sub_4();
bool sub_9();
bool sub_10();
bool sub_12();
bool sub_14();
bool sub_2();
bool sub_3();
bool sub_5();
bool sub_7();
bool sub_17();
bool sub_18();
bool sub_24();
bool sub_25();
bool sub_26();
bool sub_27();
bool sub_29();
bool sub_31();
bool sub_32();
bool sub_33();
bool sub_34();
bool sub_35();
bool sub_36();
bool sub_37();
bool sub_38();
bool sub_39();
bool sub_40();
bool sub_41();
bool sub_42();
bool sub_19();
bool sub_20();
bool sub_21();
bool sub_22();
bool sub_23();
bool sub_28();
bool sub_30();
bool sub_0();
bool sub_1();
bool sub_8();
bool sub_15();
bool sub_16();

bool exec_shader() {
    sub_0();
    return true;
}

bool sub_13() {
    uint jmp_to = 0u;
    while (true) {
        switch (jmp_to) {
        case 0u: {
            reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
            reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
            reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
            reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
            reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
            reg_tmp6.x = rsq_s(reg_tmp6.x);
            reg_tmp7.x = rsq_s(reg_tmp7.x);
            reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            reg_tmp0 = uniforms.f[93].yxxx;
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            reg_tmp4 = mul_s(uniforms.f[94].xxxx, reg_tmp4);
            conditional_code = greaterThanEqual(uniforms.f[93].xx, reg_tmp4.xx);
            reg_tmp4 = vec4(rsq_s(reg_tmp4.x));
            reg_tmp5 = mul_s(uniforms.f[94].xxxx, reg_tmp14);
            if (conditional_code.x) {
                { jmp_to = 18u; break; }
            }
            reg_tmp0.z = rcp_s(reg_tmp4.x);
            reg_tmp0.xy = (mul_s(reg_tmp5, reg_tmp4)).xy;
        }
        case 18u: {
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_6() {
    uint jmp_to = 19u;
    while (true) {
        switch (jmp_to) {
        case 19u: {
            reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
            reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
            reg_tmp6.x = rsq_s(reg_tmp6.x);
            reg_tmp7.x = rsq_s(reg_tmp7.x);
            reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            reg_tmp13.xyz = (mul_s(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            reg_tmp11.xyz = (mul_s(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            reg_tmp0 = uniforms.f[93].yxxx;
            reg_tmp13.xyz = (mul_s(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            reg_tmp11.xyz = (mul_s(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            reg_tmp5 = mul_s(reg_tmp14.yzxx, reg_tmp13.zxyy);
            reg_tmp5 = fma_s(-reg_tmp13.yzxx, reg_tmp14.zxyy, reg_tmp5);
            reg_tmp5.w = dot_3(reg_tmp5.xyz, reg_tmp5.xyz);
            reg_tmp5.w = rsq_s(reg_tmp5.w);
            reg_tmp5 = mul_s(reg_tmp5, reg_tmp5.wwww);
            reg_tmp6.w = (reg_tmp14.zzzz + reg_tmp5.yyyy).w;
            reg_tmp13 = mul_s(reg_tmp5.yzxx, reg_tmp14.zxyy);
            reg_tmp13 = fma_s(-reg_tmp14.yzxx, reg_tmp5.zxyy, reg_tmp13);
            reg_tmp6.w = (reg_tmp13.xxxx + reg_tmp6).w;
            reg_tmp13.w = (reg_tmp5.zzzz).w;
            reg_tmp5.z = (reg_tmp13.xxxx).z;
            reg_tmp6.w = (uniforms.f[93].yyyy + reg_tmp6).w;
            reg_tmp14.w = (reg_tmp5.xxxx).w;
            reg_tmp5.x = (reg_tmp14.zzzz).x;
            conditional_code = lessThan(uniforms.f[94].zz, reg_tmp6.ww);
            reg_tmp6.x = (uniforms.f[93].yyyy).x;
            reg_tmp6.y = (-uniforms.f[93].yyyy).y;
            if (!conditional_code.x) {
                { jmp_to = 54u; break; }
            }
            reg_tmp7.xz = (reg_tmp13.wwyy + -reg_tmp14.yyww).xz;
            reg_tmp7.y = (reg_tmp14.xxxx + -reg_tmp13.zzzz).y;
            reg_tmp7.w = (reg_tmp6).w;
            reg_tmp6 = vec4(dot_s(reg_tmp7, reg_tmp7));
            reg_tmp6 = vec4(rsq_s(reg_tmp6.x));
            reg_tmp0 = mul_s(reg_tmp7, reg_tmp6);
        }
        case 54u: {
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_11() {
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    reg_tmp4.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_4() {
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    reg_tmp4.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp5.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp13.xyz);
    reg_tmp5.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp13.xyz);
    reg_tmp5.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp13.xyz);
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    reg_tmp11 = fma_s(reg_tmp1.wwww, reg_tmp5, reg_tmp11);
    return false;
}
bool sub_9() {
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    reg_tmp13.xyz = (vs_in_reg2).xyz;
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    if (uniforms.b[0]) {
        sub_10();
    } else {
        sub_12();
    }
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    {
        sub_13();
    }
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    vs_out_attr2 = -reg_tmp15;
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    if (all(conditional_code)) {
        sub_14();
    }
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_10() {
    reg_tmp7 = uniforms.f[93].xxxx;
    reg_tmp12 = uniforms.f[93].xxxx;
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    {
        sub_11();
    }
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    {
        sub_11();
    }
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    {
        sub_11();
    }
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    {
        sub_11();
    }
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    reg_tmp10 = reg_tmp7;
    return false;
}
bool sub_12() {
    reg_tmp7 = reg_tmp15;
    reg_tmp10.x = dot_s(uniforms.f[10], reg_tmp7);
    reg_tmp10.y = dot_s(uniforms.f[11], reg_tmp7);
    reg_tmp10.z = dot_s(uniforms.f[12], reg_tmp7);
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    reg_tmp12.x = dot_3(uniforms.f[10].xyz, reg_tmp14.xyz);
    reg_tmp12.y = dot_3(uniforms.f[11].xyz, reg_tmp14.xyz);
    reg_tmp12.z = dot_3(uniforms.f[12].xyz, reg_tmp14.xyz);
    return false;
}
bool sub_14() {
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_2() {
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    reg_tmp13.xyz = (vs_in_reg2).xyz;
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    if (uniforms.b[0]) {
        sub_3();
    } else {
        sub_5();
    }
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    reg_tmp13.x = dot_3(uniforms.f[90].xyz, reg_tmp11.xyz);
    reg_tmp13.y = dot_3(uniforms.f[91].xyz, reg_tmp11.xyz);
    reg_tmp13.z = dot_3(uniforms.f[92].xyz, reg_tmp11.xyz);
    {
        sub_6();
    }
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    vs_out_attr2 = -reg_tmp15;
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    if (all(conditional_code)) {
        sub_7();
    }
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_3() {
    reg_tmp7 = uniforms.f[93].xxxx;
    reg_tmp12 = uniforms.f[93].xxxx;
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    {
        sub_4();
    }
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    {
        sub_4();
    }
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    {
        sub_4();
    }
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    {
        sub_4();
    }
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    reg_tmp10 = reg_tmp7;
    return false;
}
bool sub_5() {
    reg_tmp7 = reg_tmp15;
    reg_tmp10.x = dot_s(uniforms.f[10], reg_tmp7);
    reg_tmp10.y = dot_s(uniforms.f[11], reg_tmp7);
    reg_tmp10.z = dot_s(uniforms.f[12], reg_tmp7);
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    reg_tmp12.x = dot_3(uniforms.f[10].xyz, reg_tmp14.xyz);
    reg_tmp12.y = dot_3(uniforms.f[11].xyz, reg_tmp14.xyz);
    reg_tmp12.z = dot_3(uniforms.f[12].xyz, reg_tmp14.xyz);
    reg_tmp11.x = dot_3(uniforms.f[10].xyz, reg_tmp13.xyz);
    reg_tmp11.y = dot_3(uniforms.f[11].xyz, reg_tmp13.xyz);
    reg_tmp11.z = dot_3(uniforms.f[12].xyz, reg_tmp13.xyz);
    return false;
}
bool sub_7() {
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_17() {
    reg_tmp0.xy = (uniforms.f[0].xxxx).xy;
    if (uniforms.b[2]) {
        sub_18();
    } else {
        sub_24();
    }
    return false;
}
bool sub_18() {
    {
        sub_19();
    }
    reg_tmp3.x = dot_s(uniforms.f[1].xywz, reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2].xywz, reg_tmp6);
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_24() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_25();
    } else {
        sub_26();
    }
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_25() {
    reg_tmp6 = reg_tmp10;
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    reg_tmp3.z = dot_s(uniforms.f[3], reg_tmp6);
    reg_tmp0.xy = (mul_s(uniforms.f[9].xyyy, reg_tmp3.zzzz)).xy;
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_26() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_27();
    } else {
        sub_29();
    }
    return false;
}
bool sub_27() {
    {
        sub_28();
    }
    reg_tmp3.x = dot_3(uniforms.f[1].xyz, reg_tmp6.xyz);
    reg_tmp3.y = dot_3(uniforms.f[2].xyz, reg_tmp6.xyz);
    reg_tmp3.z = dot_3(uniforms.f[3].xyz, reg_tmp6.xyz);
    return false;
}
bool sub_29() {
    {
        sub_30();
    }
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    return false;
}
bool sub_31() {
    reg_tmp0.xy = (uniforms.f[0].yyyy).xy;
    if (uniforms.b[3]) {
        sub_32();
    } else {
        sub_33();
    }
    return false;
}
bool sub_32() {
    {
        sub_19();
    }
    reg_tmp4.x = dot_s(uniforms.f[4].xywz, reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5].xywz, reg_tmp6);
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_33() {
    if (uniforms.b[5]) {
        sub_34();
    } else {
        sub_37();
    }
    return false;
}
bool sub_34() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_35();
    } else {
        sub_36();
    }
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_35() {
    reg_tmp6 = reg_tmp10;
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    reg_tmp4.z = dot_s(uniforms.f[6], reg_tmp6);
    reg_tmp6.w = rcp_s(reg_tmp4.z);
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    reg_tmp4.xy = (uniforms.f[9].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_36() {
    {
        sub_30();
    }
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    return false;
}
bool sub_37() {
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_38() {
    reg_tmp0.xy = (uniforms.f[0].zzzz).xy;
    if (uniforms.b[4]) {
        sub_39();
    } else {
        sub_40();
    }
    return false;
}
bool sub_39() {
    {
        sub_19();
    }
    reg_tmp5.x = dot_s(uniforms.f[7].xywz, reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8].xywz, reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_40() {
    if (uniforms.b[6]) {
        sub_41();
    } else {
        sub_42();
    }
    return false;
}
bool sub_41() {
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    {
        sub_30();
    }
    reg_tmp5.x = dot_s(uniforms.f[7], reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8], reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_42() {
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
bool sub_19() {
    conditional_code = equal(uniforms.f[93].yz, reg_tmp0.xy);
    if (all(not(conditional_code))) {
        sub_20();
    } else {
        sub_21();
    }
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_20() {
    reg_tmp6.xy = (vs_in_reg4.xyyy).xy;
    return false;
}
bool sub_21() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_22();
    } else {
        sub_23();
    }
    return false;
}
bool sub_22() {
    reg_tmp6.xy = (vs_in_reg5.xyyy).xy;
    return false;
}
bool sub_23() {
    reg_tmp6.xy = (vs_in_reg6.xyyy).xy;
    return false;
}
bool sub_28() {
    reg_tmp2 = -reg_tmp15;
    reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
    reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_30() {
    reg_tmp1 = reg_tmp14;
    reg_tmp2.w = dot_3(reg_tmp1.xyz, reg_tmp1.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp1 = mul_s(reg_tmp1, reg_tmp2.wwww);
    reg_tmp1 = mul_s(uniforms.f[94].xxxx, reg_tmp1);
    reg_tmp6.xy = (uniforms.f[94].xxxx + reg_tmp1.xyyy).xy;
    return false;
}
bool sub_0() {
    if (uniforms.b[10]) {
        sub_1();
    } else {
        sub_8();
    }
    if (uniforms.b[1]) {
        sub_15();
    } else {
        sub_16();
    }
    vs_out_attr3 = reg_tmp2;
    {
        sub_17();
    }
    {
        sub_31();
    }
    {
        sub_38();
    }
    return true;
}
bool sub_1() {
    {
        sub_2();
    }
    return false;
}
bool sub_8() {
    {
        sub_9();
    }
    return false;
}
bool sub_15() {
    reg_tmp0 = vec4(dot_3(uniforms.f[83].xyz, reg_tmp12.xyz));
    reg_tmp0 = max(uniforms.f[93].xxxx, reg_tmp0);
    reg_tmp0 = mul_s(uniforms.f[84], reg_tmp0);
    reg_tmp0 = uniforms.f[85] + reg_tmp0;
    reg_tmp0.w = (uniforms.f[93].yyyy).w;
    reg_tmp1 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
    reg_tmp2 = mul_s(reg_tmp0, reg_tmp1);
    return false;
}
bool sub_16() {
    reg_tmp2 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
    return false;
}
// reference: 59C745238199894B, BEC1B215F99385B9
// shader: 8B30, 6393144EC6B7C460
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor1.aaa) * (texcolor1.aaa), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (rounded_primary_color.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.aaa), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) + (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: FBEC36122394C1DC, 6393144EC6B7C460
// program: BEC1B215F99385B9, 0D30074279C2FEED, 6393144EC6B7C460
// reference: 1793BA63026CEF39, BEC1B215F99385B9
// shader: 8B30, 71260FB838A09A82
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 2C801EA34245A1AF, 71260FB838A09A82
// program: BEC1B215F99385B9, 0D30074279C2FEED, 71260FB838A09A82
// shader: 8B30, 184C7DC1D30B7FEA
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (texcolor1.rgb) + (texcolor2.rgb) * (vec3(1.0) - (texcolor1.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 88F70EAB2A0DD9B5, 184C7DC1D30B7FEA
// program: BEC1B215F99385B9, 0D30074279C2FEED, 184C7DC1D30B7FEA
// shader: 8B30, 8EEA50D59BE2263A
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 186E808133587B0D, 8EEA50D59BE2263A
// program: BEC1B215F99385B9, 0D30074279C2FEED, 8EEA50D59BE2263A
// shader: 8B30, C59FB987FA81F0B3
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor1.g) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (texcolor1.rrr) + (const_color[2].rgb) * (vec3(1.0) - (texcolor1.rrr)), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 4CD3A9AD9C30D273, C59FB987FA81F0B3
// program: BEC1B215F99385B9, 0D30074279C2FEED, C59FB987FA81F0B3
// shader: 8B30, 0DA2D889D2CD465D
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 7F018AB24245A1AF, 0DA2D889D2CD465D
// program: BEC1B215F99385B9, 0D30074279C2FEED, 0DA2D889D2CD465D
// reference: 7F018AB28F755D75, 0DA2D889D2CD465D
// shader: 8B30, 046E44E355D9C09A
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp(min((texcolor0.rgb) + (texcolor1.rgb), vec3(1.0)) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 28B6C1BB0A3D7126, 046E44E355D9C09A
// program: BEC1B215F99385B9, 0D30074279C2FEED, 046E44E355D9C09A
// shader: 8B30, 107C23D73DF4B2BF
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.aaa) + (texcolor1.rgb) * (vec3(1.0) - (rounded_primary_color.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 79E27667AB6B9A91, 107C23D73DF4B2BF
// program: BEC1B215F99385B9, 0D30074279C2FEED, 107C23D73DF4B2BF
// shader: 8B30, ED074CA328E24A7B
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp(min((texcolor0.rgb) + (texcolor1.rgb), vec3(1.0)) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 28B6C1BBE68A9A25, ED074CA328E24A7B
// program: BEC1B215F99385B9, 0D30074279C2FEED, ED074CA328E24A7B
// shader: 8B30, 7BE2A077F32A3F69
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.aaa) + (texcolor1.rgb) * (vec3(1.0) - (rounded_primary_color.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_1 = byteround(clamp((texcolor1.aaa) * (texcolor2.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (last_tex_env_out.rrr) + (combiner_buffer.rgb) * (vec3(1.0) - (last_tex_env_out.rrr)), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb) * (combiner_buffer.ggg) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.ggg)), vec3(0.0), vec3(1.0)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 28303F0DA914F330, 7BE2A077F32A3F69
// program: BEC1B215F99385B9, 0D30074279C2FEED, 7BE2A077F32A3F69
// shader: 8B30, AF4EE6C536ED3E7A
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(normal, normalize(half_vector))));
refl_value.g = (lut_scale_rg * LookupLightingLUTSigned(5, dot(normal, normalize(view))));
refl_value.b = (lut_scale_rb * LookupLightingLUTSigned(4, dot(normal, normalize(half_vector))));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) + (secondary_fragment_color.ggg), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D26D4A8A38E4BAF9, AF4EE6C536ED3E7A
// program: BEC1B215F99385B9, 0D30074279C2FEED, AF4EE6C536ED3E7A
// shader: 8B30, BF769EFD399154AD
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(normal, normalize(view))));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (texcolor2.aaa) + (texcolor1.rgb) * (vec3(1.0) - (texcolor2.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (secondary_fragment_color.rrr) + (last_tex_env_out.rgb) * (vec3(1.0) - (secondary_fragment_color.rrr)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 447469C623185624, BF769EFD399154AD
// program: BEC1B215F99385B9, 0D30074279C2FEED, BF769EFD399154AD
// shader: 8B30, 7CB7D5CAEB400D5B
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(normal, normalize(view))));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.aaa) + (texcolor1.rgb) * (vec3(1.0) - (rounded_primary_color.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (secondary_fragment_color.rrr) + (last_tex_env_out.rgb) * (vec3(1.0) - (secondary_fragment_color.rrr)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: BBA477028CBAA9A3, 7CB7D5CAEB400D5B
// program: BEC1B215F99385B9, 0D30074279C2FEED, 7CB7D5CAEB400D5B
// shader: 8B30, E34D1DA909F9ABA3
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(normal, normalize(view))));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb) * (secondary_fragment_color.rrr) + (texcolor1.rgb) * (vec3(1.0) - (secondary_fragment_color.rrr)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_1 = (texcolor0.rgb);
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor0.rgb) * (texcolor2.aaa) + (combiner_buffer.rgb) * (vec3(1.0) - (texcolor2.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) * (texcolor2.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D03CA6A18F5B2684, E34D1DA909F9ABA3
// program: BEC1B215F99385B9, 0D30074279C2FEED, E34D1DA909F9ABA3
// shader: 8B31, A2A90E8B8AD1B11E

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;
out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_5();
bool sub_3();
bool sub_1();
bool sub_2();
bool sub_4();
bool sub_6();
bool sub_9();
bool sub_10();
bool sub_16();
bool sub_17();
bool sub_18();
bool sub_19();
bool sub_21();
bool sub_23();
bool sub_24();
bool sub_25();
bool sub_26();
bool sub_27();
bool sub_28();
bool sub_29();
bool sub_30();
bool sub_31();
bool sub_32();
bool sub_33();
bool sub_34();
bool sub_11();
bool sub_12();
bool sub_13();
bool sub_14();
bool sub_15();
bool sub_20();
bool sub_22();
bool sub_0();
bool sub_7();
bool sub_8();

bool exec_shader() {
    sub_0();
    return true;
}

bool sub_5() {
    uint jmp_to = 0u;
    while (true) {
        switch (jmp_to) {
        case 0u: {
            reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
            reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
            reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
            reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
            reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
            reg_tmp6.x = rsq_s(reg_tmp6.x);
            reg_tmp7.x = rsq_s(reg_tmp7.x);
            reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            reg_tmp0 = uniforms.f[93].yxxx;
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            reg_tmp4 = mul_s(uniforms.f[94].xxxx, reg_tmp4);
            conditional_code = greaterThanEqual(uniforms.f[93].xx, reg_tmp4.xx);
            reg_tmp4 = vec4(rsq_s(reg_tmp4.x));
            reg_tmp5 = mul_s(uniforms.f[94].xxxx, reg_tmp14);
            if (conditional_code.x) {
                { jmp_to = 18u; break; }
            }
            reg_tmp0.z = rcp_s(reg_tmp4.x);
            reg_tmp0.xy = (mul_s(reg_tmp5, reg_tmp4)).xy;
        }
        case 18u: {
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_3() {
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    reg_tmp4.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_1() {
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    if (uniforms.b[0]) {
        sub_2();
    } else {
        sub_4();
    }
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    {
        sub_5();
    }
    vs_out_attr2 = -reg_tmp15;
    reg_tmp0.x = (uniforms.f[93].yyyy).x;
    address_registers.x = (ivec2(vs_in_reg3.xx)).x;
    reg_tmp0.x = (mul_s(uniforms.f[13 + address_registers.x].xxxx, reg_tmp0.xxxx)).x;
    address_registers.x = (ivec2(vs_in_reg3.yy)).x;
    reg_tmp0.x = (mul_s(uniforms.f[13 + address_registers.x].yyyy, reg_tmp0.xxxx)).x;
    address_registers.x = (ivec2(vs_in_reg3.zz)).x;
    reg_tmp0.x = (mul_s(uniforms.f[13 + address_registers.x].zzzz, reg_tmp0.xxxx)).x;
    address_registers.x = (ivec2(vs_in_reg3.ww)).x;
    reg_tmp0.x = (mul_s(uniforms.f[13 + address_registers.x].wwww, reg_tmp0.xxxx)).x;
    reg_tmp15.xyz = (mul_s(reg_tmp15.xyzz, reg_tmp0.xxxx)).xyz;
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    if (all(conditional_code)) {
        sub_6();
    }
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_2() {
    reg_tmp7 = uniforms.f[93].xxxx;
    reg_tmp12 = uniforms.f[93].xxxx;
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    {
        sub_3();
    }
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    {
        sub_3();
    }
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    {
        sub_3();
    }
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    {
        sub_3();
    }
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    reg_tmp10 = reg_tmp7;
    return false;
}
bool sub_4() {
    reg_tmp7 = reg_tmp15;
    reg_tmp10.x = dot_s(uniforms.f[10], reg_tmp7);
    reg_tmp10.y = dot_s(uniforms.f[11], reg_tmp7);
    reg_tmp10.z = dot_s(uniforms.f[12], reg_tmp7);
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    reg_tmp12.x = dot_3(uniforms.f[10].xyz, reg_tmp14.xyz);
    reg_tmp12.y = dot_3(uniforms.f[11].xyz, reg_tmp14.xyz);
    reg_tmp12.z = dot_3(uniforms.f[12].xyz, reg_tmp14.xyz);
    return false;
}
bool sub_6() {
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_9() {
    reg_tmp0.xy = (uniforms.f[0].xxxx).xy;
    if (uniforms.b[2]) {
        sub_10();
    } else {
        sub_16();
    }
    return false;
}
bool sub_10() {
    {
        sub_11();
    }
    reg_tmp3.x = dot_s(uniforms.f[1].xywz, reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2].xywz, reg_tmp6);
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_16() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_17();
    } else {
        sub_18();
    }
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_17() {
    reg_tmp6 = reg_tmp10;
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    reg_tmp3.z = dot_s(uniforms.f[3], reg_tmp6);
    reg_tmp0.xy = (mul_s(uniforms.f[9].xyyy, reg_tmp3.zzzz)).xy;
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_18() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_19();
    } else {
        sub_21();
    }
    return false;
}
bool sub_19() {
    {
        sub_20();
    }
    reg_tmp3.x = dot_3(uniforms.f[1].xyz, reg_tmp6.xyz);
    reg_tmp3.y = dot_3(uniforms.f[2].xyz, reg_tmp6.xyz);
    reg_tmp3.z = dot_3(uniforms.f[3].xyz, reg_tmp6.xyz);
    return false;
}
bool sub_21() {
    {
        sub_22();
    }
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    return false;
}
bool sub_23() {
    reg_tmp0.xy = (uniforms.f[0].yyyy).xy;
    if (uniforms.b[3]) {
        sub_24();
    } else {
        sub_25();
    }
    return false;
}
bool sub_24() {
    {
        sub_11();
    }
    reg_tmp4.x = dot_s(uniforms.f[4].xywz, reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5].xywz, reg_tmp6);
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_25() {
    if (uniforms.b[5]) {
        sub_26();
    } else {
        sub_29();
    }
    return false;
}
bool sub_26() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_27();
    } else {
        sub_28();
    }
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_27() {
    reg_tmp6 = reg_tmp10;
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    reg_tmp4.z = dot_s(uniforms.f[6], reg_tmp6);
    reg_tmp6.w = rcp_s(reg_tmp4.z);
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    reg_tmp4.xy = (uniforms.f[9].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_28() {
    {
        sub_22();
    }
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    return false;
}
bool sub_29() {
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_30() {
    reg_tmp0.xy = (uniforms.f[0].zzzz).xy;
    if (uniforms.b[4]) {
        sub_31();
    } else {
        sub_32();
    }
    return false;
}
bool sub_31() {
    {
        sub_11();
    }
    reg_tmp5.x = dot_s(uniforms.f[7].xywz, reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8].xywz, reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_32() {
    if (uniforms.b[6]) {
        sub_33();
    } else {
        sub_34();
    }
    return false;
}
bool sub_33() {
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    {
        sub_22();
    }
    reg_tmp5.x = dot_s(uniforms.f[7], reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8], reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_34() {
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
bool sub_11() {
    conditional_code = equal(uniforms.f[93].yz, reg_tmp0.xy);
    if (all(not(conditional_code))) {
        sub_12();
    } else {
        sub_13();
    }
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_12() {
    reg_tmp6.xy = (vs_in_reg4.xyyy).xy;
    return false;
}
bool sub_13() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_14();
    } else {
        sub_15();
    }
    return false;
}
bool sub_14() {
    reg_tmp6.xy = (vs_in_reg5.xyyy).xy;
    return false;
}
bool sub_15() {
    reg_tmp6.xy = (vs_in_reg6.xyyy).xy;
    return false;
}
bool sub_20() {
    reg_tmp2 = -reg_tmp15;
    reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
    reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_22() {
    reg_tmp1 = reg_tmp14;
    reg_tmp2.w = dot_3(reg_tmp1.xyz, reg_tmp1.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp1 = mul_s(reg_tmp1, reg_tmp2.wwww);
    reg_tmp1 = mul_s(uniforms.f[94].xxxx, reg_tmp1);
    reg_tmp6.xy = (uniforms.f[94].xxxx + reg_tmp1.xyyy).xy;
    return false;
}
bool sub_0() {
    {
        sub_1();
    }
    if (uniforms.b[1]) {
        sub_7();
    } else {
        sub_8();
    }
    vs_out_attr3 = reg_tmp2;
    {
        sub_9();
    }
    {
        sub_23();
    }
    {
        sub_30();
    }
    return true;
}
bool sub_7() {
    reg_tmp0 = vec4(dot_3(uniforms.f[83].xyz, reg_tmp12.xyz));
    reg_tmp0 = max(uniforms.f[93].xxxx, reg_tmp0);
    reg_tmp0 = mul_s(uniforms.f[84], reg_tmp0);
    reg_tmp0 = uniforms.f[85] + reg_tmp0;
    reg_tmp0.w = (uniforms.f[93].yyyy).w;
    reg_tmp1 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
    reg_tmp2 = mul_s(reg_tmp0, reg_tmp1);
    return false;
}
bool sub_8() {
    reg_tmp2 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
    return false;
}
// reference: EEA9CDB0AADB8844, A2A90E8B8AD1B11E
// shader: 8B30, B2EFC65400C167E0
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor1.r);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 90CF07C19129C1FB, B2EFC65400C167E0
// program: A2A90E8B8AD1B11E, 0D30074279C2FEED, B2EFC65400C167E0
// shader: 8B30, BBD49FD48F367AAB
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(normal, normalize(view))));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb) * (secondary_fragment_color.rrr) + (texcolor1.rgb) * (vec3(1.0) - (secondary_fragment_color.rrr)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_1 = (texcolor0.rgb);
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor0.rgb) * (texcolor2.aaa) + (combiner_buffer.rgb) * (vec3(1.0) - (texcolor2.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) * (texcolor2.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D03CA6A163ECCD87, BBD49FD48F367AAB
// program: BEC1B215F99385B9, 0D30074279C2FEED, BBD49FD48F367AAB
// shader: 8B30, 98D162841361BB8B
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.aaa) + (texcolor1.rgb) * (vec3(1.0) - (rounded_primary_color.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 9DF0A67F2437D1FB, 98D162841361BB8B
// program: BEC1B215F99385B9, 0D30074279C2FEED, 98D162841361BB8B
// shader: 8B30, 48DDD5B538722E22
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (texcolor2.aaa) + (texcolor1.rgb) * (vec3(1.0) - (texcolor2.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (texcolor2.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 64BFB8231EF36FDE, 48DDD5B538722E22
// program: BEC1B215F99385B9, 0D30074279C2FEED, 48DDD5B538722E22
// shader: 8B30, 80EECFD6EBD016F2
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp(min((texcolor0.rgb) + (texcolor1.rgb), vec3(1.0)) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D82C9517C77B4F94, 80EECFD6EBD016F2
// program: BEC1B215F99385B9, 0D30074279C2FEED, 80EECFD6EBD016F2
// shader: 8B30, F96BC818C62F763A
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (texcolor2.aaa) + (texcolor1.rgb) * (vec3(1.0) - (texcolor2.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 79E276679FA91F25, F96BC818C62F763A
// program: BEC1B215F99385B9, 0D30074279C2FEED, F96BC818C62F763A
// shader: 8B30, 4C53D7BC7E6EE80B
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.aaa) + (texcolor1.rgb) * (vec3(1.0) - (rounded_primary_color.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (texcolor2.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 80AD683BDCD29352, 4C53D7BC7E6EE80B
// program: BEC1B215F99385B9, 0D30074279C2FEED, 4C53D7BC7E6EE80B
// shader: 8B30, 3657CCE31A12BD76
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (texcolor2.aaa) + (texcolor1.rgb) * (vec3(1.0) - (texcolor2.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (texcolor2.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 64BFB823F24484DD, 3657CCE31A12BD76
// program: BEC1B215F99385B9, 0D30074279C2FEED, 3657CCE31A12BD76
// shader: 8B30, 34C8F36A1F3B6C76
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(normal, normalize(view))));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (texcolor2.aaa) + (texcolor1.rgb) * (vec3(1.0) - (texcolor2.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (secondary_fragment_color.rrr) + (last_tex_env_out.rgb) * (vec3(1.0) - (secondary_fragment_color.rrr)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 447469C6CFAFBD27, 34C8F36A1F3B6C76
// program: BEC1B215F99385B9, 0D30074279C2FEED, 34C8F36A1F3B6C76
// shader: 8B30, 3D9AAC4EFAF520AB
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) + (texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 8DB79618EF6F0D75, 3D9AAC4EFAF520AB
// program: BEC1B215F99385B9, 0D30074279C2FEED, 3D9AAC4EFAF520AB
// shader: 8B30, 55A2B9A481178DDA
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp(min((texcolor0.rgb) + (texcolor1.rgb), vec3(1.0)) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D82C95172BCCA497, 55A2B9A481178DDA
// program: BEC1B215F99385B9, 0D30074279C2FEED, 55A2B9A481178DDA
// shader: 8B30, A944AF56B0C0C95D
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 79A26A61A6099509, A944AF56B0C0C95D
// program: BEC1B215F99385B9, 0D30074279C2FEED, A944AF56B0C0C95D
// shader: 8B30, 2F521F13578D049A
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb) * (texcolor0.ggg) + (vec3(1.0) - texcolor1.aaa) * (vec3(1.0) - (texcolor0.ggg)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (rounded_primary_color.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (texcolor0.rrr) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor0.rrr)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (texcolor0.bbb) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor0.bbb)), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rrr) + (texcolor2.rgb) * (vec3(1.0) - (primary_fragment_color.rrr)), vec3(0.0), vec3(1.0)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) + (texcolor1.rgb) - vec3(0.5), vec3(0.0), vec3(1.0)));
float alpha_output_4 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 4B90C6E2FDE11654, 2F521F13578D049A
// program: BEC1B215F99385B9, 0D30074279C2FEED, 2F521F13578D049A
// shader: 8B30, 39B31CC5B0301580
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = 2.0 * (texcolor2).rgb - 1.0;
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(normal, normalize(view))));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb) + (texcolor0.aaa), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (texcolor1.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0 * 1.0, alpha_output_0 * 2.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = (last_tex_env_out.rgb);
float alpha_output_1 = (1.0 - secondary_fragment_color.r);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a) + (combiner_buffer.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = (last_tex_env_out.rgb);
float alpha_output_5 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D7E8E0CE5473F4A9, 39B31CC5B0301580
// program: BEC1B215F99385B9, 0D30074279C2FEED, 39B31CC5B0301580
// shader: 8B30, 9820C4E77BA40ED2
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((const_color[1].a) * (texcolor1.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((1.0 - combiner_buffer.a) * (last_tex_env_out.a) + (combiner_buffer.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 2901127D29619BF1, 9820C4E77BA40ED2
// program: BEC1B215F99385B9, 0D30074279C2FEED, 9820C4E77BA40ED2
// shader: 8B30, F3A037C6B74B6FEF
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((const_color[1].a) * (texcolor1.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((1.0 - combiner_buffer.a) * (last_tex_env_out.a) + (combiner_buffer.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) < alphatest_ref) discard;
float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 2901127D4E960F87, F3A037C6B74B6FEF
// program: BEC1B215F99385B9, 0D30074279C2FEED, F3A037C6B74B6FEF
// shader: 8B30, DBA6479C0297E10E
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rrr) * (const_color[0].rrr), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor0.ggg) * (const_color[1].ggg) + (last_tex_env_out.rrr), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor0.bbb) * (const_color[2].bbb) + (last_tex_env_out.rrr), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((texcolor0.rgb) * (texcolor1.aaa), vec3(0.0), vec3(1.0)));
float alpha_output_3 = (last_tex_env_out.r);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: C769BC5CA0EADC59, DBA6479C0297E10E
// program: 4FC2B4EDFF8D2FB4, 0D30074279C2FEED, DBA6479C0297E10E
// shader: 8B30, DBB563E4FA66C8E0
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (const_color[1].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) * (const_color[2].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = (last_tex_env_out.r);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 7F53101FAE9E225A, DBB563E4FA66C8E0
// program: 4FC2B4EDFF8D2FB4, 0D30074279C2FEED, DBB563E4FA66C8E0
// reference: D3760A843A2C0878, 4FC2B4EDFF8D2FB4
// shader: 8B30, DE532DB7DA65108D
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (const_color[1].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) * (const_color[2].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 3AC51CBBC13DF401, DE532DB7DA65108D
// program: 7C96EBECB346C618, 1C4CBC8096EA16CD, DE532DB7DA65108D
// shader: 8B30, E333688E7A4E3951
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (const_color[1].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) * (const_color[2].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 3AC51CBB3ADD85B8, E333688E7A4E3951
// program: 7C96EBECB346C618, 1C4CBC8096EA16CD, E333688E7A4E3951
// shader: 8B30, F5405F949ABD9CF4
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) * (const_color[2].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 5BEBE6BBCD5F1A87, F5405F949ABD9CF4
// program: 7C96EBECB346C618, 1C4CBC8096EA16CD, F5405F949ABD9CF4
// shader: 8B30, 52C5102456B41FEE
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) * (const_color[2].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 5BEBE6BBC668E093, 52C5102456B41FEE
// program: 7C96EBECB346C618, 1C4CBC8096EA16CD, 52C5102456B41FEE
// shader: 8B30, 81F7FE3860E5FB33
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].aaa);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) * (const_color[2].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 6B53F9F065C59CBA, 81F7FE3860E5FB33
// program: 7C96EBECB346C618, 1C4CBC8096EA16CD, 81F7FE3860E5FB33
// shader: 8B30, 0B042F8EEE02D2C1
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (texcolor1.r);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
int fog_i = int(fog_index);
float fog_f = fract(fog_index);
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, fog_i + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: A10BA44298400D8A, 0B042F8EEE02D2C1
// program: BEC1B215F99385B9, 0D30074279C2FEED, 0B042F8EEE02D2C1
// shader: 8B30, 9A1CC78472C59443
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (const_color[0].a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D4F4BEF9083F90BA, 9A1CC78472C59443
// program: BEC1B215F99385B9, 0D30074279C2FEED, 9A1CC78472C59443
// reference: 1F78A60766D02152, 2B730240EE2A8461
// reference: 1F78A6079D3050EB, 61C2DBAB611E2111
// shader: 8B30, F437CC0DAF2ECC46
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 9740E06317507773, F437CC0DAF2ECC46
// program: 7C96EBECB346C618, 1C4CBC8096EA16CD, F437CC0DAF2ECC46
// shader: 8B30, 1BC182922368739F
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 9740E0631C678D67, 1BC182922368739F
// program: 7C96EBECB346C618, 1C4CBC8096EA16CD, 1BC182922368739F
// shader: 8B30, 1F5276138FD31E21
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor1.rgb) * (texcolor0.rgb) + (texcolor1.rgb) * (vec3(1.0) - (texcolor0.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.r) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = (last_tex_env_out.rgb);
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (texcolor2.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (const_color[2].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 4813F809EB2BD90D, 1F5276138FD31E21
// program: BEC1B215F99385B9, 0D30074279C2FEED, 1F5276138FD31E21
// shader: 8B30, E14C2D25B88214CA
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = (last_tex_env_out.rgb);
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (texcolor2.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (const_color[2].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 55C660775F93AA9D, E14C2D25B88214CA
// program: 7C96EBECB346C618, 1C4CBC8096EA16CD, E14C2D25B88214CA
// shader: 8B30, 4F5D3D8CAE07D74A
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = (last_tex_env_out.rgb);
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (texcolor2.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (const_color[2].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 55C66077A473DB24, 4F5D3D8CAE07D74A
// program: 7C96EBECB346C618, 1C4CBC8096EA16CD, 4F5D3D8CAE07D74A
// shader: 8B30, 543EDD4084880F4A
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (const_color[2].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 783519FFF0B542F7, 543EDD4084880F4A
// program: 7C96EBECB346C618, 1C4CBC8096EA16CD, 543EDD4084880F4A
// shader: 8B30, 01C79519B7CF99E4
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (const_color[2].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 783519FFFB82B8E3, 01C79519B7CF99E4
// program: 7C96EBECB346C618, 1C4CBC8096EA16CD, 01C79519B7CF99E4
// reference: 59C74523CE118DC9, BEC1B215F99385B9
// shader: 8B30, A8B0E6AADB116311
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) + (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor1.r) + (const_color[0].a) - 0.5, 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) - (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 7F10713B89B30A02, A8B0E6AADB116311
// program: BEC1B215F99385B9, 0D30074279C2FEED, A8B0E6AADB116311
// shader: 8B30, 66D12121A97B66A8
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) - (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 9B69AC991B4FCF91, 66D12121A97B66A8
// program: 7C96EBECB346C618, 1C4CBC8096EA16CD, 66D12121A97B66A8
// shader: 8B30, FE7D3792AF1B69C9
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) - (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 9B69AC99E0AFBE28, FE7D3792AF1B69C9
// program: 7C96EBECB346C618, 1C4CBC8096EA16CD, FE7D3792AF1B69C9
// shader: 8B30, CAF7DC684B0E0EEA
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) + (texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (const_color[0].a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (texcolor2.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = (last_tex_env_out.rgb);
float alpha_output_5 = byteround(clamp((last_tex_env_out.a) * (const_color[5].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 88BE7793AC0D0138, CAF7DC684B0E0EEA
// program: BEC1B215F99385B9, 0D30074279C2FEED, CAF7DC684B0E0EEA
// shader: 8B30, 52807296CDCEF34A
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor1.r) + (texcolor0.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) + (texcolor1.rrr), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (const_color[2].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: B2FF021960ACB158, 52807296CDCEF34A
// program: BEC1B215F99385B9, 0D30074279C2FEED, 52807296CDCEF34A
// shader: 8B30, BE3540B3D7A2029D
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb) * (texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.r) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) + (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 2A7EAF81D974A6D5, BE3540B3D7A2029D
// program: BEC1B215F99385B9, 0D30074279C2FEED, BE3540B3D7A2029D
// reference: 2E99070D93C88DBA, F7CE14589569CE00
// shader: 8B30, EBE52129F4D9ADBD
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 2F8F6701E28F10BC, EBE52129F4D9ADBD
// program: 7C96EBECB346C618, 1C4CBC8096EA16CD, EBE52129F4D9ADBD
// shader: 8B30, 29DBC75E0C056C08
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 2F8F670112589B11, 29DBC75E0C056C08
// program: 7C96EBECB346C618, 1C4CBC8096EA16CD, 29DBC75E0C056C08
// shader: 8B30, 8FAC176B88F21959
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].aaa);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 1F37784AB1F5E738, 8FAC176B88F21959
// program: 7C96EBECB346C618, 1C4CBC8096EA16CD, 8FAC176B88F21959
// reference: C9A148E3F7D5D02D, 6393144EC6B7C460
// shader: 8B30, F865192BFE939ABB
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 1ECD60529604B05E, F865192BFE939ABB
// program: BEC1B215F99385B9, 0D30074279C2FEED, F865192BFE939ABB
// reference: BABA705AFE4CC844, 184C7DC1D30B7FEA
// reference: 2A23FE70E7196AFC, 8EEA50D59BE2263A
// shader: 8B30, E4AD2884C5B04375
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor1.g) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (texcolor1.rrr) + (const_color[2].rgb) * (vec3(1.0) - (texcolor1.rrr)), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 7E9ED75C4871C382, E4AD2884C5B04375
// program: BEC1B215F99385B9, 0D30074279C2FEED, E4AD2884C5B04375
// shader: 8B30, D8044A0C153D159B
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 1080747790D7673D, D8044A0C153D159B
// program: BEC1B215F99385B9, 0D30074279C2FEED, D8044A0C153D159B
// shader: 8B30, 791B67746515F5BD
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp(min((texcolor0.rrr) + (texcolor0.ggg), vec3(1.0)) * (const_color[0].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor0.bbb) * (const_color[1].aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (vec3(1.0) - const_color[2].aaa) + (const_color[2].rgb) * (vec3(1.0) - (vec3(1.0) - const_color[2].aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((texcolor0.rgb) * (vec3(1.0) - const_color[4].aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (vec3(1.0) - const_color[4].aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 404553C09B17931E, 791B67746515F5BD
// program: 4FC2B4EDFF8D2FB4, 0D30074279C2FEED, 791B67746515F5BD
// shader: 8B30, DBBD969AF0C66F49
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (const_color[1].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 4609680C4B8F999F, DBBD969AF0C66F49
// program: BEC1B215F99385B9, 0D30074279C2FEED, DBBD969AF0C66F49
// shader: 8B30, C3A99FDA1696A8B2
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a) + (texcolor1.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (const_color[1].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 176EE9B7C22C87F7, C3A99FDA1696A8B2
// program: BEC1B215F99385B9, 0D30074279C2FEED, C3A99FDA1696A8B2
// shader: 8B30, 44776903C2844A30
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (const_color[1].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 4609680CA738729C, 44776903C2844A30
// program: BEC1B215F99385B9, 0D30074279C2FEED, 44776903C2844A30
// shader: 8B30, EA6884D3FFEAEBB5
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor1.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (texcolor1.aaa) + (texcolor0.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (const_color[2].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 7603EF8AF031590B, EA6884D3FFEAEBB5
// program: BEC1B215F99385B9, 0D30074279C2FEED, EA6884D3FFEAEBB5
// shader: 8B30, 61DF23C9A6C975E6
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.aaa) + (texcolor1.rgb) * (vec3(1.0) - (rounded_primary_color.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (const_color[0].a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (const_color[1].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 849E5E57673D3307, 61DF23C9A6C975E6
// program: BEC1B215F99385B9, 0D30074279C2FEED, 61DF23C9A6C975E6
// shader: 8B30, B35EFE43E319BB63
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = (const_color[0].a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D4F4BEF91F680A00, B35EFE43E319BB63
// program: BEC1B215F99385B9, 0D30074279C2FEED, B35EFE43E319BB63
// shader: 8B31, 3994F1926E4D24CE

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location = 0) in vec4 vs_in_reg0;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_1();
bool sub_15();
bool sub_2();
bool sub_5();
bool sub_6();
bool sub_7();
bool sub_8();
bool sub_9();
bool sub_10();
bool sub_11();
bool sub_12();
bool sub_13();
bool sub_14();
bool sub_0();
bool sub_3();
bool sub_4();

bool exec_shader() {
    sub_0();
    return true;
}

bool sub_1() {
    address_registers.x = (ivec2(vs_in_reg0.zz)).x;
    reg_tmp10 = uniforms.f[0].xxxz;
    reg_tmp10.xy = (vs_in_reg0.xyyy).xy;
    reg_tmp11 = uniforms.f[0].xxxx;
    reg_tmp12 = uniforms.f[0].xxxx;
    reg_tmp13 = uniforms.f[0].zzzz;
    reg_tmp4 = uniforms.f[0].xxxx;
    reg_tmp5 = uniforms.f[0].xxxx;
    return false;
}
bool sub_15() {
    vs_out_attr0 = reg_tmp10;
    reg_tmp13 = mul_s(uniforms.f[82], reg_tmp13);
    vs_out_attr1 = reg_tmp13;
    reg_tmp11.y = (uniforms.f[0].zzzz + -reg_tmp11.yyyy).y;
    reg_tmp12.y = (uniforms.f[0].zzzz + -reg_tmp12.yyyy).y;
    reg_tmp14.y = (uniforms.f[81].wwww).y;
    reg_tmp14.x = (mul_s(uniforms.f[0].wwww, reg_tmp14.yyyy)).x;
    reg_tmp2.x = rcp_s(reg_tmp14.x);
    reg_tmp14.z = (reg_tmp2.xxxx).z;
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp11.xyyy).xy;
    reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    reg_tmp11.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp12.xyyy).xy;
    reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    reg_tmp12.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    vs_out_attr2 = reg_tmp11;
    vs_out_attr3 = reg_tmp12;
    return false;
}
bool sub_2() {
    reg_tmp6.xyz = (-reg_tmp0.xyzz).xyz;
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    reg_tmp7.xyz = vec3(rcp_s(uniforms.f[81].y));
    reg_tmp8.xyz = (fma_s(reg_tmp6.xyzz, reg_tmp7.xyzz, uniforms.f[0].yyyy)).xyz;
    reg_tmp7.xyz = (floor(reg_tmp8.xyzz)).xyz;
    reg_tmp6.xyz = (fma_s(reg_tmp7.xyzz, -uniforms.f[81].yyyy, reg_tmp6.xyzz)).xyz;
    reg_tmp6 = min(uniforms.f[81].xxxx, reg_tmp6);
    reg_tmp6 = max(-uniforms.f[81].xxxx, reg_tmp6);
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp6.xxxx, reg_tmp6.xxxx)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp6.xxxx)).y;
    reg_tmp4.x = (reg_tmp1.xxxx).x;
    reg_tmp5.x = (reg_tmp1.yyyy).x;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp6.yyyy, reg_tmp6.yyyy)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp6.yyyy)).y;
    reg_tmp4.y = (reg_tmp1.xxxx).y;
    reg_tmp5.y = (reg_tmp1.yyyy).y;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp6.zzzz, reg_tmp6.zzzz)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp6.zzzz)).y;
    reg_tmp4.z = (reg_tmp1.xxxx).z;
    reg_tmp5.z = (reg_tmp1.yyyy).z;
    reg_tmp2.x = (mul_s(reg_tmp4.yyyy, reg_tmp5.zzzz)).x;
    reg_tmp2.y = (mul_s(reg_tmp5.yyyy, reg_tmp5.zzzz)).y;
    reg_tmp6.x = (mul_s(reg_tmp4.yyyy, reg_tmp4.zzzz)).x;
    reg_tmp6.y = (reg_tmp5.zzzz).y;
    reg_tmp6.z = (mul_s(-reg_tmp5.yyyy, reg_tmp4.zzzz)).z;
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    reg_tmp7.x = (mul_s(-reg_tmp2.xxxx, reg_tmp4.xxxx)).x;
    reg_tmp7.x = (fma_s(reg_tmp5.yyyy, reg_tmp5.xxxx, reg_tmp7.xxxx)).x;
    reg_tmp7.y = (mul_s(reg_tmp4.zzzz, reg_tmp4.xxxx)).y;
    reg_tmp7.z = (mul_s(reg_tmp2.yyyy, reg_tmp4.xxxx)).z;
    reg_tmp7.z = (fma_s(reg_tmp4.yyyy, reg_tmp5.xxxx, reg_tmp7.zzzz)).z;
    reg_tmp7.w = (uniforms.f[0].xxxx).w;
    reg_tmp8.x = (mul_s(reg_tmp2.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp8.x = (fma_s(reg_tmp5.yyyy, reg_tmp4.xxxx, reg_tmp8.xxxx)).x;
    reg_tmp8.y = (mul_s(-reg_tmp4.zzzz, reg_tmp5.xxxx)).y;
    reg_tmp8.z = (mul_s(-reg_tmp2.yyyy, reg_tmp5.xxxx)).z;
    reg_tmp8.z = (fma_s(reg_tmp4.yyyy, reg_tmp4.xxxx, reg_tmp8.zzzz)).z;
    reg_tmp8.w = (uniforms.f[0].xxxx).w;
    reg_tmp9 = uniforms.f[0].xxxz;
    return false;
}
bool sub_5() {
    reg_tmp2 = uniforms.f[90];
    reg_tmp3 = uniforms.f[91];
    reg_tmp4 = uniforms.f[92];
    reg_tmp5 = uniforms.f[0].xxxz;
    reg_tmp6 = mul_s(uniforms.f[86].xxxx, reg_tmp2);
    reg_tmp6 = fma_s(reg_tmp3, uniforms.f[86].yyyy, reg_tmp6);
    reg_tmp6 = fma_s(reg_tmp4, uniforms.f[86].zzzz, reg_tmp6);
    reg_tmp6 = fma_s(reg_tmp5, uniforms.f[86].wwww, reg_tmp6);
    reg_tmp7 = mul_s(uniforms.f[87].xxxx, reg_tmp2);
    reg_tmp7 = fma_s(reg_tmp3, uniforms.f[87].yyyy, reg_tmp7);
    reg_tmp7 = fma_s(reg_tmp4, uniforms.f[87].zzzz, reg_tmp7);
    reg_tmp7 = fma_s(reg_tmp5, uniforms.f[87].wwww, reg_tmp7);
    reg_tmp8 = mul_s(uniforms.f[88].xxxx, reg_tmp2);
    reg_tmp8 = fma_s(reg_tmp3, uniforms.f[88].yyyy, reg_tmp8);
    reg_tmp8 = fma_s(reg_tmp4, uniforms.f[88].zzzz, reg_tmp8);
    reg_tmp8 = fma_s(reg_tmp5, uniforms.f[88].wwww, reg_tmp8);
    reg_tmp9 = mul_s(uniforms.f[89].xxxx, reg_tmp2);
    reg_tmp9 = fma_s(reg_tmp3, uniforms.f[89].yyyy, reg_tmp9);
    reg_tmp9 = fma_s(reg_tmp4, uniforms.f[89].zzzz, reg_tmp9);
    reg_tmp9 = fma_s(reg_tmp5, uniforms.f[89].wwww, reg_tmp9);
    return false;
}
bool sub_6() {
    reg_tmp2.x = rcp_s(uniforms.f[81].y);
    reg_tmp2.xy = (mul_s(uniforms.f[2 + address_registers.x].zwww, reg_tmp2.xxxx)).xy;
    reg_tmp2.xy = (uniforms.f[0].yyyy + reg_tmp2.xyyy).xy;
    reg_tmp3.xy = (floor(reg_tmp2.xyyy)).xy;
    reg_tmp2.xy = (mul_s(uniforms.f[81].yyyy, reg_tmp3.xyyy)).xy;
    reg_tmp2.xy = (uniforms.f[2 + address_registers.x].zwww + -reg_tmp2.xyyy).xy;
    reg_tmp0.xy = (min(uniforms.f[81].xxxx, -reg_tmp2.xyyy)).xy;
    reg_tmp0.xy = (max(-uniforms.f[81].xxxx, reg_tmp0.xyyy)).xy;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp0.xxxx, reg_tmp0.xxxx)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.xxxx)).y;
    reg_tmp5.x = (uniforms.f[5 + address_registers.x].wwww).x;
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_7();
    }
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_8();
    }
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_9();
    }
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_10();
    }
    reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    reg_tmp4.z = (uniforms.f[83].xxxx).z;
    reg_tmp4.w = (-uniforms.f[83].yyyy).w;
    reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[3 + address_registers.x].xyyy)).xy;
    reg_tmp4.z = (-uniforms.f[3 + address_registers.x].zzzz).z;
    reg_tmp4.w = (-uniforms.f[3 + address_registers.x].wwww).w;
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    reg_tmp11.xy = (reg_tmp5.xyyy).xy;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp0.yyyy, reg_tmp0.yyyy)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.yyyy)).y;
    reg_tmp5.x = (uniforms.f[6 + address_registers.x].wwww).x;
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_11();
    }
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_12();
    }
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_13();
    }
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_14();
    }
    reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    reg_tmp4.z = (uniforms.f[83].zzzz).z;
    reg_tmp4.w = (-uniforms.f[83].wwww).w;
    reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[4 + address_registers.x].xyyy)).xy;
    reg_tmp4.z = (-uniforms.f[4 + address_registers.x].zzzz).z;
    reg_tmp4.w = (-uniforms.f[4 + address_registers.x].wwww).w;
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    reg_tmp12.xy = (reg_tmp5.xyyy).xy;
    return false;
}
bool sub_7() {
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_8() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_9() {
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_10() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_11() {
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_12() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_13() {
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_14() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_0() {
    {
        sub_1();
    }
    reg_tmp10.xy = (uniforms.f[84].xyyy + reg_tmp10.xyyy).xy;
    reg_tmp10.xy = (mul_s(uniforms.f[2 + address_registers.x].xyyy, reg_tmp10.xyyy)).xy;
    reg_tmp14 = reg_tmp10;
    reg_tmp0 = uniforms.f[7 + address_registers.x];
    {
        sub_2();
    }
    reg_tmp10.x = dot_s(reg_tmp14, reg_tmp6);
    reg_tmp10.y = dot_s(reg_tmp14, reg_tmp7);
    reg_tmp10.z = dot_s(reg_tmp14, reg_tmp8);
    reg_tmp10.w = dot_s(reg_tmp14, reg_tmp9);
    reg_tmp6 = uniforms.f[8 + address_registers.x];
    reg_tmp7 = uniforms.f[9 + address_registers.x];
    reg_tmp8 = uniforms.f[10 + address_registers.x];
    reg_tmp9 = uniforms.f[0].xxxz;
    reg_tmp6.w = (uniforms.f[5 + address_registers.x].xxxx).w;
    reg_tmp7.w = (uniforms.f[5 + address_registers.x].yyyy).w;
    reg_tmp8.w = (uniforms.f[5 + address_registers.x].zzzz).w;
    reg_tmp2.x = dot_s(reg_tmp10, reg_tmp6);
    reg_tmp2.y = dot_s(reg_tmp10, reg_tmp7);
    reg_tmp2.z = dot_s(reg_tmp10, reg_tmp8);
    reg_tmp2.w = dot_s(reg_tmp10, reg_tmp9);
    reg_tmp10 = reg_tmp2;
    reg_tmp3.xyz = (uniforms.f[5 + address_registers.x].xyzz).xyz;
    reg_tmp3.xyz = (uniforms.f[85].xyzz + -reg_tmp3.xyzz).xyz;
    reg_tmp4.x = dot_3(reg_tmp3.xyz, reg_tmp3.xyz);
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
    if (conditional_code.x) {
        sub_3();
    } else {
        sub_4();
    }
    reg_tmp3.xyz = (mul_s(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
    reg_tmp10.xyz = (fma_s(reg_tmp3.xyzz, uniforms.f[84].zzzz, reg_tmp10.xyzz)).xyz;
    {
        sub_5();
    }
    reg_tmp2 = reg_tmp10;
    reg_tmp10.x = dot_s(reg_tmp2, reg_tmp6);
    reg_tmp10.y = dot_s(reg_tmp2, reg_tmp7);
    reg_tmp10.z = dot_s(reg_tmp2, reg_tmp8);
    reg_tmp10.w = dot_s(reg_tmp2, reg_tmp9);
    reg_tmp2 = uniforms.f[1 + address_registers.x];
    reg_tmp3 = max(uniforms.f[0].xxxx, reg_tmp2);
    reg_tmp2 = min(uniforms.f[0].zzzz, reg_tmp3);
    reg_tmp13 = reg_tmp2;
    {
        sub_6();
    }
    {
        sub_15();
    }
    return true;
}
bool sub_3() {
    reg_tmp4.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_4() {
    reg_tmp4.x = rsq_s(reg_tmp4.x);
    return false;
}
// reference: 9E14AD08A900EB0E, 3994F1926E4D24CE
// shader: 8DD9, 13A54CCD8AA1DDA2

layout(triangles) in;
layout(triangle_strip, max_vertices = 3) out;

out vec4 primary_color;
out vec2 texcoord0;
out vec2 texcoord1;
out vec2 texcoord2;
out float texcoord0_w;
out vec4 normquat;
out vec3 view;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

in vec4 vs_out_attr0[];
in vec4 vs_out_attr1[];
in vec4 vs_out_attr2[];
in vec4 vs_out_attr3[];
struct Vertex {
    vec4 attributes[4];
};

vec4 GetVertexQuaternion(Vertex vtx) {
    return vec4(0.0, 0.0, 0.0, 0.0);
}

void EmitVtx(Vertex vtx, bool quats_opposite) {
    vec4 vtx_pos = vec4(vtx.attributes[0].x, vtx.attributes[0].y, vtx.attributes[0].z, vtx.attributes[0].w);
    gl_Position = vtx_pos;
#if !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)
    gl_ClipDistance[0] = -vtx_pos.z;
    gl_ClipDistance[1] = dot(clip_coef, vtx_pos);
#endif // !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)

    vec4 vtx_quat = GetVertexQuaternion(vtx);
    normquat = mix(vtx_quat, -vtx_quat, bvec4(quats_opposite));

    vec4 vtx_color = vec4(vtx.attributes[1].x, vtx.attributes[1].y, vtx.attributes[1].z, vtx.attributes[1].w);
    primary_color = min(abs(vtx_color), vec4(1.0));

    texcoord0 = vec2(vtx.attributes[2].x, vtx.attributes[2].y);
    texcoord1 = vec2(vtx.attributes[3].x, vtx.attributes[3].y);

    texcoord0_w = 0.0;
    view = vec3(0.0, 0.0, 0.0);
    texcoord2 = vec2(0.0, 0.0);

    EmitVertex();
}

bool AreQuaternionsOpposite(vec4 qa, vec4 qb) {
    return (dot(qa, qb) < 0.0);
}

void EmitPrim(Vertex vtx0, Vertex vtx1, Vertex vtx2) {
    EmitVtx(vtx0, false);
    EmitVtx(vtx1, AreQuaternionsOpposite(GetVertexQuaternion(vtx0), GetVertexQuaternion(vtx1)));
    EmitVtx(vtx2, AreQuaternionsOpposite(GetVertexQuaternion(vtx0), GetVertexQuaternion(vtx2)));
    EndPrimitive();
}

void main() {
    Vertex prim_buffer[3];
    prim_buffer[0].attributes = vec4[4](vs_out_attr0[0], vs_out_attr1[0], vs_out_attr2[0], vs_out_attr3[0]);
    prim_buffer[1].attributes = vec4[4](vs_out_attr0[1], vs_out_attr1[1], vs_out_attr2[1], vs_out_attr3[1]);
    prim_buffer[2].attributes = vec4[4](vs_out_attr0[2], vs_out_attr1[2], vs_out_attr2[2], vs_out_attr3[2]);
    EmitPrim(prim_buffer[0], prim_buffer[1], prim_buffer[2]);
}
// reference: A55C6948CCF76B42, 13A54CCD8AA1DDA2
// shader: 8B30, B6B08DE0C83FF4C8
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.r);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_2 = byteround(clamp((vec3(1.0) - combiner_buffer.rgb) * (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 703709193E737D07, B6B08DE0C83FF4C8
// program: 3994F1926E4D24CE, 13A54CCD8AA1DDA2, B6B08DE0C83FF4C8
// shader: 8B30, 4513080BBAB785A8
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((vec3(1.0) - combiner_buffer.rgb) * (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 5F0AA39F3D41FA2C, 4513080BBAB785A8
// program: 7C96EBECB346C618, 1C4CBC8096EA16CD, 4513080BBAB785A8
// reference: 5F0AA39F650CF7BC, 4513080BBAB785A8
// shader: 8B31, 8A537BEA6370A337

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location = 0) in vec4 vs_in_reg0;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;
out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_2();
bool sub_1();
bool sub_3();
bool sub_4();
bool sub_0();

bool exec_shader() {
    sub_0();
    return true;
}

bool sub_2() {
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    return false;
}
bool sub_1() {
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    reg_tmp7 = uniforms.f[93].xxxx;
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    {
        sub_2();
    }
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    {
        sub_2();
    }
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    if (conditional_code.x) {
        sub_2();
    }
    if (uniforms.b[11]) {
        sub_3();
    }
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    reg_tmp10 = reg_tmp7;
    reg_tmp6.y = (-uniforms.f[83].wwww + reg_tmp10.yyyy).y;
    reg_tmp9.xyz = (uniforms.f[83].xyzz).xyz;
    reg_tmp7.x = dot_s(reg_tmp9.xyzz, reg_tmp9.xyzz);
    reg_tmp7.x = rsq_s(reg_tmp7.x);
    reg_tmp7.xyz = (mul_s(reg_tmp9.xyzz, reg_tmp7.xxxx)).xyz;
    reg_tmp8.y = rcp_s(-reg_tmp7.y);
    reg_tmp8.y = (mul_s(reg_tmp6.yyyy, reg_tmp8.yyyy)).y;
    reg_tmp7.xyz = (mul_s(reg_tmp7.xyzz, reg_tmp8.yyyy)).xyz;
    reg_tmp10.xyz = (reg_tmp10.xyzz + reg_tmp7.xyzz).xyz;
    reg_tmp10.y = (uniforms.f[94].xxxx + reg_tmp10.yyyy).y;
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    vs_out_attr1 = uniforms.f[93].xxxx;
    vs_out_attr2 = -reg_tmp15;
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    if (all(conditional_code)) {
        sub_4();
    }
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_3() {
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    if (conditional_code.y) {
        sub_2();
    }
    return false;
}
bool sub_4() {
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_0() {
    {
        sub_1();
    }
    vs_out_attr4 = uniforms.f[93].xxxx;
    vs_out_attr5 = uniforms.f[93].xxxx;
    vs_out_attr6 = uniforms.f[93].xxxx;
    vs_out_attr3 = uniforms.f[93].xxxx;
    return true;
}
// reference: A25A5920FEA7EFA3, 8A537BEA6370A337
// shader: 8B30, 5C810B10151A2528
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = (const_color[0].a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = (last_tex_env_out.rgb);
float alpha_output_5 = (const_color[5].r);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 7E0CA6739081C321, 5C810B10151A2528
// program: 8A537BEA6370A337, 0D30074279C2FEED, 5C810B10151A2528
// reference: EC0EA6607D5289D1, 8A537BEA6370A337
// shader: 8B30, F46A424E601B7C89
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) + (const_color[0].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].aaa) + (const_color[1].rgb) * (vec3(1.0) - (const_color[1].aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (const_color[2].a) + (const_color[2].r) * (1.0 - (const_color[2].a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((texcolor1.a) * (const_color[3].a) + (texcolor1.r) * (1.0 - (const_color[3].a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = (last_tex_env_out.rgb);
float alpha_output_4 = byteround(clamp((last_tex_env_out.a) * (combiner_buffer.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D3310DE01E8B3F75, F46A424E601B7C89
// program: AAA8EB839E9F5CC6, 0D30074279C2FEED, F46A424E601B7C89
// shader: 8B31, 5860A67EDEA44DB1

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;
out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_11();
bool sub_9();
bool sub_3();
bool sub_5();
bool sub_2();
bool sub_4();
bool sub_6();
bool sub_8();
bool sub_10();
bool sub_12();
bool sub_19();
bool sub_20();
bool sub_26();
bool sub_27();
bool sub_28();
bool sub_29();
bool sub_31();
bool sub_33();
bool sub_34();
bool sub_35();
bool sub_36();
bool sub_37();
bool sub_38();
bool sub_39();
bool sub_40();
bool sub_41();
bool sub_42();
bool sub_43();
bool sub_44();
bool sub_21();
bool sub_22();
bool sub_23();
bool sub_24();
bool sub_25();
bool sub_30();
bool sub_32();
bool sub_14();
bool sub_15();
bool sub_16();
bool sub_17();
bool sub_0();
bool sub_1();
bool sub_7();
bool sub_13();
bool sub_18();

bool exec_shader() {
    sub_0();
    return true;
}

bool sub_11() {
    uint jmp_to = 0u;
    while (true) {
        switch (jmp_to) {
        case 0u: {
            reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
            reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
            reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
            reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
            reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
            reg_tmp6.x = rsq_s(reg_tmp6.x);
            reg_tmp7.x = rsq_s(reg_tmp7.x);
            reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            reg_tmp0 = uniforms.f[93].yxxx;
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            reg_tmp4 = mul_s(uniforms.f[94].xxxx, reg_tmp4);
            conditional_code = greaterThanEqual(uniforms.f[93].xx, reg_tmp4.xx);
            reg_tmp4 = vec4(rsq_s(reg_tmp4.x));
            reg_tmp5 = mul_s(uniforms.f[94].xxxx, reg_tmp14);
            if (conditional_code.x) {
                { jmp_to = 18u; break; }
            }
            reg_tmp0.z = rcp_s(reg_tmp4.x);
            reg_tmp0.xy = (mul_s(reg_tmp5, reg_tmp4)).xy;
        }
        case 18u: {
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_9() {
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    reg_tmp4.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_3() {
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    reg_tmp3.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp3.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp3.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp12);
    reg_tmp3.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp13.xyz);
    reg_tmp3.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp13.xyz);
    reg_tmp3.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp13.xyz);
    reg_tmp11 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp11);
    reg_tmp3.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp5.xyz);
    reg_tmp3.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp5.xyz);
    reg_tmp3.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp5.xyz);
    reg_tmp9 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp9);
    reg_tmp3.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp6.xyz);
    reg_tmp3.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp6.xyz);
    reg_tmp3.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp6.xyz);
    reg_tmp8 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp8);
    return false;
}
bool sub_5() {
    reg_tmp0.xyz = (mul_s(reg_tmp9.yzxx, reg_tmp8.zxyy)).xyz;
    reg_tmp0.xyz = (fma_s(-reg_tmp8.yzxx, reg_tmp9.zxyy, reg_tmp0)).xyz;
    reg_tmp1 = uniforms.f[83];
    reg_tmp2.x = dot_s(reg_tmp1.xyzz, reg_tmp1.xyzz);
    reg_tmp2.x = rsq_s(reg_tmp2.x);
    reg_tmp2.xyz = (mul_s(reg_tmp1.xyzz, reg_tmp2.xxxx)).xyz;
    reg_tmp1.x = dot_3(reg_tmp2.xyz, reg_tmp8.xyz);
    reg_tmp1.y = dot_3(reg_tmp2.xyz, reg_tmp0.xyz);
    reg_tmp1.z = dot_3(reg_tmp2.xyz, reg_tmp9.xyz);
    reg_tmp2.x = dot_s(reg_tmp1.xyzz, reg_tmp1.xyzz);
    reg_tmp2.x = rsq_s(reg_tmp2.x);
    reg_tmp2.xyz = (mul_s(reg_tmp1.xyzz, reg_tmp2.xxxx)).xyz;
    reg_tmp2.w = (uniforms.f[93].yyyy).w;
    vs_out_attr2 = reg_tmp2;
    return false;
}
bool sub_2() {
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    reg_tmp13.xyz = (vs_in_reg2).xyz;
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    reg_tmp5 = uniforms.f[93].xxyy;
    reg_tmp6 = uniforms.f[93].yxxy;
    reg_tmp7 = uniforms.f[93].xxxx;
    reg_tmp12 = uniforms.f[93].xxxx;
    reg_tmp11 = uniforms.f[93].xxxx;
    reg_tmp9 = uniforms.f[93].xxxx;
    reg_tmp8 = uniforms.f[93].xxxx;
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    {
        sub_3();
    }
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    {
        sub_3();
    }
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    if (conditional_code.x) {
        sub_3();
    }
    if (uniforms.b[11]) {
        sub_4();
    }
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    reg_tmp10 = reg_tmp7;
    reg_tmp13.x = dot_3(uniforms.f[90].xyz, reg_tmp11.xyz);
    reg_tmp13.y = dot_3(uniforms.f[91].xyz, reg_tmp11.xyz);
    reg_tmp13.z = dot_3(uniforms.f[92].xyz, reg_tmp11.xyz);
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    {
        sub_5();
    }
    vs_out_attr1 = uniforms.f[93].xxxy;
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    if (all(conditional_code)) {
        sub_6();
    }
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_4() {
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    if (conditional_code.y) {
        sub_3();
    }
    return false;
}
bool sub_6() {
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_8() {
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    reg_tmp7 = uniforms.f[93].xxxx;
    reg_tmp12 = uniforms.f[93].xxxx;
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    {
        sub_9();
    }
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    {
        sub_9();
    }
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    if (conditional_code.x) {
        sub_9();
    }
    if (uniforms.b[11]) {
        sub_10();
    }
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    reg_tmp10 = reg_tmp7;
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    {
        sub_11();
    }
    vs_out_attr2 = -reg_tmp15;
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    if (all(conditional_code)) {
        sub_12();
    }
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_10() {
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    if (conditional_code.y) {
        sub_9();
    }
    return false;
}
bool sub_12() {
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_19() {
    reg_tmp0.xy = (uniforms.f[0].xxxx).xy;
    if (uniforms.b[2]) {
        sub_20();
    } else {
        sub_26();
    }
    return false;
}
bool sub_20() {
    {
        sub_21();
    }
    reg_tmp3.x = dot_s(uniforms.f[1].xywz, reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2].xywz, reg_tmp6);
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_26() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_27();
    } else {
        sub_28();
    }
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_27() {
    reg_tmp6 = reg_tmp10;
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    reg_tmp3.z = dot_s(uniforms.f[3], reg_tmp6);
    reg_tmp0.xy = (mul_s(uniforms.f[9].xyyy, reg_tmp3.zzzz)).xy;
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_28() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_29();
    } else {
        sub_31();
    }
    return false;
}
bool sub_29() {
    {
        sub_30();
    }
    reg_tmp3.x = dot_3(uniforms.f[1].xyz, reg_tmp6.xyz);
    reg_tmp3.y = dot_3(uniforms.f[2].xyz, reg_tmp6.xyz);
    reg_tmp3.z = dot_3(uniforms.f[3].xyz, reg_tmp6.xyz);
    return false;
}
bool sub_31() {
    {
        sub_32();
    }
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    return false;
}
bool sub_33() {
    reg_tmp0.xy = (uniforms.f[0].yyyy).xy;
    if (uniforms.b[3]) {
        sub_34();
    } else {
        sub_35();
    }
    return false;
}
bool sub_34() {
    {
        sub_21();
    }
    reg_tmp4.x = dot_s(uniforms.f[4].xywz, reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5].xywz, reg_tmp6);
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_35() {
    if (uniforms.b[5]) {
        sub_36();
    } else {
        sub_39();
    }
    return false;
}
bool sub_36() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_37();
    } else {
        sub_38();
    }
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_37() {
    reg_tmp6 = reg_tmp10;
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    reg_tmp4.z = dot_s(uniforms.f[6], reg_tmp6);
    reg_tmp6.w = rcp_s(reg_tmp4.z);
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    reg_tmp4.xy = (uniforms.f[9].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_38() {
    {
        sub_32();
    }
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    return false;
}
bool sub_39() {
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_40() {
    reg_tmp0.xy = (uniforms.f[0].zzzz).xy;
    if (uniforms.b[4]) {
        sub_41();
    } else {
        sub_42();
    }
    return false;
}
bool sub_41() {
    {
        sub_21();
    }
    reg_tmp5.x = dot_s(uniforms.f[7].xywz, reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8].xywz, reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_42() {
    if (uniforms.b[6]) {
        sub_43();
    } else {
        sub_44();
    }
    return false;
}
bool sub_43() {
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    {
        sub_32();
    }
    reg_tmp5.x = dot_s(uniforms.f[7], reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8], reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_44() {
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
bool sub_21() {
    conditional_code = equal(uniforms.f[93].yz, reg_tmp0.xy);
    if (all(not(conditional_code))) {
        sub_22();
    } else {
        sub_23();
    }
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_22() {
    reg_tmp6.xy = (vs_in_reg4.xyyy).xy;
    return false;
}
bool sub_23() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_24();
    } else {
        sub_25();
    }
    return false;
}
bool sub_24() {
    reg_tmp6.xy = (vs_in_reg5.xyyy).xy;
    return false;
}
bool sub_25() {
    reg_tmp6.xy = (vs_in_reg6.xyyy).xy;
    return false;
}
bool sub_30() {
    reg_tmp2 = -reg_tmp15;
    reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
    reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_32() {
    reg_tmp1 = reg_tmp14;
    reg_tmp2.w = dot_3(reg_tmp1.xyz, reg_tmp1.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp1 = mul_s(reg_tmp1, reg_tmp2.wwww);
    reg_tmp1 = mul_s(uniforms.f[94].xxxx, reg_tmp1);
    reg_tmp6.xy = (uniforms.f[94].xxxx + reg_tmp1.xyyy).xy;
    return false;
}
bool sub_14() {
    reg_tmp1.xyz = (uniforms.f[93].xxyx).xyz;
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    reg_tmp14.w = (uniforms.f[93].xxxx).w;
    reg_tmp8 = reg_tmp14;
    reg_tmp14.x = dot_s(reg_tmp8, reg_tmp8);
    reg_tmp14.x = rsq_s(reg_tmp14.x);
    reg_tmp14 = mul_s(reg_tmp8, reg_tmp14.xxxx);
    reg_tmp8 = uniforms.f[83];
    reg_tmp6.x = dot_3(uniforms.f[90].xyz, reg_tmp8.xyz);
    reg_tmp6.y = dot_3(uniforms.f[91].xyz, reg_tmp8.xyz);
    reg_tmp6.z = dot_3(uniforms.f[92].xyz, reg_tmp8.xyz);
    reg_tmp8.xyz = (reg_tmp6.xyzz + reg_tmp1.xyzz).xyz;
    reg_tmp8.w = (uniforms.f[93].xxxx).w;
    reg_tmp0.x = dot_s(reg_tmp8, reg_tmp8);
    reg_tmp0.x = rsq_s(reg_tmp0.x);
    reg_tmp0 = mul_s(reg_tmp8, reg_tmp0.xxxx);
    reg_tmp2 = uniforms.f[93].xxxx;
    if (uniforms.b[9]) {
        sub_15();
    }
    if (uniforms.b[7]) {
        sub_16();
    }
    if (uniforms.b[8]) {
        sub_17();
    }
    vs_out_attr3 = reg_tmp2;
    return false;
}
bool sub_15() {
    reg_tmp8.x = dot_3(reg_tmp14.xyz, -reg_tmp6.xyz);
    reg_tmp8.y = dot_3(reg_tmp1.xyz, -reg_tmp6.xyz);
    reg_tmp8 = max(uniforms.f[93].xxxx, reg_tmp8);
    reg_tmp8.y = (mul_s(uniforms.f[94].xxxx, reg_tmp8.yyyy)).y;
    reg_tmp8.y = (uniforms.f[94].xxxx + reg_tmp8.yyyy).y;
    reg_tmp2.y = (mul_s(reg_tmp8.xxxx, reg_tmp8.yyyy)).y;
    return false;
}
bool sub_16() {
    reg_tmp9.z = dot_3(reg_tmp14.xyz, reg_tmp0.xyz);
    reg_tmp9.z = (max(uniforms.f[93].xxxx, reg_tmp9.zzzz)).z;
    reg_tmp9.z = (min(uniforms.f[93].yyyy, reg_tmp9.zzzz)).z;
    reg_tmp9.z = log2(reg_tmp9.z);
    reg_tmp9.z = (mul_s(uniforms.f[82].zzzz, reg_tmp9.zzzz)).z;
    reg_tmp9.z = exp2(reg_tmp9.z);
    reg_tmp2.z = (mul_s(uniforms.f[82].wwww, reg_tmp9.zzzz)).z;
    return false;
}
bool sub_17() {
    reg_tmp9.x = dot_3(reg_tmp14.xyz, reg_tmp1.xyz);
    reg_tmp9.x = (max(uniforms.f[93].xxxx, reg_tmp9.xxxx)).x;
    reg_tmp9.x = (min(uniforms.f[93].yyyy, reg_tmp9.xxxx)).x;
    reg_tmp9.x = (uniforms.f[93].yyyy + -reg_tmp9.xxxx).x;
    reg_tmp9.x = log2(reg_tmp9.x);
    reg_tmp9.x = (mul_s(uniforms.f[82].xxxx, reg_tmp9.xxxx)).x;
    reg_tmp9.x = exp2(reg_tmp9.x);
    reg_tmp2.w = (mul_s(uniforms.f[82].yyyy, reg_tmp9.xxxx)).w;
    return false;
}
bool sub_0() {
    if (uniforms.b[10]) {
        sub_1();
    } else {
        sub_7();
    }
    if (uniforms.b[1]) {
        sub_13();
    } else {
        sub_18();
    }
    {
        sub_19();
    }
    {
        sub_33();
    }
    {
        sub_40();
    }
    return true;
}
bool sub_1() {
    {
        sub_2();
    }
    return false;
}
bool sub_7() {
    {
        sub_8();
    }
    return false;
}
bool sub_13() {
    {
        sub_14();
    }
    return false;
}
bool sub_18() {
    vs_out_attr3 = uniforms.f[93].yyyy;
    return false;
}
// reference: EF359D593CBA9A7A, 5860A67EDEA44DB1
// shader: 8B30, FE3CDC9FA9FF9FA9
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = 2.0 * (texcolor2).rgb - 1.0;
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(normal, normalize(view))));
refl_value.g = (lut_scale_rg * LookupLightingLUTSigned(5, dot(normal, normalize(view))));
refl_value.b = (lut_scale_rb * LookupLightingLUTSigned(4, dot(normal, normalize(view))));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = byteround(clamp((secondary_fragment_color.r) * (texcolor2.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor0.rgb) * (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (1.0 - const_color[1].a) + (secondary_fragment_color.b) * (1.0 - (1.0 - const_color[1].a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (texcolor1.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((secondary_fragment_color.ggg) * (const_color[3].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((rounded_primary_color.aaa) * (const_color[4].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: B9C7C307E036E114, FE3CDC9FA9FF9FA9
// program: 5860A67EDEA44DB1, 0D30074279C2FEED, FE3CDC9FA9FF9FA9
// reference: A1616219BF4FFC08, 5860A67EDEA44DB1
// shader: 8B30, B3D8BDDED8751DC1
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = 2.0 * (texcolor2).rgb - 1.0;
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(normal, normalize(view))));
refl_value.g = (lut_scale_rg * LookupLightingLUTSigned(5, dot(normal, normalize(view))));
refl_value.b = (lut_scale_rb * LookupLightingLUTSigned(4, dot(normal, normalize(view))));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((secondary_fragment_color.r) * (1.0 - const_color[0].a) + (secondary_fragment_color.b) * (1.0 - (1.0 - const_color[0].a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (texcolor0.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((secondary_fragment_color.ggg) * (const_color[2].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((rounded_primary_color.aaa) * (const_color[3].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = (texcolor1.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: FE0F5D31E87D96D8, B3D8BDDED8751DC1
// program: 5860A67EDEA44DB1, 0D30074279C2FEED, B3D8BDDED8751DC1
// shader: 8B30, 71558E57CB578675
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = 2.0 * (texcolor2).rgb - 1.0;
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(normal, normalize(view))));
refl_value.g = (lut_scale_rg * LookupLightingLUTSigned(5, dot(normal, normalize(view))));
refl_value.b = (lut_scale_rb * LookupLightingLUTSigned(4, dot(normal, normalize(view))));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((secondary_fragment_color.r) * (1.0 - const_color[0].a) + (secondary_fragment_color.b) * (1.0 - (1.0 - const_color[0].a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (texcolor0.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((secondary_fragment_color.ggg) * (const_color[2].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor2.a) * (const_color[2].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_3 = byteround(clamp((texcolor1.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((rounded_primary_color.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((rounded_primary_color.aaa) * (const_color[4].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp(min((combiner_buffer.aaa) + (const_color[5].rgb), vec3(1.0)) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: B83DE5C9FA1DA930, 71558E57CB578675
// program: 5860A67EDEA44DB1, 0D30074279C2FEED, 71558E57CB578675
// shader: 8B30, B39B86850EF4C09C
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = 2.0 * (texcolor2).rgb - 1.0;
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(normal, normalize(view))));
refl_value.g = (lut_scale_rg * LookupLightingLUTSigned(5, dot(normal, normalize(view))));
refl_value.b = (lut_scale_rb * LookupLightingLUTSigned(4, dot(normal, normalize(view))));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((secondary_fragment_color.r) * (1.0 - const_color[0].a) + (secondary_fragment_color.b) * (1.0 - (1.0 - const_color[0].a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (texcolor0.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((secondary_fragment_color.ggg) * (last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((rounded_primary_color.g) * (const_color[2].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (texcolor1.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.aaa) * (const_color[4].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 4B64D36FDA37B8DB, B39B86850EF4C09C
// program: 5860A67EDEA44DB1, 0D30074279C2FEED, B39B86850EF4C09C
// shader: 8B30, 7FBD92A5E9176C9B
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = 2.0 * (texcolor2).rgb - 1.0;
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(normal, normalize(view))));
refl_value.g = (lut_scale_rg * LookupLightingLUTSigned(5, dot(normal, normalize(view))));
refl_value.b = (lut_scale_rb * LookupLightingLUTSigned(4, dot(normal, normalize(view))));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((secondary_fragment_color.r) * (1.0 - const_color[0].a) + (secondary_fragment_color.b) * (1.0 - (1.0 - const_color[0].a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (texcolor0.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((secondary_fragment_color.ggg) * (last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((texcolor1.a) * (texcolor2.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 025F771450084C5D, 7FBD92A5E9176C9B
// program: 5860A67EDEA44DB1, 0D30074279C2FEED, 7FBD92A5E9176C9B
// shader: 8B30, 18029AEFBF0A9810
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = 2.0 * (texcolor2).rgb - 1.0;
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(normal, normalize(view))));
refl_value.g = (lut_scale_rg * LookupLightingLUTSigned(5, dot(normal, normalize(view))));
refl_value.b = (lut_scale_rb * LookupLightingLUTSigned(4, dot(normal, normalize(view))));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((secondary_fragment_color.r) * (1.0 - const_color[0].a) + (secondary_fragment_color.b) * (1.0 - (1.0 - const_color[0].a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (texcolor0.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((secondary_fragment_color.ggg) * (const_color[2].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((rounded_primary_color.b) + (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((texcolor1.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = (last_tex_env_out.rgb);
float alpha_output_4 = byteround(clamp((last_tex_env_out.a) + (secondary_fragment_color.g), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 6122AFA083698865, 18029AEFBF0A9810
// program: 5860A67EDEA44DB1, 0D30074279C2FEED, 18029AEFBF0A9810
// shader: 8B30, DC12E218392F9BDB
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D4F4BEF95B3A33D3, DC12E218392F9BDB
// program: BEC1B215F99385B9, 0D30074279C2FEED, DC12E218392F9BDB
// reference: 1793BA634DE4EBBB, BEC1B215F99385B9
// shader: 8B31, 655FFD4060F406B6

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location = 0) in vec4 vs_in_reg0;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_1();
bool sub_16();
bool sub_2();
bool sub_3();
bool sub_6();
bool sub_7();
bool sub_8();
bool sub_9();
bool sub_10();
bool sub_11();
bool sub_12();
bool sub_13();
bool sub_14();
bool sub_15();
bool sub_0();
bool sub_4();
bool sub_5();

bool exec_shader() {
    sub_0();
    return true;
}

bool sub_1() {
    address_registers.x = (ivec2(vs_in_reg0.zz)).x;
    reg_tmp10 = uniforms.f[0].xxxz;
    reg_tmp10.xy = (vs_in_reg0.xyyy).xy;
    reg_tmp11 = uniforms.f[0].xxxx;
    reg_tmp12 = uniforms.f[0].xxxx;
    reg_tmp13 = uniforms.f[0].zzzz;
    reg_tmp4 = uniforms.f[0].xxxx;
    reg_tmp5 = uniforms.f[0].xxxx;
    return false;
}
bool sub_16() {
    vs_out_attr0 = reg_tmp10;
    reg_tmp13 = mul_s(uniforms.f[82], reg_tmp13);
    vs_out_attr1 = reg_tmp13;
    reg_tmp11.y = (uniforms.f[0].zzzz + -reg_tmp11.yyyy).y;
    reg_tmp12.y = (uniforms.f[0].zzzz + -reg_tmp12.yyyy).y;
    reg_tmp14.y = (uniforms.f[81].wwww).y;
    reg_tmp14.x = (mul_s(uniforms.f[0].wwww, reg_tmp14.yyyy)).x;
    reg_tmp2.x = rcp_s(reg_tmp14.x);
    reg_tmp14.z = (reg_tmp2.xxxx).z;
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp11.xyyy).xy;
    reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    reg_tmp11.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp12.xyyy).xy;
    reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    reg_tmp12.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    vs_out_attr2 = reg_tmp11;
    vs_out_attr3 = reg_tmp12;
    return false;
}
bool sub_2() {
    reg_tmp6.xyz = (-reg_tmp0.xyzz).xyz;
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    reg_tmp7.xyz = vec3(rcp_s(uniforms.f[81].y));
    reg_tmp8.xyz = (fma_s(reg_tmp6.xyzz, reg_tmp7.xyzz, uniforms.f[0].yyyy)).xyz;
    reg_tmp7.xyz = (floor(reg_tmp8.xyzz)).xyz;
    reg_tmp6.xyz = (fma_s(reg_tmp7.xyzz, -uniforms.f[81].yyyy, reg_tmp6.xyzz)).xyz;
    reg_tmp6 = min(uniforms.f[81].xxxx, reg_tmp6);
    reg_tmp6 = max(-uniforms.f[81].xxxx, reg_tmp6);
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp6.xxxx, reg_tmp6.xxxx)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp6.xxxx)).y;
    reg_tmp4.x = (reg_tmp1.xxxx).x;
    reg_tmp5.x = (reg_tmp1.yyyy).x;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp6.yyyy, reg_tmp6.yyyy)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp6.yyyy)).y;
    reg_tmp4.y = (reg_tmp1.xxxx).y;
    reg_tmp5.y = (reg_tmp1.yyyy).y;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp6.zzzz, reg_tmp6.zzzz)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp6.zzzz)).y;
    reg_tmp4.z = (reg_tmp1.xxxx).z;
    reg_tmp5.z = (reg_tmp1.yyyy).z;
    reg_tmp2.x = (mul_s(reg_tmp4.yyyy, reg_tmp5.zzzz)).x;
    reg_tmp2.y = (mul_s(reg_tmp5.yyyy, reg_tmp5.zzzz)).y;
    reg_tmp6.x = (mul_s(reg_tmp4.yyyy, reg_tmp4.zzzz)).x;
    reg_tmp6.y = (reg_tmp5.zzzz).y;
    reg_tmp6.z = (mul_s(-reg_tmp5.yyyy, reg_tmp4.zzzz)).z;
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    reg_tmp7.x = (mul_s(-reg_tmp2.xxxx, reg_tmp4.xxxx)).x;
    reg_tmp7.x = (fma_s(reg_tmp5.yyyy, reg_tmp5.xxxx, reg_tmp7.xxxx)).x;
    reg_tmp7.y = (mul_s(reg_tmp4.zzzz, reg_tmp4.xxxx)).y;
    reg_tmp7.z = (mul_s(reg_tmp2.yyyy, reg_tmp4.xxxx)).z;
    reg_tmp7.z = (fma_s(reg_tmp4.yyyy, reg_tmp5.xxxx, reg_tmp7.zzzz)).z;
    reg_tmp7.w = (uniforms.f[0].xxxx).w;
    reg_tmp8.x = (mul_s(reg_tmp2.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp8.x = (fma_s(reg_tmp5.yyyy, reg_tmp4.xxxx, reg_tmp8.xxxx)).x;
    reg_tmp8.y = (mul_s(-reg_tmp4.zzzz, reg_tmp5.xxxx)).y;
    reg_tmp8.z = (mul_s(-reg_tmp2.yyyy, reg_tmp5.xxxx)).z;
    reg_tmp8.z = (fma_s(reg_tmp4.yyyy, reg_tmp4.xxxx, reg_tmp8.zzzz)).z;
    reg_tmp8.w = (uniforms.f[0].xxxx).w;
    reg_tmp9 = uniforms.f[0].xxxz;
    return false;
}
bool sub_3() {
    reg_tmp6.x = (uniforms.f[90].xxxx).x;
    reg_tmp6.y = (uniforms.f[91].xxxx).y;
    reg_tmp6.z = (uniforms.f[92].xxxx).z;
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    reg_tmp7.x = (uniforms.f[90].yyyy).x;
    reg_tmp7.y = (uniforms.f[91].yyyy).y;
    reg_tmp7.z = (uniforms.f[92].yyyy).z;
    reg_tmp7.w = (uniforms.f[0].xxxx).w;
    reg_tmp8.x = (uniforms.f[90].zzzz).x;
    reg_tmp8.y = (uniforms.f[91].zzzz).y;
    reg_tmp8.z = (uniforms.f[92].zzzz).z;
    reg_tmp8.w = (uniforms.f[0].xxxx).w;
    reg_tmp9.x = (uniforms.f[90].wwww).x;
    reg_tmp9.y = (uniforms.f[91].wwww).y;
    reg_tmp9.z = (uniforms.f[92].wwww).z;
    reg_tmp9.w = (uniforms.f[0].zzzz).w;
    return false;
}
bool sub_6() {
    reg_tmp2 = uniforms.f[90];
    reg_tmp3 = uniforms.f[91];
    reg_tmp4 = uniforms.f[92];
    reg_tmp5 = uniforms.f[0].xxxz;
    reg_tmp6 = mul_s(uniforms.f[86].xxxx, reg_tmp2);
    reg_tmp6 = fma_s(reg_tmp3, uniforms.f[86].yyyy, reg_tmp6);
    reg_tmp6 = fma_s(reg_tmp4, uniforms.f[86].zzzz, reg_tmp6);
    reg_tmp6 = fma_s(reg_tmp5, uniforms.f[86].wwww, reg_tmp6);
    reg_tmp7 = mul_s(uniforms.f[87].xxxx, reg_tmp2);
    reg_tmp7 = fma_s(reg_tmp3, uniforms.f[87].yyyy, reg_tmp7);
    reg_tmp7 = fma_s(reg_tmp4, uniforms.f[87].zzzz, reg_tmp7);
    reg_tmp7 = fma_s(reg_tmp5, uniforms.f[87].wwww, reg_tmp7);
    reg_tmp8 = mul_s(uniforms.f[88].xxxx, reg_tmp2);
    reg_tmp8 = fma_s(reg_tmp3, uniforms.f[88].yyyy, reg_tmp8);
    reg_tmp8 = fma_s(reg_tmp4, uniforms.f[88].zzzz, reg_tmp8);
    reg_tmp8 = fma_s(reg_tmp5, uniforms.f[88].wwww, reg_tmp8);
    reg_tmp9 = mul_s(uniforms.f[89].xxxx, reg_tmp2);
    reg_tmp9 = fma_s(reg_tmp3, uniforms.f[89].yyyy, reg_tmp9);
    reg_tmp9 = fma_s(reg_tmp4, uniforms.f[89].zzzz, reg_tmp9);
    reg_tmp9 = fma_s(reg_tmp5, uniforms.f[89].wwww, reg_tmp9);
    return false;
}
bool sub_7() {
    reg_tmp2.x = rcp_s(uniforms.f[81].y);
    reg_tmp2.xy = (mul_s(uniforms.f[2 + address_registers.x].zwww, reg_tmp2.xxxx)).xy;
    reg_tmp2.xy = (uniforms.f[0].yyyy + reg_tmp2.xyyy).xy;
    reg_tmp3.xy = (floor(reg_tmp2.xyyy)).xy;
    reg_tmp2.xy = (mul_s(uniforms.f[81].yyyy, reg_tmp3.xyyy)).xy;
    reg_tmp2.xy = (uniforms.f[2 + address_registers.x].zwww + -reg_tmp2.xyyy).xy;
    reg_tmp0.xy = (min(uniforms.f[81].xxxx, -reg_tmp2.xyyy)).xy;
    reg_tmp0.xy = (max(-uniforms.f[81].xxxx, reg_tmp0.xyyy)).xy;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp0.xxxx, reg_tmp0.xxxx)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.xxxx)).y;
    reg_tmp5.x = (uniforms.f[5 + address_registers.x].wwww).x;
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_8();
    }
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_9();
    }
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_10();
    }
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_11();
    }
    reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    reg_tmp4.z = (uniforms.f[83].xxxx).z;
    reg_tmp4.w = (-uniforms.f[83].yyyy).w;
    reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[3 + address_registers.x].xyyy)).xy;
    reg_tmp4.z = (-uniforms.f[3 + address_registers.x].zzzz).z;
    reg_tmp4.w = (-uniforms.f[3 + address_registers.x].wwww).w;
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    reg_tmp11.xy = (reg_tmp5.xyyy).xy;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp0.yyyy, reg_tmp0.yyyy)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.yyyy)).y;
    reg_tmp5.x = (uniforms.f[6 + address_registers.x].wwww).x;
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_12();
    }
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_13();
    }
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_14();
    }
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_15();
    }
    reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    reg_tmp4.z = (uniforms.f[83].zzzz).z;
    reg_tmp4.w = (-uniforms.f[83].wwww).w;
    reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[4 + address_registers.x].xyyy)).xy;
    reg_tmp4.z = (-uniforms.f[4 + address_registers.x].zzzz).z;
    reg_tmp4.w = (-uniforms.f[4 + address_registers.x].wwww).w;
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    reg_tmp12.xy = (reg_tmp5.xyyy).xy;
    return false;
}
bool sub_8() {
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_9() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_10() {
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_11() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_12() {
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_13() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_14() {
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_15() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_0() {
    {
        sub_1();
    }
    reg_tmp10.xy = (uniforms.f[84].xyyy + reg_tmp10.xyyy).xy;
    reg_tmp10.xy = (mul_s(uniforms.f[2 + address_registers.x].xyyy, reg_tmp10.xyyy)).xy;
    reg_tmp0 = uniforms.f[7 + address_registers.x];
    {
        sub_2();
    }
    reg_tmp2.x = dot_s(reg_tmp10, reg_tmp6);
    reg_tmp2.y = dot_s(reg_tmp10, reg_tmp7);
    reg_tmp2.z = dot_s(reg_tmp10, reg_tmp8);
    reg_tmp2.w = dot_s(reg_tmp10, reg_tmp9);
    reg_tmp10 = reg_tmp2;
    {
        sub_3();
    }
    reg_tmp2.x = dot_s(reg_tmp10, reg_tmp6);
    reg_tmp2.y = dot_s(reg_tmp10, reg_tmp7);
    reg_tmp2.z = dot_s(reg_tmp10, reg_tmp8);
    reg_tmp2.w = dot_s(uniforms.f[0].xxxz, reg_tmp10);
    reg_tmp3.xyz = (uniforms.f[5 + address_registers.x].xyzz).xyz;
    reg_tmp3.xyz = (uniforms.f[85].xyzz + -reg_tmp3.xyzz).xyz;
    reg_tmp4.x = dot_3(reg_tmp3.xyz, reg_tmp3.xyz);
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
    if (conditional_code.x) {
        sub_4();
    } else {
        sub_5();
    }
    reg_tmp3.xyz = (mul_s(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
    reg_tmp10.xyz = (uniforms.f[5 + address_registers.x].xyzz + reg_tmp2.xyzz).xyz;
    reg_tmp10.xyz = (fma_s(reg_tmp3.xyzz, uniforms.f[84].zzzz, reg_tmp10.xyzz)).xyz;
    {
        sub_6();
    }
    reg_tmp2 = reg_tmp10;
    reg_tmp10.x = dot_s(reg_tmp2, reg_tmp6);
    reg_tmp10.y = dot_s(reg_tmp2, reg_tmp7);
    reg_tmp10.z = dot_s(reg_tmp2, reg_tmp8);
    reg_tmp10.w = dot_s(reg_tmp2, reg_tmp9);
    reg_tmp2 = uniforms.f[1 + address_registers.x];
    reg_tmp3 = max(uniforms.f[0].xxxx, reg_tmp2);
    reg_tmp2 = min(uniforms.f[0].zzzz, reg_tmp3);
    reg_tmp13 = reg_tmp2;
    {
        sub_7();
    }
    {
        sub_16();
    }
    return true;
}
bool sub_4() {
    reg_tmp4.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_5() {
    reg_tmp4.x = rsq_s(reg_tmp4.x);
    return false;
}
// reference: 5B835BF59B2B2298, 655FFD4060F406B6
// shader: 8B30, B6B08DE01E86DE2D
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_2 = byteround(clamp((vec3(1.0) - combiner_buffer.rgb) * (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: AE3D27E93E737D07, B6B08DE01E86DE2D
// program: 655FFD4060F406B6, 13A54CCD8AA1DDA2, B6B08DE01E86DE2D
// shader: 8B30, D6B195DAA984D13A
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_2 = byteround(clamp((vec3(1.0) - combiner_buffer.rgb) * (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: E7C524FDD196C12C, D6B195DAA984D13A
// program: 7C96EBECB346C618, 1C4CBC8096EA16CD, D6B195DAA984D13A
// shader: 8B30, 77A77A3265B65D73
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((vec3(1.0) - combiner_buffer.rgb) * (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: E7C524FD21414A81, 77A77A3265B65D73
// program: 7C96EBECB346C618, 1C4CBC8096EA16CD, 77A77A3265B65D73
// shader: 8B30, 695BB514E3AF063F
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].aaa);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((vec3(1.0) - combiner_buffer.rgb) * (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D77D3BB682EC36A8, 695BB514E3AF063F
// program: 7C96EBECB346C618, 1C4CBC8096EA16CD, 695BB514E3AF063F
// program: 655FFD4060F406B6, 13A54CCD8AA1DDA2, B6B08DE0C83FF4C8
// shader: 8B31, FBDEFFFAE3D442C5

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location = 0) in vec4 vs_in_reg0;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_1();
bool sub_15();
bool sub_2();
bool sub_5();
bool sub_6();
bool sub_7();
bool sub_8();
bool sub_9();
bool sub_10();
bool sub_11();
bool sub_12();
bool sub_13();
bool sub_14();
bool sub_0();
bool sub_3();
bool sub_4();

bool exec_shader() {
    sub_0();
    return true;
}

bool sub_1() {
    address_registers.x = (ivec2(vs_in_reg0.zz)).x;
    reg_tmp10 = uniforms.f[0].xxxz;
    reg_tmp10.xy = (vs_in_reg0.xyyy).xy;
    reg_tmp11 = uniforms.f[0].xxxx;
    reg_tmp12 = uniforms.f[0].xxxx;
    reg_tmp13 = uniforms.f[0].zzzz;
    reg_tmp4 = uniforms.f[0].xxxx;
    reg_tmp5 = uniforms.f[0].xxxx;
    return false;
}
bool sub_15() {
    vs_out_attr0 = reg_tmp10;
    reg_tmp13 = mul_s(uniforms.f[82], reg_tmp13);
    vs_out_attr1 = reg_tmp13;
    reg_tmp11.y = (uniforms.f[0].zzzz + -reg_tmp11.yyyy).y;
    reg_tmp12.y = (uniforms.f[0].zzzz + -reg_tmp12.yyyy).y;
    reg_tmp14.y = (uniforms.f[81].wwww).y;
    reg_tmp14.x = (mul_s(uniforms.f[0].wwww, reg_tmp14.yyyy)).x;
    reg_tmp2.x = rcp_s(reg_tmp14.x);
    reg_tmp14.z = (reg_tmp2.xxxx).z;
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp11.xyyy).xy;
    reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    reg_tmp11.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp12.xyyy).xy;
    reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    reg_tmp12.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    vs_out_attr2 = reg_tmp11;
    vs_out_attr3 = reg_tmp12;
    return false;
}
bool sub_2() {
    reg_tmp6.x = (uniforms.f[90].xxxx).x;
    reg_tmp6.y = (uniforms.f[91].xxxx).y;
    reg_tmp6.z = (uniforms.f[92].xxxx).z;
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    reg_tmp7.x = (uniforms.f[90].yyyy).x;
    reg_tmp7.y = (uniforms.f[91].yyyy).y;
    reg_tmp7.z = (uniforms.f[92].yyyy).z;
    reg_tmp7.w = (uniforms.f[0].xxxx).w;
    reg_tmp8.x = (uniforms.f[90].zzzz).x;
    reg_tmp8.y = (uniforms.f[91].zzzz).y;
    reg_tmp8.z = (uniforms.f[92].zzzz).z;
    reg_tmp8.w = (uniforms.f[0].xxxx).w;
    reg_tmp9.x = (uniforms.f[90].wwww).x;
    reg_tmp9.y = (uniforms.f[91].wwww).y;
    reg_tmp9.z = (uniforms.f[92].wwww).z;
    reg_tmp9.w = (uniforms.f[0].zzzz).w;
    return false;
}
bool sub_5() {
    reg_tmp2 = uniforms.f[90];
    reg_tmp3 = uniforms.f[91];
    reg_tmp4 = uniforms.f[92];
    reg_tmp5 = uniforms.f[0].xxxz;
    reg_tmp6 = mul_s(uniforms.f[86].xxxx, reg_tmp2);
    reg_tmp6 = fma_s(reg_tmp3, uniforms.f[86].yyyy, reg_tmp6);
    reg_tmp6 = fma_s(reg_tmp4, uniforms.f[86].zzzz, reg_tmp6);
    reg_tmp6 = fma_s(reg_tmp5, uniforms.f[86].wwww, reg_tmp6);
    reg_tmp7 = mul_s(uniforms.f[87].xxxx, reg_tmp2);
    reg_tmp7 = fma_s(reg_tmp3, uniforms.f[87].yyyy, reg_tmp7);
    reg_tmp7 = fma_s(reg_tmp4, uniforms.f[87].zzzz, reg_tmp7);
    reg_tmp7 = fma_s(reg_tmp5, uniforms.f[87].wwww, reg_tmp7);
    reg_tmp8 = mul_s(uniforms.f[88].xxxx, reg_tmp2);
    reg_tmp8 = fma_s(reg_tmp3, uniforms.f[88].yyyy, reg_tmp8);
    reg_tmp8 = fma_s(reg_tmp4, uniforms.f[88].zzzz, reg_tmp8);
    reg_tmp8 = fma_s(reg_tmp5, uniforms.f[88].wwww, reg_tmp8);
    reg_tmp9 = mul_s(uniforms.f[89].xxxx, reg_tmp2);
    reg_tmp9 = fma_s(reg_tmp3, uniforms.f[89].yyyy, reg_tmp9);
    reg_tmp9 = fma_s(reg_tmp4, uniforms.f[89].zzzz, reg_tmp9);
    reg_tmp9 = fma_s(reg_tmp5, uniforms.f[89].wwww, reg_tmp9);
    return false;
}
bool sub_6() {
    reg_tmp2.x = rcp_s(uniforms.f[81].y);
    reg_tmp2.xy = (mul_s(uniforms.f[2 + address_registers.x].zwww, reg_tmp2.xxxx)).xy;
    reg_tmp2.xy = (uniforms.f[0].yyyy + reg_tmp2.xyyy).xy;
    reg_tmp3.xy = (floor(reg_tmp2.xyyy)).xy;
    reg_tmp2.xy = (mul_s(uniforms.f[81].yyyy, reg_tmp3.xyyy)).xy;
    reg_tmp2.xy = (uniforms.f[2 + address_registers.x].zwww + -reg_tmp2.xyyy).xy;
    reg_tmp0.xy = (min(uniforms.f[81].xxxx, -reg_tmp2.xyyy)).xy;
    reg_tmp0.xy = (max(-uniforms.f[81].xxxx, reg_tmp0.xyyy)).xy;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp0.xxxx, reg_tmp0.xxxx)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.xxxx)).y;
    reg_tmp5.x = (uniforms.f[5 + address_registers.x].wwww).x;
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_7();
    }
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_8();
    }
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_9();
    }
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_10();
    }
    reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    reg_tmp4.z = (uniforms.f[83].xxxx).z;
    reg_tmp4.w = (-uniforms.f[83].yyyy).w;
    reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[3 + address_registers.x].xyyy)).xy;
    reg_tmp4.z = (-uniforms.f[3 + address_registers.x].zzzz).z;
    reg_tmp4.w = (-uniforms.f[3 + address_registers.x].wwww).w;
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    reg_tmp11.xy = (reg_tmp5.xyyy).xy;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp0.yyyy, reg_tmp0.yyyy)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.yyyy)).y;
    reg_tmp5.x = (uniforms.f[6 + address_registers.x].wwww).x;
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_11();
    }
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_12();
    }
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_13();
    }
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_14();
    }
    reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    reg_tmp4.z = (uniforms.f[83].zzzz).z;
    reg_tmp4.w = (-uniforms.f[83].wwww).w;
    reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[4 + address_registers.x].xyyy)).xy;
    reg_tmp4.z = (-uniforms.f[4 + address_registers.x].zzzz).z;
    reg_tmp4.w = (-uniforms.f[4 + address_registers.x].wwww).w;
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    reg_tmp12.xy = (reg_tmp5.xyyy).xy;
    return false;
}
bool sub_7() {
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_8() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_9() {
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_10() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_11() {
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_12() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_13() {
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_14() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_0() {
    {
        sub_1();
    }
    reg_tmp10.xy = (uniforms.f[84].xyyy + reg_tmp10.xyyy).xy;
    reg_tmp10.xy = (mul_s(uniforms.f[2 + address_registers.x].xyyy, reg_tmp10.xyyy)).xy;
    {
        sub_2();
    }
    reg_tmp2.x = dot_s(reg_tmp10, reg_tmp6);
    reg_tmp2.y = dot_s(reg_tmp10, reg_tmp7);
    reg_tmp2.z = dot_s(reg_tmp10, reg_tmp8);
    reg_tmp2.w = dot_s(uniforms.f[0].xxxz, reg_tmp10);
    reg_tmp3.xyz = (uniforms.f[5 + address_registers.x].xyzz).xyz;
    reg_tmp3.xyz = (uniforms.f[85].xyzz + -reg_tmp3.xyzz).xyz;
    reg_tmp4.x = dot_3(reg_tmp3.xyz, reg_tmp3.xyz);
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
    if (conditional_code.x) {
        sub_3();
    } else {
        sub_4();
    }
    reg_tmp3.xyz = (mul_s(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
    reg_tmp10.xyz = (uniforms.f[5 + address_registers.x].xyzz + reg_tmp2.xyzz).xyz;
    reg_tmp10.xyz = (fma_s(reg_tmp3.xyzz, uniforms.f[84].zzzz, reg_tmp10.xyzz)).xyz;
    {
        sub_5();
    }
    reg_tmp2 = reg_tmp10;
    reg_tmp10.x = dot_s(reg_tmp2, reg_tmp6);
    reg_tmp10.y = dot_s(reg_tmp2, reg_tmp7);
    reg_tmp10.z = dot_s(reg_tmp2, reg_tmp8);
    reg_tmp10.w = dot_s(reg_tmp2, reg_tmp9);
    reg_tmp2 = uniforms.f[1 + address_registers.x];
    reg_tmp3 = max(uniforms.f[0].xxxx, reg_tmp2);
    reg_tmp2 = min(uniforms.f[0].zzzz, reg_tmp3);
    reg_tmp13 = reg_tmp2;
    {
        sub_6();
    }
    {
        sub_15();
    }
    return true;
}
bool sub_3() {
    reg_tmp4.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_4() {
    reg_tmp4.x = rsq_s(reg_tmp4.x);
    return false;
}
// reference: 6590628EAA0789EF, FBDEFFFAE3D442C5
// program: FBDEFFFAE3D442C5, 13A54CCD8AA1DDA2, B6B08DE0C83FF4C8
// shader: 8B30, BA3F71487BA61D01
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.r) + (texcolor1.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 0FEF1F2F49AF6349, BA3F71487BA61D01
// program: FBDEFFFAE3D442C5, 13A54CCD8AA1DDA2, BA3F71487BA61D01
// shader: 8B30, FECCDB07121C469A
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].aaa);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((vec3(1.0) - combiner_buffer.rgb) * (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 6FB2BCD49EEC8605, FECCDB07121C469A
// program: 7C96EBECB346C618, 1C4CBC8096EA16CD, FECCDB07121C469A
// shader: 8B30, 6064ABBB985A5B22
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 2A23FE70A6099509, 6064ABBB985A5B22
// program: BEC1B215F99385B9, 0D30074279C2FEED, 6064ABBB985A5B22
// shader: 8B30, 9CE5E607337B297A
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(light_vector, normal)));
refl_value.g = (lut_scale_rg * LookupLightingLUTSigned(5, dot(light_vector, normal)));
refl_value.b = (lut_scale_rb * LookupLightingLUTSigned(4, dot(light_vector, normal)));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (secondary_fragment_color.r);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (texcolor0.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) - (texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: F20DB75BD5534DAF, 9CE5E607337B297A
// program: F611EDC1B656F4E7, 0D30074279C2FEED, 9CE5E607337B297A
// shader: 8B30, F809C797ACA3151F
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(light_vector, normal)));
refl_value.g = (lut_scale_rg * LookupLightingLUTSigned(5, dot(light_vector, normal)));
refl_value.b = (lut_scale_rb * LookupLightingLUTSigned(4, dot(light_vector, normal)));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (secondary_fragment_color.r);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (texcolor0.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) - (texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) * (const_color[4].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 314FAD7D3936E34B, F809C797ACA3151F
// program: F611EDC1B656F4E7, 0D30074279C2FEED, F809C797ACA3151F
// reference: 15D7A4B518DE44EA, 655FFD4060F406B6
// shader: 8B30, 1041172C77D1741F
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.r) * (texcolor1.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_2 = byteround(clamp((vec3(1.0) - combiner_buffer.rgb) * (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 6AF29988B26CD5C1, 1041172C77D1741F
// program: 655FFD4060F406B6, 13A54CCD8AA1DDA2, 1041172C77D1741F
// shader: 8B30, EDB11957E1308F8F
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.r);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_2 = byteround(clamp((vec3(1.0) - combiner_buffer.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 7037091908602FB1, EDB11957E1308F8F
// program: 655FFD4060F406B6, 13A54CCD8AA1DDA2, EDB11957E1308F8F
// reference: 2BC49DCE29F2EF9D, FBDEFFFAE3D442C5
// shader: 8B30, FECCDB075D3282D4
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((vec3(1.0) - combiner_buffer.rgb) * (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 5F0AA39FC6A18B95, FECCDB075D3282D4
// program: 7C96EBECB346C618, 1C4CBC8096EA16CD, FECCDB075D3282D4
// shader: 8B30, 17F705211262CD00
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((vec3(1.0) - combiner_buffer.rgb) * (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: E7C524FDDAA13B38, 17F705211262CD00
// program: 7C96EBECB346C618, 1C4CBC8096EA16CD, 17F705211262CD00
// shader: 8B31, 30F46A99686BC4D4

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;
out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_5();
bool sub_3();
bool sub_1();
bool sub_2();
bool sub_4();
bool sub_6();
bool sub_9();
bool sub_10();
bool sub_16();
bool sub_17();
bool sub_18();
bool sub_19();
bool sub_21();
bool sub_23();
bool sub_24();
bool sub_25();
bool sub_26();
bool sub_27();
bool sub_28();
bool sub_29();
bool sub_30();
bool sub_31();
bool sub_32();
bool sub_33();
bool sub_34();
bool sub_11();
bool sub_12();
bool sub_13();
bool sub_14();
bool sub_15();
bool sub_20();
bool sub_22();
bool sub_0();
bool sub_7();
bool sub_8();

bool exec_shader() {
    sub_0();
    return true;
}

bool sub_5() {
    uint jmp_to = 0u;
    while (true) {
        switch (jmp_to) {
        case 0u: {
            reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
            reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
            reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
            reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
            reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
            reg_tmp6.x = rsq_s(reg_tmp6.x);
            reg_tmp7.x = rsq_s(reg_tmp7.x);
            reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            reg_tmp0 = uniforms.f[93].yxxx;
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            reg_tmp4 = mul_s(uniforms.f[94].xxxx, reg_tmp4);
            conditional_code = greaterThanEqual(uniforms.f[93].xx, reg_tmp4.xx);
            reg_tmp4 = vec4(rsq_s(reg_tmp4.x));
            reg_tmp5 = mul_s(uniforms.f[94].xxxx, reg_tmp14);
            if (conditional_code.x) {
                { jmp_to = 18u; break; }
            }
            reg_tmp0.z = rcp_s(reg_tmp4.x);
            reg_tmp0.xy = (mul_s(reg_tmp5, reg_tmp4)).xy;
        }
        case 18u: {
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_3() {
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    reg_tmp4.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_1() {
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    if (uniforms.b[0]) {
        sub_2();
    } else {
        sub_4();
    }
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    {
        sub_5();
    }
    vs_out_attr2 = reg_tmp15;
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    if (all(conditional_code)) {
        sub_6();
    }
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_2() {
    reg_tmp7 = uniforms.f[93].xxxx;
    reg_tmp12 = uniforms.f[93].xxxx;
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    {
        sub_3();
    }
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    {
        sub_3();
    }
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    {
        sub_3();
    }
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    {
        sub_3();
    }
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    reg_tmp10 = reg_tmp7;
    return false;
}
bool sub_4() {
    reg_tmp7 = reg_tmp15;
    reg_tmp10.x = dot_s(uniforms.f[10], reg_tmp7);
    reg_tmp10.y = dot_s(uniforms.f[11], reg_tmp7);
    reg_tmp10.z = dot_s(uniforms.f[12], reg_tmp7);
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    reg_tmp12.x = dot_3(uniforms.f[10].xyz, reg_tmp14.xyz);
    reg_tmp12.y = dot_3(uniforms.f[11].xyz, reg_tmp14.xyz);
    reg_tmp12.z = dot_3(uniforms.f[12].xyz, reg_tmp14.xyz);
    return false;
}
bool sub_6() {
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_9() {
    reg_tmp0.xy = (uniforms.f[0].xxxx).xy;
    if (uniforms.b[2]) {
        sub_10();
    } else {
        sub_16();
    }
    return false;
}
bool sub_10() {
    {
        sub_11();
    }
    reg_tmp3.x = dot_s(uniforms.f[1].xywz, reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2].xywz, reg_tmp6);
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_16() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_17();
    } else {
        sub_18();
    }
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_17() {
    reg_tmp6 = reg_tmp10;
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    reg_tmp3.z = dot_s(uniforms.f[3], reg_tmp6);
    reg_tmp0.xy = (mul_s(uniforms.f[9].xyyy, reg_tmp3.zzzz)).xy;
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_18() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_19();
    } else {
        sub_21();
    }
    return false;
}
bool sub_19() {
    {
        sub_20();
    }
    reg_tmp3.x = dot_3(uniforms.f[1].xyz, reg_tmp6.xyz);
    reg_tmp3.y = dot_3(uniforms.f[2].xyz, reg_tmp6.xyz);
    reg_tmp3.z = dot_3(uniforms.f[3].xyz, reg_tmp6.xyz);
    return false;
}
bool sub_21() {
    {
        sub_22();
    }
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    return false;
}
bool sub_23() {
    reg_tmp0.xy = (uniforms.f[0].yyyy).xy;
    if (uniforms.b[3]) {
        sub_24();
    } else {
        sub_25();
    }
    return false;
}
bool sub_24() {
    {
        sub_11();
    }
    reg_tmp4.x = dot_s(uniforms.f[4].xywz, reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5].xywz, reg_tmp6);
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_25() {
    if (uniforms.b[5]) {
        sub_26();
    } else {
        sub_29();
    }
    return false;
}
bool sub_26() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_27();
    } else {
        sub_28();
    }
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_27() {
    reg_tmp6 = reg_tmp10;
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    reg_tmp4.z = dot_s(uniforms.f[6], reg_tmp6);
    reg_tmp6.w = rcp_s(reg_tmp4.z);
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    reg_tmp4.xy = (uniforms.f[9].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_28() {
    {
        sub_22();
    }
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    return false;
}
bool sub_29() {
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_30() {
    reg_tmp0.xy = (uniforms.f[0].zzzz).xy;
    if (uniforms.b[4]) {
        sub_31();
    } else {
        sub_32();
    }
    return false;
}
bool sub_31() {
    {
        sub_11();
    }
    reg_tmp5.x = dot_s(uniforms.f[7].xywz, reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8].xywz, reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_32() {
    if (uniforms.b[6]) {
        sub_33();
    } else {
        sub_34();
    }
    return false;
}
bool sub_33() {
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    {
        sub_22();
    }
    reg_tmp5.x = dot_s(uniforms.f[7], reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8], reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_34() {
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
bool sub_11() {
    conditional_code = equal(uniforms.f[93].yz, reg_tmp0.xy);
    if (all(not(conditional_code))) {
        sub_12();
    } else {
        sub_13();
    }
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_12() {
    reg_tmp6.xy = (vs_in_reg4.xyyy).xy;
    return false;
}
bool sub_13() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_14();
    } else {
        sub_15();
    }
    return false;
}
bool sub_14() {
    reg_tmp6.xy = (vs_in_reg5.xyyy).xy;
    return false;
}
bool sub_15() {
    reg_tmp6.xy = (vs_in_reg6.xyyy).xy;
    return false;
}
bool sub_20() {
    reg_tmp2 = -reg_tmp15;
    reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
    reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_22() {
    reg_tmp1 = reg_tmp14;
    reg_tmp2.w = dot_3(reg_tmp1.xyz, reg_tmp1.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp1 = mul_s(reg_tmp1, reg_tmp2.wwww);
    reg_tmp1 = mul_s(uniforms.f[94].xxxx, reg_tmp1);
    reg_tmp6.xy = (uniforms.f[94].xxxx + reg_tmp1.xyyy).xy;
    return false;
}
bool sub_0() {
    {
        sub_1();
    }
    if (uniforms.b[1]) {
        sub_7();
    } else {
        sub_8();
    }
    vs_out_attr3 = reg_tmp2;
    {
        sub_9();
    }
    {
        sub_23();
    }
    {
        sub_30();
    }
    return true;
}
bool sub_7() {
    reg_tmp0 = vec4(dot_3(uniforms.f[83].xyz, reg_tmp12.xyz));
    reg_tmp0 = max(uniforms.f[93].xxxx, reg_tmp0);
    reg_tmp0 = mul_s(uniforms.f[84], reg_tmp0);
    reg_tmp0 = uniforms.f[85] + reg_tmp0;
    reg_tmp0.w = (uniforms.f[93].yyyy).w;
    reg_tmp1 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
    reg_tmp2 = mul_s(reg_tmp0, reg_tmp1);
    return false;
}
bool sub_8() {
    reg_tmp2 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
    return false;
}
// reference: ABAF98651E8111D6, 30F46A99686BC4D4
// shader: 8B30, 4D5CFC1E9D9B8FEC
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = (const_color[0].a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D4F4BEF93E852CAC, 4D5CFC1E9D9B8FEC
// program: 30F46A99686BC4D4, 0D30074279C2FEED, 4D5CFC1E9D9B8FEC
// shader: 8B31, 9C4924FA28F6423B

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location = 0) in vec4 vs_in_reg0;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_1();
bool sub_19();
bool sub_2();
bool sub_9();
bool sub_10();
bool sub_11();
bool sub_12();
bool sub_13();
bool sub_14();
bool sub_15();
bool sub_16();
bool sub_17();
bool sub_18();
bool sub_0();
bool sub_3();
bool sub_4();
bool sub_5();
bool sub_6();
bool sub_7();
bool sub_8();

bool exec_shader() {
    sub_0();
    return true;
}

bool sub_1() {
    address_registers.x = (ivec2(vs_in_reg0.zz)).x;
    reg_tmp10 = uniforms.f[0].xxxz;
    reg_tmp10.xy = (vs_in_reg0.xyyy).xy;
    reg_tmp11 = uniforms.f[0].xxxx;
    reg_tmp12 = uniforms.f[0].xxxx;
    reg_tmp13 = uniforms.f[0].zzzz;
    reg_tmp4 = uniforms.f[0].xxxx;
    reg_tmp5 = uniforms.f[0].xxxx;
    return false;
}
bool sub_19() {
    vs_out_attr0 = reg_tmp10;
    reg_tmp13 = mul_s(uniforms.f[82], reg_tmp13);
    vs_out_attr1 = reg_tmp13;
    reg_tmp11.y = (uniforms.f[0].zzzz + -reg_tmp11.yyyy).y;
    reg_tmp12.y = (uniforms.f[0].zzzz + -reg_tmp12.yyyy).y;
    reg_tmp14.y = (uniforms.f[81].wwww).y;
    reg_tmp14.x = (mul_s(uniforms.f[0].wwww, reg_tmp14.yyyy)).x;
    reg_tmp2.x = rcp_s(reg_tmp14.x);
    reg_tmp14.z = (reg_tmp2.xxxx).z;
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp11.xyyy).xy;
    reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    reg_tmp11.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp12.xyyy).xy;
    reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    reg_tmp12.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    vs_out_attr2 = reg_tmp11;
    vs_out_attr3 = reg_tmp12;
    return false;
}
bool sub_2() {
    reg_tmp1.xyz = (uniforms.f[92].xyzz).xyz;
    reg_tmp1.w = (uniforms.f[0].xxxx).w;
    return false;
}
bool sub_9() {
    reg_tmp2 = uniforms.f[90];
    reg_tmp3 = uniforms.f[91];
    reg_tmp4 = uniforms.f[92];
    reg_tmp5 = uniforms.f[0].xxxz;
    reg_tmp6 = mul_s(uniforms.f[86].xxxx, reg_tmp2);
    reg_tmp6 = fma_s(reg_tmp3, uniforms.f[86].yyyy, reg_tmp6);
    reg_tmp6 = fma_s(reg_tmp4, uniforms.f[86].zzzz, reg_tmp6);
    reg_tmp6 = fma_s(reg_tmp5, uniforms.f[86].wwww, reg_tmp6);
    reg_tmp7 = mul_s(uniforms.f[87].xxxx, reg_tmp2);
    reg_tmp7 = fma_s(reg_tmp3, uniforms.f[87].yyyy, reg_tmp7);
    reg_tmp7 = fma_s(reg_tmp4, uniforms.f[87].zzzz, reg_tmp7);
    reg_tmp7 = fma_s(reg_tmp5, uniforms.f[87].wwww, reg_tmp7);
    reg_tmp8 = mul_s(uniforms.f[88].xxxx, reg_tmp2);
    reg_tmp8 = fma_s(reg_tmp3, uniforms.f[88].yyyy, reg_tmp8);
    reg_tmp8 = fma_s(reg_tmp4, uniforms.f[88].zzzz, reg_tmp8);
    reg_tmp8 = fma_s(reg_tmp5, uniforms.f[88].wwww, reg_tmp8);
    reg_tmp9 = mul_s(uniforms.f[89].xxxx, reg_tmp2);
    reg_tmp9 = fma_s(reg_tmp3, uniforms.f[89].yyyy, reg_tmp9);
    reg_tmp9 = fma_s(reg_tmp4, uniforms.f[89].zzzz, reg_tmp9);
    reg_tmp9 = fma_s(reg_tmp5, uniforms.f[89].wwww, reg_tmp9);
    return false;
}
bool sub_10() {
    reg_tmp2.x = rcp_s(uniforms.f[81].y);
    reg_tmp2.xy = (mul_s(uniforms.f[2 + address_registers.x].zwww, reg_tmp2.xxxx)).xy;
    reg_tmp2.xy = (uniforms.f[0].yyyy + reg_tmp2.xyyy).xy;
    reg_tmp3.xy = (floor(reg_tmp2.xyyy)).xy;
    reg_tmp2.xy = (mul_s(uniforms.f[81].yyyy, reg_tmp3.xyyy)).xy;
    reg_tmp2.xy = (uniforms.f[2 + address_registers.x].zwww + -reg_tmp2.xyyy).xy;
    reg_tmp0.xy = (min(uniforms.f[81].xxxx, -reg_tmp2.xyyy)).xy;
    reg_tmp0.xy = (max(-uniforms.f[81].xxxx, reg_tmp0.xyyy)).xy;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp0.xxxx, reg_tmp0.xxxx)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.xxxx)).y;
    reg_tmp5.x = (uniforms.f[5 + address_registers.x].wwww).x;
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_11();
    }
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_12();
    }
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_13();
    }
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_14();
    }
    reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    reg_tmp4.z = (uniforms.f[83].xxxx).z;
    reg_tmp4.w = (-uniforms.f[83].yyyy).w;
    reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[3 + address_registers.x].xyyy)).xy;
    reg_tmp4.z = (-uniforms.f[3 + address_registers.x].zzzz).z;
    reg_tmp4.w = (-uniforms.f[3 + address_registers.x].wwww).w;
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    reg_tmp11.xy = (reg_tmp5.xyyy).xy;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp0.yyyy, reg_tmp0.yyyy)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.yyyy)).y;
    reg_tmp5.x = (uniforms.f[6 + address_registers.x].wwww).x;
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_15();
    }
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_16();
    }
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_17();
    }
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_18();
    }
    reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    reg_tmp4.z = (uniforms.f[83].zzzz).z;
    reg_tmp4.w = (-uniforms.f[83].wwww).w;
    reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[4 + address_registers.x].xyyy)).xy;
    reg_tmp4.z = (-uniforms.f[4 + address_registers.x].zzzz).z;
    reg_tmp4.w = (-uniforms.f[4 + address_registers.x].wwww).w;
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    reg_tmp12.xy = (reg_tmp5.xyyy).xy;
    return false;
}
bool sub_11() {
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_12() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_13() {
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_14() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_15() {
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_16() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_17() {
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_18() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_0() {
    {
        sub_1();
    }
    reg_tmp10.xy = (uniforms.f[84].xyyy + reg_tmp10.xyyy).xy;
    reg_tmp10.xy = (mul_s(uniforms.f[2 + address_registers.x].xyyy, reg_tmp10.xyyy)).xy;
    {
        sub_2();
    }
    reg_tmp2.xyz = (reg_tmp1.xyzz).xyz;
    reg_tmp3.xyz = (uniforms.f[6 + address_registers.x].xyzz).xyz;
    reg_tmp4.x = dot_3(reg_tmp3.xyz, reg_tmp3.xyz);
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
    if (conditional_code.x) {
        sub_3();
    } else {
        sub_4();
    }
    reg_tmp3.xyz = (mul_s(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
    reg_tmp4.xyz = (mul_s(reg_tmp3.yzxx, reg_tmp2.zxyy)).xyz;
    reg_tmp4.xyz = (fma_s(-reg_tmp2.yzxx, reg_tmp3.zxyy, reg_tmp4)).xyz;
    reg_tmp5.x = dot_3(reg_tmp4.xyz, reg_tmp4.xyz);
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp5.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp5.y;
    if (conditional_code.x) {
        sub_5();
    } else {
        sub_6();
    }
    reg_tmp4.xyz = (mul_s(reg_tmp4.xyzz, reg_tmp5.xxxx)).xyz;
    reg_tmp5.xyz = (mul_s(reg_tmp3.yzxx, reg_tmp4.zxyy)).xyz;
    reg_tmp5.xyz = (fma_s(-reg_tmp4.yzxx, reg_tmp3.zxyy, reg_tmp5)).xyz;
    reg_tmp6.x = (reg_tmp4.xxxx).x;
    reg_tmp6.y = (reg_tmp3.xxxx).y;
    reg_tmp6.z = (reg_tmp5.xxxx).z;
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    reg_tmp7.x = (reg_tmp4.yyyy).x;
    reg_tmp7.y = (reg_tmp3.yyyy).y;
    reg_tmp7.z = (reg_tmp5.yyyy).z;
    reg_tmp7.w = (uniforms.f[0].xxxx).w;
    reg_tmp8.x = (reg_tmp4.zzzz).x;
    reg_tmp8.y = (reg_tmp3.zzzz).y;
    reg_tmp8.z = (reg_tmp5.zzzz).z;
    reg_tmp8.w = (uniforms.f[0].xxxx).w;
    reg_tmp9 = uniforms.f[0].xxxz;
    reg_tmp2.x = dot_s(reg_tmp10, reg_tmp6);
    reg_tmp2.y = dot_s(reg_tmp10, reg_tmp7);
    reg_tmp2.z = dot_s(reg_tmp10, reg_tmp8);
    reg_tmp2.w = dot_s(reg_tmp10, reg_tmp9);
    reg_tmp3.xyz = (uniforms.f[5 + address_registers.x].xyzz).xyz;
    reg_tmp3.xyz = (-uniforms.f[85].xyzz + reg_tmp3.xyzz).xyz;
    reg_tmp4.x = dot_3(reg_tmp3.xyz, reg_tmp3.xyz);
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
    if (conditional_code.x) {
        sub_7();
    } else {
        sub_8();
    }
    reg_tmp3.xyz = (mul_s(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
    reg_tmp10.xyz = (uniforms.f[5 + address_registers.x].xyzz + reg_tmp2.xyzz).xyz;
    reg_tmp10.xyz = (fma_s(reg_tmp3.xyzz, -uniforms.f[84].zzzz, reg_tmp10.xyzz)).xyz;
    {
        sub_9();
    }
    reg_tmp2 = reg_tmp10;
    reg_tmp10.x = dot_s(reg_tmp2, reg_tmp6);
    reg_tmp10.y = dot_s(reg_tmp2, reg_tmp7);
    reg_tmp10.z = dot_s(reg_tmp2, reg_tmp8);
    reg_tmp10.w = dot_s(reg_tmp2, reg_tmp9);
    reg_tmp2 = uniforms.f[1 + address_registers.x];
    reg_tmp3 = max(uniforms.f[0].xxxx, reg_tmp2);
    reg_tmp2 = min(uniforms.f[0].zzzz, reg_tmp3);
    reg_tmp13 = reg_tmp2;
    {
        sub_10();
    }
    {
        sub_19();
    }
    return true;
}
bool sub_3() {
    reg_tmp4.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_4() {
    reg_tmp4.x = rsq_s(reg_tmp4.x);
    return false;
}
bool sub_5() {
    reg_tmp5.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_6() {
    reg_tmp5.x = rsq_s(reg_tmp5.x);
    return false;
}
bool sub_7() {
    reg_tmp4.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_8() {
    reg_tmp4.x = rsq_s(reg_tmp4.x);
    return false;
}
// reference: 5C1EACCACBF57FC1, 9C4924FA28F6423B
// program: 9C4924FA28F6423B, 13A54CCD8AA1DDA2, B6B08DE0C83FF4C8
// shader: 8B30, 67619795CF293FFC
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.r);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) - (1.0 - rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1 * 1.0, alpha_output_1 * 2.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_2 = byteround(clamp((vec3(1.0) - combiner_buffer.rgb) * (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 277AD2EAA944BD87, 67619795CF293FFC
// program: 9C4924FA28F6423B, 13A54CCD8AA1DDA2, 67619795CF293FFC
// reference: 124A538A480019B3, 9C4924FA28F6423B
// shader: 8B30, A8FC15635CBD744A
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb) * (texcolor0.rgb) + (const_color[0].rgb) * (vec3(1.0) - (texcolor0.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_1 = (last_tex_env_out.rgb);
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (texcolor2.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor1.rgb) * (const_color[2].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = (last_tex_env_out.rgb);
float alpha_output_5 = byteround(clamp((last_tex_env_out.a) * (const_color[5].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 55A22F7A1AA2C3FC, A8FC15635CBD744A
// program: BEC1B215F99385B9, 0D30074279C2FEED, A8FC15635CBD744A
// shader: 8B30, 664FC942DC6F2932
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb) * (texcolor0.rgb) + (const_color[0].rgb) * (vec3(1.0) - (texcolor0.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.r) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_1 = (last_tex_env_out.rgb);
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (texcolor2.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor1.rgb) * (const_color[2].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = (last_tex_env_out.rgb);
float alpha_output_5 = byteround(clamp((last_tex_env_out.a) * (const_color[5].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 8BA8018AF3FA96C4, 664FC942DC6F2932
// program: BEC1B215F99385B9, 0D30074279C2FEED, 664FC942DC6F2932
// shader: 8B30, 8BCC92BF77D1741F
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.r) * (texcolor1.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_2 = byteround(clamp((vec3(1.0) - combiner_buffer.rgb) * (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: E73A4802B26CD5C1, 8BCC92BF77D1741F
// program: 9C4924FA28F6423B, 13A54CCD8AA1DDA2, 8BCC92BF77D1741F
// program: FBDEFFFAE3D442C5, 13A54CCD8AA1DDA2, EDB11957E1308F8F
// shader: 8B30, 33E9C4BEB3FD7391
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.r) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 103B0098D5C9395D, 33E9C4BEB3FD7391
// program: BEC1B215F99385B9, 0D30074279C2FEED, 33E9C4BEB3FD7391
// reference: B2CD74B51F680A00, B35EFE43E319BB63
// program: 4FC2B4EDFF8D2FB4, 0D30074279C2FEED, B35EFE43E319BB63
// shader: 8B30, A56F946360E5FB33
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) * (const_color[2].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 5BEBE6BB3D88912A, A56F946360E5FB33
// program: 7C96EBECB346C618, 1C4CBC8096EA16CD, A56F946360E5FB33
// shader: 8B30, 72F56F6D6A16B65C
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp(min((texcolor0.rgb) + (texcolor1.rgb), vec3(1.0)) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 7B3755AA0A3D7126, 72F56F6D6A16B65C
// program: BEC1B215F99385B9, 0D30074279C2FEED, 72F56F6D6A16B65C
// shader: 8B30, E9F98F2A6669187A
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rrr) + (texcolor2.rgb) * (vec3(1.0) - (primary_fragment_color.rrr)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 4925DD1ED2A3C03F, E9F98F2A6669187A
// program: BEC1B215F99385B9, 0D30074279C2FEED, E9F98F2A6669187A
// shader: 8B30, 1D9576CD2CFA910E
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp(min((texcolor0.rgb) + (texcolor1.rgb), vec3(1.0)) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 8BAD0106C77B4F94, 1D9576CD2CFA910E
// program: BEC1B215F99385B9, 0D30074279C2FEED, 1D9576CD2CFA910E
// shader: 8B30, 7170135E7B36AD4A
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp(min((texcolor0.rgb) + (texcolor1.rgb), vec3(1.0)) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 8BAD01062BCCA497, 7170135E7B36AD4A
// program: BEC1B215F99385B9, 0D30074279C2FEED, 7170135E7B36AD4A
// shader: 8B30, 865DCB3F9A66E87D
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 2C801EA3AEF24AAC, 865DCB3F9A66E87D
// program: BEC1B215F99385B9, 0D30074279C2FEED, 865DCB3F9A66E87D
// shader: 8B30, 40D793FB8D8DA15D
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor1.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (const_color[1].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (primary_fragment_color.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: F4FFC6A99CDFF886, 40D793FB8D8DA15D
// program: BEC1B215F99385B9, 0D30074279C2FEED, 40D793FB8D8DA15D
// shader: 8B30, 79E9834AE783AD92
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = (last_tex_env_out.rgb);
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (primary_fragment_color.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (const_color[2].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: B6C296E9F1628B97, 79E9834AE783AD92
// program: BEC1B215F99385B9, 0D30074279C2FEED, 79E9834AE783AD92
// shader: 8B30, 75AFB4429A99DBF3
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(normal, normalize(view))));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (secondary_fragment_color.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 2FAD43B77FC07EC1, 75AFB4429A99DBF3
// program: BEC1B215F99385B9, 0D30074279C2FEED, 75AFB4429A99DBF3
// shader: 8B30, 817DF3D39A617632
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: F6779270599F0D6D, 817DF3D39A617632
// program: 7C96EBECB346C618, 1C4CBC8096EA16CD, 817DF3D39A617632
// shader: 8B30, 121AEB2C209E06DE
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: F6779270A27F7CD4, 121AEB2C209E06DE
// program: 7C96EBECB346C618, 1C4CBC8096EA16CD, 121AEB2C209E06DE
// shader: 8B30, CB75C1E4FB5DDB7C
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 8ED580B86326FA84, CB75C1E4FB5DDB7C
// program: 7C96EBECB346C618, 1C4CBC8096EA16CD, CB75C1E4FB5DDB7C
// shader: 8B30, 7AF70408255288CC
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 8ED580B868110090, 7AF70408255288CC
// program: 7C96EBECB346C618, 1C4CBC8096EA16CD, 7AF70408255288CC
// shader: 8B30, BD1D7911CA7BEBFB
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 8ED580B893F17129, BD1D7911CA7BEBFB
// program: 7C96EBECB346C618, 1C4CBC8096EA16CD, BD1D7911CA7BEBFB
// shader: 8B30, BFD88A99D3C22DB9
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(normal, normalize(view))));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb) * (secondary_fragment_color.rrr) + (texcolor0.rgb) * (vec3(1.0) - (secondary_fragment_color.rrr)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 0EB02BAC89C8D99A, BFD88A99D3C22DB9
// program: BEC1B215F99385B9, 0D30074279C2FEED, BFD88A99D3C22DB9
// shader: 8B30, 385AE4FF8AADDC31
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 00970B37A52CB7E1, 385AE4FF8AADDC31
// program: 7C96EBECB346C618, 1C4CBC8096EA16CD, 385AE4FF8AADDC31
// shader: 8B30, 0B79B9743EBF4CD3
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 00970B375ECCC658, 0B79B9743EBF4CD3
// program: 7C96EBECB346C618, 1C4CBC8096EA16CD, 0B79B9743EBF4CD3
// shader: 8B30, 21FE9B12EEB051D9
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 783519FF9F954008, 21FE9B12EEB051D9
// program: 7C96EBECB346C618, 1C4CBC8096EA16CD, 21FE9B12EEB051D9
// shader: 8B30, 3280E15438323023
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 783519FF94A2BA1C, 3280E15438323023
// program: 7C96EBECB346C618, 1C4CBC8096EA16CD, 3280E15438323023
// shader: 8B31, F3965AC225A24CBC

#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define fma_s(x, y, z) (mix(x * y, vec4(0.0), isnan(x * y)) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;
out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_13();
bool sub_6();
bool sub_11();
bool sub_4();
bool sub_9();
bool sub_10();
bool sub_12();
bool sub_14();
bool sub_2();
bool sub_3();
bool sub_5();
bool sub_7();
bool sub_17();
bool sub_18();
bool sub_24();
bool sub_25();
bool sub_26();
bool sub_27();
bool sub_29();
bool sub_31();
bool sub_32();
bool sub_33();
bool sub_34();
bool sub_35();
bool sub_36();
bool sub_37();
bool sub_38();
bool sub_39();
bool sub_40();
bool sub_41();
bool sub_42();
bool sub_19();
bool sub_20();
bool sub_21();
bool sub_22();
bool sub_23();
bool sub_28();
bool sub_30();
bool sub_0();
bool sub_1();
bool sub_8();
bool sub_15();
bool sub_16();

bool exec_shader() {
    sub_0();
    return true;
}

bool sub_13() {
    uint jmp_to = 0u;
    while (true) {
        switch (jmp_to) {
        case 0u: {
            reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
            reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
            reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
            reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
            reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
            reg_tmp6.x = rsq_s(reg_tmp6.x);
            reg_tmp7.x = rsq_s(reg_tmp7.x);
            reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            reg_tmp0 = uniforms.f[93].yxxx;
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            reg_tmp4 = mul_s(uniforms.f[94].xxxx, reg_tmp4);
            conditional_code = greaterThanEqual(uniforms.f[93].xx, reg_tmp4.xx);
            reg_tmp4 = vec4(rsq_s(reg_tmp4.x));
            reg_tmp5 = mul_s(uniforms.f[94].xxxx, reg_tmp14);
            if (conditional_code.x) {
                { jmp_to = 18u; break; }
            }
            reg_tmp0.z = rcp_s(reg_tmp4.x);
            reg_tmp0.xy = (mul_s(reg_tmp5, reg_tmp4)).xy;
        }
        case 18u: {
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_6() {
    uint jmp_to = 19u;
    while (true) {
        switch (jmp_to) {
        case 19u: {
            reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
            reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
            reg_tmp6.x = rsq_s(reg_tmp6.x);
            reg_tmp7.x = rsq_s(reg_tmp7.x);
            reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            reg_tmp13.xyz = (mul_s(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            reg_tmp11.xyz = (mul_s(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            reg_tmp0 = uniforms.f[93].yxxx;
            reg_tmp13.xyz = (mul_s(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            reg_tmp11.xyz = (mul_s(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            reg_tmp5 = mul_s(reg_tmp14.yzxx, reg_tmp13.zxyy);
            reg_tmp5 = fma_s(-reg_tmp13.yzxx, reg_tmp14.zxyy, reg_tmp5);
            reg_tmp5.w = dot_3(reg_tmp5.xyz, reg_tmp5.xyz);
            reg_tmp5.w = rsq_s(reg_tmp5.w);
            reg_tmp5 = mul_s(reg_tmp5, reg_tmp5.wwww);
            reg_tmp6.w = (reg_tmp14.zzzz + reg_tmp5.yyyy).w;
            reg_tmp13 = mul_s(reg_tmp5.yzxx, reg_tmp14.zxyy);
            reg_tmp13 = fma_s(-reg_tmp14.yzxx, reg_tmp5.zxyy, reg_tmp13);
            reg_tmp6.w = (reg_tmp13.xxxx + reg_tmp6).w;
            reg_tmp13.w = (reg_tmp5.zzzz).w;
            reg_tmp5.z = (reg_tmp13.xxxx).z;
            reg_tmp6.w = (uniforms.f[93].yyyy + reg_tmp6).w;
            reg_tmp14.w = (reg_tmp5.xxxx).w;
            reg_tmp5.x = (reg_tmp14.zzzz).x;
            conditional_code = lessThan(uniforms.f[94].zz, reg_tmp6.ww);
            reg_tmp6.x = (uniforms.f[93].yyyy).x;
            reg_tmp6.y = (-uniforms.f[93].yyyy).y;
            if (!conditional_code.x) {
                { jmp_to = 54u; break; }
            }
            reg_tmp7.xz = (reg_tmp13.wwyy + -reg_tmp14.yyww).xz;
            reg_tmp7.y = (reg_tmp14.xxxx + -reg_tmp13.zzzz).y;
            reg_tmp7.w = (reg_tmp6).w;
            reg_tmp6 = vec4(dot_s(reg_tmp7, reg_tmp7));
            reg_tmp6 = vec4(rsq_s(reg_tmp6.x));
            reg_tmp0 = mul_s(reg_tmp7, reg_tmp6);
        }
        case 54u: {
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_11() {
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    reg_tmp4.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_4() {
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    reg_tmp4.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp5.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp13.xyz);
    reg_tmp5.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp13.xyz);
    reg_tmp5.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp13.xyz);
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    reg_tmp11 = fma_s(reg_tmp1.wwww, reg_tmp5, reg_tmp11);
    return false;
}
bool sub_9() {
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    reg_tmp13.xyz = (vs_in_reg2).xyz;
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    if (uniforms.b[0]) {
        sub_10();
    } else {
        sub_12();
    }
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    {
        sub_13();
    }
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    vs_out_attr2 = -reg_tmp15;
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    if (all(conditional_code)) {
        sub_14();
    }
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_10() {
    reg_tmp7 = uniforms.f[93].xxxx;
    reg_tmp12 = uniforms.f[93].xxxx;
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    {
        sub_11();
    }
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    {
        sub_11();
    }
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    {
        sub_11();
    }
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    {
        sub_11();
    }
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    reg_tmp10 = reg_tmp7;
    return false;
}
bool sub_12() {
    reg_tmp7 = reg_tmp15;
    reg_tmp10.x = dot_s(uniforms.f[10], reg_tmp7);
    reg_tmp10.y = dot_s(uniforms.f[11], reg_tmp7);
    reg_tmp10.z = dot_s(uniforms.f[12], reg_tmp7);
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    reg_tmp12.x = dot_3(uniforms.f[10].xyz, reg_tmp14.xyz);
    reg_tmp12.y = dot_3(uniforms.f[11].xyz, reg_tmp14.xyz);
    reg_tmp12.z = dot_3(uniforms.f[12].xyz, reg_tmp14.xyz);
    return false;
}
bool sub_14() {
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_2() {
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    reg_tmp13.xyz = (vs_in_reg2).xyz;
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    if (uniforms.b[0]) {
        sub_3();
    } else {
        sub_5();
    }
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    reg_tmp13.x = dot_3(uniforms.f[90].xyz, reg_tmp11.xyz);
    reg_tmp13.y = dot_3(uniforms.f[91].xyz, reg_tmp11.xyz);
    reg_tmp13.z = dot_3(uniforms.f[92].xyz, reg_tmp11.xyz);
    {
        sub_6();
    }
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    vs_out_attr2 = -reg_tmp15;
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    if (all(conditional_code)) {
        sub_7();
    }
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_3() {
    reg_tmp7 = uniforms.f[93].xxxx;
    reg_tmp12 = uniforms.f[93].xxxx;
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    {
        sub_4();
    }
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    {
        sub_4();
    }
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    {
        sub_4();
    }
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    {
        sub_4();
    }
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    reg_tmp10 = reg_tmp7;
    return false;
}
bool sub_5() {
    reg_tmp7 = reg_tmp15;
    reg_tmp10.x = dot_s(uniforms.f[10], reg_tmp7);
    reg_tmp10.y = dot_s(uniforms.f[11], reg_tmp7);
    reg_tmp10.z = dot_s(uniforms.f[12], reg_tmp7);
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    reg_tmp12.x = dot_3(uniforms.f[10].xyz, reg_tmp14.xyz);
    reg_tmp12.y = dot_3(uniforms.f[11].xyz, reg_tmp14.xyz);
    reg_tmp12.z = dot_3(uniforms.f[12].xyz, reg_tmp14.xyz);
    reg_tmp11.x = dot_3(uniforms.f[10].xyz, reg_tmp13.xyz);
    reg_tmp11.y = dot_3(uniforms.f[11].xyz, reg_tmp13.xyz);
    reg_tmp11.z = dot_3(uniforms.f[12].xyz, reg_tmp13.xyz);
    return false;
}
bool sub_7() {
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_17() {
    reg_tmp0.xy = (uniforms.f[0].xxxx).xy;
    if (uniforms.b[2]) {
        sub_18();
    } else {
        sub_24();
    }
    return false;
}
bool sub_18() {
    {
        sub_19();
    }
    reg_tmp3.x = dot_s(uniforms.f[1].xywz, reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2].xywz, reg_tmp6);
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_24() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_25();
    } else {
        sub_26();
    }
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_25() {
    reg_tmp6 = reg_tmp10;
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    reg_tmp3.z = dot_s(uniforms.f[3], reg_tmp6);
    reg_tmp0.xy = (mul_s(uniforms.f[9].xyyy, reg_tmp3.zzzz)).xy;
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_26() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_27();
    } else {
        sub_29();
    }
    return false;
}
bool sub_27() {
    {
        sub_28();
    }
    reg_tmp3.x = dot_3(uniforms.f[1].xyz, reg_tmp6.xyz);
    reg_tmp3.y = dot_3(uniforms.f[2].xyz, reg_tmp6.xyz);
    reg_tmp3.z = dot_3(uniforms.f[3].xyz, reg_tmp6.xyz);
    return false;
}
bool sub_29() {
    {
        sub_30();
    }
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    return false;
}
bool sub_31() {
    reg_tmp0.xy = (uniforms.f[0].yyyy).xy;
    if (uniforms.b[3]) {
        sub_32();
    } else {
        sub_33();
    }
    return false;
}
bool sub_32() {
    {
        sub_19();
    }
    reg_tmp4.x = dot_s(uniforms.f[4].xywz, reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5].xywz, reg_tmp6);
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_33() {
    if (uniforms.b[5]) {
        sub_34();
    } else {
        sub_37();
    }
    return false;
}
bool sub_34() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_35();
    } else {
        sub_36();
    }
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_35() {
    reg_tmp6 = reg_tmp10;
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    reg_tmp4.z = dot_s(uniforms.f[6], reg_tmp6);
    reg_tmp6.w = rcp_s(reg_tmp4.z);
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    reg_tmp4.xy = (uniforms.f[9].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_36() {
    {
        sub_30();
    }
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    return false;
}
bool sub_37() {
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_38() {
    reg_tmp0.xy = (uniforms.f[0].zzzz).xy;
    if (uniforms.b[4]) {
        sub_39();
    } else {
        sub_40();
    }
    return false;
}
bool sub_39() {
    {
        sub_19();
    }
    reg_tmp5.x = dot_s(uniforms.f[7].xywz, reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8].xywz, reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_40() {
    if (uniforms.b[6]) {
        sub_41();
    } else {
        sub_42();
    }
    return false;
}
bool sub_41() {
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    {
        sub_30();
    }
    reg_tmp5.x = dot_s(uniforms.f[7], reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8], reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_42() {
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
bool sub_19() {
    conditional_code = equal(uniforms.f[93].yz, reg_tmp0.xy);
    if (all(not(conditional_code))) {
        sub_20();
    } else {
        sub_21();
    }
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_20() {
    reg_tmp6.xy = (vs_in_reg4.xyyy).xy;
    return false;
}
bool sub_21() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_22();
    } else {
        sub_23();
    }
    return false;
}
bool sub_22() {
    reg_tmp6.xy = (vs_in_reg5.xyyy).xy;
    return false;
}
bool sub_23() {
    reg_tmp6.xy = (vs_in_reg6.xyyy).xy;
    return false;
}
bool sub_28() {
    reg_tmp2 = -reg_tmp15;
    reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
    reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_30() {
    reg_tmp1 = reg_tmp14;
    reg_tmp2.w = dot_3(reg_tmp1.xyz, reg_tmp1.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp1 = mul_s(reg_tmp1, reg_tmp2.wwww);
    reg_tmp1 = mul_s(uniforms.f[94].xxxx, reg_tmp1);
    reg_tmp6.xy = (uniforms.f[94].xxxx + reg_tmp1.xyyy).xy;
    return false;
}
bool sub_0() {
    if (uniforms.b[10]) {
        sub_1();
    } else {
        sub_8();
    }
    if (uniforms.b[1]) {
        sub_15();
    } else {
        sub_16();
    }
    vs_out_attr3 = reg_tmp2;
    {
        sub_17();
    }
    {
        sub_31();
    }
    {
        sub_38();
    }
    return true;
}
bool sub_1() {
    {
        sub_2();
    }
    return false;
}
bool sub_8() {
    {
        sub_9();
    }
    return false;
}
bool sub_15() {
    reg_tmp0 = vec4(dot_3(uniforms.f[83].xyz, reg_tmp12.xyz));
    reg_tmp0 = max(uniforms.f[93].xxxx, reg_tmp0);
    reg_tmp0 = mul_s(uniforms.f[84], reg_tmp0);
    reg_tmp0 = uniforms.f[85] + reg_tmp0;
    reg_tmp0.w = (uniforms.f[93].yyyy).w;
    reg_tmp1 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
    reg_tmp2 = mul_s(reg_tmp0, reg_tmp1);
    return false;
}
bool sub_16() {
    reg_tmp2 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
    return false;
}
// reference: 1793BA63971C3BAC, F3965AC225A24CBC
// program: F3965AC225A24CBC, 0D30074279C2FEED, 71260FB838A09A82
// program: F3965AC225A24CBC, 0D30074279C2FEED, 75AFB4429A99DBF3
// program: F3965AC225A24CBC, 0D30074279C2FEED, 6064ABBB985A5B22
// shader: 8B31, 970AA6E82CDE4E04

#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define fma_s(x, y, z) (mix(x * y, vec4(0.0), isnan(x * y)) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location = 0) in vec4 vs_in_reg0;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_5();
bool sub_6();
bool sub_7();
bool sub_8();
bool sub_9();
bool sub_10();
bool sub_11();
bool sub_12();
bool sub_13();
bool sub_14();
bool sub_15();
bool sub_16();
bool sub_17();
bool sub_18();
bool sub_19();
bool sub_20();
bool sub_21();
bool sub_22();
bool sub_23();
bool sub_24();
bool sub_25();
bool sub_26();
bool sub_27();
bool sub_28();
bool sub_29();
bool sub_30();
bool sub_31();
bool sub_32();
bool sub_1();
bool sub_0();
bool sub_2();
bool sub_3();
bool sub_4();
bool sub_33();
bool sub_34();
bool sub_35();
bool sub_36();
bool sub_37();
bool sub_38();
bool sub_39();
bool sub_40();
bool sub_41();

bool exec_shader() {
    sub_0();
    return true;
}

bool sub_5() {
    reg_tmp13 = floor(reg_tmp0.xxxx);
    reg_tmp13 = reg_tmp0.xxxx + -reg_tmp13;
    address_registers.y = (ivec2(reg_tmp11.zz)).y;
    conditional_code = lessThanEqual(uniforms.f[5].ww, reg_tmp13.xx);
    if (conditional_code.x) {
        sub_6();
    }
    conditional_code = lessThanEqual(uniforms.f[5].yy, reg_tmp11.xy);
    if (!conditional_code.y) {
        sub_15();
    } else {
        sub_22();
    }
    return false;
}
bool sub_6() {
    reg_tmp12.xy = (uniforms.f[5].xyyy + vs_in_reg0.zwww).xy;
    reg_tmp14.xy = (uniforms.f[6].wzzz).xy;
    reg_tmp13.xy = (mul_s(uniforms.f[5].zzzz, reg_tmp0.xxxx)).xy;
    reg_tmp13.y = (floor(reg_tmp13)).y;
    reg_tmp13.x = (reg_tmp13.xxxx + -reg_tmp13.yyyy).x;
    conditional_code = lessThanEqual(uniforms.f[5].ww, reg_tmp13.xx);
    if (conditional_code.x) {
        sub_7();
    }
    reg_tmp14.xy = (mul_s(reg_tmp14, reg_tmp2)).xy;
    reg_tmp13.x = (mul_s(uniforms.f[5].zzzz, reg_tmp13.xxxx)).x;
    reg_tmp13 = mul_s(uniforms.f[5].zyzy, reg_tmp13.xxxx);
    reg_tmp13.zw = (floor(reg_tmp13)).zw;
    reg_tmp13.xy = (reg_tmp13.xyyy + -reg_tmp13.zwww).xy;
    conditional_code = lessThanEqual(uniforms.f[5].ww, reg_tmp13.xy);
    if (conditional_code.y) {
        sub_8();
    }
    if (conditional_code.x) {
        sub_9();
    }
    reg_tmp14.xy = (uniforms.f[5].yyyy + -reg_tmp14.xyyy).xy;
    reg_tmp13.x = (mul_s(uniforms.f[5].zzzz, reg_tmp13.xxxx)).x;
    reg_tmp13 = mul_s(uniforms.f[5].zyzy, reg_tmp13.xxxx);
    reg_tmp13.zw = (floor(reg_tmp13)).zw;
    reg_tmp13.xy = (reg_tmp13.xyyy + -reg_tmp13.zwww).xy;
    conditional_code = lessThanEqual(uniforms.f[5].ww, reg_tmp13.xy);
    if (conditional_code.y) {
        sub_10();
    }
    if (conditional_code.x) {
        sub_11();
    }
    reg_tmp13.x = (mul_s(uniforms.f[5].zzzz, reg_tmp13.xxxx)).x;
    reg_tmp13 = mul_s(uniforms.f[5].zyzy, reg_tmp13.xxxx);
    reg_tmp13.zw = (floor(reg_tmp13)).zw;
    reg_tmp13.xy = (reg_tmp13.xyyy + -reg_tmp13.zwww).xy;
    conditional_code = lessThanEqual(uniforms.f[5].ww, reg_tmp13.xy);
    if (conditional_code.y) {
        sub_12();
    }
    if (conditional_code.x) {
        sub_13();
    }
    reg_tmp13.xy = (mul_s(uniforms.f[5].zzzz, reg_tmp0.xxxx)).xy;
    reg_tmp13.y = (floor(reg_tmp13)).y;
    reg_tmp13.x = (reg_tmp13.xxxx + -reg_tmp13.yyyy).x;
    conditional_code = lessThanEqual(uniforms.f[5].ww, reg_tmp13.xx);
    if (conditional_code.x) {
        sub_14();
    }
    reg_tmp12.y = (uniforms.f[5].yyyy + -reg_tmp12.yyyy).y;
    return false;
}
bool sub_7() {
    reg_tmp14.xy = (reg_tmp14.yxxx).xy;
    return false;
}
bool sub_8() {
    reg_tmp12.x = (mul_s(reg_tmp12.xxxx, reg_tmp14.xxxx)).x;
    return false;
}
bool sub_9() {
    reg_tmp12.y = (fma_s(reg_tmp12.yyyy, reg_tmp14.yyyy, uniforms.f[5].yyyy)).y;
    reg_tmp12.y = (reg_tmp12.yyyy + -reg_tmp14.yyyy).y;
    return false;
}
bool sub_10() {
    reg_tmp12.x = (reg_tmp12.xxxx + reg_tmp14.xxxx).x;
    return false;
}
bool sub_11() {
    reg_tmp12.y = (reg_tmp12.yyyy + -reg_tmp14.yyyy).y;
    return false;
}
bool sub_12() {
    reg_tmp12.x = (uniforms.f[5].yyyy + -reg_tmp12.xxxx).x;
    return false;
}
bool sub_13() {
    reg_tmp12.y = (uniforms.f[5].yyyy + -reg_tmp12.yyyy).y;
    return false;
}
bool sub_14() {
    reg_tmp12.xy = (uniforms.f[5].yyyy + -reg_tmp12.yxxx).xy;
    return false;
}
bool sub_15() {
    reg_tmp13.x = (floor(reg_tmp0.xxxx)).x;
    reg_tmp13.x = (reg_tmp0.xxxx + -reg_tmp13).x;
    conditional_code = lessThanEqual(uniforms.f[5].ww, reg_tmp13.xx);
    reg_tmp13 = uniforms.f[32 + address_registers.y].wzyx;
    if (conditional_code.x) {
        sub_16();
    } else {
        sub_17();
    }
    reg_tmp11.z = (uniforms.f[5].yyyy + reg_tmp11.zzzz).z;
    return false;
}
bool sub_16() {
    reg_tmp11.xy = (fma_s(reg_tmp12.xyyy, reg_tmp13.xyyy, reg_tmp13.zwww)).xy;
    reg_tmp11.xy = (mul_s(reg_tmp11.xyyy, reg_tmp14.zwww)).xy;
    reg_tmp11.y = (uniforms.f[5].yyyy + -reg_tmp11.yyyy).y;
    return false;
}
bool sub_17() {
    conditional_code = notEqual(uniforms.f[5].xx, vs_in_reg0.zw);
    if (!conditional_code.x) {
        sub_18();
    } else {
        sub_19();
    }
    if (!conditional_code.y) {
        sub_20();
    } else {
        sub_21();
    }
    return false;
}
bool sub_18() {
    reg_tmp11.x = (reg_tmp13.xxxx).x;
    return false;
}
bool sub_19() {
    reg_tmp11.x = (reg_tmp13.zzzz).x;
    return false;
}
bool sub_20() {
    reg_tmp11.y = (reg_tmp13.yyyy).y;
    return false;
}
bool sub_21() {
    reg_tmp11.y = (reg_tmp13.wwww).y;
    return false;
}
bool sub_22() {
    if (!conditional_code.x) {
        sub_23();
    } else {
        sub_32();
    }
    reg_tmp11.z = (uniforms.f[5].zzzz + reg_tmp11.zzzz).z;
    return false;
}
bool sub_23() {
    reg_tmp13.x = (floor(reg_tmp0.xxxx)).x;
    reg_tmp13.x = (reg_tmp0.xxxx + -reg_tmp13).x;
    conditional_code = lessThanEqual(uniforms.f[5].ww, reg_tmp13.xx);
    if (conditional_code.x) {
        sub_24();
    } else {
        sub_25();
    }
    return false;
}
bool sub_24() {
    reg_tmp12.zw = (uniforms.f[5].xxxy).zw;
    reg_tmp11.x = dot_s(uniforms.f[32 + address_registers.y].wzyx, reg_tmp12);
    reg_tmp11.y = dot_s(uniforms.f[33 + address_registers.y].wzyx, reg_tmp12);
    reg_tmp11.xy = (mul_s(reg_tmp11.xyyy, reg_tmp14.zwww)).xy;
    reg_tmp11.y = (uniforms.f[5].yyyy + -reg_tmp11.yyyy).y;
    return false;
}
bool sub_25() {
    reg_tmp14 = uniforms.f[32 + address_registers.y].wzyx;
    reg_tmp13 = uniforms.f[33 + address_registers.y].wzyx;
    conditional_code = notEqual(uniforms.f[5].xx, vs_in_reg0.zw);
    if (!conditional_code.y) {
        sub_26();
    } else {
        sub_29();
    }
    return false;
}
bool sub_26() {
    if (!conditional_code.x) {
        sub_27();
    } else {
        sub_28();
    }
    return false;
}
bool sub_27() {
    reg_tmp11.xy = (reg_tmp14.xyyy).xy;
    return false;
}
bool sub_28() {
    reg_tmp11.xy = (reg_tmp13.zwww).xy;
    return false;
}
bool sub_29() {
    if (!conditional_code.x) {
        sub_30();
    } else {
        sub_31();
    }
    return false;
}
bool sub_30() {
    reg_tmp11.xy = (reg_tmp13.xyyy).xy;
    return false;
}
bool sub_31() {
    reg_tmp11.xy = (reg_tmp14.zwww).xy;
    return false;
}
bool sub_32() {
    reg_tmp11.x = dot_s(uniforms.f[32 + address_registers.y].wzyx, reg_tmp1);
    reg_tmp11.y = dot_s(uniforms.f[33 + address_registers.y].wzyx, reg_tmp1);
    return false;
}
bool sub_1() {
    uint jmp_to = 97u;
    while (true) {
        switch (jmp_to) {
        case 97u: {
            reg_tmp3.x = dot_s(uniforms.f[32 + address_registers.x].wzyx, reg_tmp1);
            reg_tmp3.y = dot_s(uniforms.f[33 + address_registers.x].wzyx, reg_tmp1);
            reg_tmp3.z = dot_s(uniforms.f[34 + address_registers.x].wzyx, reg_tmp1);
            reg_tmp3.w = (reg_tmp1.wwww).w;
            reg_tmp11 = uniforms.f[4].wzyx;
            reg_tmp11.z = (-uniforms.f[34 + address_registers.x].xxxx + reg_tmp11.zzzz).z;
            conditional_code.x = uniforms.f[5].xxxx.x != reg_tmp11.xzzz.x;
            conditional_code.y = uniforms.f[5].xxxx.y < reg_tmp11.xzzz.y;
            if (any(not(conditional_code))) {
                { jmp_to = 108u; break; }
            }
            reg_tmp11.z = rcp_s(reg_tmp11.z);
            reg_tmp3.x = (reg_tmp3.xxxx + reg_tmp11.xxxx).x;
            reg_tmp3.x = (fma_s(-reg_tmp11.yyyy, reg_tmp11.zzzz, reg_tmp3.xxxx)).x;
        }
        case 108u: {
        }
        default: return false;
        }
    }
    return false;
}
bool sub_0() {
    uint jmp_to = 109u;
    while (true) {
        switch (jmp_to) {
        case 109u: {
            address_registers.x = (ivec2(vs_in_reg0.xx)).x;
            reg_tmp0 = uniforms.f[9 + address_registers.x].wzyx;
            reg_tmp1.xy = (vs_in_reg0.zwzw).xy;
            reg_tmp1.zw = (uniforms.f[5].xyxy).zw;
            address_registers.xy = ivec2(reg_tmp0.xy);
            reg_tmp2 = uniforms.f[32 + address_registers.y].wzyx;
            if (uniforms.b[0]) {
                { jmp_to = 191u; break; }
            }
            reg_tmp4 = uniforms.f[31 + address_registers.x].wzyx;
            reg_tmp1.xy = (fma_s(reg_tmp1.xyyy, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
            {
                sub_1();
            }
            vs_out_attr0.x = dot_s(uniforms.f[0].wzyx, reg_tmp3);
            vs_out_attr0.y = dot_s(uniforms.f[1].wzyx, reg_tmp3);
            vs_out_attr0.z = dot_s(uniforms.f[2].wzyx, reg_tmp3);
            vs_out_attr0.w = dot_s(uniforms.f[3].wzyx, reg_tmp3);
            conditional_code = greaterThanEqual(uniforms.f[5].yy, reg_tmp0.ww);
            if (all(conditional_code)) {
                sub_2();
            } else {
                sub_3();
            }
            reg_tmp11.z = (reg_tmp0.zzzz).z;
            reg_tmp9 = mul_s(uniforms.f[5].zyzy, reg_tmp0.zzzz);
            reg_tmp9.xy = (floor(reg_tmp9)).xy;
            reg_tmp9.xy = (reg_tmp9.zwww + -reg_tmp9.xyyy).xy;
            reg_tmp9 = mul_s(uniforms.f[5].zzzz, reg_tmp9);
            reg_tmp14 = uniforms.f[6].wzyx;
            reg_tmp11.xy = (reg_tmp9.xyyy).xy;
            {
                sub_5();
            }
            if (uniforms.b[1]) {
                sub_33();
            }
            if (uniforms.b[2]) {
                sub_34();
            }
            vs_out_attr2 = reg_tmp11.xyyy;
            reg_tmp9 = mul_s(uniforms.f[5].zyzy, reg_tmp9.xxxx);
            reg_tmp9.xy = (floor(reg_tmp9)).xy;
            reg_tmp9.xy = (reg_tmp9.zwww + -reg_tmp9.xyyy).xy;
            reg_tmp9 = mul_s(uniforms.f[5].zzzz, reg_tmp9);
            reg_tmp14 = uniforms.f[7].wzyx;
            reg_tmp11.xy = (reg_tmp9.xyyy).xy;
            {
                sub_5();
            }
            if (uniforms.b[3]) {
                sub_35();
            }
            if (uniforms.b[4]) {
                sub_36();
            }
            vs_out_attr3 = reg_tmp11.xyyy;
            reg_tmp9 = mul_s(uniforms.f[5].zyzy, reg_tmp9.xxxx);
            reg_tmp9.xy = (floor(reg_tmp9)).xy;
            reg_tmp9.xy = (reg_tmp9.zwww + -reg_tmp9.xyyy).xy;
            reg_tmp9 = mul_s(uniforms.f[5].zzzz, reg_tmp9);
            reg_tmp14 = uniforms.f[8].wzyx;
            reg_tmp11.xy = (reg_tmp9.xyyy).xy;
            {
                sub_5();
            }
            if (uniforms.b[5]) {
                sub_37();
            }
            if (uniforms.b[6]) {
                sub_38();
            }
            vs_out_attr4 = reg_tmp11.xyyy;
            return true;
        }
        case 191u: {
            reg_tmp2.w = (reg_tmp2.wwww + reg_tmp2.yyyy).w;
            reg_tmp1.y = (-uniforms.f[5].yyyy + -reg_tmp1.yyyy).y;
            reg_tmp13.xy = (mul_s(uniforms.f[36 + address_registers.x].wzzz, reg_tmp2.xyyy)).xy;
            reg_tmp11.x = (mul_s(uniforms.f[35 + address_registers.x].wwww, -reg_tmp1.yyyy)).x;
            reg_tmp1.xy = (mul_s(reg_tmp1.xyyy, reg_tmp13.xyyy)).xy;
            reg_tmp1.x = (reg_tmp1.xxxx + reg_tmp11.xxxx).x;
            if (uniforms.b[1]) {
                sub_39();
            }
            reg_tmp1.xy = (reg_tmp1.xyyy + reg_tmp2.zwww).xy;
            reg_tmp1.xy = (uniforms.f[36 + address_registers.x].yxxx + reg_tmp1.xyyy).xy;
            {
                sub_1();
            }
            vs_out_attr0.x = dot_s(uniforms.f[0].wzyx, reg_tmp3);
            vs_out_attr0.y = dot_s(uniforms.f[1].wzyx, reg_tmp3);
            vs_out_attr0.z = dot_s(uniforms.f[2].wzyx, reg_tmp3);
            vs_out_attr0.w = dot_s(uniforms.f[3].wzyx, reg_tmp3);
            if (uniforms.b[2]) {
                sub_40();
            } else {
                sub_41();
            }
            reg_tmp8 = reg_tmp8 + -reg_tmp7;
            vs_out_attr1 = fma_s(reg_tmp8, reg_tmp11.yyyy, reg_tmp7);
            reg_tmp9.xy = (mul_s(uniforms.f[32 + address_registers.x].yxxx, reg_tmp11)).xy;
            reg_tmp11.zw = (vec4(lessThan(reg_tmp11, uniforms.f[5].yyyy))).zw;
            reg_tmp9.xy = (fma_s(reg_tmp11.zwww, uniforms.f[32 + address_registers.x].wzzz, reg_tmp9.xyyy)).xy;
            reg_tmp9.y = (uniforms.f[5].yyyy + -reg_tmp9.yyyy).y;
            vs_out_attr2 = reg_tmp9;
            vs_out_attr3 = reg_tmp9;
            vs_out_attr4 = reg_tmp9;
            return true;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_2() {
    vs_out_attr1.xyz = (uniforms.f[5].yyyy).xyz;
    vs_out_attr1.w = (reg_tmp0.wwww).w;
    return false;
}
bool sub_3() {
    address_registers.y = (ivec2(reg_tmp0.ww)).y;
    reg_tmp7 = uniforms.f[32 + address_registers.y].wzyx;
    reg_tmp8 = uniforms.f[33 + address_registers.y].wzyx;
    reg_tmp9 = uniforms.f[34 + address_registers.y].wzyx;
    reg_tmp10 = uniforms.f[35 + address_registers.y].wzyx;
    reg_tmp11.xy = (vs_in_reg0.zwww).xy;
    reg_tmp14.x = (floor(reg_tmp0.yyyy)).x;
    reg_tmp14.x = (reg_tmp0.yyyy + -reg_tmp14.xxxx).x;
    conditional_code = lessThanEqual(uniforms.f[5].ww, reg_tmp14.xx);
    if (conditional_code.x) {
        sub_4();
    }
    reg_tmp11.xy = (abs(reg_tmp11.xyyy)).xy;
    reg_tmp8 = reg_tmp8 + -reg_tmp7;
    reg_tmp8 = fma_s(reg_tmp8, reg_tmp11.xxxx, reg_tmp7);
    reg_tmp10 = reg_tmp10 + -reg_tmp9;
    reg_tmp10 = fma_s(reg_tmp10, reg_tmp11.xxxx, reg_tmp9);
    reg_tmp10 = reg_tmp10 + -reg_tmp8;
    reg_tmp10 = fma_s(reg_tmp10, reg_tmp11.yyyy, reg_tmp8);
    vs_out_attr1 = reg_tmp10;
    return false;
}
bool sub_4() {
    reg_tmp11.z = rcp_s(reg_tmp4.x);
    reg_tmp11.w = rcp_s(reg_tmp4.y);
    reg_tmp11.xy = (reg_tmp1.xyyy + -reg_tmp4.zwww).xy;
    reg_tmp11.xy = (mul_s(reg_tmp11.xyyy, reg_tmp11.zwww)).xy;
    return false;
}
bool sub_33() {
    reg_tmp11.xy = (reg_tmp11.yxxx).xy;
    reg_tmp11.y = (uniforms.f[5].yyyy + -reg_tmp11.yyyy).y;
    return false;
}
bool sub_34() {
    reg_tmp11.xy = (uniforms.f[5].yyyy + -reg_tmp11.yxxx).xy;
    return false;
}
bool sub_35() {
    reg_tmp11.xy = (reg_tmp11.yxxx).xy;
    reg_tmp11.y = (uniforms.f[5].yyyy + -reg_tmp11.yyyy).y;
    return false;
}
bool sub_36() {
    reg_tmp11.xy = (uniforms.f[5].yyyy + -reg_tmp11.yxxx).xy;
    return false;
}
bool sub_37() {
    reg_tmp11.xy = (reg_tmp11.yxxx).xy;
    reg_tmp11.y = (uniforms.f[5].yyyy + -reg_tmp11.yyyy).y;
    return false;
}
bool sub_38() {
    reg_tmp11.xy = (uniforms.f[5].yyyy + -reg_tmp11.yxxx).xy;
    return false;
}
bool sub_39() {
    reg_tmp13.xzw = (mul_s(uniforms.f[5].wxxx, reg_tmp13.xxxx)).xzw;
    reg_tmp13.y = (mul_s(uniforms.f[34 + address_registers.y].yyyy, reg_tmp13.yyyy)).y;
    reg_tmp11 = fma_s(reg_tmp1, uniforms.f[5].yyxx, -reg_tmp13);
    reg_tmp14 = uniforms.f[33 + address_registers.y].wzyx;
    reg_tmp1.x = dot_3(reg_tmp11.xyz, reg_tmp14.xyy);
    reg_tmp1.y = dot_3(reg_tmp11.xyz, reg_tmp14.zww);
    reg_tmp14 = uniforms.f[34 + address_registers.y].wzyx;
    reg_tmp1.z = dot_s(vec4(reg_tmp11.xyz, 1.0), reg_tmp14);
    reg_tmp1.xy = (reg_tmp1.xyyy + reg_tmp13.xyyy).xy;
    return false;
}
bool sub_40() {
    reg_tmp11 = abs(vs_in_reg0.zwzw);
    reg_tmp14.w = (floor(reg_tmp0.zzzz)).w;
    reg_tmp14.w = (reg_tmp0.zzzz + -reg_tmp14).w;
    address_registers.xy = ivec2(reg_tmp0.zx);
    reg_tmp14.w = (mul_s(uniforms.f[5].zzzz, reg_tmp14.wwww)).w;
    reg_tmp14.xyz = (uniforms.f[5].yyyy).xyz;
    reg_tmp7 = mul_s(uniforms.f[37 + address_registers.y].wzyx, reg_tmp14);
    reg_tmp8 = mul_s(uniforms.f[38 + address_registers.y].wzyx, reg_tmp14);
    return false;
}
bool sub_41() {
    reg_tmp11 = abs(vs_in_reg0.zwzw);
    address_registers.xy = ivec2(reg_tmp0.zw);
    reg_tmp7 = uniforms.f[32 + address_registers.y].wzyx;
    reg_tmp8 = uniforms.f[33 + address_registers.y].wzyx;
    return false;
}
// reference: 31D3563693F0BB93, 970AA6E82CDE4E04
// program: 970AA6E82CDE4E04, 1C4CBC8096EA16CD, 0B79B9743EBF4CD3
// reference: 7F87A9761005DDE1, 970AA6E82CDE4E04
// program: 970AA6E82CDE4E04, 1C4CBC8096EA16CD, 385AE4FF8AADDC31
// program: 970AA6E82CDE4E04, 1C4CBC8096EA16CD, 21FE9B12EEB051D9
// program: 970AA6E82CDE4E04, 1C4CBC8096EA16CD, 3280E15438323023
// reference: 59C7452314E95DDE, F3965AC225A24CBC
// program: F3965AC225A24CBC, 0D30074279C2FEED, 72F56F6D6A16B65C
// program: F3965AC225A24CBC, 0D30074279C2FEED, 1D9576CD2CFA910E
// program: F3965AC225A24CBC, 0D30074279C2FEED, 7170135E7B36AD4A
// program: F3965AC225A24CBC, 0D30074279C2FEED, 865DCB3F9A66E87D
// program: F3965AC225A24CBC, 0D30074279C2FEED, BFD88A99D3C22DB9
// shader: 8B31, D914C0A8DC043EA1

#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define fma_s(x, y, z) (mix(x * y, vec4(0.0), isnan(x * y)) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location = 0) in vec4 vs_in_reg0;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;
out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_1();
bool sub_2();
bool sub_8();
bool sub_9();
bool sub_10();
bool sub_11();
bool sub_13();
bool sub_15();
bool sub_16();
bool sub_17();
bool sub_18();
bool sub_19();
bool sub_20();
bool sub_21();
bool sub_22();
bool sub_23();
bool sub_24();
bool sub_25();
bool sub_26();
bool sub_3();
bool sub_4();
bool sub_5();
bool sub_6();
bool sub_7();
bool sub_12();
bool sub_14();
bool sub_0();

bool exec_shader() {
    sub_0();
    return true;
}

bool sub_1() {
    reg_tmp0.xy = (uniforms.f[0].xxxx).xy;
    if (uniforms.b[2]) {
        sub_2();
    } else {
        sub_8();
    }
    return false;
}
bool sub_2() {
    {
        sub_3();
    }
    reg_tmp3.x = dot_s(uniforms.f[1].xywz, reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2].xywz, reg_tmp6);
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_8() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_9();
    } else {
        sub_10();
    }
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_9() {
    reg_tmp6 = reg_tmp10;
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    reg_tmp3.z = dot_s(uniforms.f[3], reg_tmp6);
    reg_tmp0.xy = (mul_s(uniforms.f[9].xyyy, reg_tmp3.zzzz)).xy;
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_10() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_11();
    } else {
        sub_13();
    }
    return false;
}
bool sub_11() {
    {
        sub_12();
    }
    reg_tmp3.x = dot_3(uniforms.f[1].xyz, reg_tmp6.xyz);
    reg_tmp3.y = dot_3(uniforms.f[2].xyz, reg_tmp6.xyz);
    reg_tmp3.z = dot_3(uniforms.f[3].xyz, reg_tmp6.xyz);
    return false;
}
bool sub_13() {
    {
        sub_14();
    }
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    return false;
}
bool sub_15() {
    reg_tmp0.xy = (uniforms.f[0].yyyy).xy;
    if (uniforms.b[3]) {
        sub_16();
    } else {
        sub_17();
    }
    return false;
}
bool sub_16() {
    {
        sub_3();
    }
    reg_tmp4.x = dot_s(uniforms.f[4].xywz, reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5].xywz, reg_tmp6);
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_17() {
    if (uniforms.b[5]) {
        sub_18();
    } else {
        sub_21();
    }
    return false;
}
bool sub_18() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_19();
    } else {
        sub_20();
    }
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_19() {
    reg_tmp6 = reg_tmp10;
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    reg_tmp4.z = dot_s(uniforms.f[6], reg_tmp6);
    reg_tmp6.w = rcp_s(reg_tmp4.z);
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    reg_tmp4.xy = (uniforms.f[9].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_20() {
    {
        sub_14();
    }
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    return false;
}
bool sub_21() {
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_22() {
    reg_tmp0.xy = (uniforms.f[0].zzzz).xy;
    if (uniforms.b[4]) {
        sub_23();
    } else {
        sub_24();
    }
    return false;
}
bool sub_23() {
    {
        sub_3();
    }
    reg_tmp5.x = dot_s(uniforms.f[7].xywz, reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8].xywz, reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_24() {
    if (uniforms.b[6]) {
        sub_25();
    } else {
        sub_26();
    }
    return false;
}
bool sub_25() {
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    {
        sub_14();
    }
    reg_tmp5.x = dot_s(uniforms.f[7], reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8], reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_26() {
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
bool sub_3() {
    conditional_code = equal(uniforms.f[93].yz, reg_tmp0.xy);
    if (all(not(conditional_code))) {
        sub_4();
    } else {
        sub_5();
    }
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_4() {
    reg_tmp6.xy = (vs_in_reg4.xyyy).xy;
    return false;
}
bool sub_5() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_6();
    } else {
        sub_7();
    }
    return false;
}
bool sub_6() {
    reg_tmp6.xy = (vs_in_reg5.xyyy).xy;
    return false;
}
bool sub_7() {
    reg_tmp6.xy = (vs_in_reg6.xyyy).xy;
    return false;
}
bool sub_12() {
    reg_tmp2 = -reg_tmp15;
    reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
    reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_14() {
    {
        sub_12();
    }
    reg_tmp1 = reg_tmp6;
    reg_tmp1.z = (uniforms.f[93].yyyy + reg_tmp1.zzzz).z;
    reg_tmp1 = vec4(dot_3(reg_tmp1.xyz, reg_tmp1.xyz));
    reg_tmp2 = vec4(rsq_s(reg_tmp1.x));
    reg_tmp2 = mul_s(uniforms.f[94].xxxx, reg_tmp2);
    reg_tmp6.xy = (mul_s(reg_tmp6.xyyy, reg_tmp2)).xy;
    reg_tmp6.xy = (uniforms.f[94].xxxx + reg_tmp6.xyyy).xy;
    return false;
}
bool sub_0() {
    reg_tmp0 = vs_in_reg0;
    reg_tmp0.z = (uniforms.f[93].xxxx).z;
    reg_tmp0.w = (uniforms.f[93].yyyy).w;
    vs_out_attr0 = reg_tmp0;
    vs_out_attr2 = reg_tmp0;
    vs_out_attr1 = reg_tmp0;
    vs_out_attr3 = uniforms.f[93].yyyy;
    {
        sub_1();
    }
    {
        sub_15();
    }
    {
        sub_22();
    }
    return true;
}
// reference: 9D22F5C42CA9BA9F, D914C0A8DC043EA1
// program: D914C0A8DC043EA1, 0D30074279C2FEED, B35EFE43E319BB63
// program: 970AA6E82CDE4E04, 1C4CBC8096EA16CD, 2B730240EE2A8461
// program: 970AA6E82CDE4E04, 1C4CBC8096EA16CD, 61C2DBAB611E2111
// program: 970AA6E82CDE4E04, 1C4CBC8096EA16CD, F437CC0DAF2ECC46
// program: 970AA6E82CDE4E04, 1C4CBC8096EA16CD, 1BC182922368739F
// shader: 8B30, 87048F89800A5AF7
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 783519FF6F42CBA5, 87048F89800A5AF7
// program: 970AA6E82CDE4E04, 1C4CBC8096EA16CD, 87048F89800A5AF7
// program: F3965AC225A24CBC, 0D30074279C2FEED, 6393144EC6B7C460
// program: F3965AC225A24CBC, 0D30074279C2FEED, 184C7DC1D30B7FEA
// program: F3965AC225A24CBC, 0D30074279C2FEED, 8EEA50D59BE2263A
// program: F3965AC225A24CBC, 0D30074279C2FEED, C59FB987FA81F0B3
// program: F3965AC225A24CBC, 0D30074279C2FEED, E9F98F2A6669187A
// program: F3965AC225A24CBC, 0D30074279C2FEED, 40D793FB8D8DA15D
// program: F3965AC225A24CBC, 0D30074279C2FEED, 79E9834AE783AD92
// program: 970AA6E82CDE4E04, 1C4CBC8096EA16CD, 817DF3D39A617632
// program: 970AA6E82CDE4E04, 1C4CBC8096EA16CD, 121AEB2C209E06DE
// program: 970AA6E82CDE4E04, 1C4CBC8096EA16CD, CB75C1E4FB5DDB7C
// program: 970AA6E82CDE4E04, 1C4CBC8096EA16CD, 7AF70408255288CC
// program: 970AA6E82CDE4E04, 1C4CBC8096EA16CD, BD1D7911CA7BEBFB
// program: F3965AC225A24CBC, 0D30074279C2FEED, 0DA2D889D2CD465D
// program: F3965AC225A24CBC, 0D30074279C2FEED, 046E44E355D9C09A
// program: F3965AC225A24CBC, 0D30074279C2FEED, 107C23D73DF4B2BF
// program: F3965AC225A24CBC, 0D30074279C2FEED, ED074CA328E24A7B
// program: F3965AC225A24CBC, 0D30074279C2FEED, 7BE2A077F32A3F69
// program: F3965AC225A24CBC, 0D30074279C2FEED, AF4EE6C536ED3E7A
// program: F3965AC225A24CBC, 0D30074279C2FEED, BF769EFD399154AD
// program: F3965AC225A24CBC, 0D30074279C2FEED, 7CB7D5CAEB400D5B
// program: F3965AC225A24CBC, 0D30074279C2FEED, E34D1DA909F9ABA3
// shader: 8B31, F11B5DF7CFF03FEE

#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define fma_s(x, y, z) (mix(x * y, vec4(0.0), isnan(x * y)) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;
out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_5();
bool sub_3();
bool sub_1();
bool sub_2();
bool sub_4();
bool sub_6();
bool sub_9();
bool sub_10();
bool sub_16();
bool sub_17();
bool sub_18();
bool sub_19();
bool sub_21();
bool sub_23();
bool sub_24();
bool sub_25();
bool sub_26();
bool sub_27();
bool sub_28();
bool sub_29();
bool sub_30();
bool sub_31();
bool sub_32();
bool sub_33();
bool sub_34();
bool sub_11();
bool sub_12();
bool sub_13();
bool sub_14();
bool sub_15();
bool sub_20();
bool sub_22();
bool sub_0();
bool sub_7();
bool sub_8();

bool exec_shader() {
    sub_0();
    return true;
}

bool sub_5() {
    uint jmp_to = 0u;
    while (true) {
        switch (jmp_to) {
        case 0u: {
            reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
            reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
            reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
            reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
            reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
            reg_tmp6.x = rsq_s(reg_tmp6.x);
            reg_tmp7.x = rsq_s(reg_tmp7.x);
            reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            reg_tmp0 = uniforms.f[93].yxxx;
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            reg_tmp4 = mul_s(uniforms.f[94].xxxx, reg_tmp4);
            conditional_code = greaterThanEqual(uniforms.f[93].xx, reg_tmp4.xx);
            reg_tmp4 = vec4(rsq_s(reg_tmp4.x));
            reg_tmp5 = mul_s(uniforms.f[94].xxxx, reg_tmp14);
            if (conditional_code.x) {
                { jmp_to = 18u; break; }
            }
            reg_tmp0.z = rcp_s(reg_tmp4.x);
            reg_tmp0.xy = (mul_s(reg_tmp5, reg_tmp4)).xy;
        }
        case 18u: {
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_3() {
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    reg_tmp4.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_1() {
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    if (uniforms.b[0]) {
        sub_2();
    } else {
        sub_4();
    }
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    {
        sub_5();
    }
    vs_out_attr2 = -reg_tmp15;
    reg_tmp0.x = (uniforms.f[93].yyyy).x;
    address_registers.x = (ivec2(vs_in_reg3.xx)).x;
    reg_tmp0.x = (mul_s(uniforms.f[13 + address_registers.x].xxxx, reg_tmp0.xxxx)).x;
    address_registers.x = (ivec2(vs_in_reg3.yy)).x;
    reg_tmp0.x = (mul_s(uniforms.f[13 + address_registers.x].yyyy, reg_tmp0.xxxx)).x;
    address_registers.x = (ivec2(vs_in_reg3.zz)).x;
    reg_tmp0.x = (mul_s(uniforms.f[13 + address_registers.x].zzzz, reg_tmp0.xxxx)).x;
    address_registers.x = (ivec2(vs_in_reg3.ww)).x;
    reg_tmp0.x = (mul_s(uniforms.f[13 + address_registers.x].wwww, reg_tmp0.xxxx)).x;
    reg_tmp15.xyz = (mul_s(reg_tmp15.xyzz, reg_tmp0.xxxx)).xyz;
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    if (all(conditional_code)) {
        sub_6();
    }
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_2() {
    reg_tmp7 = uniforms.f[93].xxxx;
    reg_tmp12 = uniforms.f[93].xxxx;
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    {
        sub_3();
    }
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    {
        sub_3();
    }
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    {
        sub_3();
    }
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    {
        sub_3();
    }
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    reg_tmp10 = reg_tmp7;
    return false;
}
bool sub_4() {
    reg_tmp7 = reg_tmp15;
    reg_tmp10.x = dot_s(uniforms.f[10], reg_tmp7);
    reg_tmp10.y = dot_s(uniforms.f[11], reg_tmp7);
    reg_tmp10.z = dot_s(uniforms.f[12], reg_tmp7);
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    reg_tmp12.x = dot_3(uniforms.f[10].xyz, reg_tmp14.xyz);
    reg_tmp12.y = dot_3(uniforms.f[11].xyz, reg_tmp14.xyz);
    reg_tmp12.z = dot_3(uniforms.f[12].xyz, reg_tmp14.xyz);
    return false;
}
bool sub_6() {
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_9() {
    reg_tmp0.xy = (uniforms.f[0].xxxx).xy;
    if (uniforms.b[2]) {
        sub_10();
    } else {
        sub_16();
    }
    return false;
}
bool sub_10() {
    {
        sub_11();
    }
    reg_tmp3.x = dot_s(uniforms.f[1].xywz, reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2].xywz, reg_tmp6);
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_16() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_17();
    } else {
        sub_18();
    }
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_17() {
    reg_tmp6 = reg_tmp10;
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    reg_tmp3.z = dot_s(uniforms.f[3], reg_tmp6);
    reg_tmp0.xy = (mul_s(uniforms.f[9].xyyy, reg_tmp3.zzzz)).xy;
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_18() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_19();
    } else {
        sub_21();
    }
    return false;
}
bool sub_19() {
    {
        sub_20();
    }
    reg_tmp3.x = dot_3(uniforms.f[1].xyz, reg_tmp6.xyz);
    reg_tmp3.y = dot_3(uniforms.f[2].xyz, reg_tmp6.xyz);
    reg_tmp3.z = dot_3(uniforms.f[3].xyz, reg_tmp6.xyz);
    return false;
}
bool sub_21() {
    {
        sub_22();
    }
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    return false;
}
bool sub_23() {
    reg_tmp0.xy = (uniforms.f[0].yyyy).xy;
    if (uniforms.b[3]) {
        sub_24();
    } else {
        sub_25();
    }
    return false;
}
bool sub_24() {
    {
        sub_11();
    }
    reg_tmp4.x = dot_s(uniforms.f[4].xywz, reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5].xywz, reg_tmp6);
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_25() {
    if (uniforms.b[5]) {
        sub_26();
    } else {
        sub_29();
    }
    return false;
}
bool sub_26() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_27();
    } else {
        sub_28();
    }
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_27() {
    reg_tmp6 = reg_tmp10;
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    reg_tmp4.z = dot_s(uniforms.f[6], reg_tmp6);
    reg_tmp6.w = rcp_s(reg_tmp4.z);
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    reg_tmp4.xy = (uniforms.f[9].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_28() {
    {
        sub_22();
    }
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    return false;
}
bool sub_29() {
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_30() {
    reg_tmp0.xy = (uniforms.f[0].zzzz).xy;
    if (uniforms.b[4]) {
        sub_31();
    } else {
        sub_32();
    }
    return false;
}
bool sub_31() {
    {
        sub_11();
    }
    reg_tmp5.x = dot_s(uniforms.f[7].xywz, reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8].xywz, reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_32() {
    if (uniforms.b[6]) {
        sub_33();
    } else {
        sub_34();
    }
    return false;
}
bool sub_33() {
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    {
        sub_22();
    }
    reg_tmp5.x = dot_s(uniforms.f[7], reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8], reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_34() {
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
bool sub_11() {
    conditional_code = equal(uniforms.f[93].yz, reg_tmp0.xy);
    if (all(not(conditional_code))) {
        sub_12();
    } else {
        sub_13();
    }
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_12() {
    reg_tmp6.xy = (vs_in_reg4.xyyy).xy;
    return false;
}
bool sub_13() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_14();
    } else {
        sub_15();
    }
    return false;
}
bool sub_14() {
    reg_tmp6.xy = (vs_in_reg5.xyyy).xy;
    return false;
}
bool sub_15() {
    reg_tmp6.xy = (vs_in_reg6.xyyy).xy;
    return false;
}
bool sub_20() {
    reg_tmp2 = -reg_tmp15;
    reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
    reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_22() {
    reg_tmp1 = reg_tmp14;
    reg_tmp2.w = dot_3(reg_tmp1.xyz, reg_tmp1.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp1 = mul_s(reg_tmp1, reg_tmp2.wwww);
    reg_tmp1 = mul_s(uniforms.f[94].xxxx, reg_tmp1);
    reg_tmp6.xy = (uniforms.f[94].xxxx + reg_tmp1.xyyy).xy;
    return false;
}
bool sub_0() {
    {
        sub_1();
    }
    if (uniforms.b[1]) {
        sub_7();
    } else {
        sub_8();
    }
    vs_out_attr3 = reg_tmp2;
    {
        sub_9();
    }
    {
        sub_23();
    }
    {
        sub_30();
    }
    return true;
}
bool sub_7() {
    reg_tmp0 = vec4(dot_3(uniforms.f[83].xyz, reg_tmp12.xyz));
    reg_tmp0 = max(uniforms.f[93].xxxx, reg_tmp0);
    reg_tmp0 = mul_s(uniforms.f[84], reg_tmp0);
    reg_tmp0 = uniforms.f[85] + reg_tmp0;
    reg_tmp0.w = (uniforms.f[93].yyyy).w;
    reg_tmp1 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
    reg_tmp2 = mul_s(reg_tmp0, reg_tmp1);
    return false;
}
bool sub_8() {
    reg_tmp2 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
    return false;
}
// reference: EEA9CDB03FAB5CD1, F11B5DF7CFF03FEE
// program: F11B5DF7CFF03FEE, 0D30074279C2FEED, B2EFC65400C167E0
// program: F3965AC225A24CBC, 0D30074279C2FEED, BBD49FD48F367AAB
// program: F3965AC225A24CBC, 0D30074279C2FEED, 98D162841361BB8B
// program: F3965AC225A24CBC, 0D30074279C2FEED, 48DDD5B538722E22
// program: F3965AC225A24CBC, 0D30074279C2FEED, 80EECFD6EBD016F2
// program: F3965AC225A24CBC, 0D30074279C2FEED, F96BC818C62F763A
// program: F3965AC225A24CBC, 0D30074279C2FEED, 4C53D7BC7E6EE80B
// program: F3965AC225A24CBC, 0D30074279C2FEED, 3657CCE31A12BD76
// program: F3965AC225A24CBC, 0D30074279C2FEED, 34C8F36A1F3B6C76
// program: F3965AC225A24CBC, 0D30074279C2FEED, 3D9AAC4EFAF520AB
// program: F3965AC225A24CBC, 0D30074279C2FEED, 55A2B9A481178DDA
// program: F3965AC225A24CBC, 0D30074279C2FEED, A944AF56B0C0C95D
// program: F3965AC225A24CBC, 0D30074279C2FEED, 2F521F13578D049A
// program: F3965AC225A24CBC, 0D30074279C2FEED, 39B31CC5B0301580
// program: F3965AC225A24CBC, 0D30074279C2FEED, 9820C4E77BA40ED2
// program: F3965AC225A24CBC, 0D30074279C2FEED, F3A037C6B74B6FEF
// program: D914C0A8DC043EA1, 0D30074279C2FEED, DBA6479C0297E10E
// program: D914C0A8DC043EA1, 0D30074279C2FEED, DBB563E4FA66C8E0
// reference: D3760A84AF5CDCED, D914C0A8DC043EA1
// program: 970AA6E82CDE4E04, 1C4CBC8096EA16CD, DE532DB7DA65108D
// program: 970AA6E82CDE4E04, 1C4CBC8096EA16CD, E333688E7A4E3951
// program: 970AA6E82CDE4E04, 1C4CBC8096EA16CD, F5405F949ABD9CF4
// program: 970AA6E82CDE4E04, 1C4CBC8096EA16CD, 52C5102456B41FEE
// program: F3965AC225A24CBC, 0D30074279C2FEED, 33E9C4BEB3FD7391
// program: F3965AC225A24CBC, 0D30074279C2FEED, 0B042F8EEE02D2C1
// program: F3965AC225A24CBC, 0D30074279C2FEED, 9A1CC78472C59443
// program: F3965AC225A24CBC, 0D30074279C2FEED, 1F5276138FD31E21
// program: 970AA6E82CDE4E04, 1C4CBC8096EA16CD, E14C2D25B88214CA
// program: 970AA6E82CDE4E04, 1C4CBC8096EA16CD, 4F5D3D8CAE07D74A
// program: 970AA6E82CDE4E04, 1C4CBC8096EA16CD, 543EDD4084880F4A
// program: 970AA6E82CDE4E04, 1C4CBC8096EA16CD, 01C79519B7CF99E4
// reference: 59C745235B61595C, F3965AC225A24CBC
// program: F3965AC225A24CBC, 0D30074279C2FEED, A8B0E6AADB116311
// program: 970AA6E82CDE4E04, 1C4CBC8096EA16CD, 66D12121A97B66A8
// program: 970AA6E82CDE4E04, 1C4CBC8096EA16CD, FE7D3792AF1B69C9
// program: F3965AC225A24CBC, 0D30074279C2FEED, CAF7DC684B0E0EEA
// program: F3965AC225A24CBC, 0D30074279C2FEED, 52807296CDCEF34A
// shader: 8B31, 3FBD0C361A2F3294

#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define fma_s(x, y, z) (mix(x * y, vec4(0.0), isnan(x * y)) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location = 0) in vec4 vs_in_reg0;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;
out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_2();
bool sub_3();
bool sub_4();
bool sub_5();
bool sub_7();
bool sub_8();
bool sub_14();
bool sub_15();
bool sub_16();
bool sub_17();
bool sub_19();
bool sub_21();
bool sub_22();
bool sub_23();
bool sub_24();
bool sub_25();
bool sub_26();
bool sub_27();
bool sub_28();
bool sub_29();
bool sub_30();
bool sub_31();
bool sub_32();
bool sub_9();
bool sub_10();
bool sub_11();
bool sub_12();
bool sub_13();
bool sub_18();
bool sub_20();
bool sub_0();
bool sub_1();
bool sub_6();

bool exec_shader() {
    sub_0();
    return true;
}

bool sub_2() {
    reg_tmp1.xyz = (uniforms.f[93].xxyx).xyz;
    reg_tmp8.x = dot_3(uniforms.f[0].xyz, reg_tmp12.xyz);
    reg_tmp8.y = dot_3(uniforms.f[1].xyz, reg_tmp12.xyz);
    reg_tmp8.z = dot_3(uniforms.f[2].xyz, reg_tmp12.xyz);
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp8.xyz);
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp8.xyz);
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp8.xyz);
    reg_tmp14.w = (uniforms.f[93].xxxx).w;
    reg_tmp8 = reg_tmp14;
    reg_tmp14.x = dot_s(reg_tmp8, reg_tmp8);
    reg_tmp14.x = rsq_s(reg_tmp14.x);
    reg_tmp14 = mul_s(reg_tmp8, reg_tmp14.xxxx);
    reg_tmp0 = uniforms.f[23];
    reg_tmp8.x = dot_3(uniforms.f[0].xyz, reg_tmp0.xyz);
    reg_tmp8.y = dot_3(uniforms.f[1].xyz, reg_tmp0.xyz);
    reg_tmp8.z = dot_3(uniforms.f[2].xyz, reg_tmp0.xyz);
    reg_tmp6.x = dot_3(uniforms.f[90].xyz, reg_tmp8.xyz);
    reg_tmp6.y = dot_3(uniforms.f[91].xyz, reg_tmp8.xyz);
    reg_tmp6.z = dot_3(uniforms.f[92].xyz, reg_tmp8.xyz);
    reg_tmp8.xyz = (reg_tmp6.xyzz + reg_tmp1.xyzz).xyz;
    reg_tmp8.w = (uniforms.f[93].xxxx).w;
    reg_tmp0.x = dot_s(reg_tmp8, reg_tmp8);
    reg_tmp0.x = rsq_s(reg_tmp0.x);
    reg_tmp0 = mul_s(reg_tmp8, reg_tmp0.xxxx);
    if (uniforms.b[5]) {
        sub_3();
    }
    if (uniforms.b[3]) {
        sub_4();
    }
    if (uniforms.b[4]) {
        sub_5();
    }
    vs_out_attr3 = reg_tmp2;
    return false;
}
bool sub_3() {
    reg_tmp8.x = dot_3(reg_tmp14.xyz, -reg_tmp6.xyz);
    reg_tmp8.y = dot_3(reg_tmp1.xyz, -reg_tmp6.xyz);
    reg_tmp8 = max(uniforms.f[93].xxxx, reg_tmp8);
    reg_tmp8.y = (mul_s(uniforms.f[94].zzzz, reg_tmp8.yyyy)).y;
    reg_tmp8.y = (uniforms.f[94].zzzz + reg_tmp8.yyyy).y;
    reg_tmp2.y = (mul_s(reg_tmp8.xxxx, reg_tmp8.yyyy)).y;
    return false;
}
bool sub_4() {
    reg_tmp9.z = dot_3(reg_tmp14.xyz, reg_tmp0.xyz);
    reg_tmp9.z = (max(uniforms.f[93].xxxx, reg_tmp9.zzzz)).z;
    reg_tmp9.z = (min(uniforms.f[93].yyyy, reg_tmp9.zzzz)).z;
    reg_tmp9.z = log2(reg_tmp9.z);
    reg_tmp9.z = (mul_s(uniforms.f[22].zzzz, reg_tmp9.zzzz)).z;
    reg_tmp9.z = exp2(reg_tmp9.z);
    reg_tmp2.z = (mul_s(uniforms.f[22].wwww, reg_tmp9.zzzz)).z;
    return false;
}
bool sub_5() {
    reg_tmp9.x = dot_3(reg_tmp14.xyz, reg_tmp1.xyz);
    reg_tmp9.x = (max(uniforms.f[93].xxxx, reg_tmp9.xxxx)).x;
    reg_tmp9.x = (min(uniforms.f[93].yyyy, reg_tmp9.xxxx)).x;
    reg_tmp9.x = (uniforms.f[93].yyyy + -reg_tmp9.xxxx).x;
    reg_tmp9.x = log2(reg_tmp9.x);
    reg_tmp9.x = (mul_s(uniforms.f[22].xxxx, reg_tmp9.xxxx)).x;
    reg_tmp9.x = exp2(reg_tmp9.x);
    reg_tmp2.w = (mul_s(uniforms.f[22].yyyy, reg_tmp9.xxxx)).w;
    return false;
}
bool sub_7() {
    reg_tmp0.xy = (uniforms.f[10].xxxx).xy;
    if (uniforms.b[9]) {
        sub_8();
    } else {
        sub_14();
    }
    return false;
}
bool sub_8() {
    {
        sub_9();
    }
    reg_tmp3.x = dot_s(uniforms.f[11].xywz, reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[12].xywz, reg_tmp6);
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_14() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_15();
    } else {
        sub_16();
    }
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_15() {
    reg_tmp6 = reg_tmp10;
    reg_tmp3.x = dot_s(uniforms.f[11], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[12], reg_tmp6);
    reg_tmp3.z = dot_s(uniforms.f[13], reg_tmp6);
    reg_tmp0.xy = (mul_s(uniforms.f[19].xyyy, reg_tmp3.zzzz)).xy;
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_16() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_17();
    } else {
        sub_19();
    }
    return false;
}
bool sub_17() {
    {
        sub_18();
    }
    reg_tmp3.x = dot_3(uniforms.f[11].xyz, reg_tmp6.xyz);
    reg_tmp3.y = dot_3(uniforms.f[12].xyz, reg_tmp6.xyz);
    reg_tmp3.z = dot_3(uniforms.f[13].xyz, reg_tmp6.xyz);
    return false;
}
bool sub_19() {
    {
        sub_20();
    }
    reg_tmp3.x = dot_s(uniforms.f[11], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[12], reg_tmp6);
    return false;
}
bool sub_21() {
    reg_tmp0.xy = (uniforms.f[10].yyyy).xy;
    if (uniforms.b[10]) {
        sub_22();
    } else {
        sub_23();
    }
    return false;
}
bool sub_22() {
    {
        sub_9();
    }
    reg_tmp4.x = dot_s(uniforms.f[14].xywz, reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[15].xywz, reg_tmp6);
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_23() {
    if (uniforms.b[13]) {
        sub_24();
    } else {
        sub_27();
    }
    return false;
}
bool sub_24() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_25();
    } else {
        sub_26();
    }
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_25() {
    reg_tmp6 = reg_tmp10;
    reg_tmp4.x = dot_s(uniforms.f[14], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[15], reg_tmp6);
    reg_tmp4.z = dot_s(uniforms.f[16], reg_tmp6);
    reg_tmp6.w = rcp_s(reg_tmp4.z);
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    reg_tmp4.xy = (uniforms.f[19].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_26() {
    {
        sub_20();
    }
    reg_tmp4.x = dot_s(uniforms.f[14], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[15], reg_tmp6);
    return false;
}
bool sub_27() {
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_28() {
    reg_tmp0.xy = (uniforms.f[10].zzzz).xy;
    if (uniforms.b[11]) {
        sub_29();
    } else {
        sub_30();
    }
    return false;
}
bool sub_29() {
    {
        sub_9();
    }
    reg_tmp5.x = dot_s(uniforms.f[17].xywz, reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[18].xywz, reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_30() {
    if (uniforms.b[14]) {
        sub_31();
    } else {
        sub_32();
    }
    return false;
}
bool sub_31() {
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    {
        sub_20();
    }
    reg_tmp5.x = dot_s(uniforms.f[17], reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[18], reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_32() {
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
bool sub_9() {
    conditional_code = equal(uniforms.f[93].yz, reg_tmp0.xy);
    if (all(not(conditional_code))) {
        sub_10();
    } else {
        sub_11();
    }
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_10() {
    reg_tmp6.xy = (mul_s(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
    return false;
}
bool sub_11() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_12();
    } else {
        sub_13();
    }
    return false;
}
bool sub_12() {
    reg_tmp6.xy = (mul_s(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
    return false;
}
bool sub_13() {
    reg_tmp6.xy = (mul_s(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
    return false;
}
bool sub_18() {
    reg_tmp2 = -reg_tmp15;
    reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
    reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_20() {
    reg_tmp1.xy = (uniforms.f[94].zzzz).xy;
    reg_tmp1.zw = (uniforms.f[93].xxxx).zw;
    reg_tmp6 = fma_s(reg_tmp14, reg_tmp1, reg_tmp1);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_0() {
    reg_tmp0 = vs_in_reg0;
    reg_tmp0.z = (uniforms.f[93].xxxx).z;
    reg_tmp0.w = (uniforms.f[93].yyyy).w;
    vs_out_attr0 = reg_tmp0;
    vs_out_attr2 = reg_tmp0;
    vs_out_attr1 = reg_tmp0;
    if (uniforms.b[6]) {
        sub_1();
    } else {
        sub_6();
    }
    {
        sub_7();
    }
    {
        sub_21();
    }
    {
        sub_28();
    }
    return true;
}
bool sub_1() {
    {
        sub_2();
    }
    return false;
}
bool sub_6() {
    vs_out_attr3 = uniforms.f[93].yyyy;
    return false;
}
// reference: D2E2F111BDC526B0, 3FBD0C361A2F3294
// program: 3FBD0C361A2F3294, 0D30074279C2FEED, 4F0C86E8EDDB4D45
// program: F3965AC225A24CBC, 0D30074279C2FEED, BE3540B3D7A2029D
// program: 970AA6E82CDE4E04, 1C4CBC8096EA16CD, F7CE14589569CE00
// program: 970AA6E82CDE4E04, 1C4CBC8096EA16CD, EBE52129F4D9ADBD
// program: 970AA6E82CDE4E04, 1C4CBC8096EA16CD, 29DBC75E0C056C08
// program: 970AA6E82CDE4E04, 1C4CBC8096EA16CD, 8FAC176B88F21959
// program: F3965AC225A24CBC, 0D30074279C2FEED, F865192BFE939ABB
// program: F3965AC225A24CBC, 0D30074279C2FEED, E4AD2884C5B04375
// program: F3965AC225A24CBC, 0D30074279C2FEED, D8044A0C153D159B
// program: D914C0A8DC043EA1, 0D30074279C2FEED, 791B67746515F5BD
// program: F3965AC225A24CBC, 0D30074279C2FEED, DBBD969AF0C66F49
// program: F3965AC225A24CBC, 0D30074279C2FEED, C3A99FDA1696A8B2
// program: F3965AC225A24CBC, 0D30074279C2FEED, 44776903C2844A30
// program: F3965AC225A24CBC, 0D30074279C2FEED, EA6884D3FFEAEBB5
// program: F3965AC225A24CBC, 0D30074279C2FEED, 61DF23C9A6C975E6
// program: F3965AC225A24CBC, 0D30074279C2FEED, B35EFE43E319BB63
// shader: 8B31, EEF51AC3C5D9903C

#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define fma_s(x, y, z) (mix(x * y, vec4(0.0), isnan(x * y)) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location = 0) in vec4 vs_in_reg0;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_1();
bool sub_15();
bool sub_2();
bool sub_5();
bool sub_6();
bool sub_7();
bool sub_8();
bool sub_9();
bool sub_10();
bool sub_11();
bool sub_12();
bool sub_13();
bool sub_14();
bool sub_0();
bool sub_3();
bool sub_4();

bool exec_shader() {
    sub_0();
    return true;
}

bool sub_1() {
    address_registers.x = (ivec2(vs_in_reg0.zz)).x;
    reg_tmp10 = uniforms.f[0].xxxz;
    reg_tmp10.xy = (vs_in_reg0.xyyy).xy;
    reg_tmp11 = uniforms.f[0].xxxx;
    reg_tmp12 = uniforms.f[0].xxxx;
    reg_tmp13 = uniforms.f[0].zzzz;
    reg_tmp4 = uniforms.f[0].xxxx;
    reg_tmp5 = uniforms.f[0].xxxx;
    return false;
}
bool sub_15() {
    vs_out_attr0 = reg_tmp10;
    reg_tmp13 = mul_s(uniforms.f[82], reg_tmp13);
    vs_out_attr1 = reg_tmp13;
    reg_tmp11.y = (uniforms.f[0].zzzz + -reg_tmp11.yyyy).y;
    reg_tmp12.y = (uniforms.f[0].zzzz + -reg_tmp12.yyyy).y;
    reg_tmp14.y = (uniforms.f[81].wwww).y;
    reg_tmp14.x = (mul_s(uniforms.f[0].wwww, reg_tmp14.yyyy)).x;
    reg_tmp2.x = rcp_s(reg_tmp14.x);
    reg_tmp14.z = (reg_tmp2.xxxx).z;
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp11.xyyy).xy;
    reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    reg_tmp11.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp12.xyyy).xy;
    reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    reg_tmp12.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    vs_out_attr2 = reg_tmp11;
    vs_out_attr3 = reg_tmp12;
    return false;
}
bool sub_2() {
    reg_tmp6.xyz = (-reg_tmp0.xyzz).xyz;
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    reg_tmp7.xyz = vec3(rcp_s(uniforms.f[81].y));
    reg_tmp8.xyz = (fma_s(reg_tmp6.xyzz, reg_tmp7.xyzz, uniforms.f[0].yyyy)).xyz;
    reg_tmp7.xyz = (floor(reg_tmp8.xyzz)).xyz;
    reg_tmp6.xyz = (fma_s(reg_tmp7.xyzz, -uniforms.f[81].yyyy, reg_tmp6.xyzz)).xyz;
    reg_tmp6 = min(uniforms.f[81].xxxx, reg_tmp6);
    reg_tmp6 = max(-uniforms.f[81].xxxx, reg_tmp6);
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp6.xxxx, reg_tmp6.xxxx)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp6.xxxx)).y;
    reg_tmp4.x = (reg_tmp1.xxxx).x;
    reg_tmp5.x = (reg_tmp1.yyyy).x;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp6.yyyy, reg_tmp6.yyyy)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp6.yyyy)).y;
    reg_tmp4.y = (reg_tmp1.xxxx).y;
    reg_tmp5.y = (reg_tmp1.yyyy).y;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp6.zzzz, reg_tmp6.zzzz)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp6.zzzz)).y;
    reg_tmp4.z = (reg_tmp1.xxxx).z;
    reg_tmp5.z = (reg_tmp1.yyyy).z;
    reg_tmp2.x = (mul_s(reg_tmp4.yyyy, reg_tmp5.zzzz)).x;
    reg_tmp2.y = (mul_s(reg_tmp5.yyyy, reg_tmp5.zzzz)).y;
    reg_tmp6.x = (mul_s(reg_tmp4.yyyy, reg_tmp4.zzzz)).x;
    reg_tmp6.y = (reg_tmp5.zzzz).y;
    reg_tmp6.z = (mul_s(-reg_tmp5.yyyy, reg_tmp4.zzzz)).z;
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    reg_tmp7.x = (mul_s(-reg_tmp2.xxxx, reg_tmp4.xxxx)).x;
    reg_tmp7.x = (fma_s(reg_tmp5.yyyy, reg_tmp5.xxxx, reg_tmp7.xxxx)).x;
    reg_tmp7.y = (mul_s(reg_tmp4.zzzz, reg_tmp4.xxxx)).y;
    reg_tmp7.z = (mul_s(reg_tmp2.yyyy, reg_tmp4.xxxx)).z;
    reg_tmp7.z = (fma_s(reg_tmp4.yyyy, reg_tmp5.xxxx, reg_tmp7.zzzz)).z;
    reg_tmp7.w = (uniforms.f[0].xxxx).w;
    reg_tmp8.x = (mul_s(reg_tmp2.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp8.x = (fma_s(reg_tmp5.yyyy, reg_tmp4.xxxx, reg_tmp8.xxxx)).x;
    reg_tmp8.y = (mul_s(-reg_tmp4.zzzz, reg_tmp5.xxxx)).y;
    reg_tmp8.z = (mul_s(-reg_tmp2.yyyy, reg_tmp5.xxxx)).z;
    reg_tmp8.z = (fma_s(reg_tmp4.yyyy, reg_tmp4.xxxx, reg_tmp8.zzzz)).z;
    reg_tmp8.w = (uniforms.f[0].xxxx).w;
    reg_tmp9 = uniforms.f[0].xxxz;
    return false;
}
bool sub_5() {
    reg_tmp2 = uniforms.f[90];
    reg_tmp3 = uniforms.f[91];
    reg_tmp4 = uniforms.f[92];
    reg_tmp5 = uniforms.f[0].xxxz;
    reg_tmp6 = mul_s(uniforms.f[86].xxxx, reg_tmp2);
    reg_tmp6 = fma_s(reg_tmp3, uniforms.f[86].yyyy, reg_tmp6);
    reg_tmp6 = fma_s(reg_tmp4, uniforms.f[86].zzzz, reg_tmp6);
    reg_tmp6 = fma_s(reg_tmp5, uniforms.f[86].wwww, reg_tmp6);
    reg_tmp7 = mul_s(uniforms.f[87].xxxx, reg_tmp2);
    reg_tmp7 = fma_s(reg_tmp3, uniforms.f[87].yyyy, reg_tmp7);
    reg_tmp7 = fma_s(reg_tmp4, uniforms.f[87].zzzz, reg_tmp7);
    reg_tmp7 = fma_s(reg_tmp5, uniforms.f[87].wwww, reg_tmp7);
    reg_tmp8 = mul_s(uniforms.f[88].xxxx, reg_tmp2);
    reg_tmp8 = fma_s(reg_tmp3, uniforms.f[88].yyyy, reg_tmp8);
    reg_tmp8 = fma_s(reg_tmp4, uniforms.f[88].zzzz, reg_tmp8);
    reg_tmp8 = fma_s(reg_tmp5, uniforms.f[88].wwww, reg_tmp8);
    reg_tmp9 = mul_s(uniforms.f[89].xxxx, reg_tmp2);
    reg_tmp9 = fma_s(reg_tmp3, uniforms.f[89].yyyy, reg_tmp9);
    reg_tmp9 = fma_s(reg_tmp4, uniforms.f[89].zzzz, reg_tmp9);
    reg_tmp9 = fma_s(reg_tmp5, uniforms.f[89].wwww, reg_tmp9);
    return false;
}
bool sub_6() {
    reg_tmp2.x = rcp_s(uniforms.f[81].y);
    reg_tmp2.xy = (mul_s(uniforms.f[2 + address_registers.x].zwww, reg_tmp2.xxxx)).xy;
    reg_tmp2.xy = (uniforms.f[0].yyyy + reg_tmp2.xyyy).xy;
    reg_tmp3.xy = (floor(reg_tmp2.xyyy)).xy;
    reg_tmp2.xy = (mul_s(uniforms.f[81].yyyy, reg_tmp3.xyyy)).xy;
    reg_tmp2.xy = (uniforms.f[2 + address_registers.x].zwww + -reg_tmp2.xyyy).xy;
    reg_tmp0.xy = (min(uniforms.f[81].xxxx, -reg_tmp2.xyyy)).xy;
    reg_tmp0.xy = (max(-uniforms.f[81].xxxx, reg_tmp0.xyyy)).xy;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp0.xxxx, reg_tmp0.xxxx)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.xxxx)).y;
    reg_tmp5.x = (uniforms.f[5 + address_registers.x].wwww).x;
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_7();
    }
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_8();
    }
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_9();
    }
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_10();
    }
    reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    reg_tmp4.z = (uniforms.f[83].xxxx).z;
    reg_tmp4.w = (-uniforms.f[83].yyyy).w;
    reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[3 + address_registers.x].xyyy)).xy;
    reg_tmp4.z = (-uniforms.f[3 + address_registers.x].zzzz).z;
    reg_tmp4.w = (-uniforms.f[3 + address_registers.x].wwww).w;
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    reg_tmp11.xy = (reg_tmp5.xyyy).xy;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp0.yyyy, reg_tmp0.yyyy)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.yyyy)).y;
    reg_tmp5.x = (uniforms.f[6 + address_registers.x].wwww).x;
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_11();
    }
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_12();
    }
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_13();
    }
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_14();
    }
    reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    reg_tmp4.z = (uniforms.f[83].zzzz).z;
    reg_tmp4.w = (-uniforms.f[83].wwww).w;
    reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[4 + address_registers.x].xyyy)).xy;
    reg_tmp4.z = (-uniforms.f[4 + address_registers.x].zzzz).z;
    reg_tmp4.w = (-uniforms.f[4 + address_registers.x].wwww).w;
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    reg_tmp12.xy = (reg_tmp5.xyyy).xy;
    return false;
}
bool sub_7() {
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_8() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_9() {
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_10() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_11() {
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_12() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_13() {
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_14() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_0() {
    {
        sub_1();
    }
    reg_tmp10.xy = (uniforms.f[84].xyyy + reg_tmp10.xyyy).xy;
    reg_tmp10.xy = (mul_s(uniforms.f[2 + address_registers.x].xyyy, reg_tmp10.xyyy)).xy;
    reg_tmp14 = reg_tmp10;
    reg_tmp0 = uniforms.f[7 + address_registers.x];
    {
        sub_2();
    }
    reg_tmp10.x = dot_s(reg_tmp14, reg_tmp6);
    reg_tmp10.y = dot_s(reg_tmp14, reg_tmp7);
    reg_tmp10.z = dot_s(reg_tmp14, reg_tmp8);
    reg_tmp10.w = dot_s(reg_tmp14, reg_tmp9);
    reg_tmp6 = uniforms.f[8 + address_registers.x];
    reg_tmp7 = uniforms.f[9 + address_registers.x];
    reg_tmp8 = uniforms.f[10 + address_registers.x];
    reg_tmp9 = uniforms.f[0].xxxz;
    reg_tmp6.w = (uniforms.f[5 + address_registers.x].xxxx).w;
    reg_tmp7.w = (uniforms.f[5 + address_registers.x].yyyy).w;
    reg_tmp8.w = (uniforms.f[5 + address_registers.x].zzzz).w;
    reg_tmp2.x = dot_s(reg_tmp10, reg_tmp6);
    reg_tmp2.y = dot_s(reg_tmp10, reg_tmp7);
    reg_tmp2.z = dot_s(reg_tmp10, reg_tmp8);
    reg_tmp2.w = dot_s(reg_tmp10, reg_tmp9);
    reg_tmp10 = reg_tmp2;
    reg_tmp3.xyz = (uniforms.f[5 + address_registers.x].xyzz).xyz;
    reg_tmp3.xyz = (uniforms.f[85].xyzz + -reg_tmp3.xyzz).xyz;
    reg_tmp4.x = dot_3(reg_tmp3.xyz, reg_tmp3.xyz);
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
    if (conditional_code.x) {
        sub_3();
    } else {
        sub_4();
    }
    reg_tmp3.xyz = (mul_s(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
    reg_tmp10.xyz = (fma_s(reg_tmp3.xyzz, uniforms.f[84].zzzz, reg_tmp10.xyzz)).xyz;
    {
        sub_5();
    }
    reg_tmp2 = reg_tmp10;
    reg_tmp10.x = dot_s(reg_tmp2, reg_tmp6);
    reg_tmp10.y = dot_s(reg_tmp2, reg_tmp7);
    reg_tmp10.z = dot_s(reg_tmp2, reg_tmp8);
    reg_tmp10.w = dot_s(reg_tmp2, reg_tmp9);
    reg_tmp2 = uniforms.f[1 + address_registers.x];
    reg_tmp3 = max(uniforms.f[0].xxxx, reg_tmp2);
    reg_tmp2 = min(uniforms.f[0].zzzz, reg_tmp3);
    reg_tmp13 = reg_tmp2;
    {
        sub_6();
    }
    {
        sub_15();
    }
    return true;
}
bool sub_3() {
    reg_tmp4.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_4() {
    reg_tmp4.x = rsq_s(reg_tmp4.x);
    return false;
}
// reference: 9E14AD083C703F9B, EEF51AC3C5D9903C
// program: EEF51AC3C5D9903C, 13A54CCD8AA1DDA2, B6B08DE0C83FF4C8
// program: 970AA6E82CDE4E04, 1C4CBC8096EA16CD, 4513080BBAB785A8
// shader: 8B31, D1ACBB21B5720FEB

#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define fma_s(x, y, z) (mix(x * y, vec4(0.0), isnan(x * y)) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location = 0) in vec4 vs_in_reg0;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;
out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_2();
bool sub_1();
bool sub_3();
bool sub_4();
bool sub_0();

bool exec_shader() {
    sub_0();
    return true;
}

bool sub_2() {
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    return false;
}
bool sub_1() {
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    reg_tmp7 = uniforms.f[93].xxxx;
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    {
        sub_2();
    }
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    {
        sub_2();
    }
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    if (conditional_code.x) {
        sub_2();
    }
    if (uniforms.b[11]) {
        sub_3();
    }
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    reg_tmp10 = reg_tmp7;
    reg_tmp6.y = (-uniforms.f[83].wwww + reg_tmp10.yyyy).y;
    reg_tmp9.xyz = (uniforms.f[83].xyzz).xyz;
    reg_tmp7.x = dot_s(reg_tmp9.xyzz, reg_tmp9.xyzz);
    reg_tmp7.x = rsq_s(reg_tmp7.x);
    reg_tmp7.xyz = (mul_s(reg_tmp9.xyzz, reg_tmp7.xxxx)).xyz;
    reg_tmp8.y = rcp_s(-reg_tmp7.y);
    reg_tmp8.y = (mul_s(reg_tmp6.yyyy, reg_tmp8.yyyy)).y;
    reg_tmp7.xyz = (mul_s(reg_tmp7.xyzz, reg_tmp8.yyyy)).xyz;
    reg_tmp10.xyz = (reg_tmp10.xyzz + reg_tmp7.xyzz).xyz;
    reg_tmp10.y = (uniforms.f[94].xxxx + reg_tmp10.yyyy).y;
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    vs_out_attr1 = uniforms.f[93].xxxx;
    vs_out_attr2 = reg_tmp15;
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    if (all(conditional_code)) {
        sub_4();
    }
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_3() {
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    if (conditional_code.y) {
        sub_2();
    }
    return false;
}
bool sub_4() {
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_0() {
    {
        sub_1();
    }
    vs_out_attr4 = uniforms.f[93].xxxx;
    vs_out_attr5 = uniforms.f[93].xxxx;
    vs_out_attr6 = uniforms.f[93].xxxx;
    vs_out_attr3 = uniforms.f[93].yyyy;
    return true;
}
// reference: B4A0054E70AABD46, D1ACBB21B5720FEB
// program: D1ACBB21B5720FEB, 0D30074279C2FEED, 5C810B10151A2528
// shader: 8B31, 652E658966E83843

#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define fma_s(x, y, z) (mix(x * y, vec4(0.0), isnan(x * y)) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;
out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_2();
bool sub_5();
bool sub_6();
bool sub_7();
bool sub_8();
bool sub_9();
bool sub_0();
bool sub_1();
bool sub_3();
bool sub_4();

bool exec_shader() {
    sub_0();
    return true;
}

bool sub_2() {
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    reg_tmp4.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_5() {
    conditional_code = equal(uniforms.f[93].yz, reg_tmp0.xy);
    if (all(not(conditional_code))) {
        sub_6();
    } else {
        sub_7();
    }
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_6() {
    reg_tmp6.xy = (vs_in_reg4.xyyy).xy;
    return false;
}
bool sub_7() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_8();
    } else {
        sub_9();
    }
    return false;
}
bool sub_8() {
    reg_tmp6.xy = (vs_in_reg5.xyyy).xy;
    return false;
}
bool sub_9() {
    reg_tmp6.xy = (vs_in_reg6.xyyy).xy;
    return false;
}
bool sub_0() {
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    if (uniforms.b[0]) {
        sub_1();
    } else {
        sub_3();
    }
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    if (all(conditional_code)) {
        sub_4();
    }
    vs_out_attr0 = reg_tmp0;
    vs_out_attr1 = uniforms.f[93].xxxx;
    vs_out_attr2 = uniforms.f[93].xxxx;
    reg_tmp0 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
    vs_out_attr3 = uniforms.f[94].zzzz + reg_tmp0;
    reg_tmp5.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    reg_tmp5.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    reg_tmp5.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    reg_tmp4.x = dot_s(reg_tmp5.xyzz, reg_tmp5.xyzz);
    reg_tmp4.x = rsq_s(reg_tmp4.x);
    reg_tmp4.xyz = (mul_s(reg_tmp5.xyzz, reg_tmp4.xxxx)).xyz;
    reg_tmp4 = mul_s(uniforms.f[94].xxxx, reg_tmp4);
    reg_tmp12 = uniforms.f[94].xxxx + reg_tmp4;
    vs_out_attr4 = reg_tmp12;
    reg_tmp0.xy = (uniforms.f[0].xxxx).xy;
    {
        sub_5();
    }
    reg_tmp4.x = dot_s(uniforms.f[4].xywz, reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5].xywz, reg_tmp6);
    vs_out_attr5 = reg_tmp4;
    vs_out_attr6 = reg_tmp4;
    return true;
}
bool sub_1() {
    reg_tmp7 = uniforms.f[93].xxxx;
    reg_tmp12 = uniforms.f[93].xxxx;
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    {
        sub_2();
    }
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    {
        sub_2();
    }
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    if (conditional_code.x) {
        sub_2();
    }
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    if (conditional_code.y) {
        sub_2();
    }
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    reg_tmp10 = reg_tmp7;
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    return false;
}
bool sub_3() {
    reg_tmp7 = reg_tmp15;
    reg_tmp10.x = dot_s(uniforms.f[10], reg_tmp7);
    reg_tmp10.y = dot_s(uniforms.f[11], reg_tmp7);
    reg_tmp10.z = dot_s(uniforms.f[12], reg_tmp7);
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    reg_tmp12.x = dot_s(uniforms.f[10], reg_tmp14);
    reg_tmp12.y = dot_s(uniforms.f[11], reg_tmp14);
    reg_tmp12.z = dot_s(uniforms.f[12], reg_tmp14);
    return false;
}
bool sub_4() {
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
// reference: 86F3078E26264823, 652E658966E83843
// program: 652E658966E83843, 0D30074279C2FEED, 36A2BF4DC040E4A7
// shader: 8B31, ECCD2E5CC6737F3E

#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define fma_s(x, y, z) (mix(x * y, vec4(0.0), isnan(x * y)) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;
out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_11();
bool sub_9();
bool sub_3();
bool sub_5();
bool sub_2();
bool sub_4();
bool sub_6();
bool sub_8();
bool sub_10();
bool sub_12();
bool sub_19();
bool sub_20();
bool sub_26();
bool sub_27();
bool sub_28();
bool sub_29();
bool sub_31();
bool sub_33();
bool sub_34();
bool sub_35();
bool sub_36();
bool sub_37();
bool sub_38();
bool sub_39();
bool sub_40();
bool sub_41();
bool sub_42();
bool sub_43();
bool sub_44();
bool sub_21();
bool sub_22();
bool sub_23();
bool sub_24();
bool sub_25();
bool sub_30();
bool sub_32();
bool sub_14();
bool sub_15();
bool sub_16();
bool sub_17();
bool sub_0();
bool sub_1();
bool sub_7();
bool sub_13();
bool sub_18();

bool exec_shader() {
    sub_0();
    return true;
}

bool sub_11() {
    uint jmp_to = 0u;
    while (true) {
        switch (jmp_to) {
        case 0u: {
            reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
            reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
            reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
            reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
            reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
            reg_tmp6.x = rsq_s(reg_tmp6.x);
            reg_tmp7.x = rsq_s(reg_tmp7.x);
            reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            reg_tmp0 = uniforms.f[93].yxxx;
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            reg_tmp4 = mul_s(uniforms.f[94].xxxx, reg_tmp4);
            conditional_code = greaterThanEqual(uniforms.f[93].xx, reg_tmp4.xx);
            reg_tmp4 = vec4(rsq_s(reg_tmp4.x));
            reg_tmp5 = mul_s(uniforms.f[94].xxxx, reg_tmp14);
            if (conditional_code.x) {
                { jmp_to = 18u; break; }
            }
            reg_tmp0.z = rcp_s(reg_tmp4.x);
            reg_tmp0.xy = (mul_s(reg_tmp5, reg_tmp4)).xy;
        }
        case 18u: {
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_9() {
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    reg_tmp4.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_3() {
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    reg_tmp3.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp3.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp3.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp12);
    reg_tmp3.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp13.xyz);
    reg_tmp3.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp13.xyz);
    reg_tmp3.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp13.xyz);
    reg_tmp11 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp11);
    reg_tmp3.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp5.xyz);
    reg_tmp3.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp5.xyz);
    reg_tmp3.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp5.xyz);
    reg_tmp9 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp9);
    reg_tmp3.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp6.xyz);
    reg_tmp3.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp6.xyz);
    reg_tmp3.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp6.xyz);
    reg_tmp8 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp8);
    return false;
}
bool sub_5() {
    reg_tmp0.xyz = (mul_s(reg_tmp9.yzxx, reg_tmp8.zxyy)).xyz;
    reg_tmp0.xyz = (fma_s(-reg_tmp8.yzxx, reg_tmp9.zxyy, reg_tmp0)).xyz;
    reg_tmp1 = uniforms.f[83];
    reg_tmp2.x = dot_s(reg_tmp1.xyzz, reg_tmp1.xyzz);
    reg_tmp2.x = rsq_s(reg_tmp2.x);
    reg_tmp2.xyz = (mul_s(reg_tmp1.xyzz, reg_tmp2.xxxx)).xyz;
    reg_tmp1.x = dot_3(reg_tmp2.xyz, reg_tmp8.xyz);
    reg_tmp1.y = dot_3(reg_tmp2.xyz, reg_tmp0.xyz);
    reg_tmp1.z = dot_3(reg_tmp2.xyz, reg_tmp9.xyz);
    reg_tmp2.x = dot_s(reg_tmp1.xyzz, reg_tmp1.xyzz);
    reg_tmp2.x = rsq_s(reg_tmp2.x);
    reg_tmp2.xyz = (mul_s(reg_tmp1.xyzz, reg_tmp2.xxxx)).xyz;
    reg_tmp2.w = (uniforms.f[93].yyyy).w;
    vs_out_attr2 = reg_tmp2;
    return false;
}
bool sub_2() {
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    reg_tmp13.xyz = (vs_in_reg2).xyz;
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    reg_tmp5 = uniforms.f[93].xxyy;
    reg_tmp6 = uniforms.f[93].yxxy;
    reg_tmp7 = uniforms.f[93].xxxx;
    reg_tmp12 = uniforms.f[93].xxxx;
    reg_tmp11 = uniforms.f[93].xxxx;
    reg_tmp9 = uniforms.f[93].xxxx;
    reg_tmp8 = uniforms.f[93].xxxx;
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    {
        sub_3();
    }
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    {
        sub_3();
    }
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    if (conditional_code.x) {
        sub_3();
    }
    if (uniforms.b[11]) {
        sub_4();
    }
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    reg_tmp10 = reg_tmp7;
    reg_tmp13.x = dot_3(uniforms.f[90].xyz, reg_tmp11.xyz);
    reg_tmp13.y = dot_3(uniforms.f[91].xyz, reg_tmp11.xyz);
    reg_tmp13.z = dot_3(uniforms.f[92].xyz, reg_tmp11.xyz);
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    {
        sub_5();
    }
    vs_out_attr1 = uniforms.f[93].xxxy;
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    if (all(conditional_code)) {
        sub_6();
    }
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_4() {
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    if (conditional_code.y) {
        sub_3();
    }
    return false;
}
bool sub_6() {
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_8() {
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    reg_tmp7 = uniforms.f[93].xxxx;
    reg_tmp12 = uniforms.f[93].xxxx;
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    {
        sub_9();
    }
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    {
        sub_9();
    }
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    if (conditional_code.x) {
        sub_9();
    }
    if (uniforms.b[11]) {
        sub_10();
    }
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    reg_tmp10 = reg_tmp7;
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    {
        sub_11();
    }
    vs_out_attr2 = -reg_tmp15;
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    if (all(conditional_code)) {
        sub_12();
    }
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_10() {
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    if (conditional_code.y) {
        sub_9();
    }
    return false;
}
bool sub_12() {
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_19() {
    reg_tmp0.xy = (uniforms.f[0].xxxx).xy;
    if (uniforms.b[2]) {
        sub_20();
    } else {
        sub_26();
    }
    return false;
}
bool sub_20() {
    {
        sub_21();
    }
    reg_tmp3.x = dot_s(uniforms.f[1].xywz, reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2].xywz, reg_tmp6);
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_26() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_27();
    } else {
        sub_28();
    }
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_27() {
    reg_tmp6 = reg_tmp10;
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    reg_tmp3.z = dot_s(uniforms.f[3], reg_tmp6);
    reg_tmp0.xy = (mul_s(uniforms.f[9].xyyy, reg_tmp3.zzzz)).xy;
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_28() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_29();
    } else {
        sub_31();
    }
    return false;
}
bool sub_29() {
    {
        sub_30();
    }
    reg_tmp3.x = dot_3(uniforms.f[1].xyz, reg_tmp6.xyz);
    reg_tmp3.y = dot_3(uniforms.f[2].xyz, reg_tmp6.xyz);
    reg_tmp3.z = dot_3(uniforms.f[3].xyz, reg_tmp6.xyz);
    return false;
}
bool sub_31() {
    {
        sub_32();
    }
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    return false;
}
bool sub_33() {
    reg_tmp0.xy = (uniforms.f[0].yyyy).xy;
    if (uniforms.b[3]) {
        sub_34();
    } else {
        sub_35();
    }
    return false;
}
bool sub_34() {
    {
        sub_21();
    }
    reg_tmp4.x = dot_s(uniforms.f[4].xywz, reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5].xywz, reg_tmp6);
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_35() {
    if (uniforms.b[5]) {
        sub_36();
    } else {
        sub_39();
    }
    return false;
}
bool sub_36() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_37();
    } else {
        sub_38();
    }
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_37() {
    reg_tmp6 = reg_tmp10;
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    reg_tmp4.z = dot_s(uniforms.f[6], reg_tmp6);
    reg_tmp6.w = rcp_s(reg_tmp4.z);
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    reg_tmp4.xy = (uniforms.f[9].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_38() {
    {
        sub_32();
    }
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    return false;
}
bool sub_39() {
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_40() {
    reg_tmp0.xy = (uniforms.f[0].zzzz).xy;
    if (uniforms.b[4]) {
        sub_41();
    } else {
        sub_42();
    }
    return false;
}
bool sub_41() {
    {
        sub_21();
    }
    reg_tmp5.x = dot_s(uniforms.f[7].xywz, reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8].xywz, reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_42() {
    if (uniforms.b[6]) {
        sub_43();
    } else {
        sub_44();
    }
    return false;
}
bool sub_43() {
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    {
        sub_32();
    }
    reg_tmp5.x = dot_s(uniforms.f[7], reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8], reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_44() {
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
bool sub_21() {
    conditional_code = equal(uniforms.f[93].yz, reg_tmp0.xy);
    if (all(not(conditional_code))) {
        sub_22();
    } else {
        sub_23();
    }
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_22() {
    reg_tmp6.xy = (vs_in_reg4.xyyy).xy;
    return false;
}
bool sub_23() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_24();
    } else {
        sub_25();
    }
    return false;
}
bool sub_24() {
    reg_tmp6.xy = (vs_in_reg5.xyyy).xy;
    return false;
}
bool sub_25() {
    reg_tmp6.xy = (vs_in_reg6.xyyy).xy;
    return false;
}
bool sub_30() {
    reg_tmp2 = -reg_tmp15;
    reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
    reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_32() {
    reg_tmp1 = reg_tmp14;
    reg_tmp2.w = dot_3(reg_tmp1.xyz, reg_tmp1.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp1 = mul_s(reg_tmp1, reg_tmp2.wwww);
    reg_tmp1 = mul_s(uniforms.f[94].xxxx, reg_tmp1);
    reg_tmp6.xy = (uniforms.f[94].xxxx + reg_tmp1.xyyy).xy;
    return false;
}
bool sub_14() {
    reg_tmp1.xyz = (uniforms.f[93].xxyx).xyz;
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    reg_tmp14.w = (uniforms.f[93].xxxx).w;
    reg_tmp8 = reg_tmp14;
    reg_tmp14.x = dot_s(reg_tmp8, reg_tmp8);
    reg_tmp14.x = rsq_s(reg_tmp14.x);
    reg_tmp14 = mul_s(reg_tmp8, reg_tmp14.xxxx);
    reg_tmp8 = uniforms.f[83];
    reg_tmp6.x = dot_3(uniforms.f[90].xyz, reg_tmp8.xyz);
    reg_tmp6.y = dot_3(uniforms.f[91].xyz, reg_tmp8.xyz);
    reg_tmp6.z = dot_3(uniforms.f[92].xyz, reg_tmp8.xyz);
    reg_tmp8.xyz = (reg_tmp6.xyzz + reg_tmp1.xyzz).xyz;
    reg_tmp8.w = (uniforms.f[93].xxxx).w;
    reg_tmp0.x = dot_s(reg_tmp8, reg_tmp8);
    reg_tmp0.x = rsq_s(reg_tmp0.x);
    reg_tmp0 = mul_s(reg_tmp8, reg_tmp0.xxxx);
    reg_tmp2 = uniforms.f[93].xxxx;
    if (uniforms.b[9]) {
        sub_15();
    }
    if (uniforms.b[7]) {
        sub_16();
    }
    if (uniforms.b[8]) {
        sub_17();
    }
    vs_out_attr3 = reg_tmp2;
    return false;
}
bool sub_15() {
    reg_tmp8.x = dot_3(reg_tmp14.xyz, -reg_tmp6.xyz);
    reg_tmp8.y = dot_3(reg_tmp1.xyz, -reg_tmp6.xyz);
    reg_tmp8 = max(uniforms.f[93].xxxx, reg_tmp8);
    reg_tmp8.y = (mul_s(uniforms.f[94].xxxx, reg_tmp8.yyyy)).y;
    reg_tmp8.y = (uniforms.f[94].xxxx + reg_tmp8.yyyy).y;
    reg_tmp2.y = (mul_s(reg_tmp8.xxxx, reg_tmp8.yyyy)).y;
    return false;
}
bool sub_16() {
    reg_tmp9.z = dot_3(reg_tmp14.xyz, reg_tmp0.xyz);
    reg_tmp9.z = (max(uniforms.f[93].xxxx, reg_tmp9.zzzz)).z;
    reg_tmp9.z = (min(uniforms.f[93].yyyy, reg_tmp9.zzzz)).z;
    reg_tmp9.z = log2(reg_tmp9.z);
    reg_tmp9.z = (mul_s(uniforms.f[82].zzzz, reg_tmp9.zzzz)).z;
    reg_tmp9.z = exp2(reg_tmp9.z);
    reg_tmp2.z = (mul_s(uniforms.f[82].wwww, reg_tmp9.zzzz)).z;
    return false;
}
bool sub_17() {
    reg_tmp9.x = dot_3(reg_tmp14.xyz, reg_tmp1.xyz);
    reg_tmp9.x = (max(uniforms.f[93].xxxx, reg_tmp9.xxxx)).x;
    reg_tmp9.x = (min(uniforms.f[93].yyyy, reg_tmp9.xxxx)).x;
    reg_tmp9.x = (uniforms.f[93].yyyy + -reg_tmp9.xxxx).x;
    reg_tmp9.x = log2(reg_tmp9.x);
    reg_tmp9.x = (mul_s(uniforms.f[82].xxxx, reg_tmp9.xxxx)).x;
    reg_tmp9.x = exp2(reg_tmp9.x);
    reg_tmp2.w = (mul_s(uniforms.f[82].yyyy, reg_tmp9.xxxx)).w;
    return false;
}
bool sub_0() {
    if (uniforms.b[10]) {
        sub_1();
    } else {
        sub_7();
    }
    if (uniforms.b[1]) {
        sub_13();
    } else {
        sub_18();
    }
    {
        sub_19();
    }
    {
        sub_33();
    }
    {
        sub_40();
    }
    return true;
}
bool sub_1() {
    {
        sub_2();
    }
    return false;
}
bool sub_7() {
    {
        sub_8();
    }
    return false;
}
bool sub_13() {
    {
        sub_14();
    }
    return false;
}
bool sub_18() {
    vs_out_attr3 = uniforms.f[93].yyyy;
    return false;
}
// reference: EF359D59A9CA4EEF, ECCD2E5CC6737F3E
// shader: 8B30, A09BB5E1066E8C4E
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = 2.0 * (texcolor2).rgb - 1.0;
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(normal, normalize(view))));
refl_value.g = (lut_scale_rg * LookupLightingLUTSigned(5, dot(normal, normalize(view))));
refl_value.b = (lut_scale_rb * LookupLightingLUTSigned(4, dot(normal, normalize(view))));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor1.rgb) * (vec3(1.0) - const_color[0].aaa) + (const_color[0].rgb) * (vec3(1.0) - (vec3(1.0) - const_color[0].aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = (texcolor1.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_1 = byteround(clamp((texcolor0.rgb) + (last_tex_env_out.rgb) - vec3(0.5), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (combiner_buffer.rgb) - vec3(0.5), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((secondary_fragment_color.r) * (1.0 - const_color[2].a) + (secondary_fragment_color.b) * (1.0 - (1.0 - const_color[2].a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_3 = (texcolor1.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((secondary_fragment_color.ggg) * (last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 00F48736B45D4053, A09BB5E1066E8C4E
// program: ECCD2E5CC6737F3E, 0D30074279C2FEED, A09BB5E1066E8C4E
// reference: A16162192A3F289D, ECCD2E5CC6737F3E
// program: F3965AC225A24CBC, 0D30074279C2FEED, DC12E218392F9BDB
// reference: 1793BA63D8943F2E, F3965AC225A24CBC
// shader: 8B31, 856D50001A60785F

#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define fma_s(x, y, z) (mix(x * y, vec4(0.0), isnan(x * y)) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location = 0) in vec4 vs_in_reg0;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_1();
bool sub_16();
bool sub_2();
bool sub_3();
bool sub_6();
bool sub_7();
bool sub_8();
bool sub_9();
bool sub_10();
bool sub_11();
bool sub_12();
bool sub_13();
bool sub_14();
bool sub_15();
bool sub_0();
bool sub_4();
bool sub_5();

bool exec_shader() {
    sub_0();
    return true;
}

bool sub_1() {
    address_registers.x = (ivec2(vs_in_reg0.zz)).x;
    reg_tmp10 = uniforms.f[0].xxxz;
    reg_tmp10.xy = (vs_in_reg0.xyyy).xy;
    reg_tmp11 = uniforms.f[0].xxxx;
    reg_tmp12 = uniforms.f[0].xxxx;
    reg_tmp13 = uniforms.f[0].zzzz;
    reg_tmp4 = uniforms.f[0].xxxx;
    reg_tmp5 = uniforms.f[0].xxxx;
    return false;
}
bool sub_16() {
    vs_out_attr0 = reg_tmp10;
    reg_tmp13 = mul_s(uniforms.f[82], reg_tmp13);
    vs_out_attr1 = reg_tmp13;
    reg_tmp11.y = (uniforms.f[0].zzzz + -reg_tmp11.yyyy).y;
    reg_tmp12.y = (uniforms.f[0].zzzz + -reg_tmp12.yyyy).y;
    reg_tmp14.y = (uniforms.f[81].wwww).y;
    reg_tmp14.x = (mul_s(uniforms.f[0].wwww, reg_tmp14.yyyy)).x;
    reg_tmp2.x = rcp_s(reg_tmp14.x);
    reg_tmp14.z = (reg_tmp2.xxxx).z;
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp11.xyyy).xy;
    reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    reg_tmp11.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp12.xyyy).xy;
    reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    reg_tmp12.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    vs_out_attr2 = reg_tmp11;
    vs_out_attr3 = reg_tmp12;
    return false;
}
bool sub_2() {
    reg_tmp6.xyz = (-reg_tmp0.xyzz).xyz;
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    reg_tmp7.xyz = vec3(rcp_s(uniforms.f[81].y));
    reg_tmp8.xyz = (fma_s(reg_tmp6.xyzz, reg_tmp7.xyzz, uniforms.f[0].yyyy)).xyz;
    reg_tmp7.xyz = (floor(reg_tmp8.xyzz)).xyz;
    reg_tmp6.xyz = (fma_s(reg_tmp7.xyzz, -uniforms.f[81].yyyy, reg_tmp6.xyzz)).xyz;
    reg_tmp6 = min(uniforms.f[81].xxxx, reg_tmp6);
    reg_tmp6 = max(-uniforms.f[81].xxxx, reg_tmp6);
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp6.xxxx, reg_tmp6.xxxx)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp6.xxxx)).y;
    reg_tmp4.x = (reg_tmp1.xxxx).x;
    reg_tmp5.x = (reg_tmp1.yyyy).x;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp6.yyyy, reg_tmp6.yyyy)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp6.yyyy)).y;
    reg_tmp4.y = (reg_tmp1.xxxx).y;
    reg_tmp5.y = (reg_tmp1.yyyy).y;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp6.zzzz, reg_tmp6.zzzz)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp6.zzzz)).y;
    reg_tmp4.z = (reg_tmp1.xxxx).z;
    reg_tmp5.z = (reg_tmp1.yyyy).z;
    reg_tmp2.x = (mul_s(reg_tmp4.yyyy, reg_tmp5.zzzz)).x;
    reg_tmp2.y = (mul_s(reg_tmp5.yyyy, reg_tmp5.zzzz)).y;
    reg_tmp6.x = (mul_s(reg_tmp4.yyyy, reg_tmp4.zzzz)).x;
    reg_tmp6.y = (reg_tmp5.zzzz).y;
    reg_tmp6.z = (mul_s(-reg_tmp5.yyyy, reg_tmp4.zzzz)).z;
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    reg_tmp7.x = (mul_s(-reg_tmp2.xxxx, reg_tmp4.xxxx)).x;
    reg_tmp7.x = (fma_s(reg_tmp5.yyyy, reg_tmp5.xxxx, reg_tmp7.xxxx)).x;
    reg_tmp7.y = (mul_s(reg_tmp4.zzzz, reg_tmp4.xxxx)).y;
    reg_tmp7.z = (mul_s(reg_tmp2.yyyy, reg_tmp4.xxxx)).z;
    reg_tmp7.z = (fma_s(reg_tmp4.yyyy, reg_tmp5.xxxx, reg_tmp7.zzzz)).z;
    reg_tmp7.w = (uniforms.f[0].xxxx).w;
    reg_tmp8.x = (mul_s(reg_tmp2.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp8.x = (fma_s(reg_tmp5.yyyy, reg_tmp4.xxxx, reg_tmp8.xxxx)).x;
    reg_tmp8.y = (mul_s(-reg_tmp4.zzzz, reg_tmp5.xxxx)).y;
    reg_tmp8.z = (mul_s(-reg_tmp2.yyyy, reg_tmp5.xxxx)).z;
    reg_tmp8.z = (fma_s(reg_tmp4.yyyy, reg_tmp4.xxxx, reg_tmp8.zzzz)).z;
    reg_tmp8.w = (uniforms.f[0].xxxx).w;
    reg_tmp9 = uniforms.f[0].xxxz;
    return false;
}
bool sub_3() {
    reg_tmp6.x = (uniforms.f[90].xxxx).x;
    reg_tmp6.y = (uniforms.f[91].xxxx).y;
    reg_tmp6.z = (uniforms.f[92].xxxx).z;
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    reg_tmp7.x = (uniforms.f[90].yyyy).x;
    reg_tmp7.y = (uniforms.f[91].yyyy).y;
    reg_tmp7.z = (uniforms.f[92].yyyy).z;
    reg_tmp7.w = (uniforms.f[0].xxxx).w;
    reg_tmp8.x = (uniforms.f[90].zzzz).x;
    reg_tmp8.y = (uniforms.f[91].zzzz).y;
    reg_tmp8.z = (uniforms.f[92].zzzz).z;
    reg_tmp8.w = (uniforms.f[0].xxxx).w;
    reg_tmp9.x = (uniforms.f[90].wwww).x;
    reg_tmp9.y = (uniforms.f[91].wwww).y;
    reg_tmp9.z = (uniforms.f[92].wwww).z;
    reg_tmp9.w = (uniforms.f[0].zzzz).w;
    return false;
}
bool sub_6() {
    reg_tmp2 = uniforms.f[90];
    reg_tmp3 = uniforms.f[91];
    reg_tmp4 = uniforms.f[92];
    reg_tmp5 = uniforms.f[0].xxxz;
    reg_tmp6 = mul_s(uniforms.f[86].xxxx, reg_tmp2);
    reg_tmp6 = fma_s(reg_tmp3, uniforms.f[86].yyyy, reg_tmp6);
    reg_tmp6 = fma_s(reg_tmp4, uniforms.f[86].zzzz, reg_tmp6);
    reg_tmp6 = fma_s(reg_tmp5, uniforms.f[86].wwww, reg_tmp6);
    reg_tmp7 = mul_s(uniforms.f[87].xxxx, reg_tmp2);
    reg_tmp7 = fma_s(reg_tmp3, uniforms.f[87].yyyy, reg_tmp7);
    reg_tmp7 = fma_s(reg_tmp4, uniforms.f[87].zzzz, reg_tmp7);
    reg_tmp7 = fma_s(reg_tmp5, uniforms.f[87].wwww, reg_tmp7);
    reg_tmp8 = mul_s(uniforms.f[88].xxxx, reg_tmp2);
    reg_tmp8 = fma_s(reg_tmp3, uniforms.f[88].yyyy, reg_tmp8);
    reg_tmp8 = fma_s(reg_tmp4, uniforms.f[88].zzzz, reg_tmp8);
    reg_tmp8 = fma_s(reg_tmp5, uniforms.f[88].wwww, reg_tmp8);
    reg_tmp9 = mul_s(uniforms.f[89].xxxx, reg_tmp2);
    reg_tmp9 = fma_s(reg_tmp3, uniforms.f[89].yyyy, reg_tmp9);
    reg_tmp9 = fma_s(reg_tmp4, uniforms.f[89].zzzz, reg_tmp9);
    reg_tmp9 = fma_s(reg_tmp5, uniforms.f[89].wwww, reg_tmp9);
    return false;
}
bool sub_7() {
    reg_tmp2.x = rcp_s(uniforms.f[81].y);
    reg_tmp2.xy = (mul_s(uniforms.f[2 + address_registers.x].zwww, reg_tmp2.xxxx)).xy;
    reg_tmp2.xy = (uniforms.f[0].yyyy + reg_tmp2.xyyy).xy;
    reg_tmp3.xy = (floor(reg_tmp2.xyyy)).xy;
    reg_tmp2.xy = (mul_s(uniforms.f[81].yyyy, reg_tmp3.xyyy)).xy;
    reg_tmp2.xy = (uniforms.f[2 + address_registers.x].zwww + -reg_tmp2.xyyy).xy;
    reg_tmp0.xy = (min(uniforms.f[81].xxxx, -reg_tmp2.xyyy)).xy;
    reg_tmp0.xy = (max(-uniforms.f[81].xxxx, reg_tmp0.xyyy)).xy;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp0.xxxx, reg_tmp0.xxxx)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.xxxx)).y;
    reg_tmp5.x = (uniforms.f[5 + address_registers.x].wwww).x;
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_8();
    }
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_9();
    }
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_10();
    }
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_11();
    }
    reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    reg_tmp4.z = (uniforms.f[83].xxxx).z;
    reg_tmp4.w = (-uniforms.f[83].yyyy).w;
    reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[3 + address_registers.x].xyyy)).xy;
    reg_tmp4.z = (-uniforms.f[3 + address_registers.x].zzzz).z;
    reg_tmp4.w = (-uniforms.f[3 + address_registers.x].wwww).w;
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    reg_tmp11.xy = (reg_tmp5.xyyy).xy;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp0.yyyy, reg_tmp0.yyyy)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.yyyy)).y;
    reg_tmp5.x = (uniforms.f[6 + address_registers.x].wwww).x;
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_12();
    }
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_13();
    }
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_14();
    }
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_15();
    }
    reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    reg_tmp4.z = (uniforms.f[83].zzzz).z;
    reg_tmp4.w = (-uniforms.f[83].wwww).w;
    reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[4 + address_registers.x].xyyy)).xy;
    reg_tmp4.z = (-uniforms.f[4 + address_registers.x].zzzz).z;
    reg_tmp4.w = (-uniforms.f[4 + address_registers.x].wwww).w;
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    reg_tmp12.xy = (reg_tmp5.xyyy).xy;
    return false;
}
bool sub_8() {
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_9() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_10() {
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_11() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_12() {
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_13() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_14() {
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_15() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_0() {
    {
        sub_1();
    }
    reg_tmp10.xy = (uniforms.f[84].xyyy + reg_tmp10.xyyy).xy;
    reg_tmp10.xy = (mul_s(uniforms.f[2 + address_registers.x].xyyy, reg_tmp10.xyyy)).xy;
    reg_tmp0 = uniforms.f[7 + address_registers.x];
    {
        sub_2();
    }
    reg_tmp2.x = dot_s(reg_tmp10, reg_tmp6);
    reg_tmp2.y = dot_s(reg_tmp10, reg_tmp7);
    reg_tmp2.z = dot_s(reg_tmp10, reg_tmp8);
    reg_tmp2.w = dot_s(reg_tmp10, reg_tmp9);
    reg_tmp10 = reg_tmp2;
    {
        sub_3();
    }
    reg_tmp2.x = dot_s(reg_tmp10, reg_tmp6);
    reg_tmp2.y = dot_s(reg_tmp10, reg_tmp7);
    reg_tmp2.z = dot_s(reg_tmp10, reg_tmp8);
    reg_tmp2.w = dot_s(uniforms.f[0].xxxz, reg_tmp10);
    reg_tmp3.xyz = (uniforms.f[5 + address_registers.x].xyzz).xyz;
    reg_tmp3.xyz = (uniforms.f[85].xyzz + -reg_tmp3.xyzz).xyz;
    reg_tmp4.x = dot_3(reg_tmp3.xyz, reg_tmp3.xyz);
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
    if (conditional_code.x) {
        sub_4();
    } else {
        sub_5();
    }
    reg_tmp3.xyz = (mul_s(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
    reg_tmp10.xyz = (uniforms.f[5 + address_registers.x].xyzz + reg_tmp2.xyzz).xyz;
    reg_tmp10.xyz = (fma_s(reg_tmp3.xyzz, uniforms.f[84].zzzz, reg_tmp10.xyzz)).xyz;
    {
        sub_6();
    }
    reg_tmp2 = reg_tmp10;
    reg_tmp10.x = dot_s(reg_tmp2, reg_tmp6);
    reg_tmp10.y = dot_s(reg_tmp2, reg_tmp7);
    reg_tmp10.z = dot_s(reg_tmp2, reg_tmp8);
    reg_tmp10.w = dot_s(reg_tmp2, reg_tmp9);
    reg_tmp2 = uniforms.f[1 + address_registers.x];
    reg_tmp3 = max(uniforms.f[0].xxxx, reg_tmp2);
    reg_tmp2 = min(uniforms.f[0].zzzz, reg_tmp3);
    reg_tmp13 = reg_tmp2;
    {
        sub_7();
    }
    {
        sub_16();
    }
    return true;
}
bool sub_4() {
    reg_tmp4.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_5() {
    reg_tmp4.x = rsq_s(reg_tmp4.x);
    return false;
}
// reference: 5B835BF50E5BF60D, 856D50001A60785F
// program: 856D50001A60785F, 13A54CCD8AA1DDA2, B6B08DE01E86DE2D
// program: 970AA6E82CDE4E04, 1C4CBC8096EA16CD, D6B195DAA984D13A
// program: 970AA6E82CDE4E04, 1C4CBC8096EA16CD, 77A77A3265B65D73
// program: 970AA6E82CDE4E04, 1C4CBC8096EA16CD, 695BB514E3AF063F
// program: 856D50001A60785F, 13A54CCD8AA1DDA2, B6B08DE0C83FF4C8
// shader: 8B31, 1B4F5D8F85FA1A43

#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define fma_s(x, y, z) (mix(x * y, vec4(0.0), isnan(x * y)) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location = 0) in vec4 vs_in_reg0;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_1();
bool sub_15();
bool sub_2();
bool sub_5();
bool sub_6();
bool sub_7();
bool sub_8();
bool sub_9();
bool sub_10();
bool sub_11();
bool sub_12();
bool sub_13();
bool sub_14();
bool sub_0();
bool sub_3();
bool sub_4();

bool exec_shader() {
    sub_0();
    return true;
}

bool sub_1() {
    address_registers.x = (ivec2(vs_in_reg0.zz)).x;
    reg_tmp10 = uniforms.f[0].xxxz;
    reg_tmp10.xy = (vs_in_reg0.xyyy).xy;
    reg_tmp11 = uniforms.f[0].xxxx;
    reg_tmp12 = uniforms.f[0].xxxx;
    reg_tmp13 = uniforms.f[0].zzzz;
    reg_tmp4 = uniforms.f[0].xxxx;
    reg_tmp5 = uniforms.f[0].xxxx;
    return false;
}
bool sub_15() {
    vs_out_attr0 = reg_tmp10;
    reg_tmp13 = mul_s(uniforms.f[82], reg_tmp13);
    vs_out_attr1 = reg_tmp13;
    reg_tmp11.y = (uniforms.f[0].zzzz + -reg_tmp11.yyyy).y;
    reg_tmp12.y = (uniforms.f[0].zzzz + -reg_tmp12.yyyy).y;
    reg_tmp14.y = (uniforms.f[81].wwww).y;
    reg_tmp14.x = (mul_s(uniforms.f[0].wwww, reg_tmp14.yyyy)).x;
    reg_tmp2.x = rcp_s(reg_tmp14.x);
    reg_tmp14.z = (reg_tmp2.xxxx).z;
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp11.xyyy).xy;
    reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    reg_tmp11.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp12.xyyy).xy;
    reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    reg_tmp12.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    vs_out_attr2 = reg_tmp11;
    vs_out_attr3 = reg_tmp12;
    return false;
}
bool sub_2() {
    reg_tmp6.x = (uniforms.f[90].xxxx).x;
    reg_tmp6.y = (uniforms.f[91].xxxx).y;
    reg_tmp6.z = (uniforms.f[92].xxxx).z;
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    reg_tmp7.x = (uniforms.f[90].yyyy).x;
    reg_tmp7.y = (uniforms.f[91].yyyy).y;
    reg_tmp7.z = (uniforms.f[92].yyyy).z;
    reg_tmp7.w = (uniforms.f[0].xxxx).w;
    reg_tmp8.x = (uniforms.f[90].zzzz).x;
    reg_tmp8.y = (uniforms.f[91].zzzz).y;
    reg_tmp8.z = (uniforms.f[92].zzzz).z;
    reg_tmp8.w = (uniforms.f[0].xxxx).w;
    reg_tmp9.x = (uniforms.f[90].wwww).x;
    reg_tmp9.y = (uniforms.f[91].wwww).y;
    reg_tmp9.z = (uniforms.f[92].wwww).z;
    reg_tmp9.w = (uniforms.f[0].zzzz).w;
    return false;
}
bool sub_5() {
    reg_tmp2 = uniforms.f[90];
    reg_tmp3 = uniforms.f[91];
    reg_tmp4 = uniforms.f[92];
    reg_tmp5 = uniforms.f[0].xxxz;
    reg_tmp6 = mul_s(uniforms.f[86].xxxx, reg_tmp2);
    reg_tmp6 = fma_s(reg_tmp3, uniforms.f[86].yyyy, reg_tmp6);
    reg_tmp6 = fma_s(reg_tmp4, uniforms.f[86].zzzz, reg_tmp6);
    reg_tmp6 = fma_s(reg_tmp5, uniforms.f[86].wwww, reg_tmp6);
    reg_tmp7 = mul_s(uniforms.f[87].xxxx, reg_tmp2);
    reg_tmp7 = fma_s(reg_tmp3, uniforms.f[87].yyyy, reg_tmp7);
    reg_tmp7 = fma_s(reg_tmp4, uniforms.f[87].zzzz, reg_tmp7);
    reg_tmp7 = fma_s(reg_tmp5, uniforms.f[87].wwww, reg_tmp7);
    reg_tmp8 = mul_s(uniforms.f[88].xxxx, reg_tmp2);
    reg_tmp8 = fma_s(reg_tmp3, uniforms.f[88].yyyy, reg_tmp8);
    reg_tmp8 = fma_s(reg_tmp4, uniforms.f[88].zzzz, reg_tmp8);
    reg_tmp8 = fma_s(reg_tmp5, uniforms.f[88].wwww, reg_tmp8);
    reg_tmp9 = mul_s(uniforms.f[89].xxxx, reg_tmp2);
    reg_tmp9 = fma_s(reg_tmp3, uniforms.f[89].yyyy, reg_tmp9);
    reg_tmp9 = fma_s(reg_tmp4, uniforms.f[89].zzzz, reg_tmp9);
    reg_tmp9 = fma_s(reg_tmp5, uniforms.f[89].wwww, reg_tmp9);
    return false;
}
bool sub_6() {
    reg_tmp2.x = rcp_s(uniforms.f[81].y);
    reg_tmp2.xy = (mul_s(uniforms.f[2 + address_registers.x].zwww, reg_tmp2.xxxx)).xy;
    reg_tmp2.xy = (uniforms.f[0].yyyy + reg_tmp2.xyyy).xy;
    reg_tmp3.xy = (floor(reg_tmp2.xyyy)).xy;
    reg_tmp2.xy = (mul_s(uniforms.f[81].yyyy, reg_tmp3.xyyy)).xy;
    reg_tmp2.xy = (uniforms.f[2 + address_registers.x].zwww + -reg_tmp2.xyyy).xy;
    reg_tmp0.xy = (min(uniforms.f[81].xxxx, -reg_tmp2.xyyy)).xy;
    reg_tmp0.xy = (max(-uniforms.f[81].xxxx, reg_tmp0.xyyy)).xy;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp0.xxxx, reg_tmp0.xxxx)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.xxxx)).y;
    reg_tmp5.x = (uniforms.f[5 + address_registers.x].wwww).x;
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_7();
    }
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_8();
    }
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_9();
    }
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_10();
    }
    reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    reg_tmp4.z = (uniforms.f[83].xxxx).z;
    reg_tmp4.w = (-uniforms.f[83].yyyy).w;
    reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[3 + address_registers.x].xyyy)).xy;
    reg_tmp4.z = (-uniforms.f[3 + address_registers.x].zzzz).z;
    reg_tmp4.w = (-uniforms.f[3 + address_registers.x].wwww).w;
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    reg_tmp11.xy = (reg_tmp5.xyyy).xy;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp0.yyyy, reg_tmp0.yyyy)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.yyyy)).y;
    reg_tmp5.x = (uniforms.f[6 + address_registers.x].wwww).x;
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_11();
    }
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_12();
    }
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_13();
    }
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_14();
    }
    reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    reg_tmp4.z = (uniforms.f[83].zzzz).z;
    reg_tmp4.w = (-uniforms.f[83].wwww).w;
    reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[4 + address_registers.x].xyyy)).xy;
    reg_tmp4.z = (-uniforms.f[4 + address_registers.x].zzzz).z;
    reg_tmp4.w = (-uniforms.f[4 + address_registers.x].wwww).w;
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    reg_tmp12.xy = (reg_tmp5.xyyy).xy;
    return false;
}
bool sub_7() {
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_8() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_9() {
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_10() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_11() {
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_12() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_13() {
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_14() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_0() {
    {
        sub_1();
    }
    reg_tmp10.xy = (uniforms.f[84].xyyy + reg_tmp10.xyyy).xy;
    reg_tmp10.xy = (mul_s(uniforms.f[2 + address_registers.x].xyyy, reg_tmp10.xyyy)).xy;
    {
        sub_2();
    }
    reg_tmp2.x = dot_s(reg_tmp10, reg_tmp6);
    reg_tmp2.y = dot_s(reg_tmp10, reg_tmp7);
    reg_tmp2.z = dot_s(reg_tmp10, reg_tmp8);
    reg_tmp2.w = dot_s(uniforms.f[0].xxxz, reg_tmp10);
    reg_tmp3.xyz = (uniforms.f[5 + address_registers.x].xyzz).xyz;
    reg_tmp3.xyz = (uniforms.f[85].xyzz + -reg_tmp3.xyzz).xyz;
    reg_tmp4.x = dot_3(reg_tmp3.xyz, reg_tmp3.xyz);
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
    if (conditional_code.x) {
        sub_3();
    } else {
        sub_4();
    }
    reg_tmp3.xyz = (mul_s(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
    reg_tmp10.xyz = (uniforms.f[5 + address_registers.x].xyzz + reg_tmp2.xyzz).xyz;
    reg_tmp10.xyz = (fma_s(reg_tmp3.xyzz, uniforms.f[84].zzzz, reg_tmp10.xyzz)).xyz;
    {
        sub_5();
    }
    reg_tmp2 = reg_tmp10;
    reg_tmp10.x = dot_s(reg_tmp2, reg_tmp6);
    reg_tmp10.y = dot_s(reg_tmp2, reg_tmp7);
    reg_tmp10.z = dot_s(reg_tmp2, reg_tmp8);
    reg_tmp10.w = dot_s(reg_tmp2, reg_tmp9);
    reg_tmp2 = uniforms.f[1 + address_registers.x];
    reg_tmp3 = max(uniforms.f[0].xxxx, reg_tmp2);
    reg_tmp2 = min(uniforms.f[0].zzzz, reg_tmp3);
    reg_tmp13 = reg_tmp2;
    {
        sub_6();
    }
    {
        sub_15();
    }
    return true;
}
bool sub_3() {
    reg_tmp4.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_4() {
    reg_tmp4.x = rsq_s(reg_tmp4.x);
    return false;
}
// reference: 6590628E3F775D7A, 1B4F5D8F85FA1A43
// program: 1B4F5D8F85FA1A43, 13A54CCD8AA1DDA2, B6B08DE0C83FF4C8
// program: 1B4F5D8F85FA1A43, 13A54CCD8AA1DDA2, BA3F71487BA61D01
// program: 970AA6E82CDE4E04, 1C4CBC8096EA16CD, FECCDB07121C469A
// program: 652E658966E83843, 0D30074279C2FEED, F46A424E601B7C89
// shader: 8B31, 016EF95E893FDD7C

#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define fma_s(x, y, z) (mix(x * y, vec4(0.0), isnan(x * y)) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;
out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_5();
bool sub_3();
bool sub_1();
bool sub_2();
bool sub_4();
bool sub_6();
bool sub_7();
bool sub_8();
bool sub_14();
bool sub_15();
bool sub_16();
bool sub_17();
bool sub_19();
bool sub_21();
bool sub_22();
bool sub_23();
bool sub_24();
bool sub_25();
bool sub_26();
bool sub_27();
bool sub_28();
bool sub_29();
bool sub_30();
bool sub_31();
bool sub_32();
bool sub_9();
bool sub_10();
bool sub_11();
bool sub_12();
bool sub_13();
bool sub_18();
bool sub_20();
bool sub_0();

bool exec_shader() {
    sub_0();
    return true;
}

bool sub_5() {
    uint jmp_to = 0u;
    while (true) {
        switch (jmp_to) {
        case 0u: {
            reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
            reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
            reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
            reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
            reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
            reg_tmp6.x = rsq_s(reg_tmp6.x);
            reg_tmp7.x = rsq_s(reg_tmp7.x);
            reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            reg_tmp0 = uniforms.f[93].yxxx;
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            reg_tmp4 = mul_s(uniforms.f[94].xxxx, reg_tmp4);
            conditional_code = greaterThanEqual(uniforms.f[93].xx, reg_tmp4.xx);
            reg_tmp4 = vec4(rsq_s(reg_tmp4.x));
            reg_tmp5 = mul_s(uniforms.f[94].xxxx, reg_tmp14);
            if (conditional_code.x) {
                { jmp_to = 18u; break; }
            }
            reg_tmp0.z = rcp_s(reg_tmp4.x);
            reg_tmp0.xy = (mul_s(reg_tmp5, reg_tmp4)).xy;
        }
        case 18u: {
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_3() {
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    reg_tmp4.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_1() {
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    reg_tmp13.xyz = (vs_in_reg2).xyz;
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    if (uniforms.b[0]) {
        sub_2();
    } else {
        sub_4();
    }
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    {
        sub_5();
    }
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    vs_out_attr2 = -reg_tmp15;
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    if (all(conditional_code)) {
        sub_6();
    }
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_2() {
    reg_tmp7 = uniforms.f[93].xxxx;
    reg_tmp12 = uniforms.f[93].xxxx;
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    {
        sub_3();
    }
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    {
        sub_3();
    }
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    {
        sub_3();
    }
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    {
        sub_3();
    }
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    reg_tmp10 = reg_tmp7;
    return false;
}
bool sub_4() {
    reg_tmp7 = reg_tmp15;
    reg_tmp10.x = dot_s(uniforms.f[10], reg_tmp7);
    reg_tmp10.y = dot_s(uniforms.f[11], reg_tmp7);
    reg_tmp10.z = dot_s(uniforms.f[12], reg_tmp7);
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    reg_tmp12.x = dot_3(uniforms.f[10].xyz, reg_tmp14.xyz);
    reg_tmp12.y = dot_3(uniforms.f[11].xyz, reg_tmp14.xyz);
    reg_tmp12.z = dot_3(uniforms.f[12].xyz, reg_tmp14.xyz);
    return false;
}
bool sub_6() {
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_7() {
    reg_tmp0.xy = (uniforms.f[0].xxxx).xy;
    if (uniforms.b[2]) {
        sub_8();
    } else {
        sub_14();
    }
    return false;
}
bool sub_8() {
    {
        sub_9();
    }
    reg_tmp3.x = dot_s(uniforms.f[1].xywz, reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2].xywz, reg_tmp6);
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_14() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_15();
    } else {
        sub_16();
    }
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_15() {
    reg_tmp6 = reg_tmp10;
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    reg_tmp3.z = dot_s(uniforms.f[3], reg_tmp6);
    reg_tmp0.xy = (mul_s(uniforms.f[9].xyyy, reg_tmp3.zzzz)).xy;
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_16() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_17();
    } else {
        sub_19();
    }
    return false;
}
bool sub_17() {
    {
        sub_18();
    }
    reg_tmp3.x = dot_3(uniforms.f[1].xyz, reg_tmp6.xyz);
    reg_tmp3.y = dot_3(uniforms.f[2].xyz, reg_tmp6.xyz);
    reg_tmp3.z = dot_3(uniforms.f[3].xyz, reg_tmp6.xyz);
    return false;
}
bool sub_19() {
    {
        sub_20();
    }
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    return false;
}
bool sub_21() {
    reg_tmp0.xy = (uniforms.f[0].yyyy).xy;
    if (uniforms.b[3]) {
        sub_22();
    } else {
        sub_23();
    }
    return false;
}
bool sub_22() {
    {
        sub_9();
    }
    reg_tmp4.x = dot_s(uniforms.f[4].xywz, reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5].xywz, reg_tmp6);
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_23() {
    if (uniforms.b[5]) {
        sub_24();
    } else {
        sub_27();
    }
    return false;
}
bool sub_24() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_25();
    } else {
        sub_26();
    }
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_25() {
    reg_tmp6 = reg_tmp10;
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    reg_tmp4.z = dot_s(uniforms.f[6], reg_tmp6);
    reg_tmp6.w = rcp_s(reg_tmp4.z);
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    reg_tmp4.xy = (uniforms.f[9].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_26() {
    {
        sub_20();
    }
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    return false;
}
bool sub_27() {
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_28() {
    reg_tmp0.xy = (uniforms.f[0].zzzz).xy;
    if (uniforms.b[4]) {
        sub_29();
    } else {
        sub_30();
    }
    return false;
}
bool sub_29() {
    {
        sub_9();
    }
    reg_tmp5.x = dot_s(uniforms.f[7].xywz, reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8].xywz, reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_30() {
    if (uniforms.b[6]) {
        sub_31();
    } else {
        sub_32();
    }
    return false;
}
bool sub_31() {
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    {
        sub_20();
    }
    reg_tmp5.x = dot_s(uniforms.f[7], reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8], reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_32() {
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
bool sub_9() {
    conditional_code = equal(uniforms.f[93].yz, reg_tmp0.xy);
    if (all(not(conditional_code))) {
        sub_10();
    } else {
        sub_11();
    }
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_10() {
    reg_tmp6.xy = (vs_in_reg4.xyyy).xy;
    return false;
}
bool sub_11() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_12();
    } else {
        sub_13();
    }
    return false;
}
bool sub_12() {
    reg_tmp6.xy = (vs_in_reg5.xyyy).xy;
    return false;
}
bool sub_13() {
    reg_tmp6.xy = (vs_in_reg6.xyyy).xy;
    return false;
}
bool sub_18() {
    reg_tmp2 = -reg_tmp15;
    reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
    reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_20() {
    reg_tmp1 = reg_tmp14;
    reg_tmp2.w = dot_3(reg_tmp1.xyz, reg_tmp1.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp1 = mul_s(reg_tmp1, reg_tmp2.wwww);
    reg_tmp1 = mul_s(uniforms.f[94].xxxx, reg_tmp1);
    reg_tmp6.xy = (uniforms.f[94].xxxx + reg_tmp1.xyyy).xy;
    return false;
}
bool sub_0() {
    {
        sub_1();
    }
    reg_tmp2 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
    reg_tmp1.xyz = (uniforms.f[93].xxyx).xyz;
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    reg_tmp14.w = (uniforms.f[93].xxxx).w;
    reg_tmp8 = reg_tmp14;
    reg_tmp14.x = dot_s(reg_tmp8, reg_tmp8);
    reg_tmp14.x = rsq_s(reg_tmp14.x);
    reg_tmp14 = mul_s(reg_tmp8, reg_tmp14.xxxx);
    reg_tmp9.x = dot_3(reg_tmp14.xyz, reg_tmp1.xyz);
    reg_tmp9.x = (max(uniforms.f[93].xxxx, reg_tmp9.xxxx)).x;
    reg_tmp9.x = (min(uniforms.f[93].yyyy, reg_tmp9.xxxx)).x;
    reg_tmp9.x = (uniforms.f[93].yyyy + -reg_tmp9.xxxx).x;
    reg_tmp9.x = log2(reg_tmp9.x);
    reg_tmp9.x = (mul_s(uniforms.f[82].xxxx, reg_tmp9.xxxx)).x;
    reg_tmp9.x = exp2(reg_tmp9.x);
    reg_tmp2.w = (mul_s(uniforms.f[82].yyyy, reg_tmp9.xxxx)).w;
    vs_out_attr3 = reg_tmp2;
    {
        sub_7();
    }
    {
        sub_21();
    }
    {
        sub_28();
    }
    return true;
}
// reference: 188084E65E65A4A4, 016EF95E893FDD7C
// program: 016EF95E893FDD7C, 0D30074279C2FEED, C7969C7985C3CB70
// reference: 56D47BA6DD90C2D6, 016EF95E893FDD7C
// program: 016EF95E893FDD7C, 0D30074279C2FEED, 9CE5E607337B297A
// program: 016EF95E893FDD7C, 0D30074279C2FEED, F809C797ACA3151F
// reference: 15D7A4B58DAE907F, 856D50001A60785F
// program: 856D50001A60785F, 13A54CCD8AA1DDA2, 1041172C77D1741F
// shader: 8B31, 5CE71904E1BA6D0C

#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define fma_s(x, y, z) (mix(x * y, vec4(0.0), isnan(x * y)) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location = 0) in vec4 vs_in_reg0;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;
out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_2();
bool sub_1();
bool sub_3();
bool sub_4();
bool sub_0();

bool exec_shader() {
    sub_0();
    return true;
}

bool sub_2() {
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    return false;
}
bool sub_1() {
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    reg_tmp7 = uniforms.f[93].xxxx;
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    {
        sub_2();
    }
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    {
        sub_2();
    }
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    if (conditional_code.x) {
        sub_2();
    }
    if (uniforms.b[11]) {
        sub_3();
    }
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    reg_tmp10 = reg_tmp7;
    reg_tmp6.y = (-uniforms.f[83].wwww + reg_tmp10.yyyy).y;
    reg_tmp9.xyz = (uniforms.f[83].xyzz).xyz;
    reg_tmp7.x = dot_s(reg_tmp9.xyzz, reg_tmp9.xyzz);
    reg_tmp7.x = rsq_s(reg_tmp7.x);
    reg_tmp7.xyz = (mul_s(reg_tmp9.xyzz, reg_tmp7.xxxx)).xyz;
    reg_tmp8.y = rcp_s(-reg_tmp7.y);
    reg_tmp8.y = (mul_s(reg_tmp6.yyyy, reg_tmp8.yyyy)).y;
    reg_tmp7.xyz = (mul_s(reg_tmp7.xyzz, reg_tmp8.yyyy)).xyz;
    reg_tmp10.xyz = (reg_tmp10.xyzz + reg_tmp7.xyzz).xyz;
    reg_tmp10.y = (uniforms.f[94].xxxx + reg_tmp10.yyyy).y;
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    vs_out_attr1 = uniforms.f[93].xxxx;
    vs_out_attr2 = -reg_tmp15;
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    if (all(conditional_code)) {
        sub_4();
    }
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_3() {
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    if (conditional_code.y) {
        sub_2();
    }
    return false;
}
bool sub_4() {
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_0() {
    {
        sub_1();
    }
    vs_out_attr4 = uniforms.f[93].xxxx;
    vs_out_attr5 = uniforms.f[93].xxxx;
    vs_out_attr6 = uniforms.f[93].xxxx;
    vs_out_attr3 = uniforms.f[93].xxxx;
    return true;
}
// reference: EC0EA660E8225D44, 5CE71904E1BA6D0C
// program: 5CE71904E1BA6D0C, 0D30074279C2FEED, 5C810B10151A2528
// program: ECCD2E5CC6737F3E, 0D30074279C2FEED, FE3CDC9FA9FF9FA9
// program: 856D50001A60785F, 13A54CCD8AA1DDA2, EDB11957E1308F8F
// reference: 2BC49DCEBC823B08, 1B4F5D8F85FA1A43
// reference: FAF4FA0EF35FDB34, D1ACBB21B5720FEB
// program: 970AA6E82CDE4E04, 1C4CBC8096EA16CD, FECCDB075D3282D4
// program: 970AA6E82CDE4E04, 1C4CBC8096EA16CD, 17F705211262CD00
// shader: 8B31, 720791B5FA362135

#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define fma_s(x, y, z) (mix(x * y, vec4(0.0), isnan(x * y)) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;
out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_5();
bool sub_3();
bool sub_1();
bool sub_2();
bool sub_4();
bool sub_6();
bool sub_9();
bool sub_10();
bool sub_16();
bool sub_17();
bool sub_18();
bool sub_19();
bool sub_21();
bool sub_23();
bool sub_24();
bool sub_25();
bool sub_26();
bool sub_27();
bool sub_28();
bool sub_29();
bool sub_30();
bool sub_31();
bool sub_32();
bool sub_33();
bool sub_34();
bool sub_11();
bool sub_12();
bool sub_13();
bool sub_14();
bool sub_15();
bool sub_20();
bool sub_22();
bool sub_0();
bool sub_7();
bool sub_8();

bool exec_shader() {
    sub_0();
    return true;
}

bool sub_5() {
    uint jmp_to = 0u;
    while (true) {
        switch (jmp_to) {
        case 0u: {
            reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
            reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
            reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
            reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
            reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
            reg_tmp6.x = rsq_s(reg_tmp6.x);
            reg_tmp7.x = rsq_s(reg_tmp7.x);
            reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            reg_tmp0 = uniforms.f[93].yxxx;
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            reg_tmp4 = mul_s(uniforms.f[94].xxxx, reg_tmp4);
            conditional_code = greaterThanEqual(uniforms.f[93].xx, reg_tmp4.xx);
            reg_tmp4 = vec4(rsq_s(reg_tmp4.x));
            reg_tmp5 = mul_s(uniforms.f[94].xxxx, reg_tmp14);
            if (conditional_code.x) {
                { jmp_to = 18u; break; }
            }
            reg_tmp0.z = rcp_s(reg_tmp4.x);
            reg_tmp0.xy = (mul_s(reg_tmp5, reg_tmp4)).xy;
        }
        case 18u: {
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_3() {
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    reg_tmp4.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_1() {
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    if (uniforms.b[0]) {
        sub_2();
    } else {
        sub_4();
    }
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    {
        sub_5();
    }
    vs_out_attr2 = reg_tmp15;
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    if (all(conditional_code)) {
        sub_6();
    }
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_2() {
    reg_tmp7 = uniforms.f[93].xxxx;
    reg_tmp12 = uniforms.f[93].xxxx;
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    {
        sub_3();
    }
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    {
        sub_3();
    }
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    {
        sub_3();
    }
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    {
        sub_3();
    }
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    reg_tmp10 = reg_tmp7;
    return false;
}
bool sub_4() {
    reg_tmp7 = reg_tmp15;
    reg_tmp10.x = dot_s(uniforms.f[10], reg_tmp7);
    reg_tmp10.y = dot_s(uniforms.f[11], reg_tmp7);
    reg_tmp10.z = dot_s(uniforms.f[12], reg_tmp7);
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    reg_tmp12.x = dot_3(uniforms.f[10].xyz, reg_tmp14.xyz);
    reg_tmp12.y = dot_3(uniforms.f[11].xyz, reg_tmp14.xyz);
    reg_tmp12.z = dot_3(uniforms.f[12].xyz, reg_tmp14.xyz);
    return false;
}
bool sub_6() {
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_9() {
    reg_tmp0.xy = (uniforms.f[0].xxxx).xy;
    if (uniforms.b[2]) {
        sub_10();
    } else {
        sub_16();
    }
    return false;
}
bool sub_10() {
    {
        sub_11();
    }
    reg_tmp3.x = dot_s(uniforms.f[1].xywz, reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2].xywz, reg_tmp6);
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_16() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_17();
    } else {
        sub_18();
    }
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_17() {
    reg_tmp6 = reg_tmp10;
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    reg_tmp3.z = dot_s(uniforms.f[3], reg_tmp6);
    reg_tmp0.xy = (mul_s(uniforms.f[9].xyyy, reg_tmp3.zzzz)).xy;
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_18() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_19();
    } else {
        sub_21();
    }
    return false;
}
bool sub_19() {
    {
        sub_20();
    }
    reg_tmp3.x = dot_3(uniforms.f[1].xyz, reg_tmp6.xyz);
    reg_tmp3.y = dot_3(uniforms.f[2].xyz, reg_tmp6.xyz);
    reg_tmp3.z = dot_3(uniforms.f[3].xyz, reg_tmp6.xyz);
    return false;
}
bool sub_21() {
    {
        sub_22();
    }
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    return false;
}
bool sub_23() {
    reg_tmp0.xy = (uniforms.f[0].yyyy).xy;
    if (uniforms.b[3]) {
        sub_24();
    } else {
        sub_25();
    }
    return false;
}
bool sub_24() {
    {
        sub_11();
    }
    reg_tmp4.x = dot_s(uniforms.f[4].xywz, reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5].xywz, reg_tmp6);
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_25() {
    if (uniforms.b[5]) {
        sub_26();
    } else {
        sub_29();
    }
    return false;
}
bool sub_26() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_27();
    } else {
        sub_28();
    }
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_27() {
    reg_tmp6 = reg_tmp10;
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    reg_tmp4.z = dot_s(uniforms.f[6], reg_tmp6);
    reg_tmp6.w = rcp_s(reg_tmp4.z);
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    reg_tmp4.xy = (uniforms.f[9].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_28() {
    {
        sub_22();
    }
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    return false;
}
bool sub_29() {
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_30() {
    reg_tmp0.xy = (uniforms.f[0].zzzz).xy;
    if (uniforms.b[4]) {
        sub_31();
    } else {
        sub_32();
    }
    return false;
}
bool sub_31() {
    {
        sub_11();
    }
    reg_tmp5.x = dot_s(uniforms.f[7].xywz, reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8].xywz, reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_32() {
    if (uniforms.b[6]) {
        sub_33();
    } else {
        sub_34();
    }
    return false;
}
bool sub_33() {
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    {
        sub_22();
    }
    reg_tmp5.x = dot_s(uniforms.f[7], reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8], reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_34() {
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
bool sub_11() {
    conditional_code = equal(uniforms.f[93].yz, reg_tmp0.xy);
    if (all(not(conditional_code))) {
        sub_12();
    } else {
        sub_13();
    }
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_12() {
    reg_tmp6.xy = (vs_in_reg4.xyyy).xy;
    return false;
}
bool sub_13() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_14();
    } else {
        sub_15();
    }
    return false;
}
bool sub_14() {
    reg_tmp6.xy = (vs_in_reg5.xyyy).xy;
    return false;
}
bool sub_15() {
    reg_tmp6.xy = (vs_in_reg6.xyyy).xy;
    return false;
}
bool sub_20() {
    reg_tmp2 = -reg_tmp15;
    reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
    reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_22() {
    reg_tmp1 = reg_tmp14;
    reg_tmp2.w = dot_3(reg_tmp1.xyz, reg_tmp1.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp1 = mul_s(reg_tmp1, reg_tmp2.wwww);
    reg_tmp1 = mul_s(uniforms.f[94].xxxx, reg_tmp1);
    reg_tmp6.xy = (uniforms.f[94].xxxx + reg_tmp1.xyyy).xy;
    return false;
}
bool sub_0() {
    {
        sub_1();
    }
    if (uniforms.b[1]) {
        sub_7();
    } else {
        sub_8();
    }
    vs_out_attr3 = reg_tmp2;
    {
        sub_9();
    }
    {
        sub_23();
    }
    {
        sub_30();
    }
    return true;
}
bool sub_7() {
    reg_tmp0 = vec4(dot_3(uniforms.f[83].xyz, reg_tmp12.xyz));
    reg_tmp0 = max(uniforms.f[93].xxxx, reg_tmp0);
    reg_tmp0 = mul_s(uniforms.f[84], reg_tmp0);
    reg_tmp0 = uniforms.f[85] + reg_tmp0;
    reg_tmp0.w = (uniforms.f[93].yyyy).w;
    reg_tmp1 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
    reg_tmp2 = mul_s(reg_tmp0, reg_tmp1);
    return false;
}
bool sub_8() {
    reg_tmp2 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
    return false;
}
// reference: ABAF98658BF1C543, 720791B5FA362135
// program: 720791B5FA362135, 0D30074279C2FEED, 4D5CFC1E9D9B8FEC
// shader: 8B30, EDB119573789A56A
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_2 = byteround(clamp((vec3(1.0) - combiner_buffer.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: AE3D27E908602FB1, EDB119573789A56A
// program: 1B4F5D8F85FA1A43, 13A54CCD8AA1DDA2, EDB119573789A56A
// reference: D0405248BF8559E9, EEF51AC3C5D9903C
// shader: 8B30, 2B10BB0377D1741F
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.r) + (texcolor1.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_2 = byteround(clamp((vec3(1.0) - combiner_buffer.rgb) * (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 70D611D1B26CD5C1, 2B10BB0377D1741F
// program: EEF51AC3C5D9903C, 13A54CCD8AA1DDA2, 2B10BB0377D1741F
// shader: 8B30, B037FFD877D1741F
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) + (texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.r) + (texcolor1.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_2 = byteround(clamp((vec3(1.0) - combiner_buffer.rgb) * (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: C874F9B1B26CD5C1, B037FFD877D1741F
// program: EEF51AC3C5D9903C, 13A54CCD8AA1DDA2, B037FFD877D1741F
// program: 1B4F5D8F85FA1A43, 13A54CCD8AA1DDA2, EDB11957E1308F8F
// reference: A25A59206BD73B36, 5CE71904E1BA6D0C
// shader: 8B31, 888358E3BB131C20

#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define mul_3(x, y) mix(x * y, vec3(0.0), isnan(x * y))
#define fma_s(x, y, z) (mul_s(x, y) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(mul_3(x, y), vec3(1.0))

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;
out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_13();
bool sub_6();
bool sub_11();
bool sub_4();
bool sub_9();
bool sub_10();
bool sub_12();
bool sub_14();
bool sub_2();
bool sub_3();
bool sub_5();
bool sub_7();
bool sub_17();
bool sub_18();
bool sub_24();
bool sub_25();
bool sub_26();
bool sub_27();
bool sub_29();
bool sub_31();
bool sub_32();
bool sub_33();
bool sub_34();
bool sub_35();
bool sub_36();
bool sub_37();
bool sub_38();
bool sub_39();
bool sub_40();
bool sub_41();
bool sub_42();
bool sub_19();
bool sub_20();
bool sub_21();
bool sub_22();
bool sub_23();
bool sub_28();
bool sub_30();
bool sub_0();
bool sub_1();
bool sub_8();
bool sub_15();
bool sub_16();

bool exec_shader() {
    sub_0();
    return true;
}

bool sub_13() {
    uint jmp_to = 0u;
    while (true) {
        switch (jmp_to) {
        case 0u: {
            reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
            reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
            reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
            reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
            reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
            reg_tmp6.x = rsq_s(reg_tmp6.x);
            reg_tmp7.x = rsq_s(reg_tmp7.x);
            reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            reg_tmp0 = uniforms.f[93].yxxx;
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            reg_tmp4 = mul_s(uniforms.f[94].xxxx, reg_tmp4);
            conditional_code = greaterThanEqual(uniforms.f[93].xx, reg_tmp4.xx);
            reg_tmp4 = vec4(rsq_s(reg_tmp4.x));
            reg_tmp5 = mul_s(uniforms.f[94].xxxx, reg_tmp14);
            if (conditional_code.x) {
                { jmp_to = 18u; break; }
            }
            reg_tmp0.z = rcp_s(reg_tmp4.x);
            reg_tmp0.xy = (mul_s(reg_tmp5, reg_tmp4)).xy;
        }
        case 18u: {
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_6() {
    uint jmp_to = 19u;
    while (true) {
        switch (jmp_to) {
        case 19u: {
            reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
            reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
            reg_tmp6.x = rsq_s(reg_tmp6.x);
            reg_tmp7.x = rsq_s(reg_tmp7.x);
            reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            reg_tmp13.xyz = (mul_s(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            reg_tmp11.xyz = (mul_s(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            reg_tmp0 = uniforms.f[93].yxxx;
            reg_tmp13.xyz = (mul_s(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            reg_tmp11.xyz = (mul_s(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            reg_tmp5 = mul_s(reg_tmp14.yzxx, reg_tmp13.zxyy);
            reg_tmp5 = fma_s(-reg_tmp13.yzxx, reg_tmp14.zxyy, reg_tmp5);
            reg_tmp5.w = dot_3(reg_tmp5.xyz, reg_tmp5.xyz);
            reg_tmp5.w = rsq_s(reg_tmp5.w);
            reg_tmp5 = mul_s(reg_tmp5, reg_tmp5.wwww);
            reg_tmp6.w = (reg_tmp14.zzzz + reg_tmp5.yyyy).w;
            reg_tmp13 = mul_s(reg_tmp5.yzxx, reg_tmp14.zxyy);
            reg_tmp13 = fma_s(-reg_tmp14.yzxx, reg_tmp5.zxyy, reg_tmp13);
            reg_tmp6.w = (reg_tmp13.xxxx + reg_tmp6).w;
            reg_tmp13.w = (reg_tmp5.zzzz).w;
            reg_tmp5.z = (reg_tmp13.xxxx).z;
            reg_tmp6.w = (uniforms.f[93].yyyy + reg_tmp6).w;
            reg_tmp14.w = (reg_tmp5.xxxx).w;
            reg_tmp5.x = (reg_tmp14.zzzz).x;
            conditional_code = lessThan(uniforms.f[94].zz, reg_tmp6.ww);
            reg_tmp6.x = (uniforms.f[93].yyyy).x;
            reg_tmp6.y = (-uniforms.f[93].yyyy).y;
            if (!conditional_code.x) {
                { jmp_to = 54u; break; }
            }
            reg_tmp7.xz = (reg_tmp13.wwyy + -reg_tmp14.yyww).xz;
            reg_tmp7.y = (reg_tmp14.xxxx + -reg_tmp13.zzzz).y;
            reg_tmp7.w = (reg_tmp6).w;
            reg_tmp6 = vec4(dot_s(reg_tmp7, reg_tmp7));
            reg_tmp6 = vec4(rsq_s(reg_tmp6.x));
            reg_tmp0 = mul_s(reg_tmp7, reg_tmp6);
        }
        case 54u: {
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_11() {
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    reg_tmp4.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_4() {
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    reg_tmp4.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp5.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp13.xyz);
    reg_tmp5.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp13.xyz);
    reg_tmp5.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp13.xyz);
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    reg_tmp11 = fma_s(reg_tmp1.wwww, reg_tmp5, reg_tmp11);
    return false;
}
bool sub_9() {
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    reg_tmp13.xyz = (vs_in_reg2).xyz;
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    if (uniforms.b[0]) {
        sub_10();
    } else {
        sub_12();
    }
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    {
        sub_13();
    }
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    vs_out_attr2 = -reg_tmp15;
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    if (all(conditional_code)) {
        sub_14();
    }
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_10() {
    reg_tmp7 = uniforms.f[93].xxxx;
    reg_tmp12 = uniforms.f[93].xxxx;
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    {
        sub_11();
    }
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    {
        sub_11();
    }
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    {
        sub_11();
    }
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    {
        sub_11();
    }
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    reg_tmp10 = reg_tmp7;
    return false;
}
bool sub_12() {
    reg_tmp7 = reg_tmp15;
    reg_tmp10.x = dot_s(uniforms.f[10], reg_tmp7);
    reg_tmp10.y = dot_s(uniforms.f[11], reg_tmp7);
    reg_tmp10.z = dot_s(uniforms.f[12], reg_tmp7);
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    reg_tmp12.x = dot_3(uniforms.f[10].xyz, reg_tmp14.xyz);
    reg_tmp12.y = dot_3(uniforms.f[11].xyz, reg_tmp14.xyz);
    reg_tmp12.z = dot_3(uniforms.f[12].xyz, reg_tmp14.xyz);
    return false;
}
bool sub_14() {
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_2() {
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    reg_tmp13.xyz = (vs_in_reg2).xyz;
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    if (uniforms.b[0]) {
        sub_3();
    } else {
        sub_5();
    }
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    reg_tmp13.x = dot_3(uniforms.f[90].xyz, reg_tmp11.xyz);
    reg_tmp13.y = dot_3(uniforms.f[91].xyz, reg_tmp11.xyz);
    reg_tmp13.z = dot_3(uniforms.f[92].xyz, reg_tmp11.xyz);
    {
        sub_6();
    }
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    vs_out_attr2 = -reg_tmp15;
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    if (all(conditional_code)) {
        sub_7();
    }
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_3() {
    reg_tmp7 = uniforms.f[93].xxxx;
    reg_tmp12 = uniforms.f[93].xxxx;
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    {
        sub_4();
    }
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    {
        sub_4();
    }
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    {
        sub_4();
    }
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    {
        sub_4();
    }
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    reg_tmp10 = reg_tmp7;
    return false;
}
bool sub_5() {
    reg_tmp7 = reg_tmp15;
    reg_tmp10.x = dot_s(uniforms.f[10], reg_tmp7);
    reg_tmp10.y = dot_s(uniforms.f[11], reg_tmp7);
    reg_tmp10.z = dot_s(uniforms.f[12], reg_tmp7);
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    reg_tmp12.x = dot_3(uniforms.f[10].xyz, reg_tmp14.xyz);
    reg_tmp12.y = dot_3(uniforms.f[11].xyz, reg_tmp14.xyz);
    reg_tmp12.z = dot_3(uniforms.f[12].xyz, reg_tmp14.xyz);
    reg_tmp11.x = dot_3(uniforms.f[10].xyz, reg_tmp13.xyz);
    reg_tmp11.y = dot_3(uniforms.f[11].xyz, reg_tmp13.xyz);
    reg_tmp11.z = dot_3(uniforms.f[12].xyz, reg_tmp13.xyz);
    return false;
}
bool sub_7() {
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_17() {
    reg_tmp0.xy = (uniforms.f[0].xxxx).xy;
    if (uniforms.b[2]) {
        sub_18();
    } else {
        sub_24();
    }
    return false;
}
bool sub_18() {
    {
        sub_19();
    }
    reg_tmp3.x = dot_s(uniforms.f[1].xywz, reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2].xywz, reg_tmp6);
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_24() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_25();
    } else {
        sub_26();
    }
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_25() {
    reg_tmp6 = reg_tmp10;
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    reg_tmp3.z = dot_s(uniforms.f[3], reg_tmp6);
    reg_tmp0.xy = (mul_s(uniforms.f[9].xyyy, reg_tmp3.zzzz)).xy;
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_26() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_27();
    } else {
        sub_29();
    }
    return false;
}
bool sub_27() {
    {
        sub_28();
    }
    reg_tmp3.x = dot_3(uniforms.f[1].xyz, reg_tmp6.xyz);
    reg_tmp3.y = dot_3(uniforms.f[2].xyz, reg_tmp6.xyz);
    reg_tmp3.z = dot_3(uniforms.f[3].xyz, reg_tmp6.xyz);
    return false;
}
bool sub_29() {
    {
        sub_30();
    }
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    return false;
}
bool sub_31() {
    reg_tmp0.xy = (uniforms.f[0].yyyy).xy;
    if (uniforms.b[3]) {
        sub_32();
    } else {
        sub_33();
    }
    return false;
}
bool sub_32() {
    {
        sub_19();
    }
    reg_tmp4.x = dot_s(uniforms.f[4].xywz, reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5].xywz, reg_tmp6);
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_33() {
    if (uniforms.b[5]) {
        sub_34();
    } else {
        sub_37();
    }
    return false;
}
bool sub_34() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_35();
    } else {
        sub_36();
    }
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_35() {
    reg_tmp6 = reg_tmp10;
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    reg_tmp4.z = dot_s(uniforms.f[6], reg_tmp6);
    reg_tmp6.w = rcp_s(reg_tmp4.z);
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    reg_tmp4.xy = (uniforms.f[9].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_36() {
    {
        sub_30();
    }
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    return false;
}
bool sub_37() {
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_38() {
    reg_tmp0.xy = (uniforms.f[0].zzzz).xy;
    if (uniforms.b[4]) {
        sub_39();
    } else {
        sub_40();
    }
    return false;
}
bool sub_39() {
    {
        sub_19();
    }
    reg_tmp5.x = dot_s(uniforms.f[7].xywz, reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8].xywz, reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_40() {
    if (uniforms.b[6]) {
        sub_41();
    } else {
        sub_42();
    }
    return false;
}
bool sub_41() {
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    {
        sub_30();
    }
    reg_tmp5.x = dot_s(uniforms.f[7], reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8], reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_42() {
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
bool sub_19() {
    conditional_code = equal(uniforms.f[93].yz, reg_tmp0.xy);
    if (all(not(conditional_code))) {
        sub_20();
    } else {
        sub_21();
    }
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_20() {
    reg_tmp6.xy = (vs_in_reg4.xyyy).xy;
    return false;
}
bool sub_21() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_22();
    } else {
        sub_23();
    }
    return false;
}
bool sub_22() {
    reg_tmp6.xy = (vs_in_reg5.xyyy).xy;
    return false;
}
bool sub_23() {
    reg_tmp6.xy = (vs_in_reg6.xyyy).xy;
    return false;
}
bool sub_28() {
    reg_tmp2 = -reg_tmp15;
    reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
    reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_30() {
    reg_tmp1 = reg_tmp14;
    reg_tmp2.w = dot_3(reg_tmp1.xyz, reg_tmp1.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp1 = mul_s(reg_tmp1, reg_tmp2.wwww);
    reg_tmp1 = mul_s(uniforms.f[94].xxxx, reg_tmp1);
    reg_tmp6.xy = (uniforms.f[94].xxxx + reg_tmp1.xyyy).xy;
    return false;
}
bool sub_0() {
    if (uniforms.b[10]) {
        sub_1();
    } else {
        sub_8();
    }
    if (uniforms.b[1]) {
        sub_15();
    } else {
        sub_16();
    }
    vs_out_attr3 = reg_tmp2;
    {
        sub_17();
    }
    {
        sub_31();
    }
    {
        sub_38();
    }
    return true;
}
bool sub_1() {
    {
        sub_2();
    }
    return false;
}
bool sub_8() {
    {
        sub_9();
    }
    return false;
}
bool sub_15() {
    reg_tmp0 = vec4(dot_3(uniforms.f[83].xyz, reg_tmp12.xyz));
    reg_tmp0 = max(uniforms.f[93].xxxx, reg_tmp0);
    reg_tmp0 = mul_s(uniforms.f[84], reg_tmp0);
    reg_tmp0 = uniforms.f[85] + reg_tmp0;
    reg_tmp0.w = (uniforms.f[93].yyyy).w;
    reg_tmp1 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
    reg_tmp2 = mul_s(reg_tmp0, reg_tmp1);
    return false;
}
bool sub_16() {
    reg_tmp2 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
    return false;
}
// reference: 59C7452370092620, 888358E3BB131C20
// program: 888358E3BB131C20, 0D30074279C2FEED, 6393144EC6B7C460
// reference: 1793BA63F3FC4052, 888358E3BB131C20
// program: 888358E3BB131C20, 0D30074279C2FEED, 71260FB838A09A82
// program: 888358E3BB131C20, 0D30074279C2FEED, 184C7DC1D30B7FEA
// program: 888358E3BB131C20, 0D30074279C2FEED, 8EEA50D59BE2263A
// program: 888358E3BB131C20, 0D30074279C2FEED, C59FB987FA81F0B3
// program: 888358E3BB131C20, 0D30074279C2FEED, 0DA2D889D2CD465D
// program: 888358E3BB131C20, 0D30074279C2FEED, 107C23D73DF4B2BF
// program: 888358E3BB131C20, 0D30074279C2FEED, 7BE2A077F32A3F69
// program: 888358E3BB131C20, 0D30074279C2FEED, AF4EE6C536ED3E7A
// program: 888358E3BB131C20, 0D30074279C2FEED, BF769EFD399154AD
// program: 888358E3BB131C20, 0D30074279C2FEED, 7CB7D5CAEB400D5B
// program: 888358E3BB131C20, 0D30074279C2FEED, E34D1DA909F9ABA3
// shader: 8B31, 205F10DC908B0FAB

#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define mul_3(x, y) mix(x * y, vec3(0.0), isnan(x * y))
#define fma_s(x, y, z) (mul_s(x, y) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(mul_3(x, y), vec3(1.0))

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;
out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_5();
bool sub_3();
bool sub_1();
bool sub_2();
bool sub_4();
bool sub_6();
bool sub_9();
bool sub_10();
bool sub_16();
bool sub_17();
bool sub_18();
bool sub_19();
bool sub_21();
bool sub_23();
bool sub_24();
bool sub_25();
bool sub_26();
bool sub_27();
bool sub_28();
bool sub_29();
bool sub_30();
bool sub_31();
bool sub_32();
bool sub_33();
bool sub_34();
bool sub_11();
bool sub_12();
bool sub_13();
bool sub_14();
bool sub_15();
bool sub_20();
bool sub_22();
bool sub_0();
bool sub_7();
bool sub_8();

bool exec_shader() {
    sub_0();
    return true;
}

bool sub_5() {
    uint jmp_to = 0u;
    while (true) {
        switch (jmp_to) {
        case 0u: {
            reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
            reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
            reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
            reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
            reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
            reg_tmp6.x = rsq_s(reg_tmp6.x);
            reg_tmp7.x = rsq_s(reg_tmp7.x);
            reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            reg_tmp0 = uniforms.f[93].yxxx;
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            reg_tmp4 = mul_s(uniforms.f[94].xxxx, reg_tmp4);
            conditional_code = greaterThanEqual(uniforms.f[93].xx, reg_tmp4.xx);
            reg_tmp4 = vec4(rsq_s(reg_tmp4.x));
            reg_tmp5 = mul_s(uniforms.f[94].xxxx, reg_tmp14);
            if (conditional_code.x) {
                { jmp_to = 18u; break; }
            }
            reg_tmp0.z = rcp_s(reg_tmp4.x);
            reg_tmp0.xy = (mul_s(reg_tmp5, reg_tmp4)).xy;
        }
        case 18u: {
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_3() {
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    reg_tmp4.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_1() {
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    if (uniforms.b[0]) {
        sub_2();
    } else {
        sub_4();
    }
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    {
        sub_5();
    }
    vs_out_attr2 = -reg_tmp15;
    reg_tmp0.x = (uniforms.f[93].yyyy).x;
    address_registers.x = (ivec2(vs_in_reg3.xx)).x;
    reg_tmp0.x = (mul_s(uniforms.f[13 + address_registers.x].xxxx, reg_tmp0.xxxx)).x;
    address_registers.x = (ivec2(vs_in_reg3.yy)).x;
    reg_tmp0.x = (mul_s(uniforms.f[13 + address_registers.x].yyyy, reg_tmp0.xxxx)).x;
    address_registers.x = (ivec2(vs_in_reg3.zz)).x;
    reg_tmp0.x = (mul_s(uniforms.f[13 + address_registers.x].zzzz, reg_tmp0.xxxx)).x;
    address_registers.x = (ivec2(vs_in_reg3.ww)).x;
    reg_tmp0.x = (mul_s(uniforms.f[13 + address_registers.x].wwww, reg_tmp0.xxxx)).x;
    reg_tmp15.xyz = (mul_s(reg_tmp15.xyzz, reg_tmp0.xxxx)).xyz;
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    if (all(conditional_code)) {
        sub_6();
    }
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_2() {
    reg_tmp7 = uniforms.f[93].xxxx;
    reg_tmp12 = uniforms.f[93].xxxx;
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    {
        sub_3();
    }
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    {
        sub_3();
    }
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    {
        sub_3();
    }
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    {
        sub_3();
    }
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    reg_tmp10 = reg_tmp7;
    return false;
}
bool sub_4() {
    reg_tmp7 = reg_tmp15;
    reg_tmp10.x = dot_s(uniforms.f[10], reg_tmp7);
    reg_tmp10.y = dot_s(uniforms.f[11], reg_tmp7);
    reg_tmp10.z = dot_s(uniforms.f[12], reg_tmp7);
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    reg_tmp12.x = dot_3(uniforms.f[10].xyz, reg_tmp14.xyz);
    reg_tmp12.y = dot_3(uniforms.f[11].xyz, reg_tmp14.xyz);
    reg_tmp12.z = dot_3(uniforms.f[12].xyz, reg_tmp14.xyz);
    return false;
}
bool sub_6() {
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_9() {
    reg_tmp0.xy = (uniforms.f[0].xxxx).xy;
    if (uniforms.b[2]) {
        sub_10();
    } else {
        sub_16();
    }
    return false;
}
bool sub_10() {
    {
        sub_11();
    }
    reg_tmp3.x = dot_s(uniforms.f[1].xywz, reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2].xywz, reg_tmp6);
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_16() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_17();
    } else {
        sub_18();
    }
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_17() {
    reg_tmp6 = reg_tmp10;
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    reg_tmp3.z = dot_s(uniforms.f[3], reg_tmp6);
    reg_tmp0.xy = (mul_s(uniforms.f[9].xyyy, reg_tmp3.zzzz)).xy;
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_18() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_19();
    } else {
        sub_21();
    }
    return false;
}
bool sub_19() {
    {
        sub_20();
    }
    reg_tmp3.x = dot_3(uniforms.f[1].xyz, reg_tmp6.xyz);
    reg_tmp3.y = dot_3(uniforms.f[2].xyz, reg_tmp6.xyz);
    reg_tmp3.z = dot_3(uniforms.f[3].xyz, reg_tmp6.xyz);
    return false;
}
bool sub_21() {
    {
        sub_22();
    }
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    return false;
}
bool sub_23() {
    reg_tmp0.xy = (uniforms.f[0].yyyy).xy;
    if (uniforms.b[3]) {
        sub_24();
    } else {
        sub_25();
    }
    return false;
}
bool sub_24() {
    {
        sub_11();
    }
    reg_tmp4.x = dot_s(uniforms.f[4].xywz, reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5].xywz, reg_tmp6);
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_25() {
    if (uniforms.b[5]) {
        sub_26();
    } else {
        sub_29();
    }
    return false;
}
bool sub_26() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_27();
    } else {
        sub_28();
    }
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_27() {
    reg_tmp6 = reg_tmp10;
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    reg_tmp4.z = dot_s(uniforms.f[6], reg_tmp6);
    reg_tmp6.w = rcp_s(reg_tmp4.z);
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    reg_tmp4.xy = (uniforms.f[9].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_28() {
    {
        sub_22();
    }
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    return false;
}
bool sub_29() {
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_30() {
    reg_tmp0.xy = (uniforms.f[0].zzzz).xy;
    if (uniforms.b[4]) {
        sub_31();
    } else {
        sub_32();
    }
    return false;
}
bool sub_31() {
    {
        sub_11();
    }
    reg_tmp5.x = dot_s(uniforms.f[7].xywz, reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8].xywz, reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_32() {
    if (uniforms.b[6]) {
        sub_33();
    } else {
        sub_34();
    }
    return false;
}
bool sub_33() {
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    {
        sub_22();
    }
    reg_tmp5.x = dot_s(uniforms.f[7], reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8], reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_34() {
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
bool sub_11() {
    conditional_code = equal(uniforms.f[93].yz, reg_tmp0.xy);
    if (all(not(conditional_code))) {
        sub_12();
    } else {
        sub_13();
    }
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_12() {
    reg_tmp6.xy = (vs_in_reg4.xyyy).xy;
    return false;
}
bool sub_13() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_14();
    } else {
        sub_15();
    }
    return false;
}
bool sub_14() {
    reg_tmp6.xy = (vs_in_reg5.xyyy).xy;
    return false;
}
bool sub_15() {
    reg_tmp6.xy = (vs_in_reg6.xyyy).xy;
    return false;
}
bool sub_20() {
    reg_tmp2 = -reg_tmp15;
    reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
    reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_22() {
    reg_tmp1 = reg_tmp14;
    reg_tmp2.w = dot_3(reg_tmp1.xyz, reg_tmp1.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp1 = mul_s(reg_tmp1, reg_tmp2.wwww);
    reg_tmp1 = mul_s(uniforms.f[94].xxxx, reg_tmp1);
    reg_tmp6.xy = (uniforms.f[94].xxxx + reg_tmp1.xyyy).xy;
    return false;
}
bool sub_0() {
    {
        sub_1();
    }
    if (uniforms.b[1]) {
        sub_7();
    } else {
        sub_8();
    }
    vs_out_attr3 = reg_tmp2;
    {
        sub_9();
    }
    {
        sub_23();
    }
    {
        sub_30();
    }
    return true;
}
bool sub_7() {
    reg_tmp0 = vec4(dot_3(uniforms.f[83].xyz, reg_tmp12.xyz));
    reg_tmp0 = max(uniforms.f[93].xxxx, reg_tmp0);
    reg_tmp0 = mul_s(uniforms.f[84], reg_tmp0);
    reg_tmp0 = uniforms.f[85] + reg_tmp0;
    reg_tmp0.w = (uniforms.f[93].yyyy).w;
    reg_tmp1 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
    reg_tmp2 = mul_s(reg_tmp0, reg_tmp1);
    return false;
}
bool sub_8() {
    reg_tmp2 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
    return false;
}
// reference: EEA9CDB05B4B272F, 205F10DC908B0FAB
// program: 205F10DC908B0FAB, 0D30074279C2FEED, B2EFC65400C167E0
// program: 888358E3BB131C20, 0D30074279C2FEED, BBD49FD48F367AAB
// program: 888358E3BB131C20, 0D30074279C2FEED, 98D162841361BB8B
// program: 888358E3BB131C20, 0D30074279C2FEED, 48DDD5B538722E22
// program: 888358E3BB131C20, 0D30074279C2FEED, 80EECFD6EBD016F2
// program: 888358E3BB131C20, 0D30074279C2FEED, F96BC818C62F763A
// program: 888358E3BB131C20, 0D30074279C2FEED, 4C53D7BC7E6EE80B
// program: 888358E3BB131C20, 0D30074279C2FEED, 3657CCE31A12BD76
// program: 888358E3BB131C20, 0D30074279C2FEED, 34C8F36A1F3B6C76
// program: 888358E3BB131C20, 0D30074279C2FEED, 3D9AAC4EFAF520AB
// program: 888358E3BB131C20, 0D30074279C2FEED, 55A2B9A481178DDA
// program: 888358E3BB131C20, 0D30074279C2FEED, A944AF56B0C0C95D
// program: 888358E3BB131C20, 0D30074279C2FEED, 2F521F13578D049A
// program: 888358E3BB131C20, 0D30074279C2FEED, 39B31CC5B0301580
// program: 888358E3BB131C20, 0D30074279C2FEED, 9820C4E77BA40ED2
// program: 888358E3BB131C20, 0D30074279C2FEED, F3A037C6B74B6FEF
// shader: 8B31, FE7DE1650A5ACC34

#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define mul_3(x, y) mix(x * y, vec3(0.0), isnan(x * y))
#define fma_s(x, y, z) (mul_s(x, y) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(mul_3(x, y), vec3(1.0))

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location = 0) in vec4 vs_in_reg0;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;
out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_1();
bool sub_2();
bool sub_8();
bool sub_9();
bool sub_10();
bool sub_11();
bool sub_13();
bool sub_15();
bool sub_16();
bool sub_17();
bool sub_18();
bool sub_19();
bool sub_20();
bool sub_21();
bool sub_22();
bool sub_23();
bool sub_24();
bool sub_25();
bool sub_26();
bool sub_3();
bool sub_4();
bool sub_5();
bool sub_6();
bool sub_7();
bool sub_12();
bool sub_14();
bool sub_0();

bool exec_shader() {
    sub_0();
    return true;
}

bool sub_1() {
    reg_tmp0.xy = (uniforms.f[0].xxxx).xy;
    if (uniforms.b[2]) {
        sub_2();
    } else {
        sub_8();
    }
    return false;
}
bool sub_2() {
    {
        sub_3();
    }
    reg_tmp3.x = dot_s(uniforms.f[1].xywz, reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2].xywz, reg_tmp6);
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_8() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_9();
    } else {
        sub_10();
    }
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_9() {
    reg_tmp6 = reg_tmp10;
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    reg_tmp3.z = dot_s(uniforms.f[3], reg_tmp6);
    reg_tmp0.xy = (mul_s(uniforms.f[9].xyyy, reg_tmp3.zzzz)).xy;
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_10() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_11();
    } else {
        sub_13();
    }
    return false;
}
bool sub_11() {
    {
        sub_12();
    }
    reg_tmp3.x = dot_3(uniforms.f[1].xyz, reg_tmp6.xyz);
    reg_tmp3.y = dot_3(uniforms.f[2].xyz, reg_tmp6.xyz);
    reg_tmp3.z = dot_3(uniforms.f[3].xyz, reg_tmp6.xyz);
    return false;
}
bool sub_13() {
    {
        sub_14();
    }
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    return false;
}
bool sub_15() {
    reg_tmp0.xy = (uniforms.f[0].yyyy).xy;
    if (uniforms.b[3]) {
        sub_16();
    } else {
        sub_17();
    }
    return false;
}
bool sub_16() {
    {
        sub_3();
    }
    reg_tmp4.x = dot_s(uniforms.f[4].xywz, reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5].xywz, reg_tmp6);
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_17() {
    if (uniforms.b[5]) {
        sub_18();
    } else {
        sub_21();
    }
    return false;
}
bool sub_18() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_19();
    } else {
        sub_20();
    }
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_19() {
    reg_tmp6 = reg_tmp10;
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    reg_tmp4.z = dot_s(uniforms.f[6], reg_tmp6);
    reg_tmp6.w = rcp_s(reg_tmp4.z);
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    reg_tmp4.xy = (uniforms.f[9].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_20() {
    {
        sub_14();
    }
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    return false;
}
bool sub_21() {
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_22() {
    reg_tmp0.xy = (uniforms.f[0].zzzz).xy;
    if (uniforms.b[4]) {
        sub_23();
    } else {
        sub_24();
    }
    return false;
}
bool sub_23() {
    {
        sub_3();
    }
    reg_tmp5.x = dot_s(uniforms.f[7].xywz, reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8].xywz, reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_24() {
    if (uniforms.b[6]) {
        sub_25();
    } else {
        sub_26();
    }
    return false;
}
bool sub_25() {
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    {
        sub_14();
    }
    reg_tmp5.x = dot_s(uniforms.f[7], reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8], reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_26() {
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
bool sub_3() {
    conditional_code = equal(uniforms.f[93].yz, reg_tmp0.xy);
    if (all(not(conditional_code))) {
        sub_4();
    } else {
        sub_5();
    }
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_4() {
    reg_tmp6.xy = (vs_in_reg4.xyyy).xy;
    return false;
}
bool sub_5() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_6();
    } else {
        sub_7();
    }
    return false;
}
bool sub_6() {
    reg_tmp6.xy = (vs_in_reg5.xyyy).xy;
    return false;
}
bool sub_7() {
    reg_tmp6.xy = (vs_in_reg6.xyyy).xy;
    return false;
}
bool sub_12() {
    reg_tmp2 = -reg_tmp15;
    reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
    reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_14() {
    {
        sub_12();
    }
    reg_tmp1 = reg_tmp6;
    reg_tmp1.z = (uniforms.f[93].yyyy + reg_tmp1.zzzz).z;
    reg_tmp1 = vec4(dot_3(reg_tmp1.xyz, reg_tmp1.xyz));
    reg_tmp2 = vec4(rsq_s(reg_tmp1.x));
    reg_tmp2 = mul_s(uniforms.f[94].xxxx, reg_tmp2);
    reg_tmp6.xy = (mul_s(reg_tmp6.xyyy, reg_tmp2)).xy;
    reg_tmp6.xy = (uniforms.f[94].xxxx + reg_tmp6.xyyy).xy;
    return false;
}
bool sub_0() {
    reg_tmp0 = vs_in_reg0;
    reg_tmp0.z = (uniforms.f[93].xxxx).z;
    reg_tmp0.w = (uniforms.f[93].yyyy).w;
    vs_out_attr0 = reg_tmp0;
    vs_out_attr2 = reg_tmp0;
    vs_out_attr1 = reg_tmp0;
    vs_out_attr3 = uniforms.f[93].yyyy;
    {
        sub_1();
    }
    {
        sub_15();
    }
    {
        sub_22();
    }
    return true;
}
// reference: 9D22F5C44849C161, FE7DE1650A5ACC34
// program: FE7DE1650A5ACC34, 0D30074279C2FEED, DBA6479C0297E10E
// program: FE7DE1650A5ACC34, 0D30074279C2FEED, DBB563E4FA66C8E0
// reference: D3760A84CBBCA713, FE7DE1650A5ACC34
// shader: 8B31, AC6AA2648888417C

#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define mul_3(x, y) mix(x * y, vec3(0.0), isnan(x * y))
#define fma_s(x, y, z) (mul_s(x, y) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(mul_3(x, y), vec3(1.0))

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location = 0) in vec4 vs_in_reg0;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_5();
bool sub_6();
bool sub_7();
bool sub_8();
bool sub_9();
bool sub_10();
bool sub_11();
bool sub_12();
bool sub_13();
bool sub_14();
bool sub_15();
bool sub_16();
bool sub_17();
bool sub_18();
bool sub_19();
bool sub_20();
bool sub_21();
bool sub_22();
bool sub_23();
bool sub_24();
bool sub_25();
bool sub_26();
bool sub_27();
bool sub_28();
bool sub_29();
bool sub_30();
bool sub_31();
bool sub_32();
bool sub_1();
bool sub_0();
bool sub_2();
bool sub_3();
bool sub_4();
bool sub_33();
bool sub_34();
bool sub_35();
bool sub_36();
bool sub_37();
bool sub_38();
bool sub_39();
bool sub_40();
bool sub_41();

bool exec_shader() {
    sub_0();
    return true;
}

bool sub_5() {
    reg_tmp13 = floor(reg_tmp0.xxxx);
    reg_tmp13 = reg_tmp0.xxxx + -reg_tmp13;
    address_registers.y = (ivec2(reg_tmp11.zz)).y;
    conditional_code = lessThanEqual(uniforms.f[5].ww, reg_tmp13.xx);
    if (conditional_code.x) {
        sub_6();
    }
    conditional_code = lessThanEqual(uniforms.f[5].yy, reg_tmp11.xy);
    if (!conditional_code.y) {
        sub_15();
    } else {
        sub_22();
    }
    return false;
}
bool sub_6() {
    reg_tmp12.xy = (uniforms.f[5].xyyy + vs_in_reg0.zwww).xy;
    reg_tmp14.xy = (uniforms.f[6].wzzz).xy;
    reg_tmp13.xy = (mul_s(uniforms.f[5].zzzz, reg_tmp0.xxxx)).xy;
    reg_tmp13.y = (floor(reg_tmp13)).y;
    reg_tmp13.x = (reg_tmp13.xxxx + -reg_tmp13.yyyy).x;
    conditional_code = lessThanEqual(uniforms.f[5].ww, reg_tmp13.xx);
    if (conditional_code.x) {
        sub_7();
    }
    reg_tmp14.xy = (mul_s(reg_tmp14, reg_tmp2)).xy;
    reg_tmp13.x = (mul_s(uniforms.f[5].zzzz, reg_tmp13.xxxx)).x;
    reg_tmp13 = mul_s(uniforms.f[5].zyzy, reg_tmp13.xxxx);
    reg_tmp13.zw = (floor(reg_tmp13)).zw;
    reg_tmp13.xy = (reg_tmp13.xyyy + -reg_tmp13.zwww).xy;
    conditional_code = lessThanEqual(uniforms.f[5].ww, reg_tmp13.xy);
    if (conditional_code.y) {
        sub_8();
    }
    if (conditional_code.x) {
        sub_9();
    }
    reg_tmp14.xy = (uniforms.f[5].yyyy + -reg_tmp14.xyyy).xy;
    reg_tmp13.x = (mul_s(uniforms.f[5].zzzz, reg_tmp13.xxxx)).x;
    reg_tmp13 = mul_s(uniforms.f[5].zyzy, reg_tmp13.xxxx);
    reg_tmp13.zw = (floor(reg_tmp13)).zw;
    reg_tmp13.xy = (reg_tmp13.xyyy + -reg_tmp13.zwww).xy;
    conditional_code = lessThanEqual(uniforms.f[5].ww, reg_tmp13.xy);
    if (conditional_code.y) {
        sub_10();
    }
    if (conditional_code.x) {
        sub_11();
    }
    reg_tmp13.x = (mul_s(uniforms.f[5].zzzz, reg_tmp13.xxxx)).x;
    reg_tmp13 = mul_s(uniforms.f[5].zyzy, reg_tmp13.xxxx);
    reg_tmp13.zw = (floor(reg_tmp13)).zw;
    reg_tmp13.xy = (reg_tmp13.xyyy + -reg_tmp13.zwww).xy;
    conditional_code = lessThanEqual(uniforms.f[5].ww, reg_tmp13.xy);
    if (conditional_code.y) {
        sub_12();
    }
    if (conditional_code.x) {
        sub_13();
    }
    reg_tmp13.xy = (mul_s(uniforms.f[5].zzzz, reg_tmp0.xxxx)).xy;
    reg_tmp13.y = (floor(reg_tmp13)).y;
    reg_tmp13.x = (reg_tmp13.xxxx + -reg_tmp13.yyyy).x;
    conditional_code = lessThanEqual(uniforms.f[5].ww, reg_tmp13.xx);
    if (conditional_code.x) {
        sub_14();
    }
    reg_tmp12.y = (uniforms.f[5].yyyy + -reg_tmp12.yyyy).y;
    return false;
}
bool sub_7() {
    reg_tmp14.xy = (reg_tmp14.yxxx).xy;
    return false;
}
bool sub_8() {
    reg_tmp12.x = (mul_s(reg_tmp12.xxxx, reg_tmp14.xxxx)).x;
    return false;
}
bool sub_9() {
    reg_tmp12.y = (fma_s(reg_tmp12.yyyy, reg_tmp14.yyyy, uniforms.f[5].yyyy)).y;
    reg_tmp12.y = (reg_tmp12.yyyy + -reg_tmp14.yyyy).y;
    return false;
}
bool sub_10() {
    reg_tmp12.x = (reg_tmp12.xxxx + reg_tmp14.xxxx).x;
    return false;
}
bool sub_11() {
    reg_tmp12.y = (reg_tmp12.yyyy + -reg_tmp14.yyyy).y;
    return false;
}
bool sub_12() {
    reg_tmp12.x = (uniforms.f[5].yyyy + -reg_tmp12.xxxx).x;
    return false;
}
bool sub_13() {
    reg_tmp12.y = (uniforms.f[5].yyyy + -reg_tmp12.yyyy).y;
    return false;
}
bool sub_14() {
    reg_tmp12.xy = (uniforms.f[5].yyyy + -reg_tmp12.yxxx).xy;
    return false;
}
bool sub_15() {
    reg_tmp13.x = (floor(reg_tmp0.xxxx)).x;
    reg_tmp13.x = (reg_tmp0.xxxx + -reg_tmp13).x;
    conditional_code = lessThanEqual(uniforms.f[5].ww, reg_tmp13.xx);
    reg_tmp13 = uniforms.f[32 + address_registers.y].wzyx;
    if (conditional_code.x) {
        sub_16();
    } else {
        sub_17();
    }
    reg_tmp11.z = (uniforms.f[5].yyyy + reg_tmp11.zzzz).z;
    return false;
}
bool sub_16() {
    reg_tmp11.xy = (fma_s(reg_tmp12.xyyy, reg_tmp13.xyyy, reg_tmp13.zwww)).xy;
    reg_tmp11.xy = (mul_s(reg_tmp11.xyyy, reg_tmp14.zwww)).xy;
    reg_tmp11.y = (uniforms.f[5].yyyy + -reg_tmp11.yyyy).y;
    return false;
}
bool sub_17() {
    conditional_code = notEqual(uniforms.f[5].xx, vs_in_reg0.zw);
    if (!conditional_code.x) {
        sub_18();
    } else {
        sub_19();
    }
    if (!conditional_code.y) {
        sub_20();
    } else {
        sub_21();
    }
    return false;
}
bool sub_18() {
    reg_tmp11.x = (reg_tmp13.xxxx).x;
    return false;
}
bool sub_19() {
    reg_tmp11.x = (reg_tmp13.zzzz).x;
    return false;
}
bool sub_20() {
    reg_tmp11.y = (reg_tmp13.yyyy).y;
    return false;
}
bool sub_21() {
    reg_tmp11.y = (reg_tmp13.wwww).y;
    return false;
}
bool sub_22() {
    if (!conditional_code.x) {
        sub_23();
    } else {
        sub_32();
    }
    reg_tmp11.z = (uniforms.f[5].zzzz + reg_tmp11.zzzz).z;
    return false;
}
bool sub_23() {
    reg_tmp13.x = (floor(reg_tmp0.xxxx)).x;
    reg_tmp13.x = (reg_tmp0.xxxx + -reg_tmp13).x;
    conditional_code = lessThanEqual(uniforms.f[5].ww, reg_tmp13.xx);
    if (conditional_code.x) {
        sub_24();
    } else {
        sub_25();
    }
    return false;
}
bool sub_24() {
    reg_tmp12.zw = (uniforms.f[5].xxxy).zw;
    reg_tmp11.x = dot_s(uniforms.f[32 + address_registers.y].wzyx, reg_tmp12);
    reg_tmp11.y = dot_s(uniforms.f[33 + address_registers.y].wzyx, reg_tmp12);
    reg_tmp11.xy = (mul_s(reg_tmp11.xyyy, reg_tmp14.zwww)).xy;
    reg_tmp11.y = (uniforms.f[5].yyyy + -reg_tmp11.yyyy).y;
    return false;
}
bool sub_25() {
    reg_tmp14 = uniforms.f[32 + address_registers.y].wzyx;
    reg_tmp13 = uniforms.f[33 + address_registers.y].wzyx;
    conditional_code = notEqual(uniforms.f[5].xx, vs_in_reg0.zw);
    if (!conditional_code.y) {
        sub_26();
    } else {
        sub_29();
    }
    return false;
}
bool sub_26() {
    if (!conditional_code.x) {
        sub_27();
    } else {
        sub_28();
    }
    return false;
}
bool sub_27() {
    reg_tmp11.xy = (reg_tmp14.xyyy).xy;
    return false;
}
bool sub_28() {
    reg_tmp11.xy = (reg_tmp13.zwww).xy;
    return false;
}
bool sub_29() {
    if (!conditional_code.x) {
        sub_30();
    } else {
        sub_31();
    }
    return false;
}
bool sub_30() {
    reg_tmp11.xy = (reg_tmp13.xyyy).xy;
    return false;
}
bool sub_31() {
    reg_tmp11.xy = (reg_tmp14.zwww).xy;
    return false;
}
bool sub_32() {
    reg_tmp11.x = dot_s(uniforms.f[32 + address_registers.y].wzyx, reg_tmp1);
    reg_tmp11.y = dot_s(uniforms.f[33 + address_registers.y].wzyx, reg_tmp1);
    return false;
}
bool sub_1() {
    uint jmp_to = 97u;
    while (true) {
        switch (jmp_to) {
        case 97u: {
            reg_tmp3.x = dot_s(uniforms.f[32 + address_registers.x].wzyx, reg_tmp1);
            reg_tmp3.y = dot_s(uniforms.f[33 + address_registers.x].wzyx, reg_tmp1);
            reg_tmp3.z = dot_s(uniforms.f[34 + address_registers.x].wzyx, reg_tmp1);
            reg_tmp3.w = (reg_tmp1.wwww).w;
            reg_tmp11 = uniforms.f[4].wzyx;
            reg_tmp11.z = (-uniforms.f[34 + address_registers.x].xxxx + reg_tmp11.zzzz).z;
            conditional_code.x = uniforms.f[5].xxxx.x != reg_tmp11.xzzz.x;
            conditional_code.y = uniforms.f[5].xxxx.y < reg_tmp11.xzzz.y;
            if (any(not(conditional_code))) {
                { jmp_to = 108u; break; }
            }
            reg_tmp11.z = rcp_s(reg_tmp11.z);
            reg_tmp3.x = (reg_tmp3.xxxx + reg_tmp11.xxxx).x;
            reg_tmp3.x = (fma_s(-reg_tmp11.yyyy, reg_tmp11.zzzz, reg_tmp3.xxxx)).x;
        }
        case 108u: {
        }
        default: return false;
        }
    }
    return false;
}
bool sub_0() {
    uint jmp_to = 109u;
    while (true) {
        switch (jmp_to) {
        case 109u: {
            address_registers.x = (ivec2(vs_in_reg0.xx)).x;
            reg_tmp0 = uniforms.f[9 + address_registers.x].wzyx;
            reg_tmp1.xy = (vs_in_reg0.zwzw).xy;
            reg_tmp1.zw = (uniforms.f[5].xyxy).zw;
            address_registers.xy = ivec2(reg_tmp0.xy);
            reg_tmp2 = uniforms.f[32 + address_registers.y].wzyx;
            if (uniforms.b[0]) {
                { jmp_to = 191u; break; }
            }
            reg_tmp4 = uniforms.f[31 + address_registers.x].wzyx;
            reg_tmp1.xy = (fma_s(reg_tmp1.xyyy, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
            {
                sub_1();
            }
            vs_out_attr0.x = dot_s(uniforms.f[0].wzyx, reg_tmp3);
            vs_out_attr0.y = dot_s(uniforms.f[1].wzyx, reg_tmp3);
            vs_out_attr0.z = dot_s(uniforms.f[2].wzyx, reg_tmp3);
            vs_out_attr0.w = dot_s(uniforms.f[3].wzyx, reg_tmp3);
            conditional_code = greaterThanEqual(uniforms.f[5].yy, reg_tmp0.ww);
            if (all(conditional_code)) {
                sub_2();
            } else {
                sub_3();
            }
            reg_tmp11.z = (reg_tmp0.zzzz).z;
            reg_tmp9 = mul_s(uniforms.f[5].zyzy, reg_tmp0.zzzz);
            reg_tmp9.xy = (floor(reg_tmp9)).xy;
            reg_tmp9.xy = (reg_tmp9.zwww + -reg_tmp9.xyyy).xy;
            reg_tmp9 = mul_s(uniforms.f[5].zzzz, reg_tmp9);
            reg_tmp14 = uniforms.f[6].wzyx;
            reg_tmp11.xy = (reg_tmp9.xyyy).xy;
            {
                sub_5();
            }
            if (uniforms.b[1]) {
                sub_33();
            }
            if (uniforms.b[2]) {
                sub_34();
            }
            vs_out_attr2 = reg_tmp11.xyyy;
            reg_tmp9 = mul_s(uniforms.f[5].zyzy, reg_tmp9.xxxx);
            reg_tmp9.xy = (floor(reg_tmp9)).xy;
            reg_tmp9.xy = (reg_tmp9.zwww + -reg_tmp9.xyyy).xy;
            reg_tmp9 = mul_s(uniforms.f[5].zzzz, reg_tmp9);
            reg_tmp14 = uniforms.f[7].wzyx;
            reg_tmp11.xy = (reg_tmp9.xyyy).xy;
            {
                sub_5();
            }
            if (uniforms.b[3]) {
                sub_35();
            }
            if (uniforms.b[4]) {
                sub_36();
            }
            vs_out_attr3 = reg_tmp11.xyyy;
            reg_tmp9 = mul_s(uniforms.f[5].zyzy, reg_tmp9.xxxx);
            reg_tmp9.xy = (floor(reg_tmp9)).xy;
            reg_tmp9.xy = (reg_tmp9.zwww + -reg_tmp9.xyyy).xy;
            reg_tmp9 = mul_s(uniforms.f[5].zzzz, reg_tmp9);
            reg_tmp14 = uniforms.f[8].wzyx;
            reg_tmp11.xy = (reg_tmp9.xyyy).xy;
            {
                sub_5();
            }
            if (uniforms.b[5]) {
                sub_37();
            }
            if (uniforms.b[6]) {
                sub_38();
            }
            vs_out_attr4 = reg_tmp11.xyyy;
            return true;
        }
        case 191u: {
            reg_tmp2.w = (reg_tmp2.wwww + reg_tmp2.yyyy).w;
            reg_tmp1.y = (-uniforms.f[5].yyyy + -reg_tmp1.yyyy).y;
            reg_tmp13.xy = (mul_s(uniforms.f[36 + address_registers.x].wzzz, reg_tmp2.xyyy)).xy;
            reg_tmp11.x = (mul_s(uniforms.f[35 + address_registers.x].wwww, -reg_tmp1.yyyy)).x;
            reg_tmp1.xy = (mul_s(reg_tmp1.xyyy, reg_tmp13.xyyy)).xy;
            reg_tmp1.x = (reg_tmp1.xxxx + reg_tmp11.xxxx).x;
            if (uniforms.b[1]) {
                sub_39();
            }
            reg_tmp1.xy = (reg_tmp1.xyyy + reg_tmp2.zwww).xy;
            reg_tmp1.xy = (uniforms.f[36 + address_registers.x].yxxx + reg_tmp1.xyyy).xy;
            {
                sub_1();
            }
            vs_out_attr0.x = dot_s(uniforms.f[0].wzyx, reg_tmp3);
            vs_out_attr0.y = dot_s(uniforms.f[1].wzyx, reg_tmp3);
            vs_out_attr0.z = dot_s(uniforms.f[2].wzyx, reg_tmp3);
            vs_out_attr0.w = dot_s(uniforms.f[3].wzyx, reg_tmp3);
            if (uniforms.b[2]) {
                sub_40();
            } else {
                sub_41();
            }
            reg_tmp8 = reg_tmp8 + -reg_tmp7;
            vs_out_attr1 = fma_s(reg_tmp8, reg_tmp11.yyyy, reg_tmp7);
            reg_tmp9.xy = (mul_s(uniforms.f[32 + address_registers.x].yxxx, reg_tmp11)).xy;
            reg_tmp11.zw = (vec4(lessThan(reg_tmp11, uniforms.f[5].yyyy))).zw;
            reg_tmp9.xy = (fma_s(reg_tmp11.zwww, uniforms.f[32 + address_registers.x].wzzz, reg_tmp9.xyyy)).xy;
            reg_tmp9.y = (uniforms.f[5].yyyy + -reg_tmp9.yyyy).y;
            vs_out_attr2 = reg_tmp9;
            vs_out_attr3 = reg_tmp9;
            vs_out_attr4 = reg_tmp9;
            return true;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_2() {
    vs_out_attr1.xyz = (uniforms.f[5].yyyy).xyz;
    vs_out_attr1.w = (reg_tmp0.wwww).w;
    return false;
}
bool sub_3() {
    address_registers.y = (ivec2(reg_tmp0.ww)).y;
    reg_tmp7 = uniforms.f[32 + address_registers.y].wzyx;
    reg_tmp8 = uniforms.f[33 + address_registers.y].wzyx;
    reg_tmp9 = uniforms.f[34 + address_registers.y].wzyx;
    reg_tmp10 = uniforms.f[35 + address_registers.y].wzyx;
    reg_tmp11.xy = (vs_in_reg0.zwww).xy;
    reg_tmp14.x = (floor(reg_tmp0.yyyy)).x;
    reg_tmp14.x = (reg_tmp0.yyyy + -reg_tmp14.xxxx).x;
    conditional_code = lessThanEqual(uniforms.f[5].ww, reg_tmp14.xx);
    if (conditional_code.x) {
        sub_4();
    }
    reg_tmp11.xy = (abs(reg_tmp11.xyyy)).xy;
    reg_tmp8 = reg_tmp8 + -reg_tmp7;
    reg_tmp8 = fma_s(reg_tmp8, reg_tmp11.xxxx, reg_tmp7);
    reg_tmp10 = reg_tmp10 + -reg_tmp9;
    reg_tmp10 = fma_s(reg_tmp10, reg_tmp11.xxxx, reg_tmp9);
    reg_tmp10 = reg_tmp10 + -reg_tmp8;
    reg_tmp10 = fma_s(reg_tmp10, reg_tmp11.yyyy, reg_tmp8);
    vs_out_attr1 = reg_tmp10;
    return false;
}
bool sub_4() {
    reg_tmp11.z = rcp_s(reg_tmp4.x);
    reg_tmp11.w = rcp_s(reg_tmp4.y);
    reg_tmp11.xy = (reg_tmp1.xyyy + -reg_tmp4.zwww).xy;
    reg_tmp11.xy = (mul_s(reg_tmp11.xyyy, reg_tmp11.zwww)).xy;
    return false;
}
bool sub_33() {
    reg_tmp11.xy = (reg_tmp11.yxxx).xy;
    reg_tmp11.y = (uniforms.f[5].yyyy + -reg_tmp11.yyyy).y;
    return false;
}
bool sub_34() {
    reg_tmp11.xy = (uniforms.f[5].yyyy + -reg_tmp11.yxxx).xy;
    return false;
}
bool sub_35() {
    reg_tmp11.xy = (reg_tmp11.yxxx).xy;
    reg_tmp11.y = (uniforms.f[5].yyyy + -reg_tmp11.yyyy).y;
    return false;
}
bool sub_36() {
    reg_tmp11.xy = (uniforms.f[5].yyyy + -reg_tmp11.yxxx).xy;
    return false;
}
bool sub_37() {
    reg_tmp11.xy = (reg_tmp11.yxxx).xy;
    reg_tmp11.y = (uniforms.f[5].yyyy + -reg_tmp11.yyyy).y;
    return false;
}
bool sub_38() {
    reg_tmp11.xy = (uniforms.f[5].yyyy + -reg_tmp11.yxxx).xy;
    return false;
}
bool sub_39() {
    reg_tmp13.xzw = (mul_s(uniforms.f[5].wxxx, reg_tmp13.xxxx)).xzw;
    reg_tmp13.y = (mul_s(uniforms.f[34 + address_registers.y].yyyy, reg_tmp13.yyyy)).y;
    reg_tmp11 = fma_s(reg_tmp1, uniforms.f[5].yyxx, -reg_tmp13);
    reg_tmp14 = uniforms.f[33 + address_registers.y].wzyx;
    reg_tmp1.x = dot_3(reg_tmp11.xyz, reg_tmp14.xyy);
    reg_tmp1.y = dot_3(reg_tmp11.xyz, reg_tmp14.zww);
    reg_tmp14 = uniforms.f[34 + address_registers.y].wzyx;
    reg_tmp1.z = dot_s(vec4(reg_tmp11.xyz, 1.0), reg_tmp14);
    reg_tmp1.xy = (reg_tmp1.xyyy + reg_tmp13.xyyy).xy;
    return false;
}
bool sub_40() {
    reg_tmp11 = abs(vs_in_reg0.zwzw);
    reg_tmp14.w = (floor(reg_tmp0.zzzz)).w;
    reg_tmp14.w = (reg_tmp0.zzzz + -reg_tmp14).w;
    address_registers.xy = ivec2(reg_tmp0.zx);
    reg_tmp14.w = (mul_s(uniforms.f[5].zzzz, reg_tmp14.wwww)).w;
    reg_tmp14.xyz = (uniforms.f[5].yyyy).xyz;
    reg_tmp7 = mul_s(uniforms.f[37 + address_registers.y].wzyx, reg_tmp14);
    reg_tmp8 = mul_s(uniforms.f[38 + address_registers.y].wzyx, reg_tmp14);
    return false;
}
bool sub_41() {
    reg_tmp11 = abs(vs_in_reg0.zwzw);
    address_registers.xy = ivec2(reg_tmp0.zw);
    reg_tmp7 = uniforms.f[32 + address_registers.y].wzyx;
    reg_tmp8 = uniforms.f[33 + address_registers.y].wzyx;
    return false;
}
// reference: 31D35636F710C06D, AC6AA2648888417C
// program: AC6AA2648888417C, 1C4CBC8096EA16CD, E333688E7A4E3951
// reference: 7F87A97674E5A61F, AC6AA2648888417C
// program: AC6AA2648888417C, 1C4CBC8096EA16CD, DE532DB7DA65108D
// program: AC6AA2648888417C, 1C4CBC8096EA16CD, F5405F949ABD9CF4
// program: AC6AA2648888417C, 1C4CBC8096EA16CD, 52C5102456B41FEE
// program: 888358E3BB131C20, 0D30074279C2FEED, 33E9C4BEB3FD7391
// program: 888358E3BB131C20, 0D30074279C2FEED, ED074CA328E24A7B
// program: 888358E3BB131C20, 0D30074279C2FEED, 046E44E355D9C09A
// program: FE7DE1650A5ACC34, 0D30074279C2FEED, B35EFE43E319BB63
// program: AC6AA2648888417C, 1C4CBC8096EA16CD, 2B730240EE2A8461
// program: AC6AA2648888417C, 1C4CBC8096EA16CD, 61C2DBAB611E2111
// program: AC6AA2648888417C, 1C4CBC8096EA16CD, F437CC0DAF2ECC46
// program: AC6AA2648888417C, 1C4CBC8096EA16CD, 1BC182922368739F
// program: AC6AA2648888417C, 1C4CBC8096EA16CD, A56F946360E5FB33
// program: 888358E3BB131C20, 0D30074279C2FEED, 72F56F6D6A16B65C
// program: 888358E3BB131C20, 0D30074279C2FEED, E9F98F2A6669187A
// program: 888358E3BB131C20, 0D30074279C2FEED, 1D9576CD2CFA910E
// program: 888358E3BB131C20, 0D30074279C2FEED, 7170135E7B36AD4A
// program: 888358E3BB131C20, 0D30074279C2FEED, 865DCB3F9A66E87D
// program: 888358E3BB131C20, 0D30074279C2FEED, 40D793FB8D8DA15D
// program: 888358E3BB131C20, 0D30074279C2FEED, 79E9834AE783AD92
// program: 888358E3BB131C20, 0D30074279C2FEED, 6064ABBB985A5B22
// program: 888358E3BB131C20, 0D30074279C2FEED, 75AFB4429A99DBF3
// program: AC6AA2648888417C, 1C4CBC8096EA16CD, 817DF3D39A617632
// program: AC6AA2648888417C, 1C4CBC8096EA16CD, 121AEB2C209E06DE
// program: AC6AA2648888417C, 1C4CBC8096EA16CD, CB75C1E4FB5DDB7C
// program: AC6AA2648888417C, 1C4CBC8096EA16CD, 7AF70408255288CC
// program: AC6AA2648888417C, 1C4CBC8096EA16CD, BD1D7911CA7BEBFB
// program: 888358E3BB131C20, 0D30074279C2FEED, BFD88A99D3C22DB9
// program: AC6AA2648888417C, 1C4CBC8096EA16CD, 385AE4FF8AADDC31
// program: AC6AA2648888417C, 1C4CBC8096EA16CD, 0B79B9743EBF4CD3
// program: AC6AA2648888417C, 1C4CBC8096EA16CD, 21FE9B12EEB051D9
// program: AC6AA2648888417C, 1C4CBC8096EA16CD, 3280E15438323023
// program: AC6AA2648888417C, 1C4CBC8096EA16CD, 87048F89800A5AF7
// shader: 8B30, 5FEF831D7A4E3951
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].aaa);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (const_color[1].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) * (const_color[2].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 0A7D03F062908828, 5FEF831D7A4E3951
// program: AC6AA2648888417C, 1C4CBC8096EA16CD, 5FEF831D7A4E3951
// shader: 8B30, 08377B7756F8B78C
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) * (const_color[2].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: E32461D938807D48, 08377B7756F8B78C
// program: AC6AA2648888417C, 1C4CBC8096EA16CD, 08377B7756F8B78C
// shader: 8B30, 8B81878A775F6657
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) * (const_color[2].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: E32461D91DAC008A, 8B81878A775F6657
// program: AC6AA2648888417C, 1C4CBC8096EA16CD, 8B81878A775F6657
// shader: 8B30, E00AB77EBC157119
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) * (const_color[2].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: E32461D9ED7B8B27, E00AB77EBC157119
// program: AC6AA2648888417C, 1C4CBC8096EA16CD, E00AB77EBC157119
// shader: 8B30, 3CB74A761B2F1FB4
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].aaa);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) * (const_color[2].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D39C7E924ED6F70E, 3CB74A761B2F1FB4
// program: AC6AA2648888417C, 1C4CBC8096EA16CD, 3CB74A761B2F1FB4
// shader: 8B30, A049CD441B2F1FB4
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) * (const_color[2].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: E32461D9169BFA9E, A049CD441B2F1FB4
// program: AC6AA2648888417C, 1C4CBC8096EA16CD, A049CD441B2F1FB4
// shader: 8B30, 1D1915B0BF53892A
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) * (const_color[2].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (const_color[3].rgb);
float alpha_output_3 = (const_color[3].a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: E32461D9C857F6E5, 1D1915B0BF53892A
// program: AC6AA2648888417C, 1C4CBC8096EA16CD, 1D1915B0BF53892A
// shader: 8B31, 44CE3A13C1B65B01

#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define mul_3(x, y) mix(x * y, vec3(0.0), isnan(x * y))
#define fma_s(x, y, z) (mul_s(x, y) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(mul_3(x, y), vec3(1.0))

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location = 0) in vec4 vs_in_reg0;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_1();
bool sub_19();
bool sub_2();
bool sub_9();
bool sub_10();
bool sub_11();
bool sub_12();
bool sub_13();
bool sub_14();
bool sub_15();
bool sub_16();
bool sub_17();
bool sub_18();
bool sub_0();
bool sub_3();
bool sub_4();
bool sub_5();
bool sub_6();
bool sub_7();
bool sub_8();

bool exec_shader() {
    sub_0();
    return true;
}

bool sub_1() {
    address_registers.x = (ivec2(vs_in_reg0.zz)).x;
    reg_tmp10 = uniforms.f[0].xxxz;
    reg_tmp10.xy = (vs_in_reg0.xyyy).xy;
    reg_tmp11 = uniforms.f[0].xxxx;
    reg_tmp12 = uniforms.f[0].xxxx;
    reg_tmp13 = uniforms.f[0].zzzz;
    reg_tmp4 = uniforms.f[0].xxxx;
    reg_tmp5 = uniforms.f[0].xxxx;
    return false;
}
bool sub_19() {
    vs_out_attr0 = reg_tmp10;
    reg_tmp13 = mul_s(uniforms.f[82], reg_tmp13);
    vs_out_attr1 = reg_tmp13;
    reg_tmp11.y = (uniforms.f[0].zzzz + -reg_tmp11.yyyy).y;
    reg_tmp12.y = (uniforms.f[0].zzzz + -reg_tmp12.yyyy).y;
    reg_tmp14.y = (uniforms.f[81].wwww).y;
    reg_tmp14.x = (mul_s(uniforms.f[0].wwww, reg_tmp14.yyyy)).x;
    reg_tmp2.x = rcp_s(reg_tmp14.x);
    reg_tmp14.z = (reg_tmp2.xxxx).z;
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp11.xyyy).xy;
    reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    reg_tmp11.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp12.xyyy).xy;
    reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    reg_tmp12.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    vs_out_attr2 = reg_tmp11;
    vs_out_attr3 = reg_tmp12;
    return false;
}
bool sub_2() {
    reg_tmp1.xyz = (uniforms.f[92].xyzz).xyz;
    reg_tmp1.w = (uniforms.f[0].xxxx).w;
    return false;
}
bool sub_9() {
    reg_tmp2 = uniforms.f[90];
    reg_tmp3 = uniforms.f[91];
    reg_tmp4 = uniforms.f[92];
    reg_tmp5 = uniforms.f[0].xxxz;
    reg_tmp6 = mul_s(uniforms.f[86].xxxx, reg_tmp2);
    reg_tmp6 = fma_s(reg_tmp3, uniforms.f[86].yyyy, reg_tmp6);
    reg_tmp6 = fma_s(reg_tmp4, uniforms.f[86].zzzz, reg_tmp6);
    reg_tmp6 = fma_s(reg_tmp5, uniforms.f[86].wwww, reg_tmp6);
    reg_tmp7 = mul_s(uniforms.f[87].xxxx, reg_tmp2);
    reg_tmp7 = fma_s(reg_tmp3, uniforms.f[87].yyyy, reg_tmp7);
    reg_tmp7 = fma_s(reg_tmp4, uniforms.f[87].zzzz, reg_tmp7);
    reg_tmp7 = fma_s(reg_tmp5, uniforms.f[87].wwww, reg_tmp7);
    reg_tmp8 = mul_s(uniforms.f[88].xxxx, reg_tmp2);
    reg_tmp8 = fma_s(reg_tmp3, uniforms.f[88].yyyy, reg_tmp8);
    reg_tmp8 = fma_s(reg_tmp4, uniforms.f[88].zzzz, reg_tmp8);
    reg_tmp8 = fma_s(reg_tmp5, uniforms.f[88].wwww, reg_tmp8);
    reg_tmp9 = mul_s(uniforms.f[89].xxxx, reg_tmp2);
    reg_tmp9 = fma_s(reg_tmp3, uniforms.f[89].yyyy, reg_tmp9);
    reg_tmp9 = fma_s(reg_tmp4, uniforms.f[89].zzzz, reg_tmp9);
    reg_tmp9 = fma_s(reg_tmp5, uniforms.f[89].wwww, reg_tmp9);
    return false;
}
bool sub_10() {
    reg_tmp2.x = rcp_s(uniforms.f[81].y);
    reg_tmp2.xy = (mul_s(uniforms.f[2 + address_registers.x].zwww, reg_tmp2.xxxx)).xy;
    reg_tmp2.xy = (uniforms.f[0].yyyy + reg_tmp2.xyyy).xy;
    reg_tmp3.xy = (floor(reg_tmp2.xyyy)).xy;
    reg_tmp2.xy = (mul_s(uniforms.f[81].yyyy, reg_tmp3.xyyy)).xy;
    reg_tmp2.xy = (uniforms.f[2 + address_registers.x].zwww + -reg_tmp2.xyyy).xy;
    reg_tmp0.xy = (min(uniforms.f[81].xxxx, -reg_tmp2.xyyy)).xy;
    reg_tmp0.xy = (max(-uniforms.f[81].xxxx, reg_tmp0.xyyy)).xy;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp0.xxxx, reg_tmp0.xxxx)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.xxxx)).y;
    reg_tmp5.x = (uniforms.f[5 + address_registers.x].wwww).x;
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_11();
    }
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_12();
    }
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_13();
    }
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_14();
    }
    reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    reg_tmp4.z = (uniforms.f[83].xxxx).z;
    reg_tmp4.w = (-uniforms.f[83].yyyy).w;
    reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[3 + address_registers.x].xyyy)).xy;
    reg_tmp4.z = (-uniforms.f[3 + address_registers.x].zzzz).z;
    reg_tmp4.w = (-uniforms.f[3 + address_registers.x].wwww).w;
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    reg_tmp11.xy = (reg_tmp5.xyyy).xy;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp0.yyyy, reg_tmp0.yyyy)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.yyyy)).y;
    reg_tmp5.x = (uniforms.f[6 + address_registers.x].wwww).x;
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_15();
    }
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_16();
    }
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_17();
    }
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_18();
    }
    reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    reg_tmp4.z = (uniforms.f[83].zzzz).z;
    reg_tmp4.w = (-uniforms.f[83].wwww).w;
    reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[4 + address_registers.x].xyyy)).xy;
    reg_tmp4.z = (-uniforms.f[4 + address_registers.x].zzzz).z;
    reg_tmp4.w = (-uniforms.f[4 + address_registers.x].wwww).w;
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    reg_tmp12.xy = (reg_tmp5.xyyy).xy;
    return false;
}
bool sub_11() {
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_12() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_13() {
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_14() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_15() {
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_16() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_17() {
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_18() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_0() {
    {
        sub_1();
    }
    reg_tmp10.xy = (uniforms.f[84].xyyy + reg_tmp10.xyyy).xy;
    reg_tmp10.xy = (mul_s(uniforms.f[2 + address_registers.x].xyyy, reg_tmp10.xyyy)).xy;
    {
        sub_2();
    }
    reg_tmp2.xyz = (reg_tmp1.xyzz).xyz;
    reg_tmp3.xyz = (uniforms.f[6 + address_registers.x].xyzz).xyz;
    reg_tmp4.x = dot_3(reg_tmp3.xyz, reg_tmp3.xyz);
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
    if (conditional_code.x) {
        sub_3();
    } else {
        sub_4();
    }
    reg_tmp3.xyz = (mul_s(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
    reg_tmp4.xyz = (mul_s(reg_tmp3.yzxx, reg_tmp2.zxyy)).xyz;
    reg_tmp4.xyz = (fma_s(-reg_tmp2.yzxx, reg_tmp3.zxyy, reg_tmp4)).xyz;
    reg_tmp5.x = dot_3(reg_tmp4.xyz, reg_tmp4.xyz);
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp5.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp5.y;
    if (conditional_code.x) {
        sub_5();
    } else {
        sub_6();
    }
    reg_tmp4.xyz = (mul_s(reg_tmp4.xyzz, reg_tmp5.xxxx)).xyz;
    reg_tmp5.xyz = (mul_s(reg_tmp3.yzxx, reg_tmp4.zxyy)).xyz;
    reg_tmp5.xyz = (fma_s(-reg_tmp4.yzxx, reg_tmp3.zxyy, reg_tmp5)).xyz;
    reg_tmp6.x = (reg_tmp4.xxxx).x;
    reg_tmp6.y = (reg_tmp3.xxxx).y;
    reg_tmp6.z = (reg_tmp5.xxxx).z;
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    reg_tmp7.x = (reg_tmp4.yyyy).x;
    reg_tmp7.y = (reg_tmp3.yyyy).y;
    reg_tmp7.z = (reg_tmp5.yyyy).z;
    reg_tmp7.w = (uniforms.f[0].xxxx).w;
    reg_tmp8.x = (reg_tmp4.zzzz).x;
    reg_tmp8.y = (reg_tmp3.zzzz).y;
    reg_tmp8.z = (reg_tmp5.zzzz).z;
    reg_tmp8.w = (uniforms.f[0].xxxx).w;
    reg_tmp9 = uniforms.f[0].xxxz;
    reg_tmp2.x = dot_s(reg_tmp10, reg_tmp6);
    reg_tmp2.y = dot_s(reg_tmp10, reg_tmp7);
    reg_tmp2.z = dot_s(reg_tmp10, reg_tmp8);
    reg_tmp2.w = dot_s(reg_tmp10, reg_tmp9);
    reg_tmp3.xyz = (uniforms.f[5 + address_registers.x].xyzz).xyz;
    reg_tmp3.xyz = (-uniforms.f[85].xyzz + reg_tmp3.xyzz).xyz;
    reg_tmp4.x = dot_3(reg_tmp3.xyz, reg_tmp3.xyz);
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
    if (conditional_code.x) {
        sub_7();
    } else {
        sub_8();
    }
    reg_tmp3.xyz = (mul_s(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
    reg_tmp10.xyz = (uniforms.f[5 + address_registers.x].xyzz + reg_tmp2.xyzz).xyz;
    reg_tmp10.xyz = (fma_s(reg_tmp3.xyzz, -uniforms.f[84].zzzz, reg_tmp10.xyzz)).xyz;
    {
        sub_9();
    }
    reg_tmp2 = reg_tmp10;
    reg_tmp10.x = dot_s(reg_tmp2, reg_tmp6);
    reg_tmp10.y = dot_s(reg_tmp2, reg_tmp7);
    reg_tmp10.z = dot_s(reg_tmp2, reg_tmp8);
    reg_tmp10.w = dot_s(reg_tmp2, reg_tmp9);
    reg_tmp2 = uniforms.f[1 + address_registers.x];
    reg_tmp3 = max(uniforms.f[0].xxxx, reg_tmp2);
    reg_tmp2 = min(uniforms.f[0].zzzz, reg_tmp3);
    reg_tmp13 = reg_tmp2;
    {
        sub_10();
    }
    {
        sub_19();
    }
    return true;
}
bool sub_3() {
    reg_tmp4.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_4() {
    reg_tmp4.x = rsq_s(reg_tmp4.x);
    return false;
}
bool sub_5() {
    reg_tmp5.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_6() {
    reg_tmp5.x = rsq_s(reg_tmp5.x);
    return false;
}
bool sub_7() {
    reg_tmp4.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_8() {
    reg_tmp4.x = rsq_s(reg_tmp4.x);
    return false;
}
// reference: 5C1EACCA3A65D0AA, 44CE3A13C1B65B01
// program: 44CE3A13C1B65B01, 13A54CCD8AA1DDA2, B6B08DE0C83FF4C8
// shader: 8B31, BE1CA71D0DC7876E

#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define mul_3(x, y) mix(x * y, vec3(0.0), isnan(x * y))
#define fma_s(x, y, z) (mul_s(x, y) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(mul_3(x, y), vec3(1.0))

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location = 0) in vec4 vs_in_reg0;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_1();
bool sub_16();
bool sub_2();
bool sub_3();
bool sub_6();
bool sub_7();
bool sub_8();
bool sub_9();
bool sub_10();
bool sub_11();
bool sub_12();
bool sub_13();
bool sub_14();
bool sub_15();
bool sub_0();
bool sub_4();
bool sub_5();

bool exec_shader() {
    sub_0();
    return true;
}

bool sub_1() {
    address_registers.x = (ivec2(vs_in_reg0.zz)).x;
    reg_tmp10 = uniforms.f[0].xxxz;
    reg_tmp10.xy = (vs_in_reg0.xyyy).xy;
    reg_tmp11 = uniforms.f[0].xxxx;
    reg_tmp12 = uniforms.f[0].xxxx;
    reg_tmp13 = uniforms.f[0].zzzz;
    reg_tmp4 = uniforms.f[0].xxxx;
    reg_tmp5 = uniforms.f[0].xxxx;
    return false;
}
bool sub_16() {
    vs_out_attr0 = reg_tmp10;
    reg_tmp13 = mul_s(uniforms.f[82], reg_tmp13);
    vs_out_attr1 = reg_tmp13;
    reg_tmp11.y = (uniforms.f[0].zzzz + -reg_tmp11.yyyy).y;
    reg_tmp12.y = (uniforms.f[0].zzzz + -reg_tmp12.yyyy).y;
    reg_tmp14.y = (uniforms.f[81].wwww).y;
    reg_tmp14.x = (mul_s(uniforms.f[0].wwww, reg_tmp14.yyyy)).x;
    reg_tmp2.x = rcp_s(reg_tmp14.x);
    reg_tmp14.z = (reg_tmp2.xxxx).z;
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp11.xyyy).xy;
    reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    reg_tmp11.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp12.xyyy).xy;
    reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    reg_tmp12.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    vs_out_attr2 = reg_tmp11;
    vs_out_attr3 = reg_tmp12;
    return false;
}
bool sub_2() {
    reg_tmp6.xyz = (-reg_tmp0.xyzz).xyz;
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    reg_tmp7.xyz = vec3(rcp_s(uniforms.f[81].y));
    reg_tmp8.xyz = (fma_s(reg_tmp6.xyzz, reg_tmp7.xyzz, uniforms.f[0].yyyy)).xyz;
    reg_tmp7.xyz = (floor(reg_tmp8.xyzz)).xyz;
    reg_tmp6.xyz = (fma_s(reg_tmp7.xyzz, -uniforms.f[81].yyyy, reg_tmp6.xyzz)).xyz;
    reg_tmp6 = min(uniforms.f[81].xxxx, reg_tmp6);
    reg_tmp6 = max(-uniforms.f[81].xxxx, reg_tmp6);
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp6.xxxx, reg_tmp6.xxxx)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp6.xxxx)).y;
    reg_tmp4.x = (reg_tmp1.xxxx).x;
    reg_tmp5.x = (reg_tmp1.yyyy).x;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp6.yyyy, reg_tmp6.yyyy)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp6.yyyy)).y;
    reg_tmp4.y = (reg_tmp1.xxxx).y;
    reg_tmp5.y = (reg_tmp1.yyyy).y;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp6.zzzz, reg_tmp6.zzzz)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp6.zzzz)).y;
    reg_tmp4.z = (reg_tmp1.xxxx).z;
    reg_tmp5.z = (reg_tmp1.yyyy).z;
    reg_tmp2.x = (mul_s(reg_tmp4.yyyy, reg_tmp5.zzzz)).x;
    reg_tmp2.y = (mul_s(reg_tmp5.yyyy, reg_tmp5.zzzz)).y;
    reg_tmp6.x = (mul_s(reg_tmp4.yyyy, reg_tmp4.zzzz)).x;
    reg_tmp6.y = (reg_tmp5.zzzz).y;
    reg_tmp6.z = (mul_s(-reg_tmp5.yyyy, reg_tmp4.zzzz)).z;
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    reg_tmp7.x = (mul_s(-reg_tmp2.xxxx, reg_tmp4.xxxx)).x;
    reg_tmp7.x = (fma_s(reg_tmp5.yyyy, reg_tmp5.xxxx, reg_tmp7.xxxx)).x;
    reg_tmp7.y = (mul_s(reg_tmp4.zzzz, reg_tmp4.xxxx)).y;
    reg_tmp7.z = (mul_s(reg_tmp2.yyyy, reg_tmp4.xxxx)).z;
    reg_tmp7.z = (fma_s(reg_tmp4.yyyy, reg_tmp5.xxxx, reg_tmp7.zzzz)).z;
    reg_tmp7.w = (uniforms.f[0].xxxx).w;
    reg_tmp8.x = (mul_s(reg_tmp2.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp8.x = (fma_s(reg_tmp5.yyyy, reg_tmp4.xxxx, reg_tmp8.xxxx)).x;
    reg_tmp8.y = (mul_s(-reg_tmp4.zzzz, reg_tmp5.xxxx)).y;
    reg_tmp8.z = (mul_s(-reg_tmp2.yyyy, reg_tmp5.xxxx)).z;
    reg_tmp8.z = (fma_s(reg_tmp4.yyyy, reg_tmp4.xxxx, reg_tmp8.zzzz)).z;
    reg_tmp8.w = (uniforms.f[0].xxxx).w;
    reg_tmp9 = uniforms.f[0].xxxz;
    return false;
}
bool sub_3() {
    reg_tmp6.x = (uniforms.f[90].xxxx).x;
    reg_tmp6.y = (uniforms.f[91].xxxx).y;
    reg_tmp6.z = (uniforms.f[92].xxxx).z;
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    reg_tmp7.x = (uniforms.f[90].yyyy).x;
    reg_tmp7.y = (uniforms.f[91].yyyy).y;
    reg_tmp7.z = (uniforms.f[92].yyyy).z;
    reg_tmp7.w = (uniforms.f[0].xxxx).w;
    reg_tmp8.x = (uniforms.f[90].zzzz).x;
    reg_tmp8.y = (uniforms.f[91].zzzz).y;
    reg_tmp8.z = (uniforms.f[92].zzzz).z;
    reg_tmp8.w = (uniforms.f[0].xxxx).w;
    reg_tmp9.x = (uniforms.f[90].wwww).x;
    reg_tmp9.y = (uniforms.f[91].wwww).y;
    reg_tmp9.z = (uniforms.f[92].wwww).z;
    reg_tmp9.w = (uniforms.f[0].zzzz).w;
    return false;
}
bool sub_6() {
    reg_tmp2 = uniforms.f[90];
    reg_tmp3 = uniforms.f[91];
    reg_tmp4 = uniforms.f[92];
    reg_tmp5 = uniforms.f[0].xxxz;
    reg_tmp6 = mul_s(uniforms.f[86].xxxx, reg_tmp2);
    reg_tmp6 = fma_s(reg_tmp3, uniforms.f[86].yyyy, reg_tmp6);
    reg_tmp6 = fma_s(reg_tmp4, uniforms.f[86].zzzz, reg_tmp6);
    reg_tmp6 = fma_s(reg_tmp5, uniforms.f[86].wwww, reg_tmp6);
    reg_tmp7 = mul_s(uniforms.f[87].xxxx, reg_tmp2);
    reg_tmp7 = fma_s(reg_tmp3, uniforms.f[87].yyyy, reg_tmp7);
    reg_tmp7 = fma_s(reg_tmp4, uniforms.f[87].zzzz, reg_tmp7);
    reg_tmp7 = fma_s(reg_tmp5, uniforms.f[87].wwww, reg_tmp7);
    reg_tmp8 = mul_s(uniforms.f[88].xxxx, reg_tmp2);
    reg_tmp8 = fma_s(reg_tmp3, uniforms.f[88].yyyy, reg_tmp8);
    reg_tmp8 = fma_s(reg_tmp4, uniforms.f[88].zzzz, reg_tmp8);
    reg_tmp8 = fma_s(reg_tmp5, uniforms.f[88].wwww, reg_tmp8);
    reg_tmp9 = mul_s(uniforms.f[89].xxxx, reg_tmp2);
    reg_tmp9 = fma_s(reg_tmp3, uniforms.f[89].yyyy, reg_tmp9);
    reg_tmp9 = fma_s(reg_tmp4, uniforms.f[89].zzzz, reg_tmp9);
    reg_tmp9 = fma_s(reg_tmp5, uniforms.f[89].wwww, reg_tmp9);
    return false;
}
bool sub_7() {
    reg_tmp2.x = rcp_s(uniforms.f[81].y);
    reg_tmp2.xy = (mul_s(uniforms.f[2 + address_registers.x].zwww, reg_tmp2.xxxx)).xy;
    reg_tmp2.xy = (uniforms.f[0].yyyy + reg_tmp2.xyyy).xy;
    reg_tmp3.xy = (floor(reg_tmp2.xyyy)).xy;
    reg_tmp2.xy = (mul_s(uniforms.f[81].yyyy, reg_tmp3.xyyy)).xy;
    reg_tmp2.xy = (uniforms.f[2 + address_registers.x].zwww + -reg_tmp2.xyyy).xy;
    reg_tmp0.xy = (min(uniforms.f[81].xxxx, -reg_tmp2.xyyy)).xy;
    reg_tmp0.xy = (max(-uniforms.f[81].xxxx, reg_tmp0.xyyy)).xy;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp0.xxxx, reg_tmp0.xxxx)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.xxxx)).y;
    reg_tmp5.x = (uniforms.f[5 + address_registers.x].wwww).x;
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_8();
    }
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_9();
    }
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_10();
    }
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_11();
    }
    reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    reg_tmp4.z = (uniforms.f[83].xxxx).z;
    reg_tmp4.w = (-uniforms.f[83].yyyy).w;
    reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[3 + address_registers.x].xyyy)).xy;
    reg_tmp4.z = (-uniforms.f[3 + address_registers.x].zzzz).z;
    reg_tmp4.w = (-uniforms.f[3 + address_registers.x].wwww).w;
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    reg_tmp11.xy = (reg_tmp5.xyyy).xy;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp0.yyyy, reg_tmp0.yyyy)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.yyyy)).y;
    reg_tmp5.x = (uniforms.f[6 + address_registers.x].wwww).x;
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_12();
    }
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_13();
    }
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_14();
    }
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_15();
    }
    reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    reg_tmp4.z = (uniforms.f[83].zzzz).z;
    reg_tmp4.w = (-uniforms.f[83].wwww).w;
    reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[4 + address_registers.x].xyyy)).xy;
    reg_tmp4.z = (-uniforms.f[4 + address_registers.x].zzzz).z;
    reg_tmp4.w = (-uniforms.f[4 + address_registers.x].wwww).w;
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    reg_tmp12.xy = (reg_tmp5.xyyy).xy;
    return false;
}
bool sub_8() {
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_9() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_10() {
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_11() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_12() {
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_13() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_14() {
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_15() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_0() {
    {
        sub_1();
    }
    reg_tmp10.xy = (uniforms.f[84].xyyy + reg_tmp10.xyyy).xy;
    reg_tmp10.xy = (mul_s(uniforms.f[2 + address_registers.x].xyyy, reg_tmp10.xyyy)).xy;
    reg_tmp0 = uniforms.f[7 + address_registers.x];
    {
        sub_2();
    }
    reg_tmp2.x = dot_s(reg_tmp10, reg_tmp6);
    reg_tmp2.y = dot_s(reg_tmp10, reg_tmp7);
    reg_tmp2.z = dot_s(reg_tmp10, reg_tmp8);
    reg_tmp2.w = dot_s(reg_tmp10, reg_tmp9);
    reg_tmp10 = reg_tmp2;
    {
        sub_3();
    }
    reg_tmp2.x = dot_s(reg_tmp10, reg_tmp6);
    reg_tmp2.y = dot_s(reg_tmp10, reg_tmp7);
    reg_tmp2.z = dot_s(reg_tmp10, reg_tmp8);
    reg_tmp2.w = dot_s(uniforms.f[0].xxxz, reg_tmp10);
    reg_tmp3.xyz = (uniforms.f[5 + address_registers.x].xyzz).xyz;
    reg_tmp3.xyz = (uniforms.f[85].xyzz + -reg_tmp3.xyzz).xyz;
    reg_tmp4.x = dot_3(reg_tmp3.xyz, reg_tmp3.xyz);
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
    if (conditional_code.x) {
        sub_4();
    } else {
        sub_5();
    }
    reg_tmp3.xyz = (mul_s(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
    reg_tmp10.xyz = (uniforms.f[5 + address_registers.x].xyzz + reg_tmp2.xyzz).xyz;
    reg_tmp10.xyz = (fma_s(reg_tmp3.xyzz, uniforms.f[84].zzzz, reg_tmp10.xyzz)).xyz;
    {
        sub_6();
    }
    reg_tmp2 = reg_tmp10;
    reg_tmp10.x = dot_s(reg_tmp2, reg_tmp6);
    reg_tmp10.y = dot_s(reg_tmp2, reg_tmp7);
    reg_tmp10.z = dot_s(reg_tmp2, reg_tmp8);
    reg_tmp10.w = dot_s(reg_tmp2, reg_tmp9);
    reg_tmp2 = uniforms.f[1 + address_registers.x];
    reg_tmp3 = max(uniforms.f[0].xxxx, reg_tmp2);
    reg_tmp2 = min(uniforms.f[0].zzzz, reg_tmp3);
    reg_tmp13 = reg_tmp2;
    {
        sub_7();
    }
    {
        sub_16();
    }
    return true;
}
bool sub_4() {
    reg_tmp4.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_5() {
    reg_tmp4.x = rsq_s(reg_tmp4.x);
    return false;
}
// reference: 5B835BF56ABB8DF3, BE1CA71D0DC7876E
// program: BE1CA71D0DC7876E, 13A54CCD8AA1DDA2, 1041172C77D1741F
// shader: 8B31, 524C55FEFFD825DF

#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define mul_3(x, y) mix(x * y, vec3(0.0), isnan(x * y))
#define fma_s(x, y, z) (mul_s(x, y) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(mul_3(x, y), vec3(1.0))

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location = 0) in vec4 vs_in_reg0;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_1();
bool sub_15();
bool sub_2();
bool sub_5();
bool sub_6();
bool sub_7();
bool sub_8();
bool sub_9();
bool sub_10();
bool sub_11();
bool sub_12();
bool sub_13();
bool sub_14();
bool sub_0();
bool sub_3();
bool sub_4();

bool exec_shader() {
    sub_0();
    return true;
}

bool sub_1() {
    address_registers.x = (ivec2(vs_in_reg0.zz)).x;
    reg_tmp10 = uniforms.f[0].xxxz;
    reg_tmp10.xy = (vs_in_reg0.xyyy).xy;
    reg_tmp11 = uniforms.f[0].xxxx;
    reg_tmp12 = uniforms.f[0].xxxx;
    reg_tmp13 = uniforms.f[0].zzzz;
    reg_tmp4 = uniforms.f[0].xxxx;
    reg_tmp5 = uniforms.f[0].xxxx;
    return false;
}
bool sub_15() {
    vs_out_attr0 = reg_tmp10;
    reg_tmp13 = mul_s(uniforms.f[82], reg_tmp13);
    vs_out_attr1 = reg_tmp13;
    reg_tmp11.y = (uniforms.f[0].zzzz + -reg_tmp11.yyyy).y;
    reg_tmp12.y = (uniforms.f[0].zzzz + -reg_tmp12.yyyy).y;
    reg_tmp14.y = (uniforms.f[81].wwww).y;
    reg_tmp14.x = (mul_s(uniforms.f[0].wwww, reg_tmp14.yyyy)).x;
    reg_tmp2.x = rcp_s(reg_tmp14.x);
    reg_tmp14.z = (reg_tmp2.xxxx).z;
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp11.xyyy).xy;
    reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    reg_tmp11.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp12.xyyy).xy;
    reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    reg_tmp12.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    vs_out_attr2 = reg_tmp11;
    vs_out_attr3 = reg_tmp12;
    return false;
}
bool sub_2() {
    reg_tmp6.xyz = (-reg_tmp0.xyzz).xyz;
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    reg_tmp7.xyz = vec3(rcp_s(uniforms.f[81].y));
    reg_tmp8.xyz = (fma_s(reg_tmp6.xyzz, reg_tmp7.xyzz, uniforms.f[0].yyyy)).xyz;
    reg_tmp7.xyz = (floor(reg_tmp8.xyzz)).xyz;
    reg_tmp6.xyz = (fma_s(reg_tmp7.xyzz, -uniforms.f[81].yyyy, reg_tmp6.xyzz)).xyz;
    reg_tmp6 = min(uniforms.f[81].xxxx, reg_tmp6);
    reg_tmp6 = max(-uniforms.f[81].xxxx, reg_tmp6);
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp6.xxxx, reg_tmp6.xxxx)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp6.xxxx)).y;
    reg_tmp4.x = (reg_tmp1.xxxx).x;
    reg_tmp5.x = (reg_tmp1.yyyy).x;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp6.yyyy, reg_tmp6.yyyy)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp6.yyyy)).y;
    reg_tmp4.y = (reg_tmp1.xxxx).y;
    reg_tmp5.y = (reg_tmp1.yyyy).y;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp6.zzzz, reg_tmp6.zzzz)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp6.zzzz)).y;
    reg_tmp4.z = (reg_tmp1.xxxx).z;
    reg_tmp5.z = (reg_tmp1.yyyy).z;
    reg_tmp2.x = (mul_s(reg_tmp4.yyyy, reg_tmp5.zzzz)).x;
    reg_tmp2.y = (mul_s(reg_tmp5.yyyy, reg_tmp5.zzzz)).y;
    reg_tmp6.x = (mul_s(reg_tmp4.yyyy, reg_tmp4.zzzz)).x;
    reg_tmp6.y = (reg_tmp5.zzzz).y;
    reg_tmp6.z = (mul_s(-reg_tmp5.yyyy, reg_tmp4.zzzz)).z;
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    reg_tmp7.x = (mul_s(-reg_tmp2.xxxx, reg_tmp4.xxxx)).x;
    reg_tmp7.x = (fma_s(reg_tmp5.yyyy, reg_tmp5.xxxx, reg_tmp7.xxxx)).x;
    reg_tmp7.y = (mul_s(reg_tmp4.zzzz, reg_tmp4.xxxx)).y;
    reg_tmp7.z = (mul_s(reg_tmp2.yyyy, reg_tmp4.xxxx)).z;
    reg_tmp7.z = (fma_s(reg_tmp4.yyyy, reg_tmp5.xxxx, reg_tmp7.zzzz)).z;
    reg_tmp7.w = (uniforms.f[0].xxxx).w;
    reg_tmp8.x = (mul_s(reg_tmp2.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp8.x = (fma_s(reg_tmp5.yyyy, reg_tmp4.xxxx, reg_tmp8.xxxx)).x;
    reg_tmp8.y = (mul_s(-reg_tmp4.zzzz, reg_tmp5.xxxx)).y;
    reg_tmp8.z = (mul_s(-reg_tmp2.yyyy, reg_tmp5.xxxx)).z;
    reg_tmp8.z = (fma_s(reg_tmp4.yyyy, reg_tmp4.xxxx, reg_tmp8.zzzz)).z;
    reg_tmp8.w = (uniforms.f[0].xxxx).w;
    reg_tmp9 = uniforms.f[0].xxxz;
    return false;
}
bool sub_5() {
    reg_tmp2 = uniforms.f[90];
    reg_tmp3 = uniforms.f[91];
    reg_tmp4 = uniforms.f[92];
    reg_tmp5 = uniforms.f[0].xxxz;
    reg_tmp6 = mul_s(uniforms.f[86].xxxx, reg_tmp2);
    reg_tmp6 = fma_s(reg_tmp3, uniforms.f[86].yyyy, reg_tmp6);
    reg_tmp6 = fma_s(reg_tmp4, uniforms.f[86].zzzz, reg_tmp6);
    reg_tmp6 = fma_s(reg_tmp5, uniforms.f[86].wwww, reg_tmp6);
    reg_tmp7 = mul_s(uniforms.f[87].xxxx, reg_tmp2);
    reg_tmp7 = fma_s(reg_tmp3, uniforms.f[87].yyyy, reg_tmp7);
    reg_tmp7 = fma_s(reg_tmp4, uniforms.f[87].zzzz, reg_tmp7);
    reg_tmp7 = fma_s(reg_tmp5, uniforms.f[87].wwww, reg_tmp7);
    reg_tmp8 = mul_s(uniforms.f[88].xxxx, reg_tmp2);
    reg_tmp8 = fma_s(reg_tmp3, uniforms.f[88].yyyy, reg_tmp8);
    reg_tmp8 = fma_s(reg_tmp4, uniforms.f[88].zzzz, reg_tmp8);
    reg_tmp8 = fma_s(reg_tmp5, uniforms.f[88].wwww, reg_tmp8);
    reg_tmp9 = mul_s(uniforms.f[89].xxxx, reg_tmp2);
    reg_tmp9 = fma_s(reg_tmp3, uniforms.f[89].yyyy, reg_tmp9);
    reg_tmp9 = fma_s(reg_tmp4, uniforms.f[89].zzzz, reg_tmp9);
    reg_tmp9 = fma_s(reg_tmp5, uniforms.f[89].wwww, reg_tmp9);
    return false;
}
bool sub_6() {
    reg_tmp2.x = rcp_s(uniforms.f[81].y);
    reg_tmp2.xy = (mul_s(uniforms.f[2 + address_registers.x].zwww, reg_tmp2.xxxx)).xy;
    reg_tmp2.xy = (uniforms.f[0].yyyy + reg_tmp2.xyyy).xy;
    reg_tmp3.xy = (floor(reg_tmp2.xyyy)).xy;
    reg_tmp2.xy = (mul_s(uniforms.f[81].yyyy, reg_tmp3.xyyy)).xy;
    reg_tmp2.xy = (uniforms.f[2 + address_registers.x].zwww + -reg_tmp2.xyyy).xy;
    reg_tmp0.xy = (min(uniforms.f[81].xxxx, -reg_tmp2.xyyy)).xy;
    reg_tmp0.xy = (max(-uniforms.f[81].xxxx, reg_tmp0.xyyy)).xy;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp0.xxxx, reg_tmp0.xxxx)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.xxxx)).y;
    reg_tmp5.x = (uniforms.f[5 + address_registers.x].wwww).x;
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_7();
    }
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_8();
    }
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_9();
    }
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_10();
    }
    reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    reg_tmp4.z = (uniforms.f[83].xxxx).z;
    reg_tmp4.w = (-uniforms.f[83].yyyy).w;
    reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[3 + address_registers.x].xyyy)).xy;
    reg_tmp4.z = (-uniforms.f[3 + address_registers.x].zzzz).z;
    reg_tmp4.w = (-uniforms.f[3 + address_registers.x].wwww).w;
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    reg_tmp11.xy = (reg_tmp5.xyyy).xy;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp0.yyyy, reg_tmp0.yyyy)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.yyyy)).y;
    reg_tmp5.x = (uniforms.f[6 + address_registers.x].wwww).x;
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_11();
    }
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_12();
    }
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_13();
    }
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_14();
    }
    reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    reg_tmp4.z = (uniforms.f[83].zzzz).z;
    reg_tmp4.w = (-uniforms.f[83].wwww).w;
    reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[4 + address_registers.x].xyyy)).xy;
    reg_tmp4.z = (-uniforms.f[4 + address_registers.x].zzzz).z;
    reg_tmp4.w = (-uniforms.f[4 + address_registers.x].wwww).w;
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    reg_tmp12.xy = (reg_tmp5.xyyy).xy;
    return false;
}
bool sub_7() {
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_8() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_9() {
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_10() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_11() {
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_12() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_13() {
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_14() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_0() {
    {
        sub_1();
    }
    reg_tmp10.xy = (uniforms.f[84].xyyy + reg_tmp10.xyyy).xy;
    reg_tmp10.xy = (mul_s(uniforms.f[2 + address_registers.x].xyyy, reg_tmp10.xyyy)).xy;
    reg_tmp2 = reg_tmp10.xzyw;
    reg_tmp2.z = (-reg_tmp2.zzzz).z;
    reg_tmp14 = reg_tmp2;
    reg_tmp0 = uniforms.f[7 + address_registers.x];
    {
        sub_2();
    }
    reg_tmp2.x = dot_s(reg_tmp14, reg_tmp6);
    reg_tmp2.y = dot_s(reg_tmp14, reg_tmp7);
    reg_tmp2.z = dot_s(reg_tmp14, reg_tmp8);
    reg_tmp2.w = dot_s(reg_tmp14, reg_tmp9);
    reg_tmp6 = uniforms.f[8 + address_registers.x];
    reg_tmp7 = uniforms.f[9 + address_registers.x];
    reg_tmp8 = uniforms.f[10 + address_registers.x];
    reg_tmp9 = uniforms.f[0].xxxz;
    reg_tmp6.w = (uniforms.f[5 + address_registers.x].xxxx).w;
    reg_tmp7.w = (uniforms.f[5 + address_registers.x].yyyy).w;
    reg_tmp8.w = (uniforms.f[5 + address_registers.x].zzzz).w;
    reg_tmp10.x = dot_s(reg_tmp2, reg_tmp6);
    reg_tmp10.y = dot_s(reg_tmp2, reg_tmp7);
    reg_tmp10.z = dot_s(reg_tmp2, reg_tmp8);
    reg_tmp10.w = dot_s(reg_tmp2, reg_tmp9);
    reg_tmp3.xyz = (uniforms.f[5 + address_registers.x].xyzz).xyz;
    reg_tmp3.xyz = (uniforms.f[85].xyzz + -reg_tmp3.xyzz).xyz;
    reg_tmp4.x = dot_3(reg_tmp3.xyz, reg_tmp3.xyz);
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
    if (conditional_code.x) {
        sub_3();
    } else {
        sub_4();
    }
    reg_tmp3.xyz = (mul_s(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
    reg_tmp10.xyz = (fma_s(reg_tmp3.xyzz, uniforms.f[84].zzzz, reg_tmp10.xyzz)).xyz;
    {
        sub_5();
    }
    reg_tmp2 = reg_tmp10;
    reg_tmp10.x = dot_s(reg_tmp2, reg_tmp6);
    reg_tmp10.y = dot_s(reg_tmp2, reg_tmp7);
    reg_tmp10.z = dot_s(reg_tmp2, reg_tmp8);
    reg_tmp10.w = dot_s(reg_tmp2, reg_tmp9);
    reg_tmp2 = uniforms.f[1 + address_registers.x];
    reg_tmp3 = max(uniforms.f[0].xxxx, reg_tmp2);
    reg_tmp2 = min(uniforms.f[0].zzzz, reg_tmp3);
    reg_tmp13 = reg_tmp2;
    {
        sub_6();
    }
    {
        sub_15();
    }
    return true;
}
bool sub_3() {
    reg_tmp4.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_4() {
    reg_tmp4.x = rsq_s(reg_tmp4.x);
    return false;
}
// reference: 4F2FA6E17562F839, 524C55FEFFD825DF
// program: 524C55FEFFD825DF, 13A54CCD8AA1DDA2, B6B08DE0C83FF4C8
// program: BE1CA71D0DC7876E, 13A54CCD8AA1DDA2, B6B08DE0C83FF4C8
// shader: 8B31, 2E8C44D06926572F

#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define mul_3(x, y) mix(x * y, vec3(0.0), isnan(x * y))
#define fma_s(x, y, z) (mul_s(x, y) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(mul_3(x, y), vec3(1.0))

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location = 0) in vec4 vs_in_reg0;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_1();
bool sub_18();
bool sub_8();
bool sub_9();
bool sub_10();
bool sub_11();
bool sub_12();
bool sub_13();
bool sub_14();
bool sub_15();
bool sub_16();
bool sub_17();
bool sub_0();
bool sub_2();
bool sub_3();
bool sub_4();
bool sub_5();
bool sub_6();
bool sub_7();

bool exec_shader() {
    sub_0();
    return true;
}

bool sub_1() {
    address_registers.x = (ivec2(vs_in_reg0.zz)).x;
    reg_tmp10 = uniforms.f[0].xxxz;
    reg_tmp10.xy = (vs_in_reg0.xyyy).xy;
    reg_tmp11 = uniforms.f[0].xxxx;
    reg_tmp12 = uniforms.f[0].xxxx;
    reg_tmp13 = uniforms.f[0].zzzz;
    reg_tmp4 = uniforms.f[0].xxxx;
    reg_tmp5 = uniforms.f[0].xxxx;
    return false;
}
bool sub_18() {
    vs_out_attr0 = reg_tmp10;
    reg_tmp13 = mul_s(uniforms.f[82], reg_tmp13);
    vs_out_attr1 = reg_tmp13;
    reg_tmp11.y = (uniforms.f[0].zzzz + -reg_tmp11.yyyy).y;
    reg_tmp12.y = (uniforms.f[0].zzzz + -reg_tmp12.yyyy).y;
    reg_tmp14.y = (uniforms.f[81].wwww).y;
    reg_tmp14.x = (mul_s(uniforms.f[0].wwww, reg_tmp14.yyyy)).x;
    reg_tmp2.x = rcp_s(reg_tmp14.x);
    reg_tmp14.z = (reg_tmp2.xxxx).z;
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp11.xyyy).xy;
    reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    reg_tmp11.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp12.xyyy).xy;
    reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    reg_tmp12.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    vs_out_attr2 = reg_tmp11;
    vs_out_attr3 = reg_tmp12;
    return false;
}
bool sub_8() {
    reg_tmp2 = uniforms.f[90];
    reg_tmp3 = uniforms.f[91];
    reg_tmp4 = uniforms.f[92];
    reg_tmp5 = uniforms.f[0].xxxz;
    reg_tmp6 = mul_s(uniforms.f[86].xxxx, reg_tmp2);
    reg_tmp6 = fma_s(reg_tmp3, uniforms.f[86].yyyy, reg_tmp6);
    reg_tmp6 = fma_s(reg_tmp4, uniforms.f[86].zzzz, reg_tmp6);
    reg_tmp6 = fma_s(reg_tmp5, uniforms.f[86].wwww, reg_tmp6);
    reg_tmp7 = mul_s(uniforms.f[87].xxxx, reg_tmp2);
    reg_tmp7 = fma_s(reg_tmp3, uniforms.f[87].yyyy, reg_tmp7);
    reg_tmp7 = fma_s(reg_tmp4, uniforms.f[87].zzzz, reg_tmp7);
    reg_tmp7 = fma_s(reg_tmp5, uniforms.f[87].wwww, reg_tmp7);
    reg_tmp8 = mul_s(uniforms.f[88].xxxx, reg_tmp2);
    reg_tmp8 = fma_s(reg_tmp3, uniforms.f[88].yyyy, reg_tmp8);
    reg_tmp8 = fma_s(reg_tmp4, uniforms.f[88].zzzz, reg_tmp8);
    reg_tmp8 = fma_s(reg_tmp5, uniforms.f[88].wwww, reg_tmp8);
    reg_tmp9 = mul_s(uniforms.f[89].xxxx, reg_tmp2);
    reg_tmp9 = fma_s(reg_tmp3, uniforms.f[89].yyyy, reg_tmp9);
    reg_tmp9 = fma_s(reg_tmp4, uniforms.f[89].zzzz, reg_tmp9);
    reg_tmp9 = fma_s(reg_tmp5, uniforms.f[89].wwww, reg_tmp9);
    return false;
}
bool sub_9() {
    reg_tmp2.x = rcp_s(uniforms.f[81].y);
    reg_tmp2.xy = (mul_s(uniforms.f[2 + address_registers.x].zwww, reg_tmp2.xxxx)).xy;
    reg_tmp2.xy = (uniforms.f[0].yyyy + reg_tmp2.xyyy).xy;
    reg_tmp3.xy = (floor(reg_tmp2.xyyy)).xy;
    reg_tmp2.xy = (mul_s(uniforms.f[81].yyyy, reg_tmp3.xyyy)).xy;
    reg_tmp2.xy = (uniforms.f[2 + address_registers.x].zwww + -reg_tmp2.xyyy).xy;
    reg_tmp0.xy = (min(uniforms.f[81].xxxx, -reg_tmp2.xyyy)).xy;
    reg_tmp0.xy = (max(-uniforms.f[81].xxxx, reg_tmp0.xyyy)).xy;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp0.xxxx, reg_tmp0.xxxx)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.xxxx)).y;
    reg_tmp5.x = (uniforms.f[5 + address_registers.x].wwww).x;
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_10();
    }
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_11();
    }
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_12();
    }
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_13();
    }
    reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    reg_tmp4.z = (uniforms.f[83].xxxx).z;
    reg_tmp4.w = (-uniforms.f[83].yyyy).w;
    reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[3 + address_registers.x].xyyy)).xy;
    reg_tmp4.z = (-uniforms.f[3 + address_registers.x].zzzz).z;
    reg_tmp4.w = (-uniforms.f[3 + address_registers.x].wwww).w;
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    reg_tmp11.xy = (reg_tmp5.xyyy).xy;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp0.yyyy, reg_tmp0.yyyy)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.yyyy)).y;
    reg_tmp5.x = (uniforms.f[6 + address_registers.x].wwww).x;
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_14();
    }
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_15();
    }
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_16();
    }
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_17();
    }
    reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    reg_tmp4.z = (uniforms.f[83].zzzz).z;
    reg_tmp4.w = (-uniforms.f[83].wwww).w;
    reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[4 + address_registers.x].xyyy)).xy;
    reg_tmp4.z = (-uniforms.f[4 + address_registers.x].zzzz).z;
    reg_tmp4.w = (-uniforms.f[4 + address_registers.x].wwww).w;
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    reg_tmp12.xy = (reg_tmp5.xyyy).xy;
    return false;
}
bool sub_10() {
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_11() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_12() {
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_13() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_14() {
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_15() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_16() {
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_17() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_0() {
    {
        sub_1();
    }
    reg_tmp10.xy = (uniforms.f[84].xyyy + reg_tmp10.xyyy).xy;
    reg_tmp10.xy = (mul_s(uniforms.f[2 + address_registers.x].xyyy, reg_tmp10.xyyy)).xy;
    reg_tmp2.x = (uniforms.f[8 + address_registers.x].yyyy).x;
    reg_tmp2.y = (uniforms.f[9 + address_registers.x].yyyy).y;
    reg_tmp2.z = (uniforms.f[10 + address_registers.x].yyyy).z;
    reg_tmp3.xyz = (uniforms.f[6 + address_registers.x].xyzz).xyz;
    reg_tmp4.x = dot_3(reg_tmp3.xyz, reg_tmp3.xyz);
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
    if (conditional_code.x) {
        sub_2();
    } else {
        sub_3();
    }
    reg_tmp3.xyz = (mul_s(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
    reg_tmp4.xyz = (mul_s(reg_tmp2.yzxx, reg_tmp3.zxyy)).xyz;
    reg_tmp4.xyz = (fma_s(-reg_tmp3.yzxx, reg_tmp2.zxyy, reg_tmp4)).xyz;
    reg_tmp5.x = dot_3(reg_tmp4.xyz, reg_tmp4.xyz);
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp5.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp5.y;
    if (conditional_code.x) {
        sub_4();
    } else {
        sub_5();
    }
    reg_tmp4.xyz = (mul_s(reg_tmp4.xyzz, reg_tmp5.xxxx)).xyz;
    reg_tmp5.xyz = (mul_s(reg_tmp4.yzxx, reg_tmp3.zxyy)).xyz;
    reg_tmp5.xyz = (fma_s(-reg_tmp3.yzxx, reg_tmp4.zxyy, reg_tmp5)).xyz;
    reg_tmp6.x = (reg_tmp4.xxxx).x;
    reg_tmp6.y = (reg_tmp3.xxxx).y;
    reg_tmp6.z = (reg_tmp5.xxxx).z;
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    reg_tmp7.x = (reg_tmp4.yyyy).x;
    reg_tmp7.y = (reg_tmp3.yyyy).y;
    reg_tmp7.z = (reg_tmp5.yyyy).z;
    reg_tmp7.w = (uniforms.f[0].xxxx).w;
    reg_tmp8.x = (reg_tmp4.zzzz).x;
    reg_tmp8.y = (reg_tmp3.zzzz).y;
    reg_tmp8.z = (reg_tmp5.zzzz).z;
    reg_tmp8.w = (uniforms.f[0].xxxx).w;
    reg_tmp9 = uniforms.f[0].xxxz;
    reg_tmp2.x = dot_s(reg_tmp10, reg_tmp6);
    reg_tmp2.y = dot_s(reg_tmp10, reg_tmp7);
    reg_tmp2.z = dot_s(reg_tmp10, reg_tmp8);
    reg_tmp2.w = dot_s(reg_tmp10, reg_tmp9);
    reg_tmp3.xyz = (uniforms.f[5 + address_registers.x].xyzz).xyz;
    reg_tmp3.xyz = (uniforms.f[85].xyzz + -reg_tmp3.xyzz).xyz;
    reg_tmp4.x = dot_3(reg_tmp3.xyz, reg_tmp3.xyz);
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
    if (conditional_code.x) {
        sub_6();
    } else {
        sub_7();
    }
    reg_tmp3.xyz = (mul_s(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
    reg_tmp10.xyz = (uniforms.f[5 + address_registers.x].xyzz + reg_tmp2.xyzz).xyz;
    reg_tmp10.xyz = (fma_s(reg_tmp3.xyzz, uniforms.f[84].zzzz, reg_tmp10.xyzz)).xyz;
    {
        sub_8();
    }
    reg_tmp2 = reg_tmp10;
    reg_tmp10.x = dot_s(reg_tmp2, reg_tmp6);
    reg_tmp10.y = dot_s(reg_tmp2, reg_tmp7);
    reg_tmp10.z = dot_s(reg_tmp2, reg_tmp8);
    reg_tmp10.w = dot_s(reg_tmp2, reg_tmp9);
    reg_tmp2 = uniforms.f[1 + address_registers.x];
    reg_tmp3 = max(uniforms.f[0].xxxx, reg_tmp2);
    reg_tmp2 = min(uniforms.f[0].zzzz, reg_tmp3);
    reg_tmp13 = reg_tmp2;
    {
        sub_9();
    }
    {
        sub_18();
    }
    return true;
}
bool sub_2() {
    reg_tmp4.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_3() {
    reg_tmp4.x = rsq_s(reg_tmp4.x);
    return false;
}
bool sub_4() {
    reg_tmp5.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_5() {
    reg_tmp5.x = rsq_s(reg_tmp5.x);
    return false;
}
bool sub_6() {
    reg_tmp4.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_7() {
    reg_tmp4.x = rsq_s(reg_tmp4.x);
    return false;
}
// reference: E006E3BA57FAC53F, 2E8C44D06926572F
// program: 2E8C44D06926572F, 13A54CCD8AA1DDA2, 67619795CF293FFC
// reference: 124A538AB990B6D8, 44CE3A13C1B65B01
// program: 44CE3A13C1B65B01, 13A54CCD8AA1DDA2, B6B08DE01E86DE2D
// reference: 15D7A4B5E94EEB81, BE1CA71D0DC7876E
// program: BE1CA71D0DC7876E, 13A54CCD8AA1DDA2, B6B08DE01E86DE2D
// reference: 1793BA63BC7444D0, 888358E3BB131C20
// shader: 8B30, 7574BC53E28D25B1
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb) * (texcolor0.rgb) + (rounded_primary_color.rgb) * (vec3(1.0) - (texcolor0.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.r) + (texcolor1.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = (last_tex_env_out.rgb);
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) - (const_color[1].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: BDC03991ADBFECD6, 7574BC53E28D25B1
// program: 888358E3BB131C20, 0D30074279C2FEED, 7574BC53E28D25B1
// shader: 8B30, EBC0728EE28D25B1
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24
struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb) * (texcolor0.rgb) + (rounded_primary_color.rgb) * (vec3(1.0) - (texcolor0.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.r) * (texcolor1.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = (last_tex_env_out.rgb);
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) - (const_color[1].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 2A2C6042ADBFECD6, EBC0728EE28D25B1
// program: 888358E3BB131C20, 0D30074279C2FEED, EBC0728EE28D25B1
// program: 44CE3A13C1B65B01, 13A54CCD8AA1DDA2, 67619795CF293FFC
// program: 888358E3BB131C20, 0D30074279C2FEED, 0B042F8EEE02D2C1
// program: 888358E3BB131C20, 0D30074279C2FEED, 9A1CC78472C59443
// program: 888358E3BB131C20, 0D30074279C2FEED, 1F5276138FD31E21
// program: AC6AA2648888417C, 1C4CBC8096EA16CD, E14C2D25B88214CA
// program: AC6AA2648888417C, 1C4CBC8096EA16CD, 4F5D3D8CAE07D74A
// program: AC6AA2648888417C, 1C4CBC8096EA16CD, 543EDD4084880F4A
// program: AC6AA2648888417C, 1C4CBC8096EA16CD, 01C79519B7CF99E4
// reference: 59C745233F8122A2, 888358E3BB131C20
// program: 888358E3BB131C20, 0D30074279C2FEED, A8B0E6AADB116311
// program: AC6AA2648888417C, 1C4CBC8096EA16CD, 66D12121A97B66A8
// program: AC6AA2648888417C, 1C4CBC8096EA16CD, FE7D3792AF1B69C9
// program: 888358E3BB131C20, 0D30074279C2FEED, CAF7DC684B0E0EEA
// program: 888358E3BB131C20, 0D30074279C2FEED, 52807296CDCEF34A
// shader: 8B31, 1A354F3835595589

#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define mul_3(x, y) mix(x * y, vec3(0.0), isnan(x * y))
#define fma_s(x, y, z) (mul_s(x, y) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(mul_3(x, y), vec3(1.0))

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location = 0) in vec4 vs_in_reg0;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;
out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_2();
bool sub_3();
bool sub_4();
bool sub_5();
bool sub_7();
bool sub_8();
bool sub_14();
bool sub_15();
bool sub_16();
bool sub_17();
bool sub_19();
bool sub_21();
bool sub_22();
bool sub_23();
bool sub_24();
bool sub_25();
bool sub_26();
bool sub_27();
bool sub_28();
bool sub_29();
bool sub_30();
bool sub_31();
bool sub_32();
bool sub_9();
bool sub_10();
bool sub_11();
bool sub_12();
bool sub_13();
bool sub_18();
bool sub_20();
bool sub_0();
bool sub_1();
bool sub_6();

bool exec_shader() {
    sub_0();
    return true;
}

bool sub_2() {
    reg_tmp1.xyz = (uniforms.f[93].xxyx).xyz;
    reg_tmp8.x = dot_3(uniforms.f[0].xyz, reg_tmp12.xyz);
    reg_tmp8.y = dot_3(uniforms.f[1].xyz, reg_tmp12.xyz);
    reg_tmp8.z = dot_3(uniforms.f[2].xyz, reg_tmp12.xyz);
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp8.xyz);
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp8.xyz);
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp8.xyz);
    reg_tmp14.w = (uniforms.f[93].xxxx).w;
    reg_tmp8 = reg_tmp14;
    reg_tmp14.x = dot_s(reg_tmp8, reg_tmp8);
    reg_tmp14.x = rsq_s(reg_tmp14.x);
    reg_tmp14 = mul_s(reg_tmp8, reg_tmp14.xxxx);
    reg_tmp0 = uniforms.f[23];
    reg_tmp8.x = dot_3(uniforms.f[0].xyz, reg_tmp0.xyz);
    reg_tmp8.y = dot_3(uniforms.f[1].xyz, reg_tmp0.xyz);
    reg_tmp8.z = dot_3(uniforms.f[2].xyz, reg_tmp0.xyz);
    reg_tmp6.x = dot_3(uniforms.f[90].xyz, reg_tmp8.xyz);
    reg_tmp6.y = dot_3(uniforms.f[91].xyz, reg_tmp8.xyz);
    reg_tmp6.z = dot_3(uniforms.f[92].xyz, reg_tmp8.xyz);
    reg_tmp8.xyz = (reg_tmp6.xyzz + reg_tmp1.xyzz).xyz;
    reg_tmp8.w = (uniforms.f[93].xxxx).w;
    reg_tmp0.x = dot_s(reg_tmp8, reg_tmp8);
    reg_tmp0.x = rsq_s(reg_tmp0.x);
    reg_tmp0 = mul_s(reg_tmp8, reg_tmp0.xxxx);
    if (uniforms.b[5]) {
        sub_3();
    }
    if (uniforms.b[3]) {
        sub_4();
    }
    if (uniforms.b[4]) {
        sub_5();
    }
    vs_out_attr3 = reg_tmp2;
    return false;
}
bool sub_3() {
    reg_tmp8.x = dot_3(reg_tmp14.xyz, -reg_tmp6.xyz);
    reg_tmp8.y = dot_3(reg_tmp1.xyz, -reg_tmp6.xyz);
    reg_tmp8 = max(uniforms.f[93].xxxx, reg_tmp8);
    reg_tmp8.y = (mul_s(uniforms.f[94].zzzz, reg_tmp8.yyyy)).y;
    reg_tmp8.y = (uniforms.f[94].zzzz + reg_tmp8.yyyy).y;
    reg_tmp2.y = (mul_s(reg_tmp8.xxxx, reg_tmp8.yyyy)).y;
    return false;
}
bool sub_4() {
    reg_tmp9.z = dot_3(reg_tmp14.xyz, reg_tmp0.xyz);
    reg_tmp9.z = (max(uniforms.f[93].xxxx, reg_tmp9.zzzz)).z;
    reg_tmp9.z = (min(uniforms.f[93].yyyy, reg_tmp9.zzzz)).z;
    reg_tmp9.z = log2(reg_tmp9.z);
    reg_tmp9.z = (mul_s(uniforms.f[22].zzzz, reg_tmp9.zzzz)).z;
    reg_tmp9.z = exp2(reg_tmp9.z);
    reg_tmp2.z = (mul_s(uniforms.f[22].wwww, reg_tmp9.zzzz)).z;
    return false;
}
bool sub_5() {
    reg_tmp9.x = dot_3(reg_tmp14.xyz, reg_tmp1.xyz);
    reg_tmp9.x = (max(uniforms.f[93].xxxx, reg_tmp9.xxxx)).x;
    reg_tmp9.x = (min(uniforms.f[93].yyyy, reg_tmp9.xxxx)).x;
    reg_tmp9.x = (uniforms.f[93].yyyy + -reg_tmp9.xxxx).x;
    reg_tmp9.x = log2(reg_tmp9.x);
    reg_tmp9.x = (mul_s(uniforms.f[22].xxxx, reg_tmp9.xxxx)).x;
    reg_tmp9.x = exp2(reg_tmp9.x);
    reg_tmp2.w = (mul_s(uniforms.f[22].yyyy, reg_tmp9.xxxx)).w;
    return false;
}
bool sub_7() {
    reg_tmp0.xy = (uniforms.f[10].xxxx).xy;
    if (uniforms.b[9]) {
        sub_8();
    } else {
        sub_14();
    }
    return false;
}
bool sub_8() {
    {
        sub_9();
    }
    reg_tmp3.x = dot_s(uniforms.f[11].xywz, reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[12].xywz, reg_tmp6);
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_14() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_15();
    } else {
        sub_16();
    }
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_15() {
    reg_tmp6 = reg_tmp10;
    reg_tmp3.x = dot_s(uniforms.f[11], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[12], reg_tmp6);
    reg_tmp3.z = dot_s(uniforms.f[13], reg_tmp6);
    reg_tmp0.xy = (mul_s(uniforms.f[19].xyyy, reg_tmp3.zzzz)).xy;
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_16() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_17();
    } else {
        sub_19();
    }
    return false;
}
bool sub_17() {
    {
        sub_18();
    }
    reg_tmp3.x = dot_3(uniforms.f[11].xyz, reg_tmp6.xyz);
    reg_tmp3.y = dot_3(uniforms.f[12].xyz, reg_tmp6.xyz);
    reg_tmp3.z = dot_3(uniforms.f[13].xyz, reg_tmp6.xyz);
    return false;
}
bool sub_19() {
    {
        sub_20();
    }
    reg_tmp3.x = dot_s(uniforms.f[11], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[12], reg_tmp6);
    return false;
}
bool sub_21() {
    reg_tmp0.xy = (uniforms.f[10].yyyy).xy;
    if (uniforms.b[10]) {
        sub_22();
    } else {
        sub_23();
    }
    return false;
}
bool sub_22() {
    {
        sub_9();
    }
    reg_tmp4.x = dot_s(uniforms.f[14].xywz, reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[15].xywz, reg_tmp6);
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_23() {
    if (uniforms.b[13]) {
        sub_24();
    } else {
        sub_27();
    }
    return false;
}
bool sub_24() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_25();
    } else {
        sub_26();
    }
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_25() {
    reg_tmp6 = reg_tmp10;
    reg_tmp4.x = dot_s(uniforms.f[14], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[15], reg_tmp6);
    reg_tmp4.z = dot_s(uniforms.f[16], reg_tmp6);
    reg_tmp6.w = rcp_s(reg_tmp4.z);
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    reg_tmp4.xy = (uniforms.f[19].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_26() {
    {
        sub_20();
    }
    reg_tmp4.x = dot_s(uniforms.f[14], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[15], reg_tmp6);
    return false;
}
bool sub_27() {
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_28() {
    reg_tmp0.xy = (uniforms.f[10].zzzz).xy;
    if (uniforms.b[11]) {
        sub_29();
    } else {
        sub_30();
    }
    return false;
}
bool sub_29() {
    {
        sub_9();
    }
    reg_tmp5.x = dot_s(uniforms.f[17].xywz, reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[18].xywz, reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_30() {
    if (uniforms.b[14]) {
        sub_31();
    } else {
        sub_32();
    }
    return false;
}
bool sub_31() {
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    {
        sub_20();
    }
    reg_tmp5.x = dot_s(uniforms.f[17], reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[18], reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_32() {
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
bool sub_9() {
    conditional_code = equal(uniforms.f[93].yz, reg_tmp0.xy);
    if (all(not(conditional_code))) {
        sub_10();
    } else {
        sub_11();
    }
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_10() {
    reg_tmp6.xy = (mul_s(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
    return false;
}
bool sub_11() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_12();
    } else {
        sub_13();
    }
    return false;
}
bool sub_12() {
    reg_tmp6.xy = (mul_s(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
    return false;
}
bool sub_13() {
    reg_tmp6.xy = (mul_s(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
    return false;
}
bool sub_18() {
    reg_tmp2 = -reg_tmp15;
    reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
    reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_20() {
    reg_tmp1.xy = (uniforms.f[94].zzzz).xy;
    reg_tmp1.zw = (uniforms.f[93].xxxx).zw;
    reg_tmp6 = fma_s(reg_tmp14, reg_tmp1, reg_tmp1);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_0() {
    reg_tmp0 = vs_in_reg0;
    reg_tmp0.z = (uniforms.f[93].xxxx).z;
    reg_tmp0.w = (uniforms.f[93].yyyy).w;
    vs_out_attr0 = reg_tmp0;
    vs_out_attr2 = reg_tmp0;
    vs_out_attr1 = reg_tmp0;
    if (uniforms.b[6]) {
        sub_1();
    } else {
        sub_6();
    }
    {
        sub_7();
    }
    {
        sub_21();
    }
    {
        sub_28();
    }
    return true;
}
bool sub_1() {
    {
        sub_2();
    }
    return false;
}
bool sub_6() {
    vs_out_attr3 = uniforms.f[93].yyyy;
    return false;
}
// reference: D2E2F111D9255D4E, 1A354F3835595589
// program: 1A354F3835595589, 0D30074279C2FEED, 4F0C86E8EDDB4D45
// program: 888358E3BB131C20, 0D30074279C2FEED, BE3540B3D7A2029D
// program: AC6AA2648888417C, 1C4CBC8096EA16CD, F7CE14589569CE00
// program: AC6AA2648888417C, 1C4CBC8096EA16CD, EBE52129F4D9ADBD
// program: AC6AA2648888417C, 1C4CBC8096EA16CD, 29DBC75E0C056C08
// program: AC6AA2648888417C, 1C4CBC8096EA16CD, 8FAC176B88F21959
// program: 888358E3BB131C20, 0D30074279C2FEED, F865192BFE939ABB
// program: 888358E3BB131C20, 0D30074279C2FEED, E4AD2884C5B04375
// program: 888358E3BB131C20, 0D30074279C2FEED, D8044A0C153D159B
// program: FE7DE1650A5ACC34, 0D30074279C2FEED, 791B67746515F5BD
// program: 888358E3BB131C20, 0D30074279C2FEED, DBBD969AF0C66F49
// program: 888358E3BB131C20, 0D30074279C2FEED, C3A99FDA1696A8B2
// program: 888358E3BB131C20, 0D30074279C2FEED, 44776903C2844A30
// program: 888358E3BB131C20, 0D30074279C2FEED, EA6884D3FFEAEBB5
// program: 888358E3BB131C20, 0D30074279C2FEED, 61DF23C9A6C975E6
// program: 888358E3BB131C20, 0D30074279C2FEED, B35EFE43E319BB63
// shader: 8B31, 947ED74154D564AF

#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define mul_3(x, y) mix(x * y, vec3(0.0), isnan(x * y))
#define fma_s(x, y, z) (mul_s(x, y) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(mul_3(x, y), vec3(1.0))

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location = 0) in vec4 vs_in_reg0;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_1();
bool sub_15();
bool sub_2();
bool sub_5();
bool sub_6();
bool sub_7();
bool sub_8();
bool sub_9();
bool sub_10();
bool sub_11();
bool sub_12();
bool sub_13();
bool sub_14();
bool sub_0();
bool sub_3();
bool sub_4();

bool exec_shader() {
    sub_0();
    return true;
}

bool sub_1() {
    address_registers.x = (ivec2(vs_in_reg0.zz)).x;
    reg_tmp10 = uniforms.f[0].xxxz;
    reg_tmp10.xy = (vs_in_reg0.xyyy).xy;
    reg_tmp11 = uniforms.f[0].xxxx;
    reg_tmp12 = uniforms.f[0].xxxx;
    reg_tmp13 = uniforms.f[0].zzzz;
    reg_tmp4 = uniforms.f[0].xxxx;
    reg_tmp5 = uniforms.f[0].xxxx;
    return false;
}
bool sub_15() {
    vs_out_attr0 = reg_tmp10;
    reg_tmp13 = mul_s(uniforms.f[82], reg_tmp13);
    vs_out_attr1 = reg_tmp13;
    reg_tmp11.y = (uniforms.f[0].zzzz + -reg_tmp11.yyyy).y;
    reg_tmp12.y = (uniforms.f[0].zzzz + -reg_tmp12.yyyy).y;
    reg_tmp14.y = (uniforms.f[81].wwww).y;
    reg_tmp14.x = (mul_s(uniforms.f[0].wwww, reg_tmp14.yyyy)).x;
    reg_tmp2.x = rcp_s(reg_tmp14.x);
    reg_tmp14.z = (reg_tmp2.xxxx).z;
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp11.xyyy).xy;
    reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    reg_tmp11.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp12.xyyy).xy;
    reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    reg_tmp12.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    vs_out_attr2 = reg_tmp11;
    vs_out_attr3 = reg_tmp12;
    return false;
}
bool sub_2() {
    reg_tmp6.xyz = (-reg_tmp0.xyzz).xyz;
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    reg_tmp7.xyz = vec3(rcp_s(uniforms.f[81].y));
    reg_tmp8.xyz = (fma_s(reg_tmp6.xyzz, reg_tmp7.xyzz, uniforms.f[0].yyyy)).xyz;
    reg_tmp7.xyz = (floor(reg_tmp8.xyzz)).xyz;
    reg_tmp6.xyz = (fma_s(reg_tmp7.xyzz, -uniforms.f[81].yyyy, reg_tmp6.xyzz)).xyz;
    reg_tmp6 = min(uniforms.f[81].xxxx, reg_tmp6);
    reg_tmp6 = max(-uniforms.f[81].xxxx, reg_tmp6);
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp6.xxxx, reg_tmp6.xxxx)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp6.xxxx)).y;
    reg_tmp4.x = (reg_tmp1.xxxx).x;
    reg_tmp5.x = (reg_tmp1.yyyy).x;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp6.yyyy, reg_tmp6.yyyy)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp6.yyyy)).y;
    reg_tmp4.y = (reg_tmp1.xxxx).y;
    reg_tmp5.y = (reg_tmp1.yyyy).y;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp6.zzzz, reg_tmp6.zzzz)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp6.zzzz)).y;
    reg_tmp4.z = (reg_tmp1.xxxx).z;
    reg_tmp5.z = (reg_tmp1.yyyy).z;
    reg_tmp2.x = (mul_s(reg_tmp4.yyyy, reg_tmp5.zzzz)).x;
    reg_tmp2.y = (mul_s(reg_tmp5.yyyy, reg_tmp5.zzzz)).y;
    reg_tmp6.x = (mul_s(reg_tmp4.yyyy, reg_tmp4.zzzz)).x;
    reg_tmp6.y = (reg_tmp5.zzzz).y;
    reg_tmp6.z = (mul_s(-reg_tmp5.yyyy, reg_tmp4.zzzz)).z;
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    reg_tmp7.x = (mul_s(-reg_tmp2.xxxx, reg_tmp4.xxxx)).x;
    reg_tmp7.x = (fma_s(reg_tmp5.yyyy, reg_tmp5.xxxx, reg_tmp7.xxxx)).x;
    reg_tmp7.y = (mul_s(reg_tmp4.zzzz, reg_tmp4.xxxx)).y;
    reg_tmp7.z = (mul_s(reg_tmp2.yyyy, reg_tmp4.xxxx)).z;
    reg_tmp7.z = (fma_s(reg_tmp4.yyyy, reg_tmp5.xxxx, reg_tmp7.zzzz)).z;
    reg_tmp7.w = (uniforms.f[0].xxxx).w;
    reg_tmp8.x = (mul_s(reg_tmp2.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp8.x = (fma_s(reg_tmp5.yyyy, reg_tmp4.xxxx, reg_tmp8.xxxx)).x;
    reg_tmp8.y = (mul_s(-reg_tmp4.zzzz, reg_tmp5.xxxx)).y;
    reg_tmp8.z = (mul_s(-reg_tmp2.yyyy, reg_tmp5.xxxx)).z;
    reg_tmp8.z = (fma_s(reg_tmp4.yyyy, reg_tmp4.xxxx, reg_tmp8.zzzz)).z;
    reg_tmp8.w = (uniforms.f[0].xxxx).w;
    reg_tmp9 = uniforms.f[0].xxxz;
    return false;
}
bool sub_5() {
    reg_tmp2 = uniforms.f[90];
    reg_tmp3 = uniforms.f[91];
    reg_tmp4 = uniforms.f[92];
    reg_tmp5 = uniforms.f[0].xxxz;
    reg_tmp6 = mul_s(uniforms.f[86].xxxx, reg_tmp2);
    reg_tmp6 = fma_s(reg_tmp3, uniforms.f[86].yyyy, reg_tmp6);
    reg_tmp6 = fma_s(reg_tmp4, uniforms.f[86].zzzz, reg_tmp6);
    reg_tmp6 = fma_s(reg_tmp5, uniforms.f[86].wwww, reg_tmp6);
    reg_tmp7 = mul_s(uniforms.f[87].xxxx, reg_tmp2);
    reg_tmp7 = fma_s(reg_tmp3, uniforms.f[87].yyyy, reg_tmp7);
    reg_tmp7 = fma_s(reg_tmp4, uniforms.f[87].zzzz, reg_tmp7);
    reg_tmp7 = fma_s(reg_tmp5, uniforms.f[87].wwww, reg_tmp7);
    reg_tmp8 = mul_s(uniforms.f[88].xxxx, reg_tmp2);
    reg_tmp8 = fma_s(reg_tmp3, uniforms.f[88].yyyy, reg_tmp8);
    reg_tmp8 = fma_s(reg_tmp4, uniforms.f[88].zzzz, reg_tmp8);
    reg_tmp8 = fma_s(reg_tmp5, uniforms.f[88].wwww, reg_tmp8);
    reg_tmp9 = mul_s(uniforms.f[89].xxxx, reg_tmp2);
    reg_tmp9 = fma_s(reg_tmp3, uniforms.f[89].yyyy, reg_tmp9);
    reg_tmp9 = fma_s(reg_tmp4, uniforms.f[89].zzzz, reg_tmp9);
    reg_tmp9 = fma_s(reg_tmp5, uniforms.f[89].wwww, reg_tmp9);
    return false;
}
bool sub_6() {
    reg_tmp2.x = rcp_s(uniforms.f[81].y);
    reg_tmp2.xy = (mul_s(uniforms.f[2 + address_registers.x].zwww, reg_tmp2.xxxx)).xy;
    reg_tmp2.xy = (uniforms.f[0].yyyy + reg_tmp2.xyyy).xy;
    reg_tmp3.xy = (floor(reg_tmp2.xyyy)).xy;
    reg_tmp2.xy = (mul_s(uniforms.f[81].yyyy, reg_tmp3.xyyy)).xy;
    reg_tmp2.xy = (uniforms.f[2 + address_registers.x].zwww + -reg_tmp2.xyyy).xy;
    reg_tmp0.xy = (min(uniforms.f[81].xxxx, -reg_tmp2.xyyy)).xy;
    reg_tmp0.xy = (max(-uniforms.f[81].xxxx, reg_tmp0.xyyy)).xy;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp0.xxxx, reg_tmp0.xxxx)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.xxxx)).y;
    reg_tmp5.x = (uniforms.f[5 + address_registers.x].wwww).x;
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_7();
    }
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_8();
    }
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_9();
    }
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_10();
    }
    reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    reg_tmp4.z = (uniforms.f[83].xxxx).z;
    reg_tmp4.w = (-uniforms.f[83].yyyy).w;
    reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[3 + address_registers.x].xyyy)).xy;
    reg_tmp4.z = (-uniforms.f[3 + address_registers.x].zzzz).z;
    reg_tmp4.w = (-uniforms.f[3 + address_registers.x].wwww).w;
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    reg_tmp11.xy = (reg_tmp5.xyyy).xy;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp0.yyyy, reg_tmp0.yyyy)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.yyyy)).y;
    reg_tmp5.x = (uniforms.f[6 + address_registers.x].wwww).x;
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_11();
    }
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_12();
    }
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_13();
    }
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_14();
    }
    reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    reg_tmp4.z = (uniforms.f[83].zzzz).z;
    reg_tmp4.w = (-uniforms.f[83].wwww).w;
    reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[4 + address_registers.x].xyyy)).xy;
    reg_tmp4.z = (-uniforms.f[4 + address_registers.x].zzzz).z;
    reg_tmp4.w = (-uniforms.f[4 + address_registers.x].wwww).w;
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    reg_tmp12.xy = (reg_tmp5.xyyy).xy;
    return false;
}
bool sub_7() {
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_8() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_9() {
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_10() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_11() {
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_12() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_13() {
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_14() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_0() {
    {
        sub_1();
    }
    reg_tmp10.xy = (uniforms.f[84].xyyy + reg_tmp10.xyyy).xy;
    reg_tmp10.xy = (mul_s(uniforms.f[2 + address_registers.x].xyyy, reg_tmp10.xyyy)).xy;
    reg_tmp14 = reg_tmp10;
    reg_tmp0 = uniforms.f[7 + address_registers.x];
    {
        sub_2();
    }
    reg_tmp10.x = dot_s(reg_tmp14, reg_tmp6);
    reg_tmp10.y = dot_s(reg_tmp14, reg_tmp7);
    reg_tmp10.z = dot_s(reg_tmp14, reg_tmp8);
    reg_tmp10.w = dot_s(reg_tmp14, reg_tmp9);
    reg_tmp6 = uniforms.f[8 + address_registers.x];
    reg_tmp7 = uniforms.f[9 + address_registers.x];
    reg_tmp8 = uniforms.f[10 + address_registers.x];
    reg_tmp9 = uniforms.f[0].xxxz;
    reg_tmp6.w = (uniforms.f[5 + address_registers.x].xxxx).w;
    reg_tmp7.w = (uniforms.f[5 + address_registers.x].yyyy).w;
    reg_tmp8.w = (uniforms.f[5 + address_registers.x].zzzz).w;
    reg_tmp2.x = dot_s(reg_tmp10, reg_tmp6);
    reg_tmp2.y = dot_s(reg_tmp10, reg_tmp7);
    reg_tmp2.z = dot_s(reg_tmp10, reg_tmp8);
    reg_tmp2.w = dot_s(reg_tmp10, reg_tmp9);
    reg_tmp10 = reg_tmp2;
    reg_tmp3.xyz = (uniforms.f[5 + address_registers.x].xyzz).xyz;
    reg_tmp3.xyz = (uniforms.f[85].xyzz + -reg_tmp3.xyzz).xyz;
    reg_tmp4.x = dot_3(reg_tmp3.xyz, reg_tmp3.xyz);
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
    if (conditional_code.x) {
        sub_3();
    } else {
        sub_4();
    }
    reg_tmp3.xyz = (mul_s(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
    reg_tmp10.xyz = (fma_s(reg_tmp3.xyzz, uniforms.f[84].zzzz, reg_tmp10.xyzz)).xyz;
    {
        sub_5();
    }
    reg_tmp2 = reg_tmp10;
    reg_tmp10.x = dot_s(reg_tmp2, reg_tmp6);
    reg_tmp10.y = dot_s(reg_tmp2, reg_tmp7);
    reg_tmp10.z = dot_s(reg_tmp2, reg_tmp8);
    reg_tmp10.w = dot_s(reg_tmp2, reg_tmp9);
    reg_tmp2 = uniforms.f[1 + address_registers.x];
    reg_tmp3 = max(uniforms.f[0].xxxx, reg_tmp2);
    reg_tmp2 = min(uniforms.f[0].zzzz, reg_tmp3);
    reg_tmp13 = reg_tmp2;
    {
        sub_6();
    }
    {
        sub_15();
    }
    return true;
}
bool sub_3() {
    reg_tmp4.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_4() {
    reg_tmp4.x = rsq_s(reg_tmp4.x);
    return false;
}
// reference: 9E14AD0858904465, 947ED74154D564AF
// program: 947ED74154D564AF, 13A54CCD8AA1DDA2, B6B08DE0C83FF4C8
// program: AC6AA2648888417C, 1C4CBC8096EA16CD, 4513080BBAB785A8
// shader: 8B31, 41E479466D7D2696

#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define mul_3(x, y) mix(x * y, vec3(0.0), isnan(x * y))
#define fma_s(x, y, z) (mul_s(x, y) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(mul_3(x, y), vec3(1.0))

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location = 0) in vec4 vs_in_reg0;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;
out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_2();
bool sub_1();
bool sub_3();
bool sub_4();
bool sub_0();

bool exec_shader() {
    sub_0();
    return true;
}

bool sub_2() {
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    return false;
}
bool sub_1() {
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    reg_tmp7 = uniforms.f[93].xxxx;
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    {
        sub_2();
    }
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    {
        sub_2();
    }
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    if (conditional_code.x) {
        sub_2();
    }
    if (uniforms.b[11]) {
        sub_3();
    }
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    reg_tmp10 = reg_tmp7;
    reg_tmp6.y = (-uniforms.f[83].wwww + reg_tmp10.yyyy).y;
    reg_tmp9.xyz = (uniforms.f[83].xyzz).xyz;
    reg_tmp7.x = dot_s(reg_tmp9.xyzz, reg_tmp9.xyzz);
    reg_tmp7.x = rsq_s(reg_tmp7.x);
    reg_tmp7.xyz = (mul_s(reg_tmp9.xyzz, reg_tmp7.xxxx)).xyz;
    reg_tmp8.y = rcp_s(-reg_tmp7.y);
    reg_tmp8.y = (mul_s(reg_tmp6.yyyy, reg_tmp8.yyyy)).y;
    reg_tmp7.xyz = (mul_s(reg_tmp7.xyzz, reg_tmp8.yyyy)).xyz;
    reg_tmp10.xyz = (reg_tmp10.xyzz + reg_tmp7.xyzz).xyz;
    reg_tmp10.y = (uniforms.f[94].xxxx + reg_tmp10.yyyy).y;
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    vs_out_attr1 = uniforms.f[93].xxxx;
    vs_out_attr2 = reg_tmp15;
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    if (all(conditional_code)) {
        sub_4();
    }
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_3() {
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    if (conditional_code.y) {
        sub_2();
    }
    return false;
}
bool sub_4() {
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_0() {
    {
        sub_1();
    }
    vs_out_attr4 = uniforms.f[93].xxxx;
    vs_out_attr5 = uniforms.f[93].xxxx;
    vs_out_attr6 = uniforms.f[93].xxxx;
    vs_out_attr3 = uniforms.f[93].yyyy;
    return true;
}
// reference: B4A0054E144AC6B8, 41E479466D7D2696
// program: 41E479466D7D2696, 0D30074279C2FEED, 5C810B10151A2528
// shader: 8B31, 5B96D5C12ECE564C

#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define mul_3(x, y) mix(x * y, vec3(0.0), isnan(x * y))
#define fma_s(x, y, z) (mul_s(x, y) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(mul_3(x, y), vec3(1.0))

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;
out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_2();
bool sub_5();
bool sub_6();
bool sub_7();
bool sub_8();
bool sub_9();
bool sub_0();
bool sub_1();
bool sub_3();
bool sub_4();

bool exec_shader() {
    sub_0();
    return true;
}

bool sub_2() {
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    reg_tmp4.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_5() {
    conditional_code = equal(uniforms.f[93].yz, reg_tmp0.xy);
    if (all(not(conditional_code))) {
        sub_6();
    } else {
        sub_7();
    }
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_6() {
    reg_tmp6.xy = (vs_in_reg4.xyyy).xy;
    return false;
}
bool sub_7() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_8();
    } else {
        sub_9();
    }
    return false;
}
bool sub_8() {
    reg_tmp6.xy = (vs_in_reg5.xyyy).xy;
    return false;
}
bool sub_9() {
    reg_tmp6.xy = (vs_in_reg6.xyyy).xy;
    return false;
}
bool sub_0() {
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    if (uniforms.b[0]) {
        sub_1();
    } else {
        sub_3();
    }
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    if (all(conditional_code)) {
        sub_4();
    }
    vs_out_attr0 = reg_tmp0;
    vs_out_attr1 = uniforms.f[93].xxxx;
    vs_out_attr2 = uniforms.f[93].xxxx;
    reg_tmp0 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
    vs_out_attr3 = uniforms.f[94].zzzz + reg_tmp0;
    reg_tmp5.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    reg_tmp5.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    reg_tmp5.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    reg_tmp4.x = dot_s(reg_tmp5.xyzz, reg_tmp5.xyzz);
    reg_tmp4.x = rsq_s(reg_tmp4.x);
    reg_tmp4.xyz = (mul_s(reg_tmp5.xyzz, reg_tmp4.xxxx)).xyz;
    reg_tmp4 = mul_s(uniforms.f[94].xxxx, reg_tmp4);
    reg_tmp12 = uniforms.f[94].xxxx + reg_tmp4;
    vs_out_attr4 = reg_tmp12;
    reg_tmp0.xy = (uniforms.f[0].xxxx).xy;
    {
        sub_5();
    }
    reg_tmp4.x = dot_s(uniforms.f[4].xywz, reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5].xywz, reg_tmp6);
    vs_out_attr5 = reg_tmp4;
    vs_out_attr6 = reg_tmp4;
    return true;
}
bool sub_1() {
    reg_tmp7 = uniforms.f[93].xxxx;
    reg_tmp12 = uniforms.f[93].xxxx;
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    {
        sub_2();
    }
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    {
        sub_2();
    }
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    if (conditional_code.x) {
        sub_2();
    }
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    if (conditional_code.y) {
        sub_2();
    }
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    reg_tmp10 = reg_tmp7;
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    return false;
}
bool sub_3() {
    reg_tmp7 = reg_tmp15;
    reg_tmp10.x = dot_s(uniforms.f[10], reg_tmp7);
    reg_tmp10.y = dot_s(uniforms.f[11], reg_tmp7);
    reg_tmp10.z = dot_s(uniforms.f[12], reg_tmp7);
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    reg_tmp12.x = dot_s(uniforms.f[10], reg_tmp14);
    reg_tmp12.y = dot_s(uniforms.f[11], reg_tmp14);
    reg_tmp12.z = dot_s(uniforms.f[12], reg_tmp14);
    return false;
}
bool sub_4() {
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
// reference: 86F3078E42C633DD, 5B96D5C12ECE564C
// program: 5B96D5C12ECE564C, 0D30074279C2FEED, 36A2BF4DC040E4A7
// shader: 8B31, 6646015FB9778410

#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define mul_3(x, y) mix(x * y, vec3(0.0), isnan(x * y))
#define fma_s(x, y, z) (mul_s(x, y) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(mul_3(x, y), vec3(1.0))

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;
out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_11();
bool sub_9();
bool sub_3();
bool sub_5();
bool sub_2();
bool sub_4();
bool sub_6();
bool sub_8();
bool sub_10();
bool sub_12();
bool sub_19();
bool sub_20();
bool sub_26();
bool sub_27();
bool sub_28();
bool sub_29();
bool sub_31();
bool sub_33();
bool sub_34();
bool sub_35();
bool sub_36();
bool sub_37();
bool sub_38();
bool sub_39();
bool sub_40();
bool sub_41();
bool sub_42();
bool sub_43();
bool sub_44();
bool sub_21();
bool sub_22();
bool sub_23();
bool sub_24();
bool sub_25();
bool sub_30();
bool sub_32();
bool sub_14();
bool sub_15();
bool sub_16();
bool sub_17();
bool sub_0();
bool sub_1();
bool sub_7();
bool sub_13();
bool sub_18();

bool exec_shader() {
    sub_0();
    return true;
}

bool sub_11() {
    uint jmp_to = 0u;
    while (true) {
        switch (jmp_to) {
        case 0u: {
            reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
            reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
            reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
            reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
            reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
            reg_tmp6.x = rsq_s(reg_tmp6.x);
            reg_tmp7.x = rsq_s(reg_tmp7.x);
            reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            reg_tmp0 = uniforms.f[93].yxxx;
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            reg_tmp4 = mul_s(uniforms.f[94].xxxx, reg_tmp4);
            conditional_code = greaterThanEqual(uniforms.f[93].xx, reg_tmp4.xx);
            reg_tmp4 = vec4(rsq_s(reg_tmp4.x));
            reg_tmp5 = mul_s(uniforms.f[94].xxxx, reg_tmp14);
            if (conditional_code.x) {
                { jmp_to = 18u; break; }
            }
            reg_tmp0.z = rcp_s(reg_tmp4.x);
            reg_tmp0.xy = (mul_s(reg_tmp5, reg_tmp4)).xy;
        }
        case 18u: {
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_9() {
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    reg_tmp4.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_3() {
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    reg_tmp3.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp3.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp3.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp12);
    reg_tmp3.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp13.xyz);
    reg_tmp3.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp13.xyz);
    reg_tmp3.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp13.xyz);
    reg_tmp11 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp11);
    reg_tmp3.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp5.xyz);
    reg_tmp3.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp5.xyz);
    reg_tmp3.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp5.xyz);
    reg_tmp9 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp9);
    reg_tmp3.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp6.xyz);
    reg_tmp3.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp6.xyz);
    reg_tmp3.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp6.xyz);
    reg_tmp8 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp8);
    return false;
}
bool sub_5() {
    reg_tmp0.xyz = (mul_s(reg_tmp9.yzxx, reg_tmp8.zxyy)).xyz;
    reg_tmp0.xyz = (fma_s(-reg_tmp8.yzxx, reg_tmp9.zxyy, reg_tmp0)).xyz;
    reg_tmp1 = uniforms.f[83];
    reg_tmp2.x = dot_s(reg_tmp1.xyzz, reg_tmp1.xyzz);
    reg_tmp2.x = rsq_s(reg_tmp2.x);
    reg_tmp2.xyz = (mul_s(reg_tmp1.xyzz, reg_tmp2.xxxx)).xyz;
    reg_tmp1.x = dot_3(reg_tmp2.xyz, reg_tmp8.xyz);
    reg_tmp1.y = dot_3(reg_tmp2.xyz, reg_tmp0.xyz);
    reg_tmp1.z = dot_3(reg_tmp2.xyz, reg_tmp9.xyz);
    reg_tmp2.x = dot_s(reg_tmp1.xyzz, reg_tmp1.xyzz);
    reg_tmp2.x = rsq_s(reg_tmp2.x);
    reg_tmp2.xyz = (mul_s(reg_tmp1.xyzz, reg_tmp2.xxxx)).xyz;
    reg_tmp2.w = (uniforms.f[93].yyyy).w;
    vs_out_attr2 = reg_tmp2;
    return false;
}
bool sub_2() {
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    reg_tmp13.xyz = (vs_in_reg2).xyz;
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    reg_tmp5 = uniforms.f[93].xxyy;
    reg_tmp6 = uniforms.f[93].yxxy;
    reg_tmp7 = uniforms.f[93].xxxx;
    reg_tmp12 = uniforms.f[93].xxxx;
    reg_tmp11 = uniforms.f[93].xxxx;
    reg_tmp9 = uniforms.f[93].xxxx;
    reg_tmp8 = uniforms.f[93].xxxx;
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    {
        sub_3();
    }
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    {
        sub_3();
    }
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    if (conditional_code.x) {
        sub_3();
    }
    if (uniforms.b[11]) {
        sub_4();
    }
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    reg_tmp10 = reg_tmp7;
    reg_tmp13.x = dot_3(uniforms.f[90].xyz, reg_tmp11.xyz);
    reg_tmp13.y = dot_3(uniforms.f[91].xyz, reg_tmp11.xyz);
    reg_tmp13.z = dot_3(uniforms.f[92].xyz, reg_tmp11.xyz);
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    {
        sub_5();
    }
    vs_out_attr1 = uniforms.f[93].xxxy;
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    if (all(conditional_code)) {
        sub_6();
    }
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_4() {
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    if (conditional_code.y) {
        sub_3();
    }
    return false;
}
bool sub_6() {
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_8() {
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    reg_tmp7 = uniforms.f[93].xxxx;
    reg_tmp12 = uniforms.f[93].xxxx;
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    {
        sub_9();
    }
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    {
        sub_9();
    }
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    if (conditional_code.x) {
        sub_9();
    }
    if (uniforms.b[11]) {
        sub_10();
    }
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    reg_tmp10 = reg_tmp7;
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    {
        sub_11();
    }
    vs_out_attr2 = -reg_tmp15;
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    if (all(conditional_code)) {
        sub_12();
    }
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_10() {
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    if (conditional_code.y) {
        sub_9();
    }
    return false;
}
bool sub_12() {
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_19() {
    reg_tmp0.xy = (uniforms.f[0].xxxx).xy;
    if (uniforms.b[2]) {
        sub_20();
    } else {
        sub_26();
    }
    return false;
}
bool sub_20() {
    {
        sub_21();
    }
    reg_tmp3.x = dot_s(uniforms.f[1].xywz, reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2].xywz, reg_tmp6);
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_26() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_27();
    } else {
        sub_28();
    }
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_27() {
    reg_tmp6 = reg_tmp10;
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    reg_tmp3.z = dot_s(uniforms.f[3], reg_tmp6);
    reg_tmp0.xy = (mul_s(uniforms.f[9].xyyy, reg_tmp3.zzzz)).xy;
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_28() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_29();
    } else {
        sub_31();
    }
    return false;
}
bool sub_29() {
    {
        sub_30();
    }
    reg_tmp3.x = dot_3(uniforms.f[1].xyz, reg_tmp6.xyz);
    reg_tmp3.y = dot_3(uniforms.f[2].xyz, reg_tmp6.xyz);
    reg_tmp3.z = dot_3(uniforms.f[3].xyz, reg_tmp6.xyz);
    return false;
}
bool sub_31() {
    {
        sub_32();
    }
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    return false;
}
bool sub_33() {
    reg_tmp0.xy = (uniforms.f[0].yyyy).xy;
    if (uniforms.b[3]) {
        sub_34();
    } else {
        sub_35();
    }
    return false;
}
bool sub_34() {
    {
        sub_21();
    }
    reg_tmp4.x = dot_s(uniforms.f[4].xywz, reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5].xywz, reg_tmp6);
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_35() {
    if (uniforms.b[5]) {
        sub_36();
    } else {
        sub_39();
    }
    return false;
}
bool sub_36() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_37();
    } else {
        sub_38();
    }
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_37() {
    reg_tmp6 = reg_tmp10;
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    reg_tmp4.z = dot_s(uniforms.f[6], reg_tmp6);
    reg_tmp6.w = rcp_s(reg_tmp4.z);
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    reg_tmp4.xy = (uniforms.f[9].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_38() {
    {
        sub_32();
    }
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    return false;
}
bool sub_39() {
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_40() {
    reg_tmp0.xy = (uniforms.f[0].zzzz).xy;
    if (uniforms.b[4]) {
        sub_41();
    } else {
        sub_42();
    }
    return false;
}
bool sub_41() {
    {
        sub_21();
    }
    reg_tmp5.x = dot_s(uniforms.f[7].xywz, reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8].xywz, reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_42() {
    if (uniforms.b[6]) {
        sub_43();
    } else {
        sub_44();
    }
    return false;
}
bool sub_43() {
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    {
        sub_32();
    }
    reg_tmp5.x = dot_s(uniforms.f[7], reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8], reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_44() {
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
bool sub_21() {
    conditional_code = equal(uniforms.f[93].yz, reg_tmp0.xy);
    if (all(not(conditional_code))) {
        sub_22();
    } else {
        sub_23();
    }
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_22() {
    reg_tmp6.xy = (vs_in_reg4.xyyy).xy;
    return false;
}
bool sub_23() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_24();
    } else {
        sub_25();
    }
    return false;
}
bool sub_24() {
    reg_tmp6.xy = (vs_in_reg5.xyyy).xy;
    return false;
}
bool sub_25() {
    reg_tmp6.xy = (vs_in_reg6.xyyy).xy;
    return false;
}
bool sub_30() {
    reg_tmp2 = -reg_tmp15;
    reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
    reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_32() {
    reg_tmp1 = reg_tmp14;
    reg_tmp2.w = dot_3(reg_tmp1.xyz, reg_tmp1.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp1 = mul_s(reg_tmp1, reg_tmp2.wwww);
    reg_tmp1 = mul_s(uniforms.f[94].xxxx, reg_tmp1);
    reg_tmp6.xy = (uniforms.f[94].xxxx + reg_tmp1.xyyy).xy;
    return false;
}
bool sub_14() {
    reg_tmp1.xyz = (uniforms.f[93].xxyx).xyz;
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    reg_tmp14.w = (uniforms.f[93].xxxx).w;
    reg_tmp8 = reg_tmp14;
    reg_tmp14.x = dot_s(reg_tmp8, reg_tmp8);
    reg_tmp14.x = rsq_s(reg_tmp14.x);
    reg_tmp14 = mul_s(reg_tmp8, reg_tmp14.xxxx);
    reg_tmp8 = uniforms.f[83];
    reg_tmp6.x = dot_3(uniforms.f[90].xyz, reg_tmp8.xyz);
    reg_tmp6.y = dot_3(uniforms.f[91].xyz, reg_tmp8.xyz);
    reg_tmp6.z = dot_3(uniforms.f[92].xyz, reg_tmp8.xyz);
    reg_tmp8.xyz = (reg_tmp6.xyzz + reg_tmp1.xyzz).xyz;
    reg_tmp8.w = (uniforms.f[93].xxxx).w;
    reg_tmp0.x = dot_s(reg_tmp8, reg_tmp8);
    reg_tmp0.x = rsq_s(reg_tmp0.x);
    reg_tmp0 = mul_s(reg_tmp8, reg_tmp0.xxxx);
    reg_tmp2 = uniforms.f[93].xxxx;
    if (uniforms.b[9]) {
        sub_15();
    }
    if (uniforms.b[7]) {
        sub_16();
    }
    if (uniforms.b[8]) {
        sub_17();
    }
    vs_out_attr3 = reg_tmp2;
    return false;
}
bool sub_15() {
    reg_tmp8.x = dot_3(reg_tmp14.xyz, -reg_tmp6.xyz);
    reg_tmp8.y = dot_3(reg_tmp1.xyz, -reg_tmp6.xyz);
    reg_tmp8 = max(uniforms.f[93].xxxx, reg_tmp8);
    reg_tmp8.y = (mul_s(uniforms.f[94].xxxx, reg_tmp8.yyyy)).y;
    reg_tmp8.y = (uniforms.f[94].xxxx + reg_tmp8.yyyy).y;
    reg_tmp2.y = (mul_s(reg_tmp8.xxxx, reg_tmp8.yyyy)).y;
    return false;
}
bool sub_16() {
    reg_tmp9.z = dot_3(reg_tmp14.xyz, reg_tmp0.xyz);
    reg_tmp9.z = (max(uniforms.f[93].xxxx, reg_tmp9.zzzz)).z;
    reg_tmp9.z = (min(uniforms.f[93].yyyy, reg_tmp9.zzzz)).z;
    reg_tmp9.z = log2(reg_tmp9.z);
    reg_tmp9.z = (mul_s(uniforms.f[82].zzzz, reg_tmp9.zzzz)).z;
    reg_tmp9.z = exp2(reg_tmp9.z);
    reg_tmp2.z = (mul_s(uniforms.f[82].wwww, reg_tmp9.zzzz)).z;
    return false;
}
bool sub_17() {
    reg_tmp9.x = dot_3(reg_tmp14.xyz, reg_tmp1.xyz);
    reg_tmp9.x = (max(uniforms.f[93].xxxx, reg_tmp9.xxxx)).x;
    reg_tmp9.x = (min(uniforms.f[93].yyyy, reg_tmp9.xxxx)).x;
    reg_tmp9.x = (uniforms.f[93].yyyy + -reg_tmp9.xxxx).x;
    reg_tmp9.x = log2(reg_tmp9.x);
    reg_tmp9.x = (mul_s(uniforms.f[82].xxxx, reg_tmp9.xxxx)).x;
    reg_tmp9.x = exp2(reg_tmp9.x);
    reg_tmp2.w = (mul_s(uniforms.f[82].yyyy, reg_tmp9.xxxx)).w;
    return false;
}
bool sub_0() {
    if (uniforms.b[10]) {
        sub_1();
    } else {
        sub_7();
    }
    if (uniforms.b[1]) {
        sub_13();
    } else {
        sub_18();
    }
    {
        sub_19();
    }
    {
        sub_33();
    }
    {
        sub_40();
    }
    return true;
}
bool sub_1() {
    {
        sub_2();
    }
    return false;
}
bool sub_7() {
    {
        sub_8();
    }
    return false;
}
bool sub_13() {
    {
        sub_14();
    }
    return false;
}
bool sub_18() {
    vs_out_attr3 = uniforms.f[93].yyyy;
    return false;
}
// reference: EF359D59CD2A3511, 6646015FB9778410
// program: 6646015FB9778410, 0D30074279C2FEED, A09BB5E1066E8C4E
// reference: A16162194EDF5363, 6646015FB9778410
// program: 888358E3BB131C20, 0D30074279C2FEED, DC12E218392F9BDB
// program: AC6AA2648888417C, 1C4CBC8096EA16CD, D6B195DAA984D13A
// program: AC6AA2648888417C, 1C4CBC8096EA16CD, 77A77A3265B65D73
// program: AC6AA2648888417C, 1C4CBC8096EA16CD, 695BB514E3AF063F
// shader: 8B31, 4C0FFB8132202FAB

#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define mul_3(x, y) mix(x * y, vec3(0.0), isnan(x * y))
#define fma_s(x, y, z) (mul_s(x, y) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(mul_3(x, y), vec3(1.0))

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location = 0) in vec4 vs_in_reg0;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_1();
bool sub_15();
bool sub_2();
bool sub_5();
bool sub_6();
bool sub_7();
bool sub_8();
bool sub_9();
bool sub_10();
bool sub_11();
bool sub_12();
bool sub_13();
bool sub_14();
bool sub_0();
bool sub_3();
bool sub_4();

bool exec_shader() {
    sub_0();
    return true;
}

bool sub_1() {
    address_registers.x = (ivec2(vs_in_reg0.zz)).x;
    reg_tmp10 = uniforms.f[0].xxxz;
    reg_tmp10.xy = (vs_in_reg0.xyyy).xy;
    reg_tmp11 = uniforms.f[0].xxxx;
    reg_tmp12 = uniforms.f[0].xxxx;
    reg_tmp13 = uniforms.f[0].zzzz;
    reg_tmp4 = uniforms.f[0].xxxx;
    reg_tmp5 = uniforms.f[0].xxxx;
    return false;
}
bool sub_15() {
    vs_out_attr0 = reg_tmp10;
    reg_tmp13 = mul_s(uniforms.f[82], reg_tmp13);
    vs_out_attr1 = reg_tmp13;
    reg_tmp11.y = (uniforms.f[0].zzzz + -reg_tmp11.yyyy).y;
    reg_tmp12.y = (uniforms.f[0].zzzz + -reg_tmp12.yyyy).y;
    reg_tmp14.y = (uniforms.f[81].wwww).y;
    reg_tmp14.x = (mul_s(uniforms.f[0].wwww, reg_tmp14.yyyy)).x;
    reg_tmp2.x = rcp_s(reg_tmp14.x);
    reg_tmp14.z = (reg_tmp2.xxxx).z;
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp11.xyyy).xy;
    reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    reg_tmp11.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp12.xyyy).xy;
    reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    reg_tmp12.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    vs_out_attr2 = reg_tmp11;
    vs_out_attr3 = reg_tmp12;
    return false;
}
bool sub_2() {
    reg_tmp6.x = (uniforms.f[90].xxxx).x;
    reg_tmp6.y = (uniforms.f[91].xxxx).y;
    reg_tmp6.z = (uniforms.f[92].xxxx).z;
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    reg_tmp7.x = (uniforms.f[90].yyyy).x;
    reg_tmp7.y = (uniforms.f[91].yyyy).y;
    reg_tmp7.z = (uniforms.f[92].yyyy).z;
    reg_tmp7.w = (uniforms.f[0].xxxx).w;
    reg_tmp8.x = (uniforms.f[90].zzzz).x;
    reg_tmp8.y = (uniforms.f[91].zzzz).y;
    reg_tmp8.z = (uniforms.f[92].zzzz).z;
    reg_tmp8.w = (uniforms.f[0].xxxx).w;
    reg_tmp9.x = (uniforms.f[90].wwww).x;
    reg_tmp9.y = (uniforms.f[91].wwww).y;
    reg_tmp9.z = (uniforms.f[92].wwww).z;
    reg_tmp9.w = (uniforms.f[0].zzzz).w;
    return false;
}
bool sub_5() {
    reg_tmp2 = uniforms.f[90];
    reg_tmp3 = uniforms.f[91];
    reg_tmp4 = uniforms.f[92];
    reg_tmp5 = uniforms.f[0].xxxz;
    reg_tmp6 = mul_s(uniforms.f[86].xxxx, reg_tmp2);
    reg_tmp6 = fma_s(reg_tmp3, uniforms.f[86].yyyy, reg_tmp6);
    reg_tmp6 = fma_s(reg_tmp4, uniforms.f[86].zzzz, reg_tmp6);
    reg_tmp6 = fma_s(reg_tmp5, uniforms.f[86].wwww, reg_tmp6);
    reg_tmp7 = mul_s(uniforms.f[87].xxxx, reg_tmp2);
    reg_tmp7 = fma_s(reg_tmp3, uniforms.f[87].yyyy, reg_tmp7);
    reg_tmp7 = fma_s(reg_tmp4, uniforms.f[87].zzzz, reg_tmp7);
    reg_tmp7 = fma_s(reg_tmp5, uniforms.f[87].wwww, reg_tmp7);
    reg_tmp8 = mul_s(uniforms.f[88].xxxx, reg_tmp2);
    reg_tmp8 = fma_s(reg_tmp3, uniforms.f[88].yyyy, reg_tmp8);
    reg_tmp8 = fma_s(reg_tmp4, uniforms.f[88].zzzz, reg_tmp8);
    reg_tmp8 = fma_s(reg_tmp5, uniforms.f[88].wwww, reg_tmp8);
    reg_tmp9 = mul_s(uniforms.f[89].xxxx, reg_tmp2);
    reg_tmp9 = fma_s(reg_tmp3, uniforms.f[89].yyyy, reg_tmp9);
    reg_tmp9 = fma_s(reg_tmp4, uniforms.f[89].zzzz, reg_tmp9);
    reg_tmp9 = fma_s(reg_tmp5, uniforms.f[89].wwww, reg_tmp9);
    return false;
}
bool sub_6() {
    reg_tmp2.x = rcp_s(uniforms.f[81].y);
    reg_tmp2.xy = (mul_s(uniforms.f[2 + address_registers.x].zwww, reg_tmp2.xxxx)).xy;
    reg_tmp2.xy = (uniforms.f[0].yyyy + reg_tmp2.xyyy).xy;
    reg_tmp3.xy = (floor(reg_tmp2.xyyy)).xy;
    reg_tmp2.xy = (mul_s(uniforms.f[81].yyyy, reg_tmp3.xyyy)).xy;
    reg_tmp2.xy = (uniforms.f[2 + address_registers.x].zwww + -reg_tmp2.xyyy).xy;
    reg_tmp0.xy = (min(uniforms.f[81].xxxx, -reg_tmp2.xyyy)).xy;
    reg_tmp0.xy = (max(-uniforms.f[81].xxxx, reg_tmp0.xyyy)).xy;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp0.xxxx, reg_tmp0.xxxx)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.xxxx)).y;
    reg_tmp5.x = (uniforms.f[5 + address_registers.x].wwww).x;
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_7();
    }
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_8();
    }
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_9();
    }
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_10();
    }
    reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    reg_tmp4.z = (uniforms.f[83].xxxx).z;
    reg_tmp4.w = (-uniforms.f[83].yyyy).w;
    reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[3 + address_registers.x].xyyy)).xy;
    reg_tmp4.z = (-uniforms.f[3 + address_registers.x].zzzz).z;
    reg_tmp4.w = (-uniforms.f[3 + address_registers.x].wwww).w;
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    reg_tmp11.xy = (reg_tmp5.xyyy).xy;
    reg_tmp2 = uniforms.f[95];
    reg_tmp3 = uniforms.f[94];
    reg_tmp1.z = (mul_s(reg_tmp0.yyyy, reg_tmp0.yyyy)).z;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    reg_tmp2 = uniforms.f[93];
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.yyyy)).y;
    reg_tmp5.x = (uniforms.f[6 + address_registers.x].wwww).x;
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_11();
    }
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_12();
    }
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_13();
    }
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    if (conditional_code.x) {
        sub_14();
    }
    reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    reg_tmp4.z = (uniforms.f[83].zzzz).z;
    reg_tmp4.w = (-uniforms.f[83].wwww).w;
    reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[4 + address_registers.x].xyyy)).xy;
    reg_tmp4.z = (-uniforms.f[4 + address_registers.x].zzzz).z;
    reg_tmp4.w = (-uniforms.f[4 + address_registers.x].wwww).w;
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    reg_tmp12.xy = (reg_tmp5.xyyy).xy;
    return false;
}
bool sub_7() {
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_8() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_9() {
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_10() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_11() {
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_12() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_13() {
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_14() {
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_0() {
    {
        sub_1();
    }
    reg_tmp10.xy = (uniforms.f[84].xyyy + reg_tmp10.xyyy).xy;
    reg_tmp10.xy = (mul_s(uniforms.f[2 + address_registers.x].xyyy, reg_tmp10.xyyy)).xy;
    {
        sub_2();
    }
    reg_tmp2.x = dot_s(reg_tmp10, reg_tmp6);
    reg_tmp2.y = dot_s(reg_tmp10, reg_tmp7);
    reg_tmp2.z = dot_s(reg_tmp10, reg_tmp8);
    reg_tmp2.w = dot_s(uniforms.f[0].xxxz, reg_tmp10);
    reg_tmp3.xyz = (uniforms.f[5 + address_registers.x].xyzz).xyz;
    reg_tmp3.xyz = (uniforms.f[85].xyzz + -reg_tmp3.xyzz).xyz;
    reg_tmp4.x = dot_3(reg_tmp3.xyz, reg_tmp3.xyz);
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
    if (conditional_code.x) {
        sub_3();
    } else {
        sub_4();
    }
    reg_tmp3.xyz = (mul_s(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
    reg_tmp10.xyz = (uniforms.f[5 + address_registers.x].xyzz + reg_tmp2.xyzz).xyz;
    reg_tmp10.xyz = (fma_s(reg_tmp3.xyzz, uniforms.f[84].zzzz, reg_tmp10.xyzz)).xyz;
    {
        sub_5();
    }
    reg_tmp2 = reg_tmp10;
    reg_tmp10.x = dot_s(reg_tmp2, reg_tmp6);
    reg_tmp10.y = dot_s(reg_tmp2, reg_tmp7);
    reg_tmp10.z = dot_s(reg_tmp2, reg_tmp8);
    reg_tmp10.w = dot_s(reg_tmp2, reg_tmp9);
    reg_tmp2 = uniforms.f[1 + address_registers.x];
    reg_tmp3 = max(uniforms.f[0].xxxx, reg_tmp2);
    reg_tmp2 = min(uniforms.f[0].zzzz, reg_tmp3);
    reg_tmp13 = reg_tmp2;
    {
        sub_6();
    }
    {
        sub_15();
    }
    return true;
}
bool sub_3() {
    reg_tmp4.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_4() {
    reg_tmp4.x = rsq_s(reg_tmp4.x);
    return false;
}
// reference: 6590628E5B972684, 4C0FFB8132202FAB
// program: 4C0FFB8132202FAB, 13A54CCD8AA1DDA2, B6B08DE0C83FF4C8
// program: 4C0FFB8132202FAB, 13A54CCD8AA1DDA2, BA3F71487BA61D01
// program: AC6AA2648888417C, 1C4CBC8096EA16CD, FECCDB07121C469A
// program: 5B96D5C12ECE564C, 0D30074279C2FEED, F46A424E601B7C89
// shader: 8B31, CC9BBBC59EE3249E

#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define mul_3(x, y) mix(x * y, vec3(0.0), isnan(x * y))
#define fma_s(x, y, z) (mul_s(x, y) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(mul_3(x, y), vec3(1.0))

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;
out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_5();
bool sub_3();
bool sub_1();
bool sub_2();
bool sub_4();
bool sub_6();
bool sub_7();
bool sub_8();
bool sub_14();
bool sub_15();
bool sub_16();
bool sub_17();
bool sub_19();
bool sub_21();
bool sub_22();
bool sub_23();
bool sub_24();
bool sub_25();
bool sub_26();
bool sub_27();
bool sub_28();
bool sub_29();
bool sub_30();
bool sub_31();
bool sub_32();
bool sub_9();
bool sub_10();
bool sub_11();
bool sub_12();
bool sub_13();
bool sub_18();
bool sub_20();
bool sub_0();

bool exec_shader() {
    sub_0();
    return true;
}

bool sub_5() {
    uint jmp_to = 0u;
    while (true) {
        switch (jmp_to) {
        case 0u: {
            reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
            reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
            reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
            reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
            reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
            reg_tmp6.x = rsq_s(reg_tmp6.x);
            reg_tmp7.x = rsq_s(reg_tmp7.x);
            reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            reg_tmp0 = uniforms.f[93].yxxx;
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            reg_tmp4 = mul_s(uniforms.f[94].xxxx, reg_tmp4);
            conditional_code = greaterThanEqual(uniforms.f[93].xx, reg_tmp4.xx);
            reg_tmp4 = vec4(rsq_s(reg_tmp4.x));
            reg_tmp5 = mul_s(uniforms.f[94].xxxx, reg_tmp14);
            if (conditional_code.x) {
                { jmp_to = 18u; break; }
            }
            reg_tmp0.z = rcp_s(reg_tmp4.x);
            reg_tmp0.xy = (mul_s(reg_tmp5, reg_tmp4)).xy;
        }
        case 18u: {
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_3() {
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    reg_tmp4.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_1() {
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    reg_tmp13.xyz = (vs_in_reg2).xyz;
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    if (uniforms.b[0]) {
        sub_2();
    } else {
        sub_4();
    }
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    {
        sub_5();
    }
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    vs_out_attr2 = -reg_tmp15;
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    if (all(conditional_code)) {
        sub_6();
    }
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_2() {
    reg_tmp7 = uniforms.f[93].xxxx;
    reg_tmp12 = uniforms.f[93].xxxx;
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    {
        sub_3();
    }
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    {
        sub_3();
    }
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    {
        sub_3();
    }
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    {
        sub_3();
    }
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    reg_tmp10 = reg_tmp7;
    return false;
}
bool sub_4() {
    reg_tmp7 = reg_tmp15;
    reg_tmp10.x = dot_s(uniforms.f[10], reg_tmp7);
    reg_tmp10.y = dot_s(uniforms.f[11], reg_tmp7);
    reg_tmp10.z = dot_s(uniforms.f[12], reg_tmp7);
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    reg_tmp12.x = dot_3(uniforms.f[10].xyz, reg_tmp14.xyz);
    reg_tmp12.y = dot_3(uniforms.f[11].xyz, reg_tmp14.xyz);
    reg_tmp12.z = dot_3(uniforms.f[12].xyz, reg_tmp14.xyz);
    return false;
}
bool sub_6() {
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_7() {
    reg_tmp0.xy = (uniforms.f[0].xxxx).xy;
    if (uniforms.b[2]) {
        sub_8();
    } else {
        sub_14();
    }
    return false;
}
bool sub_8() {
    {
        sub_9();
    }
    reg_tmp3.x = dot_s(uniforms.f[1].xywz, reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2].xywz, reg_tmp6);
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_14() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_15();
    } else {
        sub_16();
    }
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_15() {
    reg_tmp6 = reg_tmp10;
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    reg_tmp3.z = dot_s(uniforms.f[3], reg_tmp6);
    reg_tmp0.xy = (mul_s(uniforms.f[9].xyyy, reg_tmp3.zzzz)).xy;
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_16() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_17();
    } else {
        sub_19();
    }
    return false;
}
bool sub_17() {
    {
        sub_18();
    }
    reg_tmp3.x = dot_3(uniforms.f[1].xyz, reg_tmp6.xyz);
    reg_tmp3.y = dot_3(uniforms.f[2].xyz, reg_tmp6.xyz);
    reg_tmp3.z = dot_3(uniforms.f[3].xyz, reg_tmp6.xyz);
    return false;
}
bool sub_19() {
    {
        sub_20();
    }
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    return false;
}
bool sub_21() {
    reg_tmp0.xy = (uniforms.f[0].yyyy).xy;
    if (uniforms.b[3]) {
        sub_22();
    } else {
        sub_23();
    }
    return false;
}
bool sub_22() {
    {
        sub_9();
    }
    reg_tmp4.x = dot_s(uniforms.f[4].xywz, reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5].xywz, reg_tmp6);
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_23() {
    if (uniforms.b[5]) {
        sub_24();
    } else {
        sub_27();
    }
    return false;
}
bool sub_24() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_25();
    } else {
        sub_26();
    }
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_25() {
    reg_tmp6 = reg_tmp10;
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    reg_tmp4.z = dot_s(uniforms.f[6], reg_tmp6);
    reg_tmp6.w = rcp_s(reg_tmp4.z);
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    reg_tmp4.xy = (uniforms.f[9].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_26() {
    {
        sub_20();
    }
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    return false;
}
bool sub_27() {
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_28() {
    reg_tmp0.xy = (uniforms.f[0].zzzz).xy;
    if (uniforms.b[4]) {
        sub_29();
    } else {
        sub_30();
    }
    return false;
}
bool sub_29() {
    {
        sub_9();
    }
    reg_tmp5.x = dot_s(uniforms.f[7].xywz, reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8].xywz, reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_30() {
    if (uniforms.b[6]) {
        sub_31();
    } else {
        sub_32();
    }
    return false;
}
bool sub_31() {
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    {
        sub_20();
    }
    reg_tmp5.x = dot_s(uniforms.f[7], reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8], reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_32() {
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
bool sub_9() {
    conditional_code = equal(uniforms.f[93].yz, reg_tmp0.xy);
    if (all(not(conditional_code))) {
        sub_10();
    } else {
        sub_11();
    }
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_10() {
    reg_tmp6.xy = (vs_in_reg4.xyyy).xy;
    return false;
}
bool sub_11() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_12();
    } else {
        sub_13();
    }
    return false;
}
bool sub_12() {
    reg_tmp6.xy = (vs_in_reg5.xyyy).xy;
    return false;
}
bool sub_13() {
    reg_tmp6.xy = (vs_in_reg6.xyyy).xy;
    return false;
}
bool sub_18() {
    reg_tmp2 = -reg_tmp15;
    reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
    reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_20() {
    reg_tmp1 = reg_tmp14;
    reg_tmp2.w = dot_3(reg_tmp1.xyz, reg_tmp1.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp1 = mul_s(reg_tmp1, reg_tmp2.wwww);
    reg_tmp1 = mul_s(uniforms.f[94].xxxx, reg_tmp1);
    reg_tmp6.xy = (uniforms.f[94].xxxx + reg_tmp1.xyyy).xy;
    return false;
}
bool sub_0() {
    {
        sub_1();
    }
    reg_tmp2 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
    reg_tmp1.xyz = (uniforms.f[93].xxyx).xyz;
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    reg_tmp14.w = (uniforms.f[93].xxxx).w;
    reg_tmp8 = reg_tmp14;
    reg_tmp14.x = dot_s(reg_tmp8, reg_tmp8);
    reg_tmp14.x = rsq_s(reg_tmp14.x);
    reg_tmp14 = mul_s(reg_tmp8, reg_tmp14.xxxx);
    reg_tmp9.x = dot_3(reg_tmp14.xyz, reg_tmp1.xyz);
    reg_tmp9.x = (max(uniforms.f[93].xxxx, reg_tmp9.xxxx)).x;
    reg_tmp9.x = (min(uniforms.f[93].yyyy, reg_tmp9.xxxx)).x;
    reg_tmp9.x = (uniforms.f[93].yyyy + -reg_tmp9.xxxx).x;
    reg_tmp9.x = log2(reg_tmp9.x);
    reg_tmp9.x = (mul_s(uniforms.f[82].xxxx, reg_tmp9.xxxx)).x;
    reg_tmp9.x = exp2(reg_tmp9.x);
    reg_tmp2.w = (mul_s(uniforms.f[82].yyyy, reg_tmp9.xxxx)).w;
    vs_out_attr3 = reg_tmp2;
    {
        sub_7();
    }
    {
        sub_21();
    }
    {
        sub_28();
    }
    return true;
}
// reference: 188084E63A85DF5A, CC9BBBC59EE3249E
// program: CC9BBBC59EE3249E, 0D30074279C2FEED, C7969C7985C3CB70
// reference: 56D47BA6B970B928, CC9BBBC59EE3249E
// program: CC9BBBC59EE3249E, 0D30074279C2FEED, 9CE5E607337B297A
// program: CC9BBBC59EE3249E, 0D30074279C2FEED, F809C797ACA3151F
// shader: 8B31, B800CABB0B40661E

#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define mul_3(x, y) mix(x * y, vec3(0.0), isnan(x * y))
#define fma_s(x, y, z) (mul_s(x, y) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(mul_3(x, y), vec3(1.0))

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location = 0) in vec4 vs_in_reg0;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;
out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_2();
bool sub_1();
bool sub_3();
bool sub_4();
bool sub_0();

bool exec_shader() {
    sub_0();
    return true;
}

bool sub_2() {
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    return false;
}
bool sub_1() {
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    reg_tmp7 = uniforms.f[93].xxxx;
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    {
        sub_2();
    }
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    {
        sub_2();
    }
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    if (conditional_code.x) {
        sub_2();
    }
    if (uniforms.b[11]) {
        sub_3();
    }
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    reg_tmp10 = reg_tmp7;
    reg_tmp6.y = (-uniforms.f[83].wwww + reg_tmp10.yyyy).y;
    reg_tmp9.xyz = (uniforms.f[83].xyzz).xyz;
    reg_tmp7.x = dot_s(reg_tmp9.xyzz, reg_tmp9.xyzz);
    reg_tmp7.x = rsq_s(reg_tmp7.x);
    reg_tmp7.xyz = (mul_s(reg_tmp9.xyzz, reg_tmp7.xxxx)).xyz;
    reg_tmp8.y = rcp_s(-reg_tmp7.y);
    reg_tmp8.y = (mul_s(reg_tmp6.yyyy, reg_tmp8.yyyy)).y;
    reg_tmp7.xyz = (mul_s(reg_tmp7.xyzz, reg_tmp8.yyyy)).xyz;
    reg_tmp10.xyz = (reg_tmp10.xyzz + reg_tmp7.xyzz).xyz;
    reg_tmp10.y = (uniforms.f[94].xxxx + reg_tmp10.yyyy).y;
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    vs_out_attr1 = uniforms.f[93].xxxx;
    vs_out_attr2 = -reg_tmp15;
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    if (all(conditional_code)) {
        sub_4();
    }
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_3() {
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    if (conditional_code.y) {
        sub_2();
    }
    return false;
}
bool sub_4() {
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_0() {
    {
        sub_1();
    }
    vs_out_attr4 = uniforms.f[93].xxxx;
    vs_out_attr5 = uniforms.f[93].xxxx;
    vs_out_attr6 = uniforms.f[93].xxxx;
    vs_out_attr3 = uniforms.f[93].xxxx;
    return true;
}
// reference: EC0EA6608CC226BA, B800CABB0B40661E
// program: B800CABB0B40661E, 0D30074279C2FEED, 5C810B10151A2528
// program: 6646015FB9778410, 0D30074279C2FEED, FE3CDC9FA9FF9FA9
// program: BE1CA71D0DC7876E, 13A54CCD8AA1DDA2, EDB11957E1308F8F
// reference: 2BC49DCED86240F6, 4C0FFB8132202FAB
// reference: FAF4FA0E97BFA0CA, 41E479466D7D2696
// program: AC6AA2648888417C, 1C4CBC8096EA16CD, FECCDB075D3282D4
// program: AC6AA2648888417C, 1C4CBC8096EA16CD, 17F705211262CD00
// shader: 8B31, 258C5AF249C6F5B2

#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define mul_3(x, y) mix(x * y, vec3(0.0), isnan(x * y))
#define fma_s(x, y, z) (mul_s(x, y) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(mul_3(x, y), vec3(1.0))

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

out vec4 vs_out_attr0;
out vec4 vs_out_attr1;
out vec4 vs_out_attr2;
out vec4 vs_out_attr3;
out vec4 vs_out_attr4;
out vec4 vs_out_attr5;
out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}
bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_5();
bool sub_3();
bool sub_1();
bool sub_2();
bool sub_4();
bool sub_6();
bool sub_9();
bool sub_10();
bool sub_16();
bool sub_17();
bool sub_18();
bool sub_19();
bool sub_21();
bool sub_23();
bool sub_24();
bool sub_25();
bool sub_26();
bool sub_27();
bool sub_28();
bool sub_29();
bool sub_30();
bool sub_31();
bool sub_32();
bool sub_33();
bool sub_34();
bool sub_11();
bool sub_12();
bool sub_13();
bool sub_14();
bool sub_15();
bool sub_20();
bool sub_22();
bool sub_0();
bool sub_7();
bool sub_8();

bool exec_shader() {
    sub_0();
    return true;
}

bool sub_5() {
    uint jmp_to = 0u;
    while (true) {
        switch (jmp_to) {
        case 0u: {
            reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
            reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
            reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
            reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
            reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
            reg_tmp6.x = rsq_s(reg_tmp6.x);
            reg_tmp7.x = rsq_s(reg_tmp7.x);
            reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            reg_tmp0 = uniforms.f[93].yxxx;
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            reg_tmp4 = mul_s(uniforms.f[94].xxxx, reg_tmp4);
            conditional_code = greaterThanEqual(uniforms.f[93].xx, reg_tmp4.xx);
            reg_tmp4 = vec4(rsq_s(reg_tmp4.x));
            reg_tmp5 = mul_s(uniforms.f[94].xxxx, reg_tmp14);
            if (conditional_code.x) {
                { jmp_to = 18u; break; }
            }
            reg_tmp0.z = rcp_s(reg_tmp4.x);
            reg_tmp0.xy = (mul_s(reg_tmp5, reg_tmp4)).xy;
        }
        case 18u: {
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_3() {
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    reg_tmp4.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp4.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_1() {
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    if (uniforms.b[0]) {
        sub_2();
    } else {
        sub_4();
    }
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    {
        sub_5();
    }
    vs_out_attr2 = reg_tmp15;
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    if (all(conditional_code)) {
        sub_6();
    }
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_2() {
    reg_tmp7 = uniforms.f[93].xxxx;
    reg_tmp12 = uniforms.f[93].xxxx;
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    {
        sub_3();
    }
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    {
        sub_3();
    }
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    {
        sub_3();
    }
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    {
        sub_3();
    }
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    reg_tmp10 = reg_tmp7;
    return false;
}
bool sub_4() {
    reg_tmp7 = reg_tmp15;
    reg_tmp10.x = dot_s(uniforms.f[10], reg_tmp7);
    reg_tmp10.y = dot_s(uniforms.f[11], reg_tmp7);
    reg_tmp10.z = dot_s(uniforms.f[12], reg_tmp7);
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    reg_tmp12.x = dot_3(uniforms.f[10].xyz, reg_tmp14.xyz);
    reg_tmp12.y = dot_3(uniforms.f[11].xyz, reg_tmp14.xyz);
    reg_tmp12.z = dot_3(uniforms.f[12].xyz, reg_tmp14.xyz);
    return false;
}
bool sub_6() {
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_9() {
    reg_tmp0.xy = (uniforms.f[0].xxxx).xy;
    if (uniforms.b[2]) {
        sub_10();
    } else {
        sub_16();
    }
    return false;
}
bool sub_10() {
    {
        sub_11();
    }
    reg_tmp3.x = dot_s(uniforms.f[1].xywz, reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2].xywz, reg_tmp6);
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_16() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_17();
    } else {
        sub_18();
    }
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_17() {
    reg_tmp6 = reg_tmp10;
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    reg_tmp3.z = dot_s(uniforms.f[3], reg_tmp6);
    reg_tmp0.xy = (mul_s(uniforms.f[9].xyyy, reg_tmp3.zzzz)).xy;
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_18() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_19();
    } else {
        sub_21();
    }
    return false;
}
bool sub_19() {
    {
        sub_20();
    }
    reg_tmp3.x = dot_3(uniforms.f[1].xyz, reg_tmp6.xyz);
    reg_tmp3.y = dot_3(uniforms.f[2].xyz, reg_tmp6.xyz);
    reg_tmp3.z = dot_3(uniforms.f[3].xyz, reg_tmp6.xyz);
    return false;
}
bool sub_21() {
    {
        sub_22();
    }
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    return false;
}
bool sub_23() {
    reg_tmp0.xy = (uniforms.f[0].yyyy).xy;
    if (uniforms.b[3]) {
        sub_24();
    } else {
        sub_25();
    }
    return false;
}
bool sub_24() {
    {
        sub_11();
    }
    reg_tmp4.x = dot_s(uniforms.f[4].xywz, reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5].xywz, reg_tmp6);
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_25() {
    if (uniforms.b[5]) {
        sub_26();
    } else {
        sub_29();
    }
    return false;
}
bool sub_26() {
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    if (all(not(conditional_code))) {
        sub_27();
    } else {
        sub_28();
    }
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_27() {
    reg_tmp6 = reg_tmp10;
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    reg_tmp4.z = dot_s(uniforms.f[6], reg_tmp6);
    reg_tmp6.w = rcp_s(reg_tmp4.z);
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    reg_tmp4.xy = (uniforms.f[9].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_28() {
    {
        sub_22();
    }
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    return false;
}
bool sub_29() {
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_30() {
    reg_tmp0.xy = (uniforms.f[0].zzzz).xy;
    if (uniforms.b[4]) {
        sub_31();
    } else {
        sub_32();
    }
    return false;
}
bool sub_31() {
    {
        sub_11();
    }
    reg_tmp5.x = dot_s(uniforms.f[7].xywz, reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8].xywz, reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_32() {
    if (uniforms.b[6]) {
        sub_33();
    } else {
        sub_34();
    }
    return false;
}
bool sub_33() {
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    {
        sub_22();
    }
    reg_tmp5.x = dot_s(uniforms.f[7], reg_tmp6);
    reg_tmp5.y = dot_s(uniforms.f[8], reg_tmp6);
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_34() {
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
bool sub_11() {
    conditional_code = equal(uniforms.f[93].yz, reg_tmp0.xy);
    if (all(not(conditional_code))) {
        sub_12();
    } else {
        sub_13();
    }
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_12() {
    reg_tmp6.xy = (vs_in_reg4.xyyy).xy;
    return false;
}
bool sub_13() {
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_14();
    } else {
        sub_15();
    }
    return false;
}
bool sub_14() {
    reg_tmp6.xy = (vs_in_reg5.xyyy).xy;
    return false;
}
bool sub_15() {
    reg_tmp6.xy = (vs_in_reg6.xyyy).xy;
    return false;
}
bool sub_20() {
    reg_tmp2 = -reg_tmp15;
    reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
    reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_22() {
    reg_tmp1 = reg_tmp14;
    reg_tmp2.w = dot_3(reg_tmp1.xyz, reg_tmp1.xyz);
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    reg_tmp1 = mul_s(reg_tmp1, reg_tmp2.wwww);
    reg_tmp1 = mul_s(uniforms.f[94].xxxx, reg_tmp1);
    reg_tmp6.xy = (uniforms.f[94].xxxx + reg_tmp1.xyyy).xy;
    return false;
}
bool sub_0() {
    {
        sub_1();
    }
    if (uniforms.b[1]) {
        sub_7();
    } else {
        sub_8();
    }
    vs_out_attr3 = reg_tmp2;
    {
        sub_9();
    }
    {
        sub_23();
    }
    {
        sub_30();
    }
    return true;
}
bool sub_7() {
    reg_tmp0 = vec4(dot_3(uniforms.f[83].xyz, reg_tmp12.xyz));
    reg_tmp0 = max(uniforms.f[93].xxxx, reg_tmp0);
    reg_tmp0 = mul_s(uniforms.f[84], reg_tmp0);
    reg_tmp0 = uniforms.f[85] + reg_tmp0;
    reg_tmp0.w = (uniforms.f[93].yyyy).w;
    reg_tmp1 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
    reg_tmp2 = mul_s(reg_tmp0, reg_tmp1);
    return false;
}
bool sub_8() {
    reg_tmp2 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
    return false;
}
// reference: ABAF9865EF11BEBD, 258C5AF249C6F5B2
// program: 258C5AF249C6F5B2, 0D30074279C2FEED, 4D5CFC1E9D9B8FEC
// program: 888358E3BB131C20, 0D30074279C2FEED, A8FC15635CBD744A
// program: 888358E3BB131C20, 0D30074279C2FEED, 664FC942DC6F2932
// program: 44CE3A13C1B65B01, 13A54CCD8AA1DDA2, 8BCC92BF77D1741F
// program: 4C0FFB8132202FAB, 13A54CCD8AA1DDA2, EDB11957E1308F8F
// reference: A25A59200F3740C8, B800CABB0B40661E
// program: 6646015FB9778410, 0D30074279C2FEED, B3D8BDDED8751DC1
// program: 6646015FB9778410, 0D30074279C2FEED, 71558E57CB578675
// program: 6646015FB9778410, 0D30074279C2FEED, B39B86850EF4C09C
// program: 6646015FB9778410, 0D30074279C2FEED, 7FBD92A5E9176C9B
// program: 6646015FB9778410, 0D30074279C2FEED, 18029AEFBF0A9810
