// shader: 8B31, B3A9ECAF0A8ECFA3

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;
 out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}


#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_76_103();
bool sub_78_83();
bool sub_83_102();
bool sub_86_92();
bool sub_92_101();
bool sub_93_97();
bool sub_97_100();
bool sub_103_127();
bool sub_105_109();
bool sub_109_126();
bool sub_110_124();
bool sub_113_120();
bool sub_120_123();
bool sub_124_125();
bool sub_127_143();
bool sub_129_133();
bool sub_133_142();
bool sub_134_140();
bool sub_140_141();
bool sub_143_151();
bool sub_145_146();
bool sub_146_150();
bool sub_147_148();
bool sub_148_149();
bool sub_151_158();
bool sub_158_166();
bool sub_166_4096();

bool exec_shader() {
    sub_166_4096();
    return true;
}

bool sub_76_103() {
    // 76: mov
    reg_tmp0.xy = (uniforms.f[0].xxxx).xy;
    // 77: ifu
    if (uniforms.b[2]) {
        sub_78_83();
    } else {
        sub_83_102();
    }
    // 102: nop
    return false;
}
bool sub_78_83() {
    // 78: call
    {
        sub_143_151();
    }
    // 79: dp4
    reg_tmp3.x = dot_s(uniforms.f[1].xywz, reg_tmp6);
    // 80: dp4
    reg_tmp3.y = dot_s(uniforms.f[2].xywz, reg_tmp6);
    // 81: mov
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    // 82: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_83_102() {
    // 83: cmp
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    // 84: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 85: ifc
    if (all(not(conditional_code))) {
        sub_86_92();
    } else {
        sub_92_101();
    }
    // 101: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_86_92() {
    // 86: mov
    reg_tmp6 = reg_tmp10;
    // 87: dp4
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    // 88: dp4
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    // 89: dp4
    reg_tmp3.z = dot_s(uniforms.f[3], reg_tmp6);
    // 90: mul
    reg_tmp0.xy = (mul_s(uniforms.f[9].xyyy, reg_tmp3.zzzz)).xy;
    // 91: add
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_92_101() {
    // 92: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_93_97();
    } else {
        sub_97_100();
    }
    // 100: nop
    return false;
}
bool sub_93_97() {
    // 93: call
    {
        sub_151_158();
    }
    // 94: dp3
    reg_tmp3.x = dot_3(uniforms.f[1].xyz, reg_tmp6.xyz);
    // 95: dp3
    reg_tmp3.y = dot_3(uniforms.f[2].xyz, reg_tmp6.xyz);
    // 96: dp3
    reg_tmp3.z = dot_3(uniforms.f[3].xyz, reg_tmp6.xyz);
    return false;
}
bool sub_97_100() {
    // 97: call
    {
        sub_158_166();
    }
    // 98: dp4
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    // 99: dp4
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    return false;
}
bool sub_103_127() {
    // 103: mov
    reg_tmp0.xy = (uniforms.f[0].yyyy).xy;
    // 104: ifu
    if (uniforms.b[3]) {
        sub_105_109();
    } else {
        sub_109_126();
    }
    // 126: nop
    return false;
}
bool sub_105_109() {
    // 105: call
    {
        sub_143_151();
    }
    // 106: dp4
    reg_tmp4.x = dot_s(uniforms.f[4].xywz, reg_tmp6);
    // 107: dp4
    reg_tmp4.y = dot_s(uniforms.f[5].xywz, reg_tmp6);
    // 108: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_109_126() {
    // 109: ifu
    if (uniforms.b[5]) {
        sub_110_124();
    } else {
        sub_124_125();
    }
    // 125: nop
    return false;
}
bool sub_110_124() {
    // 110: cmp
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    // 111: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 112: ifc
    if (all(not(conditional_code))) {
        sub_113_120();
    } else {
        sub_120_123();
    }
    // 123: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_113_120() {
    // 113: mov
    reg_tmp6 = reg_tmp10;
    // 114: dp4
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    // 115: dp4
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    // 116: dp4
    reg_tmp4.z = dot_s(uniforms.f[6], reg_tmp6);
    // 117: rcp
    reg_tmp6.w = rcp_s(reg_tmp4.z);
    // 118: mul
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    // 119: add
    reg_tmp4.xy = (uniforms.f[9].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_120_123() {
    // 120: call
    {
        sub_158_166();
    }
    // 121: dp4
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    // 122: dp4
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    return false;
}
bool sub_124_125() {
    // 124: mov
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_127_143() {
    // 127: mov
    reg_tmp0.xy = (uniforms.f[0].zzzz).xy;
    // 128: ifu
    if (uniforms.b[4]) {
        sub_129_133();
    } else {
        sub_133_142();
    }
    // 142: nop
    return false;
}
bool sub_129_133() {
    // 129: call
    {
        sub_143_151();
    }
    // 130: dp4
    reg_tmp5.x = dot_s(uniforms.f[7].xywz, reg_tmp6);
    // 131: dp4
    reg_tmp5.y = dot_s(uniforms.f[8].xywz, reg_tmp6);
    // 132: mov
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_133_142() {
    // 133: ifu
    if (uniforms.b[6]) {
        sub_134_140();
    } else {
        sub_140_141();
    }
    // 141: nop
    return false;
}
bool sub_134_140() {
    // 134: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 135: mov
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    // 136: call
    {
        sub_158_166();
    }
    // 137: dp4
    reg_tmp5.x = dot_s(uniforms.f[7], reg_tmp6);
    // 138: dp4
    reg_tmp5.y = dot_s(uniforms.f[8], reg_tmp6);
    // 139: mov
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_140_141() {
    // 140: mov
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
bool sub_143_151() {
    // 143: cmp
    conditional_code = equal(uniforms.f[93].yz, reg_tmp0.xy);
    // 144: ifc
    if (all(not(conditional_code))) {
        sub_145_146();
    } else {
        sub_146_150();
    }
    // 150: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_145_146() {
    // 145: mov
    reg_tmp6.xy = (vs_in_reg4.xyyy).xy;
    return false;
}
bool sub_146_150() {
    // 146: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_147_148();
    } else {
        sub_148_149();
    }
    // 149: nop
    return false;
}
bool sub_147_148() {
    // 147: mov
    reg_tmp6.xy = (vs_in_reg5.xyyy).xy;
    return false;
}
bool sub_148_149() {
    // 148: mov
    reg_tmp6.xy = (vs_in_reg6.xyyy).xy;
    return false;
}
bool sub_151_158() {
    // 151: mov
    reg_tmp2 = -reg_tmp15;
    // 152: dp3
    reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
    // 153: rsq
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    // 154: mul
    reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
    // 155: dp3
    reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
    // 156: add
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    // 157: mad
    reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_158_166() {
    // 158: call
    {
        sub_151_158();
    }
    // 159: mov
    reg_tmp1 = reg_tmp6;
    // 160: add
    reg_tmp1.z = (uniforms.f[93].yyyy + reg_tmp1.zzzz).z;
    // 161: dp3
    reg_tmp1 = vec4(dot_3(reg_tmp1.xyz, reg_tmp1.xyz));
    // 162: rsq
    reg_tmp2 = vec4(rsq_s(reg_tmp1.x));
    // 163: mul
    reg_tmp2 = mul_s(uniforms.f[94].xxxx, reg_tmp2);
    // 164: mul
    reg_tmp6.xy = (mul_s(reg_tmp6.xyyy, reg_tmp2)).xy;
    // 165: add
    reg_tmp6.xy = (uniforms.f[94].xxxx + reg_tmp6.xyyy).xy;
    return false;
}
bool sub_166_4096() {
    // 166: mov
    reg_tmp0 = vs_in_reg0;
    // 167: mov
    reg_tmp0.z = (uniforms.f[93].xxxx).z;
    // 168: mov
    reg_tmp0.w = (uniforms.f[93].yyyy).w;
    // 169: mov
    vs_out_attr0 = reg_tmp0;
    // 170: mov
    vs_out_attr2 = reg_tmp0;
    // 171: mov
    vs_out_attr1 = reg_tmp0;
    // 172: mov
    vs_out_attr3 = uniforms.f[93].yyyy;
    // 173: call
    {
        sub_76_103();
    }
    // 174: call
    {
        sub_103_127();
    }
    // 175: call
    {
        sub_127_143();
    }
    // 176: end
    return true;
}
// reference: 9049A31F314B486A, B3A9ECAF0A8ECFA3
// shader: 8DD9, AD7922A63ED54CA7

layout(triangles) in;
layout(triangle_strip, max_vertices = 3) out;

out vec4 primary_color;
out vec2 texcoord0;
out vec2 texcoord1;
out vec2 texcoord2;
out float texcoord0_w;
out vec4 normquat;
out vec3 view;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

 in vec4 vs_out_attr0[];
 in vec4 vs_out_attr1[];
 in vec4 vs_out_attr2[];
 in vec4 vs_out_attr3[];
 in vec4 vs_out_attr4[];
 in vec4 vs_out_attr5[];
 in vec4 vs_out_attr6[];

struct Vertex {
    vec4 attributes[7];
};

vec4 GetVertexQuaternion(Vertex vtx) {
    return vec4(vtx.attributes[1].x, vtx.attributes[1].y, vtx.attributes[1].z, vtx.attributes[1].w);
}

void EmitVtx(Vertex vtx, bool quats_opposite) {
    vec4 vtx_pos = vec4(vtx.attributes[0].x, vtx.attributes[0].y, vtx.attributes[0].z, vtx.attributes[0].w);
    gl_Position = vtx_pos;
#if !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)
    gl_ClipDistance[0] = -vtx_pos.z;
    gl_ClipDistance[1] = dot(clip_coef, vtx_pos);
#endif // !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)

    vec4 vtx_quat = GetVertexQuaternion(vtx);
    normquat = mix(vtx_quat, -vtx_quat, bvec4(quats_opposite));

    vec4 vtx_color = vec4(vtx.attributes[3].x, vtx.attributes[3].y, vtx.attributes[3].z, vtx.attributes[3].w);
    primary_color = min(abs(vtx_color), vec4(1.0));

    texcoord0 = vec2(vtx.attributes[4].x, vtx.attributes[4].y);
    texcoord1 = vec2(vtx.attributes[5].x, vtx.attributes[5].y);

    texcoord0_w = vtx.attributes[4].z;
    view = vec3(vtx.attributes[2].x, vtx.attributes[2].y, vtx.attributes[2].z);

    texcoord2 = vec2(vtx.attributes[6].x, vtx.attributes[6].y);

    EmitVertex();
}

bool AreQuaternionsOpposite(vec4 qa, vec4 qb) {
    return (dot(qa, qb) < 0.0);
}

void EmitPrim(Vertex vtx0, Vertex vtx1, Vertex vtx2) {
    EmitVtx(vtx0, false);
    EmitVtx(vtx1, AreQuaternionsOpposite(GetVertexQuaternion(vtx0), GetVertexQuaternion(vtx1)));
    EmitVtx(vtx2, AreQuaternionsOpposite(GetVertexQuaternion(vtx0), GetVertexQuaternion(vtx2)));
    EndPrimitive();
}

void main() {
    Vertex prim_buffer[3];
    prim_buffer[0].attributes = vec4[7](vs_out_attr0[0], vs_out_attr1[0], vs_out_attr2[0], vs_out_attr3[0], vs_out_attr4[0], vs_out_attr5[0], vs_out_attr6[0]);
    prim_buffer[1].attributes = vec4[7](vs_out_attr0[1], vs_out_attr1[1], vs_out_attr2[1], vs_out_attr3[1], vs_out_attr4[1], vs_out_attr5[1], vs_out_attr6[1]);
    prim_buffer[2].attributes = vec4[7](vs_out_attr0[2], vs_out_attr1[2], vs_out_attr2[2], vs_out_attr3[2], vs_out_attr4[2], vs_out_attr5[2], vs_out_attr6[2]);
    EmitPrim(prim_buffer[0], prim_buffer[1], prim_buffer[2]);
}
// reference: FC74FA4ACA1C8C74, AD7922A63ED54CA7
// shader: 8B30, 645CF88181B5EE32

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 845FF0BC87927CCD, 645CF88181B5EE32
// program: B3A9ECAF0A8ECFA3, AD7922A63ED54CA7, 645CF88181B5EE32
// shader: 8B31, DEDDD3577BD6F4B8

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}


#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_97();
bool sub_5_50();
bool sub_12_13();
bool sub_20_21();
bool sub_22_24();
bool sub_31_32();
bool sub_33_34();
bool sub_40_41();
bool sub_42_43();
bool sub_48_49();
bool sub_52_69();
bool sub_57_60();
bool sub_60_68();
bool sub_62_63();
bool sub_63_64();
bool sub_65_66();
bool sub_66_67();
bool sub_69_96();
bool sub_70_93();
bool sub_74_79();
bool sub_79_92();
bool sub_83_87();
bool sub_84_85();
bool sub_85_86();
bool sub_87_91();
bool sub_88_89();
bool sub_89_90();
bool sub_93_95();
bool sub_97_109();
bool sub_109_4096();
bool sub_125_127();
bool sub_127_149();
bool sub_137_141();
bool sub_158_160();
bool sub_161_162();
bool sub_171_173();
bool sub_174_175();
bool sub_184_186();
bool sub_187_188();
bool sub_198_207();
bool sub_215_223();
bool sub_223_227();

bool exec_shader() {
    sub_109_4096();
    return true;
}

bool sub_0_97() {
    // 0: flr
    reg_tmp13 = floor(reg_tmp0.xxxx);
    // 1: add
    reg_tmp13 = reg_tmp0.xxxx + -reg_tmp13;
    // 2: mova
    address_registers.y = (ivec2(reg_tmp11.zz)).y;
    // 3: cmp
    conditional_code = lessThanEqual(uniforms.f[5].ww, reg_tmp13.xx);
    // 4: ifc
    if (conditional_code.x) {
        sub_5_50();
    }
    // 50: cmp
    conditional_code = lessThanEqual(uniforms.f[5].yy, reg_tmp11.xy);
    // 51: ifc
    if (!conditional_code.y) {
        sub_52_69();
    } else {
        sub_69_96();
    }
    // 96: nop
    return false;
}
bool sub_5_50() {
    // 5: add
    reg_tmp12.xy = (uniforms.f[5].xyyy + vs_in_reg0.zwww).xy;
    // 6: mov
    reg_tmp14.xy = (uniforms.f[6].wzzz).xy;
    // 7: mul
    reg_tmp13.xy = (mul_s(uniforms.f[5].zzzz, reg_tmp0.xxxx)).xy;
    // 8: flr
    reg_tmp13.y = (floor(reg_tmp13)).y;
    // 9: add
    reg_tmp13.x = (reg_tmp13.xxxx + -reg_tmp13.yyyy).x;
    // 10: cmp
    conditional_code = lessThanEqual(uniforms.f[5].ww, reg_tmp13.xx);
    // 11: ifc
    if (conditional_code.x) {
        sub_12_13();
    }
    // 13: mul
    reg_tmp14.xy = (mul_s(reg_tmp14, reg_tmp2)).xy;
    // 14: mul
    reg_tmp13.x = (mul_s(uniforms.f[5].zzzz, reg_tmp13.xxxx)).x;
    // 15: mul
    reg_tmp13 = mul_s(uniforms.f[5].zyzy, reg_tmp13.xxxx);
    // 16: flr
    reg_tmp13.zw = (floor(reg_tmp13)).zw;
    // 17: add
    reg_tmp13.xy = (reg_tmp13.xyyy + -reg_tmp13.zwww).xy;
    // 18: cmp
    conditional_code = lessThanEqual(uniforms.f[5].ww, reg_tmp13.xy);
    // 19: ifc
    if (conditional_code.y) {
        sub_20_21();
    }
    // 21: ifc
    if (conditional_code.x) {
        sub_22_24();
    }
    // 24: add
    reg_tmp14.xy = (uniforms.f[5].yyyy + -reg_tmp14.xyyy).xy;
    // 25: mul
    reg_tmp13.x = (mul_s(uniforms.f[5].zzzz, reg_tmp13.xxxx)).x;
    // 26: mul
    reg_tmp13 = mul_s(uniforms.f[5].zyzy, reg_tmp13.xxxx);
    // 27: flr
    reg_tmp13.zw = (floor(reg_tmp13)).zw;
    // 28: add
    reg_tmp13.xy = (reg_tmp13.xyyy + -reg_tmp13.zwww).xy;
    // 29: cmp
    conditional_code = lessThanEqual(uniforms.f[5].ww, reg_tmp13.xy);
    // 30: ifc
    if (conditional_code.y) {
        sub_31_32();
    }
    // 32: ifc
    if (conditional_code.x) {
        sub_33_34();
    }
    // 34: mul
    reg_tmp13.x = (mul_s(uniforms.f[5].zzzz, reg_tmp13.xxxx)).x;
    // 35: mul
    reg_tmp13 = mul_s(uniforms.f[5].zyzy, reg_tmp13.xxxx);
    // 36: flr
    reg_tmp13.zw = (floor(reg_tmp13)).zw;
    // 37: add
    reg_tmp13.xy = (reg_tmp13.xyyy + -reg_tmp13.zwww).xy;
    // 38: cmp
    conditional_code = lessThanEqual(uniforms.f[5].ww, reg_tmp13.xy);
    // 39: ifc
    if (conditional_code.y) {
        sub_40_41();
    }
    // 41: ifc
    if (conditional_code.x) {
        sub_42_43();
    }
    // 43: mul
    reg_tmp13.xy = (mul_s(uniforms.f[5].zzzz, reg_tmp0.xxxx)).xy;
    // 44: flr
    reg_tmp13.y = (floor(reg_tmp13)).y;
    // 45: add
    reg_tmp13.x = (reg_tmp13.xxxx + -reg_tmp13.yyyy).x;
    // 46: cmp
    conditional_code = lessThanEqual(uniforms.f[5].ww, reg_tmp13.xx);
    // 47: ifc
    if (conditional_code.x) {
        sub_48_49();
    }
    // 49: add
    reg_tmp12.y = (uniforms.f[5].yyyy + -reg_tmp12.yyyy).y;
    return false;
}
bool sub_12_13() {
    // 12: mov
    reg_tmp14.xy = (reg_tmp14.yxxx).xy;
    return false;
}
bool sub_20_21() {
    // 20: mul
    reg_tmp12.x = (mul_s(reg_tmp12.xxxx, reg_tmp14.xxxx)).x;
    return false;
}
bool sub_22_24() {
    // 22: madi
    reg_tmp12.y = (fma_s(reg_tmp12.yyyy, reg_tmp14.yyyy, uniforms.f[5].yyyy)).y;
    // 23: add
    reg_tmp12.y = (reg_tmp12.yyyy + -reg_tmp14.yyyy).y;
    return false;
}
bool sub_31_32() {
    // 31: add
    reg_tmp12.x = (reg_tmp12.xxxx + reg_tmp14.xxxx).x;
    return false;
}
bool sub_33_34() {
    // 33: add
    reg_tmp12.y = (reg_tmp12.yyyy + -reg_tmp14.yyyy).y;
    return false;
}
bool sub_40_41() {
    // 40: add
    reg_tmp12.x = (uniforms.f[5].yyyy + -reg_tmp12.xxxx).x;
    return false;
}
bool sub_42_43() {
    // 42: add
    reg_tmp12.y = (uniforms.f[5].yyyy + -reg_tmp12.yyyy).y;
    return false;
}
bool sub_48_49() {
    // 48: add
    reg_tmp12.xy = (uniforms.f[5].yyyy + -reg_tmp12.yxxx).xy;
    return false;
}
bool sub_52_69() {
    // 52: flr
    reg_tmp13.x = (floor(reg_tmp0.xxxx)).x;
    // 53: add
    reg_tmp13.x = (reg_tmp0.xxxx + -reg_tmp13).x;
    // 54: cmp
    conditional_code = lessThanEqual(uniforms.f[5].ww, reg_tmp13.xx);
    // 55: mov
    reg_tmp13 = uniforms.f[32 + address_registers.y].wzyx;
    // 56: ifc
    if (conditional_code.x) {
        sub_57_60();
    } else {
        sub_60_68();
    }
    // 68: add
    reg_tmp11.z = (uniforms.f[5].yyyy + reg_tmp11.zzzz).z;
    return false;
}
bool sub_57_60() {
    // 57: mad
    reg_tmp11.xy = (fma_s(reg_tmp12.xyyy, reg_tmp13.xyyy, reg_tmp13.zwww)).xy;
    // 58: mul
    reg_tmp11.xy = (mul_s(reg_tmp11.xyyy, reg_tmp14.zwww)).xy;
    // 59: add
    reg_tmp11.y = (uniforms.f[5].yyyy + -reg_tmp11.yyyy).y;
    return false;
}
bool sub_60_68() {
    // 60: cmp
    conditional_code = notEqual(uniforms.f[5].xx, vs_in_reg0.zw);
    // 61: ifc
    if (!conditional_code.x) {
        sub_62_63();
    } else {
        sub_63_64();
    }
    // 64: ifc
    if (!conditional_code.y) {
        sub_65_66();
    } else {
        sub_66_67();
    }
    // 67: nop
    return false;
}
bool sub_62_63() {
    // 62: mov
    reg_tmp11.x = (reg_tmp13.xxxx).x;
    return false;
}
bool sub_63_64() {
    // 63: mov
    reg_tmp11.x = (reg_tmp13.zzzz).x;
    return false;
}
bool sub_65_66() {
    // 65: mov
    reg_tmp11.y = (reg_tmp13.yyyy).y;
    return false;
}
bool sub_66_67() {
    // 66: mov
    reg_tmp11.y = (reg_tmp13.wwww).y;
    return false;
}
bool sub_69_96() {
    // 69: ifc
    if (!conditional_code.x) {
        sub_70_93();
    } else {
        sub_93_95();
    }
    // 95: add
    reg_tmp11.z = (uniforms.f[5].zzzz + reg_tmp11.zzzz).z;
    return false;
}
bool sub_70_93() {
    // 70: flr
    reg_tmp13.x = (floor(reg_tmp0.xxxx)).x;
    // 71: add
    reg_tmp13.x = (reg_tmp0.xxxx + -reg_tmp13).x;
    // 72: cmp
    conditional_code = lessThanEqual(uniforms.f[5].ww, reg_tmp13.xx);
    // 73: ifc
    if (conditional_code.x) {
        sub_74_79();
    } else {
        sub_79_92();
    }
    // 92: nop
    return false;
}
bool sub_74_79() {
    // 74: mov
    reg_tmp12.zw = (uniforms.f[5].xxxy).zw;
    // 75: dp4
    reg_tmp11.x = dot_s(uniforms.f[32 + address_registers.y].wzyx, reg_tmp12);
    // 76: dp4
    reg_tmp11.y = dot_s(uniforms.f[33 + address_registers.y].wzyx, reg_tmp12);
    // 77: mul
    reg_tmp11.xy = (mul_s(reg_tmp11.xyyy, reg_tmp14.zwww)).xy;
    // 78: add
    reg_tmp11.y = (uniforms.f[5].yyyy + -reg_tmp11.yyyy).y;
    return false;
}
bool sub_79_92() {
    // 79: mov
    reg_tmp14 = uniforms.f[32 + address_registers.y].wzyx;
    // 80: mov
    reg_tmp13 = uniforms.f[33 + address_registers.y].wzyx;
    // 81: cmp
    conditional_code = notEqual(uniforms.f[5].xx, vs_in_reg0.zw);
    // 82: ifc
    if (!conditional_code.y) {
        sub_83_87();
    } else {
        sub_87_91();
    }
    // 91: nop
    return false;
}
bool sub_83_87() {
    // 83: ifc
    if (!conditional_code.x) {
        sub_84_85();
    } else {
        sub_85_86();
    }
    // 86: nop
    return false;
}
bool sub_84_85() {
    // 84: mov
    reg_tmp11.xy = (reg_tmp14.xyyy).xy;
    return false;
}
bool sub_85_86() {
    // 85: mov
    reg_tmp11.xy = (reg_tmp13.zwww).xy;
    return false;
}
bool sub_87_91() {
    // 87: ifc
    if (!conditional_code.x) {
        sub_88_89();
    } else {
        sub_89_90();
    }
    // 90: nop
    return false;
}
bool sub_88_89() {
    // 88: mov
    reg_tmp11.xy = (reg_tmp13.xyyy).xy;
    return false;
}
bool sub_89_90() {
    // 89: mov
    reg_tmp11.xy = (reg_tmp14.zwww).xy;
    return false;
}
bool sub_93_95() {
    // 93: dp4
    reg_tmp11.x = dot_s(uniforms.f[32 + address_registers.y].wzyx, reg_tmp1);
    // 94: dp4
    reg_tmp11.y = dot_s(uniforms.f[33 + address_registers.y].wzyx, reg_tmp1);
    return false;
}
bool sub_97_109() {
    uint jmp_to = 97u;
    while (true) {
        switch (jmp_to) {
        case 97u: {
            // 97: dp4
            reg_tmp3.x = dot_s(uniforms.f[32 + address_registers.x].wzyx, reg_tmp1);
            // 98: dp4
            reg_tmp3.y = dot_s(uniforms.f[33 + address_registers.x].wzyx, reg_tmp1);
            // 99: dp4
            reg_tmp3.z = dot_s(uniforms.f[34 + address_registers.x].wzyx, reg_tmp1);
            // 100: mov
            reg_tmp3.w = (reg_tmp1.wwww).w;
            // 101: mov
            reg_tmp11 = uniforms.f[4].wzyx;
            // 102: add
            reg_tmp11.z = (-uniforms.f[34 + address_registers.x].xxxx + reg_tmp11.zzzz).z;
            // 103: cmp
            conditional_code.x = uniforms.f[5].xxxx.x != reg_tmp11.xzzz.x;
            conditional_code.y = uniforms.f[5].xxxx.y < reg_tmp11.xzzz.y;
            // 104: jmpc
            if (any(not(conditional_code))) {
                { jmp_to = 108u; break; }
            }
            // 105: rcp
            reg_tmp11.z = rcp_s(reg_tmp11.z);
            // 106: add
            reg_tmp3.x = (reg_tmp3.xxxx + reg_tmp11.xxxx).x;
            // 107: mad
            reg_tmp3.x = (fma_s(-reg_tmp11.yyyy, reg_tmp11.zzzz, reg_tmp3.xxxx)).x;
        }
        case 108u: {
            // 108: nop
        }
        default: return false;
        }
    }
    return false;
}
bool sub_109_4096() {
    uint jmp_to = 109u;
    while (true) {
        switch (jmp_to) {
        case 109u: {
            // 109: mova
            address_registers.x = (ivec2(vs_in_reg0.xx)).x;
            // 110: mov
            reg_tmp0 = uniforms.f[9 + address_registers.x].wzyx;
            // 111: mov
            reg_tmp1.xy = (vs_in_reg0.zwzw).xy;
            // 112: mov
            reg_tmp1.zw = (uniforms.f[5].xyxy).zw;
            // 113: mova
            address_registers.xy = ivec2(reg_tmp0.xy);
            // 114: mov
            reg_tmp2 = uniforms.f[32 + address_registers.y].wzyx;
            // 115: jmpu
            if (uniforms.b[0]) {
                { jmp_to = 191u; break; }
            }
            // 116: mov
            reg_tmp4 = uniforms.f[31 + address_registers.x].wzyx;
            // 117: mad
            reg_tmp1.xy = (fma_s(reg_tmp1.xyyy, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
            // 118: call
            {
                sub_97_109();
            }
            // 119: dp4
            vs_out_attr0.x = dot_s(uniforms.f[0].wzyx, reg_tmp3);
            // 120: dp4
            vs_out_attr0.y = dot_s(uniforms.f[1].wzyx, reg_tmp3);
            // 121: dp4
            vs_out_attr0.z = dot_s(uniforms.f[2].wzyx, reg_tmp3);
            // 122: dp4
            vs_out_attr0.w = dot_s(uniforms.f[3].wzyx, reg_tmp3);
            // 123: cmp
            conditional_code = greaterThanEqual(uniforms.f[5].yy, reg_tmp0.ww);
            // 124: ifc
            if (all(conditional_code)) {
                sub_125_127();
            } else {
                sub_127_149();
            }
            // 149: mov
            reg_tmp11.z = (reg_tmp0.zzzz).z;
            // 150: mul
            reg_tmp9 = mul_s(uniforms.f[5].zyzy, reg_tmp0.zzzz);
            // 151: flr
            reg_tmp9.xy = (floor(reg_tmp9)).xy;
            // 152: add
            reg_tmp9.xy = (reg_tmp9.zwww + -reg_tmp9.xyyy).xy;
            // 153: mul
            reg_tmp9 = mul_s(uniforms.f[5].zzzz, reg_tmp9);
            // 154: mov
            reg_tmp14 = uniforms.f[6].wzyx;
            // 155: mov
            reg_tmp11.xy = (reg_tmp9.xyyy).xy;
            // 156: call
            {
                sub_0_97();
            }
            // 157: ifu
            if (uniforms.b[1]) {
                sub_158_160();
            }
            // 160: ifu
            if (uniforms.b[2]) {
                sub_161_162();
            }
            // 162: mov
            vs_out_attr2 = reg_tmp11.xyyy;
            // 163: mul
            reg_tmp9 = mul_s(uniforms.f[5].zyzy, reg_tmp9.xxxx);
            // 164: flr
            reg_tmp9.xy = (floor(reg_tmp9)).xy;
            // 165: add
            reg_tmp9.xy = (reg_tmp9.zwww + -reg_tmp9.xyyy).xy;
            // 166: mul
            reg_tmp9 = mul_s(uniforms.f[5].zzzz, reg_tmp9);
            // 167: mov
            reg_tmp14 = uniforms.f[7].wzyx;
            // 168: mov
            reg_tmp11.xy = (reg_tmp9.xyyy).xy;
            // 169: call
            {
                sub_0_97();
            }
            // 170: ifu
            if (uniforms.b[3]) {
                sub_171_173();
            }
            // 173: ifu
            if (uniforms.b[4]) {
                sub_174_175();
            }
            // 175: mov
            vs_out_attr3 = reg_tmp11.xyyy;
            // 176: mul
            reg_tmp9 = mul_s(uniforms.f[5].zyzy, reg_tmp9.xxxx);
            // 177: flr
            reg_tmp9.xy = (floor(reg_tmp9)).xy;
            // 178: add
            reg_tmp9.xy = (reg_tmp9.zwww + -reg_tmp9.xyyy).xy;
            // 179: mul
            reg_tmp9 = mul_s(uniforms.f[5].zzzz, reg_tmp9);
            // 180: mov
            reg_tmp14 = uniforms.f[8].wzyx;
            // 181: mov
            reg_tmp11.xy = (reg_tmp9.xyyy).xy;
            // 182: call
            {
                sub_0_97();
            }
            // 183: ifu
            if (uniforms.b[5]) {
                sub_184_186();
            }
            // 186: ifu
            if (uniforms.b[6]) {
                sub_187_188();
            }
            // 188: mov
            vs_out_attr4 = reg_tmp11.xyyy;
            // 189: end
            return true;
        }
        case 191u: {
            // 191: add
            reg_tmp2.w = (reg_tmp2.wwww + reg_tmp2.yyyy).w;
            // 192: add
            reg_tmp1.y = (-uniforms.f[5].yyyy + -reg_tmp1.yyyy).y;
            // 193: mul
            reg_tmp13.xy = (mul_s(uniforms.f[36 + address_registers.x].wzzz, reg_tmp2.xyyy)).xy;
            // 194: mul
            reg_tmp11.x = (mul_s(uniforms.f[35 + address_registers.x].wwww, -reg_tmp1.yyyy)).x;
            // 195: mul
            reg_tmp1.xy = (mul_s(reg_tmp1.xyyy, reg_tmp13.xyyy)).xy;
            // 196: add
            reg_tmp1.x = (reg_tmp1.xxxx + reg_tmp11.xxxx).x;
            // 197: ifu
            if (uniforms.b[1]) {
                sub_198_207();
            }
            // 207: add
            reg_tmp1.xy = (reg_tmp1.xyyy + reg_tmp2.zwww).xy;
            // 208: add
            reg_tmp1.xy = (uniforms.f[36 + address_registers.x].yxxx + reg_tmp1.xyyy).xy;
            // 209: call
            {
                sub_97_109();
            }
            // 210: dp4
            vs_out_attr0.x = dot_s(uniforms.f[0].wzyx, reg_tmp3);
            // 211: dp4
            vs_out_attr0.y = dot_s(uniforms.f[1].wzyx, reg_tmp3);
            // 212: dp4
            vs_out_attr0.z = dot_s(uniforms.f[2].wzyx, reg_tmp3);
            // 213: dp4
            vs_out_attr0.w = dot_s(uniforms.f[3].wzyx, reg_tmp3);
            // 214: ifu
            if (uniforms.b[2]) {
                sub_215_223();
            } else {
                sub_223_227();
            }
            // 227: add
            reg_tmp8 = reg_tmp8 + -reg_tmp7;
            // 228: mad
            vs_out_attr1 = fma_s(reg_tmp8, reg_tmp11.yyyy, reg_tmp7);
            // 229: mul
            reg_tmp9.xy = (mul_s(uniforms.f[32 + address_registers.x].yxxx, reg_tmp11)).xy;
            // 230: slti
            reg_tmp11.zw = (vec4(lessThan(reg_tmp11, uniforms.f[5].yyyy))).zw;
            // 231: mad
            reg_tmp9.xy = (fma_s(reg_tmp11.zwww, uniforms.f[32 + address_registers.x].wzzz, reg_tmp9.xyyy)).xy;
            // 232: add
            reg_tmp9.y = (uniforms.f[5].yyyy + -reg_tmp9.yyyy).y;
            // 233: mov
            vs_out_attr2 = reg_tmp9;
            // 234: mov
            vs_out_attr3 = reg_tmp9;
            // 235: mov
            vs_out_attr4 = reg_tmp9;
            // 236: end
            return true;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_125_127() {
    // 125: mov
    vs_out_attr1.xyz = (uniforms.f[5].yyyy).xyz;
    // 126: mov
    vs_out_attr1.w = (reg_tmp0.wwww).w;
    return false;
}
bool sub_127_149() {
    // 127: mova
    address_registers.y = (ivec2(reg_tmp0.ww)).y;
    // 128: mov
    reg_tmp7 = uniforms.f[32 + address_registers.y].wzyx;
    // 129: mov
    reg_tmp8 = uniforms.f[33 + address_registers.y].wzyx;
    // 130: mov
    reg_tmp9 = uniforms.f[34 + address_registers.y].wzyx;
    // 131: mov
    reg_tmp10 = uniforms.f[35 + address_registers.y].wzyx;
    // 132: mov
    reg_tmp11.xy = (vs_in_reg0.zwww).xy;
    // 133: flr
    reg_tmp14.x = (floor(reg_tmp0.yyyy)).x;
    // 134: add
    reg_tmp14.x = (reg_tmp0.yyyy + -reg_tmp14.xxxx).x;
    // 135: cmp
    conditional_code = lessThanEqual(uniforms.f[5].ww, reg_tmp14.xx);
    // 136: ifc
    if (conditional_code.x) {
        sub_137_141();
    }
    // 141: max
    reg_tmp11.xy = (abs(reg_tmp11.xyyy)).xy;
    // 142: add
    reg_tmp8 = reg_tmp8 + -reg_tmp7;
    // 143: mad
    reg_tmp8 = fma_s(reg_tmp8, reg_tmp11.xxxx, reg_tmp7);
    // 144: add
    reg_tmp10 = reg_tmp10 + -reg_tmp9;
    // 145: mad
    reg_tmp10 = fma_s(reg_tmp10, reg_tmp11.xxxx, reg_tmp9);
    // 146: add
    reg_tmp10 = reg_tmp10 + -reg_tmp8;
    // 147: mad
    reg_tmp10 = fma_s(reg_tmp10, reg_tmp11.yyyy, reg_tmp8);
    // 148: mov
    vs_out_attr1 = reg_tmp10;
    return false;
}
bool sub_137_141() {
    // 137: rcp
    reg_tmp11.z = rcp_s(reg_tmp4.x);
    // 138: rcp
    reg_tmp11.w = rcp_s(reg_tmp4.y);
    // 139: add
    reg_tmp11.xy = (reg_tmp1.xyyy + -reg_tmp4.zwww).xy;
    // 140: mul
    reg_tmp11.xy = (mul_s(reg_tmp11.xyyy, reg_tmp11.zwww)).xy;
    return false;
}
bool sub_158_160() {
    // 158: mov
    reg_tmp11.xy = (reg_tmp11.yxxx).xy;
    // 159: add
    reg_tmp11.y = (uniforms.f[5].yyyy + -reg_tmp11.yyyy).y;
    return false;
}
bool sub_161_162() {
    // 161: add
    reg_tmp11.xy = (uniforms.f[5].yyyy + -reg_tmp11.yxxx).xy;
    return false;
}
bool sub_171_173() {
    // 171: mov
    reg_tmp11.xy = (reg_tmp11.yxxx).xy;
    // 172: add
    reg_tmp11.y = (uniforms.f[5].yyyy + -reg_tmp11.yyyy).y;
    return false;
}
bool sub_174_175() {
    // 174: add
    reg_tmp11.xy = (uniforms.f[5].yyyy + -reg_tmp11.yxxx).xy;
    return false;
}
bool sub_184_186() {
    // 184: mov
    reg_tmp11.xy = (reg_tmp11.yxxx).xy;
    // 185: add
    reg_tmp11.y = (uniforms.f[5].yyyy + -reg_tmp11.yyyy).y;
    return false;
}
bool sub_187_188() {
    // 187: add
    reg_tmp11.xy = (uniforms.f[5].yyyy + -reg_tmp11.yxxx).xy;
    return false;
}
bool sub_198_207() {
    // 198: mul
    reg_tmp13.xzw = (mul_s(uniforms.f[5].wxxx, reg_tmp13.xxxx)).xzw;
    // 199: mul
    reg_tmp13.y = (mul_s(uniforms.f[34 + address_registers.y].yyyy, reg_tmp13.yyyy)).y;
    // 200: mad
    reg_tmp11 = fma_s(reg_tmp1, uniforms.f[5].yyxx, -reg_tmp13);
    // 201: mov
    reg_tmp14 = uniforms.f[33 + address_registers.y].wzyx;
    // 202: dp3
    reg_tmp1.x = dot_3(reg_tmp11.xyz, reg_tmp14.xyy);
    // 203: dp3
    reg_tmp1.y = dot_3(reg_tmp11.xyz, reg_tmp14.zww);
    // 204: mov
    reg_tmp14 = uniforms.f[34 + address_registers.y].wzyx;
    // 205: dph
    reg_tmp1.z = dot_s(vec4(reg_tmp11.xyz, 1.0), reg_tmp14);
    // 206: add
    reg_tmp1.xy = (reg_tmp1.xyyy + reg_tmp13.xyyy).xy;
    return false;
}
bool sub_215_223() {
    // 215: max
    reg_tmp11 = abs(vs_in_reg0.zwzw);
    // 216: flr
    reg_tmp14.w = (floor(reg_tmp0.zzzz)).w;
    // 217: add
    reg_tmp14.w = (reg_tmp0.zzzz + -reg_tmp14).w;
    // 218: mova
    address_registers.xy = ivec2(reg_tmp0.zx);
    // 219: mul
    reg_tmp14.w = (mul_s(uniforms.f[5].zzzz, reg_tmp14.wwww)).w;
    // 220: mov
    reg_tmp14.xyz = (uniforms.f[5].yyyy).xyz;
    // 221: mul
    reg_tmp7 = mul_s(uniforms.f[37 + address_registers.y].wzyx, reg_tmp14);
    // 222: mul
    reg_tmp8 = mul_s(uniforms.f[38 + address_registers.y].wzyx, reg_tmp14);
    return false;
}
bool sub_223_227() {
    // 223: max
    reg_tmp11 = abs(vs_in_reg0.zwzw);
    // 224: mova
    address_registers.xy = ivec2(reg_tmp0.zw);
    // 225: mov
    reg_tmp7 = uniforms.f[32 + address_registers.y].wzyx;
    // 226: mov
    reg_tmp8 = uniforms.f[33 + address_registers.y].wzyx;
    return false;
}
// reference: 26B611F7B99C7E94, DEDDD3577BD6F4B8
// shader: 8DD9, 5D764F9A6220D694

layout(triangles) in;
layout(triangle_strip, max_vertices = 3) out;

out vec4 primary_color;
out vec2 texcoord0;
out vec2 texcoord1;
out vec2 texcoord2;
out float texcoord0_w;
out vec4 normquat;
out vec3 view;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

 in vec4 vs_out_attr0[];
 in vec4 vs_out_attr1[];
 in vec4 vs_out_attr2[];
 in vec4 vs_out_attr3[];
 in vec4 vs_out_attr4[];

struct Vertex {
    vec4 attributes[5];
};

vec4 GetVertexQuaternion(Vertex vtx) {
    return vec4(0.0, 0.0, 0.0, 0.0);
}

void EmitVtx(Vertex vtx, bool quats_opposite) {
    vec4 vtx_pos = vec4(vtx.attributes[0].x, vtx.attributes[0].y, vtx.attributes[0].z, vtx.attributes[0].w);
    gl_Position = vtx_pos;
#if !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)
    gl_ClipDistance[0] = -vtx_pos.z;
    gl_ClipDistance[1] = dot(clip_coef, vtx_pos);
#endif // !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)

    vec4 vtx_quat = GetVertexQuaternion(vtx);
    normquat = mix(vtx_quat, -vtx_quat, bvec4(quats_opposite));

    vec4 vtx_color = vec4(vtx.attributes[1].x, vtx.attributes[1].y, vtx.attributes[1].z, vtx.attributes[1].w);
    primary_color = min(abs(vtx_color), vec4(1.0));

    texcoord0 = vec2(vtx.attributes[2].x, vtx.attributes[2].y);
    texcoord1 = vec2(vtx.attributes[3].x, vtx.attributes[3].y);

    texcoord0_w = 0.0;
    view = vec3(0.0, 0.0, 0.0);

    texcoord2 = vec2(vtx.attributes[4].x, vtx.attributes[4].y);

    EmitVertex();
}

bool AreQuaternionsOpposite(vec4 qa, vec4 qb) {
    return (dot(qa, qb) < 0.0);
}

void EmitPrim(Vertex vtx0, Vertex vtx1, Vertex vtx2) {
    EmitVtx(vtx0, false);
    EmitVtx(vtx1, AreQuaternionsOpposite(GetVertexQuaternion(vtx0), GetVertexQuaternion(vtx1)));
    EmitVtx(vtx2, AreQuaternionsOpposite(GetVertexQuaternion(vtx0), GetVertexQuaternion(vtx2)));
    EndPrimitive();
}

void main() {
    Vertex prim_buffer[3];
    prim_buffer[0].attributes = vec4[5](vs_out_attr0[0], vs_out_attr1[0], vs_out_attr2[0], vs_out_attr3[0], vs_out_attr4[0]);
    prim_buffer[1].attributes = vec4[5](vs_out_attr0[1], vs_out_attr1[1], vs_out_attr2[1], vs_out_attr3[1], vs_out_attr4[1]);
    prim_buffer[2].attributes = vec4[5](vs_out_attr0[2], vs_out_attr1[2], vs_out_attr2[2], vs_out_attr3[2], vs_out_attr4[2]);
    EmitPrim(prim_buffer[0], prim_buffer[1], prim_buffer[2]);
}
// reference: 5DAD5699F59B3586, 5D764F9A6220D694
// shader: 8B30, ECB67079092E1152

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 1F78A607E9F3C0A1, ECB67079092E1152
// program: DEDDD3577BD6F4B8, 5D764F9A6220D694, ECB67079092E1152
// reference: 2FBDCACD0F2A7F15, B3A9ECAF0A8ECFA3
// reference: 845FF0BC865016FA, 645CF88181B5EE32
// reference: F535D60EB99C7E94, DEDDD3577BD6F4B8
// shader: 8B30, 20BCD1F2228017BC

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 1F78A6071213B118, 20BCD1F2228017BC
// program: DEDDD3577BD6F4B8, 5D764F9A6220D694, 20BCD1F2228017BC
// shader: 8B30, 3909C47025D5B887

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor2.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 61A079249DFD89EE, 3909C47025D5B887
// program: DEDDD3577BD6F4B8, 5D764F9A6220D694, 3909C47025D5B887
// reference: F535D60ECB23C7B6, DEDDD3577BD6F4B8
// shader: 8B30, ABFE2AAE4EC81BC1

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor2.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 61A079247B45F66B, ABFE2AAE4EC81BC1
// program: DEDDD3577BD6F4B8, 5D764F9A6220D694, ABFE2AAE4EC81BC1
// shader: 8B30, 43DBAC02A34923F1

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor2.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 61A0792480A587D2, 43DBAC02A34923F1
// program: DEDDD3577BD6F4B8, 5D764F9A6220D694, 43DBAC02A34923F1
// shader: 8B30, B8379EB77E81C497

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor2.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 5118666F2308FBFB, B8379EB77E81C497
// program: DEDDD3577BD6F4B8, 5D764F9A6220D694, B8379EB77E81C497
// shader: 8B30, 39A3026ACEC0346D

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor2.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D96FFE465B6167CB, 39A3026ACEC0346D
// program: DEDDD3577BD6F4B8, 5D764F9A6220D694, 39A3026ACEC0346D
// shader: 8B30, A4D1A5B1361BECA2

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor2.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D96FFE467E4D1A09, A4D1A5B1361BECA2
// program: DEDDD3577BD6F4B8, 5D764F9A6220D694, A4D1A5B1361BECA2
// shader: 8B30, B060C10D234F1E48

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor2.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: E9D7E10D2D37ED8D, B060C10D234F1E48
// program: DEDDD3577BD6F4B8, 5D764F9A6220D694, B060C10D234F1E48
// shader: 8B30, D954FF4D0EAC5F3C

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor2.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D96FFE468E9A91A4, D954FF4D0EAC5F3C
// program: DEDDD3577BD6F4B8, 5D764F9A6220D694, D954FF4D0EAC5F3C
// shader: 8B30, C1EE6A0B0079331A

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor2.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D96FFE46757AE01D, C1EE6A0B0079331A
// program: DEDDD3577BD6F4B8, 5D764F9A6220D694, C1EE6A0B0079331A
// shader: 8B31, 50CFCD58AAA1C3A6

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;
 out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}


#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_49();
bool sub_25_31();
bool sub_32_39();
bool sub_40_48();
bool sub_175_202();
bool sub_177_182();
bool sub_182_201();
bool sub_185_191();
bool sub_191_200();
bool sub_192_196();
bool sub_196_199();
bool sub_202_226();
bool sub_204_208();
bool sub_208_225();
bool sub_209_223();
bool sub_212_219();
bool sub_219_222();
bool sub_223_224();
bool sub_226_242();
bool sub_228_232();
bool sub_232_241();
bool sub_233_239();
bool sub_239_240();
bool sub_242_250();
bool sub_244_245();
bool sub_245_249();
bool sub_246_247();
bool sub_247_248();
bool sub_343_350();
bool sub_350_354();
bool sub_354_4096();
bool sub_361_363();
bool sub_363_364();

bool exec_shader() {
    sub_354_4096();
    return true;
}

bool sub_0_49() {
    // 0: mov
    reg_tmp1.xyz = (uniforms.f[93].xxyx).xyz;
    // 1: dp3
    reg_tmp8.x = dot_3(uniforms.f[0].xyz, reg_tmp12.xyz);
    // 2: dp3
    reg_tmp8.y = dot_3(uniforms.f[1].xyz, reg_tmp12.xyz);
    // 3: dp3
    reg_tmp8.z = dot_3(uniforms.f[2].xyz, reg_tmp12.xyz);
    // 4: dp3
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp8.xyz);
    // 5: dp3
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp8.xyz);
    // 6: dp3
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp8.xyz);
    // 7: mov
    reg_tmp14.w = (uniforms.f[93].xxxx).w;
    // 8: mov
    reg_tmp8 = reg_tmp14;
    // 9: dp4
    reg_tmp14.x = dot_s(reg_tmp8, reg_tmp8);
    // 10: rsq
    reg_tmp14.x = rsq_s(reg_tmp14.x);
    // 11: mul
    reg_tmp14 = mul_s(reg_tmp8, reg_tmp14.xxxx);
    // 12: mov
    reg_tmp0 = uniforms.f[23];
    // 13: dp3
    reg_tmp8.x = dot_3(uniforms.f[0].xyz, reg_tmp0.xyz);
    // 14: dp3
    reg_tmp8.y = dot_3(uniforms.f[1].xyz, reg_tmp0.xyz);
    // 15: dp3
    reg_tmp8.z = dot_3(uniforms.f[2].xyz, reg_tmp0.xyz);
    // 16: dp3
    reg_tmp6.x = dot_3(uniforms.f[90].xyz, reg_tmp8.xyz);
    // 17: dp3
    reg_tmp6.y = dot_3(uniforms.f[91].xyz, reg_tmp8.xyz);
    // 18: dp3
    reg_tmp6.z = dot_3(uniforms.f[92].xyz, reg_tmp8.xyz);
    // 19: add
    reg_tmp8.xyz = (reg_tmp6.xyzz + reg_tmp1.xyzz).xyz;
    // 20: mov
    reg_tmp8.w = (uniforms.f[93].xxxx).w;
    // 21: dp4
    reg_tmp0.x = dot_s(reg_tmp8, reg_tmp8);
    // 22: rsq
    reg_tmp0.x = rsq_s(reg_tmp0.x);
    // 23: mul
    reg_tmp0 = mul_s(reg_tmp8, reg_tmp0.xxxx);
    // 24: ifu
    if (uniforms.b[5]) {
        sub_25_31();
    }
    // 31: ifu
    if (uniforms.b[3]) {
        sub_32_39();
    }
    // 39: ifu
    if (uniforms.b[4]) {
        sub_40_48();
    }
    // 48: mov
    vs_out_attr3 = reg_tmp2;
    return false;
}
bool sub_25_31() {
    // 25: dp3
    reg_tmp8.x = dot_3(reg_tmp14.xyz, -reg_tmp6.xyz);
    // 26: dp3
    reg_tmp8.y = dot_3(reg_tmp1.xyz, -reg_tmp6.xyz);
    // 27: max
    reg_tmp8 = max(uniforms.f[93].xxxx, reg_tmp8);
    // 28: mul
    reg_tmp8.y = (mul_s(uniforms.f[94].zzzz, reg_tmp8.yyyy)).y;
    // 29: add
    reg_tmp8.y = (uniforms.f[94].zzzz + reg_tmp8.yyyy).y;
    // 30: mul
    reg_tmp2.y = (mul_s(reg_tmp8.xxxx, reg_tmp8.yyyy)).y;
    return false;
}
bool sub_32_39() {
    // 32: dp3
    reg_tmp9.z = dot_3(reg_tmp14.xyz, reg_tmp0.xyz);
    // 33: max
    reg_tmp9.z = (max(uniforms.f[93].xxxx, reg_tmp9.zzzz)).z;
    // 34: min
    reg_tmp9.z = (min(uniforms.f[93].yyyy, reg_tmp9.zzzz)).z;
    // 35: log
    reg_tmp9.z = log2(reg_tmp9.z);
    // 36: mul
    reg_tmp9.z = (mul_s(uniforms.f[22].zzzz, reg_tmp9.zzzz)).z;
    // 37: exp
    reg_tmp9.z = exp2(reg_tmp9.z);
    // 38: mul
    reg_tmp2.z = (mul_s(uniforms.f[22].wwww, reg_tmp9.zzzz)).z;
    return false;
}
bool sub_40_48() {
    // 40: dp3
    reg_tmp9.x = dot_3(reg_tmp14.xyz, reg_tmp1.xyz);
    // 41: max
    reg_tmp9.x = (max(uniforms.f[93].xxxx, reg_tmp9.xxxx)).x;
    // 42: min
    reg_tmp9.x = (min(uniforms.f[93].yyyy, reg_tmp9.xxxx)).x;
    // 43: add
    reg_tmp9.x = (uniforms.f[93].yyyy + -reg_tmp9.xxxx).x;
    // 44: log
    reg_tmp9.x = log2(reg_tmp9.x);
    // 45: mul
    reg_tmp9.x = (mul_s(uniforms.f[22].xxxx, reg_tmp9.xxxx)).x;
    // 46: exp
    reg_tmp9.x = exp2(reg_tmp9.x);
    // 47: mul
    reg_tmp2.w = (mul_s(uniforms.f[22].yyyy, reg_tmp9.xxxx)).w;
    return false;
}
bool sub_175_202() {
    // 175: mov
    reg_tmp0.xy = (uniforms.f[10].xxxx).xy;
    // 176: ifu
    if (uniforms.b[9]) {
        sub_177_182();
    } else {
        sub_182_201();
    }
    // 201: nop
    return false;
}
bool sub_177_182() {
    // 177: call
    {
        sub_242_250();
    }
    // 178: dp4
    reg_tmp3.x = dot_s(uniforms.f[11].xywz, reg_tmp6);
    // 179: dp4
    reg_tmp3.y = dot_s(uniforms.f[12].xywz, reg_tmp6);
    // 180: mov
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    // 181: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_182_201() {
    // 182: cmp
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    // 183: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 184: ifc
    if (all(not(conditional_code))) {
        sub_185_191();
    } else {
        sub_191_200();
    }
    // 200: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_185_191() {
    // 185: mov
    reg_tmp6 = reg_tmp10;
    // 186: dp4
    reg_tmp3.x = dot_s(uniforms.f[11], reg_tmp6);
    // 187: dp4
    reg_tmp3.y = dot_s(uniforms.f[12], reg_tmp6);
    // 188: dp4
    reg_tmp3.z = dot_s(uniforms.f[13], reg_tmp6);
    // 189: mul
    reg_tmp0.xy = (mul_s(uniforms.f[19].xyyy, reg_tmp3.zzzz)).xy;
    // 190: add
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_191_200() {
    // 191: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_192_196();
    } else {
        sub_196_199();
    }
    // 199: nop
    return false;
}
bool sub_192_196() {
    // 192: call
    {
        sub_343_350();
    }
    // 193: dp3
    reg_tmp3.x = dot_3(uniforms.f[11].xyz, reg_tmp6.xyz);
    // 194: dp3
    reg_tmp3.y = dot_3(uniforms.f[12].xyz, reg_tmp6.xyz);
    // 195: dp3
    reg_tmp3.z = dot_3(uniforms.f[13].xyz, reg_tmp6.xyz);
    return false;
}
bool sub_196_199() {
    // 196: call
    {
        sub_350_354();
    }
    // 197: dp4
    reg_tmp3.x = dot_s(uniforms.f[11], reg_tmp6);
    // 198: dp4
    reg_tmp3.y = dot_s(uniforms.f[12], reg_tmp6);
    return false;
}
bool sub_202_226() {
    // 202: mov
    reg_tmp0.xy = (uniforms.f[10].yyyy).xy;
    // 203: ifu
    if (uniforms.b[10]) {
        sub_204_208();
    } else {
        sub_208_225();
    }
    // 225: nop
    return false;
}
bool sub_204_208() {
    // 204: call
    {
        sub_242_250();
    }
    // 205: dp4
    reg_tmp4.x = dot_s(uniforms.f[14].xywz, reg_tmp6);
    // 206: dp4
    reg_tmp4.y = dot_s(uniforms.f[15].xywz, reg_tmp6);
    // 207: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_208_225() {
    // 208: ifu
    if (uniforms.b[13]) {
        sub_209_223();
    } else {
        sub_223_224();
    }
    // 224: nop
    return false;
}
bool sub_209_223() {
    // 209: cmp
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    // 210: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 211: ifc
    if (all(not(conditional_code))) {
        sub_212_219();
    } else {
        sub_219_222();
    }
    // 222: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_212_219() {
    // 212: mov
    reg_tmp6 = reg_tmp10;
    // 213: dp4
    reg_tmp4.x = dot_s(uniforms.f[14], reg_tmp6);
    // 214: dp4
    reg_tmp4.y = dot_s(uniforms.f[15], reg_tmp6);
    // 215: dp4
    reg_tmp4.z = dot_s(uniforms.f[16], reg_tmp6);
    // 216: rcp
    reg_tmp6.w = rcp_s(reg_tmp4.z);
    // 217: mul
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    // 218: add
    reg_tmp4.xy = (uniforms.f[19].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_219_222() {
    // 219: call
    {
        sub_350_354();
    }
    // 220: dp4
    reg_tmp4.x = dot_s(uniforms.f[14], reg_tmp6);
    // 221: dp4
    reg_tmp4.y = dot_s(uniforms.f[15], reg_tmp6);
    return false;
}
bool sub_223_224() {
    // 223: mov
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_226_242() {
    // 226: mov
    reg_tmp0.xy = (uniforms.f[10].zzzz).xy;
    // 227: ifu
    if (uniforms.b[11]) {
        sub_228_232();
    } else {
        sub_232_241();
    }
    // 241: nop
    return false;
}
bool sub_228_232() {
    // 228: call
    {
        sub_242_250();
    }
    // 229: dp4
    reg_tmp5.x = dot_s(uniforms.f[17].xywz, reg_tmp6);
    // 230: dp4
    reg_tmp5.y = dot_s(uniforms.f[18].xywz, reg_tmp6);
    // 231: mov
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_232_241() {
    // 232: ifu
    if (uniforms.b[14]) {
        sub_233_239();
    } else {
        sub_239_240();
    }
    // 240: nop
    return false;
}
bool sub_233_239() {
    // 233: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 234: mov
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    // 235: call
    {
        sub_350_354();
    }
    // 236: dp4
    reg_tmp5.x = dot_s(uniforms.f[17], reg_tmp6);
    // 237: dp4
    reg_tmp5.y = dot_s(uniforms.f[18], reg_tmp6);
    // 238: mov
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_239_240() {
    // 239: mov
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
bool sub_242_250() {
    // 242: cmp
    conditional_code = equal(uniforms.f[93].yz, reg_tmp0.xy);
    // 243: ifc
    if (all(not(conditional_code))) {
        sub_244_245();
    } else {
        sub_245_249();
    }
    // 249: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_244_245() {
    // 244: mul
    reg_tmp6.xy = (mul_s(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
    return false;
}
bool sub_245_249() {
    // 245: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_246_247();
    } else {
        sub_247_248();
    }
    // 248: nop
    return false;
}
bool sub_246_247() {
    // 246: mul
    reg_tmp6.xy = (mul_s(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
    return false;
}
bool sub_247_248() {
    // 247: mul
    reg_tmp6.xy = (mul_s(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
    return false;
}
bool sub_343_350() {
    // 343: mov
    reg_tmp2 = -reg_tmp15;
    // 344: dp3
    reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
    // 345: rsq
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    // 346: mul
    reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
    // 347: dp3
    reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
    // 348: add
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    // 349: mad
    reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_350_354() {
    // 350: mov
    reg_tmp1.xy = (uniforms.f[94].zzzz).xy;
    // 351: mov
    reg_tmp1.zw = (uniforms.f[93].xxxx).zw;
    // 352: mad
    reg_tmp6 = fma_s(reg_tmp14, reg_tmp1, reg_tmp1);
    // 353: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_354_4096() {
    // 354: mov
    reg_tmp0 = vs_in_reg0;
    // 355: mov
    reg_tmp0.z = (uniforms.f[93].xxxx).z;
    // 356: mov
    reg_tmp0.w = (uniforms.f[93].yyyy).w;
    // 357: mov
    vs_out_attr0 = reg_tmp0;
    // 358: mov
    vs_out_attr2 = reg_tmp0;
    // 359: mov
    vs_out_attr1 = reg_tmp0;
    // 360: ifu
    if (uniforms.b[6]) {
        sub_361_363();
    } else {
        sub_363_364();
    }
    // 364: call
    {
        sub_175_202();
    }
    // 365: call
    {
        sub_202_226();
    }
    // 366: call
    {
        sub_226_242();
    }
    // 367: end
    return true;
}
bool sub_361_363() {
    // 361: call
    {
        sub_0_49();
    }
    // 362: nop
    return false;
}
bool sub_363_364() {
    // 363: mov
    vs_out_attr3 = uniforms.f[93].yyyy;
    return false;
}
// reference: A572BCB01EC424BA, 50CFCD58AAA1C3A6
// shader: 8B30, 584EE58D46F0B98C

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp(vec3(dot((texcolor0.rgb) - vec3(0.5), (texcolor1.rgb) - vec3(0.5)) * 4.0), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) + (1.0 - texcolor1.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_1 = byteround(clamp(vec3(dot((texcolor0.rgb) - vec3(0.5), (texcolor2.rgb) - vec3(0.5)) * 4.0), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp(min((texcolor1.a) + (1.0 - texcolor0.a), 1.0) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (combiner_buffer.rgb) + (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp(min((texcolor0.a) + (1.0 - texcolor2.a), 1.0) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp(min((texcolor2.a) + (1.0 - texcolor0.a), 1.0) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a) - (const_color[4].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4 * 1.0, alpha_output_4 * 4.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (last_tex_env_out.aaa) + (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a) - (primary_fragment_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5 * 1.0, alpha_output_5 * 4.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: BAE480A51A8FC20E, 584EE58D46F0B98C
// program: 50CFCD58AAA1C3A6, AD7922A63ED54CA7, 584EE58D46F0B98C
// reference: BF76358E6952708D, DEDDD3577BD6F4B8
// shader: 8B30, 70FA246ED3E2FAD4

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp(vec3(dot((texcolor0.rgb) - vec3(0.5), (texcolor2.rgb) - vec3(0.5)) * 4.0), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp(min((texcolor1.a) + (1.0 - texcolor0.a), 1.0) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (combiner_buffer.rgb) + (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp(min((texcolor0.a) + (1.0 - texcolor2.a), 1.0) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 2E99070DCB85802A, 70FA246ED3E2FAD4
// program: DEDDD3577BD6F4B8, 5D764F9A6220D694, 70FA246ED3E2FAD4
// reference: 6CF5F277B2EBD1CA, DEDDD3577BD6F4B8
// shader: 8B30, 4657CF2A14DE8C15

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp(vec3(dot((texcolor0.rgb) - vec3(0.5), (texcolor2.rgb) - vec3(0.5)) * 4.0), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp(min((texcolor1.a) + (1.0 - texcolor0.a), 1.0) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (combiner_buffer.rgb) + (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp(min((texcolor0.a) + (1.0 - texcolor2.a), 1.0) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 2E99070D3065F193, 4657CF2A14DE8C15
// program: DEDDD3577BD6F4B8, 5D764F9A6220D694, 4657CF2A14DE8C15
// reference: 6CF5F2771BEDC9AF, DEDDD3577BD6F4B8
// shader: 8B31, 7C60AA2AD49029B7

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;
 out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}


#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_19_29();
bool sub_143_151();
bool sub_145_146();
bool sub_146_150();
bool sub_147_148();
bool sub_148_149();
bool sub_166_4096();
bool sub_170_192();
bool sub_192_200();
bool sub_212_213();

bool exec_shader() {
    sub_166_4096();
    return true;
}

bool sub_19_29() {
    // 19: mova
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    // 20: nop
    // 21: dp4
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    // 22: dp4
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    // 23: dp4
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    // 24: dp3
    reg_tmp4.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    // 25: dp3
    reg_tmp4.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    // 26: dp3
    reg_tmp4.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    // 27: mad
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 28: mad
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_143_151() {
    // 143: cmp
    conditional_code = equal(uniforms.f[93].yz, reg_tmp0.xy);
    // 144: ifc
    if (all(not(conditional_code))) {
        sub_145_146();
    } else {
        sub_146_150();
    }
    // 150: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_145_146() {
    // 145: mov
    reg_tmp6.xy = (vs_in_reg4.xyyy).xy;
    return false;
}
bool sub_146_150() {
    // 146: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_147_148();
    } else {
        sub_148_149();
    }
    // 149: nop
    return false;
}
bool sub_147_148() {
    // 147: mov
    reg_tmp6.xy = (vs_in_reg5.xyyy).xy;
    return false;
}
bool sub_148_149() {
    // 148: mov
    reg_tmp6.xy = (vs_in_reg6.xyyy).xy;
    return false;
}
bool sub_166_4096() {
    // 166: mov
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    // 167: mov
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    // 168: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 169: ifu
    if (uniforms.b[0]) {
        sub_170_192();
    } else {
        sub_192_200();
    }
    // 200: dp4
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    // 201: dp4
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    // 202: dp4
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    // 203: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 204: dp4
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    // 205: dp4
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    // 206: dp4
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    // 207: dp4
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    // 208: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 209: mul
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    // 210: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 211: ifc
    if (all(conditional_code)) {
        sub_212_213();
    }
    // 213: mov
    vs_out_attr0 = reg_tmp0;
    // 214: mov
    vs_out_attr1 = uniforms.f[93].xxxx;
    // 215: mov
    vs_out_attr2 = uniforms.f[93].xxxx;
    // 216: mul
    reg_tmp0 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
    // 217: add
    vs_out_attr3 = uniforms.f[94].zzzz + reg_tmp0;
    // 218: dp3
    reg_tmp5.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    // 219: dp3
    reg_tmp5.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    // 220: dp3
    reg_tmp5.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    // 221: dp4
    reg_tmp4.x = dot_s(reg_tmp5.xyzz, reg_tmp5.xyzz);
    // 222: rsq
    reg_tmp4.x = rsq_s(reg_tmp4.x);
    // 223: mul
    reg_tmp4.xyz = (mul_s(reg_tmp5.xyzz, reg_tmp4.xxxx)).xyz;
    // 224: mul
    reg_tmp4 = mul_s(uniforms.f[94].xxxx, reg_tmp4);
    // 225: add
    reg_tmp12 = uniforms.f[94].xxxx + reg_tmp4;
    // 226: mov
    vs_out_attr4 = reg_tmp12;
    // 227: mov
    reg_tmp0.xy = (uniforms.f[0].xxxx).xy;
    // 228: call
    {
        sub_143_151();
    }
    // 229: dp4
    reg_tmp4.x = dot_s(uniforms.f[4].xywz, reg_tmp6);
    // 230: dp4
    reg_tmp4.y = dot_s(uniforms.f[5].xywz, reg_tmp6);
    // 231: mov
    vs_out_attr5 = reg_tmp4;
    // 232: mov
    vs_out_attr6 = reg_tmp4;
    // 233: end
    return true;
}
bool sub_170_192() {
    // 170: mov
    reg_tmp7 = uniforms.f[93].xxxx;
    // 171: mov
    reg_tmp12 = uniforms.f[93].xxxx;
    // 172: mul
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    // 173: cmp
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    // 174: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 175: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    // 176: call
    {
        sub_19_29();
    }
    // 177: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 178: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    // 179: call
    {
        sub_19_29();
    }
    // 180: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 181: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    // 182: callc
    if (conditional_code.x) {
        sub_19_29();
    }
    // 183: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 184: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    // 185: callc
    if (conditional_code.y) {
        sub_19_29();
    }
    // 186: nop
    // 187: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 188: mov
    reg_tmp10 = reg_tmp7;
    // 189: dp3
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    // 190: dp3
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    // 191: dp3
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    return false;
}
bool sub_192_200() {
    // 192: mov
    reg_tmp7 = reg_tmp15;
    // 193: dp4
    reg_tmp10.x = dot_s(uniforms.f[10], reg_tmp7);
    // 194: dp4
    reg_tmp10.y = dot_s(uniforms.f[11], reg_tmp7);
    // 195: dp4
    reg_tmp10.z = dot_s(uniforms.f[12], reg_tmp7);
    // 196: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 197: dp4
    reg_tmp12.x = dot_s(uniforms.f[10], reg_tmp14);
    // 198: dp4
    reg_tmp12.y = dot_s(uniforms.f[11], reg_tmp14);
    // 199: dp4
    reg_tmp12.z = dot_s(uniforms.f[12], reg_tmp14);
    return false;
}
bool sub_212_213() {
    // 212: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
// reference: 8724C28E32DA6F21, 7C60AA2AD49029B7
// shader: 8B30, 26D8D217AE804C43

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) + (const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].aaa) + (const_color[1].rgb) * (vec3(1.0) - (const_color[1].aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (const_color[2].a) + (const_color[2].r) * (1.0 - (const_color[2].a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((texcolor1.a) * (const_color[3].a) + (texcolor1.r) * (1.0 - (const_color[3].a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a) * (combiner_buffer.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D3310DE0F23CD476, 26D8D217AE804C43
// program: 7C60AA2AD49029B7, AD7922A63ED54CA7, 26D8D217AE804C43
// reference: 54A705774065D603, 7C60AA2AD49029B7
// shader: 8B31, FD6581EE07E13BFE

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;
 out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}


#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_19();
bool sub_19_29();
bool sub_29_79();
bool sub_34_52();
bool sub_52_60();
bool sub_77_78();
bool sub_79_106();
bool sub_81_86();
bool sub_86_105();
bool sub_89_95();
bool sub_95_104();
bool sub_96_100();
bool sub_100_103();
bool sub_106_130();
bool sub_108_112();
bool sub_112_129();
bool sub_113_127();
bool sub_116_123();
bool sub_123_126();
bool sub_127_128();
bool sub_130_146();
bool sub_132_136();
bool sub_136_145();
bool sub_137_143();
bool sub_143_144();
bool sub_146_154();
bool sub_148_149();
bool sub_149_153();
bool sub_150_151();
bool sub_151_152();
bool sub_154_161();
bool sub_161_167();
bool sub_167_4096();

bool exec_shader() {
    sub_167_4096();
    return true;
}

bool sub_0_19() {
    uint jmp_to = 0u;
    while (true) {
        switch (jmp_to) {
        case 0u: {
            // 0: dp3
            reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
            // 1: dp3
            reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
            // 2: dp3
            reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
            // 3: dp3
            reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
            // 4: dp3
            reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
            // 5: rsq
            reg_tmp6.x = rsq_s(reg_tmp6.x);
            // 6: rsq
            reg_tmp7.x = rsq_s(reg_tmp7.x);
            // 7: mul
            reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 8: mul
            reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 9: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 10: add
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            // 11: mul
            reg_tmp4 = mul_s(uniforms.f[94].xxxx, reg_tmp4);
            // 12: cmp
            conditional_code = greaterThanEqual(uniforms.f[93].xx, reg_tmp4.xx);
            // 13: rsq
            reg_tmp4 = vec4(rsq_s(reg_tmp4.x));
            // 14: mul
            reg_tmp5 = mul_s(uniforms.f[94].xxxx, reg_tmp14);
            // 15: jmpc
            if (conditional_code.x) {
                { jmp_to = 18u; break; }
            }
            // 16: rcp
            reg_tmp0.z = rcp_s(reg_tmp4.x);
            // 17: mul
            reg_tmp0.xy = (mul_s(reg_tmp5, reg_tmp4)).xy;
        }
        case 18u: {
            // 18: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_19_29() {
    // 19: mova
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    // 20: nop
    // 21: dp4
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    // 22: dp4
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    // 23: dp4
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    // 24: dp3
    reg_tmp4.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    // 25: dp3
    reg_tmp4.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    // 26: dp3
    reg_tmp4.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    // 27: mad
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 28: mad
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_29_79() {
    // 29: mov
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    // 30: mov
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    // 31: mov
    reg_tmp13.xyz = (vs_in_reg2).xyz;
    // 32: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 33: ifu
    if (uniforms.b[0]) {
        sub_34_52();
    } else {
        sub_52_60();
    }
    // 60: dp3
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    // 61: dp3
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    // 62: dp3
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    // 63: call
    {
        sub_0_19();
    }
    // 64: dp4
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    // 65: dp4
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    // 66: dp4
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    // 67: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 68: mov
    vs_out_attr2 = -reg_tmp15;
    // 69: dp4
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    // 70: dp4
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    // 71: dp4
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    // 72: dp4
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    // 73: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 74: mul
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    // 75: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 76: ifc
    if (all(conditional_code)) {
        sub_77_78();
    }
    // 78: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_34_52() {
    // 34: mov
    reg_tmp7 = uniforms.f[93].xxxx;
    // 35: mov
    reg_tmp12 = uniforms.f[93].xxxx;
    // 36: mul
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    // 37: cmp
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    // 38: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 39: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    // 40: call
    {
        sub_19_29();
    }
    // 41: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 42: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    // 43: call
    {
        sub_19_29();
    }
    // 44: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 45: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    // 46: call
    {
        sub_19_29();
    }
    // 47: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 48: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    // 49: call
    {
        sub_19_29();
    }
    // 50: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 51: mov
    reg_tmp10 = reg_tmp7;
    return false;
}
bool sub_52_60() {
    // 52: mov
    reg_tmp7 = reg_tmp15;
    // 53: dp4
    reg_tmp10.x = dot_s(uniforms.f[10], reg_tmp7);
    // 54: dp4
    reg_tmp10.y = dot_s(uniforms.f[11], reg_tmp7);
    // 55: dp4
    reg_tmp10.z = dot_s(uniforms.f[12], reg_tmp7);
    // 56: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 57: dp3
    reg_tmp12.x = dot_3(uniforms.f[10].xyz, reg_tmp14.xyz);
    // 58: dp3
    reg_tmp12.y = dot_3(uniforms.f[11].xyz, reg_tmp14.xyz);
    // 59: dp3
    reg_tmp12.z = dot_3(uniforms.f[12].xyz, reg_tmp14.xyz);
    return false;
}
bool sub_77_78() {
    // 77: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_79_106() {
    // 79: mov
    reg_tmp0.xy = (uniforms.f[0].xxxx).xy;
    // 80: ifu
    if (uniforms.b[2]) {
        sub_81_86();
    } else {
        sub_86_105();
    }
    // 105: nop
    return false;
}
bool sub_81_86() {
    // 81: call
    {
        sub_146_154();
    }
    // 82: dp4
    reg_tmp3.x = dot_s(uniforms.f[1].xywz, reg_tmp6);
    // 83: dp4
    reg_tmp3.y = dot_s(uniforms.f[2].xywz, reg_tmp6);
    // 84: mov
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    // 85: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_86_105() {
    // 86: cmp
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    // 87: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 88: ifc
    if (all(not(conditional_code))) {
        sub_89_95();
    } else {
        sub_95_104();
    }
    // 104: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_89_95() {
    // 89: mov
    reg_tmp6 = reg_tmp10;
    // 90: dp4
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    // 91: dp4
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    // 92: dp4
    reg_tmp3.z = dot_s(uniforms.f[3], reg_tmp6);
    // 93: mul
    reg_tmp0.xy = (mul_s(uniforms.f[9].xyyy, reg_tmp3.zzzz)).xy;
    // 94: add
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_95_104() {
    // 95: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_96_100();
    } else {
        sub_100_103();
    }
    // 103: nop
    return false;
}
bool sub_96_100() {
    // 96: call
    {
        sub_154_161();
    }
    // 97: dp3
    reg_tmp3.x = dot_3(uniforms.f[1].xyz, reg_tmp6.xyz);
    // 98: dp3
    reg_tmp3.y = dot_3(uniforms.f[2].xyz, reg_tmp6.xyz);
    // 99: dp3
    reg_tmp3.z = dot_3(uniforms.f[3].xyz, reg_tmp6.xyz);
    return false;
}
bool sub_100_103() {
    // 100: call
    {
        sub_161_167();
    }
    // 101: dp4
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    // 102: dp4
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    return false;
}
bool sub_106_130() {
    // 106: mov
    reg_tmp0.xy = (uniforms.f[0].yyyy).xy;
    // 107: ifu
    if (uniforms.b[3]) {
        sub_108_112();
    } else {
        sub_112_129();
    }
    // 129: nop
    return false;
}
bool sub_108_112() {
    // 108: call
    {
        sub_146_154();
    }
    // 109: dp4
    reg_tmp4.x = dot_s(uniforms.f[4].xywz, reg_tmp6);
    // 110: dp4
    reg_tmp4.y = dot_s(uniforms.f[5].xywz, reg_tmp6);
    // 111: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_112_129() {
    // 112: ifu
    if (uniforms.b[5]) {
        sub_113_127();
    } else {
        sub_127_128();
    }
    // 128: nop
    return false;
}
bool sub_113_127() {
    // 113: cmp
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    // 114: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 115: ifc
    if (all(not(conditional_code))) {
        sub_116_123();
    } else {
        sub_123_126();
    }
    // 126: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_116_123() {
    // 116: mov
    reg_tmp6 = reg_tmp10;
    // 117: dp4
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    // 118: dp4
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    // 119: dp4
    reg_tmp4.z = dot_s(uniforms.f[6], reg_tmp6);
    // 120: rcp
    reg_tmp6.w = rcp_s(reg_tmp4.z);
    // 121: mul
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    // 122: add
    reg_tmp4.xy = (uniforms.f[9].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_123_126() {
    // 123: call
    {
        sub_161_167();
    }
    // 124: dp4
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    // 125: dp4
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    return false;
}
bool sub_127_128() {
    // 127: mov
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_130_146() {
    // 130: mov
    reg_tmp0.xy = (uniforms.f[0].zzzz).xy;
    // 131: ifu
    if (uniforms.b[4]) {
        sub_132_136();
    } else {
        sub_136_145();
    }
    // 145: nop
    return false;
}
bool sub_132_136() {
    // 132: call
    {
        sub_146_154();
    }
    // 133: dp4
    reg_tmp5.x = dot_s(uniforms.f[7].xywz, reg_tmp6);
    // 134: dp4
    reg_tmp5.y = dot_s(uniforms.f[8].xywz, reg_tmp6);
    // 135: mov
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_136_145() {
    // 136: ifu
    if (uniforms.b[6]) {
        sub_137_143();
    } else {
        sub_143_144();
    }
    // 144: nop
    return false;
}
bool sub_137_143() {
    // 137: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 138: mov
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    // 139: call
    {
        sub_161_167();
    }
    // 140: dp4
    reg_tmp5.x = dot_s(uniforms.f[7], reg_tmp6);
    // 141: dp4
    reg_tmp5.y = dot_s(uniforms.f[8], reg_tmp6);
    // 142: mov
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_143_144() {
    // 143: mov
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
bool sub_146_154() {
    // 146: cmp
    conditional_code = equal(uniforms.f[93].yz, reg_tmp0.xy);
    // 147: ifc
    if (all(not(conditional_code))) {
        sub_148_149();
    } else {
        sub_149_153();
    }
    // 153: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_148_149() {
    // 148: mov
    reg_tmp6.xy = (vs_in_reg4.xyyy).xy;
    return false;
}
bool sub_149_153() {
    // 149: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_150_151();
    } else {
        sub_151_152();
    }
    // 152: nop
    return false;
}
bool sub_150_151() {
    // 150: mov
    reg_tmp6.xy = (vs_in_reg5.xyyy).xy;
    return false;
}
bool sub_151_152() {
    // 151: mov
    reg_tmp6.xy = (vs_in_reg6.xyyy).xy;
    return false;
}
bool sub_154_161() {
    // 154: mov
    reg_tmp2 = -reg_tmp15;
    // 155: dp3
    reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
    // 156: rsq
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    // 157: mul
    reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
    // 158: dp3
    reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
    // 159: add
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    // 160: mad
    reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_161_167() {
    // 161: mov
    reg_tmp1 = reg_tmp14;
    // 162: dp3
    reg_tmp2.w = dot_3(reg_tmp1.xyz, reg_tmp1.xyz);
    // 163: rsq
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    // 164: mul
    reg_tmp1 = mul_s(reg_tmp1, reg_tmp2.wwww);
    // 165: mul
    reg_tmp1 = mul_s(uniforms.f[94].xxxx, reg_tmp1);
    // 166: add
    reg_tmp6.xy = (uniforms.f[94].xxxx + reg_tmp1.xyyy).xy;
    return false;
}
bool sub_167_4096() {
    // 167: call
    {
        sub_29_79();
    }
    // 168: mul
    reg_tmp2 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
    // 169: mov
    reg_tmp1.xyz = (uniforms.f[93].xxyx).xyz;
    // 170: dp3
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    // 171: dp3
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    // 172: dp3
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    // 173: mov
    reg_tmp14.w = (uniforms.f[93].xxxx).w;
    // 174: mov
    reg_tmp8 = reg_tmp14;
    // 175: dp4
    reg_tmp14.x = dot_s(reg_tmp8, reg_tmp8);
    // 176: rsq
    reg_tmp14.x = rsq_s(reg_tmp14.x);
    // 177: mul
    reg_tmp14 = mul_s(reg_tmp8, reg_tmp14.xxxx);
    // 178: dp3
    reg_tmp9.x = dot_3(reg_tmp14.xyz, reg_tmp1.xyz);
    // 179: max
    reg_tmp9.x = (max(uniforms.f[93].xxxx, reg_tmp9.xxxx)).x;
    // 180: min
    reg_tmp9.x = (min(uniforms.f[93].yyyy, reg_tmp9.xxxx)).x;
    // 181: add
    reg_tmp9.x = (uniforms.f[93].yyyy + -reg_tmp9.xxxx).x;
    // 182: log
    reg_tmp9.x = log2(reg_tmp9.x);
    // 183: mul
    reg_tmp9.x = (mul_s(uniforms.f[82].xxxx, reg_tmp9.xxxx)).x;
    // 184: exp
    reg_tmp9.x = exp2(reg_tmp9.x);
    // 185: mul
    reg_tmp2.w = (mul_s(uniforms.f[82].yyyy, reg_tmp9.xxxx)).w;
    // 186: mov
    vs_out_attr3 = reg_tmp2;
    // 187: call
    {
        sub_79_106();
    }
    // 188: call
    {
        sub_106_130();
    }
    // 189: call
    {
        sub_130_146();
    }
    // 190: end
    return true;
}
// reference: 5C640A057F0309FC, FD6581EE07E13BFE
// shader: 8B30, 8F138D56CDB426A3

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(light_vector, normal)));
refl_value.g = (lut_scale_rg * LookupLightingLUTSigned(5, dot(light_vector, normal)));
refl_value.b = (lut_scale_rb * LookupLightingLUTSigned(4, dot(light_vector, normal)));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((secondary_fragment_color.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((secondary_fragment_color.ggg) * (last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) + (texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 5000F68D161C7DA9, 8F138D56CDB426A3
// program: FD6581EE07E13BFE, AD7922A63ED54CA7, 8F138D56CDB426A3
// reference: 8FE7CDFC0DBCB0DE, FD6581EE07E13BFE
// shader: 8B31, 6038F426E3FD9783

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;
 out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}


#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_19();
bool sub_19_55();
bool sub_55_65();
bool sub_65_79();
bool sub_79_129();
bool sub_84_102();
bool sub_102_110();
bool sub_127_128();
bool sub_129_185();
bool sub_134_152();
bool sub_152_163();
bool sub_183_184();
bool sub_185_212();
bool sub_187_192();
bool sub_192_211();
bool sub_195_201();
bool sub_201_210();
bool sub_202_206();
bool sub_206_209();
bool sub_212_236();
bool sub_214_218();
bool sub_218_235();
bool sub_219_233();
bool sub_222_229();
bool sub_229_232();
bool sub_233_234();
bool sub_236_252();
bool sub_238_242();
bool sub_242_251();
bool sub_243_249();
bool sub_249_250();
bool sub_252_260();
bool sub_254_255();
bool sub_255_259();
bool sub_256_257();
bool sub_257_258();
bool sub_260_267();
bool sub_267_273();
bool sub_273_4096();
bool sub_274_276();
bool sub_276_278();
bool sub_279_286();
bool sub_286_287();

bool exec_shader() {
    sub_273_4096();
    return true;
}

bool sub_0_19() {
    uint jmp_to = 0u;
    while (true) {
        switch (jmp_to) {
        case 0u: {
            // 0: dp3
            reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
            // 1: dp3
            reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
            // 2: dp3
            reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
            // 3: dp3
            reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
            // 4: dp3
            reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
            // 5: rsq
            reg_tmp6.x = rsq_s(reg_tmp6.x);
            // 6: rsq
            reg_tmp7.x = rsq_s(reg_tmp7.x);
            // 7: mul
            reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 8: mul
            reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 9: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 10: add
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            // 11: mul
            reg_tmp4 = mul_s(uniforms.f[94].xxxx, reg_tmp4);
            // 12: cmp
            conditional_code = greaterThanEqual(uniforms.f[93].xx, reg_tmp4.xx);
            // 13: rsq
            reg_tmp4 = vec4(rsq_s(reg_tmp4.x));
            // 14: mul
            reg_tmp5 = mul_s(uniforms.f[94].xxxx, reg_tmp14);
            // 15: jmpc
            if (conditional_code.x) {
                { jmp_to = 18u; break; }
            }
            // 16: rcp
            reg_tmp0.z = rcp_s(reg_tmp4.x);
            // 17: mul
            reg_tmp0.xy = (mul_s(reg_tmp5, reg_tmp4)).xy;
        }
        case 18u: {
            // 18: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_19_55() {
    uint jmp_to = 19u;
    while (true) {
        switch (jmp_to) {
        case 19u: {
            // 19: dp3
            reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
            // 20: dp3
            reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
            // 21: rsq
            reg_tmp6.x = rsq_s(reg_tmp6.x);
            // 22: rsq
            reg_tmp7.x = rsq_s(reg_tmp7.x);
            // 23: mul
            reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 24: mul
            reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 25: mul
            reg_tmp13.xyz = (mul_s(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            // 26: mul
            reg_tmp11.xyz = (mul_s(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            // 27: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 28: mul
            reg_tmp13.xyz = (mul_s(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            // 29: mul
            reg_tmp11.xyz = (mul_s(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            // 30: mul
            reg_tmp5 = mul_s(reg_tmp14.yzxx, reg_tmp13.zxyy);
            // 31: mad
            reg_tmp5 = fma_s(-reg_tmp13.yzxx, reg_tmp14.zxyy, reg_tmp5);
            // 32: dp3
            reg_tmp5.w = dot_3(reg_tmp5.xyz, reg_tmp5.xyz);
            // 33: rsq
            reg_tmp5.w = rsq_s(reg_tmp5.w);
            // 34: mul
            reg_tmp5 = mul_s(reg_tmp5, reg_tmp5.wwww);
            // 35: add
            reg_tmp6.w = (reg_tmp14.zzzz + reg_tmp5.yyyy).w;
            // 36: mul
            reg_tmp13 = mul_s(reg_tmp5.yzxx, reg_tmp14.zxyy);
            // 37: mad
            reg_tmp13 = fma_s(-reg_tmp14.yzxx, reg_tmp5.zxyy, reg_tmp13);
            // 38: add
            reg_tmp6.w = (reg_tmp13.xxxx + reg_tmp6).w;
            // 39: mov
            reg_tmp13.w = (reg_tmp5.zzzz).w;
            // 40: mov
            reg_tmp5.z = (reg_tmp13.xxxx).z;
            // 41: add
            reg_tmp6.w = (uniforms.f[93].yyyy + reg_tmp6).w;
            // 42: mov
            reg_tmp14.w = (reg_tmp5.xxxx).w;
            // 43: mov
            reg_tmp5.x = (reg_tmp14.zzzz).x;
            // 44: cmp
            conditional_code = lessThan(uniforms.f[94].zz, reg_tmp6.ww);
            // 45: mov
            reg_tmp6.x = (uniforms.f[93].yyyy).x;
            // 46: mov
            reg_tmp6.y = (-uniforms.f[93].yyyy).y;
            // 47: jmpc
            if (!conditional_code.x) {
                { jmp_to = 54u; break; }
            }
            // 48: add
            reg_tmp7.xz = (reg_tmp13.wwyy + -reg_tmp14.yyww).xz;
            // 49: add
            reg_tmp7.y = (reg_tmp14.xxxx + -reg_tmp13.zzzz).y;
            // 50: mov
            reg_tmp7.w = (reg_tmp6).w;
            // 51: dp4
            reg_tmp6 = vec4(dot_s(reg_tmp7, reg_tmp7));
            // 52: rsq
            reg_tmp6 = vec4(rsq_s(reg_tmp6.x));
            // 53: mul
            reg_tmp0 = mul_s(reg_tmp7, reg_tmp6);
        }
        case 54u: {
            // 54: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_55_65() {
    // 55: mova
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    // 56: nop
    // 57: dp4
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    // 58: dp4
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    // 59: dp4
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    // 60: dp3
    reg_tmp4.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    // 61: dp3
    reg_tmp4.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    // 62: dp3
    reg_tmp4.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    // 63: mad
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 64: mad
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_65_79() {
    // 65: mova
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    // 66: nop
    // 67: dp4
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    // 68: dp4
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    // 69: dp4
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    // 70: dp3
    reg_tmp4.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    // 71: dp3
    reg_tmp4.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    // 72: dp3
    reg_tmp4.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    // 73: dp3
    reg_tmp5.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp13.xyz);
    // 74: dp3
    reg_tmp5.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp13.xyz);
    // 75: dp3
    reg_tmp5.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp13.xyz);
    // 76: mad
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 77: mad
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    // 78: mad
    reg_tmp11 = fma_s(reg_tmp1.wwww, reg_tmp5, reg_tmp11);
    return false;
}
bool sub_79_129() {
    // 79: mov
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    // 80: mov
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    // 81: mov
    reg_tmp13.xyz = (vs_in_reg2).xyz;
    // 82: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 83: ifu
    if (uniforms.b[0]) {
        sub_84_102();
    } else {
        sub_102_110();
    }
    // 110: dp3
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    // 111: dp3
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    // 112: dp3
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    // 113: call
    {
        sub_0_19();
    }
    // 114: dp4
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    // 115: dp4
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    // 116: dp4
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    // 117: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 118: mov
    vs_out_attr2 = -reg_tmp15;
    // 119: dp4
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    // 120: dp4
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    // 121: dp4
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    // 122: dp4
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    // 123: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 124: mul
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    // 125: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 126: ifc
    if (all(conditional_code)) {
        sub_127_128();
    }
    // 128: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_84_102() {
    // 84: mov
    reg_tmp7 = uniforms.f[93].xxxx;
    // 85: mov
    reg_tmp12 = uniforms.f[93].xxxx;
    // 86: mul
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    // 87: cmp
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    // 88: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 89: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    // 90: call
    {
        sub_55_65();
    }
    // 91: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 92: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    // 93: call
    {
        sub_55_65();
    }
    // 94: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 95: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    // 96: call
    {
        sub_55_65();
    }
    // 97: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 98: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    // 99: call
    {
        sub_55_65();
    }
    // 100: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 101: mov
    reg_tmp10 = reg_tmp7;
    return false;
}
bool sub_102_110() {
    // 102: mov
    reg_tmp7 = reg_tmp15;
    // 103: dp4
    reg_tmp10.x = dot_s(uniforms.f[10], reg_tmp7);
    // 104: dp4
    reg_tmp10.y = dot_s(uniforms.f[11], reg_tmp7);
    // 105: dp4
    reg_tmp10.z = dot_s(uniforms.f[12], reg_tmp7);
    // 106: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 107: dp3
    reg_tmp12.x = dot_3(uniforms.f[10].xyz, reg_tmp14.xyz);
    // 108: dp3
    reg_tmp12.y = dot_3(uniforms.f[11].xyz, reg_tmp14.xyz);
    // 109: dp3
    reg_tmp12.z = dot_3(uniforms.f[12].xyz, reg_tmp14.xyz);
    return false;
}
bool sub_127_128() {
    // 127: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_129_185() {
    // 129: mov
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    // 130: mov
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    // 131: mov
    reg_tmp13.xyz = (vs_in_reg2).xyz;
    // 132: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 133: ifu
    if (uniforms.b[0]) {
        sub_134_152();
    } else {
        sub_152_163();
    }
    // 163: dp3
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    // 164: dp3
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    // 165: dp3
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    // 166: dp3
    reg_tmp13.x = dot_3(uniforms.f[90].xyz, reg_tmp11.xyz);
    // 167: dp3
    reg_tmp13.y = dot_3(uniforms.f[91].xyz, reg_tmp11.xyz);
    // 168: dp3
    reg_tmp13.z = dot_3(uniforms.f[92].xyz, reg_tmp11.xyz);
    // 169: call
    {
        sub_19_55();
    }
    // 170: dp4
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    // 171: dp4
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    // 172: dp4
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    // 173: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 174: mov
    vs_out_attr2 = -reg_tmp15;
    // 175: dp4
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    // 176: dp4
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    // 177: dp4
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    // 178: dp4
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    // 179: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 180: mul
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    // 181: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 182: ifc
    if (all(conditional_code)) {
        sub_183_184();
    }
    // 184: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_134_152() {
    // 134: mov
    reg_tmp7 = uniforms.f[93].xxxx;
    // 135: mov
    reg_tmp12 = uniforms.f[93].xxxx;
    // 136: mul
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    // 137: cmp
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    // 138: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 139: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    // 140: call
    {
        sub_65_79();
    }
    // 141: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 142: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    // 143: call
    {
        sub_65_79();
    }
    // 144: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 145: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    // 146: call
    {
        sub_65_79();
    }
    // 147: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 148: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    // 149: call
    {
        sub_65_79();
    }
    // 150: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 151: mov
    reg_tmp10 = reg_tmp7;
    return false;
}
bool sub_152_163() {
    // 152: mov
    reg_tmp7 = reg_tmp15;
    // 153: dp4
    reg_tmp10.x = dot_s(uniforms.f[10], reg_tmp7);
    // 154: dp4
    reg_tmp10.y = dot_s(uniforms.f[11], reg_tmp7);
    // 155: dp4
    reg_tmp10.z = dot_s(uniforms.f[12], reg_tmp7);
    // 156: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 157: dp3
    reg_tmp12.x = dot_3(uniforms.f[10].xyz, reg_tmp14.xyz);
    // 158: dp3
    reg_tmp12.y = dot_3(uniforms.f[11].xyz, reg_tmp14.xyz);
    // 159: dp3
    reg_tmp12.z = dot_3(uniforms.f[12].xyz, reg_tmp14.xyz);
    // 160: dp3
    reg_tmp11.x = dot_3(uniforms.f[10].xyz, reg_tmp13.xyz);
    // 161: dp3
    reg_tmp11.y = dot_3(uniforms.f[11].xyz, reg_tmp13.xyz);
    // 162: dp3
    reg_tmp11.z = dot_3(uniforms.f[12].xyz, reg_tmp13.xyz);
    return false;
}
bool sub_183_184() {
    // 183: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_185_212() {
    // 185: mov
    reg_tmp0.xy = (uniforms.f[0].xxxx).xy;
    // 186: ifu
    if (uniforms.b[2]) {
        sub_187_192();
    } else {
        sub_192_211();
    }
    // 211: nop
    return false;
}
bool sub_187_192() {
    // 187: call
    {
        sub_252_260();
    }
    // 188: dp4
    reg_tmp3.x = dot_s(uniforms.f[1].xywz, reg_tmp6);
    // 189: dp4
    reg_tmp3.y = dot_s(uniforms.f[2].xywz, reg_tmp6);
    // 190: mov
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    // 191: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_192_211() {
    // 192: cmp
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    // 193: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 194: ifc
    if (all(not(conditional_code))) {
        sub_195_201();
    } else {
        sub_201_210();
    }
    // 210: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_195_201() {
    // 195: mov
    reg_tmp6 = reg_tmp10;
    // 196: dp4
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    // 197: dp4
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    // 198: dp4
    reg_tmp3.z = dot_s(uniforms.f[3], reg_tmp6);
    // 199: mul
    reg_tmp0.xy = (mul_s(uniforms.f[9].xyyy, reg_tmp3.zzzz)).xy;
    // 200: add
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_201_210() {
    // 201: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_202_206();
    } else {
        sub_206_209();
    }
    // 209: nop
    return false;
}
bool sub_202_206() {
    // 202: call
    {
        sub_260_267();
    }
    // 203: dp3
    reg_tmp3.x = dot_3(uniforms.f[1].xyz, reg_tmp6.xyz);
    // 204: dp3
    reg_tmp3.y = dot_3(uniforms.f[2].xyz, reg_tmp6.xyz);
    // 205: dp3
    reg_tmp3.z = dot_3(uniforms.f[3].xyz, reg_tmp6.xyz);
    return false;
}
bool sub_206_209() {
    // 206: call
    {
        sub_267_273();
    }
    // 207: dp4
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    // 208: dp4
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    return false;
}
bool sub_212_236() {
    // 212: mov
    reg_tmp0.xy = (uniforms.f[0].yyyy).xy;
    // 213: ifu
    if (uniforms.b[3]) {
        sub_214_218();
    } else {
        sub_218_235();
    }
    // 235: nop
    return false;
}
bool sub_214_218() {
    // 214: call
    {
        sub_252_260();
    }
    // 215: dp4
    reg_tmp4.x = dot_s(uniforms.f[4].xywz, reg_tmp6);
    // 216: dp4
    reg_tmp4.y = dot_s(uniforms.f[5].xywz, reg_tmp6);
    // 217: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_218_235() {
    // 218: ifu
    if (uniforms.b[5]) {
        sub_219_233();
    } else {
        sub_233_234();
    }
    // 234: nop
    return false;
}
bool sub_219_233() {
    // 219: cmp
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    // 220: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 221: ifc
    if (all(not(conditional_code))) {
        sub_222_229();
    } else {
        sub_229_232();
    }
    // 232: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_222_229() {
    // 222: mov
    reg_tmp6 = reg_tmp10;
    // 223: dp4
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    // 224: dp4
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    // 225: dp4
    reg_tmp4.z = dot_s(uniforms.f[6], reg_tmp6);
    // 226: rcp
    reg_tmp6.w = rcp_s(reg_tmp4.z);
    // 227: mul
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    // 228: add
    reg_tmp4.xy = (uniforms.f[9].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_229_232() {
    // 229: call
    {
        sub_267_273();
    }
    // 230: dp4
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    // 231: dp4
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    return false;
}
bool sub_233_234() {
    // 233: mov
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_236_252() {
    // 236: mov
    reg_tmp0.xy = (uniforms.f[0].zzzz).xy;
    // 237: ifu
    if (uniforms.b[4]) {
        sub_238_242();
    } else {
        sub_242_251();
    }
    // 251: nop
    return false;
}
bool sub_238_242() {
    // 238: call
    {
        sub_252_260();
    }
    // 239: dp4
    reg_tmp5.x = dot_s(uniforms.f[7].xywz, reg_tmp6);
    // 240: dp4
    reg_tmp5.y = dot_s(uniforms.f[8].xywz, reg_tmp6);
    // 241: mov
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_242_251() {
    // 242: ifu
    if (uniforms.b[6]) {
        sub_243_249();
    } else {
        sub_249_250();
    }
    // 250: nop
    return false;
}
bool sub_243_249() {
    // 243: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 244: mov
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    // 245: call
    {
        sub_267_273();
    }
    // 246: dp4
    reg_tmp5.x = dot_s(uniforms.f[7], reg_tmp6);
    // 247: dp4
    reg_tmp5.y = dot_s(uniforms.f[8], reg_tmp6);
    // 248: mov
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_249_250() {
    // 249: mov
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
bool sub_252_260() {
    // 252: cmp
    conditional_code = equal(uniforms.f[93].yz, reg_tmp0.xy);
    // 253: ifc
    if (all(not(conditional_code))) {
        sub_254_255();
    } else {
        sub_255_259();
    }
    // 259: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_254_255() {
    // 254: mov
    reg_tmp6.xy = (vs_in_reg4.xyyy).xy;
    return false;
}
bool sub_255_259() {
    // 255: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_256_257();
    } else {
        sub_257_258();
    }
    // 258: nop
    return false;
}
bool sub_256_257() {
    // 256: mov
    reg_tmp6.xy = (vs_in_reg5.xyyy).xy;
    return false;
}
bool sub_257_258() {
    // 257: mov
    reg_tmp6.xy = (vs_in_reg6.xyyy).xy;
    return false;
}
bool sub_260_267() {
    // 260: mov
    reg_tmp2 = -reg_tmp15;
    // 261: dp3
    reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
    // 262: rsq
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    // 263: mul
    reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
    // 264: dp3
    reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
    // 265: add
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    // 266: mad
    reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_267_273() {
    // 267: mov
    reg_tmp1 = reg_tmp14;
    // 268: dp3
    reg_tmp2.w = dot_3(reg_tmp1.xyz, reg_tmp1.xyz);
    // 269: rsq
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    // 270: mul
    reg_tmp1 = mul_s(reg_tmp1, reg_tmp2.wwww);
    // 271: mul
    reg_tmp1 = mul_s(uniforms.f[94].xxxx, reg_tmp1);
    // 272: add
    reg_tmp6.xy = (uniforms.f[94].xxxx + reg_tmp1.xyyy).xy;
    return false;
}
bool sub_273_4096() {
    // 273: ifu
    if (uniforms.b[10]) {
        sub_274_276();
    } else {
        sub_276_278();
    }
    // 278: ifu
    if (uniforms.b[1]) {
        sub_279_286();
    } else {
        sub_286_287();
    }
    // 287: mov
    vs_out_attr3 = reg_tmp2;
    // 288: call
    {
        sub_185_212();
    }
    // 289: call
    {
        sub_212_236();
    }
    // 290: call
    {
        sub_236_252();
    }
    // 291: end
    return true;
}
bool sub_274_276() {
    // 274: call
    {
        sub_129_185();
    }
    // 275: nop
    return false;
}
bool sub_276_278() {
    // 276: call
    {
        sub_79_129();
    }
    // 277: nop
    return false;
}
bool sub_279_286() {
    // 279: dp3
    reg_tmp0 = vec4(dot_3(uniforms.f[83].xyz, reg_tmp12.xyz));
    // 280: max
    reg_tmp0 = max(uniforms.f[93].xxxx, reg_tmp0);
    // 281: mul
    reg_tmp0 = mul_s(uniforms.f[84], reg_tmp0);
    // 282: add
    reg_tmp0 = uniforms.f[85] + reg_tmp0;
    // 283: mov
    reg_tmp0.w = (uniforms.f[93].yyyy).w;
    // 284: mul
    reg_tmp1 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
    // 285: mul
    reg_tmp2 = mul_s(reg_tmp0, reg_tmp1);
    return false;
}
bool sub_286_287() {
    // 286: mul
    reg_tmp2 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
    return false;
}
// reference: 9D04A1EB1F314CEC, 6038F426E3FD9783
// shader: 8B30, 60942A308DA395BE

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor1.aaa) * (texcolor1.aaa), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.aaa), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) + (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: FBEC36122394C1DC, 60942A308DA395BE
// program: 6038F426E3FD9783, AD7922A63ED54CA7, 60942A308DA395BE
// reference: 4E8766126D8EF5CE, 6038F426E3FD9783
// shader: 8B30, 215F8EECD665CA41

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 2C801EA34245A1AF, 215F8EECD665CA41
// program: 6038F426E3FD9783, AD7922A63ED54CA7, 215F8EECD665CA41
// shader: 8B30, 5366E62DF9CFDB1A

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (texcolor1.rgb) + (texcolor2.rgb) * (vec3(1.0) - (texcolor1.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 88F70EAB2A0DD9B5, 5366E62DF9CFDB1A
// program: 6038F426E3FD9783, AD7922A63ED54CA7, 5366E62DF9CFDB1A
// reference: 4E8766122BB17EEA, 6038F426E3FD9783
// shader: 8B30, 13ECDA4EF04264FE

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 186E808133587B0D, 13ECDA4EF04264FE
// program: 6038F426E3FD9783, AD7922A63ED54CA7, 13ECDA4EF04264FE
// shader: 8B30, 8D34F09646FED1BF

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor1.g) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (texcolor1.rrr) + (const_color[2].rgb) * (vec3(1.0) - (texcolor1.rrr)), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 4CD3A9AD9C30D273, 8D34F09646FED1BF
// program: 6038F426E3FD9783, AD7922A63ED54CA7, 8D34F09646FED1BF
// shader: 8B30, 9EE99E5FCDE35D02

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 7F018AB24245A1AF, 9EE99E5FCDE35D02
// program: 6038F426E3FD9783, AD7922A63ED54CA7, 9EE99E5FCDE35D02
// reference: 7F018AB28F755D75, 9EE99E5FCDE35D02
// shader: 8B30, 339695138B1F3D79

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp(min((texcolor0.rgb) + (texcolor1.rgb), vec3(1.0)) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 28B6C1BB0A3D7126, 339695138B1F3D79
// program: 6038F426E3FD9783, AD7922A63ED54CA7, 339695138B1F3D79
// shader: 8B30, 16A79528EEAC7041

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.aaa) + (texcolor1.rgb) * (vec3(1.0) - (rounded_primary_color.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 79E27667AB6B9A91, 16A79528EEAC7041
// program: 6038F426E3FD9783, AD7922A63ED54CA7, 16A79528EEAC7041
// shader: 8B30, 4AF296A8A412F55B

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp(min((texcolor0.rgb) + (texcolor1.rgb), vec3(1.0)) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 28B6C1BBE68A9A25, 4AF296A8A412F55B
// program: 6038F426E3FD9783, AD7922A63ED54CA7, 4AF296A8A412F55B
// shader: 8B30, 52523E8864D2CEC6

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.aaa) + (texcolor1.rgb) * (vec3(1.0) - (rounded_primary_color.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_1 = byteround(clamp((texcolor1.aaa) * (texcolor2.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (last_tex_env_out.rrr) + (combiner_buffer.rgb) * (vec3(1.0) - (last_tex_env_out.rrr)), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb) * (combiner_buffer.ggg) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.ggg)), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 28303F0DA914F330, 52523E8864D2CEC6
// program: 6038F426E3FD9783, AD7922A63ED54CA7, 52523E8864D2CEC6
// shader: 8B30, 65D27335CA8277B4

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(normal, normalize(half_vector))));
refl_value.g = (lut_scale_rg * LookupLightingLUTSigned(5, dot(normal, normalize(view))));
refl_value.b = (lut_scale_rb * LookupLightingLUTSigned(4, dot(normal, normalize(half_vector))));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) + (secondary_fragment_color.ggg), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D26D4A8A38E4BAF9, 65D27335CA8277B4
// program: 6038F426E3FD9783, AD7922A63ED54CA7, 65D27335CA8277B4
// shader: 8B30, EACDE6B1FDB46048

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(normal, normalize(view))));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (texcolor2.aaa) + (texcolor1.rgb) * (vec3(1.0) - (texcolor2.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (secondary_fragment_color.rrr) + (last_tex_env_out.rgb) * (vec3(1.0) - (secondary_fragment_color.rrr)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 447469C623185624, EACDE6B1FDB46048
// program: 6038F426E3FD9783, AD7922A63ED54CA7, EACDE6B1FDB46048
// shader: 8B30, 9C1BD4D1E9CAB884

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(normal, normalize(view))));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.aaa) + (texcolor1.rgb) * (vec3(1.0) - (rounded_primary_color.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (secondary_fragment_color.rrr) + (last_tex_env_out.rgb) * (vec3(1.0) - (secondary_fragment_color.rrr)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: BBA477028CBAA9A3, 9C1BD4D1E9CAB884
// program: 6038F426E3FD9783, AD7922A63ED54CA7, 9C1BD4D1E9CAB884
// shader: 8B30, B681F102F49CF594

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(normal, normalize(view))));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb) * (secondary_fragment_color.rrr) + (texcolor1.rgb) * (vec3(1.0) - (secondary_fragment_color.rrr)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_1 = byteround(clamp((texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor0.rgb) * (texcolor2.aaa) + (combiner_buffer.rgb) * (vec3(1.0) - (texcolor2.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) * (texcolor2.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D03CA6A18F5B2684, B681F102F49CF594
// program: 6038F426E3FD9783, AD7922A63ED54CA7, B681F102F49CF594
// shader: 8B31, A5DC88B5E70699DD

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;
 out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}


#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_19();
bool sub_19_29();
bool sub_29_90();
bool sub_33_51();
bool sub_51_59();
bool sub_88_89();
bool sub_90_117();
bool sub_92_97();
bool sub_97_116();
bool sub_100_106();
bool sub_106_115();
bool sub_107_111();
bool sub_111_114();
bool sub_117_141();
bool sub_119_123();
bool sub_123_140();
bool sub_124_138();
bool sub_127_134();
bool sub_134_137();
bool sub_138_139();
bool sub_141_157();
bool sub_143_147();
bool sub_147_156();
bool sub_148_154();
bool sub_154_155();
bool sub_157_165();
bool sub_159_160();
bool sub_160_164();
bool sub_161_162();
bool sub_162_163();
bool sub_165_172();
bool sub_172_178();
bool sub_178_4096();
bool sub_180_187();
bool sub_187_188();

bool exec_shader() {
    sub_178_4096();
    return true;
}

bool sub_0_19() {
    uint jmp_to = 0u;
    while (true) {
        switch (jmp_to) {
        case 0u: {
            // 0: dp3
            reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
            // 1: dp3
            reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
            // 2: dp3
            reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
            // 3: dp3
            reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
            // 4: dp3
            reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
            // 5: rsq
            reg_tmp6.x = rsq_s(reg_tmp6.x);
            // 6: rsq
            reg_tmp7.x = rsq_s(reg_tmp7.x);
            // 7: mul
            reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 8: mul
            reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 9: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 10: add
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            // 11: mul
            reg_tmp4 = mul_s(uniforms.f[94].xxxx, reg_tmp4);
            // 12: cmp
            conditional_code = greaterThanEqual(uniforms.f[93].xx, reg_tmp4.xx);
            // 13: rsq
            reg_tmp4 = vec4(rsq_s(reg_tmp4.x));
            // 14: mul
            reg_tmp5 = mul_s(uniforms.f[94].xxxx, reg_tmp14);
            // 15: jmpc
            if (conditional_code.x) {
                { jmp_to = 18u; break; }
            }
            // 16: rcp
            reg_tmp0.z = rcp_s(reg_tmp4.x);
            // 17: mul
            reg_tmp0.xy = (mul_s(reg_tmp5, reg_tmp4)).xy;
        }
        case 18u: {
            // 18: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_19_29() {
    // 19: mova
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    // 20: nop
    // 21: dp4
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    // 22: dp4
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    // 23: dp4
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    // 24: dp3
    reg_tmp4.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    // 25: dp3
    reg_tmp4.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    // 26: dp3
    reg_tmp4.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    // 27: mad
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 28: mad
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_29_90() {
    // 29: mov
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    // 30: mov
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    // 31: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 32: ifu
    if (uniforms.b[0]) {
        sub_33_51();
    } else {
        sub_51_59();
    }
    // 59: dp4
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    // 60: dp4
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    // 61: dp4
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    // 62: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 63: call
    {
        sub_0_19();
    }
    // 64: nop
    // 65: mov
    vs_out_attr2 = -reg_tmp15;
    // 66: mov
    reg_tmp0.x = (uniforms.f[93].yyyy).x;
    // 67: mova
    address_registers.x = (ivec2(vs_in_reg3.xx)).x;
    // 68: nop
    // 69: mul
    reg_tmp0.x = (mul_s(uniforms.f[13 + address_registers.x].xxxx, reg_tmp0.xxxx)).x;
    // 70: mova
    address_registers.x = (ivec2(vs_in_reg3.yy)).x;
    // 71: nop
    // 72: mul
    reg_tmp0.x = (mul_s(uniforms.f[13 + address_registers.x].yyyy, reg_tmp0.xxxx)).x;
    // 73: mova
    address_registers.x = (ivec2(vs_in_reg3.zz)).x;
    // 74: nop
    // 75: mul
    reg_tmp0.x = (mul_s(uniforms.f[13 + address_registers.x].zzzz, reg_tmp0.xxxx)).x;
    // 76: mova
    address_registers.x = (ivec2(vs_in_reg3.ww)).x;
    // 77: nop
    // 78: mul
    reg_tmp0.x = (mul_s(uniforms.f[13 + address_registers.x].wwww, reg_tmp0.xxxx)).x;
    // 79: mul
    reg_tmp15.xyz = (mul_s(reg_tmp15.xyzz, reg_tmp0.xxxx)).xyz;
    // 80: dp4
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    // 81: dp4
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    // 82: dp4
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    // 83: dp4
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    // 84: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 85: mul
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    // 86: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 87: ifc
    if (all(conditional_code)) {
        sub_88_89();
    }
    // 89: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_33_51() {
    // 33: mov
    reg_tmp7 = uniforms.f[93].xxxx;
    // 34: mov
    reg_tmp12 = uniforms.f[93].xxxx;
    // 35: mul
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    // 36: cmp
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    // 37: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 38: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    // 39: call
    {
        sub_19_29();
    }
    // 40: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 41: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    // 42: call
    {
        sub_19_29();
    }
    // 43: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 44: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    // 45: call
    {
        sub_19_29();
    }
    // 46: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 47: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    // 48: call
    {
        sub_19_29();
    }
    // 49: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 50: mov
    reg_tmp10 = reg_tmp7;
    return false;
}
bool sub_51_59() {
    // 51: mov
    reg_tmp7 = reg_tmp15;
    // 52: dp4
    reg_tmp10.x = dot_s(uniforms.f[10], reg_tmp7);
    // 53: dp4
    reg_tmp10.y = dot_s(uniforms.f[11], reg_tmp7);
    // 54: dp4
    reg_tmp10.z = dot_s(uniforms.f[12], reg_tmp7);
    // 55: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 56: dp3
    reg_tmp12.x = dot_3(uniforms.f[10].xyz, reg_tmp14.xyz);
    // 57: dp3
    reg_tmp12.y = dot_3(uniforms.f[11].xyz, reg_tmp14.xyz);
    // 58: dp3
    reg_tmp12.z = dot_3(uniforms.f[12].xyz, reg_tmp14.xyz);
    return false;
}
bool sub_88_89() {
    // 88: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_90_117() {
    // 90: mov
    reg_tmp0.xy = (uniforms.f[0].xxxx).xy;
    // 91: ifu
    if (uniforms.b[2]) {
        sub_92_97();
    } else {
        sub_97_116();
    }
    // 116: nop
    return false;
}
bool sub_92_97() {
    // 92: call
    {
        sub_157_165();
    }
    // 93: dp4
    reg_tmp3.x = dot_s(uniforms.f[1].xywz, reg_tmp6);
    // 94: dp4
    reg_tmp3.y = dot_s(uniforms.f[2].xywz, reg_tmp6);
    // 95: mov
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    // 96: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_97_116() {
    // 97: cmp
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    // 98: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 99: ifc
    if (all(not(conditional_code))) {
        sub_100_106();
    } else {
        sub_106_115();
    }
    // 115: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_100_106() {
    // 100: mov
    reg_tmp6 = reg_tmp10;
    // 101: dp4
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    // 102: dp4
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    // 103: dp4
    reg_tmp3.z = dot_s(uniforms.f[3], reg_tmp6);
    // 104: mul
    reg_tmp0.xy = (mul_s(uniforms.f[9].xyyy, reg_tmp3.zzzz)).xy;
    // 105: add
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_106_115() {
    // 106: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_107_111();
    } else {
        sub_111_114();
    }
    // 114: nop
    return false;
}
bool sub_107_111() {
    // 107: call
    {
        sub_165_172();
    }
    // 108: dp3
    reg_tmp3.x = dot_3(uniforms.f[1].xyz, reg_tmp6.xyz);
    // 109: dp3
    reg_tmp3.y = dot_3(uniforms.f[2].xyz, reg_tmp6.xyz);
    // 110: dp3
    reg_tmp3.z = dot_3(uniforms.f[3].xyz, reg_tmp6.xyz);
    return false;
}
bool sub_111_114() {
    // 111: call
    {
        sub_172_178();
    }
    // 112: dp4
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    // 113: dp4
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    return false;
}
bool sub_117_141() {
    // 117: mov
    reg_tmp0.xy = (uniforms.f[0].yyyy).xy;
    // 118: ifu
    if (uniforms.b[3]) {
        sub_119_123();
    } else {
        sub_123_140();
    }
    // 140: nop
    return false;
}
bool sub_119_123() {
    // 119: call
    {
        sub_157_165();
    }
    // 120: dp4
    reg_tmp4.x = dot_s(uniforms.f[4].xywz, reg_tmp6);
    // 121: dp4
    reg_tmp4.y = dot_s(uniforms.f[5].xywz, reg_tmp6);
    // 122: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_123_140() {
    // 123: ifu
    if (uniforms.b[5]) {
        sub_124_138();
    } else {
        sub_138_139();
    }
    // 139: nop
    return false;
}
bool sub_124_138() {
    // 124: cmp
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    // 125: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 126: ifc
    if (all(not(conditional_code))) {
        sub_127_134();
    } else {
        sub_134_137();
    }
    // 137: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_127_134() {
    // 127: mov
    reg_tmp6 = reg_tmp10;
    // 128: dp4
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    // 129: dp4
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    // 130: dp4
    reg_tmp4.z = dot_s(uniforms.f[6], reg_tmp6);
    // 131: rcp
    reg_tmp6.w = rcp_s(reg_tmp4.z);
    // 132: mul
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    // 133: add
    reg_tmp4.xy = (uniforms.f[9].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_134_137() {
    // 134: call
    {
        sub_172_178();
    }
    // 135: dp4
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    // 136: dp4
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    return false;
}
bool sub_138_139() {
    // 138: mov
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_141_157() {
    // 141: mov
    reg_tmp0.xy = (uniforms.f[0].zzzz).xy;
    // 142: ifu
    if (uniforms.b[4]) {
        sub_143_147();
    } else {
        sub_147_156();
    }
    // 156: nop
    return false;
}
bool sub_143_147() {
    // 143: call
    {
        sub_157_165();
    }
    // 144: dp4
    reg_tmp5.x = dot_s(uniforms.f[7].xywz, reg_tmp6);
    // 145: dp4
    reg_tmp5.y = dot_s(uniforms.f[8].xywz, reg_tmp6);
    // 146: mov
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_147_156() {
    // 147: ifu
    if (uniforms.b[6]) {
        sub_148_154();
    } else {
        sub_154_155();
    }
    // 155: nop
    return false;
}
bool sub_148_154() {
    // 148: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 149: mov
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    // 150: call
    {
        sub_172_178();
    }
    // 151: dp4
    reg_tmp5.x = dot_s(uniforms.f[7], reg_tmp6);
    // 152: dp4
    reg_tmp5.y = dot_s(uniforms.f[8], reg_tmp6);
    // 153: mov
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_154_155() {
    // 154: mov
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
bool sub_157_165() {
    // 157: cmp
    conditional_code = equal(uniforms.f[93].yz, reg_tmp0.xy);
    // 158: ifc
    if (all(not(conditional_code))) {
        sub_159_160();
    } else {
        sub_160_164();
    }
    // 164: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_159_160() {
    // 159: mov
    reg_tmp6.xy = (vs_in_reg4.xyyy).xy;
    return false;
}
bool sub_160_164() {
    // 160: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_161_162();
    } else {
        sub_162_163();
    }
    // 163: nop
    return false;
}
bool sub_161_162() {
    // 161: mov
    reg_tmp6.xy = (vs_in_reg5.xyyy).xy;
    return false;
}
bool sub_162_163() {
    // 162: mov
    reg_tmp6.xy = (vs_in_reg6.xyyy).xy;
    return false;
}
bool sub_165_172() {
    // 165: mov
    reg_tmp2 = -reg_tmp15;
    // 166: dp3
    reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
    // 167: rsq
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    // 168: mul
    reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
    // 169: dp3
    reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
    // 170: add
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    // 171: mad
    reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_172_178() {
    // 172: mov
    reg_tmp1 = reg_tmp14;
    // 173: dp3
    reg_tmp2.w = dot_3(reg_tmp1.xyz, reg_tmp1.xyz);
    // 174: rsq
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    // 175: mul
    reg_tmp1 = mul_s(reg_tmp1, reg_tmp2.wwww);
    // 176: mul
    reg_tmp1 = mul_s(uniforms.f[94].xxxx, reg_tmp1);
    // 177: add
    reg_tmp6.xy = (uniforms.f[94].xxxx + reg_tmp1.xyyy).xy;
    return false;
}
bool sub_178_4096() {
    // 178: call
    {
        sub_29_90();
    }
    // 179: ifu
    if (uniforms.b[1]) {
        sub_180_187();
    } else {
        sub_187_188();
    }
    // 188: mov
    vs_out_attr3 = reg_tmp2;
    // 189: call
    {
        sub_90_117();
    }
    // 190: call
    {
        sub_117_141();
    }
    // 191: call
    {
        sub_141_157();
    }
    // 192: end
    return true;
}
bool sub_180_187() {
    // 180: dp3
    reg_tmp0 = vec4(dot_3(uniforms.f[83].xyz, reg_tmp12.xyz));
    // 181: max
    reg_tmp0 = max(uniforms.f[93].xxxx, reg_tmp0);
    // 182: mul
    reg_tmp0 = mul_s(uniforms.f[84], reg_tmp0);
    // 183: add
    reg_tmp0 = uniforms.f[85] + reg_tmp0;
    // 184: mov
    reg_tmp0.w = (uniforms.f[93].yyyy).w;
    // 185: mul
    reg_tmp1 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
    // 186: mul
    reg_tmp2 = mul_s(reg_tmp0, reg_tmp1);
    return false;
}
bool sub_187_188() {
    // 187: mul
    reg_tmp2 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
    return false;
}
// reference: 238F1CA8386BD04C, A5DC88B5E70699DD
// shader: 8B30, 6F631816794CF714

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor1.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 90CF07C19129C1FB, 6F631816794CF714
// program: A5DC88B5E70699DD, AD7922A63ED54CA7, 6F631816794CF714
// shader: 8B30, 1F02D705CD0FF35A

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(normal, normalize(view))));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb) * (secondary_fragment_color.rrr) + (texcolor1.rgb) * (vec3(1.0) - (secondary_fragment_color.rrr)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_1 = byteround(clamp((texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor0.rgb) * (texcolor2.aaa) + (combiner_buffer.rgb) * (vec3(1.0) - (texcolor2.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) * (texcolor2.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D03CA6A163ECCD87, 1F02D705CD0FF35A
// program: 6038F426E3FD9783, AD7922A63ED54CA7, 1F02D705CD0FF35A
// shader: 8B30, AFA7E256CC0E4CA8

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.aaa) + (texcolor1.rgb) * (vec3(1.0) - (rounded_primary_color.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 9DF0A67F2437D1FB, AFA7E256CC0E4CA8
// program: 6038F426E3FD9783, AD7922A63ED54CA7, AFA7E256CC0E4CA8
// shader: 8B30, AE19BF5D1615655B

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (texcolor2.aaa) + (texcolor1.rgb) * (vec3(1.0) - (texcolor2.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (texcolor2.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 64BFB8231EF36FDE, AE19BF5D1615655B
// program: 6038F426E3FD9783, AD7922A63ED54CA7, AE19BF5D1615655B
// shader: 8B30, 9AEA6425BCEBC6A1

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp(min((texcolor0.rgb) + (texcolor1.rgb), vec3(1.0)) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D82C9517C77B4F94, 9AEA6425BCEBC6A1
// program: 6038F426E3FD9783, AD7922A63ED54CA7, 9AEA6425BCEBC6A1
// shader: 8B30, 5B2355A74E739DAA

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (texcolor2.aaa) + (texcolor1.rgb) * (vec3(1.0) - (texcolor2.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 79E276679FA91F25, 5B2355A74E739DAA
// program: 6038F426E3FD9783, AD7922A63ED54CA7, 5B2355A74E739DAA
// shader: 8B30, 302549A0D553595D

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.aaa) + (texcolor1.rgb) * (vec3(1.0) - (rounded_primary_color.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (texcolor2.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 80AD683BDCD29352, 302549A0D553595D
// program: 6038F426E3FD9783, AD7922A63ED54CA7, 302549A0D553595D
// shader: 8B30, 8397200ACD21A598

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (texcolor2.aaa) + (texcolor1.rgb) * (vec3(1.0) - (texcolor2.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (texcolor2.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 64BFB823F24484DD, 8397200ACD21A598
// program: 6038F426E3FD9783, AD7922A63ED54CA7, 8397200ACD21A598
// shader: 8B30, 0224B477DBA96517

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(normal, normalize(view))));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (texcolor2.aaa) + (texcolor1.rgb) * (vec3(1.0) - (texcolor2.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (secondary_fragment_color.rrr) + (last_tex_env_out.rgb) * (vec3(1.0) - (secondary_fragment_color.rrr)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 447469C6CFAFBD27, 0224B477DBA96517
// program: 6038F426E3FD9783, AD7922A63ED54CA7, 0224B477DBA96517
// shader: 8B30, D2F06270356D0DFA

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) + (texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 8DB79618EF6F0D75, D2F06270356D0DFA
// program: 6038F426E3FD9783, AD7922A63ED54CA7, D2F06270356D0DFA
// shader: 8B30, 10FDC659B905BF4C

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp(min((texcolor0.rgb) + (texcolor1.rgb), vec3(1.0)) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D82C95172BCCA497, 10FDC659B905BF4C
// program: 6038F426E3FD9783, AD7922A63ED54CA7, 10FDC659B905BF4C
// shader: 8B30, F182435B6E756645

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 79A26A61A6099509, F182435B6E756645
// program: 6038F426E3FD9783, AD7922A63ED54CA7, F182435B6E756645
// shader: 8B30, E20C116DDD65DC74

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb) * (texcolor0.ggg) + (vec3(1.0) - texcolor1.aaa) * (vec3(1.0) - (texcolor0.ggg)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (texcolor0.rrr) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor0.rrr)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (texcolor0.bbb) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor0.bbb)), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rrr) + (texcolor2.rgb) * (vec3(1.0) - (primary_fragment_color.rrr)), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) + (texcolor1.rgb) - vec3(0.5), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 4B90C6E2FDE11654, E20C116DDD65DC74
// program: 6038F426E3FD9783, AD7922A63ED54CA7, E20C116DDD65DC74
// shader: 8B30, C056D3A957D09F20

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = 2.0 * (texcolor2).rgb - 1.0;
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(normal, normalize(view))));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb) + (texcolor0.aaa), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (texcolor1.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0 * 1.0, alpha_output_0 * 2.0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((1.0 - secondary_fragment_color.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a) + (combiner_buffer.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D7E8E0CE5473F4A9, C056D3A957D09F20
// program: 6038F426E3FD9783, AD7922A63ED54CA7, C056D3A957D09F20
// shader: 8B30, 38BCB03CDA891EAB

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((const_color[1].a) * (texcolor1.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((1.0 - combiner_buffer.a) * (last_tex_env_out.a) + (combiner_buffer.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 2901127D29619BF1, 38BCB03CDA891EAB
// program: 6038F426E3FD9783, AD7922A63ED54CA7, 38BCB03CDA891EAB
// shader: 8B30, 03EFF39D2689C425

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((const_color[1].a) * (texcolor1.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((1.0 - combiner_buffer.a) * (last_tex_env_out.a) + (combiner_buffer.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) < alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 2901127D4E960F87, 03EFF39D2689C425
// program: 6038F426E3FD9783, AD7922A63ED54CA7, 03EFF39D2689C425
// reference: EBE62C270E16CA16, B3A9ECAF0A8ECFA3
// shader: 8B30, 0A9D7FF70CF16C7A

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rrr) * (const_color[0].rrr), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor0.ggg) * (const_color[1].ggg) + (last_tex_env_out.rrr), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor0.bbb) * (const_color[2].bbb) + (last_tex_env_out.rrr), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((texcolor0.rgb) * (texcolor1.aaa), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: C769BC5CA0EADC59, 0A9D7FF70CF16C7A
// program: B3A9ECAF0A8ECFA3, AD7922A63ED54CA7, 0A9D7FF70CF16C7A
// shader: 8B30, 4FE101C8EBCDD984

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (const_color[1].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) * (const_color[2].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 7F53101FAE9E225A, 4FE101C8EBCDD984
// program: B3A9ECAF0A8ECFA3, AD7922A63ED54CA7, 4FE101C8EBCDD984
// reference: 3865EBDE614B0AD4, B3A9ECAF0A8ECFA3
// reference: BF76358ECFCBFE5F, DEDDD3577BD6F4B8
// shader: 8B30, 666AF935179E17F3

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (const_color[1].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) * (const_color[2].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 3AC51CBBC13DF401, 666AF935179E17F3
// program: DEDDD3577BD6F4B8, 5D764F9A6220D694, 666AF935179E17F3
// shader: 8B30, FD67B831C526BF4B

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (const_color[1].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) * (const_color[2].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 3AC51CBB3ADD85B8, FD67B831C526BF4B
// program: DEDDD3577BD6F4B8, 5D764F9A6220D694, FD67B831C526BF4B
// reference: 6CF5F27714725F18, DEDDD3577BD6F4B8
// reference: 4E876612C488EDAB, 6038F426E3FD9783
// shader: 8B30, 3BDC5CADABAA192D

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) * (const_color[2].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 5BEBE6BBCD5F1A87, 3BDC5CADABAA192D
// program: DEDDD3577BD6F4B8, 5D764F9A6220D694, 3BDC5CADABAA192D
// shader: 8B30, 1045BB32F597E545

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) * (const_color[2].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 5BEBE6BBC668E093, 1045BB32F597E545
// program: DEDDD3577BD6F4B8, 5D764F9A6220D694, 1045BB32F597E545
// shader: 8B30, 51FFCF70C4C2996F

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) * (const_color[2].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 6B53F9F065C59CBA, 51FFCF70C4C2996F
// program: DEDDD3577BD6F4B8, 5D764F9A6220D694, 51FFCF70C4C2996F
// shader: 8B30, 3323F8FDC088A936

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.r) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 103B0098D5C9395D, 3323F8FDC088A936
// program: 6038F426E3FD9783, AD7922A63ED54CA7, 3323F8FDC088A936
// shader: 8B30, 47C12CB4EFB88BF9

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: B2CD74B51F680A00, 47C12CB4EFB88BF9
// program: B3A9ECAF0A8ECFA3, AD7922A63ED54CA7, 47C12CB4EFB88BF9
// reference: 1F78A60766D02152, ECB67079092E1152
// reference: 1F78A6079D3050EB, 20BCD1F2228017BC
// shader: 8B30, BF3EC3006F4471DB

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 9740E06317507773, BF3EC3006F4471DB
// program: DEDDD3577BD6F4B8, 5D764F9A6220D694, BF3EC3006F4471DB
// shader: 8B30, 21D2EFBCAB5A0E94

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 9740E0631C678D67, 21D2EFBCAB5A0E94
// program: DEDDD3577BD6F4B8, 5D764F9A6220D694, 21D2EFBCAB5A0E94
// shader: 8B30, 3587AE04D7C7682A

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) * (const_color[2].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 5BEBE6BB3D88912A, 3587AE04D7C7682A
// program: DEDDD3577BD6F4B8, 5D764F9A6220D694, 3587AE04D7C7682A
// shader: 8B30, FC2CBF2A9DB45F93

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp(min((texcolor0.rgb) + (texcolor1.rgb), vec3(1.0)) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 7B3755AA0A3D7126, FC2CBF2A9DB45F93
// program: 6038F426E3FD9783, AD7922A63ED54CA7, FC2CBF2A9DB45F93
// shader: 8B30, A8ED9350933F4D1E

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rrr) + (texcolor2.rgb) * (vec3(1.0) - (primary_fragment_color.rrr)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 4925DD1ED2A3C03F, A8ED9350933F4D1E
// program: 6038F426E3FD9783, AD7922A63ED54CA7, A8ED9350933F4D1E
// shader: 8B30, 4F8FB5FF21C2E40B

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp(min((texcolor0.rgb) + (texcolor1.rgb), vec3(1.0)) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 8BAD0106C77B4F94, 4F8FB5FF21C2E40B
// program: 6038F426E3FD9783, AD7922A63ED54CA7, 4F8FB5FF21C2E40B
// shader: 8B30, 1EB158E31F258370

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp(min((texcolor0.rgb) + (texcolor1.rgb), vec3(1.0)) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 8BAD01062BCCA497, 1EB158E31F258370
// program: 6038F426E3FD9783, AD7922A63ED54CA7, 1EB158E31F258370
// shader: 8B30, B97E9E8610E0C725

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 2C801EA3AEF24AAC, B97E9E8610E0C725
// program: 6038F426E3FD9783, AD7922A63ED54CA7, B97E9E8610E0C725
// shader: 8B30, 13CA774367456694

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor1.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (const_color[1].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (primary_fragment_color.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: F4FFC6A99CDFF886, 13CA774367456694
// program: 6038F426E3FD9783, AD7922A63ED54CA7, 13CA774367456694
// shader: 8B30, C77C47D383B89BBB

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (primary_fragment_color.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (const_color[2].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: B6C296E9F1628B97, C77C47D383B89BBB
// program: 6038F426E3FD9783, AD7922A63ED54CA7, C77C47D383B89BBB
// shader: 8B30, 0DE1581A47773D32

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 2A23FE70A6099509, 0DE1581A47773D32
// program: 6038F426E3FD9783, AD7922A63ED54CA7, 0DE1581A47773D32
// shader: 8B30, 931971F98DD11715

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(normal, normalize(view))));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (secondary_fragment_color.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 2FAD43B77FC07EC1, 931971F98DD11715
// program: 6038F426E3FD9783, AD7922A63ED54CA7, 931971F98DD11715
// shader: 8B30, BB9BA9D9496AD48E

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: F6779270599F0D6D, BB9BA9D9496AD48E
// program: DEDDD3577BD6F4B8, 5D764F9A6220D694, BB9BA9D9496AD48E
// shader: 8B30, B5FDA4DDACF2E4C3

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: F6779270A27F7CD4, B5FDA4DDACF2E4C3
// program: DEDDD3577BD6F4B8, 5D764F9A6220D694, B5FDA4DDACF2E4C3
// shader: 8B30, A1F07D18137744B0

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 8ED580B86326FA84, A1F07D18137744B0
// program: DEDDD3577BD6F4B8, 5D764F9A6220D694, A1F07D18137744B0
// shader: 8B30, E04524D81D23AD4B

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 8ED580B868110090, E04524D81D23AD4B
// program: DEDDD3577BD6F4B8, 5D764F9A6220D694, E04524D81D23AD4B
// shader: 8B31, 619ABEE00AF51137

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;
 out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}


#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define mul_3(x, y) mix(x * y, vec3(0.0), isnan(x * y))
#define fma_s(x, y, z) (mul_s(x, y) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(mul_3(x, y), vec3(1.0))

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_19();
bool sub_19_55();
bool sub_55_65();
bool sub_65_79();
bool sub_79_129();
bool sub_84_102();
bool sub_102_110();
bool sub_127_128();
bool sub_129_185();
bool sub_134_152();
bool sub_152_163();
bool sub_183_184();
bool sub_185_212();
bool sub_187_192();
bool sub_192_211();
bool sub_195_201();
bool sub_201_210();
bool sub_202_206();
bool sub_206_209();
bool sub_212_236();
bool sub_214_218();
bool sub_218_235();
bool sub_219_233();
bool sub_222_229();
bool sub_229_232();
bool sub_233_234();
bool sub_236_252();
bool sub_238_242();
bool sub_242_251();
bool sub_243_249();
bool sub_249_250();
bool sub_252_260();
bool sub_254_255();
bool sub_255_259();
bool sub_256_257();
bool sub_257_258();
bool sub_260_267();
bool sub_267_273();
bool sub_273_4096();
bool sub_274_276();
bool sub_276_278();
bool sub_279_286();
bool sub_286_287();

bool exec_shader() {
    sub_273_4096();
    return true;
}

bool sub_0_19() {
    uint jmp_to = 0u;
    while (true) {
        switch (jmp_to) {
        case 0u: {
            // 0: dp3
            reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
            // 1: dp3
            reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
            // 2: dp3
            reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
            // 3: dp3
            reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
            // 4: dp3
            reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
            // 5: rsq
            reg_tmp6.x = rsq_s(reg_tmp6.x);
            // 6: rsq
            reg_tmp7.x = rsq_s(reg_tmp7.x);
            // 7: mul
            reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 8: mul
            reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 9: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 10: add
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            // 11: mul
            reg_tmp4 = mul_s(uniforms.f[94].xxxx, reg_tmp4);
            // 12: cmp
            conditional_code = greaterThanEqual(uniforms.f[93].xx, reg_tmp4.xx);
            // 13: rsq
            reg_tmp4 = vec4(rsq_s(reg_tmp4.x));
            // 14: mul
            reg_tmp5 = mul_s(uniforms.f[94].xxxx, reg_tmp14);
            // 15: jmpc
            if (conditional_code.x) {
                { jmp_to = 18u; break; }
            }
            // 16: rcp
            reg_tmp0.z = rcp_s(reg_tmp4.x);
            // 17: mul
            reg_tmp0.xy = (mul_s(reg_tmp5, reg_tmp4)).xy;
        }
        case 18u: {
            // 18: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_19_55() {
    uint jmp_to = 19u;
    while (true) {
        switch (jmp_to) {
        case 19u: {
            // 19: dp3
            reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
            // 20: dp3
            reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
            // 21: rsq
            reg_tmp6.x = rsq_s(reg_tmp6.x);
            // 22: rsq
            reg_tmp7.x = rsq_s(reg_tmp7.x);
            // 23: mul
            reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 24: mul
            reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 25: mul
            reg_tmp13.xyz = (mul_s(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            // 26: mul
            reg_tmp11.xyz = (mul_s(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            // 27: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 28: mul
            reg_tmp13.xyz = (mul_s(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            // 29: mul
            reg_tmp11.xyz = (mul_s(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            // 30: mul
            reg_tmp5 = mul_s(reg_tmp14.yzxx, reg_tmp13.zxyy);
            // 31: mad
            reg_tmp5 = fma_s(-reg_tmp13.yzxx, reg_tmp14.zxyy, reg_tmp5);
            // 32: dp3
            reg_tmp5.w = dot_3(reg_tmp5.xyz, reg_tmp5.xyz);
            // 33: rsq
            reg_tmp5.w = rsq_s(reg_tmp5.w);
            // 34: mul
            reg_tmp5 = mul_s(reg_tmp5, reg_tmp5.wwww);
            // 35: add
            reg_tmp6.w = (reg_tmp14.zzzz + reg_tmp5.yyyy).w;
            // 36: mul
            reg_tmp13 = mul_s(reg_tmp5.yzxx, reg_tmp14.zxyy);
            // 37: mad
            reg_tmp13 = fma_s(-reg_tmp14.yzxx, reg_tmp5.zxyy, reg_tmp13);
            // 38: add
            reg_tmp6.w = (reg_tmp13.xxxx + reg_tmp6).w;
            // 39: mov
            reg_tmp13.w = (reg_tmp5.zzzz).w;
            // 40: mov
            reg_tmp5.z = (reg_tmp13.xxxx).z;
            // 41: add
            reg_tmp6.w = (uniforms.f[93].yyyy + reg_tmp6).w;
            // 42: mov
            reg_tmp14.w = (reg_tmp5.xxxx).w;
            // 43: mov
            reg_tmp5.x = (reg_tmp14.zzzz).x;
            // 44: cmp
            conditional_code = lessThan(uniforms.f[94].zz, reg_tmp6.ww);
            // 45: mov
            reg_tmp6.x = (uniforms.f[93].yyyy).x;
            // 46: mov
            reg_tmp6.y = (-uniforms.f[93].yyyy).y;
            // 47: jmpc
            if (!conditional_code.x) {
                { jmp_to = 54u; break; }
            }
            // 48: add
            reg_tmp7.xz = (reg_tmp13.wwyy + -reg_tmp14.yyww).xz;
            // 49: add
            reg_tmp7.y = (reg_tmp14.xxxx + -reg_tmp13.zzzz).y;
            // 50: mov
            reg_tmp7.w = (reg_tmp6).w;
            // 51: dp4
            reg_tmp6 = vec4(dot_s(reg_tmp7, reg_tmp7));
            // 52: rsq
            reg_tmp6 = vec4(rsq_s(reg_tmp6.x));
            // 53: mul
            reg_tmp0 = mul_s(reg_tmp7, reg_tmp6);
        }
        case 54u: {
            // 54: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_55_65() {
    // 55: mova
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    // 56: nop
    // 57: dp4
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    // 58: dp4
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    // 59: dp4
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    // 60: dp3
    reg_tmp4.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    // 61: dp3
    reg_tmp4.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    // 62: dp3
    reg_tmp4.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    // 63: mad
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 64: mad
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_65_79() {
    // 65: mova
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    // 66: nop
    // 67: dp4
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    // 68: dp4
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    // 69: dp4
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    // 70: dp3
    reg_tmp4.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    // 71: dp3
    reg_tmp4.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    // 72: dp3
    reg_tmp4.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    // 73: dp3
    reg_tmp5.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp13.xyz);
    // 74: dp3
    reg_tmp5.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp13.xyz);
    // 75: dp3
    reg_tmp5.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp13.xyz);
    // 76: mad
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 77: mad
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    // 78: mad
    reg_tmp11 = fma_s(reg_tmp1.wwww, reg_tmp5, reg_tmp11);
    return false;
}
bool sub_79_129() {
    // 79: mov
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    // 80: mov
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    // 81: mov
    reg_tmp13.xyz = (vs_in_reg2).xyz;
    // 82: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 83: ifu
    if (uniforms.b[0]) {
        sub_84_102();
    } else {
        sub_102_110();
    }
    // 110: dp3
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    // 111: dp3
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    // 112: dp3
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    // 113: call
    {
        sub_0_19();
    }
    // 114: dp4
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    // 115: dp4
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    // 116: dp4
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    // 117: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 118: mov
    vs_out_attr2 = -reg_tmp15;
    // 119: dp4
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    // 120: dp4
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    // 121: dp4
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    // 122: dp4
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    // 123: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 124: mul
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    // 125: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 126: ifc
    if (all(conditional_code)) {
        sub_127_128();
    }
    // 128: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_84_102() {
    // 84: mov
    reg_tmp7 = uniforms.f[93].xxxx;
    // 85: mov
    reg_tmp12 = uniforms.f[93].xxxx;
    // 86: mul
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    // 87: cmp
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    // 88: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 89: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    // 90: call
    {
        sub_55_65();
    }
    // 91: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 92: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    // 93: call
    {
        sub_55_65();
    }
    // 94: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 95: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    // 96: call
    {
        sub_55_65();
    }
    // 97: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 98: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    // 99: call
    {
        sub_55_65();
    }
    // 100: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 101: mov
    reg_tmp10 = reg_tmp7;
    return false;
}
bool sub_102_110() {
    // 102: mov
    reg_tmp7 = reg_tmp15;
    // 103: dp4
    reg_tmp10.x = dot_s(uniforms.f[10], reg_tmp7);
    // 104: dp4
    reg_tmp10.y = dot_s(uniforms.f[11], reg_tmp7);
    // 105: dp4
    reg_tmp10.z = dot_s(uniforms.f[12], reg_tmp7);
    // 106: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 107: dp3
    reg_tmp12.x = dot_3(uniforms.f[10].xyz, reg_tmp14.xyz);
    // 108: dp3
    reg_tmp12.y = dot_3(uniforms.f[11].xyz, reg_tmp14.xyz);
    // 109: dp3
    reg_tmp12.z = dot_3(uniforms.f[12].xyz, reg_tmp14.xyz);
    return false;
}
bool sub_127_128() {
    // 127: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_129_185() {
    // 129: mov
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    // 130: mov
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    // 131: mov
    reg_tmp13.xyz = (vs_in_reg2).xyz;
    // 132: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 133: ifu
    if (uniforms.b[0]) {
        sub_134_152();
    } else {
        sub_152_163();
    }
    // 163: dp3
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    // 164: dp3
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    // 165: dp3
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    // 166: dp3
    reg_tmp13.x = dot_3(uniforms.f[90].xyz, reg_tmp11.xyz);
    // 167: dp3
    reg_tmp13.y = dot_3(uniforms.f[91].xyz, reg_tmp11.xyz);
    // 168: dp3
    reg_tmp13.z = dot_3(uniforms.f[92].xyz, reg_tmp11.xyz);
    // 169: call
    {
        sub_19_55();
    }
    // 170: dp4
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    // 171: dp4
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    // 172: dp4
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    // 173: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 174: mov
    vs_out_attr2 = -reg_tmp15;
    // 175: dp4
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    // 176: dp4
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    // 177: dp4
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    // 178: dp4
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    // 179: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 180: mul
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    // 181: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 182: ifc
    if (all(conditional_code)) {
        sub_183_184();
    }
    // 184: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_134_152() {
    // 134: mov
    reg_tmp7 = uniforms.f[93].xxxx;
    // 135: mov
    reg_tmp12 = uniforms.f[93].xxxx;
    // 136: mul
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    // 137: cmp
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    // 138: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 139: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    // 140: call
    {
        sub_65_79();
    }
    // 141: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 142: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    // 143: call
    {
        sub_65_79();
    }
    // 144: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 145: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    // 146: call
    {
        sub_65_79();
    }
    // 147: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 148: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    // 149: call
    {
        sub_65_79();
    }
    // 150: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 151: mov
    reg_tmp10 = reg_tmp7;
    return false;
}
bool sub_152_163() {
    // 152: mov
    reg_tmp7 = reg_tmp15;
    // 153: dp4
    reg_tmp10.x = dot_s(uniforms.f[10], reg_tmp7);
    // 154: dp4
    reg_tmp10.y = dot_s(uniforms.f[11], reg_tmp7);
    // 155: dp4
    reg_tmp10.z = dot_s(uniforms.f[12], reg_tmp7);
    // 156: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 157: dp3
    reg_tmp12.x = dot_3(uniforms.f[10].xyz, reg_tmp14.xyz);
    // 158: dp3
    reg_tmp12.y = dot_3(uniforms.f[11].xyz, reg_tmp14.xyz);
    // 159: dp3
    reg_tmp12.z = dot_3(uniforms.f[12].xyz, reg_tmp14.xyz);
    // 160: dp3
    reg_tmp11.x = dot_3(uniforms.f[10].xyz, reg_tmp13.xyz);
    // 161: dp3
    reg_tmp11.y = dot_3(uniforms.f[11].xyz, reg_tmp13.xyz);
    // 162: dp3
    reg_tmp11.z = dot_3(uniforms.f[12].xyz, reg_tmp13.xyz);
    return false;
}
bool sub_183_184() {
    // 183: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_185_212() {
    // 185: mov
    reg_tmp0.xy = (uniforms.f[0].xxxx).xy;
    // 186: ifu
    if (uniforms.b[2]) {
        sub_187_192();
    } else {
        sub_192_211();
    }
    // 211: nop
    return false;
}
bool sub_187_192() {
    // 187: call
    {
        sub_252_260();
    }
    // 188: dp4
    reg_tmp3.x = dot_s(uniforms.f[1].xywz, reg_tmp6);
    // 189: dp4
    reg_tmp3.y = dot_s(uniforms.f[2].xywz, reg_tmp6);
    // 190: mov
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    // 191: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_192_211() {
    // 192: cmp
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    // 193: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 194: ifc
    if (all(not(conditional_code))) {
        sub_195_201();
    } else {
        sub_201_210();
    }
    // 210: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_195_201() {
    // 195: mov
    reg_tmp6 = reg_tmp10;
    // 196: dp4
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    // 197: dp4
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    // 198: dp4
    reg_tmp3.z = dot_s(uniforms.f[3], reg_tmp6);
    // 199: mul
    reg_tmp0.xy = (mul_s(uniforms.f[9].xyyy, reg_tmp3.zzzz)).xy;
    // 200: add
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_201_210() {
    // 201: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_202_206();
    } else {
        sub_206_209();
    }
    // 209: nop
    return false;
}
bool sub_202_206() {
    // 202: call
    {
        sub_260_267();
    }
    // 203: dp3
    reg_tmp3.x = dot_3(uniforms.f[1].xyz, reg_tmp6.xyz);
    // 204: dp3
    reg_tmp3.y = dot_3(uniforms.f[2].xyz, reg_tmp6.xyz);
    // 205: dp3
    reg_tmp3.z = dot_3(uniforms.f[3].xyz, reg_tmp6.xyz);
    return false;
}
bool sub_206_209() {
    // 206: call
    {
        sub_267_273();
    }
    // 207: dp4
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    // 208: dp4
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    return false;
}
bool sub_212_236() {
    // 212: mov
    reg_tmp0.xy = (uniforms.f[0].yyyy).xy;
    // 213: ifu
    if (uniforms.b[3]) {
        sub_214_218();
    } else {
        sub_218_235();
    }
    // 235: nop
    return false;
}
bool sub_214_218() {
    // 214: call
    {
        sub_252_260();
    }
    // 215: dp4
    reg_tmp4.x = dot_s(uniforms.f[4].xywz, reg_tmp6);
    // 216: dp4
    reg_tmp4.y = dot_s(uniforms.f[5].xywz, reg_tmp6);
    // 217: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_218_235() {
    // 218: ifu
    if (uniforms.b[5]) {
        sub_219_233();
    } else {
        sub_233_234();
    }
    // 234: nop
    return false;
}
bool sub_219_233() {
    // 219: cmp
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    // 220: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 221: ifc
    if (all(not(conditional_code))) {
        sub_222_229();
    } else {
        sub_229_232();
    }
    // 232: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_222_229() {
    // 222: mov
    reg_tmp6 = reg_tmp10;
    // 223: dp4
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    // 224: dp4
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    // 225: dp4
    reg_tmp4.z = dot_s(uniforms.f[6], reg_tmp6);
    // 226: rcp
    reg_tmp6.w = rcp_s(reg_tmp4.z);
    // 227: mul
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    // 228: add
    reg_tmp4.xy = (uniforms.f[9].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_229_232() {
    // 229: call
    {
        sub_267_273();
    }
    // 230: dp4
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    // 231: dp4
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    return false;
}
bool sub_233_234() {
    // 233: mov
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_236_252() {
    // 236: mov
    reg_tmp0.xy = (uniforms.f[0].zzzz).xy;
    // 237: ifu
    if (uniforms.b[4]) {
        sub_238_242();
    } else {
        sub_242_251();
    }
    // 251: nop
    return false;
}
bool sub_238_242() {
    // 238: call
    {
        sub_252_260();
    }
    // 239: dp4
    reg_tmp5.x = dot_s(uniforms.f[7].xywz, reg_tmp6);
    // 240: dp4
    reg_tmp5.y = dot_s(uniforms.f[8].xywz, reg_tmp6);
    // 241: mov
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_242_251() {
    // 242: ifu
    if (uniforms.b[6]) {
        sub_243_249();
    } else {
        sub_249_250();
    }
    // 250: nop
    return false;
}
bool sub_243_249() {
    // 243: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 244: mov
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    // 245: call
    {
        sub_267_273();
    }
    // 246: dp4
    reg_tmp5.x = dot_s(uniforms.f[7], reg_tmp6);
    // 247: dp4
    reg_tmp5.y = dot_s(uniforms.f[8], reg_tmp6);
    // 248: mov
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_249_250() {
    // 249: mov
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
bool sub_252_260() {
    // 252: cmp
    conditional_code = equal(uniforms.f[93].yz, reg_tmp0.xy);
    // 253: ifc
    if (all(not(conditional_code))) {
        sub_254_255();
    } else {
        sub_255_259();
    }
    // 259: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_254_255() {
    // 254: mov
    reg_tmp6.xy = (vs_in_reg4.xyyy).xy;
    return false;
}
bool sub_255_259() {
    // 255: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_256_257();
    } else {
        sub_257_258();
    }
    // 258: nop
    return false;
}
bool sub_256_257() {
    // 256: mov
    reg_tmp6.xy = (vs_in_reg5.xyyy).xy;
    return false;
}
bool sub_257_258() {
    // 257: mov
    reg_tmp6.xy = (vs_in_reg6.xyyy).xy;
    return false;
}
bool sub_260_267() {
    // 260: mov
    reg_tmp2 = -reg_tmp15;
    // 261: dp3
    reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
    // 262: rsq
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    // 263: mul
    reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
    // 264: dp3
    reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
    // 265: add
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    // 266: mad
    reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_267_273() {
    // 267: mov
    reg_tmp1 = reg_tmp14;
    // 268: dp3
    reg_tmp2.w = dot_3(reg_tmp1.xyz, reg_tmp1.xyz);
    // 269: rsq
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    // 270: mul
    reg_tmp1 = mul_s(reg_tmp1, reg_tmp2.wwww);
    // 271: mul
    reg_tmp1 = mul_s(uniforms.f[94].xxxx, reg_tmp1);
    // 272: add
    reg_tmp6.xy = (uniforms.f[94].xxxx + reg_tmp1.xyyy).xy;
    return false;
}
bool sub_273_4096() {
    // 273: ifu
    if (uniforms.b[10]) {
        sub_274_276();
    } else {
        sub_276_278();
    }
    // 278: ifu
    if (uniforms.b[1]) {
        sub_279_286();
    } else {
        sub_286_287();
    }
    // 287: mov
    vs_out_attr3 = reg_tmp2;
    // 288: call
    {
        sub_185_212();
    }
    // 289: call
    {
        sub_212_236();
    }
    // 290: call
    {
        sub_236_252();
    }
    // 291: end
    return true;
}
bool sub_274_276() {
    // 274: call
    {
        sub_129_185();
    }
    // 275: nop
    return false;
}
bool sub_276_278() {
    // 276: call
    {
        sub_79_129();
    }
    // 277: nop
    return false;
}
bool sub_279_286() {
    // 279: dp3
    reg_tmp0 = vec4(dot_3(uniforms.f[83].xyz, reg_tmp12.xyz));
    // 280: max
    reg_tmp0 = max(uniforms.f[93].xxxx, reg_tmp0);
    // 281: mul
    reg_tmp0 = mul_s(uniforms.f[84], reg_tmp0);
    // 282: add
    reg_tmp0 = uniforms.f[85] + reg_tmp0;
    // 283: mov
    reg_tmp0.w = (uniforms.f[93].yyyy).w;
    // 284: mul
    reg_tmp1 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
    // 285: mul
    reg_tmp2 = mul_s(reg_tmp0, reg_tmp1);
    return false;
}
bool sub_286_287() {
    // 286: mul
    reg_tmp2 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
    return false;
}
// reference: 9D04A1EBEEA1E387, 619ABEE00AF51137
// program: 619ABEE00AF51137, AD7922A63ED54CA7, 60942A308DA395BE
// reference: 4E876612351842C0, 619ABEE00AF51137
// program: 619ABEE00AF51137, AD7922A63ED54CA7, 215F8EECD665CA41
// program: 619ABEE00AF51137, AD7922A63ED54CA7, 5366E62DF9CFDB1A
// reference: 4E876612DA21D181, 619ABEE00AF51137
// program: 619ABEE00AF51137, AD7922A63ED54CA7, 13ECDA4EF04264FE
// program: 619ABEE00AF51137, AD7922A63ED54CA7, 8D34F09646FED1BF
// program: 619ABEE00AF51137, AD7922A63ED54CA7, FC2CBF2A9DB45F93
// program: 619ABEE00AF51137, AD7922A63ED54CA7, A8ED9350933F4D1E
// program: 619ABEE00AF51137, AD7922A63ED54CA7, 4F8FB5FF21C2E40B
// program: 619ABEE00AF51137, AD7922A63ED54CA7, 1EB158E31F258370
// program: 619ABEE00AF51137, AD7922A63ED54CA7, B97E9E8610E0C725
// program: 619ABEE00AF51137, AD7922A63ED54CA7, 13CA774367456694
// program: 619ABEE00AF51137, AD7922A63ED54CA7, C77C47D383B89BBB
// program: 619ABEE00AF51137, AD7922A63ED54CA7, 0DE1581A47773D32
// program: 619ABEE00AF51137, AD7922A63ED54CA7, 931971F98DD11715
// shader: 8B31, 93C50366EC4126B4

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}


#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define mul_3(x, y) mix(x * y, vec3(0.0), isnan(x * y))
#define fma_s(x, y, z) (mul_s(x, y) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(mul_3(x, y), vec3(1.0))

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_97();
bool sub_5_50();
bool sub_12_13();
bool sub_20_21();
bool sub_22_24();
bool sub_31_32();
bool sub_33_34();
bool sub_40_41();
bool sub_42_43();
bool sub_48_49();
bool sub_52_69();
bool sub_57_60();
bool sub_60_68();
bool sub_62_63();
bool sub_63_64();
bool sub_65_66();
bool sub_66_67();
bool sub_69_96();
bool sub_70_93();
bool sub_74_79();
bool sub_79_92();
bool sub_83_87();
bool sub_84_85();
bool sub_85_86();
bool sub_87_91();
bool sub_88_89();
bool sub_89_90();
bool sub_93_95();
bool sub_97_109();
bool sub_109_4096();
bool sub_125_127();
bool sub_127_149();
bool sub_137_141();
bool sub_158_160();
bool sub_161_162();
bool sub_171_173();
bool sub_174_175();
bool sub_184_186();
bool sub_187_188();
bool sub_198_207();
bool sub_215_223();
bool sub_223_227();

bool exec_shader() {
    sub_109_4096();
    return true;
}

bool sub_0_97() {
    // 0: flr
    reg_tmp13 = floor(reg_tmp0.xxxx);
    // 1: add
    reg_tmp13 = reg_tmp0.xxxx + -reg_tmp13;
    // 2: mova
    address_registers.y = (ivec2(reg_tmp11.zz)).y;
    // 3: cmp
    conditional_code = lessThanEqual(uniforms.f[5].ww, reg_tmp13.xx);
    // 4: ifc
    if (conditional_code.x) {
        sub_5_50();
    }
    // 50: cmp
    conditional_code = lessThanEqual(uniforms.f[5].yy, reg_tmp11.xy);
    // 51: ifc
    if (!conditional_code.y) {
        sub_52_69();
    } else {
        sub_69_96();
    }
    // 96: nop
    return false;
}
bool sub_5_50() {
    // 5: add
    reg_tmp12.xy = (uniforms.f[5].xyyy + vs_in_reg0.zwww).xy;
    // 6: mov
    reg_tmp14.xy = (uniforms.f[6].wzzz).xy;
    // 7: mul
    reg_tmp13.xy = (mul_s(uniforms.f[5].zzzz, reg_tmp0.xxxx)).xy;
    // 8: flr
    reg_tmp13.y = (floor(reg_tmp13)).y;
    // 9: add
    reg_tmp13.x = (reg_tmp13.xxxx + -reg_tmp13.yyyy).x;
    // 10: cmp
    conditional_code = lessThanEqual(uniforms.f[5].ww, reg_tmp13.xx);
    // 11: ifc
    if (conditional_code.x) {
        sub_12_13();
    }
    // 13: mul
    reg_tmp14.xy = (mul_s(reg_tmp14, reg_tmp2)).xy;
    // 14: mul
    reg_tmp13.x = (mul_s(uniforms.f[5].zzzz, reg_tmp13.xxxx)).x;
    // 15: mul
    reg_tmp13 = mul_s(uniforms.f[5].zyzy, reg_tmp13.xxxx);
    // 16: flr
    reg_tmp13.zw = (floor(reg_tmp13)).zw;
    // 17: add
    reg_tmp13.xy = (reg_tmp13.xyyy + -reg_tmp13.zwww).xy;
    // 18: cmp
    conditional_code = lessThanEqual(uniforms.f[5].ww, reg_tmp13.xy);
    // 19: ifc
    if (conditional_code.y) {
        sub_20_21();
    }
    // 21: ifc
    if (conditional_code.x) {
        sub_22_24();
    }
    // 24: add
    reg_tmp14.xy = (uniforms.f[5].yyyy + -reg_tmp14.xyyy).xy;
    // 25: mul
    reg_tmp13.x = (mul_s(uniforms.f[5].zzzz, reg_tmp13.xxxx)).x;
    // 26: mul
    reg_tmp13 = mul_s(uniforms.f[5].zyzy, reg_tmp13.xxxx);
    // 27: flr
    reg_tmp13.zw = (floor(reg_tmp13)).zw;
    // 28: add
    reg_tmp13.xy = (reg_tmp13.xyyy + -reg_tmp13.zwww).xy;
    // 29: cmp
    conditional_code = lessThanEqual(uniforms.f[5].ww, reg_tmp13.xy);
    // 30: ifc
    if (conditional_code.y) {
        sub_31_32();
    }
    // 32: ifc
    if (conditional_code.x) {
        sub_33_34();
    }
    // 34: mul
    reg_tmp13.x = (mul_s(uniforms.f[5].zzzz, reg_tmp13.xxxx)).x;
    // 35: mul
    reg_tmp13 = mul_s(uniforms.f[5].zyzy, reg_tmp13.xxxx);
    // 36: flr
    reg_tmp13.zw = (floor(reg_tmp13)).zw;
    // 37: add
    reg_tmp13.xy = (reg_tmp13.xyyy + -reg_tmp13.zwww).xy;
    // 38: cmp
    conditional_code = lessThanEqual(uniforms.f[5].ww, reg_tmp13.xy);
    // 39: ifc
    if (conditional_code.y) {
        sub_40_41();
    }
    // 41: ifc
    if (conditional_code.x) {
        sub_42_43();
    }
    // 43: mul
    reg_tmp13.xy = (mul_s(uniforms.f[5].zzzz, reg_tmp0.xxxx)).xy;
    // 44: flr
    reg_tmp13.y = (floor(reg_tmp13)).y;
    // 45: add
    reg_tmp13.x = (reg_tmp13.xxxx + -reg_tmp13.yyyy).x;
    // 46: cmp
    conditional_code = lessThanEqual(uniforms.f[5].ww, reg_tmp13.xx);
    // 47: ifc
    if (conditional_code.x) {
        sub_48_49();
    }
    // 49: add
    reg_tmp12.y = (uniforms.f[5].yyyy + -reg_tmp12.yyyy).y;
    return false;
}
bool sub_12_13() {
    // 12: mov
    reg_tmp14.xy = (reg_tmp14.yxxx).xy;
    return false;
}
bool sub_20_21() {
    // 20: mul
    reg_tmp12.x = (mul_s(reg_tmp12.xxxx, reg_tmp14.xxxx)).x;
    return false;
}
bool sub_22_24() {
    // 22: madi
    reg_tmp12.y = (fma_s(reg_tmp12.yyyy, reg_tmp14.yyyy, uniforms.f[5].yyyy)).y;
    // 23: add
    reg_tmp12.y = (reg_tmp12.yyyy + -reg_tmp14.yyyy).y;
    return false;
}
bool sub_31_32() {
    // 31: add
    reg_tmp12.x = (reg_tmp12.xxxx + reg_tmp14.xxxx).x;
    return false;
}
bool sub_33_34() {
    // 33: add
    reg_tmp12.y = (reg_tmp12.yyyy + -reg_tmp14.yyyy).y;
    return false;
}
bool sub_40_41() {
    // 40: add
    reg_tmp12.x = (uniforms.f[5].yyyy + -reg_tmp12.xxxx).x;
    return false;
}
bool sub_42_43() {
    // 42: add
    reg_tmp12.y = (uniforms.f[5].yyyy + -reg_tmp12.yyyy).y;
    return false;
}
bool sub_48_49() {
    // 48: add
    reg_tmp12.xy = (uniforms.f[5].yyyy + -reg_tmp12.yxxx).xy;
    return false;
}
bool sub_52_69() {
    // 52: flr
    reg_tmp13.x = (floor(reg_tmp0.xxxx)).x;
    // 53: add
    reg_tmp13.x = (reg_tmp0.xxxx + -reg_tmp13).x;
    // 54: cmp
    conditional_code = lessThanEqual(uniforms.f[5].ww, reg_tmp13.xx);
    // 55: mov
    reg_tmp13 = uniforms.f[32 + address_registers.y].wzyx;
    // 56: ifc
    if (conditional_code.x) {
        sub_57_60();
    } else {
        sub_60_68();
    }
    // 68: add
    reg_tmp11.z = (uniforms.f[5].yyyy + reg_tmp11.zzzz).z;
    return false;
}
bool sub_57_60() {
    // 57: mad
    reg_tmp11.xy = (fma_s(reg_tmp12.xyyy, reg_tmp13.xyyy, reg_tmp13.zwww)).xy;
    // 58: mul
    reg_tmp11.xy = (mul_s(reg_tmp11.xyyy, reg_tmp14.zwww)).xy;
    // 59: add
    reg_tmp11.y = (uniforms.f[5].yyyy + -reg_tmp11.yyyy).y;
    return false;
}
bool sub_60_68() {
    // 60: cmp
    conditional_code = notEqual(uniforms.f[5].xx, vs_in_reg0.zw);
    // 61: ifc
    if (!conditional_code.x) {
        sub_62_63();
    } else {
        sub_63_64();
    }
    // 64: ifc
    if (!conditional_code.y) {
        sub_65_66();
    } else {
        sub_66_67();
    }
    // 67: nop
    return false;
}
bool sub_62_63() {
    // 62: mov
    reg_tmp11.x = (reg_tmp13.xxxx).x;
    return false;
}
bool sub_63_64() {
    // 63: mov
    reg_tmp11.x = (reg_tmp13.zzzz).x;
    return false;
}
bool sub_65_66() {
    // 65: mov
    reg_tmp11.y = (reg_tmp13.yyyy).y;
    return false;
}
bool sub_66_67() {
    // 66: mov
    reg_tmp11.y = (reg_tmp13.wwww).y;
    return false;
}
bool sub_69_96() {
    // 69: ifc
    if (!conditional_code.x) {
        sub_70_93();
    } else {
        sub_93_95();
    }
    // 95: add
    reg_tmp11.z = (uniforms.f[5].zzzz + reg_tmp11.zzzz).z;
    return false;
}
bool sub_70_93() {
    // 70: flr
    reg_tmp13.x = (floor(reg_tmp0.xxxx)).x;
    // 71: add
    reg_tmp13.x = (reg_tmp0.xxxx + -reg_tmp13).x;
    // 72: cmp
    conditional_code = lessThanEqual(uniforms.f[5].ww, reg_tmp13.xx);
    // 73: ifc
    if (conditional_code.x) {
        sub_74_79();
    } else {
        sub_79_92();
    }
    // 92: nop
    return false;
}
bool sub_74_79() {
    // 74: mov
    reg_tmp12.zw = (uniforms.f[5].xxxy).zw;
    // 75: dp4
    reg_tmp11.x = dot_s(uniforms.f[32 + address_registers.y].wzyx, reg_tmp12);
    // 76: dp4
    reg_tmp11.y = dot_s(uniforms.f[33 + address_registers.y].wzyx, reg_tmp12);
    // 77: mul
    reg_tmp11.xy = (mul_s(reg_tmp11.xyyy, reg_tmp14.zwww)).xy;
    // 78: add
    reg_tmp11.y = (uniforms.f[5].yyyy + -reg_tmp11.yyyy).y;
    return false;
}
bool sub_79_92() {
    // 79: mov
    reg_tmp14 = uniforms.f[32 + address_registers.y].wzyx;
    // 80: mov
    reg_tmp13 = uniforms.f[33 + address_registers.y].wzyx;
    // 81: cmp
    conditional_code = notEqual(uniforms.f[5].xx, vs_in_reg0.zw);
    // 82: ifc
    if (!conditional_code.y) {
        sub_83_87();
    } else {
        sub_87_91();
    }
    // 91: nop
    return false;
}
bool sub_83_87() {
    // 83: ifc
    if (!conditional_code.x) {
        sub_84_85();
    } else {
        sub_85_86();
    }
    // 86: nop
    return false;
}
bool sub_84_85() {
    // 84: mov
    reg_tmp11.xy = (reg_tmp14.xyyy).xy;
    return false;
}
bool sub_85_86() {
    // 85: mov
    reg_tmp11.xy = (reg_tmp13.zwww).xy;
    return false;
}
bool sub_87_91() {
    // 87: ifc
    if (!conditional_code.x) {
        sub_88_89();
    } else {
        sub_89_90();
    }
    // 90: nop
    return false;
}
bool sub_88_89() {
    // 88: mov
    reg_tmp11.xy = (reg_tmp13.xyyy).xy;
    return false;
}
bool sub_89_90() {
    // 89: mov
    reg_tmp11.xy = (reg_tmp14.zwww).xy;
    return false;
}
bool sub_93_95() {
    // 93: dp4
    reg_tmp11.x = dot_s(uniforms.f[32 + address_registers.y].wzyx, reg_tmp1);
    // 94: dp4
    reg_tmp11.y = dot_s(uniforms.f[33 + address_registers.y].wzyx, reg_tmp1);
    return false;
}
bool sub_97_109() {
    uint jmp_to = 97u;
    while (true) {
        switch (jmp_to) {
        case 97u: {
            // 97: dp4
            reg_tmp3.x = dot_s(uniforms.f[32 + address_registers.x].wzyx, reg_tmp1);
            // 98: dp4
            reg_tmp3.y = dot_s(uniforms.f[33 + address_registers.x].wzyx, reg_tmp1);
            // 99: dp4
            reg_tmp3.z = dot_s(uniforms.f[34 + address_registers.x].wzyx, reg_tmp1);
            // 100: mov
            reg_tmp3.w = (reg_tmp1.wwww).w;
            // 101: mov
            reg_tmp11 = uniforms.f[4].wzyx;
            // 102: add
            reg_tmp11.z = (-uniforms.f[34 + address_registers.x].xxxx + reg_tmp11.zzzz).z;
            // 103: cmp
            conditional_code.x = uniforms.f[5].xxxx.x != reg_tmp11.xzzz.x;
            conditional_code.y = uniforms.f[5].xxxx.y < reg_tmp11.xzzz.y;
            // 104: jmpc
            if (any(not(conditional_code))) {
                { jmp_to = 108u; break; }
            }
            // 105: rcp
            reg_tmp11.z = rcp_s(reg_tmp11.z);
            // 106: add
            reg_tmp3.x = (reg_tmp3.xxxx + reg_tmp11.xxxx).x;
            // 107: mad
            reg_tmp3.x = (fma_s(-reg_tmp11.yyyy, reg_tmp11.zzzz, reg_tmp3.xxxx)).x;
        }
        case 108u: {
            // 108: nop
        }
        default: return false;
        }
    }
    return false;
}
bool sub_109_4096() {
    uint jmp_to = 109u;
    while (true) {
        switch (jmp_to) {
        case 109u: {
            // 109: mova
            address_registers.x = (ivec2(vs_in_reg0.xx)).x;
            // 110: mov
            reg_tmp0 = uniforms.f[9 + address_registers.x].wzyx;
            // 111: mov
            reg_tmp1.xy = (vs_in_reg0.zwzw).xy;
            // 112: mov
            reg_tmp1.zw = (uniforms.f[5].xyxy).zw;
            // 113: mova
            address_registers.xy = ivec2(reg_tmp0.xy);
            // 114: mov
            reg_tmp2 = uniforms.f[32 + address_registers.y].wzyx;
            // 115: jmpu
            if (uniforms.b[0]) {
                { jmp_to = 191u; break; }
            }
            // 116: mov
            reg_tmp4 = uniforms.f[31 + address_registers.x].wzyx;
            // 117: mad
            reg_tmp1.xy = (fma_s(reg_tmp1.xyyy, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
            // 118: call
            {
                sub_97_109();
            }
            // 119: dp4
            vs_out_attr0.x = dot_s(uniforms.f[0].wzyx, reg_tmp3);
            // 120: dp4
            vs_out_attr0.y = dot_s(uniforms.f[1].wzyx, reg_tmp3);
            // 121: dp4
            vs_out_attr0.z = dot_s(uniforms.f[2].wzyx, reg_tmp3);
            // 122: dp4
            vs_out_attr0.w = dot_s(uniforms.f[3].wzyx, reg_tmp3);
            // 123: cmp
            conditional_code = greaterThanEqual(uniforms.f[5].yy, reg_tmp0.ww);
            // 124: ifc
            if (all(conditional_code)) {
                sub_125_127();
            } else {
                sub_127_149();
            }
            // 149: mov
            reg_tmp11.z = (reg_tmp0.zzzz).z;
            // 150: mul
            reg_tmp9 = mul_s(uniforms.f[5].zyzy, reg_tmp0.zzzz);
            // 151: flr
            reg_tmp9.xy = (floor(reg_tmp9)).xy;
            // 152: add
            reg_tmp9.xy = (reg_tmp9.zwww + -reg_tmp9.xyyy).xy;
            // 153: mul
            reg_tmp9 = mul_s(uniforms.f[5].zzzz, reg_tmp9);
            // 154: mov
            reg_tmp14 = uniforms.f[6].wzyx;
            // 155: mov
            reg_tmp11.xy = (reg_tmp9.xyyy).xy;
            // 156: call
            {
                sub_0_97();
            }
            // 157: ifu
            if (uniforms.b[1]) {
                sub_158_160();
            }
            // 160: ifu
            if (uniforms.b[2]) {
                sub_161_162();
            }
            // 162: mov
            vs_out_attr2 = reg_tmp11.xyyy;
            // 163: mul
            reg_tmp9 = mul_s(uniforms.f[5].zyzy, reg_tmp9.xxxx);
            // 164: flr
            reg_tmp9.xy = (floor(reg_tmp9)).xy;
            // 165: add
            reg_tmp9.xy = (reg_tmp9.zwww + -reg_tmp9.xyyy).xy;
            // 166: mul
            reg_tmp9 = mul_s(uniforms.f[5].zzzz, reg_tmp9);
            // 167: mov
            reg_tmp14 = uniforms.f[7].wzyx;
            // 168: mov
            reg_tmp11.xy = (reg_tmp9.xyyy).xy;
            // 169: call
            {
                sub_0_97();
            }
            // 170: ifu
            if (uniforms.b[3]) {
                sub_171_173();
            }
            // 173: ifu
            if (uniforms.b[4]) {
                sub_174_175();
            }
            // 175: mov
            vs_out_attr3 = reg_tmp11.xyyy;
            // 176: mul
            reg_tmp9 = mul_s(uniforms.f[5].zyzy, reg_tmp9.xxxx);
            // 177: flr
            reg_tmp9.xy = (floor(reg_tmp9)).xy;
            // 178: add
            reg_tmp9.xy = (reg_tmp9.zwww + -reg_tmp9.xyyy).xy;
            // 179: mul
            reg_tmp9 = mul_s(uniforms.f[5].zzzz, reg_tmp9);
            // 180: mov
            reg_tmp14 = uniforms.f[8].wzyx;
            // 181: mov
            reg_tmp11.xy = (reg_tmp9.xyyy).xy;
            // 182: call
            {
                sub_0_97();
            }
            // 183: ifu
            if (uniforms.b[5]) {
                sub_184_186();
            }
            // 186: ifu
            if (uniforms.b[6]) {
                sub_187_188();
            }
            // 188: mov
            vs_out_attr4 = reg_tmp11.xyyy;
            // 189: end
            return true;
        }
        case 191u: {
            // 191: add
            reg_tmp2.w = (reg_tmp2.wwww + reg_tmp2.yyyy).w;
            // 192: add
            reg_tmp1.y = (-uniforms.f[5].yyyy + -reg_tmp1.yyyy).y;
            // 193: mul
            reg_tmp13.xy = (mul_s(uniforms.f[36 + address_registers.x].wzzz, reg_tmp2.xyyy)).xy;
            // 194: mul
            reg_tmp11.x = (mul_s(uniforms.f[35 + address_registers.x].wwww, -reg_tmp1.yyyy)).x;
            // 195: mul
            reg_tmp1.xy = (mul_s(reg_tmp1.xyyy, reg_tmp13.xyyy)).xy;
            // 196: add
            reg_tmp1.x = (reg_tmp1.xxxx + reg_tmp11.xxxx).x;
            // 197: ifu
            if (uniforms.b[1]) {
                sub_198_207();
            }
            // 207: add
            reg_tmp1.xy = (reg_tmp1.xyyy + reg_tmp2.zwww).xy;
            // 208: add
            reg_tmp1.xy = (uniforms.f[36 + address_registers.x].yxxx + reg_tmp1.xyyy).xy;
            // 209: call
            {
                sub_97_109();
            }
            // 210: dp4
            vs_out_attr0.x = dot_s(uniforms.f[0].wzyx, reg_tmp3);
            // 211: dp4
            vs_out_attr0.y = dot_s(uniforms.f[1].wzyx, reg_tmp3);
            // 212: dp4
            vs_out_attr0.z = dot_s(uniforms.f[2].wzyx, reg_tmp3);
            // 213: dp4
            vs_out_attr0.w = dot_s(uniforms.f[3].wzyx, reg_tmp3);
            // 214: ifu
            if (uniforms.b[2]) {
                sub_215_223();
            } else {
                sub_223_227();
            }
            // 227: add
            reg_tmp8 = reg_tmp8 + -reg_tmp7;
            // 228: mad
            vs_out_attr1 = fma_s(reg_tmp8, reg_tmp11.yyyy, reg_tmp7);
            // 229: mul
            reg_tmp9.xy = (mul_s(uniforms.f[32 + address_registers.x].yxxx, reg_tmp11)).xy;
            // 230: slti
            reg_tmp11.zw = (vec4(lessThan(reg_tmp11, uniforms.f[5].yyyy))).zw;
            // 231: mad
            reg_tmp9.xy = (fma_s(reg_tmp11.zwww, uniforms.f[32 + address_registers.x].wzzz, reg_tmp9.xyyy)).xy;
            // 232: add
            reg_tmp9.y = (uniforms.f[5].yyyy + -reg_tmp9.yyyy).y;
            // 233: mov
            vs_out_attr2 = reg_tmp9;
            // 234: mov
            vs_out_attr3 = reg_tmp9;
            // 235: mov
            vs_out_attr4 = reg_tmp9;
            // 236: end
            return true;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_125_127() {
    // 125: mov
    vs_out_attr1.xyz = (uniforms.f[5].yyyy).xyz;
    // 126: mov
    vs_out_attr1.w = (reg_tmp0.wwww).w;
    return false;
}
bool sub_127_149() {
    // 127: mova
    address_registers.y = (ivec2(reg_tmp0.ww)).y;
    // 128: mov
    reg_tmp7 = uniforms.f[32 + address_registers.y].wzyx;
    // 129: mov
    reg_tmp8 = uniforms.f[33 + address_registers.y].wzyx;
    // 130: mov
    reg_tmp9 = uniforms.f[34 + address_registers.y].wzyx;
    // 131: mov
    reg_tmp10 = uniforms.f[35 + address_registers.y].wzyx;
    // 132: mov
    reg_tmp11.xy = (vs_in_reg0.zwww).xy;
    // 133: flr
    reg_tmp14.x = (floor(reg_tmp0.yyyy)).x;
    // 134: add
    reg_tmp14.x = (reg_tmp0.yyyy + -reg_tmp14.xxxx).x;
    // 135: cmp
    conditional_code = lessThanEqual(uniforms.f[5].ww, reg_tmp14.xx);
    // 136: ifc
    if (conditional_code.x) {
        sub_137_141();
    }
    // 141: max
    reg_tmp11.xy = (abs(reg_tmp11.xyyy)).xy;
    // 142: add
    reg_tmp8 = reg_tmp8 + -reg_tmp7;
    // 143: mad
    reg_tmp8 = fma_s(reg_tmp8, reg_tmp11.xxxx, reg_tmp7);
    // 144: add
    reg_tmp10 = reg_tmp10 + -reg_tmp9;
    // 145: mad
    reg_tmp10 = fma_s(reg_tmp10, reg_tmp11.xxxx, reg_tmp9);
    // 146: add
    reg_tmp10 = reg_tmp10 + -reg_tmp8;
    // 147: mad
    reg_tmp10 = fma_s(reg_tmp10, reg_tmp11.yyyy, reg_tmp8);
    // 148: mov
    vs_out_attr1 = reg_tmp10;
    return false;
}
bool sub_137_141() {
    // 137: rcp
    reg_tmp11.z = rcp_s(reg_tmp4.x);
    // 138: rcp
    reg_tmp11.w = rcp_s(reg_tmp4.y);
    // 139: add
    reg_tmp11.xy = (reg_tmp1.xyyy + -reg_tmp4.zwww).xy;
    // 140: mul
    reg_tmp11.xy = (mul_s(reg_tmp11.xyyy, reg_tmp11.zwww)).xy;
    return false;
}
bool sub_158_160() {
    // 158: mov
    reg_tmp11.xy = (reg_tmp11.yxxx).xy;
    // 159: add
    reg_tmp11.y = (uniforms.f[5].yyyy + -reg_tmp11.yyyy).y;
    return false;
}
bool sub_161_162() {
    // 161: add
    reg_tmp11.xy = (uniforms.f[5].yyyy + -reg_tmp11.yxxx).xy;
    return false;
}
bool sub_171_173() {
    // 171: mov
    reg_tmp11.xy = (reg_tmp11.yxxx).xy;
    // 172: add
    reg_tmp11.y = (uniforms.f[5].yyyy + -reg_tmp11.yyyy).y;
    return false;
}
bool sub_174_175() {
    // 174: add
    reg_tmp11.xy = (uniforms.f[5].yyyy + -reg_tmp11.yxxx).xy;
    return false;
}
bool sub_184_186() {
    // 184: mov
    reg_tmp11.xy = (reg_tmp11.yxxx).xy;
    // 185: add
    reg_tmp11.y = (uniforms.f[5].yyyy + -reg_tmp11.yyyy).y;
    return false;
}
bool sub_187_188() {
    // 187: add
    reg_tmp11.xy = (uniforms.f[5].yyyy + -reg_tmp11.yxxx).xy;
    return false;
}
bool sub_198_207() {
    // 198: mul
    reg_tmp13.xzw = (mul_s(uniforms.f[5].wxxx, reg_tmp13.xxxx)).xzw;
    // 199: mul
    reg_tmp13.y = (mul_s(uniforms.f[34 + address_registers.y].yyyy, reg_tmp13.yyyy)).y;
    // 200: mad
    reg_tmp11 = fma_s(reg_tmp1, uniforms.f[5].yyxx, -reg_tmp13);
    // 201: mov
    reg_tmp14 = uniforms.f[33 + address_registers.y].wzyx;
    // 202: dp3
    reg_tmp1.x = dot_3(reg_tmp11.xyz, reg_tmp14.xyy);
    // 203: dp3
    reg_tmp1.y = dot_3(reg_tmp11.xyz, reg_tmp14.zww);
    // 204: mov
    reg_tmp14 = uniforms.f[34 + address_registers.y].wzyx;
    // 205: dph
    reg_tmp1.z = dot_s(vec4(reg_tmp11.xyz, 1.0), reg_tmp14);
    // 206: add
    reg_tmp1.xy = (reg_tmp1.xyyy + reg_tmp13.xyyy).xy;
    return false;
}
bool sub_215_223() {
    // 215: max
    reg_tmp11 = abs(vs_in_reg0.zwzw);
    // 216: flr
    reg_tmp14.w = (floor(reg_tmp0.zzzz)).w;
    // 217: add
    reg_tmp14.w = (reg_tmp0.zzzz + -reg_tmp14).w;
    // 218: mova
    address_registers.xy = ivec2(reg_tmp0.zx);
    // 219: mul
    reg_tmp14.w = (mul_s(uniforms.f[5].zzzz, reg_tmp14.wwww)).w;
    // 220: mov
    reg_tmp14.xyz = (uniforms.f[5].yyyy).xyz;
    // 221: mul
    reg_tmp7 = mul_s(uniforms.f[37 + address_registers.y].wzyx, reg_tmp14);
    // 222: mul
    reg_tmp8 = mul_s(uniforms.f[38 + address_registers.y].wzyx, reg_tmp14);
    return false;
}
bool sub_223_227() {
    // 223: max
    reg_tmp11 = abs(vs_in_reg0.zwzw);
    // 224: mova
    address_registers.xy = ivec2(reg_tmp0.zw);
    // 225: mov
    reg_tmp7 = uniforms.f[32 + address_registers.y].wzyx;
    // 226: mov
    reg_tmp8 = uniforms.f[33 + address_registers.y].wzyx;
    return false;
}
// reference: BF76358E3E5B5134, 93C50366EC4126B4
// program: 93C50366EC4126B4, 5D764F9A6220D694, B5FDA4DDACF2E4C3
// reference: 6CF5F277E5E2F073, 93C50366EC4126B4
// program: 93C50366EC4126B4, 5D764F9A6220D694, BB9BA9D9496AD48E
// program: 93C50366EC4126B4, 5D764F9A6220D694, A1F07D18137744B0
// program: 93C50366EC4126B4, 5D764F9A6220D694, E04524D81D23AD4B
// shader: 8B31, 458EEA119FC06605

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;
 out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}


#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define mul_3(x, y) mix(x * y, vec3(0.0), isnan(x * y))
#define fma_s(x, y, z) (mul_s(x, y) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(mul_3(x, y), vec3(1.0))

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_76_103();
bool sub_78_83();
bool sub_83_102();
bool sub_86_92();
bool sub_92_101();
bool sub_93_97();
bool sub_97_100();
bool sub_103_127();
bool sub_105_109();
bool sub_109_126();
bool sub_110_124();
bool sub_113_120();
bool sub_120_123();
bool sub_124_125();
bool sub_127_143();
bool sub_129_133();
bool sub_133_142();
bool sub_134_140();
bool sub_140_141();
bool sub_143_151();
bool sub_145_146();
bool sub_146_150();
bool sub_147_148();
bool sub_148_149();
bool sub_151_158();
bool sub_158_166();
bool sub_166_4096();

bool exec_shader() {
    sub_166_4096();
    return true;
}

bool sub_76_103() {
    // 76: mov
    reg_tmp0.xy = (uniforms.f[0].xxxx).xy;
    // 77: ifu
    if (uniforms.b[2]) {
        sub_78_83();
    } else {
        sub_83_102();
    }
    // 102: nop
    return false;
}
bool sub_78_83() {
    // 78: call
    {
        sub_143_151();
    }
    // 79: dp4
    reg_tmp3.x = dot_s(uniforms.f[1].xywz, reg_tmp6);
    // 80: dp4
    reg_tmp3.y = dot_s(uniforms.f[2].xywz, reg_tmp6);
    // 81: mov
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    // 82: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_83_102() {
    // 83: cmp
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    // 84: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 85: ifc
    if (all(not(conditional_code))) {
        sub_86_92();
    } else {
        sub_92_101();
    }
    // 101: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_86_92() {
    // 86: mov
    reg_tmp6 = reg_tmp10;
    // 87: dp4
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    // 88: dp4
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    // 89: dp4
    reg_tmp3.z = dot_s(uniforms.f[3], reg_tmp6);
    // 90: mul
    reg_tmp0.xy = (mul_s(uniforms.f[9].xyyy, reg_tmp3.zzzz)).xy;
    // 91: add
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_92_101() {
    // 92: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_93_97();
    } else {
        sub_97_100();
    }
    // 100: nop
    return false;
}
bool sub_93_97() {
    // 93: call
    {
        sub_151_158();
    }
    // 94: dp3
    reg_tmp3.x = dot_3(uniforms.f[1].xyz, reg_tmp6.xyz);
    // 95: dp3
    reg_tmp3.y = dot_3(uniforms.f[2].xyz, reg_tmp6.xyz);
    // 96: dp3
    reg_tmp3.z = dot_3(uniforms.f[3].xyz, reg_tmp6.xyz);
    return false;
}
bool sub_97_100() {
    // 97: call
    {
        sub_158_166();
    }
    // 98: dp4
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    // 99: dp4
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    return false;
}
bool sub_103_127() {
    // 103: mov
    reg_tmp0.xy = (uniforms.f[0].yyyy).xy;
    // 104: ifu
    if (uniforms.b[3]) {
        sub_105_109();
    } else {
        sub_109_126();
    }
    // 126: nop
    return false;
}
bool sub_105_109() {
    // 105: call
    {
        sub_143_151();
    }
    // 106: dp4
    reg_tmp4.x = dot_s(uniforms.f[4].xywz, reg_tmp6);
    // 107: dp4
    reg_tmp4.y = dot_s(uniforms.f[5].xywz, reg_tmp6);
    // 108: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_109_126() {
    // 109: ifu
    if (uniforms.b[5]) {
        sub_110_124();
    } else {
        sub_124_125();
    }
    // 125: nop
    return false;
}
bool sub_110_124() {
    // 110: cmp
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    // 111: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 112: ifc
    if (all(not(conditional_code))) {
        sub_113_120();
    } else {
        sub_120_123();
    }
    // 123: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_113_120() {
    // 113: mov
    reg_tmp6 = reg_tmp10;
    // 114: dp4
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    // 115: dp4
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    // 116: dp4
    reg_tmp4.z = dot_s(uniforms.f[6], reg_tmp6);
    // 117: rcp
    reg_tmp6.w = rcp_s(reg_tmp4.z);
    // 118: mul
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    // 119: add
    reg_tmp4.xy = (uniforms.f[9].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_120_123() {
    // 120: call
    {
        sub_158_166();
    }
    // 121: dp4
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    // 122: dp4
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    return false;
}
bool sub_124_125() {
    // 124: mov
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_127_143() {
    // 127: mov
    reg_tmp0.xy = (uniforms.f[0].zzzz).xy;
    // 128: ifu
    if (uniforms.b[4]) {
        sub_129_133();
    } else {
        sub_133_142();
    }
    // 142: nop
    return false;
}
bool sub_129_133() {
    // 129: call
    {
        sub_143_151();
    }
    // 130: dp4
    reg_tmp5.x = dot_s(uniforms.f[7].xywz, reg_tmp6);
    // 131: dp4
    reg_tmp5.y = dot_s(uniforms.f[8].xywz, reg_tmp6);
    // 132: mov
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_133_142() {
    // 133: ifu
    if (uniforms.b[6]) {
        sub_134_140();
    } else {
        sub_140_141();
    }
    // 141: nop
    return false;
}
bool sub_134_140() {
    // 134: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 135: mov
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    // 136: call
    {
        sub_158_166();
    }
    // 137: dp4
    reg_tmp5.x = dot_s(uniforms.f[7], reg_tmp6);
    // 138: dp4
    reg_tmp5.y = dot_s(uniforms.f[8], reg_tmp6);
    // 139: mov
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_140_141() {
    // 140: mov
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
bool sub_143_151() {
    // 143: cmp
    conditional_code = equal(uniforms.f[93].yz, reg_tmp0.xy);
    // 144: ifc
    if (all(not(conditional_code))) {
        sub_145_146();
    } else {
        sub_146_150();
    }
    // 150: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_145_146() {
    // 145: mov
    reg_tmp6.xy = (vs_in_reg4.xyyy).xy;
    return false;
}
bool sub_146_150() {
    // 146: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_147_148();
    } else {
        sub_148_149();
    }
    // 149: nop
    return false;
}
bool sub_147_148() {
    // 147: mov
    reg_tmp6.xy = (vs_in_reg5.xyyy).xy;
    return false;
}
bool sub_148_149() {
    // 148: mov
    reg_tmp6.xy = (vs_in_reg6.xyyy).xy;
    return false;
}
bool sub_151_158() {
    // 151: mov
    reg_tmp2 = -reg_tmp15;
    // 152: dp3
    reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
    // 153: rsq
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    // 154: mul
    reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
    // 155: dp3
    reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
    // 156: add
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    // 157: mad
    reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_158_166() {
    // 158: call
    {
        sub_151_158();
    }
    // 159: mov
    reg_tmp1 = reg_tmp6;
    // 160: add
    reg_tmp1.z = (uniforms.f[93].yyyy + reg_tmp1.zzzz).z;
    // 161: dp3
    reg_tmp1 = vec4(dot_3(reg_tmp1.xyz, reg_tmp1.xyz));
    // 162: rsq
    reg_tmp2 = vec4(rsq_s(reg_tmp1.x));
    // 163: mul
    reg_tmp2 = mul_s(uniforms.f[94].xxxx, reg_tmp2);
    // 164: mul
    reg_tmp6.xy = (mul_s(reg_tmp6.xyyy, reg_tmp2)).xy;
    // 165: add
    reg_tmp6.xy = (uniforms.f[94].xxxx + reg_tmp6.xyyy).xy;
    return false;
}
bool sub_166_4096() {
    // 166: mov
    reg_tmp0 = vs_in_reg0;
    // 167: mov
    reg_tmp0.z = (uniforms.f[93].xxxx).z;
    // 168: mov
    reg_tmp0.w = (uniforms.f[93].yyyy).w;
    // 169: mov
    vs_out_attr0 = reg_tmp0;
    // 170: mov
    vs_out_attr2 = reg_tmp0;
    // 171: mov
    vs_out_attr1 = reg_tmp0;
    // 172: mov
    vs_out_attr3 = uniforms.f[93].yyyy;
    // 173: call
    {
        sub_76_103();
    }
    // 174: call
    {
        sub_103_127();
    }
    // 175: call
    {
        sub_127_143();
    }
    // 176: end
    return true;
}
// reference: EBE62C27FF86657D, 458EEA119FC06605
// program: 458EEA119FC06605, AD7922A63ED54CA7, 47C12CB4EFB88BF9
// program: 93C50366EC4126B4, 5D764F9A6220D694, ECB67079092E1152
// program: 93C50366EC4126B4, 5D764F9A6220D694, 20BCD1F2228017BC
// program: 93C50366EC4126B4, 5D764F9A6220D694, BF3EC3006F4471DB
// program: 93C50366EC4126B4, 5D764F9A6220D694, 21D2EFBCAB5A0E94
// shader: 8B30, BD5603BA886D2C8D

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 8ED580B893F17129, BD5603BA886D2C8D
// program: 93C50366EC4126B4, 5D764F9A6220D694, BD5603BA886D2C8D
// program: 619ABEE00AF51137, AD7922A63ED54CA7, 9EE99E5FCDE35D02
// program: 619ABEE00AF51137, AD7922A63ED54CA7, 339695138B1F3D79
// program: 619ABEE00AF51137, AD7922A63ED54CA7, 16A79528EEAC7041
// program: 619ABEE00AF51137, AD7922A63ED54CA7, 4AF296A8A412F55B
// program: 619ABEE00AF51137, AD7922A63ED54CA7, 52523E8864D2CEC6
// program: 619ABEE00AF51137, AD7922A63ED54CA7, 65D27335CA8277B4
// program: 619ABEE00AF51137, AD7922A63ED54CA7, EACDE6B1FDB46048
// program: 619ABEE00AF51137, AD7922A63ED54CA7, 9C1BD4D1E9CAB884
// program: 619ABEE00AF51137, AD7922A63ED54CA7, B681F102F49CF594
// shader: 8B31, 457C73F53FB014B8

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;
 out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}


#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define mul_3(x, y) mix(x * y, vec3(0.0), isnan(x * y))
#define fma_s(x, y, z) (mul_s(x, y) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(mul_3(x, y), vec3(1.0))

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_19();
bool sub_19_29();
bool sub_29_90();
bool sub_33_51();
bool sub_51_59();
bool sub_88_89();
bool sub_90_117();
bool sub_92_97();
bool sub_97_116();
bool sub_100_106();
bool sub_106_115();
bool sub_107_111();
bool sub_111_114();
bool sub_117_141();
bool sub_119_123();
bool sub_123_140();
bool sub_124_138();
bool sub_127_134();
bool sub_134_137();
bool sub_138_139();
bool sub_141_157();
bool sub_143_147();
bool sub_147_156();
bool sub_148_154();
bool sub_154_155();
bool sub_157_165();
bool sub_159_160();
bool sub_160_164();
bool sub_161_162();
bool sub_162_163();
bool sub_165_172();
bool sub_172_178();
bool sub_178_4096();
bool sub_180_187();
bool sub_187_188();

bool exec_shader() {
    sub_178_4096();
    return true;
}

bool sub_0_19() {
    uint jmp_to = 0u;
    while (true) {
        switch (jmp_to) {
        case 0u: {
            // 0: dp3
            reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
            // 1: dp3
            reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
            // 2: dp3
            reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
            // 3: dp3
            reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
            // 4: dp3
            reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
            // 5: rsq
            reg_tmp6.x = rsq_s(reg_tmp6.x);
            // 6: rsq
            reg_tmp7.x = rsq_s(reg_tmp7.x);
            // 7: mul
            reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 8: mul
            reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 9: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 10: add
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            // 11: mul
            reg_tmp4 = mul_s(uniforms.f[94].xxxx, reg_tmp4);
            // 12: cmp
            conditional_code = greaterThanEqual(uniforms.f[93].xx, reg_tmp4.xx);
            // 13: rsq
            reg_tmp4 = vec4(rsq_s(reg_tmp4.x));
            // 14: mul
            reg_tmp5 = mul_s(uniforms.f[94].xxxx, reg_tmp14);
            // 15: jmpc
            if (conditional_code.x) {
                { jmp_to = 18u; break; }
            }
            // 16: rcp
            reg_tmp0.z = rcp_s(reg_tmp4.x);
            // 17: mul
            reg_tmp0.xy = (mul_s(reg_tmp5, reg_tmp4)).xy;
        }
        case 18u: {
            // 18: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_19_29() {
    // 19: mova
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    // 20: nop
    // 21: dp4
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    // 22: dp4
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    // 23: dp4
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    // 24: dp3
    reg_tmp4.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    // 25: dp3
    reg_tmp4.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    // 26: dp3
    reg_tmp4.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    // 27: mad
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 28: mad
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_29_90() {
    // 29: mov
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    // 30: mov
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    // 31: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 32: ifu
    if (uniforms.b[0]) {
        sub_33_51();
    } else {
        sub_51_59();
    }
    // 59: dp4
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    // 60: dp4
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    // 61: dp4
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    // 62: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 63: call
    {
        sub_0_19();
    }
    // 64: nop
    // 65: mov
    vs_out_attr2 = -reg_tmp15;
    // 66: mov
    reg_tmp0.x = (uniforms.f[93].yyyy).x;
    // 67: mova
    address_registers.x = (ivec2(vs_in_reg3.xx)).x;
    // 68: nop
    // 69: mul
    reg_tmp0.x = (mul_s(uniforms.f[13 + address_registers.x].xxxx, reg_tmp0.xxxx)).x;
    // 70: mova
    address_registers.x = (ivec2(vs_in_reg3.yy)).x;
    // 71: nop
    // 72: mul
    reg_tmp0.x = (mul_s(uniforms.f[13 + address_registers.x].yyyy, reg_tmp0.xxxx)).x;
    // 73: mova
    address_registers.x = (ivec2(vs_in_reg3.zz)).x;
    // 74: nop
    // 75: mul
    reg_tmp0.x = (mul_s(uniforms.f[13 + address_registers.x].zzzz, reg_tmp0.xxxx)).x;
    // 76: mova
    address_registers.x = (ivec2(vs_in_reg3.ww)).x;
    // 77: nop
    // 78: mul
    reg_tmp0.x = (mul_s(uniforms.f[13 + address_registers.x].wwww, reg_tmp0.xxxx)).x;
    // 79: mul
    reg_tmp15.xyz = (mul_s(reg_tmp15.xyzz, reg_tmp0.xxxx)).xyz;
    // 80: dp4
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    // 81: dp4
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    // 82: dp4
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    // 83: dp4
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    // 84: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 85: mul
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    // 86: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 87: ifc
    if (all(conditional_code)) {
        sub_88_89();
    }
    // 89: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_33_51() {
    // 33: mov
    reg_tmp7 = uniforms.f[93].xxxx;
    // 34: mov
    reg_tmp12 = uniforms.f[93].xxxx;
    // 35: mul
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    // 36: cmp
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    // 37: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 38: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    // 39: call
    {
        sub_19_29();
    }
    // 40: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 41: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    // 42: call
    {
        sub_19_29();
    }
    // 43: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 44: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    // 45: call
    {
        sub_19_29();
    }
    // 46: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 47: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    // 48: call
    {
        sub_19_29();
    }
    // 49: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 50: mov
    reg_tmp10 = reg_tmp7;
    return false;
}
bool sub_51_59() {
    // 51: mov
    reg_tmp7 = reg_tmp15;
    // 52: dp4
    reg_tmp10.x = dot_s(uniforms.f[10], reg_tmp7);
    // 53: dp4
    reg_tmp10.y = dot_s(uniforms.f[11], reg_tmp7);
    // 54: dp4
    reg_tmp10.z = dot_s(uniforms.f[12], reg_tmp7);
    // 55: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 56: dp3
    reg_tmp12.x = dot_3(uniforms.f[10].xyz, reg_tmp14.xyz);
    // 57: dp3
    reg_tmp12.y = dot_3(uniforms.f[11].xyz, reg_tmp14.xyz);
    // 58: dp3
    reg_tmp12.z = dot_3(uniforms.f[12].xyz, reg_tmp14.xyz);
    return false;
}
bool sub_88_89() {
    // 88: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_90_117() {
    // 90: mov
    reg_tmp0.xy = (uniforms.f[0].xxxx).xy;
    // 91: ifu
    if (uniforms.b[2]) {
        sub_92_97();
    } else {
        sub_97_116();
    }
    // 116: nop
    return false;
}
bool sub_92_97() {
    // 92: call
    {
        sub_157_165();
    }
    // 93: dp4
    reg_tmp3.x = dot_s(uniforms.f[1].xywz, reg_tmp6);
    // 94: dp4
    reg_tmp3.y = dot_s(uniforms.f[2].xywz, reg_tmp6);
    // 95: mov
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    // 96: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_97_116() {
    // 97: cmp
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    // 98: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 99: ifc
    if (all(not(conditional_code))) {
        sub_100_106();
    } else {
        sub_106_115();
    }
    // 115: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_100_106() {
    // 100: mov
    reg_tmp6 = reg_tmp10;
    // 101: dp4
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    // 102: dp4
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    // 103: dp4
    reg_tmp3.z = dot_s(uniforms.f[3], reg_tmp6);
    // 104: mul
    reg_tmp0.xy = (mul_s(uniforms.f[9].xyyy, reg_tmp3.zzzz)).xy;
    // 105: add
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_106_115() {
    // 106: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_107_111();
    } else {
        sub_111_114();
    }
    // 114: nop
    return false;
}
bool sub_107_111() {
    // 107: call
    {
        sub_165_172();
    }
    // 108: dp3
    reg_tmp3.x = dot_3(uniforms.f[1].xyz, reg_tmp6.xyz);
    // 109: dp3
    reg_tmp3.y = dot_3(uniforms.f[2].xyz, reg_tmp6.xyz);
    // 110: dp3
    reg_tmp3.z = dot_3(uniforms.f[3].xyz, reg_tmp6.xyz);
    return false;
}
bool sub_111_114() {
    // 111: call
    {
        sub_172_178();
    }
    // 112: dp4
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    // 113: dp4
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    return false;
}
bool sub_117_141() {
    // 117: mov
    reg_tmp0.xy = (uniforms.f[0].yyyy).xy;
    // 118: ifu
    if (uniforms.b[3]) {
        sub_119_123();
    } else {
        sub_123_140();
    }
    // 140: nop
    return false;
}
bool sub_119_123() {
    // 119: call
    {
        sub_157_165();
    }
    // 120: dp4
    reg_tmp4.x = dot_s(uniforms.f[4].xywz, reg_tmp6);
    // 121: dp4
    reg_tmp4.y = dot_s(uniforms.f[5].xywz, reg_tmp6);
    // 122: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_123_140() {
    // 123: ifu
    if (uniforms.b[5]) {
        sub_124_138();
    } else {
        sub_138_139();
    }
    // 139: nop
    return false;
}
bool sub_124_138() {
    // 124: cmp
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    // 125: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 126: ifc
    if (all(not(conditional_code))) {
        sub_127_134();
    } else {
        sub_134_137();
    }
    // 137: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_127_134() {
    // 127: mov
    reg_tmp6 = reg_tmp10;
    // 128: dp4
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    // 129: dp4
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    // 130: dp4
    reg_tmp4.z = dot_s(uniforms.f[6], reg_tmp6);
    // 131: rcp
    reg_tmp6.w = rcp_s(reg_tmp4.z);
    // 132: mul
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    // 133: add
    reg_tmp4.xy = (uniforms.f[9].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_134_137() {
    // 134: call
    {
        sub_172_178();
    }
    // 135: dp4
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    // 136: dp4
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    return false;
}
bool sub_138_139() {
    // 138: mov
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_141_157() {
    // 141: mov
    reg_tmp0.xy = (uniforms.f[0].zzzz).xy;
    // 142: ifu
    if (uniforms.b[4]) {
        sub_143_147();
    } else {
        sub_147_156();
    }
    // 156: nop
    return false;
}
bool sub_143_147() {
    // 143: call
    {
        sub_157_165();
    }
    // 144: dp4
    reg_tmp5.x = dot_s(uniforms.f[7].xywz, reg_tmp6);
    // 145: dp4
    reg_tmp5.y = dot_s(uniforms.f[8].xywz, reg_tmp6);
    // 146: mov
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_147_156() {
    // 147: ifu
    if (uniforms.b[6]) {
        sub_148_154();
    } else {
        sub_154_155();
    }
    // 155: nop
    return false;
}
bool sub_148_154() {
    // 148: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 149: mov
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    // 150: call
    {
        sub_172_178();
    }
    // 151: dp4
    reg_tmp5.x = dot_s(uniforms.f[7], reg_tmp6);
    // 152: dp4
    reg_tmp5.y = dot_s(uniforms.f[8], reg_tmp6);
    // 153: mov
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_154_155() {
    // 154: mov
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
bool sub_157_165() {
    // 157: cmp
    conditional_code = equal(uniforms.f[93].yz, reg_tmp0.xy);
    // 158: ifc
    if (all(not(conditional_code))) {
        sub_159_160();
    } else {
        sub_160_164();
    }
    // 164: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_159_160() {
    // 159: mov
    reg_tmp6.xy = (vs_in_reg4.xyyy).xy;
    return false;
}
bool sub_160_164() {
    // 160: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_161_162();
    } else {
        sub_162_163();
    }
    // 163: nop
    return false;
}
bool sub_161_162() {
    // 161: mov
    reg_tmp6.xy = (vs_in_reg5.xyyy).xy;
    return false;
}
bool sub_162_163() {
    // 162: mov
    reg_tmp6.xy = (vs_in_reg6.xyyy).xy;
    return false;
}
bool sub_165_172() {
    // 165: mov
    reg_tmp2 = -reg_tmp15;
    // 166: dp3
    reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
    // 167: rsq
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    // 168: mul
    reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
    // 169: dp3
    reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
    // 170: add
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    // 171: mad
    reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_172_178() {
    // 172: mov
    reg_tmp1 = reg_tmp14;
    // 173: dp3
    reg_tmp2.w = dot_3(reg_tmp1.xyz, reg_tmp1.xyz);
    // 174: rsq
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    // 175: mul
    reg_tmp1 = mul_s(reg_tmp1, reg_tmp2.wwww);
    // 176: mul
    reg_tmp1 = mul_s(uniforms.f[94].xxxx, reg_tmp1);
    // 177: add
    reg_tmp6.xy = (uniforms.f[94].xxxx + reg_tmp1.xyyy).xy;
    return false;
}
bool sub_178_4096() {
    // 178: call
    {
        sub_29_90();
    }
    // 179: ifu
    if (uniforms.b[1]) {
        sub_180_187();
    } else {
        sub_187_188();
    }
    // 188: mov
    vs_out_attr3 = reg_tmp2;
    // 189: call
    {
        sub_90_117();
    }
    // 190: call
    {
        sub_117_141();
    }
    // 191: call
    {
        sub_141_157();
    }
    // 192: end
    return true;
}
bool sub_180_187() {
    // 180: dp3
    reg_tmp0 = vec4(dot_3(uniforms.f[83].xyz, reg_tmp12.xyz));
    // 181: max
    reg_tmp0 = max(uniforms.f[93].xxxx, reg_tmp0);
    // 182: mul
    reg_tmp0 = mul_s(uniforms.f[84], reg_tmp0);
    // 183: add
    reg_tmp0 = uniforms.f[85] + reg_tmp0;
    // 184: mov
    reg_tmp0.w = (uniforms.f[93].yyyy).w;
    // 185: mul
    reg_tmp1 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
    // 186: mul
    reg_tmp2 = mul_s(reg_tmp0, reg_tmp1);
    return false;
}
bool sub_187_188() {
    // 187: mul
    reg_tmp2 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
    return false;
}
// reference: 238F1CA8C9FB7F27, 457C73F53FB014B8
// program: 457C73F53FB014B8, AD7922A63ED54CA7, 6F631816794CF714
// program: 619ABEE00AF51137, AD7922A63ED54CA7, 1F02D705CD0FF35A
// program: 619ABEE00AF51137, AD7922A63ED54CA7, AFA7E256CC0E4CA8
// program: 619ABEE00AF51137, AD7922A63ED54CA7, AE19BF5D1615655B
// program: 619ABEE00AF51137, AD7922A63ED54CA7, 9AEA6425BCEBC6A1
// program: 619ABEE00AF51137, AD7922A63ED54CA7, 5B2355A74E739DAA
// program: 619ABEE00AF51137, AD7922A63ED54CA7, 302549A0D553595D
// program: 619ABEE00AF51137, AD7922A63ED54CA7, 8397200ACD21A598
// program: 619ABEE00AF51137, AD7922A63ED54CA7, 0224B477DBA96517
// program: 619ABEE00AF51137, AD7922A63ED54CA7, D2F06270356D0DFA
// program: 619ABEE00AF51137, AD7922A63ED54CA7, 10FDC659B905BF4C
// program: 619ABEE00AF51137, AD7922A63ED54CA7, F182435B6E756645
// program: 619ABEE00AF51137, AD7922A63ED54CA7, E20C116DDD65DC74
// program: 619ABEE00AF51137, AD7922A63ED54CA7, C056D3A957D09F20
// program: 619ABEE00AF51137, AD7922A63ED54CA7, 38BCB03CDA891EAB
// program: 619ABEE00AF51137, AD7922A63ED54CA7, 03EFF39D2689C425
// program: 458EEA119FC06605, AD7922A63ED54CA7, 0A9D7FF70CF16C7A
// program: 458EEA119FC06605, AD7922A63ED54CA7, 4FE101C8EBCDD984
// reference: 3865EBDE90DBA5BF, 458EEA119FC06605
// program: 93C50366EC4126B4, 5D764F9A6220D694, 666AF935179E17F3
// program: 93C50366EC4126B4, 5D764F9A6220D694, FD67B831C526BF4B
// program: 93C50366EC4126B4, 5D764F9A6220D694, 3BDC5CADABAA192D
// program: 93C50366EC4126B4, 5D764F9A6220D694, 1045BB32F597E545
// program: 619ABEE00AF51137, AD7922A63ED54CA7, 3323F8FDC088A936
// shader: 8B30, 640F42B61984D45F

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor1.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(texture_buffer_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: A10BA44298400D8A, 640F42B61984D45F
// program: 619ABEE00AF51137, AD7922A63ED54CA7, 640F42B61984D45F
// shader: 8B30, 76F8F7F30B5408EF

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D4F4BEF9083F90BA, 76F8F7F30B5408EF
// program: 619ABEE00AF51137, AD7922A63ED54CA7, 76F8F7F30B5408EF
// shader: 8B30, AB775DCE00F096BB

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor1.rgb) * (texcolor0.rgb) + (texcolor1.rgb) * (vec3(1.0) - (texcolor0.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.r) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (texcolor2.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (const_color[2].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 4813F809EB2BD90D, AB775DCE00F096BB
// program: 619ABEE00AF51137, AD7922A63ED54CA7, AB775DCE00F096BB
// shader: 8B30, 2B106C7690EA8110

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (texcolor2.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (const_color[2].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 55C660775F93AA9D, 2B106C7690EA8110
// program: 93C50366EC4126B4, 5D764F9A6220D694, 2B106C7690EA8110
// shader: 8B30, 1910FBB60C4F0820

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (texcolor2.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (const_color[2].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 55C66077A473DB24, 1910FBB60C4F0820
// program: 93C50366EC4126B4, 5D764F9A6220D694, 1910FBB60C4F0820
// reference: 6CF5F2770ADB6332, 93C50366EC4126B4
// shader: 8B30, C7939D9EA2B18A96

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (const_color[2].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 783519FFF0B542F7, C7939D9EA2B18A96
// program: 93C50366EC4126B4, 5D764F9A6220D694, C7939D9EA2B18A96
// shader: 8B30, 8CA438A649CE933E

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (const_color[2].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 783519FFFB82B8E3, 8CA438A649CE933E
// program: 93C50366EC4126B4, 5D764F9A6220D694, 8CA438A649CE933E
// shader: 8B31, 9289DBCB1EA8472D

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;
 out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}


#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define mul_3(x, y) mix(x * y, vec3(0.0), isnan(x * y))
#define fma_s(x, y, z) (mul_s(x, y) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(mul_3(x, y), vec3(1.0))

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_19();
bool sub_19_55();
bool sub_55_65();
bool sub_65_78();
bool sub_78_128();
bool sub_83_101();
bool sub_101_109();
bool sub_126_127();
bool sub_128_184();
bool sub_133_151();
bool sub_151_162();
bool sub_182_183();
bool sub_184_211();
bool sub_186_191();
bool sub_191_210();
bool sub_194_200();
bool sub_200_209();
bool sub_201_205();
bool sub_205_208();
bool sub_211_235();
bool sub_213_217();
bool sub_217_234();
bool sub_218_232();
bool sub_221_228();
bool sub_228_231();
bool sub_232_233();
bool sub_235_251();
bool sub_237_241();
bool sub_241_250();
bool sub_242_248();
bool sub_248_249();
bool sub_251_259();
bool sub_253_254();
bool sub_254_258();
bool sub_255_256();
bool sub_256_257();
bool sub_259_266();
bool sub_266_272();
bool sub_272_4096();
bool sub_273_275();
bool sub_275_277();
bool sub_278_285();
bool sub_285_286();

bool exec_shader() {
    sub_272_4096();
    return true;
}

bool sub_0_19() {
    uint jmp_to = 0u;
    while (true) {
        switch (jmp_to) {
        case 0u: {
            // 0: dp3
            reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
            // 1: dp3
            reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
            // 2: dp3
            reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
            // 3: dp3
            reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
            // 4: dp3
            reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
            // 5: rsq
            reg_tmp6.x = rsq_s(reg_tmp6.x);
            // 6: rsq
            reg_tmp7.x = rsq_s(reg_tmp7.x);
            // 7: mul
            reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 8: mul
            reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 9: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 10: add
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            // 11: mul
            reg_tmp4 = mul_s(uniforms.f[94].xxxx, reg_tmp4);
            // 12: cmp
            conditional_code = greaterThanEqual(uniforms.f[93].xx, reg_tmp4.xx);
            // 13: rsq
            reg_tmp4 = vec4(rsq_s(reg_tmp4.x));
            // 14: mul
            reg_tmp5 = mul_s(uniforms.f[94].xxxx, reg_tmp14);
            // 15: jmpc
            if (conditional_code.x) {
                { jmp_to = 18u; break; }
            }
            // 16: rcp
            reg_tmp0.z = rcp_s(reg_tmp4.x);
            // 17: mul
            reg_tmp0.xy = (mul_s(reg_tmp5, reg_tmp4)).xy;
        }
        case 18u: {
            // 18: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_19_55() {
    uint jmp_to = 19u;
    while (true) {
        switch (jmp_to) {
        case 19u: {
            // 19: dp3
            reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
            // 20: dp3
            reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
            // 21: rsq
            reg_tmp6.x = rsq_s(reg_tmp6.x);
            // 22: rsq
            reg_tmp7.x = rsq_s(reg_tmp7.x);
            // 23: mul
            reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 24: mul
            reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 25: mul
            reg_tmp13.xyz = (mul_s(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            // 26: mul
            reg_tmp11.xyz = (mul_s(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            // 27: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 28: mul
            reg_tmp13.xyz = (mul_s(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            // 29: mul
            reg_tmp11.xyz = (mul_s(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            // 30: mul
            reg_tmp5 = mul_s(reg_tmp14.yzxx, reg_tmp13.zxyy);
            // 31: mad
            reg_tmp5 = fma_s(-reg_tmp13.yzxx, reg_tmp14.zxyy, reg_tmp5);
            // 32: dp3
            reg_tmp5.w = dot_3(reg_tmp5.xyz, reg_tmp5.xyz);
            // 33: rsq
            reg_tmp5.w = rsq_s(reg_tmp5.w);
            // 34: mul
            reg_tmp5 = mul_s(reg_tmp5, reg_tmp5.wwww);
            // 35: add
            reg_tmp6.w = (reg_tmp14.zzzz + reg_tmp5.yyyy).w;
            // 36: mul
            reg_tmp13 = mul_s(reg_tmp5.yzxx, reg_tmp14.zxyy);
            // 37: mad
            reg_tmp13 = fma_s(-reg_tmp14.yzxx, reg_tmp5.zxyy, reg_tmp13);
            // 38: add
            reg_tmp6.w = (reg_tmp13.xxxx + reg_tmp6).w;
            // 39: mov
            reg_tmp13.w = (reg_tmp5.zzzz).w;
            // 40: mov
            reg_tmp5.z = (reg_tmp13.xxxx).z;
            // 41: add
            reg_tmp6.w = (uniforms.f[93].yyyy + reg_tmp6).w;
            // 42: mov
            reg_tmp14.w = (reg_tmp5.xxxx).w;
            // 43: mov
            reg_tmp5.x = (reg_tmp14.zzzz).x;
            // 44: cmp
            conditional_code = lessThan(uniforms.f[94].zz, reg_tmp6.ww);
            // 45: mov
            reg_tmp6.x = (uniforms.f[93].yyyy).x;
            // 46: mov
            reg_tmp6.y = (-uniforms.f[93].yyyy).y;
            // 47: jmpc
            if (!conditional_code.x) {
                { jmp_to = 54u; break; }
            }
            // 48: add
            reg_tmp7.xz = (reg_tmp13.wwyy + -reg_tmp14.yyww).xz;
            // 49: add
            reg_tmp7.y = (reg_tmp14.xxxx + -reg_tmp13.zzzz).y;
            // 50: mov
            reg_tmp7.w = (reg_tmp6).w;
            // 51: dp4
            reg_tmp6 = vec4(dot_s(reg_tmp7, reg_tmp7));
            // 52: rsq
            reg_tmp6 = vec4(rsq_s(reg_tmp6.x));
            // 53: mul
            reg_tmp0 = mul_s(reg_tmp7, reg_tmp6);
        }
        case 54u: {
            // 54: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_55_65() {
    // 55: mova
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    // 56: nop
    // 57: dp4
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    // 58: dp4
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    // 59: dp4
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    // 60: dp3
    reg_tmp4.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    // 61: dp3
    reg_tmp4.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    // 62: dp3
    reg_tmp4.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    // 63: mad
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 64: mad
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_65_78() {
    // 65: mova
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    // 66: dp4
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    // 67: dp4
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    // 68: dp4
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    // 69: dp3
    reg_tmp4.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    // 70: dp3
    reg_tmp4.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    // 71: dp3
    reg_tmp4.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    // 72: dp3
    reg_tmp5.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp13.xyz);
    // 73: dp3
    reg_tmp5.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp13.xyz);
    // 74: dp3
    reg_tmp5.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp13.xyz);
    // 75: mad
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 76: mad
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    // 77: mad
    reg_tmp11 = fma_s(reg_tmp1.wwww, reg_tmp5, reg_tmp11);
    return false;
}
bool sub_78_128() {
    // 78: mov
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    // 79: mov
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    // 80: mov
    reg_tmp13.xyz = (vs_in_reg2).xyz;
    // 81: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 82: ifu
    if (uniforms.b[0]) {
        sub_83_101();
    } else {
        sub_101_109();
    }
    // 109: dp3
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    // 110: dp3
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    // 111: dp3
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    // 112: call
    {
        sub_0_19();
    }
    // 113: dp4
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    // 114: dp4
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    // 115: dp4
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    // 116: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 117: mov
    vs_out_attr2 = -reg_tmp15;
    // 118: dp4
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    // 119: dp4
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    // 120: dp4
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    // 121: dp4
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    // 122: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 123: mul
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    // 124: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 125: ifc
    if (all(conditional_code)) {
        sub_126_127();
    }
    // 127: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_83_101() {
    // 83: mov
    reg_tmp7 = uniforms.f[93].xxxx;
    // 84: mov
    reg_tmp12 = uniforms.f[93].xxxx;
    // 85: mul
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    // 86: cmp
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    // 87: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 88: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    // 89: call
    {
        sub_55_65();
    }
    // 90: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 91: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    // 92: call
    {
        sub_55_65();
    }
    // 93: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 94: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    // 95: call
    {
        sub_55_65();
    }
    // 96: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 97: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    // 98: call
    {
        sub_55_65();
    }
    // 99: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 100: mov
    reg_tmp10 = reg_tmp7;
    return false;
}
bool sub_101_109() {
    // 101: mov
    reg_tmp7 = reg_tmp15;
    // 102: dp4
    reg_tmp10.x = dot_s(uniforms.f[10], reg_tmp7);
    // 103: dp4
    reg_tmp10.y = dot_s(uniforms.f[11], reg_tmp7);
    // 104: dp4
    reg_tmp10.z = dot_s(uniforms.f[12], reg_tmp7);
    // 105: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 106: dp3
    reg_tmp12.x = dot_3(uniforms.f[10].xyz, reg_tmp14.xyz);
    // 107: dp3
    reg_tmp12.y = dot_3(uniforms.f[11].xyz, reg_tmp14.xyz);
    // 108: dp3
    reg_tmp12.z = dot_3(uniforms.f[12].xyz, reg_tmp14.xyz);
    return false;
}
bool sub_126_127() {
    // 126: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_128_184() {
    // 128: mov
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    // 129: mov
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    // 130: mov
    reg_tmp13.xyz = (vs_in_reg2).xyz;
    // 131: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 132: ifu
    if (uniforms.b[0]) {
        sub_133_151();
    } else {
        sub_151_162();
    }
    // 162: dp3
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    // 163: dp3
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    // 164: dp3
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    // 165: dp3
    reg_tmp13.x = dot_3(uniforms.f[90].xyz, reg_tmp11.xyz);
    // 166: dp3
    reg_tmp13.y = dot_3(uniforms.f[91].xyz, reg_tmp11.xyz);
    // 167: dp3
    reg_tmp13.z = dot_3(uniforms.f[92].xyz, reg_tmp11.xyz);
    // 168: call
    {
        sub_19_55();
    }
    // 169: dp4
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    // 170: dp4
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    // 171: dp4
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    // 172: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 173: mov
    vs_out_attr2 = -reg_tmp15;
    // 174: dp4
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    // 175: dp4
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    // 176: dp4
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    // 177: dp4
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    // 178: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 179: mul
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    // 180: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 181: ifc
    if (all(conditional_code)) {
        sub_182_183();
    }
    // 183: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_133_151() {
    // 133: mov
    reg_tmp7 = uniforms.f[93].xxxx;
    // 134: mov
    reg_tmp12 = uniforms.f[93].xxxx;
    // 135: mul
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    // 136: cmp
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    // 137: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 138: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    // 139: call
    {
        sub_65_78();
    }
    // 140: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 141: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    // 142: call
    {
        sub_65_78();
    }
    // 143: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 144: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    // 145: call
    {
        sub_65_78();
    }
    // 146: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 147: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    // 148: call
    {
        sub_65_78();
    }
    // 149: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 150: mov
    reg_tmp10 = reg_tmp7;
    return false;
}
bool sub_151_162() {
    // 151: mov
    reg_tmp7 = reg_tmp15;
    // 152: dp4
    reg_tmp10.x = dot_s(uniforms.f[10], reg_tmp7);
    // 153: dp4
    reg_tmp10.y = dot_s(uniforms.f[11], reg_tmp7);
    // 154: dp4
    reg_tmp10.z = dot_s(uniforms.f[12], reg_tmp7);
    // 155: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 156: dp3
    reg_tmp12.x = dot_3(uniforms.f[10].xyz, reg_tmp14.xyz);
    // 157: dp3
    reg_tmp12.y = dot_3(uniforms.f[11].xyz, reg_tmp14.xyz);
    // 158: dp3
    reg_tmp12.z = dot_3(uniforms.f[12].xyz, reg_tmp14.xyz);
    // 159: dp3
    reg_tmp11.x = dot_3(uniforms.f[10].xyz, reg_tmp13.xyz);
    // 160: dp3
    reg_tmp11.y = dot_3(uniforms.f[11].xyz, reg_tmp13.xyz);
    // 161: dp3
    reg_tmp11.z = dot_3(uniforms.f[12].xyz, reg_tmp13.xyz);
    return false;
}
bool sub_182_183() {
    // 182: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_184_211() {
    // 184: mov
    reg_tmp0.xy = (uniforms.f[0].xxxx).xy;
    // 185: ifu
    if (uniforms.b[2]) {
        sub_186_191();
    } else {
        sub_191_210();
    }
    // 210: nop
    return false;
}
bool sub_186_191() {
    // 186: call
    {
        sub_251_259();
    }
    // 187: dp4
    reg_tmp3.x = dot_s(uniforms.f[1].xywz, reg_tmp6);
    // 188: dp4
    reg_tmp3.y = dot_s(uniforms.f[2].xywz, reg_tmp6);
    // 189: mov
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    // 190: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_191_210() {
    // 191: cmp
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    // 192: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 193: ifc
    if (all(not(conditional_code))) {
        sub_194_200();
    } else {
        sub_200_209();
    }
    // 209: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_194_200() {
    // 194: mov
    reg_tmp6 = reg_tmp10;
    // 195: dp4
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    // 196: dp4
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    // 197: dp4
    reg_tmp3.z = dot_s(uniforms.f[3], reg_tmp6);
    // 198: mul
    reg_tmp0.xy = (mul_s(uniforms.f[9].xyyy, reg_tmp3.zzzz)).xy;
    // 199: add
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_200_209() {
    // 200: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_201_205();
    } else {
        sub_205_208();
    }
    // 208: nop
    return false;
}
bool sub_201_205() {
    // 201: call
    {
        sub_259_266();
    }
    // 202: dp3
    reg_tmp3.x = dot_3(uniforms.f[1].xyz, reg_tmp6.xyz);
    // 203: dp3
    reg_tmp3.y = dot_3(uniforms.f[2].xyz, reg_tmp6.xyz);
    // 204: dp3
    reg_tmp3.z = dot_3(uniforms.f[3].xyz, reg_tmp6.xyz);
    return false;
}
bool sub_205_208() {
    // 205: call
    {
        sub_266_272();
    }
    // 206: dp4
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    // 207: dp4
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    return false;
}
bool sub_211_235() {
    // 211: mov
    reg_tmp0.xy = (uniforms.f[0].yyyy).xy;
    // 212: ifu
    if (uniforms.b[3]) {
        sub_213_217();
    } else {
        sub_217_234();
    }
    // 234: nop
    return false;
}
bool sub_213_217() {
    // 213: call
    {
        sub_251_259();
    }
    // 214: dp4
    reg_tmp4.x = dot_s(uniforms.f[4].xywz, reg_tmp6);
    // 215: dp4
    reg_tmp4.y = dot_s(uniforms.f[5].xywz, reg_tmp6);
    // 216: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_217_234() {
    // 217: ifu
    if (uniforms.b[5]) {
        sub_218_232();
    } else {
        sub_232_233();
    }
    // 233: nop
    return false;
}
bool sub_218_232() {
    // 218: cmp
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    // 219: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 220: ifc
    if (all(not(conditional_code))) {
        sub_221_228();
    } else {
        sub_228_231();
    }
    // 231: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_221_228() {
    // 221: mov
    reg_tmp6 = reg_tmp10;
    // 222: dp4
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    // 223: dp4
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    // 224: dp4
    reg_tmp4.z = dot_s(uniforms.f[6], reg_tmp6);
    // 225: rcp
    reg_tmp6.w = rcp_s(reg_tmp4.z);
    // 226: mul
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    // 227: add
    reg_tmp4.xy = (uniforms.f[9].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_228_231() {
    // 228: call
    {
        sub_266_272();
    }
    // 229: dp4
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    // 230: dp4
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    return false;
}
bool sub_232_233() {
    // 232: mov
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_235_251() {
    // 235: mov
    reg_tmp0.xy = (uniforms.f[0].zzzz).xy;
    // 236: ifu
    if (uniforms.b[4]) {
        sub_237_241();
    } else {
        sub_241_250();
    }
    // 250: nop
    return false;
}
bool sub_237_241() {
    // 237: call
    {
        sub_251_259();
    }
    // 238: dp4
    reg_tmp5.x = dot_s(uniforms.f[7].xywz, reg_tmp6);
    // 239: dp4
    reg_tmp5.y = dot_s(uniforms.f[8].xywz, reg_tmp6);
    // 240: mov
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_241_250() {
    // 241: ifu
    if (uniforms.b[6]) {
        sub_242_248();
    } else {
        sub_248_249();
    }
    // 249: nop
    return false;
}
bool sub_242_248() {
    // 242: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 243: mov
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    // 244: call
    {
        sub_266_272();
    }
    // 245: dp4
    reg_tmp5.x = dot_s(uniforms.f[7], reg_tmp6);
    // 246: dp4
    reg_tmp5.y = dot_s(uniforms.f[8], reg_tmp6);
    // 247: mov
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_248_249() {
    // 248: mov
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
bool sub_251_259() {
    // 251: cmp
    conditional_code = equal(uniforms.f[93].yz, reg_tmp0.xy);
    // 252: ifc
    if (all(not(conditional_code))) {
        sub_253_254();
    } else {
        sub_254_258();
    }
    // 258: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_253_254() {
    // 253: mov
    reg_tmp6.xy = (vs_in_reg4.xyyy).xy;
    return false;
}
bool sub_254_258() {
    // 254: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_255_256();
    } else {
        sub_256_257();
    }
    // 257: nop
    return false;
}
bool sub_255_256() {
    // 255: mov
    reg_tmp6.xy = (vs_in_reg5.xyyy).xy;
    return false;
}
bool sub_256_257() {
    // 256: mov
    reg_tmp6.xy = (vs_in_reg6.xyyy).xy;
    return false;
}
bool sub_259_266() {
    // 259: mov
    reg_tmp2 = -reg_tmp15;
    // 260: dp3
    reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
    // 261: rsq
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    // 262: mul
    reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
    // 263: dp3
    reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
    // 264: add
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    // 265: mad
    reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_266_272() {
    // 266: mov
    reg_tmp1 = reg_tmp14;
    // 267: dp3
    reg_tmp2.w = dot_3(reg_tmp1.xyz, reg_tmp1.xyz);
    // 268: rsq
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    // 269: mul
    reg_tmp1 = mul_s(reg_tmp1, reg_tmp2.wwww);
    // 270: mul
    reg_tmp1 = mul_s(uniforms.f[94].xxxx, reg_tmp1);
    // 271: add
    reg_tmp6.xy = (uniforms.f[94].xxxx + reg_tmp1.xyyy).xy;
    return false;
}
bool sub_272_4096() {
    // 272: ifu
    if (uniforms.b[10]) {
        sub_273_275();
    } else {
        sub_275_277();
    }
    // 277: ifu
    if (uniforms.b[1]) {
        sub_278_285();
    } else {
        sub_285_286();
    }
    // 286: mov
    vs_out_attr3 = reg_tmp2;
    // 287: call
    {
        sub_184_211();
    }
    // 288: call
    {
        sub_211_235();
    }
    // 289: call
    {
        sub_235_251();
    }
    // 290: end
    return true;
}
bool sub_273_275() {
    // 273: call
    {
        sub_128_184();
    }
    // 274: nop
    return false;
}
bool sub_275_277() {
    // 275: call
    {
        sub_78_128();
    }
    // 276: nop
    return false;
}
bool sub_278_285() {
    // 278: dp3
    reg_tmp0 = vec4(dot_3(uniforms.f[83].xyz, reg_tmp12.xyz));
    // 279: max
    reg_tmp0 = max(uniforms.f[93].xxxx, reg_tmp0);
    // 280: mul
    reg_tmp0 = mul_s(uniforms.f[84], reg_tmp0);
    // 281: add
    reg_tmp0 = uniforms.f[85] + reg_tmp0;
    // 282: mov
    reg_tmp0.w = (uniforms.f[93].yyyy).w;
    // 283: mul
    reg_tmp1 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
    // 284: mul
    reg_tmp2 = mul_s(reg_tmp0, reg_tmp1);
    return false;
}
bool sub_285_286() {
    // 285: mul
    reg_tmp2 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
    return false;
}
// reference: 9D04A1EB4447144A, 9289DBCB1EA8472D
// shader: 8B30, 9D930D569CF26E15

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) + (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor1.r) + (const_color[0].a) - 0.5, 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) - (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 7F10713B89B30A02, 9D930D569CF26E15
// program: 9289DBCB1EA8472D, AD7922A63ED54CA7, 9D930D569CF26E15
// reference: BF76358E474F9AD2, 93C50366EC4126B4
// shader: 8B30, A696A9DBBC1702B3

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) - (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 9B69AC991B4FCF91, A696A9DBBC1702B3
// program: 93C50366EC4126B4, 5D764F9A6220D694, A696A9DBBC1702B3
// reference: 6CF5F27773CFA8D4, 93C50366EC4126B4
// shader: 8B30, 57D6B37A68031849

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) - (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 9B69AC99E0AFBE28, 57D6B37A68031849
// program: 93C50366EC4126B4, 5D764F9A6220D694, 57D6B37A68031849
// shader: 8B30, 1342087E86EF0022

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) + (texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((const_color[1].rgb) * (texcolor2.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a) * (const_color[5].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 88BE7793AC0D0138, 1342087E86EF0022
// program: 619ABEE00AF51137, AD7922A63ED54CA7, 1342087E86EF0022
// reference: 4E87661215BFC649, 619ABEE00AF51137
// shader: 8B30, 7934A1C8FECBC53A

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor1.r) + (texcolor0.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) + (texcolor1.rrr), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (const_color[2].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: B2FF021960ACB158, 7934A1C8FECBC53A
// program: 619ABEE00AF51137, AD7922A63ED54CA7, 7934A1C8FECBC53A
// shader: 8B31, C928D489F43DD72A

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;
 out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}


#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define mul_3(x, y) mix(x * y, vec3(0.0), isnan(x * y))
#define fma_s(x, y, z) (mul_s(x, y) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(mul_3(x, y), vec3(1.0))

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_49();
bool sub_25_31();
bool sub_32_39();
bool sub_40_48();
bool sub_175_202();
bool sub_177_182();
bool sub_182_201();
bool sub_185_191();
bool sub_191_200();
bool sub_192_196();
bool sub_196_199();
bool sub_202_226();
bool sub_204_208();
bool sub_208_225();
bool sub_209_223();
bool sub_212_219();
bool sub_219_222();
bool sub_223_224();
bool sub_226_242();
bool sub_228_232();
bool sub_232_241();
bool sub_233_239();
bool sub_239_240();
bool sub_242_250();
bool sub_244_245();
bool sub_245_249();
bool sub_246_247();
bool sub_247_248();
bool sub_343_350();
bool sub_350_354();
bool sub_354_4096();
bool sub_361_363();
bool sub_363_364();

bool exec_shader() {
    sub_354_4096();
    return true;
}

bool sub_0_49() {
    // 0: mov
    reg_tmp1.xyz = (uniforms.f[93].xxyx).xyz;
    // 1: dp3
    reg_tmp8.x = dot_3(uniforms.f[0].xyz, reg_tmp12.xyz);
    // 2: dp3
    reg_tmp8.y = dot_3(uniforms.f[1].xyz, reg_tmp12.xyz);
    // 3: dp3
    reg_tmp8.z = dot_3(uniforms.f[2].xyz, reg_tmp12.xyz);
    // 4: dp3
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp8.xyz);
    // 5: dp3
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp8.xyz);
    // 6: dp3
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp8.xyz);
    // 7: mov
    reg_tmp14.w = (uniforms.f[93].xxxx).w;
    // 8: mov
    reg_tmp8 = reg_tmp14;
    // 9: dp4
    reg_tmp14.x = dot_s(reg_tmp8, reg_tmp8);
    // 10: rsq
    reg_tmp14.x = rsq_s(reg_tmp14.x);
    // 11: mul
    reg_tmp14 = mul_s(reg_tmp8, reg_tmp14.xxxx);
    // 12: mov
    reg_tmp0 = uniforms.f[23];
    // 13: dp3
    reg_tmp8.x = dot_3(uniforms.f[0].xyz, reg_tmp0.xyz);
    // 14: dp3
    reg_tmp8.y = dot_3(uniforms.f[1].xyz, reg_tmp0.xyz);
    // 15: dp3
    reg_tmp8.z = dot_3(uniforms.f[2].xyz, reg_tmp0.xyz);
    // 16: dp3
    reg_tmp6.x = dot_3(uniforms.f[90].xyz, reg_tmp8.xyz);
    // 17: dp3
    reg_tmp6.y = dot_3(uniforms.f[91].xyz, reg_tmp8.xyz);
    // 18: dp3
    reg_tmp6.z = dot_3(uniforms.f[92].xyz, reg_tmp8.xyz);
    // 19: add
    reg_tmp8.xyz = (reg_tmp6.xyzz + reg_tmp1.xyzz).xyz;
    // 20: mov
    reg_tmp8.w = (uniforms.f[93].xxxx).w;
    // 21: dp4
    reg_tmp0.x = dot_s(reg_tmp8, reg_tmp8);
    // 22: rsq
    reg_tmp0.x = rsq_s(reg_tmp0.x);
    // 23: mul
    reg_tmp0 = mul_s(reg_tmp8, reg_tmp0.xxxx);
    // 24: ifu
    if (uniforms.b[5]) {
        sub_25_31();
    }
    // 31: ifu
    if (uniforms.b[3]) {
        sub_32_39();
    }
    // 39: ifu
    if (uniforms.b[4]) {
        sub_40_48();
    }
    // 48: mov
    vs_out_attr3 = reg_tmp2;
    return false;
}
bool sub_25_31() {
    // 25: dp3
    reg_tmp8.x = dot_3(reg_tmp14.xyz, -reg_tmp6.xyz);
    // 26: dp3
    reg_tmp8.y = dot_3(reg_tmp1.xyz, -reg_tmp6.xyz);
    // 27: max
    reg_tmp8 = max(uniforms.f[93].xxxx, reg_tmp8);
    // 28: mul
    reg_tmp8.y = (mul_s(uniforms.f[94].zzzz, reg_tmp8.yyyy)).y;
    // 29: add
    reg_tmp8.y = (uniforms.f[94].zzzz + reg_tmp8.yyyy).y;
    // 30: mul
    reg_tmp2.y = (mul_s(reg_tmp8.xxxx, reg_tmp8.yyyy)).y;
    return false;
}
bool sub_32_39() {
    // 32: dp3
    reg_tmp9.z = dot_3(reg_tmp14.xyz, reg_tmp0.xyz);
    // 33: max
    reg_tmp9.z = (max(uniforms.f[93].xxxx, reg_tmp9.zzzz)).z;
    // 34: min
    reg_tmp9.z = (min(uniforms.f[93].yyyy, reg_tmp9.zzzz)).z;
    // 35: log
    reg_tmp9.z = log2(reg_tmp9.z);
    // 36: mul
    reg_tmp9.z = (mul_s(uniforms.f[22].zzzz, reg_tmp9.zzzz)).z;
    // 37: exp
    reg_tmp9.z = exp2(reg_tmp9.z);
    // 38: mul
    reg_tmp2.z = (mul_s(uniforms.f[22].wwww, reg_tmp9.zzzz)).z;
    return false;
}
bool sub_40_48() {
    // 40: dp3
    reg_tmp9.x = dot_3(reg_tmp14.xyz, reg_tmp1.xyz);
    // 41: max
    reg_tmp9.x = (max(uniforms.f[93].xxxx, reg_tmp9.xxxx)).x;
    // 42: min
    reg_tmp9.x = (min(uniforms.f[93].yyyy, reg_tmp9.xxxx)).x;
    // 43: add
    reg_tmp9.x = (uniforms.f[93].yyyy + -reg_tmp9.xxxx).x;
    // 44: log
    reg_tmp9.x = log2(reg_tmp9.x);
    // 45: mul
    reg_tmp9.x = (mul_s(uniforms.f[22].xxxx, reg_tmp9.xxxx)).x;
    // 46: exp
    reg_tmp9.x = exp2(reg_tmp9.x);
    // 47: mul
    reg_tmp2.w = (mul_s(uniforms.f[22].yyyy, reg_tmp9.xxxx)).w;
    return false;
}
bool sub_175_202() {
    // 175: mov
    reg_tmp0.xy = (uniforms.f[10].xxxx).xy;
    // 176: ifu
    if (uniforms.b[9]) {
        sub_177_182();
    } else {
        sub_182_201();
    }
    // 201: nop
    return false;
}
bool sub_177_182() {
    // 177: call
    {
        sub_242_250();
    }
    // 178: dp4
    reg_tmp3.x = dot_s(uniforms.f[11].xywz, reg_tmp6);
    // 179: dp4
    reg_tmp3.y = dot_s(uniforms.f[12].xywz, reg_tmp6);
    // 180: mov
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    // 181: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_182_201() {
    // 182: cmp
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    // 183: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 184: ifc
    if (all(not(conditional_code))) {
        sub_185_191();
    } else {
        sub_191_200();
    }
    // 200: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_185_191() {
    // 185: mov
    reg_tmp6 = reg_tmp10;
    // 186: dp4
    reg_tmp3.x = dot_s(uniforms.f[11], reg_tmp6);
    // 187: dp4
    reg_tmp3.y = dot_s(uniforms.f[12], reg_tmp6);
    // 188: dp4
    reg_tmp3.z = dot_s(uniforms.f[13], reg_tmp6);
    // 189: mul
    reg_tmp0.xy = (mul_s(uniforms.f[19].xyyy, reg_tmp3.zzzz)).xy;
    // 190: add
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_191_200() {
    // 191: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_192_196();
    } else {
        sub_196_199();
    }
    // 199: nop
    return false;
}
bool sub_192_196() {
    // 192: call
    {
        sub_343_350();
    }
    // 193: dp3
    reg_tmp3.x = dot_3(uniforms.f[11].xyz, reg_tmp6.xyz);
    // 194: dp3
    reg_tmp3.y = dot_3(uniforms.f[12].xyz, reg_tmp6.xyz);
    // 195: dp3
    reg_tmp3.z = dot_3(uniforms.f[13].xyz, reg_tmp6.xyz);
    return false;
}
bool sub_196_199() {
    // 196: call
    {
        sub_350_354();
    }
    // 197: dp4
    reg_tmp3.x = dot_s(uniforms.f[11], reg_tmp6);
    // 198: dp4
    reg_tmp3.y = dot_s(uniforms.f[12], reg_tmp6);
    return false;
}
bool sub_202_226() {
    // 202: mov
    reg_tmp0.xy = (uniforms.f[10].yyyy).xy;
    // 203: ifu
    if (uniforms.b[10]) {
        sub_204_208();
    } else {
        sub_208_225();
    }
    // 225: nop
    return false;
}
bool sub_204_208() {
    // 204: call
    {
        sub_242_250();
    }
    // 205: dp4
    reg_tmp4.x = dot_s(uniforms.f[14].xywz, reg_tmp6);
    // 206: dp4
    reg_tmp4.y = dot_s(uniforms.f[15].xywz, reg_tmp6);
    // 207: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_208_225() {
    // 208: ifu
    if (uniforms.b[13]) {
        sub_209_223();
    } else {
        sub_223_224();
    }
    // 224: nop
    return false;
}
bool sub_209_223() {
    // 209: cmp
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    // 210: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 211: ifc
    if (all(not(conditional_code))) {
        sub_212_219();
    } else {
        sub_219_222();
    }
    // 222: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_212_219() {
    // 212: mov
    reg_tmp6 = reg_tmp10;
    // 213: dp4
    reg_tmp4.x = dot_s(uniforms.f[14], reg_tmp6);
    // 214: dp4
    reg_tmp4.y = dot_s(uniforms.f[15], reg_tmp6);
    // 215: dp4
    reg_tmp4.z = dot_s(uniforms.f[16], reg_tmp6);
    // 216: rcp
    reg_tmp6.w = rcp_s(reg_tmp4.z);
    // 217: mul
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    // 218: add
    reg_tmp4.xy = (uniforms.f[19].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_219_222() {
    // 219: call
    {
        sub_350_354();
    }
    // 220: dp4
    reg_tmp4.x = dot_s(uniforms.f[14], reg_tmp6);
    // 221: dp4
    reg_tmp4.y = dot_s(uniforms.f[15], reg_tmp6);
    return false;
}
bool sub_223_224() {
    // 223: mov
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_226_242() {
    // 226: mov
    reg_tmp0.xy = (uniforms.f[10].zzzz).xy;
    // 227: ifu
    if (uniforms.b[11]) {
        sub_228_232();
    } else {
        sub_232_241();
    }
    // 241: nop
    return false;
}
bool sub_228_232() {
    // 228: call
    {
        sub_242_250();
    }
    // 229: dp4
    reg_tmp5.x = dot_s(uniforms.f[17].xywz, reg_tmp6);
    // 230: dp4
    reg_tmp5.y = dot_s(uniforms.f[18].xywz, reg_tmp6);
    // 231: mov
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_232_241() {
    // 232: ifu
    if (uniforms.b[14]) {
        sub_233_239();
    } else {
        sub_239_240();
    }
    // 240: nop
    return false;
}
bool sub_233_239() {
    // 233: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 234: mov
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    // 235: call
    {
        sub_350_354();
    }
    // 236: dp4
    reg_tmp5.x = dot_s(uniforms.f[17], reg_tmp6);
    // 237: dp4
    reg_tmp5.y = dot_s(uniforms.f[18], reg_tmp6);
    // 238: mov
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_239_240() {
    // 239: mov
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
bool sub_242_250() {
    // 242: cmp
    conditional_code = equal(uniforms.f[93].yz, reg_tmp0.xy);
    // 243: ifc
    if (all(not(conditional_code))) {
        sub_244_245();
    } else {
        sub_245_249();
    }
    // 249: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_244_245() {
    // 244: mul
    reg_tmp6.xy = (mul_s(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
    return false;
}
bool sub_245_249() {
    // 245: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_246_247();
    } else {
        sub_247_248();
    }
    // 248: nop
    return false;
}
bool sub_246_247() {
    // 246: mul
    reg_tmp6.xy = (mul_s(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
    return false;
}
bool sub_247_248() {
    // 247: mul
    reg_tmp6.xy = (mul_s(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
    return false;
}
bool sub_343_350() {
    // 343: mov
    reg_tmp2 = -reg_tmp15;
    // 344: dp3
    reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
    // 345: rsq
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    // 346: mul
    reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
    // 347: dp3
    reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
    // 348: add
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    // 349: mad
    reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_350_354() {
    // 350: mov
    reg_tmp1.xy = (uniforms.f[94].zzzz).xy;
    // 351: mov
    reg_tmp1.zw = (uniforms.f[93].xxxx).zw;
    // 352: mad
    reg_tmp6 = fma_s(reg_tmp14, reg_tmp1, reg_tmp1);
    // 353: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_354_4096() {
    // 354: mov
    reg_tmp0 = vs_in_reg0;
    // 355: mov
    reg_tmp0.z = (uniforms.f[93].xxxx).z;
    // 356: mov
    reg_tmp0.w = (uniforms.f[93].yyyy).w;
    // 357: mov
    vs_out_attr0 = reg_tmp0;
    // 358: mov
    vs_out_attr2 = reg_tmp0;
    // 359: mov
    vs_out_attr1 = reg_tmp0;
    // 360: ifu
    if (uniforms.b[6]) {
        sub_361_363();
    } else {
        sub_363_364();
    }
    // 364: call
    {
        sub_175_202();
    }
    // 365: call
    {
        sub_202_226();
    }
    // 366: call
    {
        sub_226_242();
    }
    // 367: end
    return true;
}
bool sub_361_363() {
    // 361: call
    {
        sub_0_49();
    }
    // 362: nop
    return false;
}
bool sub_363_364() {
    // 363: mov
    vs_out_attr3 = uniforms.f[93].yyyy;
    return false;
}
// reference: A572BCB0EF548BD1, C928D489F43DD72A
// program: C928D489F43DD72A, AD7922A63ED54CA7, 584EE58D46F0B98C
// reference: E447428BEEA1E387, 619ABEE00AF51137
// reference: 37C4857215BFC649, 619ABEE00AF51137
// reference: 37C48572DA21D181, 619ABEE00AF51137
// reference: E447428B4447144A, 9289DBCB1EA8472D
// shader: 8B30, 84A82B5A25D98775

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb) * (texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.r) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) + (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 2A7EAF81D974A6D5, 84A82B5A25D98775
// program: 619ABEE00AF51137, AD7922A63ED54CA7, 84A82B5A25D98775
// reference: BF76358E98C2DFE6, 93C50366EC4126B4
// program: 93C50366EC4126B4, 5D764F9A6220D694, 70FA246ED3E2FAD4
// reference: 6CF5F277437B7EA1, 93C50366EC4126B4
// reference: 2E99070D93C88DBA, 70FA246ED3E2FAD4
// shader: 8B30, 92EC4965A7E72BC2

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 2F8F6701E28F10BC, 92EC4965A7E72BC2
// program: 93C50366EC4126B4, 5D764F9A6220D694, 92EC4965A7E72BC2
// shader: 8B30, 117DEA4BEBB32612

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 2F8F670112589B11, 117DEA4BEBB32612
// program: 93C50366EC4126B4, 5D764F9A6220D694, 117DEA4BEBB32612
// shader: 8B30, 7549E5EBA540C3DB

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 1F37784AB1F5E738, 7549E5EBA540C3DB
// program: 93C50366EC4126B4, 5D764F9A6220D694, 7549E5EBA540C3DB
// reference: C9A148E3F7D5D02D, 60942A308DA395BE
// shader: 8B30, 0D8E56F4BBBDAC3D

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 1ECD60529604B05E, 0D8E56F4BBBDAC3D
// program: 619ABEE00AF51137, AD7922A63ED54CA7, 0D8E56F4BBBDAC3D
// reference: BABA705AFE4CC844, 5366E62DF9CFDB1A
// reference: 2A23FE70E7196AFC, 13ECDA4EF04264FE
// shader: 8B30, 2332982C1E467B81

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor1.g) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (texcolor1.rrr) + (const_color[2].rgb) * (vec3(1.0) - (texcolor1.rrr)), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 7E9ED75C4871C382, 2332982C1E467B81
// program: 619ABEE00AF51137, AD7922A63ED54CA7, 2332982C1E467B81
// shader: 8B30, 713FE427C8E551A8

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 1080747790D7673D, 713FE427C8E551A8
// program: 619ABEE00AF51137, AD7922A63ED54CA7, 713FE427C8E551A8
// reference: B67DEEB4F1F99B53, 458EEA119FC06605
// shader: 8B30, C4696593B92A7B00

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp(min((texcolor0.rrr) + (texcolor0.ggg), vec3(1.0)) * (const_color[0].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor0.bbb) * (const_color[1].aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (vec3(1.0) - const_color[2].aaa) + (const_color[2].rgb) * (vec3(1.0) - (vec3(1.0) - const_color[2].aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((texcolor0.rgb) * (vec3(1.0) - const_color[4].aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (vec3(1.0) - const_color[4].aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 404553C09B17931E, C4696593B92A7B00
// program: 458EEA119FC06605, AD7922A63ED54CA7, C4696593B92A7B00
// shader: 8B30, 1385A2BC5FE5139F

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (const_color[1].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 4609680C4B8F999F, 1385A2BC5FE5139F
// program: 619ABEE00AF51137, AD7922A63ED54CA7, 1385A2BC5FE5139F
// shader: 8B30, C5861009B70D72DC

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a) + (texcolor1.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (const_color[1].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 176EE9B7C22C87F7, C5861009B70D72DC
// program: 619ABEE00AF51137, AD7922A63ED54CA7, C5861009B70D72DC
// shader: 8B30, 41C6BA6661374393

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (const_color[1].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 4609680CA738729C, 41C6BA6661374393
// program: 619ABEE00AF51137, AD7922A63ED54CA7, 41C6BA6661374393
// shader: 8B30, 060DB6F1FDBE0C55

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor1.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (texcolor1.aaa) + (texcolor0.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (const_color[2].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 7603EF8AF031590B, 060DB6F1FDBE0C55
// program: 619ABEE00AF51137, AD7922A63ED54CA7, 060DB6F1FDBE0C55
// shader: 8B30, 583B52E0B4D4893D

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.aaa) + (texcolor1.rgb) * (vec3(1.0) - (rounded_primary_color.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (const_color[1].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 849E5E57673D3307, 583B52E0B4D4893D
// program: 619ABEE00AF51137, AD7922A63ED54CA7, 583B52E0B4D4893D
// reference: D4F4BEF91F680A00, 47C12CB4EFB88BF9
// program: 619ABEE00AF51137, AD7922A63ED54CA7, 47C12CB4EFB88BF9
// shader: 8B31, A6CCBF05D590F4D7

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}


#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define mul_3(x, y) mix(x * y, vec3(0.0), isnan(x * y))
#define fma_s(x, y, z) (mul_s(x, y) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(mul_3(x, y), vec3(1.0))

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_8();
bool sub_9_32();
bool sub_33_96();
bool sub_146_166();
bool sub_167_259();
bool sub_190_192();
bool sub_194_195();
bool sub_197_198();
bool sub_200_202();
bool sub_232_234();
bool sub_236_237();
bool sub_239_240();
bool sub_242_244();
bool sub_260_4096();
bool sub_287_288();
bool sub_288_289();

bool exec_shader() {
    sub_260_4096();
    return true;
}

bool sub_0_8() {
    // 0: mova
    address_registers.x = (ivec2(vs_in_reg0.zz)).x;
    // 1: mov
    reg_tmp10 = uniforms.f[0].xxxz;
    // 2: mov
    reg_tmp10.xy = (vs_in_reg0.xyyy).xy;
    // 3: mov
    reg_tmp11 = uniforms.f[0].xxxx;
    // 4: mov
    reg_tmp12 = uniforms.f[0].xxxx;
    // 5: mov
    reg_tmp13 = uniforms.f[0].zzzz;
    // 6: mov
    reg_tmp4 = uniforms.f[0].xxxx;
    // 7: mov
    reg_tmp5 = uniforms.f[0].xxxx;
    return false;
}
bool sub_9_32() {
    // 9: mov
    vs_out_attr0 = reg_tmp10;
    // 10: mul
    reg_tmp13 = mul_s(uniforms.f[82], reg_tmp13);
    // 11: mov
    vs_out_attr1 = reg_tmp13;
    // 12: add
    reg_tmp11.y = (uniforms.f[0].zzzz + -reg_tmp11.yyyy).y;
    // 13: add
    reg_tmp12.y = (uniforms.f[0].zzzz + -reg_tmp12.yyyy).y;
    // 14: mov
    reg_tmp14.y = (uniforms.f[81].wwww).y;
    // 15: mul
    reg_tmp14.x = (mul_s(uniforms.f[0].wwww, reg_tmp14.yyyy)).x;
    // 16: rcp
    reg_tmp2.x = rcp_s(reg_tmp14.x);
    // 17: mov
    reg_tmp14.z = (reg_tmp2.xxxx).z;
    // 18: add
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp11.xyyy).xy;
    // 19: mul
    reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    // 20: flr
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    // 21: mul
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    // 22: add
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    // 23: add
    reg_tmp11.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    // 24: add
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp12.xyyy).xy;
    // 25: mul
    reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    // 26: flr
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    // 27: mul
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    // 28: add
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    // 29: add
    reg_tmp12.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    // 30: mov
    vs_out_attr2 = reg_tmp11;
    // 31: mov
    vs_out_attr3 = reg_tmp12;
    return false;
}
bool sub_33_96() {
    // 33: mov
    reg_tmp6.xyz = (-reg_tmp0.xyzz).xyz;
    // 34: mov
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    // 35: rcp
    reg_tmp7.xyz = vec3(rcp_s(uniforms.f[81].y));
    // 36: madi
    reg_tmp8.xyz = (fma_s(reg_tmp6.xyzz, reg_tmp7.xyzz, uniforms.f[0].yyyy)).xyz;
    // 37: flr
    reg_tmp7.xyz = (floor(reg_tmp8.xyzz)).xyz;
    // 38: mad
    reg_tmp6.xyz = (fma_s(reg_tmp7.xyzz, -uniforms.f[81].yyyy, reg_tmp6.xyzz)).xyz;
    // 39: min
    reg_tmp6 = min(uniforms.f[81].xxxx, reg_tmp6);
    // 40: max
    reg_tmp6 = max(-uniforms.f[81].xxxx, reg_tmp6);
    // 41: mov
    reg_tmp2 = uniforms.f[95];
    // 42: mov
    reg_tmp3 = uniforms.f[94];
    // 43: mul
    reg_tmp1.z = (mul_s(reg_tmp6.xxxx, reg_tmp6.xxxx)).z;
    // 44: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 45: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 46: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 47: mov
    reg_tmp2 = uniforms.f[93];
    // 48: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 49: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 50: mul
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp6.xxxx)).y;
    // 51: mov
    reg_tmp4.x = (reg_tmp1.xxxx).x;
    // 52: mov
    reg_tmp5.x = (reg_tmp1.yyyy).x;
    // 53: mov
    reg_tmp2 = uniforms.f[95];
    // 54: mov
    reg_tmp3 = uniforms.f[94];
    // 55: mul
    reg_tmp1.z = (mul_s(reg_tmp6.yyyy, reg_tmp6.yyyy)).z;
    // 56: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 57: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 58: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 59: mov
    reg_tmp2 = uniforms.f[93];
    // 60: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 61: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 62: mul
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp6.yyyy)).y;
    // 63: mov
    reg_tmp4.y = (reg_tmp1.xxxx).y;
    // 64: mov
    reg_tmp5.y = (reg_tmp1.yyyy).y;
    // 65: mov
    reg_tmp2 = uniforms.f[95];
    // 66: mov
    reg_tmp3 = uniforms.f[94];
    // 67: mul
    reg_tmp1.z = (mul_s(reg_tmp6.zzzz, reg_tmp6.zzzz)).z;
    // 68: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 69: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 70: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 71: mov
    reg_tmp2 = uniforms.f[93];
    // 72: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 73: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 74: mul
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp6.zzzz)).y;
    // 75: mov
    reg_tmp4.z = (reg_tmp1.xxxx).z;
    // 76: mov
    reg_tmp5.z = (reg_tmp1.yyyy).z;
    // 77: mul
    reg_tmp2.x = (mul_s(reg_tmp4.yyyy, reg_tmp5.zzzz)).x;
    // 78: mul
    reg_tmp2.y = (mul_s(reg_tmp5.yyyy, reg_tmp5.zzzz)).y;
    // 79: mul
    reg_tmp6.x = (mul_s(reg_tmp4.yyyy, reg_tmp4.zzzz)).x;
    // 80: mov
    reg_tmp6.y = (reg_tmp5.zzzz).y;
    // 81: mul
    reg_tmp6.z = (mul_s(-reg_tmp5.yyyy, reg_tmp4.zzzz)).z;
    // 82: mov
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    // 83: mul
    reg_tmp7.x = (mul_s(-reg_tmp2.xxxx, reg_tmp4.xxxx)).x;
    // 84: mad
    reg_tmp7.x = (fma_s(reg_tmp5.yyyy, reg_tmp5.xxxx, reg_tmp7.xxxx)).x;
    // 85: mul
    reg_tmp7.y = (mul_s(reg_tmp4.zzzz, reg_tmp4.xxxx)).y;
    // 86: mul
    reg_tmp7.z = (mul_s(reg_tmp2.yyyy, reg_tmp4.xxxx)).z;
    // 87: mad
    reg_tmp7.z = (fma_s(reg_tmp4.yyyy, reg_tmp5.xxxx, reg_tmp7.zzzz)).z;
    // 88: mov
    reg_tmp7.w = (uniforms.f[0].xxxx).w;
    // 89: mul
    reg_tmp8.x = (mul_s(reg_tmp2.xxxx, reg_tmp5.xxxx)).x;
    // 90: mad
    reg_tmp8.x = (fma_s(reg_tmp5.yyyy, reg_tmp4.xxxx, reg_tmp8.xxxx)).x;
    // 91: mul
    reg_tmp8.y = (mul_s(-reg_tmp4.zzzz, reg_tmp5.xxxx)).y;
    // 92: mul
    reg_tmp8.z = (mul_s(-reg_tmp2.yyyy, reg_tmp5.xxxx)).z;
    // 93: mad
    reg_tmp8.z = (fma_s(reg_tmp4.yyyy, reg_tmp4.xxxx, reg_tmp8.zzzz)).z;
    // 94: mov
    reg_tmp8.w = (uniforms.f[0].xxxx).w;
    // 95: mov
    reg_tmp9 = uniforms.f[0].xxxz;
    return false;
}
bool sub_146_166() {
    // 146: mov
    reg_tmp2 = uniforms.f[90];
    // 147: mov
    reg_tmp3 = uniforms.f[91];
    // 148: mov
    reg_tmp4 = uniforms.f[92];
    // 149: mov
    reg_tmp5 = uniforms.f[0].xxxz;
    // 150: mul
    reg_tmp6 = mul_s(uniforms.f[86].xxxx, reg_tmp2);
    // 151: mad
    reg_tmp6 = fma_s(reg_tmp3, uniforms.f[86].yyyy, reg_tmp6);
    // 152: mad
    reg_tmp6 = fma_s(reg_tmp4, uniforms.f[86].zzzz, reg_tmp6);
    // 153: mad
    reg_tmp6 = fma_s(reg_tmp5, uniforms.f[86].wwww, reg_tmp6);
    // 154: mul
    reg_tmp7 = mul_s(uniforms.f[87].xxxx, reg_tmp2);
    // 155: mad
    reg_tmp7 = fma_s(reg_tmp3, uniforms.f[87].yyyy, reg_tmp7);
    // 156: mad
    reg_tmp7 = fma_s(reg_tmp4, uniforms.f[87].zzzz, reg_tmp7);
    // 157: mad
    reg_tmp7 = fma_s(reg_tmp5, uniforms.f[87].wwww, reg_tmp7);
    // 158: mul
    reg_tmp8 = mul_s(uniforms.f[88].xxxx, reg_tmp2);
    // 159: mad
    reg_tmp8 = fma_s(reg_tmp3, uniforms.f[88].yyyy, reg_tmp8);
    // 160: mad
    reg_tmp8 = fma_s(reg_tmp4, uniforms.f[88].zzzz, reg_tmp8);
    // 161: mad
    reg_tmp8 = fma_s(reg_tmp5, uniforms.f[88].wwww, reg_tmp8);
    // 162: mul
    reg_tmp9 = mul_s(uniforms.f[89].xxxx, reg_tmp2);
    // 163: mad
    reg_tmp9 = fma_s(reg_tmp3, uniforms.f[89].yyyy, reg_tmp9);
    // 164: mad
    reg_tmp9 = fma_s(reg_tmp4, uniforms.f[89].zzzz, reg_tmp9);
    // 165: mad
    reg_tmp9 = fma_s(reg_tmp5, uniforms.f[89].wwww, reg_tmp9);
    return false;
}
bool sub_167_259() {
    // 167: rcp
    reg_tmp2.x = rcp_s(uniforms.f[81].y);
    // 168: mul
    reg_tmp2.xy = (mul_s(uniforms.f[2 + address_registers.x].zwww, reg_tmp2.xxxx)).xy;
    // 169: add
    reg_tmp2.xy = (uniforms.f[0].yyyy + reg_tmp2.xyyy).xy;
    // 170: flr
    reg_tmp3.xy = (floor(reg_tmp2.xyyy)).xy;
    // 171: mul
    reg_tmp2.xy = (mul_s(uniforms.f[81].yyyy, reg_tmp3.xyyy)).xy;
    // 172: add
    reg_tmp2.xy = (uniforms.f[2 + address_registers.x].zwww + -reg_tmp2.xyyy).xy;
    // 173: min
    reg_tmp0.xy = (min(uniforms.f[81].xxxx, -reg_tmp2.xyyy)).xy;
    // 174: max
    reg_tmp0.xy = (max(-uniforms.f[81].xxxx, reg_tmp0.xyyy)).xy;
    // 175: mov
    reg_tmp2 = uniforms.f[95];
    // 176: mov
    reg_tmp3 = uniforms.f[94];
    // 177: mul
    reg_tmp1.z = (mul_s(reg_tmp0.xxxx, reg_tmp0.xxxx)).z;
    // 178: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 179: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 180: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 181: mov
    reg_tmp2 = uniforms.f[93];
    // 182: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 183: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 184: mul
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.xxxx)).y;
    // 185: mov
    reg_tmp5.x = (uniforms.f[5 + address_registers.x].wwww).x;
    // 186: mov
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    // 187: mov
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    // 188: cmp
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    // 189: ifc
    if (conditional_code.x) {
        sub_190_192();
    }
    // 192: cmp
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    // 193: ifc
    if (conditional_code.x) {
        sub_194_195();
    }
    // 195: cmp
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 196: ifc
    if (conditional_code.x) {
        sub_197_198();
    }
    // 198: cmp
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 199: ifc
    if (conditional_code.x) {
        sub_200_202();
    }
    // 202: mul
    reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    // 203: mad
    reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    // 204: mad
    reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    // 205: add
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    // 206: add
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    // 207: mov
    reg_tmp4.z = (uniforms.f[83].xxxx).z;
    // 208: mov
    reg_tmp4.w = (-uniforms.f[83].yyyy).w;
    // 209: madi
    reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[3 + address_registers.x].xyyy)).xy;
    // 210: mov
    reg_tmp4.z = (-uniforms.f[3 + address_registers.x].zzzz).z;
    // 211: mov
    reg_tmp4.w = (-uniforms.f[3 + address_registers.x].wwww).w;
    // 212: add
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    // 213: add
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    // 214: mad
    reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    // 215: mad
    reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    // 216: mov
    reg_tmp11.xy = (reg_tmp5.xyyy).xy;
    // 217: mov
    reg_tmp2 = uniforms.f[95];
    // 218: mov
    reg_tmp3 = uniforms.f[94];
    // 219: mul
    reg_tmp1.z = (mul_s(reg_tmp0.yyyy, reg_tmp0.yyyy)).z;
    // 220: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 221: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 222: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 223: mov
    reg_tmp2 = uniforms.f[93];
    // 224: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 225: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 226: mul
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.yyyy)).y;
    // 227: mov
    reg_tmp5.x = (uniforms.f[6 + address_registers.x].wwww).x;
    // 228: mov
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    // 229: mov
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    // 230: cmp
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    // 231: ifc
    if (conditional_code.x) {
        sub_232_234();
    }
    // 234: cmp
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    // 235: ifc
    if (conditional_code.x) {
        sub_236_237();
    }
    // 237: cmp
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 238: ifc
    if (conditional_code.x) {
        sub_239_240();
    }
    // 240: cmp
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 241: ifc
    if (conditional_code.x) {
        sub_242_244();
    }
    // 244: mul
    reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    // 245: mad
    reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    // 246: mad
    reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    // 247: add
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    // 248: add
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    // 249: mov
    reg_tmp4.z = (uniforms.f[83].zzzz).z;
    // 250: mov
    reg_tmp4.w = (-uniforms.f[83].wwww).w;
    // 251: madi
    reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[4 + address_registers.x].xyyy)).xy;
    // 252: mov
    reg_tmp4.z = (-uniforms.f[4 + address_registers.x].zzzz).z;
    // 253: mov
    reg_tmp4.w = (-uniforms.f[4 + address_registers.x].wwww).w;
    // 254: add
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    // 255: add
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    // 256: mad
    reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    // 257: mad
    reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    // 258: mov
    reg_tmp12.xy = (reg_tmp5.xyyy).xy;
    return false;
}
bool sub_190_192() {
    // 190: mov
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    // 191: mov
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_194_195() {
    // 194: mov
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_197_198() {
    // 197: mov
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_200_202() {
    // 200: mov
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    // 201: mov
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_232_234() {
    // 232: mov
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    // 233: mov
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_236_237() {
    // 236: mov
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_239_240() {
    // 239: mov
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_242_244() {
    // 242: mov
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    // 243: mov
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_260_4096() {
    // 260: call
    {
        sub_0_8();
    }
    // 261: add
    reg_tmp10.xy = (uniforms.f[84].xyyy + reg_tmp10.xyyy).xy;
    // 262: mul
    reg_tmp10.xy = (mul_s(uniforms.f[2 + address_registers.x].xyyy, reg_tmp10.xyyy)).xy;
    // 263: mov
    reg_tmp14 = reg_tmp10;
    // 264: mov
    reg_tmp0 = uniforms.f[7 + address_registers.x];
    // 265: call
    {
        sub_33_96();
    }
    // 266: dp4
    reg_tmp10.x = dot_s(reg_tmp14, reg_tmp6);
    // 267: dp4
    reg_tmp10.y = dot_s(reg_tmp14, reg_tmp7);
    // 268: dp4
    reg_tmp10.z = dot_s(reg_tmp14, reg_tmp8);
    // 269: dp4
    reg_tmp10.w = dot_s(reg_tmp14, reg_tmp9);
    // 270: mov
    reg_tmp6 = uniforms.f[8 + address_registers.x];
    // 271: mov
    reg_tmp7 = uniforms.f[9 + address_registers.x];
    // 272: mov
    reg_tmp8 = uniforms.f[10 + address_registers.x];
    // 273: mov
    reg_tmp9 = uniforms.f[0].xxxz;
    // 274: mov
    reg_tmp6.w = (uniforms.f[5 + address_registers.x].xxxx).w;
    // 275: mov
    reg_tmp7.w = (uniforms.f[5 + address_registers.x].yyyy).w;
    // 276: mov
    reg_tmp8.w = (uniforms.f[5 + address_registers.x].zzzz).w;
    // 277: dp4
    reg_tmp2.x = dot_s(reg_tmp10, reg_tmp6);
    // 278: dp4
    reg_tmp2.y = dot_s(reg_tmp10, reg_tmp7);
    // 279: dp4
    reg_tmp2.z = dot_s(reg_tmp10, reg_tmp8);
    // 280: dp4
    reg_tmp2.w = dot_s(reg_tmp10, reg_tmp9);
    // 281: mov
    reg_tmp10 = reg_tmp2;
    // 282: mov
    reg_tmp3.xyz = (uniforms.f[5 + address_registers.x].xyzz).xyz;
    // 283: add
    reg_tmp3.xyz = (uniforms.f[85].xyzz + -reg_tmp3.xyzz).xyz;
    // 284: dp3
    reg_tmp4.x = dot_3(reg_tmp3.xyz, reg_tmp3.xyz);
    // 285: cmp
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
    // 286: ifc
    if (conditional_code.x) {
        sub_287_288();
    } else {
        sub_288_289();
    }
    // 289: mul
    reg_tmp3.xyz = (mul_s(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
    // 290: mad
    reg_tmp10.xyz = (fma_s(reg_tmp3.xyzz, uniforms.f[84].zzzz, reg_tmp10.xyzz)).xyz;
    // 291: call
    {
        sub_146_166();
    }
    // 292: mov
    reg_tmp2 = reg_tmp10;
    // 293: dp4
    reg_tmp10.x = dot_s(reg_tmp2, reg_tmp6);
    // 294: dp4
    reg_tmp10.y = dot_s(reg_tmp2, reg_tmp7);
    // 295: dp4
    reg_tmp10.z = dot_s(reg_tmp2, reg_tmp8);
    // 296: dp4
    reg_tmp10.w = dot_s(reg_tmp2, reg_tmp9);
    // 297: mov
    reg_tmp2 = uniforms.f[1 + address_registers.x];
    // 298: max
    reg_tmp3 = max(uniforms.f[0].xxxx, reg_tmp2);
    // 299: min
    reg_tmp2 = min(uniforms.f[0].zzzz, reg_tmp3);
    // 300: mov
    reg_tmp13 = reg_tmp2;
    // 301: call
    {
        sub_167_259();
    }
    // 302: call
    {
        sub_9_32();
    }
    // 303: end
    return true;
}
bool sub_287_288() {
    // 287: mov
    reg_tmp4.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_288_289() {
    // 288: rsq
    reg_tmp4.x = rsq_s(reg_tmp4.x);
    return false;
}
// reference: E545D24990C72490, A6CCBF05D590F4D7
// shader: 8DD9, CEF02063E9A18B2F

layout(triangles) in;
layout(triangle_strip, max_vertices = 3) out;

out vec4 primary_color;
out vec2 texcoord0;
out vec2 texcoord1;
out vec2 texcoord2;
out float texcoord0_w;
out vec4 normquat;
out vec3 view;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

 in vec4 vs_out_attr0[];
 in vec4 vs_out_attr1[];
 in vec4 vs_out_attr2[];
 in vec4 vs_out_attr3[];

struct Vertex {
    vec4 attributes[4];
};

vec4 GetVertexQuaternion(Vertex vtx) {
    return vec4(0.0, 0.0, 0.0, 0.0);
}

void EmitVtx(Vertex vtx, bool quats_opposite) {
    vec4 vtx_pos = vec4(vtx.attributes[0].x, vtx.attributes[0].y, vtx.attributes[0].z, vtx.attributes[0].w);
    gl_Position = vtx_pos;
#if !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)
    gl_ClipDistance[0] = -vtx_pos.z;
    gl_ClipDistance[1] = dot(clip_coef, vtx_pos);
#endif // !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)

    vec4 vtx_quat = GetVertexQuaternion(vtx);
    normquat = mix(vtx_quat, -vtx_quat, bvec4(quats_opposite));

    vec4 vtx_color = vec4(vtx.attributes[1].x, vtx.attributes[1].y, vtx.attributes[1].z, vtx.attributes[1].w);
    primary_color = min(abs(vtx_color), vec4(1.0));

    texcoord0 = vec2(vtx.attributes[2].x, vtx.attributes[2].y);
    texcoord1 = vec2(vtx.attributes[3].x, vtx.attributes[3].y);

    texcoord0_w = 0.0;
    view = vec3(0.0, 0.0, 0.0);

    texcoord2 = vec2(0.0, 0.0);

    EmitVertex();
}

bool AreQuaternionsOpposite(vec4 qa, vec4 qb) {
    return (dot(qa, qb) < 0.0);
}

void EmitPrim(Vertex vtx0, Vertex vtx1, Vertex vtx2) {
    EmitVtx(vtx0, false);
    EmitVtx(vtx1, AreQuaternionsOpposite(GetVertexQuaternion(vtx0), GetVertexQuaternion(vtx1)));
    EmitVtx(vtx2, AreQuaternionsOpposite(GetVertexQuaternion(vtx0), GetVertexQuaternion(vtx2)));
    EndPrimitive();
}

void main() {
    Vertex prim_buffer[3];
    prim_buffer[0].attributes = vec4[4](vs_out_attr0[0], vs_out_attr1[0], vs_out_attr2[0], vs_out_attr3[0]);
    prim_buffer[1].attributes = vec4[4](vs_out_attr0[1], vs_out_attr1[1], vs_out_attr2[1], vs_out_attr3[1]);
    prim_buffer[2].attributes = vec4[4](vs_out_attr0[2], vs_out_attr1[2], vs_out_attr2[2], vs_out_attr3[2]);
    EmitPrim(prim_buffer[0], prim_buffer[1], prim_buffer[2]);
}
// reference: A55C6948CCF76B42, CEF02063E9A18B2F
// shader: 8B30, 52F15AB03C873666

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_2 = byteround(clamp((vec3(1.0) - combiner_buffer.rgb) * (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 703709193E737D07, 52F15AB03C873666
// program: A6CCBF05D590F4D7, CEF02063E9A18B2F, 52F15AB03C873666
// reference: 519CD67DEB3FC063, 93C50366EC4126B4
// shader: 8B30, 4AFCA8E6553DCB17

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((vec3(1.0) - combiner_buffer.rgb) * (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 5F0AA39F3D41FA2C, 4AFCA8E6553DCB17
// program: 93C50366EC4126B4, 5D764F9A6220D694, 4AFCA8E6553DCB17
// reference: 821F118430866124, 93C50366EC4126B4
// reference: 5F0AA39F650CF7BC, 4AFCA8E6553DCB17
// reference: 73EE4218DE55A336, 619ABEE00AF51137
// reference: A06D85E1254B86F8, 619ABEE00AF51137
// reference: A06D85E1EAD59130, 619ABEE00AF51137
// reference: 73EE421874B354FB, 9289DBCB1EA8472D
// reference: 519CD67D77BBDA63, 93C50366EC4126B4
// reference: 821F1184433BE865, 93C50366EC4126B4
// reference: 58970D47C10DDBE2, 458EEA119FC06605
// shader: 8B31, 7A6559ADA21E6F2E

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;
 out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}


#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define mul_3(x, y) mix(x * y, vec3(0.0), isnan(x * y))
#define fma_s(x, y, z) (mul_s(x, y) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(mul_3(x, y), vec3(1.0))

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_6();
bool sub_6_53();
bool sub_21_25();
bool sub_51_52();
bool sub_53_4096();

bool exec_shader() {
    sub_53_4096();
    return true;
}

bool sub_0_6() {
    // 0: mova
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    // 1: nop
    // 2: dp4
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    // 3: dp4
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    // 4: dp4
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    // 5: mad
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    return false;
}
bool sub_6_53() {
    // 6: mov
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    // 7: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 8: mov
    reg_tmp7 = uniforms.f[93].xxxx;
    // 9: mul
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    // 10: cmp
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    // 11: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 12: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    // 13: call
    {
        sub_0_6();
    }
    // 14: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 15: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    // 16: call
    {
        sub_0_6();
    }
    // 17: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 18: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    // 19: callc
    if (conditional_code.x) {
        sub_0_6();
    }
    // 20: ifu
    if (uniforms.b[11]) {
        sub_21_25();
    }
    // 25: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 26: mov
    reg_tmp10 = reg_tmp7;
    // 27: add
    reg_tmp6.y = (-uniforms.f[83].wwww + reg_tmp10.yyyy).y;
    // 28: mov
    reg_tmp9.xyz = (uniforms.f[83].xyzz).xyz;
    // 29: dp4
    reg_tmp7.x = dot_s(reg_tmp9.xyzz, reg_tmp9.xyzz);
    // 30: rsq
    reg_tmp7.x = rsq_s(reg_tmp7.x);
    // 31: mul
    reg_tmp7.xyz = (mul_s(reg_tmp9.xyzz, reg_tmp7.xxxx)).xyz;
    // 32: rcp
    reg_tmp8.y = rcp_s(-reg_tmp7.y);
    // 33: mul
    reg_tmp8.y = (mul_s(reg_tmp6.yyyy, reg_tmp8.yyyy)).y;
    // 34: mul
    reg_tmp7.xyz = (mul_s(reg_tmp7.xyzz, reg_tmp8.yyyy)).xyz;
    // 35: add
    reg_tmp10.xyz = (reg_tmp10.xyzz + reg_tmp7.xyzz).xyz;
    // 36: add
    reg_tmp10.y = (uniforms.f[94].xxxx + reg_tmp10.yyyy).y;
    // 37: dp4
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    // 38: dp4
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    // 39: dp4
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    // 40: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 41: mov
    vs_out_attr1 = uniforms.f[93].xxxx;
    // 42: mov
    vs_out_attr2 = reg_tmp15;
    // 43: dp4
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    // 44: dp4
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    // 45: dp4
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    // 46: dp4
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    // 47: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 48: mul
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    // 49: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 50: ifc
    if (all(conditional_code)) {
        sub_51_52();
    }
    // 52: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_21_25() {
    // 21: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 22: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    // 23: callc
    if (conditional_code.y) {
        sub_0_6();
    }
    // 24: nop
    return false;
}
bool sub_51_52() {
    // 51: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_53_4096() {
    // 53: call
    {
        sub_6_53();
    }
    // 54: mov
    vs_out_attr4 = uniforms.f[93].xxxx;
    // 55: mov
    vs_out_attr5 = uniforms.f[93].xxxx;
    // 56: mov
    vs_out_attr6 = uniforms.f[93].xxxx;
    // 57: mov
    vs_out_attr3 = uniforms.f[93].yyyy;
    // 58: end
    return true;
}
// reference: 9FD258F1A6A474B3, 7A6559ADA21E6F2E
// shader: 8B30, B223506173AA3746

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((const_color[5].r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 7E0CA6739081C321, B223506173AA3746
// program: 7A6559ADA21E6F2E, AD7922A63ED54CA7, B223506173AA3746
// shader: 8B31, 07A736992979F928

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;
 out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}


#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define mul_3(x, y) mix(x * y, vec3(0.0), isnan(x * y))
#define fma_s(x, y, z) (mul_s(x, y) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(mul_3(x, y), vec3(1.0))

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_19_29();
bool sub_143_151();
bool sub_145_146();
bool sub_146_150();
bool sub_147_148();
bool sub_148_149();
bool sub_166_4096();
bool sub_170_192();
bool sub_192_200();
bool sub_212_213();

bool exec_shader() {
    sub_166_4096();
    return true;
}

bool sub_19_29() {
    // 19: mova
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    // 20: nop
    // 21: dp4
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    // 22: dp4
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    // 23: dp4
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    // 24: dp3
    reg_tmp4.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    // 25: dp3
    reg_tmp4.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    // 26: dp3
    reg_tmp4.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    // 27: mad
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 28: mad
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_143_151() {
    // 143: cmp
    conditional_code = equal(uniforms.f[93].yz, reg_tmp0.xy);
    // 144: ifc
    if (all(not(conditional_code))) {
        sub_145_146();
    } else {
        sub_146_150();
    }
    // 150: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_145_146() {
    // 145: mov
    reg_tmp6.xy = (vs_in_reg4.xyyy).xy;
    return false;
}
bool sub_146_150() {
    // 146: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_147_148();
    } else {
        sub_148_149();
    }
    // 149: nop
    return false;
}
bool sub_147_148() {
    // 147: mov
    reg_tmp6.xy = (vs_in_reg5.xyyy).xy;
    return false;
}
bool sub_148_149() {
    // 148: mov
    reg_tmp6.xy = (vs_in_reg6.xyyy).xy;
    return false;
}
bool sub_166_4096() {
    // 166: mov
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    // 167: mov
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    // 168: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 169: ifu
    if (uniforms.b[0]) {
        sub_170_192();
    } else {
        sub_192_200();
    }
    // 200: dp4
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    // 201: dp4
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    // 202: dp4
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    // 203: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 204: dp4
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    // 205: dp4
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    // 206: dp4
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    // 207: dp4
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    // 208: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 209: mul
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    // 210: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 211: ifc
    if (all(conditional_code)) {
        sub_212_213();
    }
    // 213: mov
    vs_out_attr0 = reg_tmp0;
    // 214: mov
    vs_out_attr1 = uniforms.f[93].xxxx;
    // 215: mov
    vs_out_attr2 = uniforms.f[93].xxxx;
    // 216: mul
    reg_tmp0 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
    // 217: add
    vs_out_attr3 = uniforms.f[94].zzzz + reg_tmp0;
    // 218: dp3
    reg_tmp5.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    // 219: dp3
    reg_tmp5.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    // 220: dp3
    reg_tmp5.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    // 221: dp4
    reg_tmp4.x = dot_s(reg_tmp5.xyzz, reg_tmp5.xyzz);
    // 222: rsq
    reg_tmp4.x = rsq_s(reg_tmp4.x);
    // 223: mul
    reg_tmp4.xyz = (mul_s(reg_tmp5.xyzz, reg_tmp4.xxxx)).xyz;
    // 224: mul
    reg_tmp4 = mul_s(uniforms.f[94].xxxx, reg_tmp4);
    // 225: add
    reg_tmp12 = uniforms.f[94].xxxx + reg_tmp4;
    // 226: mov
    vs_out_attr4 = reg_tmp12;
    // 227: mov
    reg_tmp0.xy = (uniforms.f[0].xxxx).xy;
    // 228: call
    {
        sub_143_151();
    }
    // 229: dp4
    reg_tmp4.x = dot_s(uniforms.f[4].xywz, reg_tmp6);
    // 230: dp4
    reg_tmp4.y = dot_s(uniforms.f[5].xywz, reg_tmp6);
    // 231: mov
    vs_out_attr5 = reg_tmp4;
    // 232: mov
    vs_out_attr6 = reg_tmp4;
    // 233: end
    return true;
}
bool sub_170_192() {
    // 170: mov
    reg_tmp7 = uniforms.f[93].xxxx;
    // 171: mov
    reg_tmp12 = uniforms.f[93].xxxx;
    // 172: mul
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    // 173: cmp
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    // 174: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 175: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    // 176: call
    {
        sub_19_29();
    }
    // 177: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 178: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    // 179: call
    {
        sub_19_29();
    }
    // 180: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 181: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    // 182: callc
    if (conditional_code.x) {
        sub_19_29();
    }
    // 183: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 184: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    // 185: callc
    if (conditional_code.y) {
        sub_19_29();
    }
    // 186: nop
    // 187: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 188: mov
    reg_tmp10 = reg_tmp7;
    // 189: dp3
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    // 190: dp3
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    // 191: dp3
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    return false;
}
bool sub_192_200() {
    // 192: mov
    reg_tmp7 = reg_tmp15;
    // 193: dp4
    reg_tmp10.x = dot_s(uniforms.f[10], reg_tmp7);
    // 194: dp4
    reg_tmp10.y = dot_s(uniforms.f[11], reg_tmp7);
    // 195: dp4
    reg_tmp10.z = dot_s(uniforms.f[12], reg_tmp7);
    // 196: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 197: dp4
    reg_tmp12.x = dot_s(uniforms.f[10], reg_tmp14);
    // 198: dp4
    reg_tmp12.y = dot_s(uniforms.f[11], reg_tmp14);
    // 199: dp4
    reg_tmp12.z = dot_s(uniforms.f[12], reg_tmp14);
    return false;
}
bool sub_212_213() {
    // 212: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
// reference: DD744293F96B1B23, 07A736992979F928
// program: 07A736992979F928, AD7922A63ED54CA7, 26D8D217AE804C43
// shader: 8B31, AC576E32BE8CFA08

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;
 out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}


#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define mul_3(x, y) mix(x * y, vec3(0.0), isnan(x * y))
#define fma_s(x, y, z) (mul_s(x, y) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(mul_3(x, y), vec3(1.0))

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_19();
bool sub_19_29();
bool sub_29_51();
bool sub_51_65();
bool sub_65_116();
bool sub_88_92();
bool sub_114_115();
bool sub_116_156();
bool sub_133_137();
bool sub_154_155();
bool sub_156_183();
bool sub_158_163();
bool sub_163_182();
bool sub_166_172();
bool sub_172_181();
bool sub_173_177();
bool sub_177_180();
bool sub_183_207();
bool sub_185_189();
bool sub_189_206();
bool sub_190_204();
bool sub_193_200();
bool sub_200_203();
bool sub_204_205();
bool sub_207_223();
bool sub_209_213();
bool sub_213_222();
bool sub_214_220();
bool sub_220_221();
bool sub_223_231();
bool sub_225_226();
bool sub_226_230();
bool sub_227_228();
bool sub_228_229();
bool sub_231_238();
bool sub_238_244();
bool sub_244_288();
bool sub_264_270();
bool sub_271_278();
bool sub_279_287();
bool sub_288_4096();
bool sub_289_291();
bool sub_291_293();
bool sub_294_296();
bool sub_296_298();

bool exec_shader() {
    sub_288_4096();
    return true;
}

bool sub_0_19() {
    uint jmp_to = 0u;
    while (true) {
        switch (jmp_to) {
        case 0u: {
            // 0: dp3
            reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
            // 1: dp3
            reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
            // 2: dp3
            reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
            // 3: dp3
            reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
            // 4: dp3
            reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
            // 5: rsq
            reg_tmp6.x = rsq_s(reg_tmp6.x);
            // 6: rsq
            reg_tmp7.x = rsq_s(reg_tmp7.x);
            // 7: mul
            reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 8: mul
            reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 9: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 10: add
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            // 11: mul
            reg_tmp4 = mul_s(uniforms.f[94].xxxx, reg_tmp4);
            // 12: cmp
            conditional_code = greaterThanEqual(uniforms.f[93].xx, reg_tmp4.xx);
            // 13: rsq
            reg_tmp4 = vec4(rsq_s(reg_tmp4.x));
            // 14: mul
            reg_tmp5 = mul_s(uniforms.f[94].xxxx, reg_tmp14);
            // 15: jmpc
            if (conditional_code.x) {
                { jmp_to = 18u; break; }
            }
            // 16: rcp
            reg_tmp0.z = rcp_s(reg_tmp4.x);
            // 17: mul
            reg_tmp0.xy = (mul_s(reg_tmp5, reg_tmp4)).xy;
        }
        case 18u: {
            // 18: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_19_29() {
    // 19: mova
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    // 20: nop
    // 21: dp4
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    // 22: dp4
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    // 23: dp4
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    // 24: dp3
    reg_tmp4.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    // 25: dp3
    reg_tmp4.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    // 26: dp3
    reg_tmp4.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    // 27: mad
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 28: mad
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_29_51() {
    // 29: mova
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    // 30: nop
    // 31: dp4
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    // 32: dp4
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    // 33: dp4
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    // 34: mad
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 35: dp3
    reg_tmp3.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    // 36: dp3
    reg_tmp3.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    // 37: dp3
    reg_tmp3.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    // 38: mad
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp12);
    // 39: dp3
    reg_tmp3.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp13.xyz);
    // 40: dp3
    reg_tmp3.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp13.xyz);
    // 41: dp3
    reg_tmp3.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp13.xyz);
    // 42: mad
    reg_tmp11 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp11);
    // 43: dp3
    reg_tmp3.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp5.xyz);
    // 44: dp3
    reg_tmp3.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp5.xyz);
    // 45: dp3
    reg_tmp3.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp5.xyz);
    // 46: mad
    reg_tmp9 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp9);
    // 47: dp3
    reg_tmp3.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp6.xyz);
    // 48: dp3
    reg_tmp3.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp6.xyz);
    // 49: dp3
    reg_tmp3.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp6.xyz);
    // 50: mad
    reg_tmp8 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp8);
    return false;
}
bool sub_51_65() {
    // 51: mul
    reg_tmp0.xyz = (mul_s(reg_tmp9.yzxx, reg_tmp8.zxyy)).xyz;
    // 52: mad
    reg_tmp0.xyz = (fma_s(-reg_tmp8.yzxx, reg_tmp9.zxyy, reg_tmp0)).xyz;
    // 53: mov
    reg_tmp1 = uniforms.f[83];
    // 54: dp4
    reg_tmp2.x = dot_s(reg_tmp1.xyzz, reg_tmp1.xyzz);
    // 55: rsq
    reg_tmp2.x = rsq_s(reg_tmp2.x);
    // 56: mul
    reg_tmp2.xyz = (mul_s(reg_tmp1.xyzz, reg_tmp2.xxxx)).xyz;
    // 57: dp3
    reg_tmp1.x = dot_3(reg_tmp2.xyz, reg_tmp8.xyz);
    // 58: dp3
    reg_tmp1.y = dot_3(reg_tmp2.xyz, reg_tmp0.xyz);
    // 59: dp3
    reg_tmp1.z = dot_3(reg_tmp2.xyz, reg_tmp9.xyz);
    // 60: dp4
    reg_tmp2.x = dot_s(reg_tmp1.xyzz, reg_tmp1.xyzz);
    // 61: rsq
    reg_tmp2.x = rsq_s(reg_tmp2.x);
    // 62: mul
    reg_tmp2.xyz = (mul_s(reg_tmp1.xyzz, reg_tmp2.xxxx)).xyz;
    // 63: mov
    reg_tmp2.w = (uniforms.f[93].yyyy).w;
    // 64: mov
    vs_out_attr2 = reg_tmp2;
    return false;
}
bool sub_65_116() {
    // 65: mov
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    // 66: mov
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    // 67: mov
    reg_tmp13.xyz = (vs_in_reg2).xyz;
    // 68: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 69: mov
    reg_tmp5 = uniforms.f[93].xxyy;
    // 70: mov
    reg_tmp6 = uniforms.f[93].yxxy;
    // 71: mov
    reg_tmp7 = uniforms.f[93].xxxx;
    // 72: mov
    reg_tmp12 = uniforms.f[93].xxxx;
    // 73: mov
    reg_tmp11 = uniforms.f[93].xxxx;
    // 74: mov
    reg_tmp9 = uniforms.f[93].xxxx;
    // 75: mov
    reg_tmp8 = uniforms.f[93].xxxx;
    // 76: mul
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    // 77: cmp
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    // 78: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 79: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    // 80: call
    {
        sub_29_51();
    }
    // 81: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 82: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    // 83: call
    {
        sub_29_51();
    }
    // 84: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 85: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    // 86: callc
    if (conditional_code.x) {
        sub_29_51();
    }
    // 87: ifu
    if (uniforms.b[11]) {
        sub_88_92();
    }
    // 92: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 93: mov
    reg_tmp10 = reg_tmp7;
    // 94: dp3
    reg_tmp13.x = dot_3(uniforms.f[90].xyz, reg_tmp11.xyz);
    // 95: dp3
    reg_tmp13.y = dot_3(uniforms.f[91].xyz, reg_tmp11.xyz);
    // 96: dp3
    reg_tmp13.z = dot_3(uniforms.f[92].xyz, reg_tmp11.xyz);
    // 97: dp3
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    // 98: dp3
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    // 99: dp3
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    // 100: dp4
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    // 101: dp4
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    // 102: dp4
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    // 103: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 104: call
    {
        sub_51_65();
    }
    // 105: mov
    vs_out_attr1 = uniforms.f[93].xxxy;
    // 106: dp4
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    // 107: dp4
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    // 108: dp4
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    // 109: dp4
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    // 110: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 111: mul
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    // 112: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 113: ifc
    if (all(conditional_code)) {
        sub_114_115();
    }
    // 115: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_88_92() {
    // 88: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 89: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    // 90: callc
    if (conditional_code.y) {
        sub_29_51();
    }
    // 91: nop
    return false;
}
bool sub_114_115() {
    // 114: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_116_156() {
    // 116: mov
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    // 117: mov
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    // 118: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 119: mov
    reg_tmp7 = uniforms.f[93].xxxx;
    // 120: mov
    reg_tmp12 = uniforms.f[93].xxxx;
    // 121: mul
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    // 122: cmp
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    // 123: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 124: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    // 125: call
    {
        sub_19_29();
    }
    // 126: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 127: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    // 128: call
    {
        sub_19_29();
    }
    // 129: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 130: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    // 131: callc
    if (conditional_code.x) {
        sub_19_29();
    }
    // 132: ifu
    if (uniforms.b[11]) {
        sub_133_137();
    }
    // 137: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 138: mov
    reg_tmp10 = reg_tmp7;
    // 139: dp4
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    // 140: dp4
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    // 141: dp4
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    // 142: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 143: call
    {
        sub_0_19();
    }
    // 144: nop
    // 145: mov
    vs_out_attr2 = -reg_tmp15;
    // 146: dp4
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    // 147: dp4
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    // 148: dp4
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    // 149: dp4
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    // 150: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 151: mul
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    // 152: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 153: ifc
    if (all(conditional_code)) {
        sub_154_155();
    }
    // 155: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_133_137() {
    // 133: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 134: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    // 135: callc
    if (conditional_code.y) {
        sub_19_29();
    }
    // 136: nop
    return false;
}
bool sub_154_155() {
    // 154: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_156_183() {
    // 156: mov
    reg_tmp0.xy = (uniforms.f[0].xxxx).xy;
    // 157: ifu
    if (uniforms.b[2]) {
        sub_158_163();
    } else {
        sub_163_182();
    }
    // 182: nop
    return false;
}
bool sub_158_163() {
    // 158: call
    {
        sub_223_231();
    }
    // 159: dp4
    reg_tmp3.x = dot_s(uniforms.f[1].xywz, reg_tmp6);
    // 160: dp4
    reg_tmp3.y = dot_s(uniforms.f[2].xywz, reg_tmp6);
    // 161: mov
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    // 162: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_163_182() {
    // 163: cmp
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    // 164: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 165: ifc
    if (all(not(conditional_code))) {
        sub_166_172();
    } else {
        sub_172_181();
    }
    // 181: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_166_172() {
    // 166: mov
    reg_tmp6 = reg_tmp10;
    // 167: dp4
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    // 168: dp4
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    // 169: dp4
    reg_tmp3.z = dot_s(uniforms.f[3], reg_tmp6);
    // 170: mul
    reg_tmp0.xy = (mul_s(uniforms.f[9].xyyy, reg_tmp3.zzzz)).xy;
    // 171: add
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_172_181() {
    // 172: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_173_177();
    } else {
        sub_177_180();
    }
    // 180: nop
    return false;
}
bool sub_173_177() {
    // 173: call
    {
        sub_231_238();
    }
    // 174: dp3
    reg_tmp3.x = dot_3(uniforms.f[1].xyz, reg_tmp6.xyz);
    // 175: dp3
    reg_tmp3.y = dot_3(uniforms.f[2].xyz, reg_tmp6.xyz);
    // 176: dp3
    reg_tmp3.z = dot_3(uniforms.f[3].xyz, reg_tmp6.xyz);
    return false;
}
bool sub_177_180() {
    // 177: call
    {
        sub_238_244();
    }
    // 178: dp4
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    // 179: dp4
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    return false;
}
bool sub_183_207() {
    // 183: mov
    reg_tmp0.xy = (uniforms.f[0].yyyy).xy;
    // 184: ifu
    if (uniforms.b[3]) {
        sub_185_189();
    } else {
        sub_189_206();
    }
    // 206: nop
    return false;
}
bool sub_185_189() {
    // 185: call
    {
        sub_223_231();
    }
    // 186: dp4
    reg_tmp4.x = dot_s(uniforms.f[4].xywz, reg_tmp6);
    // 187: dp4
    reg_tmp4.y = dot_s(uniforms.f[5].xywz, reg_tmp6);
    // 188: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_189_206() {
    // 189: ifu
    if (uniforms.b[5]) {
        sub_190_204();
    } else {
        sub_204_205();
    }
    // 205: nop
    return false;
}
bool sub_190_204() {
    // 190: cmp
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    // 191: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 192: ifc
    if (all(not(conditional_code))) {
        sub_193_200();
    } else {
        sub_200_203();
    }
    // 203: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_193_200() {
    // 193: mov
    reg_tmp6 = reg_tmp10;
    // 194: dp4
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    // 195: dp4
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    // 196: dp4
    reg_tmp4.z = dot_s(uniforms.f[6], reg_tmp6);
    // 197: rcp
    reg_tmp6.w = rcp_s(reg_tmp4.z);
    // 198: mul
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    // 199: add
    reg_tmp4.xy = (uniforms.f[9].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_200_203() {
    // 200: call
    {
        sub_238_244();
    }
    // 201: dp4
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    // 202: dp4
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    return false;
}
bool sub_204_205() {
    // 204: mov
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_207_223() {
    // 207: mov
    reg_tmp0.xy = (uniforms.f[0].zzzz).xy;
    // 208: ifu
    if (uniforms.b[4]) {
        sub_209_213();
    } else {
        sub_213_222();
    }
    // 222: nop
    return false;
}
bool sub_209_213() {
    // 209: call
    {
        sub_223_231();
    }
    // 210: dp4
    reg_tmp5.x = dot_s(uniforms.f[7].xywz, reg_tmp6);
    // 211: dp4
    reg_tmp5.y = dot_s(uniforms.f[8].xywz, reg_tmp6);
    // 212: mov
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_213_222() {
    // 213: ifu
    if (uniforms.b[6]) {
        sub_214_220();
    } else {
        sub_220_221();
    }
    // 221: nop
    return false;
}
bool sub_214_220() {
    // 214: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 215: mov
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    // 216: call
    {
        sub_238_244();
    }
    // 217: dp4
    reg_tmp5.x = dot_s(uniforms.f[7], reg_tmp6);
    // 218: dp4
    reg_tmp5.y = dot_s(uniforms.f[8], reg_tmp6);
    // 219: mov
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_220_221() {
    // 220: mov
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
bool sub_223_231() {
    // 223: cmp
    conditional_code = equal(uniforms.f[93].yz, reg_tmp0.xy);
    // 224: ifc
    if (all(not(conditional_code))) {
        sub_225_226();
    } else {
        sub_226_230();
    }
    // 230: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_225_226() {
    // 225: mov
    reg_tmp6.xy = (vs_in_reg4.xyyy).xy;
    return false;
}
bool sub_226_230() {
    // 226: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_227_228();
    } else {
        sub_228_229();
    }
    // 229: nop
    return false;
}
bool sub_227_228() {
    // 227: mov
    reg_tmp6.xy = (vs_in_reg5.xyyy).xy;
    return false;
}
bool sub_228_229() {
    // 228: mov
    reg_tmp6.xy = (vs_in_reg6.xyyy).xy;
    return false;
}
bool sub_231_238() {
    // 231: mov
    reg_tmp2 = -reg_tmp15;
    // 232: dp3
    reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
    // 233: rsq
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    // 234: mul
    reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
    // 235: dp3
    reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
    // 236: add
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    // 237: mad
    reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_238_244() {
    // 238: mov
    reg_tmp1 = reg_tmp14;
    // 239: dp3
    reg_tmp2.w = dot_3(reg_tmp1.xyz, reg_tmp1.xyz);
    // 240: rsq
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    // 241: mul
    reg_tmp1 = mul_s(reg_tmp1, reg_tmp2.wwww);
    // 242: mul
    reg_tmp1 = mul_s(uniforms.f[94].xxxx, reg_tmp1);
    // 243: add
    reg_tmp6.xy = (uniforms.f[94].xxxx + reg_tmp1.xyyy).xy;
    return false;
}
bool sub_244_288() {
    // 244: mov
    reg_tmp1.xyz = (uniforms.f[93].xxyx).xyz;
    // 245: dp3
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    // 246: dp3
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    // 247: dp3
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    // 248: mov
    reg_tmp14.w = (uniforms.f[93].xxxx).w;
    // 249: mov
    reg_tmp8 = reg_tmp14;
    // 250: dp4
    reg_tmp14.x = dot_s(reg_tmp8, reg_tmp8);
    // 251: rsq
    reg_tmp14.x = rsq_s(reg_tmp14.x);
    // 252: mul
    reg_tmp14 = mul_s(reg_tmp8, reg_tmp14.xxxx);
    // 253: mov
    reg_tmp8 = uniforms.f[83];
    // 254: dp3
    reg_tmp6.x = dot_3(uniforms.f[90].xyz, reg_tmp8.xyz);
    // 255: dp3
    reg_tmp6.y = dot_3(uniforms.f[91].xyz, reg_tmp8.xyz);
    // 256: dp3
    reg_tmp6.z = dot_3(uniforms.f[92].xyz, reg_tmp8.xyz);
    // 257: add
    reg_tmp8.xyz = (reg_tmp6.xyzz + reg_tmp1.xyzz).xyz;
    // 258: mov
    reg_tmp8.w = (uniforms.f[93].xxxx).w;
    // 259: dp4
    reg_tmp0.x = dot_s(reg_tmp8, reg_tmp8);
    // 260: rsq
    reg_tmp0.x = rsq_s(reg_tmp0.x);
    // 261: mul
    reg_tmp0 = mul_s(reg_tmp8, reg_tmp0.xxxx);
    // 262: mov
    reg_tmp2 = uniforms.f[93].xxxx;
    // 263: ifu
    if (uniforms.b[9]) {
        sub_264_270();
    }
    // 270: ifu
    if (uniforms.b[7]) {
        sub_271_278();
    }
    // 278: ifu
    if (uniforms.b[8]) {
        sub_279_287();
    }
    // 287: mov
    vs_out_attr3 = reg_tmp2;
    return false;
}
bool sub_264_270() {
    // 264: dp3
    reg_tmp8.x = dot_3(reg_tmp14.xyz, -reg_tmp6.xyz);
    // 265: dp3
    reg_tmp8.y = dot_3(reg_tmp1.xyz, -reg_tmp6.xyz);
    // 266: max
    reg_tmp8 = max(uniforms.f[93].xxxx, reg_tmp8);
    // 267: mul
    reg_tmp8.y = (mul_s(uniforms.f[94].xxxx, reg_tmp8.yyyy)).y;
    // 268: add
    reg_tmp8.y = (uniforms.f[94].xxxx + reg_tmp8.yyyy).y;
    // 269: mul
    reg_tmp2.y = (mul_s(reg_tmp8.xxxx, reg_tmp8.yyyy)).y;
    return false;
}
bool sub_271_278() {
    // 271: dp3
    reg_tmp9.z = dot_3(reg_tmp14.xyz, reg_tmp0.xyz);
    // 272: max
    reg_tmp9.z = (max(uniforms.f[93].xxxx, reg_tmp9.zzzz)).z;
    // 273: min
    reg_tmp9.z = (min(uniforms.f[93].yyyy, reg_tmp9.zzzz)).z;
    // 274: log
    reg_tmp9.z = log2(reg_tmp9.z);
    // 275: mul
    reg_tmp9.z = (mul_s(uniforms.f[82].zzzz, reg_tmp9.zzzz)).z;
    // 276: exp
    reg_tmp9.z = exp2(reg_tmp9.z);
    // 277: mul
    reg_tmp2.z = (mul_s(uniforms.f[82].wwww, reg_tmp9.zzzz)).z;
    return false;
}
bool sub_279_287() {
    // 279: dp3
    reg_tmp9.x = dot_3(reg_tmp14.xyz, reg_tmp1.xyz);
    // 280: max
    reg_tmp9.x = (max(uniforms.f[93].xxxx, reg_tmp9.xxxx)).x;
    // 281: min
    reg_tmp9.x = (min(uniforms.f[93].yyyy, reg_tmp9.xxxx)).x;
    // 282: add
    reg_tmp9.x = (uniforms.f[93].yyyy + -reg_tmp9.xxxx).x;
    // 283: log
    reg_tmp9.x = log2(reg_tmp9.x);
    // 284: mul
    reg_tmp9.x = (mul_s(uniforms.f[82].xxxx, reg_tmp9.xxxx)).x;
    // 285: exp
    reg_tmp9.x = exp2(reg_tmp9.x);
    // 286: mul
    reg_tmp2.w = (mul_s(uniforms.f[82].yyyy, reg_tmp9.xxxx)).w;
    return false;
}
bool sub_288_4096() {
    // 288: ifu
    if (uniforms.b[10]) {
        sub_289_291();
    } else {
        sub_291_293();
    }
    // 293: ifu
    if (uniforms.b[1]) {
        sub_294_296();
    } else {
        sub_296_298();
    }
    // 298: call
    {
        sub_156_183();
    }
    // 299: call
    {
        sub_183_207();
    }
    // 300: call
    {
        sub_207_223();
    }
    // 301: end
    return true;
}
bool sub_289_291() {
    // 289: call
    {
        sub_65_116();
    }
    // 290: nop
    return false;
}
bool sub_291_293() {
    // 291: call
    {
        sub_116_156();
    }
    // 292: nop
    return false;
}
bool sub_294_296() {
    // 294: call
    {
        sub_244_288();
    }
    // 295: nop
    return false;
}
bool sub_296_298() {
    // 296: mov
    vs_out_attr3 = uniforms.f[93].yyyy;
    // 297: nop
    return false;
}
// reference: 7189F773B67D0CDA, AC576E32BE8CFA08
// shader: 8B30, E9755AA7A48874E6

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = 2.0 * (texcolor2).rgb - 1.0;
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(normal, normalize(view))));
refl_value.g = (lut_scale_rg * LookupLightingLUTSigned(5, dot(normal, normalize(view))));
refl_value.b = (lut_scale_rb * LookupLightingLUTSigned(4, dot(normal, normalize(view))));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor1.rgb) * (vec3(1.0) - const_color[0].aaa) + (const_color[0].rgb) * (vec3(1.0) - (vec3(1.0) - const_color[0].aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor1.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_1 = byteround(clamp((texcolor0.rgb) + (last_tex_env_out.rgb) - vec3(0.5), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (combiner_buffer.rgb) - vec3(0.5), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((secondary_fragment_color.r) * (1.0 - const_color[2].a) + (secondary_fragment_color.b) * (1.0 - (1.0 - const_color[2].a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((texcolor1.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((secondary_fragment_color.ggg) * (last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 00F48736B45D4053, E9755AA7A48874E6
// program: AC576E32BE8CFA08, AD7922A63ED54CA7, E9755AA7A48874E6
// reference: A20A308A82FD3EDC, AC576E32BE8CFA08
// shader: 8B30, BE595F2A0F068639

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D4F4BEF95B3A33D3, BE595F2A0F068639
// program: 619ABEE00AF51137, AD7922A63ED54CA7, BE595F2A0F068639
// reference: 37C48572351842C0, 619ABEE00AF51137
// program: 9289DBCB1EA8472D, AD7922A63ED54CA7, AB775DCE00F096BB
// reference: 37C4857270C7264C, 9289DBCB1EA8472D
// shader: 8B31, 51F1565D56F357E9

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}


#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define mul_3(x, y) mix(x * y, vec3(0.0), isnan(x * y))
#define fma_s(x, y, z) (mul_s(x, y) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(mul_3(x, y), vec3(1.0))

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_8();
bool sub_9_32();
bool sub_33_96();
bool sub_97_113();
bool sub_146_166();
bool sub_167_259();
bool sub_190_192();
bool sub_194_195();
bool sub_197_198();
bool sub_200_202();
bool sub_232_234();
bool sub_236_237();
bool sub_239_240();
bool sub_242_244();
bool sub_260_4096();
bool sub_280_281();
bool sub_281_282();

bool exec_shader() {
    sub_260_4096();
    return true;
}

bool sub_0_8() {
    // 0: mova
    address_registers.x = (ivec2(vs_in_reg0.zz)).x;
    // 1: mov
    reg_tmp10 = uniforms.f[0].xxxz;
    // 2: mov
    reg_tmp10.xy = (vs_in_reg0.xyyy).xy;
    // 3: mov
    reg_tmp11 = uniforms.f[0].xxxx;
    // 4: mov
    reg_tmp12 = uniforms.f[0].xxxx;
    // 5: mov
    reg_tmp13 = uniforms.f[0].zzzz;
    // 6: mov
    reg_tmp4 = uniforms.f[0].xxxx;
    // 7: mov
    reg_tmp5 = uniforms.f[0].xxxx;
    return false;
}
bool sub_9_32() {
    // 9: mov
    vs_out_attr0 = reg_tmp10;
    // 10: mul
    reg_tmp13 = mul_s(uniforms.f[82], reg_tmp13);
    // 11: mov
    vs_out_attr1 = reg_tmp13;
    // 12: add
    reg_tmp11.y = (uniforms.f[0].zzzz + -reg_tmp11.yyyy).y;
    // 13: add
    reg_tmp12.y = (uniforms.f[0].zzzz + -reg_tmp12.yyyy).y;
    // 14: mov
    reg_tmp14.y = (uniforms.f[81].wwww).y;
    // 15: mul
    reg_tmp14.x = (mul_s(uniforms.f[0].wwww, reg_tmp14.yyyy)).x;
    // 16: rcp
    reg_tmp2.x = rcp_s(reg_tmp14.x);
    // 17: mov
    reg_tmp14.z = (reg_tmp2.xxxx).z;
    // 18: add
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp11.xyyy).xy;
    // 19: mul
    reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    // 20: flr
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    // 21: mul
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    // 22: add
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    // 23: add
    reg_tmp11.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    // 24: add
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp12.xyyy).xy;
    // 25: mul
    reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    // 26: flr
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    // 27: mul
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    // 28: add
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    // 29: add
    reg_tmp12.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    // 30: mov
    vs_out_attr2 = reg_tmp11;
    // 31: mov
    vs_out_attr3 = reg_tmp12;
    return false;
}
bool sub_33_96() {
    // 33: mov
    reg_tmp6.xyz = (-reg_tmp0.xyzz).xyz;
    // 34: mov
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    // 35: rcp
    reg_tmp7.xyz = vec3(rcp_s(uniforms.f[81].y));
    // 36: madi
    reg_tmp8.xyz = (fma_s(reg_tmp6.xyzz, reg_tmp7.xyzz, uniforms.f[0].yyyy)).xyz;
    // 37: flr
    reg_tmp7.xyz = (floor(reg_tmp8.xyzz)).xyz;
    // 38: mad
    reg_tmp6.xyz = (fma_s(reg_tmp7.xyzz, -uniforms.f[81].yyyy, reg_tmp6.xyzz)).xyz;
    // 39: min
    reg_tmp6 = min(uniforms.f[81].xxxx, reg_tmp6);
    // 40: max
    reg_tmp6 = max(-uniforms.f[81].xxxx, reg_tmp6);
    // 41: mov
    reg_tmp2 = uniforms.f[95];
    // 42: mov
    reg_tmp3 = uniforms.f[94];
    // 43: mul
    reg_tmp1.z = (mul_s(reg_tmp6.xxxx, reg_tmp6.xxxx)).z;
    // 44: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 45: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 46: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 47: mov
    reg_tmp2 = uniforms.f[93];
    // 48: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 49: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 50: mul
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp6.xxxx)).y;
    // 51: mov
    reg_tmp4.x = (reg_tmp1.xxxx).x;
    // 52: mov
    reg_tmp5.x = (reg_tmp1.yyyy).x;
    // 53: mov
    reg_tmp2 = uniforms.f[95];
    // 54: mov
    reg_tmp3 = uniforms.f[94];
    // 55: mul
    reg_tmp1.z = (mul_s(reg_tmp6.yyyy, reg_tmp6.yyyy)).z;
    // 56: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 57: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 58: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 59: mov
    reg_tmp2 = uniforms.f[93];
    // 60: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 61: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 62: mul
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp6.yyyy)).y;
    // 63: mov
    reg_tmp4.y = (reg_tmp1.xxxx).y;
    // 64: mov
    reg_tmp5.y = (reg_tmp1.yyyy).y;
    // 65: mov
    reg_tmp2 = uniforms.f[95];
    // 66: mov
    reg_tmp3 = uniforms.f[94];
    // 67: mul
    reg_tmp1.z = (mul_s(reg_tmp6.zzzz, reg_tmp6.zzzz)).z;
    // 68: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 69: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 70: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 71: mov
    reg_tmp2 = uniforms.f[93];
    // 72: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 73: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 74: mul
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp6.zzzz)).y;
    // 75: mov
    reg_tmp4.z = (reg_tmp1.xxxx).z;
    // 76: mov
    reg_tmp5.z = (reg_tmp1.yyyy).z;
    // 77: mul
    reg_tmp2.x = (mul_s(reg_tmp4.yyyy, reg_tmp5.zzzz)).x;
    // 78: mul
    reg_tmp2.y = (mul_s(reg_tmp5.yyyy, reg_tmp5.zzzz)).y;
    // 79: mul
    reg_tmp6.x = (mul_s(reg_tmp4.yyyy, reg_tmp4.zzzz)).x;
    // 80: mov
    reg_tmp6.y = (reg_tmp5.zzzz).y;
    // 81: mul
    reg_tmp6.z = (mul_s(-reg_tmp5.yyyy, reg_tmp4.zzzz)).z;
    // 82: mov
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    // 83: mul
    reg_tmp7.x = (mul_s(-reg_tmp2.xxxx, reg_tmp4.xxxx)).x;
    // 84: mad
    reg_tmp7.x = (fma_s(reg_tmp5.yyyy, reg_tmp5.xxxx, reg_tmp7.xxxx)).x;
    // 85: mul
    reg_tmp7.y = (mul_s(reg_tmp4.zzzz, reg_tmp4.xxxx)).y;
    // 86: mul
    reg_tmp7.z = (mul_s(reg_tmp2.yyyy, reg_tmp4.xxxx)).z;
    // 87: mad
    reg_tmp7.z = (fma_s(reg_tmp4.yyyy, reg_tmp5.xxxx, reg_tmp7.zzzz)).z;
    // 88: mov
    reg_tmp7.w = (uniforms.f[0].xxxx).w;
    // 89: mul
    reg_tmp8.x = (mul_s(reg_tmp2.xxxx, reg_tmp5.xxxx)).x;
    // 90: mad
    reg_tmp8.x = (fma_s(reg_tmp5.yyyy, reg_tmp4.xxxx, reg_tmp8.xxxx)).x;
    // 91: mul
    reg_tmp8.y = (mul_s(-reg_tmp4.zzzz, reg_tmp5.xxxx)).y;
    // 92: mul
    reg_tmp8.z = (mul_s(-reg_tmp2.yyyy, reg_tmp5.xxxx)).z;
    // 93: mad
    reg_tmp8.z = (fma_s(reg_tmp4.yyyy, reg_tmp4.xxxx, reg_tmp8.zzzz)).z;
    // 94: mov
    reg_tmp8.w = (uniforms.f[0].xxxx).w;
    // 95: mov
    reg_tmp9 = uniforms.f[0].xxxz;
    return false;
}
bool sub_97_113() {
    // 97: mov
    reg_tmp6.x = (uniforms.f[90].xxxx).x;
    // 98: mov
    reg_tmp6.y = (uniforms.f[91].xxxx).y;
    // 99: mov
    reg_tmp6.z = (uniforms.f[92].xxxx).z;
    // 100: mov
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    // 101: mov
    reg_tmp7.x = (uniforms.f[90].yyyy).x;
    // 102: mov
    reg_tmp7.y = (uniforms.f[91].yyyy).y;
    // 103: mov
    reg_tmp7.z = (uniforms.f[92].yyyy).z;
    // 104: mov
    reg_tmp7.w = (uniforms.f[0].xxxx).w;
    // 105: mov
    reg_tmp8.x = (uniforms.f[90].zzzz).x;
    // 106: mov
    reg_tmp8.y = (uniforms.f[91].zzzz).y;
    // 107: mov
    reg_tmp8.z = (uniforms.f[92].zzzz).z;
    // 108: mov
    reg_tmp8.w = (uniforms.f[0].xxxx).w;
    // 109: mov
    reg_tmp9.x = (uniforms.f[90].wwww).x;
    // 110: mov
    reg_tmp9.y = (uniforms.f[91].wwww).y;
    // 111: mov
    reg_tmp9.z = (uniforms.f[92].wwww).z;
    // 112: mov
    reg_tmp9.w = (uniforms.f[0].zzzz).w;
    return false;
}
bool sub_146_166() {
    // 146: mov
    reg_tmp2 = uniforms.f[90];
    // 147: mov
    reg_tmp3 = uniforms.f[91];
    // 148: mov
    reg_tmp4 = uniforms.f[92];
    // 149: mov
    reg_tmp5 = uniforms.f[0].xxxz;
    // 150: mul
    reg_tmp6 = mul_s(uniforms.f[86].xxxx, reg_tmp2);
    // 151: mad
    reg_tmp6 = fma_s(reg_tmp3, uniforms.f[86].yyyy, reg_tmp6);
    // 152: mad
    reg_tmp6 = fma_s(reg_tmp4, uniforms.f[86].zzzz, reg_tmp6);
    // 153: mad
    reg_tmp6 = fma_s(reg_tmp5, uniforms.f[86].wwww, reg_tmp6);
    // 154: mul
    reg_tmp7 = mul_s(uniforms.f[87].xxxx, reg_tmp2);
    // 155: mad
    reg_tmp7 = fma_s(reg_tmp3, uniforms.f[87].yyyy, reg_tmp7);
    // 156: mad
    reg_tmp7 = fma_s(reg_tmp4, uniforms.f[87].zzzz, reg_tmp7);
    // 157: mad
    reg_tmp7 = fma_s(reg_tmp5, uniforms.f[87].wwww, reg_tmp7);
    // 158: mul
    reg_tmp8 = mul_s(uniforms.f[88].xxxx, reg_tmp2);
    // 159: mad
    reg_tmp8 = fma_s(reg_tmp3, uniforms.f[88].yyyy, reg_tmp8);
    // 160: mad
    reg_tmp8 = fma_s(reg_tmp4, uniforms.f[88].zzzz, reg_tmp8);
    // 161: mad
    reg_tmp8 = fma_s(reg_tmp5, uniforms.f[88].wwww, reg_tmp8);
    // 162: mul
    reg_tmp9 = mul_s(uniforms.f[89].xxxx, reg_tmp2);
    // 163: mad
    reg_tmp9 = fma_s(reg_tmp3, uniforms.f[89].yyyy, reg_tmp9);
    // 164: mad
    reg_tmp9 = fma_s(reg_tmp4, uniforms.f[89].zzzz, reg_tmp9);
    // 165: mad
    reg_tmp9 = fma_s(reg_tmp5, uniforms.f[89].wwww, reg_tmp9);
    return false;
}
bool sub_167_259() {
    // 167: rcp
    reg_tmp2.x = rcp_s(uniforms.f[81].y);
    // 168: mul
    reg_tmp2.xy = (mul_s(uniforms.f[2 + address_registers.x].zwww, reg_tmp2.xxxx)).xy;
    // 169: add
    reg_tmp2.xy = (uniforms.f[0].yyyy + reg_tmp2.xyyy).xy;
    // 170: flr
    reg_tmp3.xy = (floor(reg_tmp2.xyyy)).xy;
    // 171: mul
    reg_tmp2.xy = (mul_s(uniforms.f[81].yyyy, reg_tmp3.xyyy)).xy;
    // 172: add
    reg_tmp2.xy = (uniforms.f[2 + address_registers.x].zwww + -reg_tmp2.xyyy).xy;
    // 173: min
    reg_tmp0.xy = (min(uniforms.f[81].xxxx, -reg_tmp2.xyyy)).xy;
    // 174: max
    reg_tmp0.xy = (max(-uniforms.f[81].xxxx, reg_tmp0.xyyy)).xy;
    // 175: mov
    reg_tmp2 = uniforms.f[95];
    // 176: mov
    reg_tmp3 = uniforms.f[94];
    // 177: mul
    reg_tmp1.z = (mul_s(reg_tmp0.xxxx, reg_tmp0.xxxx)).z;
    // 178: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 179: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 180: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 181: mov
    reg_tmp2 = uniforms.f[93];
    // 182: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 183: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 184: mul
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.xxxx)).y;
    // 185: mov
    reg_tmp5.x = (uniforms.f[5 + address_registers.x].wwww).x;
    // 186: mov
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    // 187: mov
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    // 188: cmp
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    // 189: ifc
    if (conditional_code.x) {
        sub_190_192();
    }
    // 192: cmp
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    // 193: ifc
    if (conditional_code.x) {
        sub_194_195();
    }
    // 195: cmp
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 196: ifc
    if (conditional_code.x) {
        sub_197_198();
    }
    // 198: cmp
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 199: ifc
    if (conditional_code.x) {
        sub_200_202();
    }
    // 202: mul
    reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    // 203: mad
    reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    // 204: mad
    reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    // 205: add
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    // 206: add
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    // 207: mov
    reg_tmp4.z = (uniforms.f[83].xxxx).z;
    // 208: mov
    reg_tmp4.w = (-uniforms.f[83].yyyy).w;
    // 209: madi
    reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[3 + address_registers.x].xyyy)).xy;
    // 210: mov
    reg_tmp4.z = (-uniforms.f[3 + address_registers.x].zzzz).z;
    // 211: mov
    reg_tmp4.w = (-uniforms.f[3 + address_registers.x].wwww).w;
    // 212: add
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    // 213: add
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    // 214: mad
    reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    // 215: mad
    reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    // 216: mov
    reg_tmp11.xy = (reg_tmp5.xyyy).xy;
    // 217: mov
    reg_tmp2 = uniforms.f[95];
    // 218: mov
    reg_tmp3 = uniforms.f[94];
    // 219: mul
    reg_tmp1.z = (mul_s(reg_tmp0.yyyy, reg_tmp0.yyyy)).z;
    // 220: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 221: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 222: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 223: mov
    reg_tmp2 = uniforms.f[93];
    // 224: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 225: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 226: mul
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.yyyy)).y;
    // 227: mov
    reg_tmp5.x = (uniforms.f[6 + address_registers.x].wwww).x;
    // 228: mov
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    // 229: mov
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    // 230: cmp
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    // 231: ifc
    if (conditional_code.x) {
        sub_232_234();
    }
    // 234: cmp
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    // 235: ifc
    if (conditional_code.x) {
        sub_236_237();
    }
    // 237: cmp
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 238: ifc
    if (conditional_code.x) {
        sub_239_240();
    }
    // 240: cmp
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 241: ifc
    if (conditional_code.x) {
        sub_242_244();
    }
    // 244: mul
    reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    // 245: mad
    reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    // 246: mad
    reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    // 247: add
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    // 248: add
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    // 249: mov
    reg_tmp4.z = (uniforms.f[83].zzzz).z;
    // 250: mov
    reg_tmp4.w = (-uniforms.f[83].wwww).w;
    // 251: madi
    reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[4 + address_registers.x].xyyy)).xy;
    // 252: mov
    reg_tmp4.z = (-uniforms.f[4 + address_registers.x].zzzz).z;
    // 253: mov
    reg_tmp4.w = (-uniforms.f[4 + address_registers.x].wwww).w;
    // 254: add
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    // 255: add
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    // 256: mad
    reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    // 257: mad
    reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    // 258: mov
    reg_tmp12.xy = (reg_tmp5.xyyy).xy;
    return false;
}
bool sub_190_192() {
    // 190: mov
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    // 191: mov
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_194_195() {
    // 194: mov
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_197_198() {
    // 197: mov
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_200_202() {
    // 200: mov
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    // 201: mov
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_232_234() {
    // 232: mov
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    // 233: mov
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_236_237() {
    // 236: mov
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_239_240() {
    // 239: mov
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_242_244() {
    // 242: mov
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    // 243: mov
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_260_4096() {
    // 260: call
    {
        sub_0_8();
    }
    // 261: add
    reg_tmp10.xy = (uniforms.f[84].xyyy + reg_tmp10.xyyy).xy;
    // 262: mul
    reg_tmp10.xy = (mul_s(uniforms.f[2 + address_registers.x].xyyy, reg_tmp10.xyyy)).xy;
    // 263: mov
    reg_tmp0 = uniforms.f[7 + address_registers.x];
    // 264: call
    {
        sub_33_96();
    }
    // 265: dp4
    reg_tmp2.x = dot_s(reg_tmp10, reg_tmp6);
    // 266: dp4
    reg_tmp2.y = dot_s(reg_tmp10, reg_tmp7);
    // 267: dp4
    reg_tmp2.z = dot_s(reg_tmp10, reg_tmp8);
    // 268: dp4
    reg_tmp2.w = dot_s(reg_tmp10, reg_tmp9);
    // 269: mov
    reg_tmp10 = reg_tmp2;
    // 270: call
    {
        sub_97_113();
    }
    // 271: dp4
    reg_tmp2.x = dot_s(reg_tmp10, reg_tmp6);
    // 272: dp4
    reg_tmp2.y = dot_s(reg_tmp10, reg_tmp7);
    // 273: dp4
    reg_tmp2.z = dot_s(reg_tmp10, reg_tmp8);
    // 274: dp4
    reg_tmp2.w = dot_s(uniforms.f[0].xxxz, reg_tmp10);
    // 275: mov
    reg_tmp3.xyz = (uniforms.f[5 + address_registers.x].xyzz).xyz;
    // 276: add
    reg_tmp3.xyz = (uniforms.f[85].xyzz + -reg_tmp3.xyzz).xyz;
    // 277: dp3
    reg_tmp4.x = dot_3(reg_tmp3.xyz, reg_tmp3.xyz);
    // 278: cmp
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
    // 279: ifc
    if (conditional_code.x) {
        sub_280_281();
    } else {
        sub_281_282();
    }
    // 282: mul
    reg_tmp3.xyz = (mul_s(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
    // 283: add
    reg_tmp10.xyz = (uniforms.f[5 + address_registers.x].xyzz + reg_tmp2.xyzz).xyz;
    // 284: mad
    reg_tmp10.xyz = (fma_s(reg_tmp3.xyzz, uniforms.f[84].zzzz, reg_tmp10.xyzz)).xyz;
    // 285: call
    {
        sub_146_166();
    }
    // 286: mov
    reg_tmp2 = reg_tmp10;
    // 287: dp4
    reg_tmp10.x = dot_s(reg_tmp2, reg_tmp6);
    // 288: dp4
    reg_tmp10.y = dot_s(reg_tmp2, reg_tmp7);
    // 289: dp4
    reg_tmp10.z = dot_s(reg_tmp2, reg_tmp8);
    // 290: dp4
    reg_tmp10.w = dot_s(reg_tmp2, reg_tmp9);
    // 291: mov
    reg_tmp2 = uniforms.f[1 + address_registers.x];
    // 292: max
    reg_tmp3 = max(uniforms.f[0].xxxx, reg_tmp2);
    // 293: min
    reg_tmp2 = min(uniforms.f[0].zzzz, reg_tmp3);
    // 294: mov
    reg_tmp13 = reg_tmp2;
    // 295: call
    {
        sub_167_259();
    }
    // 296: call
    {
        sub_9_32();
    }
    // 297: end
    return true;
}
bool sub_280_281() {
    // 280: mov
    reg_tmp4.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_281_282() {
    // 281: rsq
    reg_tmp4.x = rsq_s(reg_tmp4.x);
    return false;
}
// reference: C91117B33689CFFE, 51F1565D56F357E9
// shader: 8B30, 52F15AB07872CB3F

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_2 = byteround(clamp((vec3(1.0) - combiner_buffer.rgb) * (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: AE3D27E93E737D07, 52F15AB07872CB3F
// program: 51F1565D56F357E9, CEF02063E9A18B2F, 52F15AB07872CB3F
// reference: AE4BD47E79F1190B, 93C50366EC4126B4
// reference: 7DC813874D712B0D, 93C50366EC4126B4
// reference: 8C39401B6B8E258C, 619ABEE00AF51137
// reference: 5FBA87E290900042, 619ABEE00AF51137
// reference: 5FBA87E25F0E178A, 619ABEE00AF51137
// reference: 8C39401BC168D241, 9289DBCB1EA8472D
// reference: AE4BD47EC2605CD9, 93C50366EC4126B4
// reference: 7DC81387F6E06EDF, 93C50366EC4126B4
// reference: A7400F4474D65D58, 458EEA119FC06605
// reference: 60055AF2137FF209, 7A6559ADA21E6F2E
// reference: 22A340904CB09D99, 07A736992979F928
// reference: 8E5EF570B67D0CDA, AC576E32BE8CFA08
// reference: 5DDD328982FD3EDC, AC576E32BE8CFA08
// reference: AE4BD47EBB74973F, 93C50366EC4126B4
// reference: 7DC81387406AB2F1, 93C50366EC4126B4
// reference: A7400F440DC296BE, 458EEA119FC06605
// reference: 7DC813878FF4A539, 93C50366EC4126B4
// shader: 8B30, 7E43BDC96307597A

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_2 = byteround(clamp((vec3(1.0) - combiner_buffer.rgb) * (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: E7C524FDD196C12C, 7E43BDC96307597A
// program: 93C50366EC4126B4, 5D764F9A6220D694, 7E43BDC96307597A
// shader: 8B30, 3491D7B9A34DF552

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((vec3(1.0) - combiner_buffer.rgb) * (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: E7C524FD21414A81, 3491D7B9A34DF552
// program: 93C50366EC4126B4, 5D764F9A6220D694, 3491D7B9A34DF552
// shader: 8B30, 695C3AA7F8FFB342

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((vec3(1.0) - combiner_buffer.rgb) * (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D77D3BB682EC36A8, 695C3AA7F8FFB342
// program: 93C50366EC4126B4, 5D764F9A6220D694, 695C3AA7F8FFB342
// reference: A7400F44CF47188A, 458EEA119FC06605
// reference: C91117B3D9B05CBF, 51F1565D56F357E9
// reference: 7DC81387A248B84C, 93C50366EC4126B4
// reference: 5FBA87E2B03784CB, 619ABEE00AF51137
// program: 51F1565D56F357E9, CEF02063E9A18B2F, 52F15AB03C873666
// shader: 8B31, 1F86C2CEA310ECA3

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}


#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define mul_3(x, y) mix(x * y, vec3(0.0), isnan(x * y))
#define fma_s(x, y, z) (mul_s(x, y) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(mul_3(x, y), vec3(1.0))

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_8();
bool sub_9_32();
bool sub_97_113();
bool sub_146_166();
bool sub_167_259();
bool sub_190_192();
bool sub_194_195();
bool sub_197_198();
bool sub_200_202();
bool sub_232_234();
bool sub_236_237();
bool sub_239_240();
bool sub_242_244();
bool sub_260_4096();
bool sub_273_274();
bool sub_274_275();

bool exec_shader() {
    sub_260_4096();
    return true;
}

bool sub_0_8() {
    // 0: mova
    address_registers.x = (ivec2(vs_in_reg0.zz)).x;
    // 1: mov
    reg_tmp10 = uniforms.f[0].xxxz;
    // 2: mov
    reg_tmp10.xy = (vs_in_reg0.xyyy).xy;
    // 3: mov
    reg_tmp11 = uniforms.f[0].xxxx;
    // 4: mov
    reg_tmp12 = uniforms.f[0].xxxx;
    // 5: mov
    reg_tmp13 = uniforms.f[0].zzzz;
    // 6: mov
    reg_tmp4 = uniforms.f[0].xxxx;
    // 7: mov
    reg_tmp5 = uniforms.f[0].xxxx;
    return false;
}
bool sub_9_32() {
    // 9: mov
    vs_out_attr0 = reg_tmp10;
    // 10: mul
    reg_tmp13 = mul_s(uniforms.f[82], reg_tmp13);
    // 11: mov
    vs_out_attr1 = reg_tmp13;
    // 12: add
    reg_tmp11.y = (uniforms.f[0].zzzz + -reg_tmp11.yyyy).y;
    // 13: add
    reg_tmp12.y = (uniforms.f[0].zzzz + -reg_tmp12.yyyy).y;
    // 14: mov
    reg_tmp14.y = (uniforms.f[81].wwww).y;
    // 15: mul
    reg_tmp14.x = (mul_s(uniforms.f[0].wwww, reg_tmp14.yyyy)).x;
    // 16: rcp
    reg_tmp2.x = rcp_s(reg_tmp14.x);
    // 17: mov
    reg_tmp14.z = (reg_tmp2.xxxx).z;
    // 18: add
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp11.xyyy).xy;
    // 19: mul
    reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    // 20: flr
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    // 21: mul
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    // 22: add
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    // 23: add
    reg_tmp11.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    // 24: add
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp12.xyyy).xy;
    // 25: mul
    reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    // 26: flr
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    // 27: mul
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    // 28: add
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    // 29: add
    reg_tmp12.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    // 30: mov
    vs_out_attr2 = reg_tmp11;
    // 31: mov
    vs_out_attr3 = reg_tmp12;
    return false;
}
bool sub_97_113() {
    // 97: mov
    reg_tmp6.x = (uniforms.f[90].xxxx).x;
    // 98: mov
    reg_tmp6.y = (uniforms.f[91].xxxx).y;
    // 99: mov
    reg_tmp6.z = (uniforms.f[92].xxxx).z;
    // 100: mov
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    // 101: mov
    reg_tmp7.x = (uniforms.f[90].yyyy).x;
    // 102: mov
    reg_tmp7.y = (uniforms.f[91].yyyy).y;
    // 103: mov
    reg_tmp7.z = (uniforms.f[92].yyyy).z;
    // 104: mov
    reg_tmp7.w = (uniforms.f[0].xxxx).w;
    // 105: mov
    reg_tmp8.x = (uniforms.f[90].zzzz).x;
    // 106: mov
    reg_tmp8.y = (uniforms.f[91].zzzz).y;
    // 107: mov
    reg_tmp8.z = (uniforms.f[92].zzzz).z;
    // 108: mov
    reg_tmp8.w = (uniforms.f[0].xxxx).w;
    // 109: mov
    reg_tmp9.x = (uniforms.f[90].wwww).x;
    // 110: mov
    reg_tmp9.y = (uniforms.f[91].wwww).y;
    // 111: mov
    reg_tmp9.z = (uniforms.f[92].wwww).z;
    // 112: mov
    reg_tmp9.w = (uniforms.f[0].zzzz).w;
    return false;
}
bool sub_146_166() {
    // 146: mov
    reg_tmp2 = uniforms.f[90];
    // 147: mov
    reg_tmp3 = uniforms.f[91];
    // 148: mov
    reg_tmp4 = uniforms.f[92];
    // 149: mov
    reg_tmp5 = uniforms.f[0].xxxz;
    // 150: mul
    reg_tmp6 = mul_s(uniforms.f[86].xxxx, reg_tmp2);
    // 151: mad
    reg_tmp6 = fma_s(reg_tmp3, uniforms.f[86].yyyy, reg_tmp6);
    // 152: mad
    reg_tmp6 = fma_s(reg_tmp4, uniforms.f[86].zzzz, reg_tmp6);
    // 153: mad
    reg_tmp6 = fma_s(reg_tmp5, uniforms.f[86].wwww, reg_tmp6);
    // 154: mul
    reg_tmp7 = mul_s(uniforms.f[87].xxxx, reg_tmp2);
    // 155: mad
    reg_tmp7 = fma_s(reg_tmp3, uniforms.f[87].yyyy, reg_tmp7);
    // 156: mad
    reg_tmp7 = fma_s(reg_tmp4, uniforms.f[87].zzzz, reg_tmp7);
    // 157: mad
    reg_tmp7 = fma_s(reg_tmp5, uniforms.f[87].wwww, reg_tmp7);
    // 158: mul
    reg_tmp8 = mul_s(uniforms.f[88].xxxx, reg_tmp2);
    // 159: mad
    reg_tmp8 = fma_s(reg_tmp3, uniforms.f[88].yyyy, reg_tmp8);
    // 160: mad
    reg_tmp8 = fma_s(reg_tmp4, uniforms.f[88].zzzz, reg_tmp8);
    // 161: mad
    reg_tmp8 = fma_s(reg_tmp5, uniforms.f[88].wwww, reg_tmp8);
    // 162: mul
    reg_tmp9 = mul_s(uniforms.f[89].xxxx, reg_tmp2);
    // 163: mad
    reg_tmp9 = fma_s(reg_tmp3, uniforms.f[89].yyyy, reg_tmp9);
    // 164: mad
    reg_tmp9 = fma_s(reg_tmp4, uniforms.f[89].zzzz, reg_tmp9);
    // 165: mad
    reg_tmp9 = fma_s(reg_tmp5, uniforms.f[89].wwww, reg_tmp9);
    return false;
}
bool sub_167_259() {
    // 167: rcp
    reg_tmp2.x = rcp_s(uniforms.f[81].y);
    // 168: mul
    reg_tmp2.xy = (mul_s(uniforms.f[2 + address_registers.x].zwww, reg_tmp2.xxxx)).xy;
    // 169: add
    reg_tmp2.xy = (uniforms.f[0].yyyy + reg_tmp2.xyyy).xy;
    // 170: flr
    reg_tmp3.xy = (floor(reg_tmp2.xyyy)).xy;
    // 171: mul
    reg_tmp2.xy = (mul_s(uniforms.f[81].yyyy, reg_tmp3.xyyy)).xy;
    // 172: add
    reg_tmp2.xy = (uniforms.f[2 + address_registers.x].zwww + -reg_tmp2.xyyy).xy;
    // 173: min
    reg_tmp0.xy = (min(uniforms.f[81].xxxx, -reg_tmp2.xyyy)).xy;
    // 174: max
    reg_tmp0.xy = (max(-uniforms.f[81].xxxx, reg_tmp0.xyyy)).xy;
    // 175: mov
    reg_tmp2 = uniforms.f[95];
    // 176: mov
    reg_tmp3 = uniforms.f[94];
    // 177: mul
    reg_tmp1.z = (mul_s(reg_tmp0.xxxx, reg_tmp0.xxxx)).z;
    // 178: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 179: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 180: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 181: mov
    reg_tmp2 = uniforms.f[93];
    // 182: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 183: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 184: mul
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.xxxx)).y;
    // 185: mov
    reg_tmp5.x = (uniforms.f[5 + address_registers.x].wwww).x;
    // 186: mov
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    // 187: mov
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    // 188: cmp
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    // 189: ifc
    if (conditional_code.x) {
        sub_190_192();
    }
    // 192: cmp
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    // 193: ifc
    if (conditional_code.x) {
        sub_194_195();
    }
    // 195: cmp
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 196: ifc
    if (conditional_code.x) {
        sub_197_198();
    }
    // 198: cmp
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 199: ifc
    if (conditional_code.x) {
        sub_200_202();
    }
    // 202: mul
    reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    // 203: mad
    reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    // 204: mad
    reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    // 205: add
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    // 206: add
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    // 207: mov
    reg_tmp4.z = (uniforms.f[83].xxxx).z;
    // 208: mov
    reg_tmp4.w = (-uniforms.f[83].yyyy).w;
    // 209: madi
    reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[3 + address_registers.x].xyyy)).xy;
    // 210: mov
    reg_tmp4.z = (-uniforms.f[3 + address_registers.x].zzzz).z;
    // 211: mov
    reg_tmp4.w = (-uniforms.f[3 + address_registers.x].wwww).w;
    // 212: add
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    // 213: add
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    // 214: mad
    reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    // 215: mad
    reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    // 216: mov
    reg_tmp11.xy = (reg_tmp5.xyyy).xy;
    // 217: mov
    reg_tmp2 = uniforms.f[95];
    // 218: mov
    reg_tmp3 = uniforms.f[94];
    // 219: mul
    reg_tmp1.z = (mul_s(reg_tmp0.yyyy, reg_tmp0.yyyy)).z;
    // 220: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 221: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 222: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 223: mov
    reg_tmp2 = uniforms.f[93];
    // 224: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 225: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 226: mul
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.yyyy)).y;
    // 227: mov
    reg_tmp5.x = (uniforms.f[6 + address_registers.x].wwww).x;
    // 228: mov
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    // 229: mov
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    // 230: cmp
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    // 231: ifc
    if (conditional_code.x) {
        sub_232_234();
    }
    // 234: cmp
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    // 235: ifc
    if (conditional_code.x) {
        sub_236_237();
    }
    // 237: cmp
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 238: ifc
    if (conditional_code.x) {
        sub_239_240();
    }
    // 240: cmp
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 241: ifc
    if (conditional_code.x) {
        sub_242_244();
    }
    // 244: mul
    reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    // 245: mad
    reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    // 246: mad
    reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    // 247: add
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    // 248: add
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    // 249: mov
    reg_tmp4.z = (uniforms.f[83].zzzz).z;
    // 250: mov
    reg_tmp4.w = (-uniforms.f[83].wwww).w;
    // 251: madi
    reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[4 + address_registers.x].xyyy)).xy;
    // 252: mov
    reg_tmp4.z = (-uniforms.f[4 + address_registers.x].zzzz).z;
    // 253: mov
    reg_tmp4.w = (-uniforms.f[4 + address_registers.x].wwww).w;
    // 254: add
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    // 255: add
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    // 256: mad
    reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    // 257: mad
    reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    // 258: mov
    reg_tmp12.xy = (reg_tmp5.xyyy).xy;
    return false;
}
bool sub_190_192() {
    // 190: mov
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    // 191: mov
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_194_195() {
    // 194: mov
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_197_198() {
    // 197: mov
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_200_202() {
    // 200: mov
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    // 201: mov
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_232_234() {
    // 232: mov
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    // 233: mov
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_236_237() {
    // 236: mov
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_239_240() {
    // 239: mov
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_242_244() {
    // 242: mov
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    // 243: mov
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_260_4096() {
    // 260: call
    {
        sub_0_8();
    }
    // 261: add
    reg_tmp10.xy = (uniforms.f[84].xyyy + reg_tmp10.xyyy).xy;
    // 262: mul
    reg_tmp10.xy = (mul_s(uniforms.f[2 + address_registers.x].xyyy, reg_tmp10.xyyy)).xy;
    // 263: call
    {
        sub_97_113();
    }
    // 264: dp4
    reg_tmp2.x = dot_s(reg_tmp10, reg_tmp6);
    // 265: dp4
    reg_tmp2.y = dot_s(reg_tmp10, reg_tmp7);
    // 266: dp4
    reg_tmp2.z = dot_s(reg_tmp10, reg_tmp8);
    // 267: dp4
    reg_tmp2.w = dot_s(uniforms.f[0].xxxz, reg_tmp10);
    // 268: mov
    reg_tmp3.xyz = (uniforms.f[5 + address_registers.x].xyzz).xyz;
    // 269: add
    reg_tmp3.xyz = (uniforms.f[85].xyzz + -reg_tmp3.xyzz).xyz;
    // 270: dp3
    reg_tmp4.x = dot_3(reg_tmp3.xyz, reg_tmp3.xyz);
    // 271: cmp
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
    // 272: ifc
    if (conditional_code.x) {
        sub_273_274();
    } else {
        sub_274_275();
    }
    // 275: mul
    reg_tmp3.xyz = (mul_s(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
    // 276: add
    reg_tmp10.xyz = (uniforms.f[5 + address_registers.x].xyzz + reg_tmp2.xyzz).xyz;
    // 277: mad
    reg_tmp10.xyz = (fma_s(reg_tmp3.xyzz, uniforms.f[84].zzzz, reg_tmp10.xyzz)).xyz;
    // 278: call
    {
        sub_146_166();
    }
    // 279: mov
    reg_tmp2 = reg_tmp10;
    // 280: dp4
    reg_tmp10.x = dot_s(reg_tmp2, reg_tmp6);
    // 281: dp4
    reg_tmp10.y = dot_s(reg_tmp2, reg_tmp7);
    // 282: dp4
    reg_tmp10.z = dot_s(reg_tmp2, reg_tmp8);
    // 283: dp4
    reg_tmp10.w = dot_s(reg_tmp2, reg_tmp9);
    // 284: mov
    reg_tmp2 = uniforms.f[1 + address_registers.x];
    // 285: max
    reg_tmp3 = max(uniforms.f[0].xxxx, reg_tmp2);
    // 286: min
    reg_tmp2 = min(uniforms.f[0].zzzz, reg_tmp3);
    // 287: mov
    reg_tmp13 = reg_tmp2;
    // 288: call
    {
        sub_167_259();
    }
    // 289: call
    {
        sub_9_32();
    }
    // 290: end
    return true;
}
bool sub_273_274() {
    // 273: mov
    reg_tmp4.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_274_275() {
    // 274: rsq
    reg_tmp4.x = rsq_s(reg_tmp4.x);
    return false;
}
// reference: 07F9F7A4DF8D6890, 1F86C2CEA310ECA3
// program: 1F86C2CEA310ECA3, CEF02063E9A18B2F, 52F15AB03C873666
// shader: 8B30, F4D4A672151406DE

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.r) + (texcolor1.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 0FEF1F2F49AF6349, F4D4A672151406DE
// program: 1F86C2CEA310ECA3, CEF02063E9A18B2F, F4D4A672151406DE
// shader: 8B30, 7A3173B303F95A5E

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((vec3(1.0) - combiner_buffer.rgb) * (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 6FB2BCD49EEC8605, 7A3173B303F95A5E
// program: 93C50366EC4126B4, 5D764F9A6220D694, 7A3173B303F95A5E
// reference: 58970D475D89C1E2, 458EEA119FC06605
// reference: A06D85E105EC0271, 619ABEE00AF51137
// shader: 8B30, F5D6ACAB53B64CF3

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) + (const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].aaa) + (const_color[1].rgb) * (vec3(1.0) - (const_color[1].aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (const_color[2].a) + (const_color[2].r) * (1.0 - (const_color[2].a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((texcolor1.a) * (const_color[3].a) + (texcolor1.r) * (1.0 - (const_color[3].a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a) * (combiner_buffer.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D3310DE01E8B3F75, F5D6ACAB53B64CF3
// program: 07A736992979F928, AD7922A63ED54CA7, F5D6ACAB53B64CF3
// shader: 8B31, 1708AF5D88058ABC

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;
 out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}


#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define mul_3(x, y) mix(x * y, vec3(0.0), isnan(x * y))
#define fma_s(x, y, z) (mul_s(x, y) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(mul_3(x, y), vec3(1.0))

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_19();
bool sub_19_29();
bool sub_29_79();
bool sub_34_52();
bool sub_52_60();
bool sub_77_78();
bool sub_79_106();
bool sub_81_86();
bool sub_86_105();
bool sub_89_95();
bool sub_95_104();
bool sub_96_100();
bool sub_100_103();
bool sub_106_130();
bool sub_108_112();
bool sub_112_129();
bool sub_113_127();
bool sub_116_123();
bool sub_123_126();
bool sub_127_128();
bool sub_130_146();
bool sub_132_136();
bool sub_136_145();
bool sub_137_143();
bool sub_143_144();
bool sub_146_154();
bool sub_148_149();
bool sub_149_153();
bool sub_150_151();
bool sub_151_152();
bool sub_154_161();
bool sub_161_167();
bool sub_167_4096();

bool exec_shader() {
    sub_167_4096();
    return true;
}

bool sub_0_19() {
    uint jmp_to = 0u;
    while (true) {
        switch (jmp_to) {
        case 0u: {
            // 0: dp3
            reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
            // 1: dp3
            reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
            // 2: dp3
            reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
            // 3: dp3
            reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
            // 4: dp3
            reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
            // 5: rsq
            reg_tmp6.x = rsq_s(reg_tmp6.x);
            // 6: rsq
            reg_tmp7.x = rsq_s(reg_tmp7.x);
            // 7: mul
            reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 8: mul
            reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 9: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 10: add
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            // 11: mul
            reg_tmp4 = mul_s(uniforms.f[94].xxxx, reg_tmp4);
            // 12: cmp
            conditional_code = greaterThanEqual(uniforms.f[93].xx, reg_tmp4.xx);
            // 13: rsq
            reg_tmp4 = vec4(rsq_s(reg_tmp4.x));
            // 14: mul
            reg_tmp5 = mul_s(uniforms.f[94].xxxx, reg_tmp14);
            // 15: jmpc
            if (conditional_code.x) {
                { jmp_to = 18u; break; }
            }
            // 16: rcp
            reg_tmp0.z = rcp_s(reg_tmp4.x);
            // 17: mul
            reg_tmp0.xy = (mul_s(reg_tmp5, reg_tmp4)).xy;
        }
        case 18u: {
            // 18: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_19_29() {
    // 19: mova
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    // 20: nop
    // 21: dp4
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    // 22: dp4
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    // 23: dp4
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    // 24: dp3
    reg_tmp4.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    // 25: dp3
    reg_tmp4.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    // 26: dp3
    reg_tmp4.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    // 27: mad
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 28: mad
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_29_79() {
    // 29: mov
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    // 30: mov
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    // 31: mov
    reg_tmp13.xyz = (vs_in_reg2).xyz;
    // 32: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 33: ifu
    if (uniforms.b[0]) {
        sub_34_52();
    } else {
        sub_52_60();
    }
    // 60: dp3
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    // 61: dp3
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    // 62: dp3
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    // 63: call
    {
        sub_0_19();
    }
    // 64: dp4
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    // 65: dp4
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    // 66: dp4
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    // 67: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 68: mov
    vs_out_attr2 = -reg_tmp15;
    // 69: dp4
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    // 70: dp4
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    // 71: dp4
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    // 72: dp4
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    // 73: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 74: mul
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    // 75: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 76: ifc
    if (all(conditional_code)) {
        sub_77_78();
    }
    // 78: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_34_52() {
    // 34: mov
    reg_tmp7 = uniforms.f[93].xxxx;
    // 35: mov
    reg_tmp12 = uniforms.f[93].xxxx;
    // 36: mul
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    // 37: cmp
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    // 38: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 39: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    // 40: call
    {
        sub_19_29();
    }
    // 41: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 42: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    // 43: call
    {
        sub_19_29();
    }
    // 44: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 45: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    // 46: call
    {
        sub_19_29();
    }
    // 47: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 48: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    // 49: call
    {
        sub_19_29();
    }
    // 50: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 51: mov
    reg_tmp10 = reg_tmp7;
    return false;
}
bool sub_52_60() {
    // 52: mov
    reg_tmp7 = reg_tmp15;
    // 53: dp4
    reg_tmp10.x = dot_s(uniforms.f[10], reg_tmp7);
    // 54: dp4
    reg_tmp10.y = dot_s(uniforms.f[11], reg_tmp7);
    // 55: dp4
    reg_tmp10.z = dot_s(uniforms.f[12], reg_tmp7);
    // 56: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 57: dp3
    reg_tmp12.x = dot_3(uniforms.f[10].xyz, reg_tmp14.xyz);
    // 58: dp3
    reg_tmp12.y = dot_3(uniforms.f[11].xyz, reg_tmp14.xyz);
    // 59: dp3
    reg_tmp12.z = dot_3(uniforms.f[12].xyz, reg_tmp14.xyz);
    return false;
}
bool sub_77_78() {
    // 77: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_79_106() {
    // 79: mov
    reg_tmp0.xy = (uniforms.f[0].xxxx).xy;
    // 80: ifu
    if (uniforms.b[2]) {
        sub_81_86();
    } else {
        sub_86_105();
    }
    // 105: nop
    return false;
}
bool sub_81_86() {
    // 81: call
    {
        sub_146_154();
    }
    // 82: dp4
    reg_tmp3.x = dot_s(uniforms.f[1].xywz, reg_tmp6);
    // 83: dp4
    reg_tmp3.y = dot_s(uniforms.f[2].xywz, reg_tmp6);
    // 84: mov
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    // 85: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_86_105() {
    // 86: cmp
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    // 87: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 88: ifc
    if (all(not(conditional_code))) {
        sub_89_95();
    } else {
        sub_95_104();
    }
    // 104: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_89_95() {
    // 89: mov
    reg_tmp6 = reg_tmp10;
    // 90: dp4
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    // 91: dp4
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    // 92: dp4
    reg_tmp3.z = dot_s(uniforms.f[3], reg_tmp6);
    // 93: mul
    reg_tmp0.xy = (mul_s(uniforms.f[9].xyyy, reg_tmp3.zzzz)).xy;
    // 94: add
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_95_104() {
    // 95: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_96_100();
    } else {
        sub_100_103();
    }
    // 103: nop
    return false;
}
bool sub_96_100() {
    // 96: call
    {
        sub_154_161();
    }
    // 97: dp3
    reg_tmp3.x = dot_3(uniforms.f[1].xyz, reg_tmp6.xyz);
    // 98: dp3
    reg_tmp3.y = dot_3(uniforms.f[2].xyz, reg_tmp6.xyz);
    // 99: dp3
    reg_tmp3.z = dot_3(uniforms.f[3].xyz, reg_tmp6.xyz);
    return false;
}
bool sub_100_103() {
    // 100: call
    {
        sub_161_167();
    }
    // 101: dp4
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    // 102: dp4
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    return false;
}
bool sub_106_130() {
    // 106: mov
    reg_tmp0.xy = (uniforms.f[0].yyyy).xy;
    // 107: ifu
    if (uniforms.b[3]) {
        sub_108_112();
    } else {
        sub_112_129();
    }
    // 129: nop
    return false;
}
bool sub_108_112() {
    // 108: call
    {
        sub_146_154();
    }
    // 109: dp4
    reg_tmp4.x = dot_s(uniforms.f[4].xywz, reg_tmp6);
    // 110: dp4
    reg_tmp4.y = dot_s(uniforms.f[5].xywz, reg_tmp6);
    // 111: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_112_129() {
    // 112: ifu
    if (uniforms.b[5]) {
        sub_113_127();
    } else {
        sub_127_128();
    }
    // 128: nop
    return false;
}
bool sub_113_127() {
    // 113: cmp
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    // 114: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 115: ifc
    if (all(not(conditional_code))) {
        sub_116_123();
    } else {
        sub_123_126();
    }
    // 126: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_116_123() {
    // 116: mov
    reg_tmp6 = reg_tmp10;
    // 117: dp4
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    // 118: dp4
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    // 119: dp4
    reg_tmp4.z = dot_s(uniforms.f[6], reg_tmp6);
    // 120: rcp
    reg_tmp6.w = rcp_s(reg_tmp4.z);
    // 121: mul
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    // 122: add
    reg_tmp4.xy = (uniforms.f[9].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_123_126() {
    // 123: call
    {
        sub_161_167();
    }
    // 124: dp4
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    // 125: dp4
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    return false;
}
bool sub_127_128() {
    // 127: mov
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_130_146() {
    // 130: mov
    reg_tmp0.xy = (uniforms.f[0].zzzz).xy;
    // 131: ifu
    if (uniforms.b[4]) {
        sub_132_136();
    } else {
        sub_136_145();
    }
    // 145: nop
    return false;
}
bool sub_132_136() {
    // 132: call
    {
        sub_146_154();
    }
    // 133: dp4
    reg_tmp5.x = dot_s(uniforms.f[7].xywz, reg_tmp6);
    // 134: dp4
    reg_tmp5.y = dot_s(uniforms.f[8].xywz, reg_tmp6);
    // 135: mov
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_136_145() {
    // 136: ifu
    if (uniforms.b[6]) {
        sub_137_143();
    } else {
        sub_143_144();
    }
    // 144: nop
    return false;
}
bool sub_137_143() {
    // 137: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 138: mov
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    // 139: call
    {
        sub_161_167();
    }
    // 140: dp4
    reg_tmp5.x = dot_s(uniforms.f[7], reg_tmp6);
    // 141: dp4
    reg_tmp5.y = dot_s(uniforms.f[8], reg_tmp6);
    // 142: mov
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_143_144() {
    // 143: mov
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
bool sub_146_154() {
    // 146: cmp
    conditional_code = equal(uniforms.f[93].yz, reg_tmp0.xy);
    // 147: ifc
    if (all(not(conditional_code))) {
        sub_148_149();
    } else {
        sub_149_153();
    }
    // 153: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_148_149() {
    // 148: mov
    reg_tmp6.xy = (vs_in_reg4.xyyy).xy;
    return false;
}
bool sub_149_153() {
    // 149: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_150_151();
    } else {
        sub_151_152();
    }
    // 152: nop
    return false;
}
bool sub_150_151() {
    // 150: mov
    reg_tmp6.xy = (vs_in_reg5.xyyy).xy;
    return false;
}
bool sub_151_152() {
    // 151: mov
    reg_tmp6.xy = (vs_in_reg6.xyyy).xy;
    return false;
}
bool sub_154_161() {
    // 154: mov
    reg_tmp2 = -reg_tmp15;
    // 155: dp3
    reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
    // 156: rsq
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    // 157: mul
    reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
    // 158: dp3
    reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
    // 159: add
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    // 160: mad
    reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_161_167() {
    // 161: mov
    reg_tmp1 = reg_tmp14;
    // 162: dp3
    reg_tmp2.w = dot_3(reg_tmp1.xyz, reg_tmp1.xyz);
    // 163: rsq
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    // 164: mul
    reg_tmp1 = mul_s(reg_tmp1, reg_tmp2.wwww);
    // 165: mul
    reg_tmp1 = mul_s(uniforms.f[94].xxxx, reg_tmp1);
    // 166: add
    reg_tmp6.xy = (uniforms.f[94].xxxx + reg_tmp1.xyyy).xy;
    return false;
}
bool sub_167_4096() {
    // 167: call
    {
        sub_29_79();
    }
    // 168: mul
    reg_tmp2 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
    // 169: mov
    reg_tmp1.xyz = (uniforms.f[93].xxyx).xyz;
    // 170: dp3
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    // 171: dp3
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    // 172: dp3
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    // 173: mov
    reg_tmp14.w = (uniforms.f[93].xxxx).w;
    // 174: mov
    reg_tmp8 = reg_tmp14;
    // 175: dp4
    reg_tmp14.x = dot_s(reg_tmp8, reg_tmp8);
    // 176: rsq
    reg_tmp14.x = rsq_s(reg_tmp14.x);
    // 177: mul
    reg_tmp14 = mul_s(reg_tmp8, reg_tmp14.xxxx);
    // 178: dp3
    reg_tmp9.x = dot_3(reg_tmp14.xyz, reg_tmp1.xyz);
    // 179: max
    reg_tmp9.x = (max(uniforms.f[93].xxxx, reg_tmp9.xxxx)).x;
    // 180: min
    reg_tmp9.x = (min(uniforms.f[93].yyyy, reg_tmp9.xxxx)).x;
    // 181: add
    reg_tmp9.x = (uniforms.f[93].yyyy + -reg_tmp9.xxxx).x;
    // 182: log
    reg_tmp9.x = log2(reg_tmp9.x);
    // 183: mul
    reg_tmp9.x = (mul_s(uniforms.f[82].xxxx, reg_tmp9.xxxx)).x;
    // 184: exp
    reg_tmp9.x = exp2(reg_tmp9.x);
    // 185: mul
    reg_tmp2.w = (mul_s(uniforms.f[82].yyyy, reg_tmp9.xxxx)).w;
    // 186: mov
    vs_out_attr3 = reg_tmp2;
    // 187: call
    {
        sub_79_106();
    }
    // 188: call
    {
        sub_106_130();
    }
    // 189: call
    {
        sub_130_146();
    }
    // 190: end
    return true;
}
// reference: 36C80D5280324FF8, 1708AF5D88058ABC
// program: 1708AF5D88058ABC, AD7922A63ED54CA7, 8F138D56CDB426A3
// reference: E54BCAABB4B27DFE, 1708AF5D88058ABC
// reference: 9790BAAF28A228DF, 1708AF5D88058ABC
// shader: 8B30, C519A1630DEF8B1C

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(light_vector, normal)));
refl_value.g = (lut_scale_rg * LookupLightingLUTSigned(5, dot(light_vector, normal)));
refl_value.b = (lut_scale_rb * LookupLightingLUTSigned(4, dot(light_vector, normal)));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((secondary_fragment_color.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) - (texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: F20DB75BD5534DAF, C519A1630DEF8B1C
// program: 1708AF5D88058ABC, AD7922A63ED54CA7, C519A1630DEF8B1C
// reference: 44137D561C221AD9, 1708AF5D88058ABC
// shader: 8B30, 3215951A8C50D2A0

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0.0, 0.0, 1.0);
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(light_vector, normal)));
refl_value.g = (lut_scale_rg * LookupLightingLUTSigned(5, dot(light_vector, normal)));
refl_value.b = (lut_scale_rb * LookupLightingLUTSigned(4, dot(light_vector, normal)));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((secondary_fragment_color.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) - (texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) * (const_color[4].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 314FAD7D3936E34B, 3215951A8C50D2A0
// program: 1708AF5D88058ABC, AD7922A63ED54CA7, 3215951A8C50D2A0
// reference: 1A92D04A3EE0A2C3, 51F1565D56F357E9
// shader: 8B30, 3D318A15D5321B4C

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (texcolor1.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.r) * (texcolor1.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_2 = byteround(clamp((vec3(1.0) - combiner_buffer.rgb) * (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 6AF29988B26CD5C1, 3D318A15D5321B4C
// program: 51F1565D56F357E9, CEF02063E9A18B2F, 3D318A15D5321B4C
// reference: C91117B3E5590384, 51F1565D56F357E9
// shader: 8B31, B18CAF49E25618FC

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;
 out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}


#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define mul_3(x, y) mix(x * y, vec3(0.0), isnan(x * y))
#define fma_s(x, y, z) (mul_s(x, y) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(mul_3(x, y), vec3(1.0))

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_6();
bool sub_6_53();
bool sub_21_25();
bool sub_51_52();
bool sub_53_4096();

bool exec_shader() {
    sub_53_4096();
    return true;
}

bool sub_0_6() {
    // 0: mova
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    // 1: nop
    // 2: dp4
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    // 3: dp4
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    // 4: dp4
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    // 5: mad
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    return false;
}
bool sub_6_53() {
    // 6: mov
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    // 7: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 8: mov
    reg_tmp7 = uniforms.f[93].xxxx;
    // 9: mul
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    // 10: cmp
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    // 11: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 12: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    // 13: call
    {
        sub_0_6();
    }
    // 14: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 15: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    // 16: call
    {
        sub_0_6();
    }
    // 17: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 18: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    // 19: callc
    if (conditional_code.x) {
        sub_0_6();
    }
    // 20: ifu
    if (uniforms.b[11]) {
        sub_21_25();
    }
    // 25: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 26: mov
    reg_tmp10 = reg_tmp7;
    // 27: add
    reg_tmp6.y = (-uniforms.f[83].wwww + reg_tmp10.yyyy).y;
    // 28: mov
    reg_tmp9.xyz = (uniforms.f[83].xyzz).xyz;
    // 29: dp4
    reg_tmp7.x = dot_s(reg_tmp9.xyzz, reg_tmp9.xyzz);
    // 30: rsq
    reg_tmp7.x = rsq_s(reg_tmp7.x);
    // 31: mul
    reg_tmp7.xyz = (mul_s(reg_tmp9.xyzz, reg_tmp7.xxxx)).xyz;
    // 32: rcp
    reg_tmp8.y = rcp_s(-reg_tmp7.y);
    // 33: mul
    reg_tmp8.y = (mul_s(reg_tmp6.yyyy, reg_tmp8.yyyy)).y;
    // 34: mul
    reg_tmp7.xyz = (mul_s(reg_tmp7.xyzz, reg_tmp8.yyyy)).xyz;
    // 35: add
    reg_tmp10.xyz = (reg_tmp10.xyzz + reg_tmp7.xyzz).xyz;
    // 36: add
    reg_tmp10.y = (uniforms.f[94].xxxx + reg_tmp10.yyyy).y;
    // 37: dp4
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    // 38: dp4
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    // 39: dp4
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    // 40: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 41: mov
    vs_out_attr1 = uniforms.f[93].xxxx;
    // 42: mov
    vs_out_attr2 = -reg_tmp15;
    // 43: dp4
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    // 44: dp4
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    // 45: dp4
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    // 46: dp4
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    // 47: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 48: mul
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    // 49: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 50: ifc
    if (all(conditional_code)) {
        sub_51_52();
    }
    // 52: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_21_25() {
    // 21: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 22: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    // 23: callc
    if (conditional_code.y) {
        sub_0_6();
    }
    // 24: nop
    return false;
}
bool sub_51_52() {
    // 51: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_53_4096() {
    // 53: call
    {
        sub_6_53();
    }
    // 54: mov
    vs_out_attr4 = uniforms.f[93].xxxx;
    // 55: mov
    vs_out_attr5 = uniforms.f[93].xxxx;
    // 56: mov
    vs_out_attr6 = uniforms.f[93].xxxx;
    // 57: mov
    vs_out_attr3 = uniforms.f[93].xxxx;
    // 58: end
    return true;
}
// reference: 1530B407662B9F8E, B18CAF49E25618FC
// program: B18CAF49E25618FC, AD7922A63ED54CA7, B223506173AA3746
// shader: 8B30, 73516A70FF4C0B53

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = 2.0 * (texcolor2).rgb - 1.0;
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(normal, normalize(view))));
refl_value.g = (lut_scale_rg * LookupLightingLUTSigned(5, dot(normal, normalize(view))));
refl_value.b = (lut_scale_rb * LookupLightingLUTSigned(4, dot(normal, normalize(view))));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((secondary_fragment_color.r) * (texcolor2.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor0.rgb) * (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (1.0 - const_color[1].a) + (secondary_fragment_color.b) * (1.0 - (1.0 - const_color[1].a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor1.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((secondary_fragment_color.ggg) * (const_color[3].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((rounded_primary_color.aaa) * (const_color[4].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: B9C7C307E036E114, 73516A70FF4C0B53
// program: AC576E32BE8CFA08, AD7922A63ED54CA7, 73516A70FF4C0B53
// reference: 07F9F7A4E36437AB, 1F86C2CEA310ECA3
// shader: 8B30, C051D29E999B8E7B

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.r), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_2 = byteround(clamp((vec3(1.0) - combiner_buffer.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) + (combiner_buffer.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 7037091908602FB1, C051D29E999B8E7B
// program: 51F1565D56F357E9, CEF02063E9A18B2F, C051D29E999B8E7B
// reference: D47A305D38DD96EC, 1F86C2CEA310ECA3
// reference: D47A305D3135F6E9, 1F86C2CEA310ECA3
// reference: 07F9F7A4EA8C57AE, 1F86C2CEA310ECA3
// reference: 4C519F08922446B5, 7A6559ADA21E6F2E
// shader: 8B30, 793FBCF903F95A5E

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((vec3(1.0) - combiner_buffer.rgb) * (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 5F0AA39FC6A18B95, 793FBCF903F95A5E
// program: 93C50366EC4126B4, 5D764F9A6220D694, 793FBCF903F95A5E
// shader: 8B30, 15340764F8FFB342

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((vec3(1.0) - combiner_buffer.rgb) * (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: E7C524FDDAA13B38, 15340764F8FFB342
// program: 93C50366EC4126B4, 5D764F9A6220D694, 15340764F8FFB342
// reference: CD65FF5BF90F3F96, 457C73F53FB014B8
// reference: 050CCFD4CF7225CC, 458EEA119FC06605
// reference: D68F082DA02FE50E, 458EEA119FC06605
// reference: 519CD67D0EAF1185, 93C50366EC4126B4
// reference: 821F1184D516B0C2, 93C50366EC4126B4
// program: 93C50366EC4126B4, 5D764F9A6220D694, 51FFCF70C4C2996F
// reference: 73EE42182FC50C5D, 6038F426E3FD9783
// reference: A06D85E1F47CAD1A, 6038F426E3FD9783
// reference: A06D85E11B453E5B, 6038F426E3FD9783
// reference: CD65FF5B089F90FD, A5DC88B5E70699DD
// reference: 050CCFD43EE28AA7, B3A9ECAF0A8ECFA3
// reference: D68F082D51BF4A65, B3A9ECAF0A8ECFA3
// reference: 519CD67DFF3FBEEE, DEDDD3577BD6F4B8
// reference: 821F118424861FA9, DEDDD3577BD6F4B8
// program: 6038F426E3FD9783, AD7922A63ED54CA7, 640F42B61984D45F
// program: 6038F426E3FD9783, AD7922A63ED54CA7, 76F8F7F30B5408EF
// program: 6038F426E3FD9783, AD7922A63ED54CA7, AB775DCE00F096BB
// program: DEDDD3577BD6F4B8, 5D764F9A6220D694, 2B106C7690EA8110
// program: DEDDD3577BD6F4B8, 5D764F9A6220D694, 1910FBB60C4F0820
// reference: 821F1184CBBF8CE8, DEDDD3577BD6F4B8
// program: DEDDD3577BD6F4B8, 5D764F9A6220D694, C7939D9EA2B18A96
// program: DEDDD3577BD6F4B8, 5D764F9A6220D694, 8CA438A649CE933E
// shader: 8B31, F6AF8461302EECF6

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 3) in vec4 vs_in_reg3;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;
 out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}


#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_19();
bool sub_19_55();
bool sub_55_65();
bool sub_65_78();
bool sub_78_128();
bool sub_83_101();
bool sub_101_109();
bool sub_126_127();
bool sub_128_184();
bool sub_133_151();
bool sub_151_162();
bool sub_182_183();
bool sub_184_211();
bool sub_186_191();
bool sub_191_210();
bool sub_194_200();
bool sub_200_209();
bool sub_201_205();
bool sub_205_208();
bool sub_211_235();
bool sub_213_217();
bool sub_217_234();
bool sub_218_232();
bool sub_221_228();
bool sub_228_231();
bool sub_232_233();
bool sub_235_251();
bool sub_237_241();
bool sub_241_250();
bool sub_242_248();
bool sub_248_249();
bool sub_251_259();
bool sub_253_254();
bool sub_254_258();
bool sub_255_256();
bool sub_256_257();
bool sub_259_266();
bool sub_266_272();
bool sub_272_4096();
bool sub_273_275();
bool sub_275_277();
bool sub_278_285();
bool sub_285_286();

bool exec_shader() {
    sub_272_4096();
    return true;
}

bool sub_0_19() {
    uint jmp_to = 0u;
    while (true) {
        switch (jmp_to) {
        case 0u: {
            // 0: dp3
            reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
            // 1: dp3
            reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
            // 2: dp3
            reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
            // 3: dp3
            reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
            // 4: dp3
            reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
            // 5: rsq
            reg_tmp6.x = rsq_s(reg_tmp6.x);
            // 6: rsq
            reg_tmp7.x = rsq_s(reg_tmp7.x);
            // 7: mul
            reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 8: mul
            reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 9: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 10: add
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            // 11: mul
            reg_tmp4 = mul_s(uniforms.f[94].xxxx, reg_tmp4);
            // 12: cmp
            conditional_code = greaterThanEqual(uniforms.f[93].xx, reg_tmp4.xx);
            // 13: rsq
            reg_tmp4 = vec4(rsq_s(reg_tmp4.x));
            // 14: mul
            reg_tmp5 = mul_s(uniforms.f[94].xxxx, reg_tmp14);
            // 15: jmpc
            if (conditional_code.x) {
                { jmp_to = 18u; break; }
            }
            // 16: rcp
            reg_tmp0.z = rcp_s(reg_tmp4.x);
            // 17: mul
            reg_tmp0.xy = (mul_s(reg_tmp5, reg_tmp4)).xy;
        }
        case 18u: {
            // 18: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_19_55() {
    uint jmp_to = 19u;
    while (true) {
        switch (jmp_to) {
        case 19u: {
            // 19: dp3
            reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
            // 20: dp3
            reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
            // 21: rsq
            reg_tmp6.x = rsq_s(reg_tmp6.x);
            // 22: rsq
            reg_tmp7.x = rsq_s(reg_tmp7.x);
            // 23: mul
            reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 24: mul
            reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 25: mul
            reg_tmp13.xyz = (mul_s(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            // 26: mul
            reg_tmp11.xyz = (mul_s(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            // 27: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 28: mul
            reg_tmp13.xyz = (mul_s(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
            // 29: mul
            reg_tmp11.xyz = (mul_s(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
            // 30: mul
            reg_tmp5 = mul_s(reg_tmp14.yzxx, reg_tmp13.zxyy);
            // 31: mad
            reg_tmp5 = fma_s(-reg_tmp13.yzxx, reg_tmp14.zxyy, reg_tmp5);
            // 32: dp3
            reg_tmp5.w = dot_3(reg_tmp5.xyz, reg_tmp5.xyz);
            // 33: rsq
            reg_tmp5.w = rsq_s(reg_tmp5.w);
            // 34: mul
            reg_tmp5 = mul_s(reg_tmp5, reg_tmp5.wwww);
            // 35: add
            reg_tmp6.w = (reg_tmp14.zzzz + reg_tmp5.yyyy).w;
            // 36: mul
            reg_tmp13 = mul_s(reg_tmp5.yzxx, reg_tmp14.zxyy);
            // 37: mad
            reg_tmp13 = fma_s(-reg_tmp14.yzxx, reg_tmp5.zxyy, reg_tmp13);
            // 38: add
            reg_tmp6.w = (reg_tmp13.xxxx + reg_tmp6).w;
            // 39: mov
            reg_tmp13.w = (reg_tmp5.zzzz).w;
            // 40: mov
            reg_tmp5.z = (reg_tmp13.xxxx).z;
            // 41: add
            reg_tmp6.w = (uniforms.f[93].yyyy + reg_tmp6).w;
            // 42: mov
            reg_tmp14.w = (reg_tmp5.xxxx).w;
            // 43: mov
            reg_tmp5.x = (reg_tmp14.zzzz).x;
            // 44: cmp
            conditional_code = lessThan(uniforms.f[94].zz, reg_tmp6.ww);
            // 45: mov
            reg_tmp6.x = (uniforms.f[93].yyyy).x;
            // 46: mov
            reg_tmp6.y = (-uniforms.f[93].yyyy).y;
            // 47: jmpc
            if (!conditional_code.x) {
                { jmp_to = 54u; break; }
            }
            // 48: add
            reg_tmp7.xz = (reg_tmp13.wwyy + -reg_tmp14.yyww).xz;
            // 49: add
            reg_tmp7.y = (reg_tmp14.xxxx + -reg_tmp13.zzzz).y;
            // 50: mov
            reg_tmp7.w = (reg_tmp6).w;
            // 51: dp4
            reg_tmp6 = vec4(dot_s(reg_tmp7, reg_tmp7));
            // 52: rsq
            reg_tmp6 = vec4(rsq_s(reg_tmp6.x));
            // 53: mul
            reg_tmp0 = mul_s(reg_tmp7, reg_tmp6);
        }
        case 54u: {
            // 54: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_55_65() {
    // 55: mova
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    // 56: nop
    // 57: dp4
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    // 58: dp4
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    // 59: dp4
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    // 60: dp3
    reg_tmp4.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    // 61: dp3
    reg_tmp4.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    // 62: dp3
    reg_tmp4.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    // 63: mad
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 64: mad
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_65_78() {
    // 65: mova
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    // 66: dp4
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    // 67: dp4
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    // 68: dp4
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    // 69: dp3
    reg_tmp4.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    // 70: dp3
    reg_tmp4.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    // 71: dp3
    reg_tmp4.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    // 72: dp3
    reg_tmp5.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp13.xyz);
    // 73: dp3
    reg_tmp5.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp13.xyz);
    // 74: dp3
    reg_tmp5.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp13.xyz);
    // 75: mad
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 76: mad
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    // 77: mad
    reg_tmp11 = fma_s(reg_tmp1.wwww, reg_tmp5, reg_tmp11);
    return false;
}
bool sub_78_128() {
    // 78: mov
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    // 79: mov
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    // 80: mov
    reg_tmp13.xyz = (vs_in_reg2).xyz;
    // 81: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 82: ifu
    if (uniforms.b[0]) {
        sub_83_101();
    } else {
        sub_101_109();
    }
    // 109: dp3
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    // 110: dp3
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    // 111: dp3
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    // 112: call
    {
        sub_0_19();
    }
    // 113: dp4
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    // 114: dp4
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    // 115: dp4
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    // 116: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 117: mov
    vs_out_attr2 = -reg_tmp15;
    // 118: dp4
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    // 119: dp4
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    // 120: dp4
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    // 121: dp4
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    // 122: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 123: mul
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    // 124: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 125: ifc
    if (all(conditional_code)) {
        sub_126_127();
    }
    // 127: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_83_101() {
    // 83: mov
    reg_tmp7 = uniforms.f[93].xxxx;
    // 84: mov
    reg_tmp12 = uniforms.f[93].xxxx;
    // 85: mul
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    // 86: cmp
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    // 87: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 88: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    // 89: call
    {
        sub_55_65();
    }
    // 90: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 91: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    // 92: call
    {
        sub_55_65();
    }
    // 93: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 94: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    // 95: call
    {
        sub_55_65();
    }
    // 96: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 97: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    // 98: call
    {
        sub_55_65();
    }
    // 99: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 100: mov
    reg_tmp10 = reg_tmp7;
    return false;
}
bool sub_101_109() {
    // 101: mov
    reg_tmp7 = reg_tmp15;
    // 102: dp4
    reg_tmp10.x = dot_s(uniforms.f[10], reg_tmp7);
    // 103: dp4
    reg_tmp10.y = dot_s(uniforms.f[11], reg_tmp7);
    // 104: dp4
    reg_tmp10.z = dot_s(uniforms.f[12], reg_tmp7);
    // 105: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 106: dp3
    reg_tmp12.x = dot_3(uniforms.f[10].xyz, reg_tmp14.xyz);
    // 107: dp3
    reg_tmp12.y = dot_3(uniforms.f[11].xyz, reg_tmp14.xyz);
    // 108: dp3
    reg_tmp12.z = dot_3(uniforms.f[12].xyz, reg_tmp14.xyz);
    return false;
}
bool sub_126_127() {
    // 126: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_128_184() {
    // 128: mov
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    // 129: mov
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    // 130: mov
    reg_tmp13.xyz = (vs_in_reg2).xyz;
    // 131: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 132: ifu
    if (uniforms.b[0]) {
        sub_133_151();
    } else {
        sub_151_162();
    }
    // 162: dp3
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    // 163: dp3
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    // 164: dp3
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    // 165: dp3
    reg_tmp13.x = dot_3(uniforms.f[90].xyz, reg_tmp11.xyz);
    // 166: dp3
    reg_tmp13.y = dot_3(uniforms.f[91].xyz, reg_tmp11.xyz);
    // 167: dp3
    reg_tmp13.z = dot_3(uniforms.f[92].xyz, reg_tmp11.xyz);
    // 168: call
    {
        sub_19_55();
    }
    // 169: dp4
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    // 170: dp4
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    // 171: dp4
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    // 172: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 173: mov
    vs_out_attr2 = -reg_tmp15;
    // 174: dp4
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    // 175: dp4
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    // 176: dp4
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    // 177: dp4
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    // 178: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 179: mul
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    // 180: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 181: ifc
    if (all(conditional_code)) {
        sub_182_183();
    }
    // 183: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_133_151() {
    // 133: mov
    reg_tmp7 = uniforms.f[93].xxxx;
    // 134: mov
    reg_tmp12 = uniforms.f[93].xxxx;
    // 135: mul
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    // 136: cmp
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    // 137: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 138: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    // 139: call
    {
        sub_65_78();
    }
    // 140: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 141: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    // 142: call
    {
        sub_65_78();
    }
    // 143: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 144: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    // 145: call
    {
        sub_65_78();
    }
    // 146: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 147: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    // 148: call
    {
        sub_65_78();
    }
    // 149: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 150: mov
    reg_tmp10 = reg_tmp7;
    return false;
}
bool sub_151_162() {
    // 151: mov
    reg_tmp7 = reg_tmp15;
    // 152: dp4
    reg_tmp10.x = dot_s(uniforms.f[10], reg_tmp7);
    // 153: dp4
    reg_tmp10.y = dot_s(uniforms.f[11], reg_tmp7);
    // 154: dp4
    reg_tmp10.z = dot_s(uniforms.f[12], reg_tmp7);
    // 155: mov
    reg_tmp10.w = (uniforms.f[93].yyyy).w;
    // 156: dp3
    reg_tmp12.x = dot_3(uniforms.f[10].xyz, reg_tmp14.xyz);
    // 157: dp3
    reg_tmp12.y = dot_3(uniforms.f[11].xyz, reg_tmp14.xyz);
    // 158: dp3
    reg_tmp12.z = dot_3(uniforms.f[12].xyz, reg_tmp14.xyz);
    // 159: dp3
    reg_tmp11.x = dot_3(uniforms.f[10].xyz, reg_tmp13.xyz);
    // 160: dp3
    reg_tmp11.y = dot_3(uniforms.f[11].xyz, reg_tmp13.xyz);
    // 161: dp3
    reg_tmp11.z = dot_3(uniforms.f[12].xyz, reg_tmp13.xyz);
    return false;
}
bool sub_182_183() {
    // 182: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_184_211() {
    // 184: mov
    reg_tmp0.xy = (uniforms.f[0].xxxx).xy;
    // 185: ifu
    if (uniforms.b[2]) {
        sub_186_191();
    } else {
        sub_191_210();
    }
    // 210: nop
    return false;
}
bool sub_186_191() {
    // 186: call
    {
        sub_251_259();
    }
    // 187: dp4
    reg_tmp3.x = dot_s(uniforms.f[1].xywz, reg_tmp6);
    // 188: dp4
    reg_tmp3.y = dot_s(uniforms.f[2].xywz, reg_tmp6);
    // 189: mov
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    // 190: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_191_210() {
    // 191: cmp
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    // 192: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 193: ifc
    if (all(not(conditional_code))) {
        sub_194_200();
    } else {
        sub_200_209();
    }
    // 209: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_194_200() {
    // 194: mov
    reg_tmp6 = reg_tmp10;
    // 195: dp4
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    // 196: dp4
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    // 197: dp4
    reg_tmp3.z = dot_s(uniforms.f[3], reg_tmp6);
    // 198: mul
    reg_tmp0.xy = (mul_s(uniforms.f[9].xyyy, reg_tmp3.zzzz)).xy;
    // 199: add
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_200_209() {
    // 200: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_201_205();
    } else {
        sub_205_208();
    }
    // 208: nop
    return false;
}
bool sub_201_205() {
    // 201: call
    {
        sub_259_266();
    }
    // 202: dp3
    reg_tmp3.x = dot_3(uniforms.f[1].xyz, reg_tmp6.xyz);
    // 203: dp3
    reg_tmp3.y = dot_3(uniforms.f[2].xyz, reg_tmp6.xyz);
    // 204: dp3
    reg_tmp3.z = dot_3(uniforms.f[3].xyz, reg_tmp6.xyz);
    return false;
}
bool sub_205_208() {
    // 205: call
    {
        sub_266_272();
    }
    // 206: dp4
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    // 207: dp4
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    return false;
}
bool sub_211_235() {
    // 211: mov
    reg_tmp0.xy = (uniforms.f[0].yyyy).xy;
    // 212: ifu
    if (uniforms.b[3]) {
        sub_213_217();
    } else {
        sub_217_234();
    }
    // 234: nop
    return false;
}
bool sub_213_217() {
    // 213: call
    {
        sub_251_259();
    }
    // 214: dp4
    reg_tmp4.x = dot_s(uniforms.f[4].xywz, reg_tmp6);
    // 215: dp4
    reg_tmp4.y = dot_s(uniforms.f[5].xywz, reg_tmp6);
    // 216: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_217_234() {
    // 217: ifu
    if (uniforms.b[5]) {
        sub_218_232();
    } else {
        sub_232_233();
    }
    // 233: nop
    return false;
}
bool sub_218_232() {
    // 218: cmp
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    // 219: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 220: ifc
    if (all(not(conditional_code))) {
        sub_221_228();
    } else {
        sub_228_231();
    }
    // 231: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_221_228() {
    // 221: mov
    reg_tmp6 = reg_tmp10;
    // 222: dp4
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    // 223: dp4
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    // 224: dp4
    reg_tmp4.z = dot_s(uniforms.f[6], reg_tmp6);
    // 225: rcp
    reg_tmp6.w = rcp_s(reg_tmp4.z);
    // 226: mul
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    // 227: add
    reg_tmp4.xy = (uniforms.f[9].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_228_231() {
    // 228: call
    {
        sub_266_272();
    }
    // 229: dp4
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    // 230: dp4
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    return false;
}
bool sub_232_233() {
    // 232: mov
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_235_251() {
    // 235: mov
    reg_tmp0.xy = (uniforms.f[0].zzzz).xy;
    // 236: ifu
    if (uniforms.b[4]) {
        sub_237_241();
    } else {
        sub_241_250();
    }
    // 250: nop
    return false;
}
bool sub_237_241() {
    // 237: call
    {
        sub_251_259();
    }
    // 238: dp4
    reg_tmp5.x = dot_s(uniforms.f[7].xywz, reg_tmp6);
    // 239: dp4
    reg_tmp5.y = dot_s(uniforms.f[8].xywz, reg_tmp6);
    // 240: mov
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_241_250() {
    // 241: ifu
    if (uniforms.b[6]) {
        sub_242_248();
    } else {
        sub_248_249();
    }
    // 249: nop
    return false;
}
bool sub_242_248() {
    // 242: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 243: mov
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    // 244: call
    {
        sub_266_272();
    }
    // 245: dp4
    reg_tmp5.x = dot_s(uniforms.f[7], reg_tmp6);
    // 246: dp4
    reg_tmp5.y = dot_s(uniforms.f[8], reg_tmp6);
    // 247: mov
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_248_249() {
    // 248: mov
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
bool sub_251_259() {
    // 251: cmp
    conditional_code = equal(uniforms.f[93].yz, reg_tmp0.xy);
    // 252: ifc
    if (all(not(conditional_code))) {
        sub_253_254();
    } else {
        sub_254_258();
    }
    // 258: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_253_254() {
    // 253: mov
    reg_tmp6.xy = (vs_in_reg4.xyyy).xy;
    return false;
}
bool sub_254_258() {
    // 254: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_255_256();
    } else {
        sub_256_257();
    }
    // 257: nop
    return false;
}
bool sub_255_256() {
    // 255: mov
    reg_tmp6.xy = (vs_in_reg5.xyyy).xy;
    return false;
}
bool sub_256_257() {
    // 256: mov
    reg_tmp6.xy = (vs_in_reg6.xyyy).xy;
    return false;
}
bool sub_259_266() {
    // 259: mov
    reg_tmp2 = -reg_tmp15;
    // 260: dp3
    reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
    // 261: rsq
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    // 262: mul
    reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
    // 263: dp3
    reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
    // 264: add
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    // 265: mad
    reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_266_272() {
    // 266: mov
    reg_tmp1 = reg_tmp14;
    // 267: dp3
    reg_tmp2.w = dot_3(reg_tmp1.xyz, reg_tmp1.xyz);
    // 268: rsq
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    // 269: mul
    reg_tmp1 = mul_s(reg_tmp1, reg_tmp2.wwww);
    // 270: mul
    reg_tmp1 = mul_s(uniforms.f[94].xxxx, reg_tmp1);
    // 271: add
    reg_tmp6.xy = (uniforms.f[94].xxxx + reg_tmp1.xyyy).xy;
    return false;
}
bool sub_272_4096() {
    // 272: ifu
    if (uniforms.b[10]) {
        sub_273_275();
    } else {
        sub_275_277();
    }
    // 277: ifu
    if (uniforms.b[1]) {
        sub_278_285();
    } else {
        sub_285_286();
    }
    // 286: mov
    vs_out_attr3 = reg_tmp2;
    // 287: call
    {
        sub_184_211();
    }
    // 288: call
    {
        sub_211_235();
    }
    // 289: call
    {
        sub_235_251();
    }
    // 290: end
    return true;
}
bool sub_273_275() {
    // 273: call
    {
        sub_128_184();
    }
    // 274: nop
    return false;
}
bool sub_275_277() {
    // 275: call
    {
        sub_78_128();
    }
    // 276: nop
    return false;
}
bool sub_278_285() {
    // 278: dp3
    reg_tmp0 = vec4(dot_3(uniforms.f[83].xyz, reg_tmp12.xyz));
    // 279: max
    reg_tmp0 = max(uniforms.f[93].xxxx, reg_tmp0);
    // 280: mul
    reg_tmp0 = mul_s(uniforms.f[84], reg_tmp0);
    // 281: add
    reg_tmp0 = uniforms.f[85] + reg_tmp0;
    // 282: mov
    reg_tmp0.w = (uniforms.f[93].yyyy).w;
    // 283: mul
    reg_tmp1 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
    // 284: mul
    reg_tmp2 = mul_s(reg_tmp0, reg_tmp1);
    return false;
}
bool sub_285_286() {
    // 285: mul
    reg_tmp2 = mul_s(uniforms.f[94].zzzz, vs_in_reg3);
    return false;
}
// reference: 73EE42188523FB90, F6AF8461302EECF6
// program: F6AF8461302EECF6, AD7922A63ED54CA7, 9D930D569CF26E15
// reference: 519CD67D862B7508, DEDDD3577BD6F4B8
// program: DEDDD3577BD6F4B8, 5D764F9A6220D694, A696A9DBBC1702B3
// reference: 821F1184B2AB470E, DEDDD3577BD6F4B8
// program: DEDDD3577BD6F4B8, 5D764F9A6220D694, 57D6B37A68031849
// program: 6038F426E3FD9783, AD7922A63ED54CA7, 1342087E86EF0022
// reference: A06D85E1D4DB2993, 6038F426E3FD9783
// program: 6038F426E3FD9783, AD7922A63ED54CA7, 7934A1C8FECBC53A
// reference: E447428B1F314CEC, 6038F426E3FD9783
// reference: 37C48572E42F6922, 6038F426E3FD9783
// reference: 37C485722BB17EEA, 6038F426E3FD9783
// reference: E447428BB5D7BB21, F6AF8461302EECF6
// reference: BF76358EB6DF35B9, DEDDD3577BD6F4B8
// program: 6038F426E3FD9783, AD7922A63ED54CA7, 84A82B5A25D98775
// reference: 4E876612E42F6922, 6038F426E3FD9783
// reference: 9D04A1EBB5D7BB21, F6AF8461302EECF6
// reference: 6CF5F277825F07BF, DEDDD3577BD6F4B8
// program: DEDDD3577BD6F4B8, 5D764F9A6220D694, 92EC4965A7E72BC2
// program: DEDDD3577BD6F4B8, 5D764F9A6220D694, 117DEA4BEBB32612
// program: DEDDD3577BD6F4B8, 5D764F9A6220D694, 7549E5EBA540C3DB
// program: 6038F426E3FD9783, AD7922A63ED54CA7, 0D8E56F4BBBDAC3D
// program: 6038F426E3FD9783, AD7922A63ED54CA7, 2332982C1E467B81
// program: 6038F426E3FD9783, AD7922A63ED54CA7, 713FE427C8E551A8
// reference: B67DEEB400693438, B3A9ECAF0A8ECFA3
// program: B3A9ECAF0A8ECFA3, AD7922A63ED54CA7, C4696593B92A7B00
// program: 6038F426E3FD9783, AD7922A63ED54CA7, 1385A2BC5FE5139F
// program: 6038F426E3FD9783, AD7922A63ED54CA7, C5861009B70D72DC
// program: 6038F426E3FD9783, AD7922A63ED54CA7, 41C6BA6661374393
// program: 6038F426E3FD9783, AD7922A63ED54CA7, 060DB6F1FDBE0C55
// program: 6038F426E3FD9783, AD7922A63ED54CA7, 583B52E0B4D4893D
// program: 6038F426E3FD9783, AD7922A63ED54CA7, 47C12CB4EFB88BF9
// shader: 8B31, C6EC9230CB1FDB36

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}


#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_8();
bool sub_9_32();
bool sub_33_96();
bool sub_146_166();
bool sub_167_259();
bool sub_190_192();
bool sub_194_195();
bool sub_197_198();
bool sub_200_202();
bool sub_232_234();
bool sub_236_237();
bool sub_239_240();
bool sub_242_244();
bool sub_260_4096();
bool sub_287_288();
bool sub_288_289();

bool exec_shader() {
    sub_260_4096();
    return true;
}

bool sub_0_8() {
    // 0: mova
    address_registers.x = (ivec2(vs_in_reg0.zz)).x;
    // 1: mov
    reg_tmp10 = uniforms.f[0].xxxz;
    // 2: mov
    reg_tmp10.xy = (vs_in_reg0.xyyy).xy;
    // 3: mov
    reg_tmp11 = uniforms.f[0].xxxx;
    // 4: mov
    reg_tmp12 = uniforms.f[0].xxxx;
    // 5: mov
    reg_tmp13 = uniforms.f[0].zzzz;
    // 6: mov
    reg_tmp4 = uniforms.f[0].xxxx;
    // 7: mov
    reg_tmp5 = uniforms.f[0].xxxx;
    return false;
}
bool sub_9_32() {
    // 9: mov
    vs_out_attr0 = reg_tmp10;
    // 10: mul
    reg_tmp13 = mul_s(uniforms.f[82], reg_tmp13);
    // 11: mov
    vs_out_attr1 = reg_tmp13;
    // 12: add
    reg_tmp11.y = (uniforms.f[0].zzzz + -reg_tmp11.yyyy).y;
    // 13: add
    reg_tmp12.y = (uniforms.f[0].zzzz + -reg_tmp12.yyyy).y;
    // 14: mov
    reg_tmp14.y = (uniforms.f[81].wwww).y;
    // 15: mul
    reg_tmp14.x = (mul_s(uniforms.f[0].wwww, reg_tmp14.yyyy)).x;
    // 16: rcp
    reg_tmp2.x = rcp_s(reg_tmp14.x);
    // 17: mov
    reg_tmp14.z = (reg_tmp2.xxxx).z;
    // 18: add
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp11.xyyy).xy;
    // 19: mul
    reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    // 20: flr
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    // 21: mul
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    // 22: add
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    // 23: add
    reg_tmp11.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    // 24: add
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp12.xyyy).xy;
    // 25: mul
    reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    // 26: flr
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    // 27: mul
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    // 28: add
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    // 29: add
    reg_tmp12.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    // 30: mov
    vs_out_attr2 = reg_tmp11;
    // 31: mov
    vs_out_attr3 = reg_tmp12;
    return false;
}
bool sub_33_96() {
    // 33: mov
    reg_tmp6.xyz = (-reg_tmp0.xyzz).xyz;
    // 34: mov
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    // 35: rcp
    reg_tmp7.xyz = vec3(rcp_s(uniforms.f[81].y));
    // 36: madi
    reg_tmp8.xyz = (fma_s(reg_tmp6.xyzz, reg_tmp7.xyzz, uniforms.f[0].yyyy)).xyz;
    // 37: flr
    reg_tmp7.xyz = (floor(reg_tmp8.xyzz)).xyz;
    // 38: mad
    reg_tmp6.xyz = (fma_s(reg_tmp7.xyzz, -uniforms.f[81].yyyy, reg_tmp6.xyzz)).xyz;
    // 39: min
    reg_tmp6 = min(uniforms.f[81].xxxx, reg_tmp6);
    // 40: max
    reg_tmp6 = max(-uniforms.f[81].xxxx, reg_tmp6);
    // 41: mov
    reg_tmp2 = uniforms.f[95];
    // 42: mov
    reg_tmp3 = uniforms.f[94];
    // 43: mul
    reg_tmp1.z = (mul_s(reg_tmp6.xxxx, reg_tmp6.xxxx)).z;
    // 44: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 45: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 46: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 47: mov
    reg_tmp2 = uniforms.f[93];
    // 48: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 49: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 50: mul
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp6.xxxx)).y;
    // 51: mov
    reg_tmp4.x = (reg_tmp1.xxxx).x;
    // 52: mov
    reg_tmp5.x = (reg_tmp1.yyyy).x;
    // 53: mov
    reg_tmp2 = uniforms.f[95];
    // 54: mov
    reg_tmp3 = uniforms.f[94];
    // 55: mul
    reg_tmp1.z = (mul_s(reg_tmp6.yyyy, reg_tmp6.yyyy)).z;
    // 56: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 57: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 58: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 59: mov
    reg_tmp2 = uniforms.f[93];
    // 60: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 61: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 62: mul
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp6.yyyy)).y;
    // 63: mov
    reg_tmp4.y = (reg_tmp1.xxxx).y;
    // 64: mov
    reg_tmp5.y = (reg_tmp1.yyyy).y;
    // 65: mov
    reg_tmp2 = uniforms.f[95];
    // 66: mov
    reg_tmp3 = uniforms.f[94];
    // 67: mul
    reg_tmp1.z = (mul_s(reg_tmp6.zzzz, reg_tmp6.zzzz)).z;
    // 68: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 69: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 70: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 71: mov
    reg_tmp2 = uniforms.f[93];
    // 72: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 73: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 74: mul
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp6.zzzz)).y;
    // 75: mov
    reg_tmp4.z = (reg_tmp1.xxxx).z;
    // 76: mov
    reg_tmp5.z = (reg_tmp1.yyyy).z;
    // 77: mul
    reg_tmp2.x = (mul_s(reg_tmp4.yyyy, reg_tmp5.zzzz)).x;
    // 78: mul
    reg_tmp2.y = (mul_s(reg_tmp5.yyyy, reg_tmp5.zzzz)).y;
    // 79: mul
    reg_tmp6.x = (mul_s(reg_tmp4.yyyy, reg_tmp4.zzzz)).x;
    // 80: mov
    reg_tmp6.y = (reg_tmp5.zzzz).y;
    // 81: mul
    reg_tmp6.z = (mul_s(-reg_tmp5.yyyy, reg_tmp4.zzzz)).z;
    // 82: mov
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    // 83: mul
    reg_tmp7.x = (mul_s(-reg_tmp2.xxxx, reg_tmp4.xxxx)).x;
    // 84: mad
    reg_tmp7.x = (fma_s(reg_tmp5.yyyy, reg_tmp5.xxxx, reg_tmp7.xxxx)).x;
    // 85: mul
    reg_tmp7.y = (mul_s(reg_tmp4.zzzz, reg_tmp4.xxxx)).y;
    // 86: mul
    reg_tmp7.z = (mul_s(reg_tmp2.yyyy, reg_tmp4.xxxx)).z;
    // 87: mad
    reg_tmp7.z = (fma_s(reg_tmp4.yyyy, reg_tmp5.xxxx, reg_tmp7.zzzz)).z;
    // 88: mov
    reg_tmp7.w = (uniforms.f[0].xxxx).w;
    // 89: mul
    reg_tmp8.x = (mul_s(reg_tmp2.xxxx, reg_tmp5.xxxx)).x;
    // 90: mad
    reg_tmp8.x = (fma_s(reg_tmp5.yyyy, reg_tmp4.xxxx, reg_tmp8.xxxx)).x;
    // 91: mul
    reg_tmp8.y = (mul_s(-reg_tmp4.zzzz, reg_tmp5.xxxx)).y;
    // 92: mul
    reg_tmp8.z = (mul_s(-reg_tmp2.yyyy, reg_tmp5.xxxx)).z;
    // 93: mad
    reg_tmp8.z = (fma_s(reg_tmp4.yyyy, reg_tmp4.xxxx, reg_tmp8.zzzz)).z;
    // 94: mov
    reg_tmp8.w = (uniforms.f[0].xxxx).w;
    // 95: mov
    reg_tmp9 = uniforms.f[0].xxxz;
    return false;
}
bool sub_146_166() {
    // 146: mov
    reg_tmp2 = uniforms.f[90];
    // 147: mov
    reg_tmp3 = uniforms.f[91];
    // 148: mov
    reg_tmp4 = uniforms.f[92];
    // 149: mov
    reg_tmp5 = uniforms.f[0].xxxz;
    // 150: mul
    reg_tmp6 = mul_s(uniforms.f[86].xxxx, reg_tmp2);
    // 151: mad
    reg_tmp6 = fma_s(reg_tmp3, uniforms.f[86].yyyy, reg_tmp6);
    // 152: mad
    reg_tmp6 = fma_s(reg_tmp4, uniforms.f[86].zzzz, reg_tmp6);
    // 153: mad
    reg_tmp6 = fma_s(reg_tmp5, uniforms.f[86].wwww, reg_tmp6);
    // 154: mul
    reg_tmp7 = mul_s(uniforms.f[87].xxxx, reg_tmp2);
    // 155: mad
    reg_tmp7 = fma_s(reg_tmp3, uniforms.f[87].yyyy, reg_tmp7);
    // 156: mad
    reg_tmp7 = fma_s(reg_tmp4, uniforms.f[87].zzzz, reg_tmp7);
    // 157: mad
    reg_tmp7 = fma_s(reg_tmp5, uniforms.f[87].wwww, reg_tmp7);
    // 158: mul
    reg_tmp8 = mul_s(uniforms.f[88].xxxx, reg_tmp2);
    // 159: mad
    reg_tmp8 = fma_s(reg_tmp3, uniforms.f[88].yyyy, reg_tmp8);
    // 160: mad
    reg_tmp8 = fma_s(reg_tmp4, uniforms.f[88].zzzz, reg_tmp8);
    // 161: mad
    reg_tmp8 = fma_s(reg_tmp5, uniforms.f[88].wwww, reg_tmp8);
    // 162: mul
    reg_tmp9 = mul_s(uniforms.f[89].xxxx, reg_tmp2);
    // 163: mad
    reg_tmp9 = fma_s(reg_tmp3, uniforms.f[89].yyyy, reg_tmp9);
    // 164: mad
    reg_tmp9 = fma_s(reg_tmp4, uniforms.f[89].zzzz, reg_tmp9);
    // 165: mad
    reg_tmp9 = fma_s(reg_tmp5, uniforms.f[89].wwww, reg_tmp9);
    return false;
}
bool sub_167_259() {
    // 167: rcp
    reg_tmp2.x = rcp_s(uniforms.f[81].y);
    // 168: mul
    reg_tmp2.xy = (mul_s(uniforms.f[2 + address_registers.x].zwww, reg_tmp2.xxxx)).xy;
    // 169: add
    reg_tmp2.xy = (uniforms.f[0].yyyy + reg_tmp2.xyyy).xy;
    // 170: flr
    reg_tmp3.xy = (floor(reg_tmp2.xyyy)).xy;
    // 171: mul
    reg_tmp2.xy = (mul_s(uniforms.f[81].yyyy, reg_tmp3.xyyy)).xy;
    // 172: add
    reg_tmp2.xy = (uniforms.f[2 + address_registers.x].zwww + -reg_tmp2.xyyy).xy;
    // 173: min
    reg_tmp0.xy = (min(uniforms.f[81].xxxx, -reg_tmp2.xyyy)).xy;
    // 174: max
    reg_tmp0.xy = (max(-uniforms.f[81].xxxx, reg_tmp0.xyyy)).xy;
    // 175: mov
    reg_tmp2 = uniforms.f[95];
    // 176: mov
    reg_tmp3 = uniforms.f[94];
    // 177: mul
    reg_tmp1.z = (mul_s(reg_tmp0.xxxx, reg_tmp0.xxxx)).z;
    // 178: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 179: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 180: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 181: mov
    reg_tmp2 = uniforms.f[93];
    // 182: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 183: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 184: mul
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.xxxx)).y;
    // 185: mov
    reg_tmp5.x = (uniforms.f[5 + address_registers.x].wwww).x;
    // 186: mov
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    // 187: mov
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    // 188: cmp
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    // 189: ifc
    if (conditional_code.x) {
        sub_190_192();
    }
    // 192: cmp
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    // 193: ifc
    if (conditional_code.x) {
        sub_194_195();
    }
    // 195: cmp
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 196: ifc
    if (conditional_code.x) {
        sub_197_198();
    }
    // 198: cmp
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 199: ifc
    if (conditional_code.x) {
        sub_200_202();
    }
    // 202: mul
    reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    // 203: mad
    reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    // 204: mad
    reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    // 205: add
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    // 206: add
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    // 207: mov
    reg_tmp4.z = (uniforms.f[83].xxxx).z;
    // 208: mov
    reg_tmp4.w = (-uniforms.f[83].yyyy).w;
    // 209: madi
    reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[3 + address_registers.x].xyyy)).xy;
    // 210: mov
    reg_tmp4.z = (-uniforms.f[3 + address_registers.x].zzzz).z;
    // 211: mov
    reg_tmp4.w = (-uniforms.f[3 + address_registers.x].wwww).w;
    // 212: add
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    // 213: add
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    // 214: mad
    reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    // 215: mad
    reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    // 216: mov
    reg_tmp11.xy = (reg_tmp5.xyyy).xy;
    // 217: mov
    reg_tmp2 = uniforms.f[95];
    // 218: mov
    reg_tmp3 = uniforms.f[94];
    // 219: mul
    reg_tmp1.z = (mul_s(reg_tmp0.yyyy, reg_tmp0.yyyy)).z;
    // 220: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 221: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 222: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 223: mov
    reg_tmp2 = uniforms.f[93];
    // 224: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 225: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 226: mul
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.yyyy)).y;
    // 227: mov
    reg_tmp5.x = (uniforms.f[6 + address_registers.x].wwww).x;
    // 228: mov
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    // 229: mov
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    // 230: cmp
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    // 231: ifc
    if (conditional_code.x) {
        sub_232_234();
    }
    // 234: cmp
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    // 235: ifc
    if (conditional_code.x) {
        sub_236_237();
    }
    // 237: cmp
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 238: ifc
    if (conditional_code.x) {
        sub_239_240();
    }
    // 240: cmp
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 241: ifc
    if (conditional_code.x) {
        sub_242_244();
    }
    // 244: mul
    reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    // 245: mad
    reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    // 246: mad
    reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    // 247: add
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    // 248: add
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    // 249: mov
    reg_tmp4.z = (uniforms.f[83].zzzz).z;
    // 250: mov
    reg_tmp4.w = (-uniforms.f[83].wwww).w;
    // 251: madi
    reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[4 + address_registers.x].xyyy)).xy;
    // 252: mov
    reg_tmp4.z = (-uniforms.f[4 + address_registers.x].zzzz).z;
    // 253: mov
    reg_tmp4.w = (-uniforms.f[4 + address_registers.x].wwww).w;
    // 254: add
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    // 255: add
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    // 256: mad
    reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    // 257: mad
    reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    // 258: mov
    reg_tmp12.xy = (reg_tmp5.xyyy).xy;
    return false;
}
bool sub_190_192() {
    // 190: mov
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    // 191: mov
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_194_195() {
    // 194: mov
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_197_198() {
    // 197: mov
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_200_202() {
    // 200: mov
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    // 201: mov
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_232_234() {
    // 232: mov
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    // 233: mov
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_236_237() {
    // 236: mov
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_239_240() {
    // 239: mov
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_242_244() {
    // 242: mov
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    // 243: mov
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_260_4096() {
    // 260: call
    {
        sub_0_8();
    }
    // 261: add
    reg_tmp10.xy = (uniforms.f[84].xyyy + reg_tmp10.xyyy).xy;
    // 262: mul
    reg_tmp10.xy = (mul_s(uniforms.f[2 + address_registers.x].xyyy, reg_tmp10.xyyy)).xy;
    // 263: mov
    reg_tmp14 = reg_tmp10;
    // 264: mov
    reg_tmp0 = uniforms.f[7 + address_registers.x];
    // 265: call
    {
        sub_33_96();
    }
    // 266: dp4
    reg_tmp10.x = dot_s(reg_tmp14, reg_tmp6);
    // 267: dp4
    reg_tmp10.y = dot_s(reg_tmp14, reg_tmp7);
    // 268: dp4
    reg_tmp10.z = dot_s(reg_tmp14, reg_tmp8);
    // 269: dp4
    reg_tmp10.w = dot_s(reg_tmp14, reg_tmp9);
    // 270: mov
    reg_tmp6 = uniforms.f[8 + address_registers.x];
    // 271: mov
    reg_tmp7 = uniforms.f[9 + address_registers.x];
    // 272: mov
    reg_tmp8 = uniforms.f[10 + address_registers.x];
    // 273: mov
    reg_tmp9 = uniforms.f[0].xxxz;
    // 274: mov
    reg_tmp6.w = (uniforms.f[5 + address_registers.x].xxxx).w;
    // 275: mov
    reg_tmp7.w = (uniforms.f[5 + address_registers.x].yyyy).w;
    // 276: mov
    reg_tmp8.w = (uniforms.f[5 + address_registers.x].zzzz).w;
    // 277: dp4
    reg_tmp2.x = dot_s(reg_tmp10, reg_tmp6);
    // 278: dp4
    reg_tmp2.y = dot_s(reg_tmp10, reg_tmp7);
    // 279: dp4
    reg_tmp2.z = dot_s(reg_tmp10, reg_tmp8);
    // 280: dp4
    reg_tmp2.w = dot_s(reg_tmp10, reg_tmp9);
    // 281: mov
    reg_tmp10 = reg_tmp2;
    // 282: mov
    reg_tmp3.xyz = (uniforms.f[5 + address_registers.x].xyzz).xyz;
    // 283: add
    reg_tmp3.xyz = (uniforms.f[85].xyzz + -reg_tmp3.xyzz).xyz;
    // 284: dp3
    reg_tmp4.x = dot_3(reg_tmp3.xyz, reg_tmp3.xyz);
    // 285: cmp
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
    // 286: ifc
    if (conditional_code.x) {
        sub_287_288();
    } else {
        sub_288_289();
    }
    // 289: mul
    reg_tmp3.xyz = (mul_s(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
    // 290: mad
    reg_tmp10.xyz = (fma_s(reg_tmp3.xyzz, uniforms.f[84].zzzz, reg_tmp10.xyzz)).xyz;
    // 291: call
    {
        sub_146_166();
    }
    // 292: mov
    reg_tmp2 = reg_tmp10;
    // 293: dp4
    reg_tmp10.x = dot_s(reg_tmp2, reg_tmp6);
    // 294: dp4
    reg_tmp10.y = dot_s(reg_tmp2, reg_tmp7);
    // 295: dp4
    reg_tmp10.z = dot_s(reg_tmp2, reg_tmp8);
    // 296: dp4
    reg_tmp10.w = dot_s(reg_tmp2, reg_tmp9);
    // 297: mov
    reg_tmp2 = uniforms.f[1 + address_registers.x];
    // 298: max
    reg_tmp3 = max(uniforms.f[0].xxxx, reg_tmp2);
    // 299: min
    reg_tmp2 = min(uniforms.f[0].zzzz, reg_tmp3);
    // 300: mov
    reg_tmp13 = reg_tmp2;
    // 301: call
    {
        sub_167_259();
    }
    // 302: call
    {
        sub_9_32();
    }
    // 303: end
    return true;
}
bool sub_287_288() {
    // 287: mov
    reg_tmp4.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_288_289() {
    // 288: rsq
    reg_tmp4.x = rsq_s(reg_tmp4.x);
    return false;
}
// reference: E545D24961578BFB, C6EC9230CB1FDB36
// program: C6EC9230CB1FDB36, CEF02063E9A18B2F, 52F15AB03C873666
// reference: 519CD67D1AAF6F08, DEDDD3577BD6F4B8
// program: DEDDD3577BD6F4B8, 5D764F9A6220D694, 4AFCA8E6553DCB17
// reference: 821F1184C116CE4F, DEDDD3577BD6F4B8
// reference: 58970D47309D7489, B3A9ECAF0A8ECFA3
// shader: 8B31, 24A4FAE31D0E0CA7

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;
 out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}


#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_6();
bool sub_6_53();
bool sub_21_25();
bool sub_51_52();
bool sub_53_4096();

bool exec_shader() {
    sub_53_4096();
    return true;
}

bool sub_0_6() {
    // 0: mova
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    // 1: nop
    // 2: dp4
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    // 3: dp4
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    // 4: dp4
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    // 5: mad
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    return false;
}
bool sub_6_53() {
    // 6: mov
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    // 7: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 8: mov
    reg_tmp7 = uniforms.f[93].xxxx;
    // 9: mul
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    // 10: cmp
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    // 11: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 12: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    // 13: call
    {
        sub_0_6();
    }
    // 14: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 15: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    // 16: call
    {
        sub_0_6();
    }
    // 17: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 18: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    // 19: callc
    if (conditional_code.x) {
        sub_0_6();
    }
    // 20: ifu
    if (uniforms.b[11]) {
        sub_21_25();
    }
    // 25: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 26: mov
    reg_tmp10 = reg_tmp7;
    // 27: add
    reg_tmp6.y = (-uniforms.f[83].wwww + reg_tmp10.yyyy).y;
    // 28: mov
    reg_tmp9.xyz = (uniforms.f[83].xyzz).xyz;
    // 29: dp4
    reg_tmp7.x = dot_s(reg_tmp9.xyzz, reg_tmp9.xyzz);
    // 30: rsq
    reg_tmp7.x = rsq_s(reg_tmp7.x);
    // 31: mul
    reg_tmp7.xyz = (mul_s(reg_tmp9.xyzz, reg_tmp7.xxxx)).xyz;
    // 32: rcp
    reg_tmp8.y = rcp_s(-reg_tmp7.y);
    // 33: mul
    reg_tmp8.y = (mul_s(reg_tmp6.yyyy, reg_tmp8.yyyy)).y;
    // 34: mul
    reg_tmp7.xyz = (mul_s(reg_tmp7.xyzz, reg_tmp8.yyyy)).xyz;
    // 35: add
    reg_tmp10.xyz = (reg_tmp10.xyzz + reg_tmp7.xyzz).xyz;
    // 36: add
    reg_tmp10.y = (uniforms.f[94].xxxx + reg_tmp10.yyyy).y;
    // 37: dp4
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    // 38: dp4
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    // 39: dp4
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    // 40: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 41: mov
    vs_out_attr1 = uniforms.f[93].xxxx;
    // 42: mov
    vs_out_attr2 = reg_tmp15;
    // 43: dp4
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    // 44: dp4
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    // 45: dp4
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    // 46: dp4
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    // 47: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 48: mul
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    // 49: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 50: ifc
    if (all(conditional_code)) {
        sub_51_52();
    }
    // 52: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_21_25() {
    // 21: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 22: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    // 23: callc
    if (conditional_code.y) {
        sub_0_6();
    }
    // 24: nop
    return false;
}
bool sub_51_52() {
    // 51: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_53_4096() {
    // 53: call
    {
        sub_6_53();
    }
    // 54: mov
    vs_out_attr4 = uniforms.f[93].xxxx;
    // 55: mov
    vs_out_attr5 = uniforms.f[93].xxxx;
    // 56: mov
    vs_out_attr6 = uniforms.f[93].xxxx;
    // 57: mov
    vs_out_attr3 = uniforms.f[93].yyyy;
    // 58: end
    return true;
}
// reference: 9FD258F15734DBD8, 24A4FAE31D0E0CA7
// program: 24A4FAE31D0E0CA7, AD7922A63ED54CA7, B223506173AA3746
// reference: DD74429308FBB448, 7C60AA2AD49029B7
// shader: 8B31, 9D5547200C50254C

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;
 out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}


#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_19();
bool sub_19_29();
bool sub_29_51();
bool sub_51_65();
bool sub_65_116();
bool sub_88_92();
bool sub_114_115();
bool sub_116_156();
bool sub_133_137();
bool sub_154_155();
bool sub_156_183();
bool sub_158_163();
bool sub_163_182();
bool sub_166_172();
bool sub_172_181();
bool sub_173_177();
bool sub_177_180();
bool sub_183_207();
bool sub_185_189();
bool sub_189_206();
bool sub_190_204();
bool sub_193_200();
bool sub_200_203();
bool sub_204_205();
bool sub_207_223();
bool sub_209_213();
bool sub_213_222();
bool sub_214_220();
bool sub_220_221();
bool sub_223_231();
bool sub_225_226();
bool sub_226_230();
bool sub_227_228();
bool sub_228_229();
bool sub_231_238();
bool sub_238_244();
bool sub_244_288();
bool sub_264_270();
bool sub_271_278();
bool sub_279_287();
bool sub_288_4096();
bool sub_289_291();
bool sub_291_293();
bool sub_294_296();
bool sub_296_298();

bool exec_shader() {
    sub_288_4096();
    return true;
}

bool sub_0_19() {
    uint jmp_to = 0u;
    while (true) {
        switch (jmp_to) {
        case 0u: {
            // 0: dp3
            reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
            // 1: dp3
            reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
            // 2: dp3
            reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
            // 3: dp3
            reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
            // 4: dp3
            reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
            // 5: rsq
            reg_tmp6.x = rsq_s(reg_tmp6.x);
            // 6: rsq
            reg_tmp7.x = rsq_s(reg_tmp7.x);
            // 7: mul
            reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 8: mul
            reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 9: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 10: add
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            // 11: mul
            reg_tmp4 = mul_s(uniforms.f[94].xxxx, reg_tmp4);
            // 12: cmp
            conditional_code = greaterThanEqual(uniforms.f[93].xx, reg_tmp4.xx);
            // 13: rsq
            reg_tmp4 = vec4(rsq_s(reg_tmp4.x));
            // 14: mul
            reg_tmp5 = mul_s(uniforms.f[94].xxxx, reg_tmp14);
            // 15: jmpc
            if (conditional_code.x) {
                { jmp_to = 18u; break; }
            }
            // 16: rcp
            reg_tmp0.z = rcp_s(reg_tmp4.x);
            // 17: mul
            reg_tmp0.xy = (mul_s(reg_tmp5, reg_tmp4)).xy;
        }
        case 18u: {
            // 18: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_19_29() {
    // 19: mova
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    // 20: nop
    // 21: dp4
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    // 22: dp4
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    // 23: dp4
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    // 24: dp3
    reg_tmp4.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    // 25: dp3
    reg_tmp4.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    // 26: dp3
    reg_tmp4.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    // 27: mad
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 28: mad
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_29_51() {
    // 29: mova
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    // 30: nop
    // 31: dp4
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    // 32: dp4
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    // 33: dp4
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    // 34: mad
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 35: dp3
    reg_tmp3.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    // 36: dp3
    reg_tmp3.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    // 37: dp3
    reg_tmp3.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    // 38: mad
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp12);
    // 39: dp3
    reg_tmp3.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp13.xyz);
    // 40: dp3
    reg_tmp3.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp13.xyz);
    // 41: dp3
    reg_tmp3.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp13.xyz);
    // 42: mad
    reg_tmp11 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp11);
    // 43: dp3
    reg_tmp3.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp5.xyz);
    // 44: dp3
    reg_tmp3.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp5.xyz);
    // 45: dp3
    reg_tmp3.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp5.xyz);
    // 46: mad
    reg_tmp9 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp9);
    // 47: dp3
    reg_tmp3.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp6.xyz);
    // 48: dp3
    reg_tmp3.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp6.xyz);
    // 49: dp3
    reg_tmp3.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp6.xyz);
    // 50: mad
    reg_tmp8 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp8);
    return false;
}
bool sub_51_65() {
    // 51: mul
    reg_tmp0.xyz = (mul_s(reg_tmp9.yzxx, reg_tmp8.zxyy)).xyz;
    // 52: mad
    reg_tmp0.xyz = (fma_s(-reg_tmp8.yzxx, reg_tmp9.zxyy, reg_tmp0)).xyz;
    // 53: mov
    reg_tmp1 = uniforms.f[83];
    // 54: dp4
    reg_tmp2.x = dot_s(reg_tmp1.xyzz, reg_tmp1.xyzz);
    // 55: rsq
    reg_tmp2.x = rsq_s(reg_tmp2.x);
    // 56: mul
    reg_tmp2.xyz = (mul_s(reg_tmp1.xyzz, reg_tmp2.xxxx)).xyz;
    // 57: dp3
    reg_tmp1.x = dot_3(reg_tmp2.xyz, reg_tmp8.xyz);
    // 58: dp3
    reg_tmp1.y = dot_3(reg_tmp2.xyz, reg_tmp0.xyz);
    // 59: dp3
    reg_tmp1.z = dot_3(reg_tmp2.xyz, reg_tmp9.xyz);
    // 60: dp4
    reg_tmp2.x = dot_s(reg_tmp1.xyzz, reg_tmp1.xyzz);
    // 61: rsq
    reg_tmp2.x = rsq_s(reg_tmp2.x);
    // 62: mul
    reg_tmp2.xyz = (mul_s(reg_tmp1.xyzz, reg_tmp2.xxxx)).xyz;
    // 63: mov
    reg_tmp2.w = (uniforms.f[93].yyyy).w;
    // 64: mov
    vs_out_attr2 = reg_tmp2;
    return false;
}
bool sub_65_116() {
    // 65: mov
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    // 66: mov
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    // 67: mov
    reg_tmp13.xyz = (vs_in_reg2).xyz;
    // 68: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 69: mov
    reg_tmp5 = uniforms.f[93].xxyy;
    // 70: mov
    reg_tmp6 = uniforms.f[93].yxxy;
    // 71: mov
    reg_tmp7 = uniforms.f[93].xxxx;
    // 72: mov
    reg_tmp12 = uniforms.f[93].xxxx;
    // 73: mov
    reg_tmp11 = uniforms.f[93].xxxx;
    // 74: mov
    reg_tmp9 = uniforms.f[93].xxxx;
    // 75: mov
    reg_tmp8 = uniforms.f[93].xxxx;
    // 76: mul
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    // 77: cmp
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    // 78: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 79: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    // 80: call
    {
        sub_29_51();
    }
    // 81: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 82: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    // 83: call
    {
        sub_29_51();
    }
    // 84: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 85: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    // 86: callc
    if (conditional_code.x) {
        sub_29_51();
    }
    // 87: ifu
    if (uniforms.b[11]) {
        sub_88_92();
    }
    // 92: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 93: mov
    reg_tmp10 = reg_tmp7;
    // 94: dp3
    reg_tmp13.x = dot_3(uniforms.f[90].xyz, reg_tmp11.xyz);
    // 95: dp3
    reg_tmp13.y = dot_3(uniforms.f[91].xyz, reg_tmp11.xyz);
    // 96: dp3
    reg_tmp13.z = dot_3(uniforms.f[92].xyz, reg_tmp11.xyz);
    // 97: dp3
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    // 98: dp3
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    // 99: dp3
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    // 100: dp4
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    // 101: dp4
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    // 102: dp4
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    // 103: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 104: call
    {
        sub_51_65();
    }
    // 105: mov
    vs_out_attr1 = uniforms.f[93].xxxy;
    // 106: dp4
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    // 107: dp4
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    // 108: dp4
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    // 109: dp4
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    // 110: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 111: mul
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    // 112: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 113: ifc
    if (all(conditional_code)) {
        sub_114_115();
    }
    // 115: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_88_92() {
    // 88: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 89: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    // 90: callc
    if (conditional_code.y) {
        sub_29_51();
    }
    // 91: nop
    return false;
}
bool sub_114_115() {
    // 114: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_116_156() {
    // 116: mov
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    // 117: mov
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    // 118: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 119: mov
    reg_tmp7 = uniforms.f[93].xxxx;
    // 120: mov
    reg_tmp12 = uniforms.f[93].xxxx;
    // 121: mul
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    // 122: cmp
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    // 123: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 124: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    // 125: call
    {
        sub_19_29();
    }
    // 126: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 127: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    // 128: call
    {
        sub_19_29();
    }
    // 129: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 130: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    // 131: callc
    if (conditional_code.x) {
        sub_19_29();
    }
    // 132: ifu
    if (uniforms.b[11]) {
        sub_133_137();
    }
    // 137: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 138: mov
    reg_tmp10 = reg_tmp7;
    // 139: dp4
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    // 140: dp4
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    // 141: dp4
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    // 142: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 143: call
    {
        sub_0_19();
    }
    // 144: nop
    // 145: mov
    vs_out_attr2 = -reg_tmp15;
    // 146: dp4
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    // 147: dp4
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    // 148: dp4
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    // 149: dp4
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    // 150: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 151: mul
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    // 152: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 153: ifc
    if (all(conditional_code)) {
        sub_154_155();
    }
    // 155: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_133_137() {
    // 133: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 134: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    // 135: callc
    if (conditional_code.y) {
        sub_19_29();
    }
    // 136: nop
    return false;
}
bool sub_154_155() {
    // 154: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_156_183() {
    // 156: mov
    reg_tmp0.xy = (uniforms.f[0].xxxx).xy;
    // 157: ifu
    if (uniforms.b[2]) {
        sub_158_163();
    } else {
        sub_163_182();
    }
    // 182: nop
    return false;
}
bool sub_158_163() {
    // 158: call
    {
        sub_223_231();
    }
    // 159: dp4
    reg_tmp3.x = dot_s(uniforms.f[1].xywz, reg_tmp6);
    // 160: dp4
    reg_tmp3.y = dot_s(uniforms.f[2].xywz, reg_tmp6);
    // 161: mov
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    // 162: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_163_182() {
    // 163: cmp
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    // 164: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 165: ifc
    if (all(not(conditional_code))) {
        sub_166_172();
    } else {
        sub_172_181();
    }
    // 181: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_166_172() {
    // 166: mov
    reg_tmp6 = reg_tmp10;
    // 167: dp4
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    // 168: dp4
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    // 169: dp4
    reg_tmp3.z = dot_s(uniforms.f[3], reg_tmp6);
    // 170: mul
    reg_tmp0.xy = (mul_s(uniforms.f[9].xyyy, reg_tmp3.zzzz)).xy;
    // 171: add
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_172_181() {
    // 172: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_173_177();
    } else {
        sub_177_180();
    }
    // 180: nop
    return false;
}
bool sub_173_177() {
    // 173: call
    {
        sub_231_238();
    }
    // 174: dp3
    reg_tmp3.x = dot_3(uniforms.f[1].xyz, reg_tmp6.xyz);
    // 175: dp3
    reg_tmp3.y = dot_3(uniforms.f[2].xyz, reg_tmp6.xyz);
    // 176: dp3
    reg_tmp3.z = dot_3(uniforms.f[3].xyz, reg_tmp6.xyz);
    return false;
}
bool sub_177_180() {
    // 177: call
    {
        sub_238_244();
    }
    // 178: dp4
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    // 179: dp4
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    return false;
}
bool sub_183_207() {
    // 183: mov
    reg_tmp0.xy = (uniforms.f[0].yyyy).xy;
    // 184: ifu
    if (uniforms.b[3]) {
        sub_185_189();
    } else {
        sub_189_206();
    }
    // 206: nop
    return false;
}
bool sub_185_189() {
    // 185: call
    {
        sub_223_231();
    }
    // 186: dp4
    reg_tmp4.x = dot_s(uniforms.f[4].xywz, reg_tmp6);
    // 187: dp4
    reg_tmp4.y = dot_s(uniforms.f[5].xywz, reg_tmp6);
    // 188: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_189_206() {
    // 189: ifu
    if (uniforms.b[5]) {
        sub_190_204();
    } else {
        sub_204_205();
    }
    // 205: nop
    return false;
}
bool sub_190_204() {
    // 190: cmp
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    // 191: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 192: ifc
    if (all(not(conditional_code))) {
        sub_193_200();
    } else {
        sub_200_203();
    }
    // 203: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_193_200() {
    // 193: mov
    reg_tmp6 = reg_tmp10;
    // 194: dp4
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    // 195: dp4
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    // 196: dp4
    reg_tmp4.z = dot_s(uniforms.f[6], reg_tmp6);
    // 197: rcp
    reg_tmp6.w = rcp_s(reg_tmp4.z);
    // 198: mul
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    // 199: add
    reg_tmp4.xy = (uniforms.f[9].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_200_203() {
    // 200: call
    {
        sub_238_244();
    }
    // 201: dp4
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    // 202: dp4
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    return false;
}
bool sub_204_205() {
    // 204: mov
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_207_223() {
    // 207: mov
    reg_tmp0.xy = (uniforms.f[0].zzzz).xy;
    // 208: ifu
    if (uniforms.b[4]) {
        sub_209_213();
    } else {
        sub_213_222();
    }
    // 222: nop
    return false;
}
bool sub_209_213() {
    // 209: call
    {
        sub_223_231();
    }
    // 210: dp4
    reg_tmp5.x = dot_s(uniforms.f[7].xywz, reg_tmp6);
    // 211: dp4
    reg_tmp5.y = dot_s(uniforms.f[8].xywz, reg_tmp6);
    // 212: mov
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_213_222() {
    // 213: ifu
    if (uniforms.b[6]) {
        sub_214_220();
    } else {
        sub_220_221();
    }
    // 221: nop
    return false;
}
bool sub_214_220() {
    // 214: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 215: mov
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    // 216: call
    {
        sub_238_244();
    }
    // 217: dp4
    reg_tmp5.x = dot_s(uniforms.f[7], reg_tmp6);
    // 218: dp4
    reg_tmp5.y = dot_s(uniforms.f[8], reg_tmp6);
    // 219: mov
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_220_221() {
    // 220: mov
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
bool sub_223_231() {
    // 223: cmp
    conditional_code = equal(uniforms.f[93].yz, reg_tmp0.xy);
    // 224: ifc
    if (all(not(conditional_code))) {
        sub_225_226();
    } else {
        sub_226_230();
    }
    // 230: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_225_226() {
    // 225: mov
    reg_tmp6.xy = (vs_in_reg4.xyyy).xy;
    return false;
}
bool sub_226_230() {
    // 226: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_227_228();
    } else {
        sub_228_229();
    }
    // 229: nop
    return false;
}
bool sub_227_228() {
    // 227: mov
    reg_tmp6.xy = (vs_in_reg5.xyyy).xy;
    return false;
}
bool sub_228_229() {
    // 228: mov
    reg_tmp6.xy = (vs_in_reg6.xyyy).xy;
    return false;
}
bool sub_231_238() {
    // 231: mov
    reg_tmp2 = -reg_tmp15;
    // 232: dp3
    reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
    // 233: rsq
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    // 234: mul
    reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
    // 235: dp3
    reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
    // 236: add
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    // 237: mad
    reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_238_244() {
    // 238: mov
    reg_tmp1 = reg_tmp14;
    // 239: dp3
    reg_tmp2.w = dot_3(reg_tmp1.xyz, reg_tmp1.xyz);
    // 240: rsq
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    // 241: mul
    reg_tmp1 = mul_s(reg_tmp1, reg_tmp2.wwww);
    // 242: mul
    reg_tmp1 = mul_s(uniforms.f[94].xxxx, reg_tmp1);
    // 243: add
    reg_tmp6.xy = (uniforms.f[94].xxxx + reg_tmp1.xyyy).xy;
    return false;
}
bool sub_244_288() {
    // 244: mov
    reg_tmp1.xyz = (uniforms.f[93].xxyx).xyz;
    // 245: dp3
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    // 246: dp3
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    // 247: dp3
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    // 248: mov
    reg_tmp14.w = (uniforms.f[93].xxxx).w;
    // 249: mov
    reg_tmp8 = reg_tmp14;
    // 250: dp4
    reg_tmp14.x = dot_s(reg_tmp8, reg_tmp8);
    // 251: rsq
    reg_tmp14.x = rsq_s(reg_tmp14.x);
    // 252: mul
    reg_tmp14 = mul_s(reg_tmp8, reg_tmp14.xxxx);
    // 253: mov
    reg_tmp8 = uniforms.f[83];
    // 254: dp3
    reg_tmp6.x = dot_3(uniforms.f[90].xyz, reg_tmp8.xyz);
    // 255: dp3
    reg_tmp6.y = dot_3(uniforms.f[91].xyz, reg_tmp8.xyz);
    // 256: dp3
    reg_tmp6.z = dot_3(uniforms.f[92].xyz, reg_tmp8.xyz);
    // 257: add
    reg_tmp8.xyz = (reg_tmp6.xyzz + reg_tmp1.xyzz).xyz;
    // 258: mov
    reg_tmp8.w = (uniforms.f[93].xxxx).w;
    // 259: dp4
    reg_tmp0.x = dot_s(reg_tmp8, reg_tmp8);
    // 260: rsq
    reg_tmp0.x = rsq_s(reg_tmp0.x);
    // 261: mul
    reg_tmp0 = mul_s(reg_tmp8, reg_tmp0.xxxx);
    // 262: mov
    reg_tmp2 = uniforms.f[93].xxxx;
    // 263: ifu
    if (uniforms.b[9]) {
        sub_264_270();
    }
    // 270: ifu
    if (uniforms.b[7]) {
        sub_271_278();
    }
    // 278: ifu
    if (uniforms.b[8]) {
        sub_279_287();
    }
    // 287: mov
    vs_out_attr3 = reg_tmp2;
    return false;
}
bool sub_264_270() {
    // 264: dp3
    reg_tmp8.x = dot_3(reg_tmp14.xyz, -reg_tmp6.xyz);
    // 265: dp3
    reg_tmp8.y = dot_3(reg_tmp1.xyz, -reg_tmp6.xyz);
    // 266: max
    reg_tmp8 = max(uniforms.f[93].xxxx, reg_tmp8);
    // 267: mul
    reg_tmp8.y = (mul_s(uniforms.f[94].xxxx, reg_tmp8.yyyy)).y;
    // 268: add
    reg_tmp8.y = (uniforms.f[94].xxxx + reg_tmp8.yyyy).y;
    // 269: mul
    reg_tmp2.y = (mul_s(reg_tmp8.xxxx, reg_tmp8.yyyy)).y;
    return false;
}
bool sub_271_278() {
    // 271: dp3
    reg_tmp9.z = dot_3(reg_tmp14.xyz, reg_tmp0.xyz);
    // 272: max
    reg_tmp9.z = (max(uniforms.f[93].xxxx, reg_tmp9.zzzz)).z;
    // 273: min
    reg_tmp9.z = (min(uniforms.f[93].yyyy, reg_tmp9.zzzz)).z;
    // 274: log
    reg_tmp9.z = log2(reg_tmp9.z);
    // 275: mul
    reg_tmp9.z = (mul_s(uniforms.f[82].zzzz, reg_tmp9.zzzz)).z;
    // 276: exp
    reg_tmp9.z = exp2(reg_tmp9.z);
    // 277: mul
    reg_tmp2.z = (mul_s(uniforms.f[82].wwww, reg_tmp9.zzzz)).z;
    return false;
}
bool sub_279_287() {
    // 279: dp3
    reg_tmp9.x = dot_3(reg_tmp14.xyz, reg_tmp1.xyz);
    // 280: max
    reg_tmp9.x = (max(uniforms.f[93].xxxx, reg_tmp9.xxxx)).x;
    // 281: min
    reg_tmp9.x = (min(uniforms.f[93].yyyy, reg_tmp9.xxxx)).x;
    // 282: add
    reg_tmp9.x = (uniforms.f[93].yyyy + -reg_tmp9.xxxx).x;
    // 283: log
    reg_tmp9.x = log2(reg_tmp9.x);
    // 284: mul
    reg_tmp9.x = (mul_s(uniforms.f[82].xxxx, reg_tmp9.xxxx)).x;
    // 285: exp
    reg_tmp9.x = exp2(reg_tmp9.x);
    // 286: mul
    reg_tmp2.w = (mul_s(uniforms.f[82].yyyy, reg_tmp9.xxxx)).w;
    return false;
}
bool sub_288_4096() {
    // 288: ifu
    if (uniforms.b[10]) {
        sub_289_291();
    } else {
        sub_291_293();
    }
    // 293: ifu
    if (uniforms.b[1]) {
        sub_294_296();
    } else {
        sub_296_298();
    }
    // 298: call
    {
        sub_156_183();
    }
    // 299: call
    {
        sub_183_207();
    }
    // 300: call
    {
        sub_207_223();
    }
    // 301: end
    return true;
}
bool sub_289_291() {
    // 289: call
    {
        sub_65_116();
    }
    // 290: nop
    return false;
}
bool sub_291_293() {
    // 291: call
    {
        sub_116_156();
    }
    // 292: nop
    return false;
}
bool sub_294_296() {
    // 294: call
    {
        sub_244_288();
    }
    // 295: nop
    return false;
}
bool sub_296_298() {
    // 296: mov
    vs_out_attr3 = uniforms.f[93].yyyy;
    // 297: nop
    return false;
}
// reference: 7189F77347EDA3B1, 9D5547200C50254C
// program: 9D5547200C50254C, AD7922A63ED54CA7, E9755AA7A48874E6
// reference: A20A308A736D91B7, 9D5547200C50254C
// program: 6038F426E3FD9783, AD7922A63ED54CA7, BE595F2A0F068639
// reference: 37C48572C488EDAB, 6038F426E3FD9783
// program: F6AF8461302EECF6, AD7922A63ED54CA7, AB775DCE00F096BB
// reference: 37C4857281578927, F6AF8461302EECF6
// shader: 8B31, 0D4C344E3A25BB45

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}


#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_8();
bool sub_9_32();
bool sub_33_96();
bool sub_97_113();
bool sub_146_166();
bool sub_167_259();
bool sub_190_192();
bool sub_194_195();
bool sub_197_198();
bool sub_200_202();
bool sub_232_234();
bool sub_236_237();
bool sub_239_240();
bool sub_242_244();
bool sub_260_4096();
bool sub_280_281();
bool sub_281_282();

bool exec_shader() {
    sub_260_4096();
    return true;
}

bool sub_0_8() {
    // 0: mova
    address_registers.x = (ivec2(vs_in_reg0.zz)).x;
    // 1: mov
    reg_tmp10 = uniforms.f[0].xxxz;
    // 2: mov
    reg_tmp10.xy = (vs_in_reg0.xyyy).xy;
    // 3: mov
    reg_tmp11 = uniforms.f[0].xxxx;
    // 4: mov
    reg_tmp12 = uniforms.f[0].xxxx;
    // 5: mov
    reg_tmp13 = uniforms.f[0].zzzz;
    // 6: mov
    reg_tmp4 = uniforms.f[0].xxxx;
    // 7: mov
    reg_tmp5 = uniforms.f[0].xxxx;
    return false;
}
bool sub_9_32() {
    // 9: mov
    vs_out_attr0 = reg_tmp10;
    // 10: mul
    reg_tmp13 = mul_s(uniforms.f[82], reg_tmp13);
    // 11: mov
    vs_out_attr1 = reg_tmp13;
    // 12: add
    reg_tmp11.y = (uniforms.f[0].zzzz + -reg_tmp11.yyyy).y;
    // 13: add
    reg_tmp12.y = (uniforms.f[0].zzzz + -reg_tmp12.yyyy).y;
    // 14: mov
    reg_tmp14.y = (uniforms.f[81].wwww).y;
    // 15: mul
    reg_tmp14.x = (mul_s(uniforms.f[0].wwww, reg_tmp14.yyyy)).x;
    // 16: rcp
    reg_tmp2.x = rcp_s(reg_tmp14.x);
    // 17: mov
    reg_tmp14.z = (reg_tmp2.xxxx).z;
    // 18: add
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp11.xyyy).xy;
    // 19: mul
    reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    // 20: flr
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    // 21: mul
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    // 22: add
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    // 23: add
    reg_tmp11.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    // 24: add
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp12.xyyy).xy;
    // 25: mul
    reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    // 26: flr
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    // 27: mul
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    // 28: add
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    // 29: add
    reg_tmp12.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    // 30: mov
    vs_out_attr2 = reg_tmp11;
    // 31: mov
    vs_out_attr3 = reg_tmp12;
    return false;
}
bool sub_33_96() {
    // 33: mov
    reg_tmp6.xyz = (-reg_tmp0.xyzz).xyz;
    // 34: mov
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    // 35: rcp
    reg_tmp7.xyz = vec3(rcp_s(uniforms.f[81].y));
    // 36: madi
    reg_tmp8.xyz = (fma_s(reg_tmp6.xyzz, reg_tmp7.xyzz, uniforms.f[0].yyyy)).xyz;
    // 37: flr
    reg_tmp7.xyz = (floor(reg_tmp8.xyzz)).xyz;
    // 38: mad
    reg_tmp6.xyz = (fma_s(reg_tmp7.xyzz, -uniforms.f[81].yyyy, reg_tmp6.xyzz)).xyz;
    // 39: min
    reg_tmp6 = min(uniforms.f[81].xxxx, reg_tmp6);
    // 40: max
    reg_tmp6 = max(-uniforms.f[81].xxxx, reg_tmp6);
    // 41: mov
    reg_tmp2 = uniforms.f[95];
    // 42: mov
    reg_tmp3 = uniforms.f[94];
    // 43: mul
    reg_tmp1.z = (mul_s(reg_tmp6.xxxx, reg_tmp6.xxxx)).z;
    // 44: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 45: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 46: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 47: mov
    reg_tmp2 = uniforms.f[93];
    // 48: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 49: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 50: mul
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp6.xxxx)).y;
    // 51: mov
    reg_tmp4.x = (reg_tmp1.xxxx).x;
    // 52: mov
    reg_tmp5.x = (reg_tmp1.yyyy).x;
    // 53: mov
    reg_tmp2 = uniforms.f[95];
    // 54: mov
    reg_tmp3 = uniforms.f[94];
    // 55: mul
    reg_tmp1.z = (mul_s(reg_tmp6.yyyy, reg_tmp6.yyyy)).z;
    // 56: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 57: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 58: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 59: mov
    reg_tmp2 = uniforms.f[93];
    // 60: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 61: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 62: mul
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp6.yyyy)).y;
    // 63: mov
    reg_tmp4.y = (reg_tmp1.xxxx).y;
    // 64: mov
    reg_tmp5.y = (reg_tmp1.yyyy).y;
    // 65: mov
    reg_tmp2 = uniforms.f[95];
    // 66: mov
    reg_tmp3 = uniforms.f[94];
    // 67: mul
    reg_tmp1.z = (mul_s(reg_tmp6.zzzz, reg_tmp6.zzzz)).z;
    // 68: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 69: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 70: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 71: mov
    reg_tmp2 = uniforms.f[93];
    // 72: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 73: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 74: mul
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp6.zzzz)).y;
    // 75: mov
    reg_tmp4.z = (reg_tmp1.xxxx).z;
    // 76: mov
    reg_tmp5.z = (reg_tmp1.yyyy).z;
    // 77: mul
    reg_tmp2.x = (mul_s(reg_tmp4.yyyy, reg_tmp5.zzzz)).x;
    // 78: mul
    reg_tmp2.y = (mul_s(reg_tmp5.yyyy, reg_tmp5.zzzz)).y;
    // 79: mul
    reg_tmp6.x = (mul_s(reg_tmp4.yyyy, reg_tmp4.zzzz)).x;
    // 80: mov
    reg_tmp6.y = (reg_tmp5.zzzz).y;
    // 81: mul
    reg_tmp6.z = (mul_s(-reg_tmp5.yyyy, reg_tmp4.zzzz)).z;
    // 82: mov
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    // 83: mul
    reg_tmp7.x = (mul_s(-reg_tmp2.xxxx, reg_tmp4.xxxx)).x;
    // 84: mad
    reg_tmp7.x = (fma_s(reg_tmp5.yyyy, reg_tmp5.xxxx, reg_tmp7.xxxx)).x;
    // 85: mul
    reg_tmp7.y = (mul_s(reg_tmp4.zzzz, reg_tmp4.xxxx)).y;
    // 86: mul
    reg_tmp7.z = (mul_s(reg_tmp2.yyyy, reg_tmp4.xxxx)).z;
    // 87: mad
    reg_tmp7.z = (fma_s(reg_tmp4.yyyy, reg_tmp5.xxxx, reg_tmp7.zzzz)).z;
    // 88: mov
    reg_tmp7.w = (uniforms.f[0].xxxx).w;
    // 89: mul
    reg_tmp8.x = (mul_s(reg_tmp2.xxxx, reg_tmp5.xxxx)).x;
    // 90: mad
    reg_tmp8.x = (fma_s(reg_tmp5.yyyy, reg_tmp4.xxxx, reg_tmp8.xxxx)).x;
    // 91: mul
    reg_tmp8.y = (mul_s(-reg_tmp4.zzzz, reg_tmp5.xxxx)).y;
    // 92: mul
    reg_tmp8.z = (mul_s(-reg_tmp2.yyyy, reg_tmp5.xxxx)).z;
    // 93: mad
    reg_tmp8.z = (fma_s(reg_tmp4.yyyy, reg_tmp4.xxxx, reg_tmp8.zzzz)).z;
    // 94: mov
    reg_tmp8.w = (uniforms.f[0].xxxx).w;
    // 95: mov
    reg_tmp9 = uniforms.f[0].xxxz;
    return false;
}
bool sub_97_113() {
    // 97: mov
    reg_tmp6.x = (uniforms.f[90].xxxx).x;
    // 98: mov
    reg_tmp6.y = (uniforms.f[91].xxxx).y;
    // 99: mov
    reg_tmp6.z = (uniforms.f[92].xxxx).z;
    // 100: mov
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    // 101: mov
    reg_tmp7.x = (uniforms.f[90].yyyy).x;
    // 102: mov
    reg_tmp7.y = (uniforms.f[91].yyyy).y;
    // 103: mov
    reg_tmp7.z = (uniforms.f[92].yyyy).z;
    // 104: mov
    reg_tmp7.w = (uniforms.f[0].xxxx).w;
    // 105: mov
    reg_tmp8.x = (uniforms.f[90].zzzz).x;
    // 106: mov
    reg_tmp8.y = (uniforms.f[91].zzzz).y;
    // 107: mov
    reg_tmp8.z = (uniforms.f[92].zzzz).z;
    // 108: mov
    reg_tmp8.w = (uniforms.f[0].xxxx).w;
    // 109: mov
    reg_tmp9.x = (uniforms.f[90].wwww).x;
    // 110: mov
    reg_tmp9.y = (uniforms.f[91].wwww).y;
    // 111: mov
    reg_tmp9.z = (uniforms.f[92].wwww).z;
    // 112: mov
    reg_tmp9.w = (uniforms.f[0].zzzz).w;
    return false;
}
bool sub_146_166() {
    // 146: mov
    reg_tmp2 = uniforms.f[90];
    // 147: mov
    reg_tmp3 = uniforms.f[91];
    // 148: mov
    reg_tmp4 = uniforms.f[92];
    // 149: mov
    reg_tmp5 = uniforms.f[0].xxxz;
    // 150: mul
    reg_tmp6 = mul_s(uniforms.f[86].xxxx, reg_tmp2);
    // 151: mad
    reg_tmp6 = fma_s(reg_tmp3, uniforms.f[86].yyyy, reg_tmp6);
    // 152: mad
    reg_tmp6 = fma_s(reg_tmp4, uniforms.f[86].zzzz, reg_tmp6);
    // 153: mad
    reg_tmp6 = fma_s(reg_tmp5, uniforms.f[86].wwww, reg_tmp6);
    // 154: mul
    reg_tmp7 = mul_s(uniforms.f[87].xxxx, reg_tmp2);
    // 155: mad
    reg_tmp7 = fma_s(reg_tmp3, uniforms.f[87].yyyy, reg_tmp7);
    // 156: mad
    reg_tmp7 = fma_s(reg_tmp4, uniforms.f[87].zzzz, reg_tmp7);
    // 157: mad
    reg_tmp7 = fma_s(reg_tmp5, uniforms.f[87].wwww, reg_tmp7);
    // 158: mul
    reg_tmp8 = mul_s(uniforms.f[88].xxxx, reg_tmp2);
    // 159: mad
    reg_tmp8 = fma_s(reg_tmp3, uniforms.f[88].yyyy, reg_tmp8);
    // 160: mad
    reg_tmp8 = fma_s(reg_tmp4, uniforms.f[88].zzzz, reg_tmp8);
    // 161: mad
    reg_tmp8 = fma_s(reg_tmp5, uniforms.f[88].wwww, reg_tmp8);
    // 162: mul
    reg_tmp9 = mul_s(uniforms.f[89].xxxx, reg_tmp2);
    // 163: mad
    reg_tmp9 = fma_s(reg_tmp3, uniforms.f[89].yyyy, reg_tmp9);
    // 164: mad
    reg_tmp9 = fma_s(reg_tmp4, uniforms.f[89].zzzz, reg_tmp9);
    // 165: mad
    reg_tmp9 = fma_s(reg_tmp5, uniforms.f[89].wwww, reg_tmp9);
    return false;
}
bool sub_167_259() {
    // 167: rcp
    reg_tmp2.x = rcp_s(uniforms.f[81].y);
    // 168: mul
    reg_tmp2.xy = (mul_s(uniforms.f[2 + address_registers.x].zwww, reg_tmp2.xxxx)).xy;
    // 169: add
    reg_tmp2.xy = (uniforms.f[0].yyyy + reg_tmp2.xyyy).xy;
    // 170: flr
    reg_tmp3.xy = (floor(reg_tmp2.xyyy)).xy;
    // 171: mul
    reg_tmp2.xy = (mul_s(uniforms.f[81].yyyy, reg_tmp3.xyyy)).xy;
    // 172: add
    reg_tmp2.xy = (uniforms.f[2 + address_registers.x].zwww + -reg_tmp2.xyyy).xy;
    // 173: min
    reg_tmp0.xy = (min(uniforms.f[81].xxxx, -reg_tmp2.xyyy)).xy;
    // 174: max
    reg_tmp0.xy = (max(-uniforms.f[81].xxxx, reg_tmp0.xyyy)).xy;
    // 175: mov
    reg_tmp2 = uniforms.f[95];
    // 176: mov
    reg_tmp3 = uniforms.f[94];
    // 177: mul
    reg_tmp1.z = (mul_s(reg_tmp0.xxxx, reg_tmp0.xxxx)).z;
    // 178: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 179: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 180: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 181: mov
    reg_tmp2 = uniforms.f[93];
    // 182: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 183: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 184: mul
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.xxxx)).y;
    // 185: mov
    reg_tmp5.x = (uniforms.f[5 + address_registers.x].wwww).x;
    // 186: mov
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    // 187: mov
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    // 188: cmp
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    // 189: ifc
    if (conditional_code.x) {
        sub_190_192();
    }
    // 192: cmp
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    // 193: ifc
    if (conditional_code.x) {
        sub_194_195();
    }
    // 195: cmp
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 196: ifc
    if (conditional_code.x) {
        sub_197_198();
    }
    // 198: cmp
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 199: ifc
    if (conditional_code.x) {
        sub_200_202();
    }
    // 202: mul
    reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    // 203: mad
    reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    // 204: mad
    reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    // 205: add
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    // 206: add
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    // 207: mov
    reg_tmp4.z = (uniforms.f[83].xxxx).z;
    // 208: mov
    reg_tmp4.w = (-uniforms.f[83].yyyy).w;
    // 209: madi
    reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[3 + address_registers.x].xyyy)).xy;
    // 210: mov
    reg_tmp4.z = (-uniforms.f[3 + address_registers.x].zzzz).z;
    // 211: mov
    reg_tmp4.w = (-uniforms.f[3 + address_registers.x].wwww).w;
    // 212: add
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    // 213: add
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    // 214: mad
    reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    // 215: mad
    reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    // 216: mov
    reg_tmp11.xy = (reg_tmp5.xyyy).xy;
    // 217: mov
    reg_tmp2 = uniforms.f[95];
    // 218: mov
    reg_tmp3 = uniforms.f[94];
    // 219: mul
    reg_tmp1.z = (mul_s(reg_tmp0.yyyy, reg_tmp0.yyyy)).z;
    // 220: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 221: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 222: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 223: mov
    reg_tmp2 = uniforms.f[93];
    // 224: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 225: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 226: mul
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.yyyy)).y;
    // 227: mov
    reg_tmp5.x = (uniforms.f[6 + address_registers.x].wwww).x;
    // 228: mov
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    // 229: mov
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    // 230: cmp
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    // 231: ifc
    if (conditional_code.x) {
        sub_232_234();
    }
    // 234: cmp
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    // 235: ifc
    if (conditional_code.x) {
        sub_236_237();
    }
    // 237: cmp
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 238: ifc
    if (conditional_code.x) {
        sub_239_240();
    }
    // 240: cmp
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 241: ifc
    if (conditional_code.x) {
        sub_242_244();
    }
    // 244: mul
    reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    // 245: mad
    reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    // 246: mad
    reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    // 247: add
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    // 248: add
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    // 249: mov
    reg_tmp4.z = (uniforms.f[83].zzzz).z;
    // 250: mov
    reg_tmp4.w = (-uniforms.f[83].wwww).w;
    // 251: madi
    reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[4 + address_registers.x].xyyy)).xy;
    // 252: mov
    reg_tmp4.z = (-uniforms.f[4 + address_registers.x].zzzz).z;
    // 253: mov
    reg_tmp4.w = (-uniforms.f[4 + address_registers.x].wwww).w;
    // 254: add
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    // 255: add
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    // 256: mad
    reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    // 257: mad
    reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    // 258: mov
    reg_tmp12.xy = (reg_tmp5.xyyy).xy;
    return false;
}
bool sub_190_192() {
    // 190: mov
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    // 191: mov
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_194_195() {
    // 194: mov
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_197_198() {
    // 197: mov
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_200_202() {
    // 200: mov
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    // 201: mov
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_232_234() {
    // 232: mov
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    // 233: mov
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_236_237() {
    // 236: mov
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_239_240() {
    // 239: mov
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_242_244() {
    // 242: mov
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    // 243: mov
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_260_4096() {
    // 260: call
    {
        sub_0_8();
    }
    // 261: add
    reg_tmp10.xy = (uniforms.f[84].xyyy + reg_tmp10.xyyy).xy;
    // 262: mul
    reg_tmp10.xy = (mul_s(uniforms.f[2 + address_registers.x].xyyy, reg_tmp10.xyyy)).xy;
    // 263: mov
    reg_tmp0 = uniforms.f[7 + address_registers.x];
    // 264: call
    {
        sub_33_96();
    }
    // 265: dp4
    reg_tmp2.x = dot_s(reg_tmp10, reg_tmp6);
    // 266: dp4
    reg_tmp2.y = dot_s(reg_tmp10, reg_tmp7);
    // 267: dp4
    reg_tmp2.z = dot_s(reg_tmp10, reg_tmp8);
    // 268: dp4
    reg_tmp2.w = dot_s(reg_tmp10, reg_tmp9);
    // 269: mov
    reg_tmp10 = reg_tmp2;
    // 270: call
    {
        sub_97_113();
    }
    // 271: dp4
    reg_tmp2.x = dot_s(reg_tmp10, reg_tmp6);
    // 272: dp4
    reg_tmp2.y = dot_s(reg_tmp10, reg_tmp7);
    // 273: dp4
    reg_tmp2.z = dot_s(reg_tmp10, reg_tmp8);
    // 274: dp4
    reg_tmp2.w = dot_s(uniforms.f[0].xxxz, reg_tmp10);
    // 275: mov
    reg_tmp3.xyz = (uniforms.f[5 + address_registers.x].xyzz).xyz;
    // 276: add
    reg_tmp3.xyz = (uniforms.f[85].xyzz + -reg_tmp3.xyzz).xyz;
    // 277: dp3
    reg_tmp4.x = dot_3(reg_tmp3.xyz, reg_tmp3.xyz);
    // 278: cmp
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
    // 279: ifc
    if (conditional_code.x) {
        sub_280_281();
    } else {
        sub_281_282();
    }
    // 282: mul
    reg_tmp3.xyz = (mul_s(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
    // 283: add
    reg_tmp10.xyz = (uniforms.f[5 + address_registers.x].xyzz + reg_tmp2.xyzz).xyz;
    // 284: mad
    reg_tmp10.xyz = (fma_s(reg_tmp3.xyzz, uniforms.f[84].zzzz, reg_tmp10.xyzz)).xyz;
    // 285: call
    {
        sub_146_166();
    }
    // 286: mov
    reg_tmp2 = reg_tmp10;
    // 287: dp4
    reg_tmp10.x = dot_s(reg_tmp2, reg_tmp6);
    // 288: dp4
    reg_tmp10.y = dot_s(reg_tmp2, reg_tmp7);
    // 289: dp4
    reg_tmp10.z = dot_s(reg_tmp2, reg_tmp8);
    // 290: dp4
    reg_tmp10.w = dot_s(reg_tmp2, reg_tmp9);
    // 291: mov
    reg_tmp2 = uniforms.f[1 + address_registers.x];
    // 292: max
    reg_tmp3 = max(uniforms.f[0].xxxx, reg_tmp2);
    // 293: min
    reg_tmp2 = min(uniforms.f[0].zzzz, reg_tmp3);
    // 294: mov
    reg_tmp13 = reg_tmp2;
    // 295: call
    {
        sub_167_259();
    }
    // 296: call
    {
        sub_9_32();
    }
    // 297: end
    return true;
}
bool sub_280_281() {
    // 280: mov
    reg_tmp4.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_281_282() {
    // 281: rsq
    reg_tmp4.x = rsq_s(reg_tmp4.x);
    return false;
}
// reference: C91117B3C7196095, 0D4C344E3A25BB45
// program: 0D4C344E3A25BB45, CEF02063E9A18B2F, 52F15AB07872CB3F
// reference: AE4BD47E8861B660, DEDDD3577BD6F4B8
// reference: 7DC81387BCE18466, DEDDD3577BD6F4B8
// reference: 8C39401B9A1E8AE7, 6038F426E3FD9783
// reference: 5FBA87E26100AF29, 6038F426E3FD9783
// reference: 5FBA87E2AE9EB8E1, 6038F426E3FD9783
// reference: 8C39401B30F87D2A, F6AF8461302EECF6
// reference: AE4BD47E33F0F3B2, DEDDD3577BD6F4B8
// reference: 7DC813870770C1B4, DEDDD3577BD6F4B8
// reference: A7400F448546F233, B3A9ECAF0A8ECFA3
// reference: 60055AF2E2EF5D62, 24A4FAE31D0E0CA7
// reference: 22A34090BD2032F2, 7C60AA2AD49029B7
// reference: 8E5EF57047EDA3B1, 9D5547200C50254C
// reference: 5DDD3289736D91B7, 9D5547200C50254C
// reference: AE4BD47E4AE43854, DEDDD3577BD6F4B8
// reference: 7DC81387B1FA1D9A, DEDDD3577BD6F4B8
// reference: A7400F44FC5239D5, B3A9ECAF0A8ECFA3
// reference: 7DC813877E640A52, DEDDD3577BD6F4B8
// program: DEDDD3577BD6F4B8, 5D764F9A6220D694, 7E43BDC96307597A
// program: DEDDD3577BD6F4B8, 5D764F9A6220D694, 3491D7B9A34DF552
// program: DEDDD3577BD6F4B8, 5D764F9A6220D694, 695C3AA7F8FFB342
// reference: A7400F443ED7B7E1, B3A9ECAF0A8ECFA3
// reference: C91117B32820F3D4, 0D4C344E3A25BB45
// reference: 7DC8138753D81727, DEDDD3577BD6F4B8
// reference: 5FBA87E241A72BA0, 6038F426E3FD9783
// program: 0D4C344E3A25BB45, CEF02063E9A18B2F, 52F15AB03C873666
// shader: 8B31, AF58BE576C299039

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}


#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_8();
bool sub_9_32();
bool sub_97_113();
bool sub_146_166();
bool sub_167_259();
bool sub_190_192();
bool sub_194_195();
bool sub_197_198();
bool sub_200_202();
bool sub_232_234();
bool sub_236_237();
bool sub_239_240();
bool sub_242_244();
bool sub_260_4096();
bool sub_273_274();
bool sub_274_275();

bool exec_shader() {
    sub_260_4096();
    return true;
}

bool sub_0_8() {
    // 0: mova
    address_registers.x = (ivec2(vs_in_reg0.zz)).x;
    // 1: mov
    reg_tmp10 = uniforms.f[0].xxxz;
    // 2: mov
    reg_tmp10.xy = (vs_in_reg0.xyyy).xy;
    // 3: mov
    reg_tmp11 = uniforms.f[0].xxxx;
    // 4: mov
    reg_tmp12 = uniforms.f[0].xxxx;
    // 5: mov
    reg_tmp13 = uniforms.f[0].zzzz;
    // 6: mov
    reg_tmp4 = uniforms.f[0].xxxx;
    // 7: mov
    reg_tmp5 = uniforms.f[0].xxxx;
    return false;
}
bool sub_9_32() {
    // 9: mov
    vs_out_attr0 = reg_tmp10;
    // 10: mul
    reg_tmp13 = mul_s(uniforms.f[82], reg_tmp13);
    // 11: mov
    vs_out_attr1 = reg_tmp13;
    // 12: add
    reg_tmp11.y = (uniforms.f[0].zzzz + -reg_tmp11.yyyy).y;
    // 13: add
    reg_tmp12.y = (uniforms.f[0].zzzz + -reg_tmp12.yyyy).y;
    // 14: mov
    reg_tmp14.y = (uniforms.f[81].wwww).y;
    // 15: mul
    reg_tmp14.x = (mul_s(uniforms.f[0].wwww, reg_tmp14.yyyy)).x;
    // 16: rcp
    reg_tmp2.x = rcp_s(reg_tmp14.x);
    // 17: mov
    reg_tmp14.z = (reg_tmp2.xxxx).z;
    // 18: add
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp11.xyyy).xy;
    // 19: mul
    reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    // 20: flr
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    // 21: mul
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    // 22: add
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    // 23: add
    reg_tmp11.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    // 24: add
    reg_tmp3.xy = (uniforms.f[81].wwww + reg_tmp12.xyyy).xy;
    // 25: mul
    reg_tmp5.xy = (mul_s(reg_tmp3.xyyy, reg_tmp14.zzzz)).xy;
    // 26: flr
    reg_tmp4.xy = (floor(reg_tmp5.xyyy)).xy;
    // 27: mul
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp14.xxxx)).xy;
    // 28: add
    reg_tmp4.xy = (reg_tmp3.xyyy + -reg_tmp4.xyyy).xy;
    // 29: add
    reg_tmp12.xy = (-uniforms.f[81].wwww + reg_tmp4.xyyy).xy;
    // 30: mov
    vs_out_attr2 = reg_tmp11;
    // 31: mov
    vs_out_attr3 = reg_tmp12;
    return false;
}
bool sub_97_113() {
    // 97: mov
    reg_tmp6.x = (uniforms.f[90].xxxx).x;
    // 98: mov
    reg_tmp6.y = (uniforms.f[91].xxxx).y;
    // 99: mov
    reg_tmp6.z = (uniforms.f[92].xxxx).z;
    // 100: mov
    reg_tmp6.w = (uniforms.f[0].xxxx).w;
    // 101: mov
    reg_tmp7.x = (uniforms.f[90].yyyy).x;
    // 102: mov
    reg_tmp7.y = (uniforms.f[91].yyyy).y;
    // 103: mov
    reg_tmp7.z = (uniforms.f[92].yyyy).z;
    // 104: mov
    reg_tmp7.w = (uniforms.f[0].xxxx).w;
    // 105: mov
    reg_tmp8.x = (uniforms.f[90].zzzz).x;
    // 106: mov
    reg_tmp8.y = (uniforms.f[91].zzzz).y;
    // 107: mov
    reg_tmp8.z = (uniforms.f[92].zzzz).z;
    // 108: mov
    reg_tmp8.w = (uniforms.f[0].xxxx).w;
    // 109: mov
    reg_tmp9.x = (uniforms.f[90].wwww).x;
    // 110: mov
    reg_tmp9.y = (uniforms.f[91].wwww).y;
    // 111: mov
    reg_tmp9.z = (uniforms.f[92].wwww).z;
    // 112: mov
    reg_tmp9.w = (uniforms.f[0].zzzz).w;
    return false;
}
bool sub_146_166() {
    // 146: mov
    reg_tmp2 = uniforms.f[90];
    // 147: mov
    reg_tmp3 = uniforms.f[91];
    // 148: mov
    reg_tmp4 = uniforms.f[92];
    // 149: mov
    reg_tmp5 = uniforms.f[0].xxxz;
    // 150: mul
    reg_tmp6 = mul_s(uniforms.f[86].xxxx, reg_tmp2);
    // 151: mad
    reg_tmp6 = fma_s(reg_tmp3, uniforms.f[86].yyyy, reg_tmp6);
    // 152: mad
    reg_tmp6 = fma_s(reg_tmp4, uniforms.f[86].zzzz, reg_tmp6);
    // 153: mad
    reg_tmp6 = fma_s(reg_tmp5, uniforms.f[86].wwww, reg_tmp6);
    // 154: mul
    reg_tmp7 = mul_s(uniforms.f[87].xxxx, reg_tmp2);
    // 155: mad
    reg_tmp7 = fma_s(reg_tmp3, uniforms.f[87].yyyy, reg_tmp7);
    // 156: mad
    reg_tmp7 = fma_s(reg_tmp4, uniforms.f[87].zzzz, reg_tmp7);
    // 157: mad
    reg_tmp7 = fma_s(reg_tmp5, uniforms.f[87].wwww, reg_tmp7);
    // 158: mul
    reg_tmp8 = mul_s(uniforms.f[88].xxxx, reg_tmp2);
    // 159: mad
    reg_tmp8 = fma_s(reg_tmp3, uniforms.f[88].yyyy, reg_tmp8);
    // 160: mad
    reg_tmp8 = fma_s(reg_tmp4, uniforms.f[88].zzzz, reg_tmp8);
    // 161: mad
    reg_tmp8 = fma_s(reg_tmp5, uniforms.f[88].wwww, reg_tmp8);
    // 162: mul
    reg_tmp9 = mul_s(uniforms.f[89].xxxx, reg_tmp2);
    // 163: mad
    reg_tmp9 = fma_s(reg_tmp3, uniforms.f[89].yyyy, reg_tmp9);
    // 164: mad
    reg_tmp9 = fma_s(reg_tmp4, uniforms.f[89].zzzz, reg_tmp9);
    // 165: mad
    reg_tmp9 = fma_s(reg_tmp5, uniforms.f[89].wwww, reg_tmp9);
    return false;
}
bool sub_167_259() {
    // 167: rcp
    reg_tmp2.x = rcp_s(uniforms.f[81].y);
    // 168: mul
    reg_tmp2.xy = (mul_s(uniforms.f[2 + address_registers.x].zwww, reg_tmp2.xxxx)).xy;
    // 169: add
    reg_tmp2.xy = (uniforms.f[0].yyyy + reg_tmp2.xyyy).xy;
    // 170: flr
    reg_tmp3.xy = (floor(reg_tmp2.xyyy)).xy;
    // 171: mul
    reg_tmp2.xy = (mul_s(uniforms.f[81].yyyy, reg_tmp3.xyyy)).xy;
    // 172: add
    reg_tmp2.xy = (uniforms.f[2 + address_registers.x].zwww + -reg_tmp2.xyyy).xy;
    // 173: min
    reg_tmp0.xy = (min(uniforms.f[81].xxxx, -reg_tmp2.xyyy)).xy;
    // 174: max
    reg_tmp0.xy = (max(-uniforms.f[81].xxxx, reg_tmp0.xyyy)).xy;
    // 175: mov
    reg_tmp2 = uniforms.f[95];
    // 176: mov
    reg_tmp3 = uniforms.f[94];
    // 177: mul
    reg_tmp1.z = (mul_s(reg_tmp0.xxxx, reg_tmp0.xxxx)).z;
    // 178: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 179: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 180: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 181: mov
    reg_tmp2 = uniforms.f[93];
    // 182: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 183: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 184: mul
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.xxxx)).y;
    // 185: mov
    reg_tmp5.x = (uniforms.f[5 + address_registers.x].wwww).x;
    // 186: mov
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    // 187: mov
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    // 188: cmp
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    // 189: ifc
    if (conditional_code.x) {
        sub_190_192();
    }
    // 192: cmp
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    // 193: ifc
    if (conditional_code.x) {
        sub_194_195();
    }
    // 195: cmp
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 196: ifc
    if (conditional_code.x) {
        sub_197_198();
    }
    // 198: cmp
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 199: ifc
    if (conditional_code.x) {
        sub_200_202();
    }
    // 202: mul
    reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    // 203: mad
    reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    // 204: mad
    reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    // 205: add
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    // 206: add
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    // 207: mov
    reg_tmp4.z = (uniforms.f[83].xxxx).z;
    // 208: mov
    reg_tmp4.w = (-uniforms.f[83].yyyy).w;
    // 209: madi
    reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[3 + address_registers.x].xyyy)).xy;
    // 210: mov
    reg_tmp4.z = (-uniforms.f[3 + address_registers.x].zzzz).z;
    // 211: mov
    reg_tmp4.w = (-uniforms.f[3 + address_registers.x].wwww).w;
    // 212: add
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    // 213: add
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    // 214: mad
    reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    // 215: mad
    reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    // 216: mov
    reg_tmp11.xy = (reg_tmp5.xyyy).xy;
    // 217: mov
    reg_tmp2 = uniforms.f[95];
    // 218: mov
    reg_tmp3 = uniforms.f[94];
    // 219: mul
    reg_tmp1.z = (mul_s(reg_tmp0.yyyy, reg_tmp0.yyyy)).z;
    // 220: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp2.xyyy, reg_tmp2.zwww)).xy;
    // 221: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.xyyy)).xy;
    // 222: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp3.zwww)).xy;
    // 223: mov
    reg_tmp2 = uniforms.f[93];
    // 224: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.xyyy)).xy;
    // 225: mad
    reg_tmp1.xy = (fma_s(reg_tmp1.zzzz, reg_tmp1.xyyy, reg_tmp2.zwww)).xy;
    // 226: mul
    reg_tmp1.y = (mul_s(reg_tmp1.yyyy, reg_tmp0.yyyy)).y;
    // 227: mov
    reg_tmp5.x = (uniforms.f[6 + address_registers.x].wwww).x;
    // 228: mov
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    // 229: mov
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    // 230: cmp
    conditional_code.x = uniforms.f[0].xxxx.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].xxxx.y != reg_tmp5.xxxx.y;
    // 231: ifc
    if (conditional_code.x) {
        sub_232_234();
    }
    // 234: cmp
    conditional_code.x = uniforms.f[0].zzzz.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].zzzz.y != reg_tmp5.xxxx.y;
    // 235: ifc
    if (conditional_code.x) {
        sub_236_237();
    }
    // 237: cmp
    conditional_code.x = uniforms.f[0].wwww.x == reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 238: ifc
    if (conditional_code.x) {
        sub_239_240();
    }
    // 240: cmp
    conditional_code.x = uniforms.f[0].wwww.x < reg_tmp5.xxxx.x;
    conditional_code.y = uniforms.f[0].wwww.y != reg_tmp5.xxxx.y;
    // 241: ifc
    if (conditional_code.x) {
        sub_242_244();
    }
    // 244: mul
    reg_tmp4.xy = (mul_s(reg_tmp14.xxxx, reg_tmp1.xyyy)).xy;
    // 245: mad
    reg_tmp4.x = (fma_s(-reg_tmp14.yyyy, reg_tmp1.yyyy, reg_tmp4.xxxx)).x;
    // 246: mad
    reg_tmp4.y = (fma_s(reg_tmp14.yyyy, reg_tmp1.xxxx, reg_tmp4.yyyy)).y;
    // 247: add
    reg_tmp5.x = (uniforms.f[0].yyyy + reg_tmp4.xxxx).x;
    // 248: add
    reg_tmp5.y = (-uniforms.f[0].yyyy + reg_tmp4.yyyy).y;
    // 249: mov
    reg_tmp4.z = (uniforms.f[83].zzzz).z;
    // 250: mov
    reg_tmp4.w = (-uniforms.f[83].wwww).w;
    // 251: madi
    reg_tmp5.xy = (fma_s(reg_tmp5.xyyy, reg_tmp4.zwww, uniforms.f[4 + address_registers.x].xyyy)).xy;
    // 252: mov
    reg_tmp4.z = (-uniforms.f[4 + address_registers.x].zzzz).z;
    // 253: mov
    reg_tmp4.w = (-uniforms.f[4 + address_registers.x].wwww).w;
    // 254: add
    reg_tmp5.z = (uniforms.f[0].zzzz + reg_tmp4.zzzz).z;
    // 255: add
    reg_tmp5.w = (uniforms.f[0].zzzz + reg_tmp4.wwww).w;
    // 256: mad
    reg_tmp5.x = (fma_s(-reg_tmp5.zzzz, reg_tmp4.xxxx, reg_tmp5.xxxx)).x;
    // 257: mad
    reg_tmp5.y = (fma_s(reg_tmp5.wwww, reg_tmp4.yyyy, reg_tmp5.yyyy)).y;
    // 258: mov
    reg_tmp12.xy = (reg_tmp5.xyyy).xy;
    return false;
}
bool sub_190_192() {
    // 190: mov
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    // 191: mov
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_194_195() {
    // 194: mov
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_197_198() {
    // 197: mov
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_200_202() {
    // 200: mov
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    // 201: mov
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_232_234() {
    // 232: mov
    reg_tmp14.x = (vs_in_reg0.xxxx).x;
    // 233: mov
    reg_tmp14.y = (vs_in_reg0.yyyy).y;
    return false;
}
bool sub_236_237() {
    // 236: mov
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    return false;
}
bool sub_239_240() {
    // 239: mov
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_242_244() {
    // 242: mov
    reg_tmp14.x = (-vs_in_reg0.xxxx).x;
    // 243: mov
    reg_tmp14.y = (-vs_in_reg0.yyyy).y;
    return false;
}
bool sub_260_4096() {
    // 260: call
    {
        sub_0_8();
    }
    // 261: add
    reg_tmp10.xy = (uniforms.f[84].xyyy + reg_tmp10.xyyy).xy;
    // 262: mul
    reg_tmp10.xy = (mul_s(uniforms.f[2 + address_registers.x].xyyy, reg_tmp10.xyyy)).xy;
    // 263: call
    {
        sub_97_113();
    }
    // 264: dp4
    reg_tmp2.x = dot_s(reg_tmp10, reg_tmp6);
    // 265: dp4
    reg_tmp2.y = dot_s(reg_tmp10, reg_tmp7);
    // 266: dp4
    reg_tmp2.z = dot_s(reg_tmp10, reg_tmp8);
    // 267: dp4
    reg_tmp2.w = dot_s(uniforms.f[0].xxxz, reg_tmp10);
    // 268: mov
    reg_tmp3.xyz = (uniforms.f[5 + address_registers.x].xyzz).xyz;
    // 269: add
    reg_tmp3.xyz = (uniforms.f[85].xyzz + -reg_tmp3.xyzz).xyz;
    // 270: dp3
    reg_tmp4.x = dot_3(reg_tmp3.xyz, reg_tmp3.xyz);
    // 271: cmp
    conditional_code.x = uniforms.f[0].xxxx.x >= reg_tmp4.x;
    conditional_code.y = uniforms.f[0].xxxx.y == reg_tmp4.y;
    // 272: ifc
    if (conditional_code.x) {
        sub_273_274();
    } else {
        sub_274_275();
    }
    // 275: mul
    reg_tmp3.xyz = (mul_s(reg_tmp3.xyzz, reg_tmp4.xxxx)).xyz;
    // 276: add
    reg_tmp10.xyz = (uniforms.f[5 + address_registers.x].xyzz + reg_tmp2.xyzz).xyz;
    // 277: mad
    reg_tmp10.xyz = (fma_s(reg_tmp3.xyzz, uniforms.f[84].zzzz, reg_tmp10.xyzz)).xyz;
    // 278: call
    {
        sub_146_166();
    }
    // 279: mov
    reg_tmp2 = reg_tmp10;
    // 280: dp4
    reg_tmp10.x = dot_s(reg_tmp2, reg_tmp6);
    // 281: dp4
    reg_tmp10.y = dot_s(reg_tmp2, reg_tmp7);
    // 282: dp4
    reg_tmp10.z = dot_s(reg_tmp2, reg_tmp8);
    // 283: dp4
    reg_tmp10.w = dot_s(reg_tmp2, reg_tmp9);
    // 284: mov
    reg_tmp2 = uniforms.f[1 + address_registers.x];
    // 285: max
    reg_tmp3 = max(uniforms.f[0].xxxx, reg_tmp2);
    // 286: min
    reg_tmp2 = min(uniforms.f[0].zzzz, reg_tmp3);
    // 287: mov
    reg_tmp13 = reg_tmp2;
    // 288: call
    {
        sub_167_259();
    }
    // 289: call
    {
        sub_9_32();
    }
    // 290: end
    return true;
}
bool sub_273_274() {
    // 273: mov
    reg_tmp4.x = (uniforms.f[0].zzzz).x;
    return false;
}
bool sub_274_275() {
    // 274: rsq
    reg_tmp4.x = rsq_s(reg_tmp4.x);
    return false;
}
// reference: 07F9F7A42E1DC7FB, AF58BE576C299039
// program: AF58BE576C299039, CEF02063E9A18B2F, 52F15AB03C873666
// program: AF58BE576C299039, CEF02063E9A18B2F, F4D4A672151406DE
// program: DEDDD3577BD6F4B8, 5D764F9A6220D694, 7A3173B303F95A5E
// reference: 58970D47AC196E89, B3A9ECAF0A8ECFA3
// program: 7C60AA2AD49029B7, AD7922A63ED54CA7, F5D6ACAB53B64CF3
// reference: 36C80D5271A2E093, FD6581EE07E13BFE
// reference: E54BCAAB4522D295, FD6581EE07E13BFE
// reference: 9790BAAFD93287B4, FD6581EE07E13BFE
// program: FD6581EE07E13BFE, AD7922A63ED54CA7, C519A1630DEF8B1C
// reference: 44137D56EDB2B5B2, FD6581EE07E13BFE
// program: FD6581EE07E13BFE, AD7922A63ED54CA7, 3215951A8C50D2A0
// reference: 1A92D04ACF700DA8, 0D4C344E3A25BB45
// program: 0D4C344E3A25BB45, CEF02063E9A18B2F, 3D318A15D5321B4C
// reference: C91117B314C9ACEF, 0D4C344E3A25BB45
// shader: 8B31, 7973DBE2BC07EC66

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;
 out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}


#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_6();
bool sub_6_53();
bool sub_21_25();
bool sub_51_52();
bool sub_53_4096();

bool exec_shader() {
    sub_53_4096();
    return true;
}

bool sub_0_6() {
    // 0: mova
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    // 1: nop
    // 2: dp4
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    // 3: dp4
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    // 4: dp4
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    // 5: mad
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    return false;
}
bool sub_6_53() {
    // 6: mov
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    // 7: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 8: mov
    reg_tmp7 = uniforms.f[93].xxxx;
    // 9: mul
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    // 10: cmp
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    // 11: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 12: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    // 13: call
    {
        sub_0_6();
    }
    // 14: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 15: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    // 16: call
    {
        sub_0_6();
    }
    // 17: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 18: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    // 19: callc
    if (conditional_code.x) {
        sub_0_6();
    }
    // 20: ifu
    if (uniforms.b[11]) {
        sub_21_25();
    }
    // 25: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 26: mov
    reg_tmp10 = reg_tmp7;
    // 27: add
    reg_tmp6.y = (-uniforms.f[83].wwww + reg_tmp10.yyyy).y;
    // 28: mov
    reg_tmp9.xyz = (uniforms.f[83].xyzz).xyz;
    // 29: dp4
    reg_tmp7.x = dot_s(reg_tmp9.xyzz, reg_tmp9.xyzz);
    // 30: rsq
    reg_tmp7.x = rsq_s(reg_tmp7.x);
    // 31: mul
    reg_tmp7.xyz = (mul_s(reg_tmp9.xyzz, reg_tmp7.xxxx)).xyz;
    // 32: rcp
    reg_tmp8.y = rcp_s(-reg_tmp7.y);
    // 33: mul
    reg_tmp8.y = (mul_s(reg_tmp6.yyyy, reg_tmp8.yyyy)).y;
    // 34: mul
    reg_tmp7.xyz = (mul_s(reg_tmp7.xyzz, reg_tmp8.yyyy)).xyz;
    // 35: add
    reg_tmp10.xyz = (reg_tmp10.xyzz + reg_tmp7.xyzz).xyz;
    // 36: add
    reg_tmp10.y = (uniforms.f[94].xxxx + reg_tmp10.yyyy).y;
    // 37: dp4
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    // 38: dp4
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    // 39: dp4
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    // 40: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 41: mov
    vs_out_attr1 = uniforms.f[93].xxxx;
    // 42: mov
    vs_out_attr2 = -reg_tmp15;
    // 43: dp4
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    // 44: dp4
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    // 45: dp4
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    // 46: dp4
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    // 47: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 48: mul
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    // 49: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 50: ifc
    if (all(conditional_code)) {
        sub_51_52();
    }
    // 52: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_21_25() {
    // 21: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 22: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    // 23: callc
    if (conditional_code.y) {
        sub_0_6();
    }
    // 24: nop
    return false;
}
bool sub_51_52() {
    // 51: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_53_4096() {
    // 53: call
    {
        sub_6_53();
    }
    // 54: mov
    vs_out_attr4 = uniforms.f[93].xxxx;
    // 55: mov
    vs_out_attr5 = uniforms.f[93].xxxx;
    // 56: mov
    vs_out_attr6 = uniforms.f[93].xxxx;
    // 57: mov
    vs_out_attr3 = uniforms.f[93].xxxx;
    // 58: end
    return true;
}
// reference: 1530B40797BB30E5, 7973DBE2BC07EC66
// program: 7973DBE2BC07EC66, AD7922A63ED54CA7, B223506173AA3746
// program: 9D5547200C50254C, AD7922A63ED54CA7, 73516A70FF4C0B53
// reference: 07F9F7A412F498C0, AF58BE576C299039
// program: 0D4C344E3A25BB45, CEF02063E9A18B2F, C051D29E999B8E7B
// reference: D47A305DC94D3987, AF58BE576C299039
// reference: D47A305DC0A55982, AF58BE576C299039
// reference: 07F9F7A41B1CF8C5, AF58BE576C299039
// reference: 4C519F0863B4E9DE, 24A4FAE31D0E0CA7
// program: DEDDD3577BD6F4B8, 5D764F9A6220D694, 793FBCF903F95A5E
// program: DEDDD3577BD6F4B8, 5D764F9A6220D694, 15340764F8FFB342
// shader: 8B30, 73C03B06CE3D4B69

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) * (const_color[2].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: E32461D938807D48, 73C03B06CE3D4B69
// program: DEDDD3577BD6F4B8, 5D764F9A6220D694, 73C03B06CE3D4B69
// shader: 8B30, F4D9D3A0C323B133

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) * (const_color[2].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: E32461D9C857F6E5, F4D9D3A0C323B133
// program: DEDDD3577BD6F4B8, 5D764F9A6220D694, F4D9D3A0C323B133
// shader: 8B30, 6D52E90095B6681D

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) * (const_color[2].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D39C7E926BFA8ACC, 6D52E90095B6681D
// program: DEDDD3577BD6F4B8, 5D764F9A6220D694, 6D52E90095B6681D
// shader: 8B30, 1CDC4206D78F8E5B

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) * (const_color[2].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: E32461D933B7875C, 1CDC4206D78F8E5B
// program: DEDDD3577BD6F4B8, 5D764F9A6220D694, 1CDC4206D78F8E5B
// shader: 8B30, 8C813175D6234E0E

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (const_color[1].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) * (const_color[2].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 0A7D03F062908828, 8C813175D6234E0E
// program: DEDDD3577BD6F4B8, 5D764F9A6220D694, 8C813175D6234E0E
// shader: 8B30, A793B59498BD50D3

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_2 = byteround(clamp((texcolor2.rgb) * (const_color[2].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: E32461D9C3600CF1, A793B59498BD50D3
// program: DEDDD3577BD6F4B8, 5D764F9A6220D694, A793B59498BD50D3
// reference: E32461D9901AFB75, F4D9D3A0C323B133
// shader: 8B30, 123F0FE36A723C20

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp(vec3(dot((texcolor0.rgb) - vec3(0.5), (texcolor2.rgb) - vec3(0.5)) * 4.0), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp(min((texcolor1.a) + (1.0 - texcolor0.a), 1.0) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (combiner_buffer.rgb) + (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp(min((texcolor0.a) + (1.0 - texcolor2.a), 1.0) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 1E2118466828FC03, 123F0FE36A723C20
// program: DEDDD3577BD6F4B8, 5D764F9A6220D694, 123F0FE36A723C20
// shader: 8B30, 5A0A3489228017BC

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 2FC0B94CC57D5D7B, 5A0A3489228017BC
// program: DEDDD3577BD6F4B8, 5D764F9A6220D694, 5A0A3489228017BC
// reference: 1F78A6073E9D2CC2, ECB67079092E1152
// shader: 8B30, A7554B42F30AEAE4

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 1F78A6079678FE12, A7554B42F30AEAE4
// program: DEDDD3577BD6F4B8, 5D764F9A6220D694, A7554B42F30AEAE4
// shader: 8B30, E914533DE99D512D

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (texcolor2.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor2.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor2.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 84C9BC5CE245D3F0, E914533DE99D512D
// program: DEDDD3577BD6F4B8, 5D764F9A6220D694, E914533DE99D512D
// reference: 6CF5F277A2E49C68, DEDDD3577BD6F4B8
// shader: 8B30, 74485CA8ECCCD7D1

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (texcolor2.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor2.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor2.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 84C9BC5C04FDAC75, 74485CA8ECCCD7D1
// program: DEDDD3577BD6F4B8, 5D764F9A6220D694, 74485CA8ECCCD7D1
// shader: 8B30, D7797AFBADAE290D

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (texcolor2.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor2.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor2.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: B471A317A750D05C, D7797AFBADAE290D
// program: DEDDD3577BD6F4B8, 5D764F9A6220D694, D7797AFBADAE290D
// reference: 84C9BC5C5CB0A1E5, 74485CA8ECCCD7D1
// shader: 8B30, BB6E26E3E8A05095

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((const_color[0].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (texcolor2.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor2.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor2.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 84C9BC5CF4557335, BB6E26E3E8A05095
// program: DEDDD3577BD6F4B8, 5D764F9A6220D694, BB6E26E3E8A05095
// shader: 8B30, 2B21A85C45180294

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (texcolor2.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor2.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor2.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 84C9BC5CFF1DDDCC, 2B21A85C45180294
// program: DEDDD3577BD6F4B8, 5D764F9A6220D694, 2B21A85C45180294
// shader: 8B30, D59F8A0C39F6E702

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_2 = byteround(clamp((const_color[2].rgb) * (texcolor2.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor2.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor2.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 84C9BC5CF42A27D8, D59F8A0C39F6E702
// program: DEDDD3577BD6F4B8, 5D764F9A6220D694, D59F8A0C39F6E702
// reference: 8724C28E9443E1F3, 7C60AA2AD49029B7
// reference: 54A70577A0C3D3F5, 7C60AA2AD49029B7
// reference: 2DED4C7FD004B9C8, 9D5547200C50254C
// reference: FE6E8B86E4848BCE, 9D5547200C50254C
// shader: 8B31, 3D6E7D97242068C9

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;
 out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}


#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_19();
bool sub_19_29();
bool sub_29_51();
bool sub_51_65();
bool sub_65_116();
bool sub_88_92();
bool sub_114_115();
bool sub_116_156();
bool sub_133_137();
bool sub_154_155();
bool sub_156_183();
bool sub_158_163();
bool sub_163_182();
bool sub_166_172();
bool sub_172_181();
bool sub_173_177();
bool sub_177_180();
bool sub_183_207();
bool sub_185_189();
bool sub_189_206();
bool sub_190_204();
bool sub_193_200();
bool sub_200_203();
bool sub_204_205();
bool sub_207_223();
bool sub_209_213();
bool sub_213_222();
bool sub_214_220();
bool sub_220_221();
bool sub_223_231();
bool sub_225_226();
bool sub_226_230();
bool sub_227_228();
bool sub_228_229();
bool sub_231_238();
bool sub_238_242();
bool sub_242_286();
bool sub_262_268();
bool sub_269_276();
bool sub_277_285();
bool sub_286_4096();
bool sub_287_289();
bool sub_289_291();
bool sub_292_294();
bool sub_294_296();

bool exec_shader() {
    sub_286_4096();
    return true;
}

bool sub_0_19() {
    uint jmp_to = 0u;
    while (true) {
        switch (jmp_to) {
        case 0u: {
            // 0: dp3
            reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
            // 1: dp3
            reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
            // 2: dp3
            reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
            // 3: dp3
            reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
            // 4: dp3
            reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
            // 5: rsq
            reg_tmp6.x = rsq_s(reg_tmp6.x);
            // 6: rsq
            reg_tmp7.x = rsq_s(reg_tmp7.x);
            // 7: mul
            reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 8: mul
            reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 9: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 10: add
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            // 11: mul
            reg_tmp4 = mul_s(uniforms.f[94].xxxx, reg_tmp4);
            // 12: cmp
            conditional_code = greaterThanEqual(uniforms.f[93].xx, reg_tmp4.xx);
            // 13: rsq
            reg_tmp4 = vec4(rsq_s(reg_tmp4.x));
            // 14: mul
            reg_tmp5 = mul_s(uniforms.f[94].xxxx, reg_tmp14);
            // 15: jmpc
            if (conditional_code.x) {
                { jmp_to = 18u; break; }
            }
            // 16: rcp
            reg_tmp0.z = rcp_s(reg_tmp4.x);
            // 17: mul
            reg_tmp0.xy = (mul_s(reg_tmp5, reg_tmp4)).xy;
        }
        case 18u: {
            // 18: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_19_29() {
    // 19: mova
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    // 20: nop
    // 21: dp4
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    // 22: dp4
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    // 23: dp4
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    // 24: dp3
    reg_tmp4.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    // 25: dp3
    reg_tmp4.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    // 26: dp3
    reg_tmp4.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    // 27: mad
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 28: mad
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_29_51() {
    // 29: mova
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    // 30: nop
    // 31: dp4
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    // 32: dp4
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    // 33: dp4
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    // 34: mad
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 35: dp3
    reg_tmp3.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    // 36: dp3
    reg_tmp3.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    // 37: dp3
    reg_tmp3.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    // 38: mad
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp12);
    // 39: dp3
    reg_tmp3.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp13.xyz);
    // 40: dp3
    reg_tmp3.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp13.xyz);
    // 41: dp3
    reg_tmp3.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp13.xyz);
    // 42: mad
    reg_tmp11 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp11);
    // 43: dp3
    reg_tmp3.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp5.xyz);
    // 44: dp3
    reg_tmp3.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp5.xyz);
    // 45: dp3
    reg_tmp3.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp5.xyz);
    // 46: mad
    reg_tmp9 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp9);
    // 47: dp3
    reg_tmp3.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp6.xyz);
    // 48: dp3
    reg_tmp3.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp6.xyz);
    // 49: dp3
    reg_tmp3.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp6.xyz);
    // 50: mad
    reg_tmp8 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp8);
    return false;
}
bool sub_51_65() {
    // 51: mul
    reg_tmp0.xyz = (mul_s(reg_tmp9.yzxx, reg_tmp8.zxyy)).xyz;
    // 52: mad
    reg_tmp0.xyz = (fma_s(-reg_tmp8.yzxx, reg_tmp9.zxyy, reg_tmp0)).xyz;
    // 53: mov
    reg_tmp1 = uniforms.f[83];
    // 54: dp4
    reg_tmp2.x = dot_s(reg_tmp1.xyzz, reg_tmp1.xyzz);
    // 55: rsq
    reg_tmp2.x = rsq_s(reg_tmp2.x);
    // 56: mul
    reg_tmp2.xyz = (mul_s(reg_tmp1.xyzz, reg_tmp2.xxxx)).xyz;
    // 57: dp3
    reg_tmp1.x = dot_3(reg_tmp2.xyz, reg_tmp8.xyz);
    // 58: dp3
    reg_tmp1.y = dot_3(reg_tmp2.xyz, reg_tmp0.xyz);
    // 59: dp3
    reg_tmp1.z = dot_3(reg_tmp2.xyz, reg_tmp9.xyz);
    // 60: dp4
    reg_tmp2.x = dot_s(reg_tmp1.xyzz, reg_tmp1.xyzz);
    // 61: rsq
    reg_tmp2.x = rsq_s(reg_tmp2.x);
    // 62: mul
    reg_tmp2.xyz = (mul_s(reg_tmp1.xyzz, reg_tmp2.xxxx)).xyz;
    // 63: mov
    reg_tmp2.w = (uniforms.f[93].yyyy).w;
    // 64: mov
    vs_out_attr2 = reg_tmp2;
    return false;
}
bool sub_65_116() {
    // 65: mov
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    // 66: mov
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    // 67: mov
    reg_tmp13.xyz = (vs_in_reg2).xyz;
    // 68: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 69: mov
    reg_tmp5 = uniforms.f[93].xxyy;
    // 70: mov
    reg_tmp6 = uniforms.f[93].yxxy;
    // 71: mov
    reg_tmp7 = uniforms.f[93].xxxx;
    // 72: mov
    reg_tmp12 = uniforms.f[93].xxxx;
    // 73: mov
    reg_tmp11 = uniforms.f[93].xxxx;
    // 74: mov
    reg_tmp9 = uniforms.f[93].xxxx;
    // 75: mov
    reg_tmp8 = uniforms.f[93].xxxx;
    // 76: mul
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    // 77: cmp
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    // 78: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 79: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    // 80: call
    {
        sub_29_51();
    }
    // 81: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 82: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    // 83: call
    {
        sub_29_51();
    }
    // 84: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 85: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    // 86: callc
    if (conditional_code.x) {
        sub_29_51();
    }
    // 87: ifu
    if (uniforms.b[11]) {
        sub_88_92();
    }
    // 92: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 93: mov
    reg_tmp10 = reg_tmp7;
    // 94: dp3
    reg_tmp13.x = dot_3(uniforms.f[90].xyz, reg_tmp11.xyz);
    // 95: dp3
    reg_tmp13.y = dot_3(uniforms.f[91].xyz, reg_tmp11.xyz);
    // 96: dp3
    reg_tmp13.z = dot_3(uniforms.f[92].xyz, reg_tmp11.xyz);
    // 97: dp3
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    // 98: dp3
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    // 99: dp3
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    // 100: dp4
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    // 101: dp4
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    // 102: dp4
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    // 103: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 104: call
    {
        sub_51_65();
    }
    // 105: mov
    vs_out_attr1 = uniforms.f[93].xxxy;
    // 106: dp4
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    // 107: dp4
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    // 108: dp4
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    // 109: dp4
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    // 110: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 111: mul
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    // 112: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 113: ifc
    if (all(conditional_code)) {
        sub_114_115();
    }
    // 115: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_88_92() {
    // 88: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 89: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    // 90: callc
    if (conditional_code.y) {
        sub_29_51();
    }
    // 91: nop
    return false;
}
bool sub_114_115() {
    // 114: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_116_156() {
    // 116: mov
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    // 117: mov
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    // 118: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 119: mov
    reg_tmp7 = uniforms.f[93].xxxx;
    // 120: mov
    reg_tmp12 = uniforms.f[93].xxxx;
    // 121: mul
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    // 122: cmp
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    // 123: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 124: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    // 125: call
    {
        sub_19_29();
    }
    // 126: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 127: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    // 128: call
    {
        sub_19_29();
    }
    // 129: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 130: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    // 131: callc
    if (conditional_code.x) {
        sub_19_29();
    }
    // 132: ifu
    if (uniforms.b[11]) {
        sub_133_137();
    }
    // 137: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 138: mov
    reg_tmp10 = reg_tmp7;
    // 139: dp4
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    // 140: dp4
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    // 141: dp4
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    // 142: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 143: call
    {
        sub_0_19();
    }
    // 144: nop
    // 145: mov
    vs_out_attr2 = reg_tmp15;
    // 146: dp4
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    // 147: dp4
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    // 148: dp4
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    // 149: dp4
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    // 150: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 151: mul
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    // 152: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 153: ifc
    if (all(conditional_code)) {
        sub_154_155();
    }
    // 155: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_133_137() {
    // 133: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 134: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    // 135: callc
    if (conditional_code.y) {
        sub_19_29();
    }
    // 136: nop
    return false;
}
bool sub_154_155() {
    // 154: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_156_183() {
    // 156: mov
    reg_tmp0.xy = (uniforms.f[0].xxxx).xy;
    // 157: ifu
    if (uniforms.b[2]) {
        sub_158_163();
    } else {
        sub_163_182();
    }
    // 182: nop
    return false;
}
bool sub_158_163() {
    // 158: call
    {
        sub_223_231();
    }
    // 159: dp4
    reg_tmp3.x = dot_s(uniforms.f[1].xywz, reg_tmp6);
    // 160: dp4
    reg_tmp3.y = dot_s(uniforms.f[2].xywz, reg_tmp6);
    // 161: mov
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    // 162: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_163_182() {
    // 163: cmp
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    // 164: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 165: ifc
    if (all(not(conditional_code))) {
        sub_166_172();
    } else {
        sub_172_181();
    }
    // 181: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_166_172() {
    // 166: mov
    reg_tmp6 = reg_tmp10;
    // 167: dp4
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    // 168: dp4
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    // 169: dp4
    reg_tmp3.z = dot_s(uniforms.f[3], reg_tmp6);
    // 170: mul
    reg_tmp0.xy = (mul_s(uniforms.f[9].xyyy, reg_tmp3.zzzz)).xy;
    // 171: add
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_172_181() {
    // 172: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_173_177();
    } else {
        sub_177_180();
    }
    // 180: nop
    return false;
}
bool sub_173_177() {
    // 173: call
    {
        sub_231_238();
    }
    // 174: dp3
    reg_tmp3.x = dot_3(uniforms.f[1].xyz, reg_tmp6.xyz);
    // 175: dp3
    reg_tmp3.y = dot_3(uniforms.f[2].xyz, reg_tmp6.xyz);
    // 176: dp3
    reg_tmp3.z = dot_3(uniforms.f[3].xyz, reg_tmp6.xyz);
    return false;
}
bool sub_177_180() {
    // 177: call
    {
        sub_238_242();
    }
    // 178: dp4
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    // 179: dp4
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    return false;
}
bool sub_183_207() {
    // 183: mov
    reg_tmp0.xy = (uniforms.f[0].yyyy).xy;
    // 184: ifu
    if (uniforms.b[3]) {
        sub_185_189();
    } else {
        sub_189_206();
    }
    // 206: nop
    return false;
}
bool sub_185_189() {
    // 185: call
    {
        sub_223_231();
    }
    // 186: dp4
    reg_tmp4.x = dot_s(uniforms.f[4].xywz, reg_tmp6);
    // 187: dp4
    reg_tmp4.y = dot_s(uniforms.f[5].xywz, reg_tmp6);
    // 188: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_189_206() {
    // 189: ifu
    if (uniforms.b[5]) {
        sub_190_204();
    } else {
        sub_204_205();
    }
    // 205: nop
    return false;
}
bool sub_190_204() {
    // 190: cmp
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    // 191: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 192: ifc
    if (all(not(conditional_code))) {
        sub_193_200();
    } else {
        sub_200_203();
    }
    // 203: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_193_200() {
    // 193: mov
    reg_tmp6 = reg_tmp10;
    // 194: dp4
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    // 195: dp4
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    // 196: dp4
    reg_tmp4.z = dot_s(uniforms.f[6], reg_tmp6);
    // 197: rcp
    reg_tmp6.w = rcp_s(reg_tmp4.z);
    // 198: mul
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    // 199: add
    reg_tmp4.xy = (uniforms.f[9].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_200_203() {
    // 200: call
    {
        sub_238_242();
    }
    // 201: dp4
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    // 202: dp4
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    return false;
}
bool sub_204_205() {
    // 204: mov
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_207_223() {
    // 207: mov
    reg_tmp0.xy = (uniforms.f[0].zzzz).xy;
    // 208: ifu
    if (uniforms.b[4]) {
        sub_209_213();
    } else {
        sub_213_222();
    }
    // 222: nop
    return false;
}
bool sub_209_213() {
    // 209: call
    {
        sub_223_231();
    }
    // 210: dp4
    reg_tmp5.x = dot_s(uniforms.f[7].xywz, reg_tmp6);
    // 211: dp4
    reg_tmp5.y = dot_s(uniforms.f[8].xywz, reg_tmp6);
    // 212: mov
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_213_222() {
    // 213: ifu
    if (uniforms.b[6]) {
        sub_214_220();
    } else {
        sub_220_221();
    }
    // 221: nop
    return false;
}
bool sub_214_220() {
    // 214: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 215: mov
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    // 216: call
    {
        sub_238_242();
    }
    // 217: dp4
    reg_tmp5.x = dot_s(uniforms.f[7], reg_tmp6);
    // 218: dp4
    reg_tmp5.y = dot_s(uniforms.f[8], reg_tmp6);
    // 219: mov
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_220_221() {
    // 220: mov
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
bool sub_223_231() {
    // 223: cmp
    conditional_code = equal(uniforms.f[93].yz, reg_tmp0.xy);
    // 224: ifc
    if (all(not(conditional_code))) {
        sub_225_226();
    } else {
        sub_226_230();
    }
    // 230: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_225_226() {
    // 225: mov
    reg_tmp6.xy = (vs_in_reg4.xyyy).xy;
    return false;
}
bool sub_226_230() {
    // 226: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_227_228();
    } else {
        sub_228_229();
    }
    // 229: nop
    return false;
}
bool sub_227_228() {
    // 227: mov
    reg_tmp6.xy = (vs_in_reg5.xyyy).xy;
    return false;
}
bool sub_228_229() {
    // 228: mov
    reg_tmp6.xy = (vs_in_reg6.xyyy).xy;
    return false;
}
bool sub_231_238() {
    // 231: mov
    reg_tmp2 = -reg_tmp15;
    // 232: dp3
    reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
    // 233: rsq
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    // 234: mul
    reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
    // 235: dp3
    reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
    // 236: add
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    // 237: mad
    reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_238_242() {
    // 238: mov
    reg_tmp1.xy = (uniforms.f[94].xxxx).xy;
    // 239: mov
    reg_tmp1.zw = (uniforms.f[93].xxxx).zw;
    // 240: mad
    reg_tmp6 = fma_s(reg_tmp14, reg_tmp1, reg_tmp1);
    // 241: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_242_286() {
    // 242: mov
    reg_tmp1.xyz = (uniforms.f[93].xxyx).xyz;
    // 243: dp3
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    // 244: dp3
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    // 245: dp3
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    // 246: mov
    reg_tmp14.w = (uniforms.f[93].xxxx).w;
    // 247: mov
    reg_tmp8 = reg_tmp14;
    // 248: dp4
    reg_tmp14.x = dot_s(reg_tmp8, reg_tmp8);
    // 249: rsq
    reg_tmp14.x = rsq_s(reg_tmp14.x);
    // 250: mul
    reg_tmp14 = mul_s(reg_tmp8, reg_tmp14.xxxx);
    // 251: mov
    reg_tmp8 = uniforms.f[83];
    // 252: dp3
    reg_tmp6.x = dot_3(uniforms.f[90].xyz, reg_tmp8.xyz);
    // 253: dp3
    reg_tmp6.y = dot_3(uniforms.f[91].xyz, reg_tmp8.xyz);
    // 254: dp3
    reg_tmp6.z = dot_3(uniforms.f[92].xyz, reg_tmp8.xyz);
    // 255: add
    reg_tmp8.xyz = (reg_tmp6.xyzz + reg_tmp1.xyzz).xyz;
    // 256: mov
    reg_tmp8.w = (uniforms.f[93].xxxx).w;
    // 257: dp4
    reg_tmp0.x = dot_s(reg_tmp8, reg_tmp8);
    // 258: rsq
    reg_tmp0.x = rsq_s(reg_tmp0.x);
    // 259: mul
    reg_tmp0 = mul_s(reg_tmp8, reg_tmp0.xxxx);
    // 260: mov
    reg_tmp2 = uniforms.f[93].xxxx;
    // 261: ifu
    if (uniforms.b[9]) {
        sub_262_268();
    }
    // 268: ifu
    if (uniforms.b[7]) {
        sub_269_276();
    }
    // 276: ifu
    if (uniforms.b[8]) {
        sub_277_285();
    }
    // 285: mov
    vs_out_attr3 = reg_tmp2;
    return false;
}
bool sub_262_268() {
    // 262: dp3
    reg_tmp8.x = dot_3(reg_tmp14.xyz, -reg_tmp6.xyz);
    // 263: dp3
    reg_tmp8.y = dot_3(reg_tmp1.xyz, -reg_tmp6.xyz);
    // 264: max
    reg_tmp8 = max(uniforms.f[93].xxxx, reg_tmp8);
    // 265: mul
    reg_tmp8.y = (mul_s(uniforms.f[94].xxxx, reg_tmp8.yyyy)).y;
    // 266: add
    reg_tmp8.y = (uniforms.f[94].xxxx + reg_tmp8.yyyy).y;
    // 267: mul
    reg_tmp2.y = (mul_s(reg_tmp8.xxxx, reg_tmp8.yyyy)).y;
    return false;
}
bool sub_269_276() {
    // 269: dp3
    reg_tmp9.z = dot_3(reg_tmp14.xyz, reg_tmp0.xyz);
    // 270: max
    reg_tmp9.z = (max(uniforms.f[93].xxxx, reg_tmp9.zzzz)).z;
    // 271: min
    reg_tmp9.z = (min(uniforms.f[93].yyyy, reg_tmp9.zzzz)).z;
    // 272: log
    reg_tmp9.z = log2(reg_tmp9.z);
    // 273: mul
    reg_tmp9.z = (mul_s(uniforms.f[82].zzzz, reg_tmp9.zzzz)).z;
    // 274: exp
    reg_tmp9.z = exp2(reg_tmp9.z);
    // 275: mul
    reg_tmp2.z = (mul_s(uniforms.f[82].wwww, reg_tmp9.zzzz)).z;
    return false;
}
bool sub_277_285() {
    // 277: dp3
    reg_tmp9.x = dot_3(reg_tmp14.xyz, reg_tmp1.xyz);
    // 278: max
    reg_tmp9.x = (max(uniforms.f[93].xxxx, reg_tmp9.xxxx)).x;
    // 279: min
    reg_tmp9.x = (min(uniforms.f[93].yyyy, reg_tmp9.xxxx)).x;
    // 280: add
    reg_tmp9.x = (uniforms.f[93].yyyy + -reg_tmp9.xxxx).x;
    // 281: log
    reg_tmp9.x = log2(reg_tmp9.x);
    // 282: mul
    reg_tmp9.x = (mul_s(uniforms.f[82].xxxx, reg_tmp9.xxxx)).x;
    // 283: exp
    reg_tmp9.x = exp2(reg_tmp9.x);
    // 284: mul
    reg_tmp2.w = (mul_s(uniforms.f[82].yyyy, reg_tmp9.xxxx)).w;
    return false;
}
bool sub_286_4096() {
    // 286: ifu
    if (uniforms.b[10]) {
        sub_287_289();
    } else {
        sub_289_291();
    }
    // 291: ifu
    if (uniforms.b[1]) {
        sub_292_294();
    } else {
        sub_294_296();
    }
    // 296: call
    {
        sub_156_183();
    }
    // 297: call
    {
        sub_183_207();
    }
    // 298: call
    {
        sub_207_223();
    }
    // 299: end
    return true;
}
bool sub_287_289() {
    // 287: call
    {
        sub_65_116();
    }
    // 288: nop
    return false;
}
bool sub_289_291() {
    // 289: call
    {
        sub_116_156();
    }
    // 290: nop
    return false;
}
bool sub_292_294() {
    // 292: call
    {
        sub_242_286();
    }
    // 293: nop
    return false;
}
bool sub_294_296() {
    // 294: mov
    vs_out_attr3 = uniforms.f[93].yyyy;
    // 295: nop
    return false;
}
// reference: B96F17A96C6E8AA1, 3D6E7D97242068C9
// shader: 8B30, 890BFA36AB5D4BBE

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = 2.0 * (texcolor2).rgb - 1.0;
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(normal, normalize(view))));
refl_value.g = (lut_scale_rg * LookupLightingLUTSigned(5, dot(normal, normalize(view))));
refl_value.b = (lut_scale_rb * LookupLightingLUTSigned(4, dot(normal, normalize(view))));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor1.rgb) * (vec3(1.0) - const_color[0].aaa) + (const_color[0].rgb) * (vec3(1.0) - (vec3(1.0) - const_color[0].aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor1.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_1 = byteround(clamp((texcolor0.rgb) + (last_tex_env_out.rgb) - vec3(0.5), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (combiner_buffer.rgb) - vec3(0.5), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((secondary_fragment_color.r) * (1.0 - const_color[2].a) + (secondary_fragment_color.b) * (1.0 - (1.0 - const_color[2].a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((texcolor1.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((secondary_fragment_color.ggg) * (const_color[4].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 00F48736BAF0A252, 890BFA36AB5D4BBE
// program: 3D6E7D97242068C9, AD7922A63ED54CA7, 890BFA36AB5D4BBE
// reference: 6AECD05058EEB8A7, 3D6E7D97242068C9
// program: 3D6E7D97242068C9, AD7922A63ED54CA7, E9755AA7A48874E6
// shader: 8B30, 0CCD7A8F05449EBA

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = 2.0 * (texcolor2).rgb - 1.0;
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(normal, normalize(view))));
refl_value.g = (lut_scale_rg * LookupLightingLUTSigned(5, dot(normal, normalize(view))));
refl_value.b = (lut_scale_rb * LookupLightingLUTSigned(4, dot(normal, normalize(view))));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((secondary_fragment_color.r) * (1.0 - const_color[0].a) + (secondary_fragment_color.b) * (1.0 - (1.0 - const_color[0].a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((secondary_fragment_color.ggg) * (const_color[2].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((rounded_primary_color.aaa) * (const_color[3].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((texcolor1.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: FE0F5D31E87D96D8, 0CCD7A8F05449EBA
// program: 9D5547200C50254C, AD7922A63ED54CA7, 0CCD7A8F05449EBA
// shader: 8B30, 02EF419A88831FD1

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = 2.0 * (texcolor2).rgb - 1.0;
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(normal, normalize(view))));
refl_value.g = (lut_scale_rg * LookupLightingLUTSigned(5, dot(normal, normalize(view))));
refl_value.b = (lut_scale_rb * LookupLightingLUTSigned(4, dot(normal, normalize(view))));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((secondary_fragment_color.r) * (1.0 - const_color[0].a) + (secondary_fragment_color.b) * (1.0 - (1.0 - const_color[0].a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((secondary_fragment_color.ggg) * (const_color[2].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((texcolor2.a) * (const_color[2].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_3 = byteround(clamp((texcolor1.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((rounded_primary_color.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((rounded_primary_color.aaa) * (const_color[4].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp(min((combiner_buffer.aaa) + (const_color[5].rgb), vec3(1.0)) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: B83DE5C9FA1DA930, 02EF419A88831FD1
// program: 9D5547200C50254C, AD7922A63ED54CA7, 02EF419A88831FD1
// shader: 8B30, B62CF5048AD2C34C

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = 2.0 * (texcolor2).rgb - 1.0;
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(normal, normalize(view))));
refl_value.g = (lut_scale_rg * LookupLightingLUTSigned(5, dot(normal, normalize(view))));
refl_value.b = (lut_scale_rb * LookupLightingLUTSigned(4, dot(normal, normalize(view))));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((secondary_fragment_color.r) * (1.0 - const_color[0].a) + (secondary_fragment_color.b) * (1.0 - (1.0 - const_color[0].a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((secondary_fragment_color.ggg) * (last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((rounded_primary_color.g) * (const_color[2].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (texcolor1.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.aaa) * (const_color[4].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 4B64D36FDA37B8DB, B62CF5048AD2C34C
// program: 9D5547200C50254C, AD7922A63ED54CA7, B62CF5048AD2C34C
// shader: 8B30, D9F33D5C669B07C6

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = 2.0 * (texcolor2).rgb - 1.0;
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(normal, normalize(view))));
refl_value.g = (lut_scale_rg * LookupLightingLUTSigned(5, dot(normal, normalize(view))));
refl_value.b = (lut_scale_rb * LookupLightingLUTSigned(4, dot(normal, normalize(view))));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((secondary_fragment_color.r) * (1.0 - const_color[0].a) + (secondary_fragment_color.b) * (1.0 - (1.0 - const_color[0].a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((secondary_fragment_color.ggg) * (last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((texcolor1.a) * (texcolor2.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 025F771450084C5D, D9F33D5C669B07C6
// program: 9D5547200C50254C, AD7922A63ED54CA7, D9F33D5C669B07C6
// shader: 8B30, 36943105E0D66123

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = 2.0 * (texcolor2).rgb - 1.0;
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(normal, normalize(view))));
refl_value.g = (lut_scale_rg * LookupLightingLUTSigned(5, dot(normal, normalize(view))));
refl_value.b = (lut_scale_rb * LookupLightingLUTSigned(4, dot(normal, normalize(view))));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((secondary_fragment_color.r) * (1.0 - const_color[0].a) + (secondary_fragment_color.b) * (1.0 - (1.0 - const_color[0].a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((secondary_fragment_color.ggg) * (const_color[2].rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((rounded_primary_color.b) + (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((texcolor1.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a) + (secondary_fragment_color.g), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 6122AFA083698865, 36943105E0D66123
// program: 9D5547200C50254C, AD7922A63ED54CA7, 36943105E0D66123
// reference: 54A70577EF3997BE, 7C60AA2AD49029B7
// reference: FE6E8B86AB7ECF85, 9D5547200C50254C
// shader: 8B30, A518CEB00C7838B4

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = 2.0 * (texcolor2).rgb - 1.0;
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(normal, normalize(view))));
refl_value.g = (lut_scale_rg * LookupLightingLUTSigned(5, dot(normal, normalize(view))));
refl_value.b = (lut_scale_rb * LookupLightingLUTSigned(4, dot(normal, normalize(view))));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor1.rgb) * (vec3(1.0) - const_color[0].aaa) + (const_color[0].rgb) * (vec3(1.0) - (vec3(1.0) - const_color[0].aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor1.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_1 = byteround(clamp((texcolor0.rgb) + (last_tex_env_out.rgb) - vec3(0.5), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((secondary_fragment_color.r) * (texcolor2.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (combiner_buffer.rgb) - vec3(0.5), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (1.0 - const_color[2].a) + (secondary_fragment_color.b) * (1.0 - (1.0 - const_color[2].a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((texcolor1.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((secondary_fragment_color.ggg) * (last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 3DDDAAF7AE049C72, A518CEB00C7838B4
// program: 9D5547200C50254C, AD7922A63ED54CA7, A518CEB00C7838B4
// shader: 8B30, 49922377F516084C

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));

vec4 diffuse_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec4 specular_sum = vec4(0.0, 0.0, 0.0, 1.0);
vec3 light_vector = vec3(0.0);
vec3 refl_value = vec3(0.0);
vec3 spot_dir = vec3(0.0);
vec3 half_vector = vec3(0.0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = 2.0 * (texcolor2).rgb - 1.0;
vec3 surface_tangent = vec3(1.0, 0.0, 0.0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = quaternion_rotate(normalized_normquat, surface_normal);
vec3 tangent = quaternion_rotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1.0);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(normal, normalize(view))));
refl_value.g = (lut_scale_rg * LookupLightingLUTSigned(5, dot(normal, normalize(view))));
refl_value.b = (lut_scale_rb * LookupLightingLUTSigned(4, dot(normal, normalize(view))));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0.0), vec4(1.0));
secondary_fragment_color = clamp(specular_sum, vec4(0.0), vec4(1.0));

vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor1.rgb) * (vec3(1.0) - const_color[0].aaa) + (const_color[0].rgb) * (vec3(1.0) - (vec3(1.0) - const_color[0].aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor1.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;

vec3 color_output_1 = byteround(clamp((texcolor0.rgb) + (last_tex_env_out.rgb) - vec3(0.5), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (combiner_buffer.rgb) - vec3(0.5), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp((secondary_fragment_color.r) * (1.0 - const_color[2].a) + (secondary_fragment_color.b) * (1.0 - (1.0 - const_color[2].a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (last_tex_env_out.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((texcolor1.a) * (texcolor2.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((secondary_fragment_color.ggg) * (last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

if (int(last_tex_env_out.a * 255.0) <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 0B93AEB2B8DE43C7, 49922377F516084C
// program: 9D5547200C50254C, AD7922A63ED54CA7, 49922377F516084C
// reference: FE6E8B86151424A5, AC576E32BE8CFA08
// program: AC576E32BE8CFA08, AD7922A63ED54CA7, 49922377F516084C
// program: 93C50366EC4126B4, 5D764F9A6220D694, 123F0FE36A723C20
// program: 93C50366EC4126B4, 5D764F9A6220D694, 4657CF2A14DE8C15
// program: 93C50366EC4126B4, 5D764F9A6220D694, E914533DE99D512D
// reference: 6CF5F27753743303, 93C50366EC4126B4
// program: 93C50366EC4126B4, 5D764F9A6220D694, 74485CA8ECCCD7D1
// program: 93C50366EC4126B4, 5D764F9A6220D694, D7797AFBADAE290D
// program: 93C50366EC4126B4, 5D764F9A6220D694, BB6E26E3E8A05095
// program: 93C50366EC4126B4, 5D764F9A6220D694, 2B21A85C45180294
// program: 93C50366EC4126B4, 5D764F9A6220D694, D59F8A0C39F6E702
// reference: 8724C28E65D34E98, 07A736992979F928
// reference: 54A7057751537C9E, 07A736992979F928
// reference: 2DED4C7F219416A3, AC576E32BE8CFA08
// program: AC576E32BE8CFA08, AD7922A63ED54CA7, A518CEB00C7838B4
// reference: 54A705771EA938D5, 07A736992979F928
// reference: FE6E8B865AEE60EE, AC576E32BE8CFA08
// program: AC576E32BE8CFA08, AD7922A63ED54CA7, 0CCD7A8F05449EBA
// program: AC576E32BE8CFA08, AD7922A63ED54CA7, 02EF419A88831FD1
// program: AC576E32BE8CFA08, AD7922A63ED54CA7, B62CF5048AD2C34C
// program: AC576E32BE8CFA08, AD7922A63ED54CA7, D9F33D5C669B07C6
// program: AC576E32BE8CFA08, AD7922A63ED54CA7, 36943105E0D66123
// shader: 8B31, EB7A0052EF8DFB2C

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;
layout(location = 4) in vec4 vs_in_reg4;
layout(location = 5) in vec4 vs_in_reg5;
layout(location = 6) in vec4 vs_in_reg6;
layout(location = 7) in vec4 vs_in_reg7;
layout(location = 8) in vec4 vs_in_reg8;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;
 out vec4 vs_out_attr3;
 out vec4 vs_out_attr4;
 out vec4 vs_out_attr5;
 out vec4 vs_out_attr6;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr3 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr4 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr5 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr6 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}


#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define mul_3(x, y) mix(x * y, vec3(0.0), isnan(x * y))
#define fma_s(x, y, z) (mul_s(x, y) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(mul_3(x, y), vec3(1.0))

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_19();
bool sub_19_29();
bool sub_29_51();
bool sub_51_65();
bool sub_65_116();
bool sub_88_92();
bool sub_114_115();
bool sub_116_156();
bool sub_133_137();
bool sub_154_155();
bool sub_156_183();
bool sub_158_163();
bool sub_163_182();
bool sub_166_172();
bool sub_172_181();
bool sub_173_177();
bool sub_177_180();
bool sub_183_207();
bool sub_185_189();
bool sub_189_206();
bool sub_190_204();
bool sub_193_200();
bool sub_200_203();
bool sub_204_205();
bool sub_207_223();
bool sub_209_213();
bool sub_213_222();
bool sub_214_220();
bool sub_220_221();
bool sub_223_231();
bool sub_225_226();
bool sub_226_230();
bool sub_227_228();
bool sub_228_229();
bool sub_231_238();
bool sub_238_242();
bool sub_242_286();
bool sub_262_268();
bool sub_269_276();
bool sub_277_285();
bool sub_286_4096();
bool sub_287_289();
bool sub_289_291();
bool sub_292_294();
bool sub_294_296();

bool exec_shader() {
    sub_286_4096();
    return true;
}

bool sub_0_19() {
    uint jmp_to = 0u;
    while (true) {
        switch (jmp_to) {
        case 0u: {
            // 0: dp3
            reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
            // 1: dp3
            reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
            // 2: dp3
            reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
            // 3: dp3
            reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
            // 4: dp3
            reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
            // 5: rsq
            reg_tmp6.x = rsq_s(reg_tmp6.x);
            // 6: rsq
            reg_tmp7.x = rsq_s(reg_tmp7.x);
            // 7: mul
            reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
            // 8: mul
            reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
            // 9: mov
            reg_tmp0 = uniforms.f[93].yxxx;
            // 10: add
            reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
            // 11: mul
            reg_tmp4 = mul_s(uniforms.f[94].xxxx, reg_tmp4);
            // 12: cmp
            conditional_code = greaterThanEqual(uniforms.f[93].xx, reg_tmp4.xx);
            // 13: rsq
            reg_tmp4 = vec4(rsq_s(reg_tmp4.x));
            // 14: mul
            reg_tmp5 = mul_s(uniforms.f[94].xxxx, reg_tmp14);
            // 15: jmpc
            if (conditional_code.x) {
                { jmp_to = 18u; break; }
            }
            // 16: rcp
            reg_tmp0.z = rcp_s(reg_tmp4.x);
            // 17: mul
            reg_tmp0.xy = (mul_s(reg_tmp5, reg_tmp4)).xy;
        }
        case 18u: {
            // 18: mov
            vs_out_attr1 = reg_tmp0;
        }
        default: return false;
        }
    }
    return false;
}
bool sub_19_29() {
    // 19: mova
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    // 20: nop
    // 21: dp4
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    // 22: dp4
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    // 23: dp4
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    // 24: dp3
    reg_tmp4.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    // 25: dp3
    reg_tmp4.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    // 26: dp3
    reg_tmp4.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    // 27: mad
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 28: mad
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
    return false;
}
bool sub_29_51() {
    // 29: mova
    address_registers.x = (ivec2(reg_tmp1.xx)).x;
    // 30: nop
    // 31: dp4
    reg_tmp3.x = dot_s(uniforms.f[10 + address_registers.x], reg_tmp15);
    // 32: dp4
    reg_tmp3.y = dot_s(uniforms.f[11 + address_registers.x], reg_tmp15);
    // 33: dp4
    reg_tmp3.z = dot_s(uniforms.f[12 + address_registers.x], reg_tmp15);
    // 34: mad
    reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
    // 35: dp3
    reg_tmp3.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp14.xyz);
    // 36: dp3
    reg_tmp3.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp14.xyz);
    // 37: dp3
    reg_tmp3.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp14.xyz);
    // 38: mad
    reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp12);
    // 39: dp3
    reg_tmp3.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp13.xyz);
    // 40: dp3
    reg_tmp3.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp13.xyz);
    // 41: dp3
    reg_tmp3.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp13.xyz);
    // 42: mad
    reg_tmp11 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp11);
    // 43: dp3
    reg_tmp3.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp5.xyz);
    // 44: dp3
    reg_tmp3.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp5.xyz);
    // 45: dp3
    reg_tmp3.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp5.xyz);
    // 46: mad
    reg_tmp9 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp9);
    // 47: dp3
    reg_tmp3.x = dot_3(uniforms.f[10 + address_registers.x].xyz, reg_tmp6.xyz);
    // 48: dp3
    reg_tmp3.y = dot_3(uniforms.f[11 + address_registers.x].xyz, reg_tmp6.xyz);
    // 49: dp3
    reg_tmp3.z = dot_3(uniforms.f[12 + address_registers.x].xyz, reg_tmp6.xyz);
    // 50: mad
    reg_tmp8 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp8);
    return false;
}
bool sub_51_65() {
    // 51: mul
    reg_tmp0.xyz = (mul_s(reg_tmp9.yzxx, reg_tmp8.zxyy)).xyz;
    // 52: mad
    reg_tmp0.xyz = (fma_s(-reg_tmp8.yzxx, reg_tmp9.zxyy, reg_tmp0)).xyz;
    // 53: mov
    reg_tmp1 = uniforms.f[83];
    // 54: dp4
    reg_tmp2.x = dot_s(reg_tmp1.xyzz, reg_tmp1.xyzz);
    // 55: rsq
    reg_tmp2.x = rsq_s(reg_tmp2.x);
    // 56: mul
    reg_tmp2.xyz = (mul_s(reg_tmp1.xyzz, reg_tmp2.xxxx)).xyz;
    // 57: dp3
    reg_tmp1.x = dot_3(reg_tmp2.xyz, reg_tmp8.xyz);
    // 58: dp3
    reg_tmp1.y = dot_3(reg_tmp2.xyz, reg_tmp0.xyz);
    // 59: dp3
    reg_tmp1.z = dot_3(reg_tmp2.xyz, reg_tmp9.xyz);
    // 60: dp4
    reg_tmp2.x = dot_s(reg_tmp1.xyzz, reg_tmp1.xyzz);
    // 61: rsq
    reg_tmp2.x = rsq_s(reg_tmp2.x);
    // 62: mul
    reg_tmp2.xyz = (mul_s(reg_tmp1.xyzz, reg_tmp2.xxxx)).xyz;
    // 63: mov
    reg_tmp2.w = (uniforms.f[93].yyyy).w;
    // 64: mov
    vs_out_attr2 = reg_tmp2;
    return false;
}
bool sub_65_116() {
    // 65: mov
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    // 66: mov
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    // 67: mov
    reg_tmp13.xyz = (vs_in_reg2).xyz;
    // 68: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 69: mov
    reg_tmp5 = uniforms.f[93].xxyy;
    // 70: mov
    reg_tmp6 = uniforms.f[93].yxxy;
    // 71: mov
    reg_tmp7 = uniforms.f[93].xxxx;
    // 72: mov
    reg_tmp12 = uniforms.f[93].xxxx;
    // 73: mov
    reg_tmp11 = uniforms.f[93].xxxx;
    // 74: mov
    reg_tmp9 = uniforms.f[93].xxxx;
    // 75: mov
    reg_tmp8 = uniforms.f[93].xxxx;
    // 76: mul
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    // 77: cmp
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    // 78: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 79: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    // 80: call
    {
        sub_29_51();
    }
    // 81: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 82: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    // 83: call
    {
        sub_29_51();
    }
    // 84: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 85: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    // 86: callc
    if (conditional_code.x) {
        sub_29_51();
    }
    // 87: ifu
    if (uniforms.b[11]) {
        sub_88_92();
    }
    // 92: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 93: mov
    reg_tmp10 = reg_tmp7;
    // 94: dp3
    reg_tmp13.x = dot_3(uniforms.f[90].xyz, reg_tmp11.xyz);
    // 95: dp3
    reg_tmp13.y = dot_3(uniforms.f[91].xyz, reg_tmp11.xyz);
    // 96: dp3
    reg_tmp13.z = dot_3(uniforms.f[92].xyz, reg_tmp11.xyz);
    // 97: dp3
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    // 98: dp3
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    // 99: dp3
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    // 100: dp4
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    // 101: dp4
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    // 102: dp4
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    // 103: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 104: call
    {
        sub_51_65();
    }
    // 105: mov
    vs_out_attr1 = uniforms.f[93].xxxy;
    // 106: dp4
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    // 107: dp4
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    // 108: dp4
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    // 109: dp4
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    // 110: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 111: mul
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    // 112: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 113: ifc
    if (all(conditional_code)) {
        sub_114_115();
    }
    // 115: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_88_92() {
    // 88: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 89: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    // 90: callc
    if (conditional_code.y) {
        sub_29_51();
    }
    // 91: nop
    return false;
}
bool sub_114_115() {
    // 114: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_116_156() {
    // 116: mov
    reg_tmp15.xyz = (vs_in_reg0).xyz;
    // 117: mov
    reg_tmp14.xyz = (vs_in_reg1).xyz;
    // 118: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 119: mov
    reg_tmp7 = uniforms.f[93].xxxx;
    // 120: mov
    reg_tmp12 = uniforms.f[93].xxxx;
    // 121: mul
    reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
    // 122: cmp
    conditional_code = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
    // 123: mov
    reg_tmp1.xy = (reg_tmp2.xxxx).xy;
    // 124: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.xxxx)).w;
    // 125: call
    {
        sub_19_29();
    }
    // 126: mov
    reg_tmp1.xy = (reg_tmp2.yyyy).xy;
    // 127: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.yyyy)).w;
    // 128: call
    {
        sub_19_29();
    }
    // 129: mov
    reg_tmp1.xy = (reg_tmp2.zzzz).xy;
    // 130: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.zzzz)).w;
    // 131: callc
    if (conditional_code.x) {
        sub_19_29();
    }
    // 132: ifu
    if (uniforms.b[11]) {
        sub_133_137();
    }
    // 137: mov
    reg_tmp7.w = (uniforms.f[93].yyyy).w;
    // 138: mov
    reg_tmp10 = reg_tmp7;
    // 139: dp4
    reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
    // 140: dp4
    reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
    // 141: dp4
    reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
    // 142: mov
    reg_tmp15.w = (uniforms.f[93].yyyy).w;
    // 143: call
    {
        sub_0_19();
    }
    // 144: nop
    // 145: mov
    vs_out_attr2 = reg_tmp15;
    // 146: dp4
    reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
    // 147: dp4
    reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
    // 148: dp4
    reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
    // 149: dp4
    reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
    // 150: mov
    reg_tmp1.x = (-reg_tmp0.wwww).x;
    // 151: mul
    reg_tmp1.y = (mul_s(uniforms.f[94].yyyy, -reg_tmp0.wwww)).y;
    // 152: cmp
    conditional_code.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
    conditional_code.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
    // 153: ifc
    if (all(conditional_code)) {
        sub_154_155();
    }
    // 155: mov
    vs_out_attr0 = reg_tmp0;
    return false;
}
bool sub_133_137() {
    // 133: mov
    reg_tmp1.xy = (reg_tmp2.wwww).xy;
    // 134: mul
    reg_tmp1.w = (mul_s(uniforms.f[94].zzzz, vs_in_reg8.wwww)).w;
    // 135: callc
    if (conditional_code.y) {
        sub_19_29();
    }
    // 136: nop
    return false;
}
bool sub_154_155() {
    // 154: mov
    reg_tmp0.x = (-reg_tmp0.wwww).x;
    return false;
}
bool sub_156_183() {
    // 156: mov
    reg_tmp0.xy = (uniforms.f[0].xxxx).xy;
    // 157: ifu
    if (uniforms.b[2]) {
        sub_158_163();
    } else {
        sub_163_182();
    }
    // 182: nop
    return false;
}
bool sub_158_163() {
    // 158: call
    {
        sub_223_231();
    }
    // 159: dp4
    reg_tmp3.x = dot_s(uniforms.f[1].xywz, reg_tmp6);
    // 160: dp4
    reg_tmp3.y = dot_s(uniforms.f[2].xywz, reg_tmp6);
    // 161: mov
    reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
    // 162: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_163_182() {
    // 163: cmp
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    // 164: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 165: ifc
    if (all(not(conditional_code))) {
        sub_166_172();
    } else {
        sub_172_181();
    }
    // 181: mov
    vs_out_attr4 = reg_tmp3;
    return false;
}
bool sub_166_172() {
    // 166: mov
    reg_tmp6 = reg_tmp10;
    // 167: dp4
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    // 168: dp4
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    // 169: dp4
    reg_tmp3.z = dot_s(uniforms.f[3], reg_tmp6);
    // 170: mul
    reg_tmp0.xy = (mul_s(uniforms.f[9].xyyy, reg_tmp3.zzzz)).xy;
    // 171: add
    reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
    return false;
}
bool sub_172_181() {
    // 172: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_173_177();
    } else {
        sub_177_180();
    }
    // 180: nop
    return false;
}
bool sub_173_177() {
    // 173: call
    {
        sub_231_238();
    }
    // 174: dp3
    reg_tmp3.x = dot_3(uniforms.f[1].xyz, reg_tmp6.xyz);
    // 175: dp3
    reg_tmp3.y = dot_3(uniforms.f[2].xyz, reg_tmp6.xyz);
    // 176: dp3
    reg_tmp3.z = dot_3(uniforms.f[3].xyz, reg_tmp6.xyz);
    return false;
}
bool sub_177_180() {
    // 177: call
    {
        sub_238_242();
    }
    // 178: dp4
    reg_tmp3.x = dot_s(uniforms.f[1], reg_tmp6);
    // 179: dp4
    reg_tmp3.y = dot_s(uniforms.f[2], reg_tmp6);
    return false;
}
bool sub_183_207() {
    // 183: mov
    reg_tmp0.xy = (uniforms.f[0].yyyy).xy;
    // 184: ifu
    if (uniforms.b[3]) {
        sub_185_189();
    } else {
        sub_189_206();
    }
    // 206: nop
    return false;
}
bool sub_185_189() {
    // 185: call
    {
        sub_223_231();
    }
    // 186: dp4
    reg_tmp4.x = dot_s(uniforms.f[4].xywz, reg_tmp6);
    // 187: dp4
    reg_tmp4.y = dot_s(uniforms.f[5].xywz, reg_tmp6);
    // 188: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_189_206() {
    // 189: ifu
    if (uniforms.b[5]) {
        sub_190_204();
    } else {
        sub_204_205();
    }
    // 205: nop
    return false;
}
bool sub_190_204() {
    // 190: cmp
    conditional_code = equal(uniforms.f[95].xy, reg_tmp0.xy);
    // 191: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 192: ifc
    if (all(not(conditional_code))) {
        sub_193_200();
    } else {
        sub_200_203();
    }
    // 203: mov
    vs_out_attr5 = reg_tmp4;
    return false;
}
bool sub_193_200() {
    // 193: mov
    reg_tmp6 = reg_tmp10;
    // 194: dp4
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    // 195: dp4
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    // 196: dp4
    reg_tmp4.z = dot_s(uniforms.f[6], reg_tmp6);
    // 197: rcp
    reg_tmp6.w = rcp_s(reg_tmp4.z);
    // 198: mul
    reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
    // 199: add
    reg_tmp4.xy = (uniforms.f[9].zwww + reg_tmp4.xyyy).xy;
    return false;
}
bool sub_200_203() {
    // 200: call
    {
        sub_238_242();
    }
    // 201: dp4
    reg_tmp4.x = dot_s(uniforms.f[4], reg_tmp6);
    // 202: dp4
    reg_tmp4.y = dot_s(uniforms.f[5], reg_tmp6);
    return false;
}
bool sub_204_205() {
    // 204: mov
    vs_out_attr5 = uniforms.f[93].xxxx;
    return false;
}
bool sub_207_223() {
    // 207: mov
    reg_tmp0.xy = (uniforms.f[0].zzzz).xy;
    // 208: ifu
    if (uniforms.b[4]) {
        sub_209_213();
    } else {
        sub_213_222();
    }
    // 222: nop
    return false;
}
bool sub_209_213() {
    // 209: call
    {
        sub_223_231();
    }
    // 210: dp4
    reg_tmp5.x = dot_s(uniforms.f[7].xywz, reg_tmp6);
    // 211: dp4
    reg_tmp5.y = dot_s(uniforms.f[8].xywz, reg_tmp6);
    // 212: mov
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_213_222() {
    // 213: ifu
    if (uniforms.b[6]) {
        sub_214_220();
    } else {
        sub_220_221();
    }
    // 221: nop
    return false;
}
bool sub_214_220() {
    // 214: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    // 215: mov
    reg_tmp5.zw = (reg_tmp6.zwww).zw;
    // 216: call
    {
        sub_238_242();
    }
    // 217: dp4
    reg_tmp5.x = dot_s(uniforms.f[7], reg_tmp6);
    // 218: dp4
    reg_tmp5.y = dot_s(uniforms.f[8], reg_tmp6);
    // 219: mov
    vs_out_attr6 = reg_tmp5;
    return false;
}
bool sub_220_221() {
    // 220: mov
    vs_out_attr6 = uniforms.f[93].xxxx;
    return false;
}
bool sub_223_231() {
    // 223: cmp
    conditional_code = equal(uniforms.f[93].yz, reg_tmp0.xy);
    // 224: ifc
    if (all(not(conditional_code))) {
        sub_225_226();
    } else {
        sub_226_230();
    }
    // 230: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_225_226() {
    // 225: mov
    reg_tmp6.xy = (vs_in_reg4.xyyy).xy;
    return false;
}
bool sub_226_230() {
    // 226: ifc
    if (all(bvec2(conditional_code.x, !conditional_code.y))) {
        sub_227_228();
    } else {
        sub_228_229();
    }
    // 229: nop
    return false;
}
bool sub_227_228() {
    // 227: mov
    reg_tmp6.xy = (vs_in_reg5.xyyy).xy;
    return false;
}
bool sub_228_229() {
    // 228: mov
    reg_tmp6.xy = (vs_in_reg6.xyyy).xy;
    return false;
}
bool sub_231_238() {
    // 231: mov
    reg_tmp2 = -reg_tmp15;
    // 232: dp3
    reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
    // 233: rsq
    reg_tmp2.w = rsq_s(reg_tmp2.w);
    // 234: mul
    reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
    // 235: dp3
    reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
    // 236: add
    reg_tmp1 = reg_tmp1 + reg_tmp1;
    // 237: mad
    reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
    return false;
}
bool sub_238_242() {
    // 238: mov
    reg_tmp1.xy = (uniforms.f[94].xxxx).xy;
    // 239: mov
    reg_tmp1.zw = (uniforms.f[93].xxxx).zw;
    // 240: mad
    reg_tmp6 = fma_s(reg_tmp14, reg_tmp1, reg_tmp1);
    // 241: mov
    reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
    return false;
}
bool sub_242_286() {
    // 242: mov
    reg_tmp1.xyz = (uniforms.f[93].xxyx).xyz;
    // 243: dp3
    reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
    // 244: dp3
    reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
    // 245: dp3
    reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
    // 246: mov
    reg_tmp14.w = (uniforms.f[93].xxxx).w;
    // 247: mov
    reg_tmp8 = reg_tmp14;
    // 248: dp4
    reg_tmp14.x = dot_s(reg_tmp8, reg_tmp8);
    // 249: rsq
    reg_tmp14.x = rsq_s(reg_tmp14.x);
    // 250: mul
    reg_tmp14 = mul_s(reg_tmp8, reg_tmp14.xxxx);
    // 251: mov
    reg_tmp8 = uniforms.f[83];
    // 252: dp3
    reg_tmp6.x = dot_3(uniforms.f[90].xyz, reg_tmp8.xyz);
    // 253: dp3
    reg_tmp6.y = dot_3(uniforms.f[91].xyz, reg_tmp8.xyz);
    // 254: dp3
    reg_tmp6.z = dot_3(uniforms.f[92].xyz, reg_tmp8.xyz);
    // 255: add
    reg_tmp8.xyz = (reg_tmp6.xyzz + reg_tmp1.xyzz).xyz;
    // 256: mov
    reg_tmp8.w = (uniforms.f[93].xxxx).w;
    // 257: dp4
    reg_tmp0.x = dot_s(reg_tmp8, reg_tmp8);
    // 258: rsq
    reg_tmp0.x = rsq_s(reg_tmp0.x);
    // 259: mul
    reg_tmp0 = mul_s(reg_tmp8, reg_tmp0.xxxx);
    // 260: mov
    reg_tmp2 = uniforms.f[93].xxxx;
    // 261: ifu
    if (uniforms.b[9]) {
        sub_262_268();
    }
    // 268: ifu
    if (uniforms.b[7]) {
        sub_269_276();
    }
    // 276: ifu
    if (uniforms.b[8]) {
        sub_277_285();
    }
    // 285: mov
    vs_out_attr3 = reg_tmp2;
    return false;
}
bool sub_262_268() {
    // 262: dp3
    reg_tmp8.x = dot_3(reg_tmp14.xyz, -reg_tmp6.xyz);
    // 263: dp3
    reg_tmp8.y = dot_3(reg_tmp1.xyz, -reg_tmp6.xyz);
    // 264: max
    reg_tmp8 = max(uniforms.f[93].xxxx, reg_tmp8);
    // 265: mul
    reg_tmp8.y = (mul_s(uniforms.f[94].xxxx, reg_tmp8.yyyy)).y;
    // 266: add
    reg_tmp8.y = (uniforms.f[94].xxxx + reg_tmp8.yyyy).y;
    // 267: mul
    reg_tmp2.y = (mul_s(reg_tmp8.xxxx, reg_tmp8.yyyy)).y;
    return false;
}
bool sub_269_276() {
    // 269: dp3
    reg_tmp9.z = dot_3(reg_tmp14.xyz, reg_tmp0.xyz);
    // 270: max
    reg_tmp9.z = (max(uniforms.f[93].xxxx, reg_tmp9.zzzz)).z;
    // 271: min
    reg_tmp9.z = (min(uniforms.f[93].yyyy, reg_tmp9.zzzz)).z;
    // 272: log
    reg_tmp9.z = log2(reg_tmp9.z);
    // 273: mul
    reg_tmp9.z = (mul_s(uniforms.f[82].zzzz, reg_tmp9.zzzz)).z;
    // 274: exp
    reg_tmp9.z = exp2(reg_tmp9.z);
    // 275: mul
    reg_tmp2.z = (mul_s(uniforms.f[82].wwww, reg_tmp9.zzzz)).z;
    return false;
}
bool sub_277_285() {
    // 277: dp3
    reg_tmp9.x = dot_3(reg_tmp14.xyz, reg_tmp1.xyz);
    // 278: max
    reg_tmp9.x = (max(uniforms.f[93].xxxx, reg_tmp9.xxxx)).x;
    // 279: min
    reg_tmp9.x = (min(uniforms.f[93].yyyy, reg_tmp9.xxxx)).x;
    // 280: add
    reg_tmp9.x = (uniforms.f[93].yyyy + -reg_tmp9.xxxx).x;
    // 281: log
    reg_tmp9.x = log2(reg_tmp9.x);
    // 282: mul
    reg_tmp9.x = (mul_s(uniforms.f[82].xxxx, reg_tmp9.xxxx)).x;
    // 283: exp
    reg_tmp9.x = exp2(reg_tmp9.x);
    // 284: mul
    reg_tmp2.w = (mul_s(uniforms.f[82].yyyy, reg_tmp9.xxxx)).w;
    return false;
}
bool sub_286_4096() {
    // 286: ifu
    if (uniforms.b[10]) {
        sub_287_289();
    } else {
        sub_289_291();
    }
    // 291: ifu
    if (uniforms.b[1]) {
        sub_292_294();
    } else {
        sub_294_296();
    }
    // 296: call
    {
        sub_156_183();
    }
    // 297: call
    {
        sub_183_207();
    }
    // 298: call
    {
        sub_207_223();
    }
    // 299: end
    return true;
}
bool sub_287_289() {
    // 287: call
    {
        sub_65_116();
    }
    // 288: nop
    return false;
}
bool sub_289_291() {
    // 289: call
    {
        sub_116_156();
    }
    // 290: nop
    return false;
}
bool sub_292_294() {
    // 292: call
    {
        sub_242_286();
    }
    // 293: nop
    return false;
}
bool sub_294_296() {
    // 294: mov
    vs_out_attr3 = uniforms.f[93].yyyy;
    // 295: nop
    return false;
}
// reference: B96F17A99DFE25CA, EB7A0052EF8DFB2C
// program: EB7A0052EF8DFB2C, AD7922A63ED54CA7, 890BFA36AB5D4BBE
// reference: 6AECD050A97E17CC, EB7A0052EF8DFB2C
// program: EB7A0052EF8DFB2C, AD7922A63ED54CA7, E9755AA7A48874E6
// shader: 8B30, 59477F1BD550667D

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (combiner_buffer.rgb) + (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp(min((texcolor0.a) + (1.0 - texcolor2.a), 1.0) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 354429B8924D7B49, 59477F1BD550667D
// program: 93C50366EC4126B4, 5D764F9A6220D694, 59477F1BD550667D
// shader: 8B30, C25F1668778DC04B

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (combiner_buffer.rgb) + (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp(min((texcolor0.a) + (1.0 - texcolor2.a), 1.0) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 354429B8997A815D, C25F1668778DC04B
// program: 93C50366EC4126B4, 5D764F9A6220D694, C25F1668778DC04B
// shader: 8B30, DF8EC48EE028D30C

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].aaa), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (combiner_buffer.rgb) + (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp(min((texcolor0.a) + (1.0 - texcolor2.a), 1.0) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 05FC36F33AD7FD74, DF8EC48EE028D30C
// program: 93C50366EC4126B4, 5D764F9A6220D694, DF8EC48EE028D30C
// shader: 8B30, 5615A1000836B757

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (combiner_buffer.rgb) + (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp(min((texcolor0.a) + (1.0 - texcolor2.a), 1.0) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 354429B8629AF0E4, 5615A1000836B757
// program: 93C50366EC4126B4, 5D764F9A6220D694, 5615A1000836B757
// reference: 354429B8C1378CCD, C25F1668778DC04B
// shader: 8B30, 39CE430EA67AF811

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (combiner_buffer.rgb) + (const_color[2].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_2 = byteround(clamp(min((texcolor0.a) + (1.0 - texcolor2.a), 1.0) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_2, alpha_output_2), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 354429B869AD0AF0, 39CE430EA67AF811
// program: 93C50366EC4126B4, 5D764F9A6220D694, 39CE430EA67AF811
// program: 93C50366EC4126B4, 5D764F9A6220D694, 8C813175D6234E0E
// program: 93C50366EC4126B4, 5D764F9A6220D694, 73C03B06CE3D4B69
// program: 93C50366EC4126B4, 5D764F9A6220D694, F4D9D3A0C323B133
// program: 93C50366EC4126B4, 5D764F9A6220D694, 6D52E90095B6681D
// program: 93C50366EC4126B4, 5D764F9A6220D694, 1CDC4206D78F8E5B
// shader: 8B31, A506431ADA7A8BF4

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout (std140) uniform vs_config {
    pica_uniforms uniforms;
};

layout(location = 0) in vec4 vs_in_reg0;
layout(location = 1) in vec4 vs_in_reg1;
layout(location = 2) in vec4 vs_in_reg2;

 out vec4 vs_out_attr0;
 out vec4 vs_out_attr1;
 out vec4 vs_out_attr2;

void main() {
    vs_out_attr0 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr1 = vec4(0.0, 0.0, 0.0, 1.0);
    vs_out_attr2 = vec4(0.0, 0.0, 0.0, 1.0);

    exec_shader();
}


#define mul_s(x, y) mix(x * y, vec4(0.0), isnan(x * y))
#define mul_3(x, y) mix(x * y, vec3(0.0), isnan(x * y))
#define fma_s(x, y, z) (mul_s(x, y) + z)
float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x > 0.0) return inversesqrt(x);
    return 0.0;
}
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(mul_3(x, y), vec3(1.0))

bvec2 conditional_code = bvec2(false);
ivec3 address_registers = ivec3(0);
vec4 reg_tmp0 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp1 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp2 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp3 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp4 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp5 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp6 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp7 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp8 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp9 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp10 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp11 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp12 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp13 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp14 = vec4(0.0, 0.0, 0.0, 1.0);
vec4 reg_tmp15 = vec4(0.0, 0.0, 0.0, 1.0);

bool sub_0_12();
bool sub_13_4096();

bool exec_shader() {
    sub_13_4096();
    return true;
}

bool sub_0_12() {
    // 0: dp4
    reg_tmp0.x = dot_s(uniforms.f[8], vs_in_reg0);
    // 1: dp4
    reg_tmp0.y = dot_s(uniforms.f[9], vs_in_reg0);
    // 2: dp4
    reg_tmp0.z = dot_s(uniforms.f[10], vs_in_reg0);
    // 3: dp4
    reg_tmp0.w = dot_s(uniforms.f[11], vs_in_reg0);
    // 4: dp4
    reg_tmp1.x = dot_s(uniforms.f[4], reg_tmp0);
    // 5: dp4
    reg_tmp1.y = dot_s(uniforms.f[5], reg_tmp0);
    // 6: dp4
    reg_tmp1.z = dot_s(uniforms.f[6], reg_tmp0);
    // 7: dp4
    reg_tmp1.w = dot_s(uniforms.f[7], reg_tmp0);
    // 8: dp4
    vs_out_attr0.x = dot_s(uniforms.f[0], reg_tmp1);
    // 9: dp4
    vs_out_attr0.y = dot_s(uniforms.f[1], reg_tmp1);
    // 10: dp4
    vs_out_attr0.z = dot_s(uniforms.f[2], reg_tmp1);
    // 11: dp4
    vs_out_attr0.w = dot_s(uniforms.f[3], reg_tmp1);
    return false;
}
bool sub_13_4096() {
    // 13: call
    {
        sub_0_12();
    }
    // 14: mov
    vs_out_attr1 = vs_in_reg1;
    // 15: mul
    vs_out_attr2 = mul_s(uniforms.f[12], vs_in_reg2);
    // 16: end
    return true;
}
// reference: 80F7C59C0440B628, A506431ADA7A8BF4
// shader: 8DD9, 6073F2A2E32CD1D3

layout(triangles) in;
layout(triangle_strip, max_vertices = 3) out;

out vec4 primary_color;
out vec2 texcoord0;
out vec2 texcoord1;
out vec2 texcoord2;
out float texcoord0_w;
out vec4 normquat;
out vec3 view;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

 in vec4 vs_out_attr0[];
 in vec4 vs_out_attr1[];
 in vec4 vs_out_attr2[];

struct Vertex {
    vec4 attributes[3];
};

vec4 GetVertexQuaternion(Vertex vtx) {
    return vec4(0.0, 0.0, 0.0, 0.0);
}

void EmitVtx(Vertex vtx, bool quats_opposite) {
    vec4 vtx_pos = vec4(vtx.attributes[0].x, vtx.attributes[0].y, vtx.attributes[0].z, vtx.attributes[0].w);
    gl_Position = vtx_pos;
#if !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)
    gl_ClipDistance[0] = -vtx_pos.z;
    gl_ClipDistance[1] = dot(clip_coef, vtx_pos);
#endif // !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)

    vec4 vtx_quat = GetVertexQuaternion(vtx);
    normquat = mix(vtx_quat, -vtx_quat, bvec4(quats_opposite));

    vec4 vtx_color = vec4(vtx.attributes[2].x, vtx.attributes[2].y, vtx.attributes[2].z, vtx.attributes[2].w);
    primary_color = min(abs(vtx_color), vec4(1.0));

    texcoord0 = vec2(vtx.attributes[1].x, vtx.attributes[1].y);
    texcoord1 = vec2(0.0, 0.0);

    texcoord0_w = 0.0;
    view = vec3(0.0, 0.0, 0.0);

    texcoord2 = vec2(0.0, 0.0);

    EmitVertex();
}

bool AreQuaternionsOpposite(vec4 qa, vec4 qb) {
    return (dot(qa, qb) < 0.0);
}

void EmitPrim(Vertex vtx0, Vertex vtx1, Vertex vtx2) {
    EmitVtx(vtx0, false);
    EmitVtx(vtx1, AreQuaternionsOpposite(GetVertexQuaternion(vtx0), GetVertexQuaternion(vtx1)));
    EmitVtx(vtx2, AreQuaternionsOpposite(GetVertexQuaternion(vtx0), GetVertexQuaternion(vtx2)));
    EndPrimitive();
}

void main() {
    Vertex prim_buffer[3];
    prim_buffer[0].attributes = vec4[3](vs_out_attr0[0], vs_out_attr1[0], vs_out_attr2[0]);
    prim_buffer[1].attributes = vec4[3](vs_out_attr0[1], vs_out_attr1[1], vs_out_attr2[1]);
    prim_buffer[2].attributes = vec4[3](vs_out_attr0[2], vs_out_attr1[2], vs_out_attr2[2]);
    EmitPrim(prim_buffer[0], prim_buffer[1], prim_buffer[2]);
}
// reference: 5144ABDD19096853, 6073F2A2E32CD1D3
// shader: 8B30, 9003BF984D8E6760

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: CE312E683CA796CE, 9003BF984D8E6760
// program: A506431ADA7A8BF4, 6073F2A2E32CD1D3, 9003BF984D8E6760
// program: 93C50366EC4126B4, 5D764F9A6220D694, 5A0A3489228017BC
// shader: 8B30, E12F7FCEA540C3DB

precision highp int;
precision highp float;
precision highp samplerBuffer;
precision highp usampler2D;
precision highp uimage2D;
in vec4 primary_color;
in vec2 texcoord0;
in vec2 texcoord1;
in vec2 texcoord2;
in float texcoord0_w;
in vec4 normquat;
in vec3 view;

#ifndef CITRA_GLES
in vec4 gl_FragCoord;
#endif // CITRA_GLES
out vec4 color;

uniform sampler2D tex0;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform samplerCube tex_cube;
uniform samplerBuffer texture_buffer_lut_lf;
uniform samplerBuffer texture_buffer_lut_rg;
uniform samplerBuffer texture_buffer_lut_rgba;

#define NUM_TEV_STAGES 6
#define NUM_LIGHTS 8
#define NUM_LIGHTING_SAMPLERS 24

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};

layout (std140) uniform shader_data {
    int alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    float proctex_bias;
    vec3 fog_color;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 const_color[NUM_TEV_STAGES];
    vec4 tev_combiner_buffer_color;
    vec4 clip_coef;
};

layout (std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[NUM_LIGHTING_SAMPLERS / 4];
    vec3 lighting_global_ambient;
    LightSrc light_src[NUM_LIGHTS];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

// Rotate the vector v by the quaternion q
vec3 quaternion_rotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(texture_buffer_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}

float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}

float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec2 byteround(vec2 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}

// PICA's LOD formula for 2D textures.
// This LOD formula is the same as the LOD lower limit defined in OpenGL.
// f(x, y) >= max{m_u, m_v, m_w}
// (See OpenGL 4.6 spec, 8.14.1 - Scale Factor and Level-of-Detail)
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

vec4 shadowTexture(vec2 uv, float w) {
    return vec4(1.0);
}

vec4 shadowTextureCube(vec2 uv, float w) {
    return vec4(1.0);
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0.0);
vec4 secondary_fragment_color = vec4(0.0);
if (!(gl_FragCoord.x >= float(scissor_x1) && gl_FragCoord.y >= float(scissor_y1) && gl_FragCoord.x < float(scissor_x2) && gl_FragCoord.y < float(scissor_y2))) discard;
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))));
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))));
vec4 combiner_buffer = vec4(0.0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0.0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_0 = byteround(clamp((texcolor0.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_0, alpha_output_0), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
next_combiner_buffer.a = last_tex_env_out.a;

vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (texcolor1.aaa) + (last_tex_env_out.rgb) * (vec3(1.0) - (texcolor1.aaa)), vec3(0.0), vec3(1.0)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_1, alpha_output_1), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

combiner_buffer = next_combiner_buffer;

vec3 color_output_3 = byteround(clamp((const_color[3].rgb), vec3(0.0), vec3(1.0)));
float alpha_output_3 = byteround(clamp((const_color[3].a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_3, alpha_output_3), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (combiner_buffer.rgb) + (last_tex_env_out.rgb) * (vec3(1.0) - (combiner_buffer.rgb)), vec3(0.0), vec3(1.0)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (combiner_buffer.a) + (last_tex_env_out.a) * (1.0 - (combiner_buffer.a)), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_4, alpha_output_4), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0.0), vec3(1.0)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = clamp(vec4(color_output_5, alpha_output_5), vec4(0.0), vec4(1.0));
combiner_buffer = next_combiner_buffer;

gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 2F8F6701E9B8EAA8, E12F7FCEA540C3DB
// program: 93C50366EC4126B4, 5D764F9A6220D694, E12F7FCEA540C3DB
