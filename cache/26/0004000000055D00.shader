// shader: 8B30, 35452D5B70E59F5E
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = (const_color[0].a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_5 = (rounded_primary_color.rgb);
float alpha_output_5 = (rounded_primary_color.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: C56D94968F729FA3, 35452D5B70E59F5E
// program: 0000000000000000, 0000000000000000, 35452D5B70E59F5E
// shader: 8B30, 9E1179689C670733
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = (const_color[0].a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_5 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_5 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 003E4BFAC2C49FC0, 9E1179689C670733
// program: 0000000000000000, 0000000000000000, 9E1179689C670733
// shader: 8DD9, F777123A8C3D5E20

layout(triangles) in;
layout(triangle_strip, max_vertices=3) out;

layout(location=1) out vec4 primary_color;
layout(location=2) out vec2 texcoord0;
layout(location=3) out vec2 texcoord1;
layout(location=4) out vec2 texcoord2;
layout(location=5) out float texcoord0_w;
layout(location=6) out vec4 normquat;
layout(location=7) out vec3 view;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

layout(location=0) in vec4 vs_out_attr0[];
layout(location=1) in vec4 vs_out_attr1[];
layout(location=2) in vec4 vs_out_attr2[];
layout(location=3) in vec4 vs_out_attr3[];
layout(location=4) in vec4 vs_out_attr4[];
layout(location=5) in vec4 vs_out_attr5[];
struct Vertex {
    vec4 attributes[6];
};

vec4 GetVertexQuaternion(Vertex vtx) {
    return vec4(vtx.attributes[1].x, vtx.attributes[1].y, vtx.attributes[1].z, vtx.attributes[1].w);
}

void EmitVtx(Vertex vtx, bool quats_opposite) {
    vec4 vtx_pos = vec4(vtx.attributes[0].x, vtx.attributes[0].y, vtx.attributes[0].z, vtx.attributes[0].w);
    gl_Position = vtx_pos;
#if !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)
    gl_ClipDistance[0] = -vtx_pos.z;
    gl_ClipDistance[1] = dot(clip_coef, vtx_pos);
#endif // !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)

    vec4 vtx_quat = GetVertexQuaternion(vtx);
    normquat = mix(vtx_quat, -vtx_quat, bvec4(quats_opposite));

    vec4 vtx_color = vec4(vtx.attributes[3].x, vtx.attributes[3].y, vtx.attributes[3].z, vtx.attributes[3].w);
    primary_color = clamp(vtx_color, vec4(0), vec4(1));

    texcoord0 = vec2(vtx.attributes[4].x, vtx.attributes[4].y);
    texcoord1 = vec2(vtx.attributes[5].x, vtx.attributes[5].y);

    texcoord0_w = vtx.attributes[4].z;
    view = vec3(vtx.attributes[2].x, vtx.attributes[2].y, vtx.attributes[2].z);
    texcoord2 = vec2(0.0, 0.0);

    EmitVertex();
}

bool AreQuaternionsOpposite(vec4 qa, vec4 qb) {
    return (dot(qa, qb) < 0.0);
}

void EmitPrim(Vertex vtx0, Vertex vtx1, Vertex vtx2) {
    EmitVtx(vtx0, false);
    EmitVtx(vtx1, AreQuaternionsOpposite(GetVertexQuaternion(vtx0), GetVertexQuaternion(vtx1)));
    EmitVtx(vtx2, AreQuaternionsOpposite(GetVertexQuaternion(vtx0), GetVertexQuaternion(vtx2)));
    EndPrimitive();
}

void main() {
    Vertex prim_buffer[3];
    prim_buffer[0].attributes = vec4[6](vs_out_attr0[0], vs_out_attr1[0], vs_out_attr2[0], vs_out_attr3[0], vs_out_attr4[0], vs_out_attr5[0]);
    prim_buffer[1].attributes = vec4[6](vs_out_attr0[1], vs_out_attr1[1], vs_out_attr2[1], vs_out_attr3[1], vs_out_attr4[1], vs_out_attr5[1]);
    prim_buffer[2].attributes = vec4[6](vs_out_attr0[2], vs_out_attr1[2], vs_out_attr2[2], vs_out_attr3[2], vs_out_attr4[2], vs_out_attr5[2]);
    EmitPrim(prim_buffer[0], prim_buffer[1], prim_buffer[2]);
}
// reference: 46A0C2E6B155D5CD, F777123A8C3D5E20
// shader: 8B31, 625982782CCD0D7B

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)

#define min_s(x, y) min(x, y)
#define max_s(x, y) max(x, y)

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout(binding=2, std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location=0) in vec4 vs_in_reg0;
layout(location=1) in vec4 vs_in_reg1;
layout(location=2) in vec4 vs_in_reg2;
layout(location=3) in vec4 vs_in_reg3;
layout(location=4) in vec4 vs_in_reg4;
layout(location=5) in vec4 vs_in_reg5;
layout(location=6) in vec4 vs_in_reg6;
layout(location=7) in vec4 vs_in_reg7;
layout(location=8) in vec4 vs_in_reg8;

layout(location=0) out vec4 vs_out_attr0;
layout(location=1) out vec4 vs_out_attr1;
layout(location=2) out vec4 vs_out_attr2;
layout(location=3) out vec4 vs_out_attr3;
layout(location=4) out vec4 vs_out_attr4;
layout(location=5) out vec4 vs_out_attr5;

void main() {
vs_out_attr0 = vec4(0, 0, 0, 1);
vs_out_attr1 = vec4(0, 0, 0, 1);
vs_out_attr2 = vec4(0, 0, 0, 1);
vs_out_attr3 = vec4(0, 0, 0, 1);
vs_out_attr4 = vec4(0, 0, 0, 1);
vs_out_attr5 = vec4(0, 0, 0, 1);
exec_shader();
}
bvec2 bool_regs = bvec2(false);
ivec3 addr_regs = ivec3(0);
vec4 reg_tmp0 = vec4(0, 0, 0, 1);
vec4 reg_tmp1 = vec4(0, 0, 0, 1);
vec4 reg_tmp2 = vec4(0, 0, 0, 1);
vec4 reg_tmp3 = vec4(0, 0, 0, 1);
vec4 reg_tmp4 = vec4(0, 0, 0, 1);
vec4 reg_tmp5 = vec4(0, 0, 0, 1);
vec4 reg_tmp6 = vec4(0, 0, 0, 1);
vec4 reg_tmp7 = vec4(0, 0, 0, 1);
vec4 reg_tmp8 = vec4(0, 0, 0, 1);
vec4 reg_tmp9 = vec4(0, 0, 0, 1);
vec4 reg_tmp10 = vec4(0, 0, 0, 1);
vec4 reg_tmp11 = vec4(0, 0, 0, 1);
vec4 reg_tmp12 = vec4(0, 0, 0, 1);
vec4 reg_tmp13 = vec4(0, 0, 0, 1);
vec4 reg_tmp14 = vec4(0, 0, 0, 1);
vec4 reg_tmp15 = vec4(0, 0, 0, 1);

bool sub_0();
bool sub_30();
bool sub_31();
bool sub_32();
bool sub_33();
bool sub_34();
bool sub_35();
bool sub_36();
bool sub_37();
bool sub_38();
bool sub_39();
bool sub_40();
bool sub_41();
bool sub_42();
bool sub_21();
bool sub_4();
bool sub_9();
bool sub_1();
bool sub_2();
bool sub_3();
bool sub_5();
bool sub_7();
bool sub_8();
bool sub_10();
bool sub_20();
bool sub_22();
bool sub_23();
bool sub_24();
bool sub_25();
bool sub_26();
bool sub_27();
bool sub_28();
bool sub_29();
bool sub_6();
bool sub_11();
bool sub_12();
bool sub_13();
bool sub_14();
bool sub_15();
bool sub_16();
bool sub_17();
bool sub_18();
bool sub_19();

bool exec_shader() {
sub_0();
return true;
}

bool sub_0() {
sub_1();
reg_tmp8.xy = (uniforms.f[93].xxxx).xy;
reg_tmp0.y = (uniforms.f[7].wwww).y;
bool_regs = notEqual(uniforms.f[93].xx, reg_tmp0.xy);
reg_tmp9.xyz = (uniforms.f[93].xxxx).xyz;
reg_tmp9.w = (uniforms.f[21].wwww).w;
if (bool_regs.y) {
sub_30();
}
bool_regs = equal(uniforms.f[93].xx, reg_tmp8.xy);
if (all(bool_regs)) {
sub_32();
}
vs_out_attr3 = max_s(uniforms.f[93].xxxx, reg_tmp9);
reg_tmp0.xy = (uniforms.f[10].xxxx).xy;
if (uniforms.b[9]) {
sub_33();
} else {
sub_38();
}
reg_tmp0.xy = (uniforms.f[10].yyyy).xy;
bool_regs = equal(uniforms.f[93].yz, reg_tmp0.xy);
if (all(not(bool_regs))) {
sub_39();
} else {
sub_40();
}
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
reg_tmp4.x = dot_s(uniforms.f[14].xywz, reg_tmp6);
reg_tmp4.y = dot_s(uniforms.f[15].xywz, reg_tmp6);
vs_out_attr5 = reg_tmp4;
return true;
}
bool sub_30() {
reg_tmp0 = mul_s(uniforms.f[7].wwww, vs_in_reg3);
if (uniforms.b[7]) {
sub_31();
}
reg_tmp9.xyz = (mul_s(uniforms.f[20].wwww, reg_tmp0.xyzz)).xyz;
reg_tmp8.x = (uniforms.f[93].yyyy).x;
return false;
}
bool sub_31() {
reg_tmp9.w = (mul_s(reg_tmp9.wwww, reg_tmp0.wwww)).w;
return false;
}
bool sub_32() {
reg_tmp9 = uniforms.f[21];
return false;
}
bool sub_33() {
bool_regs = equal(uniforms.f[93].yz, reg_tmp0.xy);
if (all(not(bool_regs))) {
sub_34();
} else {
sub_35();
}
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
reg_tmp3.x = dot_s(uniforms.f[11].xywz, reg_tmp6);
reg_tmp3.y = dot_s(uniforms.f[12].xywz, reg_tmp6);
reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
vs_out_attr4 = reg_tmp3;
return false;
}
bool sub_34() {
reg_tmp6.xy = (mul_s(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
return false;
}
bool sub_35() {
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_36();
} else {
sub_37();
}
return false;
}
bool sub_36() {
reg_tmp6.xy = (mul_s(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
return false;
}
bool sub_37() {
reg_tmp6.xy = (mul_s(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
return false;
}
bool sub_38() {
bool_regs = equal(uniforms.f[95].xy, reg_tmp0.xy);
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
reg_tmp6 = reg_tmp10;
reg_tmp3.x = dot_s(uniforms.f[11], reg_tmp6);
reg_tmp3.y = dot_s(uniforms.f[12], reg_tmp6);
reg_tmp3.z = dot_s(uniforms.f[13], reg_tmp6);
reg_tmp0.xy = (mul_s(uniforms.f[19].xyyy, reg_tmp3.zzzz)).xy;
reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
vs_out_attr4 = reg_tmp3;
return false;
}
bool sub_39() {
reg_tmp6.xy = (mul_s(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
return false;
}
bool sub_40() {
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_41();
} else {
sub_42();
}
return false;
}
bool sub_41() {
reg_tmp6.xy = (mul_s(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
return false;
}
bool sub_42() {
reg_tmp6.xy = (mul_s(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
return false;
}
bool sub_21() {
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp3.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp3.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp3.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
return false;
}
bool sub_4() {
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp3.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp3.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp3.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp4.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
return false;
}
bool sub_9() {
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp3.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp3.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp3.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp4.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp5.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp5.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp5.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
reg_tmp11 = fma_s(reg_tmp1.wwww, reg_tmp5, reg_tmp11);
return false;
}
bool sub_1() {
reg_tmp15.xyz = (mul_s(uniforms.f[7].xxxx, vs_in_reg0)).xyz;
reg_tmp14.xyz = (mul_s(uniforms.f[7].yyyy, vs_in_reg1)).xyz;
reg_tmp13.xyz = (mul_s(uniforms.f[7].zzzz, vs_in_reg2)).xyz;
reg_tmp15.xyz = (uniforms.f[6] + reg_tmp15).xyz;
reg_tmp15.w = (uniforms.f[93].yyyy).w;
if (uniforms.b[1]) {
sub_2();
} else {
sub_23();
}
return false;
}
bool sub_2() {
reg_tmp0 = uniforms.f[7];
bool_regs = notEqual(uniforms.f[93].xx, reg_tmp0.yz);
reg_tmp7 = uniforms.f[93].xxxx;
reg_tmp12 = uniforms.f[93].xxxx;
reg_tmp11 = uniforms.f[93].xxxx;
reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_3();
} else {
sub_7();
}
vs_out_attr2 = -reg_tmp15;
vs_out_attr0.x = dot_s(uniforms.f[86], reg_tmp15);
vs_out_attr0.y = dot_s(uniforms.f[87], reg_tmp15);
vs_out_attr0.z = dot_s(uniforms.f[88], reg_tmp15);
vs_out_attr0.w = dot_s(uniforms.f[89], reg_tmp15);
return false;
}
bool sub_3() {
bool_regs = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
reg_tmp1.xy = (reg_tmp2.xxxx).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
sub_4();
reg_tmp1.xy = (reg_tmp2.yyyy).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
sub_4();
reg_tmp1.xy = (reg_tmp2.zzzz).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
if (bool_regs.x) {
sub_4();
}
if (uniforms.b[8]) {
sub_5();
}
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
sub_6();
return false;
}
bool sub_5() {
reg_tmp1.xy = (reg_tmp2.wwww).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
if (bool_regs.y) {
sub_4();
}
return false;
}
bool sub_7() {
if (all(bool_regs)) {
sub_8();
} else {
sub_20();
}
return false;
}
bool sub_8() {
bool_regs = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
reg_tmp1.xy = (reg_tmp2.xxxx).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
sub_9();
reg_tmp1.xy = (reg_tmp2.yyyy).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
sub_9();
reg_tmp1.xy = (reg_tmp2.zzzz).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
if (bool_regs.x) {
sub_9();
}
if (uniforms.b[8]) {
sub_10();
}
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp13.x = dot_3(uniforms.f[3].xyz, reg_tmp11.xyz);
reg_tmp13.y = dot_3(uniforms.f[4].xyz, reg_tmp11.xyz);
reg_tmp13.z = dot_3(uniforms.f[5].xyz, reg_tmp11.xyz);
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
sub_11();
return false;
}
bool sub_10() {
reg_tmp1.xy = (reg_tmp2.wwww).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
if (bool_regs.y) {
sub_9();
}
return false;
}
bool sub_20() {
bool_regs = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
reg_tmp1.xy = (reg_tmp2.xxxx).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
sub_21();
reg_tmp1.xy = (reg_tmp2.yyyy).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
sub_21();
reg_tmp1.xy = (reg_tmp2.zzzz).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
if (bool_regs.x) {
sub_21();
}
if (uniforms.b[8]) {
sub_22();
}
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
vs_out_attr1 = uniforms.f[93].xxxx;
return false;
}
bool sub_22() {
reg_tmp1.xy = (reg_tmp2.wwww).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
if (bool_regs.y) {
sub_21();
}
return false;
}
bool sub_23() {
reg_tmp0 = uniforms.f[7];
bool_regs = notEqual(uniforms.f[93].xx, reg_tmp0.yz);
if (uniforms.b[2]) {
sub_24();
} else {
sub_25();
}
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_26();
} else {
sub_27();
}
vs_out_attr2 = -reg_tmp15;
vs_out_attr0.x = dot_s(uniforms.f[86], reg_tmp15);
vs_out_attr0.y = dot_s(uniforms.f[87], reg_tmp15);
vs_out_attr0.z = dot_s(uniforms.f[88], reg_tmp15);
vs_out_attr0.w = dot_s(uniforms.f[89], reg_tmp15);
return false;
}
bool sub_24() {
reg_tmp1.x = (mul_s(uniforms.f[93].wwww, vs_in_reg7.xxxx)).x;
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp7.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp7.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp7.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
return false;
}
bool sub_25() {
addr_regs.x = (ivec2(uniforms.f[93].xx)).x;
reg_tmp10.x = dot_s(uniforms.f[25], reg_tmp15);
reg_tmp10.y = dot_s(uniforms.f[26], reg_tmp15);
reg_tmp10.z = dot_s(uniforms.f[27], reg_tmp15);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
return false;
}
bool sub_26() {
reg_tmp12.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
sub_6();
return false;
}
bool sub_27() {
if (all(bool_regs)) {
sub_28();
} else {
sub_29();
}
return false;
}
bool sub_28() {
reg_tmp12.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp11.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp11.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp11.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
reg_tmp13.x = dot_3(uniforms.f[3].xyz, reg_tmp11.xyz);
reg_tmp13.y = dot_3(uniforms.f[4].xyz, reg_tmp11.xyz);
reg_tmp13.z = dot_3(uniforms.f[5].xyz, reg_tmp11.xyz);
sub_11();
return false;
}
bool sub_29() {
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
vs_out_attr1 = uniforms.f[93].xxxx;
return false;
}
bool sub_6() {
uint jmp_to = 251u;
while (true) {
switch (jmp_to) {
case 251u:
reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
reg_tmp6.x = rsq_s(reg_tmp6.x);
reg_tmp7.x = rsq_s(reg_tmp7.x);
reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp0 = uniforms.f[93].yxxx;
if (!uniforms.b[15]) {
jmp_to = 267u; break;
}
reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
reg_tmp4 = mul_s(uniforms.f[94].zzzz, reg_tmp4);
bool_regs = greaterThanEqual(uniforms.f[93].xx, reg_tmp4.xx);
reg_tmp4 = vec4(rsq_s(reg_tmp4.x));
reg_tmp5 = mul_s(uniforms.f[94].zzzz, reg_tmp14);
if (bool_regs.x) {
jmp_to = 267u; break;
}
reg_tmp0.z = rcp_s(reg_tmp4.x);
reg_tmp0.xy = (mul_s(reg_tmp5, reg_tmp4)).xy;
case 267u:
vs_out_attr1 = reg_tmp0;
default: return false;
}
}
return false;
}
bool sub_11() {
uint jmp_to = 268u;
while (true) {
switch (jmp_to) {
case 268u:
reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
reg_tmp6.x = rsq_s(reg_tmp6.x);
reg_tmp7.x = rsq_s(reg_tmp7.x);
reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp13.xyz = (mul_s(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp11.xyz = (mul_s(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp0 = uniforms.f[93].yxxx;
if (!uniforms.b[15]) {
jmp_to = 343u; break;
}
reg_tmp13.xyz = (mul_s(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp11.xyz = (mul_s(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp5 = mul_s(reg_tmp14.yzxx, reg_tmp13.zxyy);
reg_tmp5 = fma_s(-reg_tmp13.yzxx, reg_tmp14.zxyy, reg_tmp5);
reg_tmp5.w = dot_3(reg_tmp5.xyz, reg_tmp5.xyz);
reg_tmp5.w = rsq_s(reg_tmp5.w);
reg_tmp5 = mul_s(reg_tmp5, reg_tmp5.wwww);
reg_tmp6.w = (reg_tmp14.zzzz + reg_tmp5.yyyy).w;
reg_tmp13 = mul_s(reg_tmp5.yzxx, reg_tmp14.zxyy);
reg_tmp13 = fma_s(-reg_tmp14.yzxx, reg_tmp5.zxyy, reg_tmp13);
reg_tmp6.w = (reg_tmp13.xxxx + reg_tmp6).w;
reg_tmp13.w = (reg_tmp5.zzzz).w;
reg_tmp5.z = (reg_tmp13.xxxx).z;
reg_tmp6.w = (uniforms.f[93].yyyy + reg_tmp6).w;
reg_tmp14.w = (reg_tmp5.xxxx).w;
reg_tmp5.x = (reg_tmp14.zzzz).x;
bool_regs = lessThan(uniforms.f[94].yy, reg_tmp6.ww);
reg_tmp6.x = (uniforms.f[93].yyyy).x;
reg_tmp6.y = (-uniforms.f[93].yyyy).y;
if (!bool_regs.x) {
jmp_to = 305u; break;
}
reg_tmp7.xz = (reg_tmp13.wwyy + -reg_tmp14.yyww).xz;
reg_tmp7.y = (reg_tmp14.xxxx + -reg_tmp13.zzzz).y;
reg_tmp7.w = (reg_tmp6).w;
reg_tmp6 = vec4(dot_s(reg_tmp7, reg_tmp7));
reg_tmp6 = vec4(rsq_s(reg_tmp6.x));
reg_tmp0 = mul_s(reg_tmp7, reg_tmp6);
if (uniforms.b[0]) {
jmp_to = 343u; break;
}
case 305u:
bool_regs = greaterThan(reg_tmp5.zy, reg_tmp5.yx);
if (bool_regs.x) {
sub_12();
} else {
sub_17();
}
reg_tmp6 = vec4(dot_s(reg_tmp8, reg_tmp8));
reg_tmp6 = vec4(rsq_s(reg_tmp6.x));
reg_tmp0 = mul_s(reg_tmp8, reg_tmp6);
case 343u:
vs_out_attr1 = reg_tmp0;
default: return false;
}
}
return false;
}
bool sub_12() {
if (bool_regs.y) {
sub_13();
} else {
sub_14();
}
reg_tmp8.w = (-reg_tmp8).w;
return false;
}
bool sub_13() {
reg_tmp8 = mul_s(reg_tmp13.yyzw, reg_tmp6.xxxy);
reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
return false;
}
bool sub_14() {
bool_regs = greaterThan(reg_tmp5.zz, reg_tmp5.xx);
reg_tmp8 = mul_s(reg_tmp13.yyzw, reg_tmp6.xxxy);
reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
if (bool_regs.x) {
sub_15();
} else {
sub_16();
}
return false;
}
bool sub_15() {
reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
return false;
}
bool sub_16() {
reg_tmp8 = mul_s(reg_tmp13.zwwy, reg_tmp6.xxxy);
reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
return false;
}
bool sub_17() {
if (bool_regs.y) {
sub_18();
} else {
sub_19();
}
return false;
}
bool sub_18() {
reg_tmp8 = mul_s(reg_tmp13.yywz, reg_tmp6.xxxy);
reg_tmp8.y = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).y;
reg_tmp9 = reg_tmp5.yyyy + -reg_tmp5.xxxx;
reg_tmp8.xzw = (reg_tmp8 + reg_tmp14.wwyx).xzw;
reg_tmp8.y = (reg_tmp9 + reg_tmp8).y;
return false;
}
bool sub_19() {
reg_tmp8 = mul_s(reg_tmp13.zwwy, reg_tmp6.xxxy);
reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
reg_tmp8.w = (-reg_tmp8).w;
return false;
}
// reference: FBC45F3F314B48C3, 625982782CCD0D7B
// shader: 8B30, 15934979BD14163F
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((secondary_fragment_color.r) * (1.0 - const_color[0].a) + (secondary_fragment_color.b) * (1.0 - (1.0 - const_color[0].a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1) - (last_tex_env_out.aaa)), vec3(0), vec3(1)));
float alpha_output_1 = (texcolor0.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = byteround(clamp((secondary_fragment_color.ggg) * (last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_4 = (last_tex_env_out.rgb);
float alpha_output_4 = byteround(clamp((rounded_primary_color.a) * (const_color[4].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
if (last_tex_env_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 6824189955155F28, 15934979BD14163F
// program: 625982782CCD0D7B, F777123A8C3D5E20, 15934979BD14163F
// reference: 015D13FC1206A9D3, 15934979BD14163F
// shader: 8B30, 586CEA818F13938D
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((secondary_fragment_color.r) * (1.0 - const_color[0].a) + (secondary_fragment_color.b) * (1.0 - (1.0 - const_color[0].a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1) - (last_tex_env_out.aaa)), vec3(0), vec3(1)));
float alpha_output_1 = (texcolor0.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = byteround(clamp((secondary_fragment_color.ggg) * (last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_4 = (last_tex_env_out.rgb);
float alpha_output_4 = byteround(clamp((rounded_primary_color.a) * (const_color[4].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_5 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_5 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: F39D29B1EB142590, 586CEA818F13938D
// program: 0000000000000000, 0000000000000000, 586CEA818F13938D
// reference: 3897724555155F28, 15934979BD14163F
// shader: 8B30, C851F57BD2BFE838
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb) * (texcolor0.rgb) + (const_color[0].rgb) * (vec3(1) - (texcolor0.rgb)), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((texcolor0.r) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 9B2C9ED0491BB6C7, C851F57BD2BFE838
// program: 0000000000000000, 0000000000000000, C851F57BD2BFE838
// reference: 4FD418551206A9D3, 15934979BD14163F
// reference: BD142218EB142590, 586CEA818F13938D
// reference: 682418993C595AD9, 15934979BD14163F
// shader: 8B30, EA2C4B29A1F80A25
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((secondary_fragment_color.r) * (1.0 - const_color[0].a) + (secondary_fragment_color.b) * (1.0 - (1.0 - const_color[0].a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1) - (last_tex_env_out.aaa)), vec3(0), vec3(1)));
float alpha_output_1 = (texcolor0.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = byteround(clamp((secondary_fragment_color.ggg) * (last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_4 = (last_tex_env_out.rgb);
float alpha_output_4 = byteround(clamp((rounded_primary_color.a) * (const_color[4].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_5 = (rounded_primary_color.rgb);
float alpha_output_5 = (rounded_primary_color.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 7847FD74A6A225F3, EA2C4B29A1F80A25
// program: 0000000000000000, 0000000000000000, EA2C4B29A1F80A25
// shader: 8B30, FD29673C2E307195
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tex_env_out.rgb;
combiner_buffer = next_combiner_buffer;
if (last_tex_env_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: DFF74B4064FAD68C, FD29673C2E307195
// program: 625982782CCD0D7B, F777123A8C3D5E20, FD29673C2E307195
// reference: E63D2AF923E92077, FD29673C2E307195
// shader: 8DD9, B6B95AFD9466EC70

layout(triangles) in;
layout(triangle_strip, max_vertices=3) out;

layout(location=1) out vec4 primary_color;
layout(location=2) out vec2 texcoord0;
layout(location=3) out vec2 texcoord1;
layout(location=4) out vec2 texcoord2;
layout(location=5) out float texcoord0_w;
layout(location=6) out vec4 normquat;
layout(location=7) out vec3 view;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

layout(location=0) in vec4 vs_out_attr0[];
layout(location=1) in vec4 vs_out_attr1[];
layout(location=2) in vec4 vs_out_attr2[];
layout(location=3) in vec4 vs_out_attr3[];
layout(location=4) in vec4 vs_out_attr4[];
struct Vertex {
    vec4 attributes[5];
};

vec4 GetVertexQuaternion(Vertex vtx) {
    return vec4(0.0, 0.0, 0.0, 0.0);
}

void EmitVtx(Vertex vtx, bool quats_opposite) {
    vec4 vtx_pos = vec4(vtx.attributes[0].x, vtx.attributes[0].y, vtx.attributes[0].z, vtx.attributes[0].w);
    gl_Position = vtx_pos;
#if !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)
    gl_ClipDistance[0] = -vtx_pos.z;
    gl_ClipDistance[1] = dot(clip_coef, vtx_pos);
#endif // !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)

    vec4 vtx_quat = GetVertexQuaternion(vtx);
    normquat = mix(vtx_quat, -vtx_quat, bvec4(quats_opposite));

    vec4 vtx_color = vec4(vtx.attributes[1].x, vtx.attributes[1].y, vtx.attributes[1].z, vtx.attributes[1].w);
    primary_color = clamp(vtx_color, vec4(0), vec4(1));

    texcoord0 = vec2(vtx.attributes[2].x, vtx.attributes[2].y);
    texcoord1 = vec2(vtx.attributes[3].x, vtx.attributes[3].y);

    texcoord0_w = 0.0;
    view = vec3(0.0, 0.0, 0.0);
    texcoord2 = vec2(vtx.attributes[4].x, vtx.attributes[4].y);

    EmitVertex();
}

bool AreQuaternionsOpposite(vec4 qa, vec4 qb) {
    return (dot(qa, qb) < 0.0);
}

void EmitPrim(Vertex vtx0, Vertex vtx1, Vertex vtx2) {
    EmitVtx(vtx0, false);
    EmitVtx(vtx1, AreQuaternionsOpposite(GetVertexQuaternion(vtx0), GetVertexQuaternion(vtx1)));
    EmitVtx(vtx2, AreQuaternionsOpposite(GetVertexQuaternion(vtx0), GetVertexQuaternion(vtx2)));
    EndPrimitive();
}

void main() {
    Vertex prim_buffer[3];
    prim_buffer[0].attributes = vec4[5](vs_out_attr0[0], vs_out_attr1[0], vs_out_attr2[0], vs_out_attr3[0], vs_out_attr4[0]);
    prim_buffer[1].attributes = vec4[5](vs_out_attr0[1], vs_out_attr1[1], vs_out_attr2[1], vs_out_attr3[1], vs_out_attr4[1]);
    prim_buffer[2].attributes = vec4[5](vs_out_attr0[2], vs_out_attr1[2], vs_out_attr2[2], vs_out_attr3[2], vs_out_attr4[2]);
    EmitPrim(prim_buffer[0], prim_buffer[1], prim_buffer[2]);
}
// reference: 5DAD5699F59B3586, B6B95AFD9466EC70
// shader: 8B31, 3AE9AAE877A9E01A

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)

#define min_s(x, y) min(x, y)
#define max_s(x, y) max(x, y)

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout(binding=2, std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location=0) in vec4 vs_in_reg0;

layout(location=0) out vec4 vs_out_attr0;
layout(location=1) out vec4 vs_out_attr1;
layout(location=2) out vec4 vs_out_attr2;
layout(location=3) out vec4 vs_out_attr3;
layout(location=4) out vec4 vs_out_attr4;

void main() {
vs_out_attr0 = vec4(0, 0, 0, 1);
vs_out_attr1 = vec4(0, 0, 0, 1);
vs_out_attr2 = vec4(0, 0, 0, 1);
vs_out_attr3 = vec4(0, 0, 0, 1);
vs_out_attr4 = vec4(0, 0, 0, 1);
exec_shader();
}
bvec2 bool_regs = bvec2(false);
ivec3 addr_regs = ivec3(0);
vec4 reg_tmp0 = vec4(0, 0, 0, 1);
vec4 reg_tmp1 = vec4(0, 0, 0, 1);
vec4 reg_tmp2 = vec4(0, 0, 0, 1);
vec4 reg_tmp3 = vec4(0, 0, 0, 1);
vec4 reg_tmp4 = vec4(0, 0, 0, 1);
vec4 reg_tmp5 = vec4(0, 0, 0, 1);
vec4 reg_tmp6 = vec4(0, 0, 0, 1);
vec4 reg_tmp7 = vec4(0, 0, 0, 1);
vec4 reg_tmp8 = vec4(0, 0, 0, 1);
vec4 reg_tmp9 = vec4(0, 0, 0, 1);
vec4 reg_tmp10 = vec4(0, 0, 0, 1);
vec4 reg_tmp11 = vec4(0, 0, 0, 1);
vec4 reg_tmp12 = vec4(0, 0, 0, 1);
vec4 reg_tmp13 = vec4(0, 0, 0, 1);
vec4 reg_tmp14 = vec4(0, 0, 0, 1);
vec4 reg_tmp15 = vec4(0, 0, 0, 1);

bool sub_0();
bool sub_1();
bool sub_2();
bool sub_3();
bool sub_4();
bool sub_5();
bool sub_6();
bool sub_7();
bool sub_8();
bool sub_9();
bool sub_10();
bool sub_11();
bool sub_12();
bool sub_13();
bool sub_14();
bool sub_15();
bool sub_16();
bool sub_17();
bool sub_18();
bool sub_19();
bool sub_20();

bool exec_shader() {
sub_0();
return true;
}

bool sub_0() {
addr_regs.x = (ivec2(vs_in_reg0.xy)).x;
reg_tmp0 = uniforms.f[6 + addr_regs.x].wzyx;
reg_tmp1.xy = (vs_in_reg0.zwzw).xy;
reg_tmp1.zw = (uniforms.f[5].xyxy).zw;
addr_regs.xy = ivec2(reg_tmp0.xy);
reg_tmp2.xw = (uniforms.f[64 + addr_regs.y].wwyy).xw;
reg_tmp2.yz = (uniforms.f[5].xxxx).yz;
reg_tmp4.x = dot_s(reg_tmp1, reg_tmp2);
reg_tmp2.yw = (uniforms.f[64 + addr_regs.y].zzxx).yw;
reg_tmp2.xz = (uniforms.f[5].xxxx).xz;
reg_tmp4.y = dot_s(reg_tmp1, reg_tmp2);
reg_tmp4.zw = (reg_tmp1.zwzw).zw;
reg_tmp3.x = dot_s(uniforms.f[32 + addr_regs.x].wzyx, reg_tmp4);
reg_tmp3.y = dot_s(uniforms.f[33 + addr_regs.x].wzyx, reg_tmp4);
reg_tmp3.z = dot_s(uniforms.f[34 + addr_regs.x].wzyx, reg_tmp4);
reg_tmp3.w = (reg_tmp1.wwww).w;
reg_tmp4.z = (uniforms.f[34 + addr_regs.x].xxxx).z;
reg_tmp4.z = (abs(reg_tmp4.zzzz)).z;
reg_tmp4.z = (uniforms.f[4].yyyy + reg_tmp4.zzzz).z;
reg_tmp4.x = (uniforms.f[4].wwww).x;
bool_regs = notEqual(uniforms.f[5].xx, reg_tmp4.xz);
if (all(bool_regs)) {
sub_1();
}
vs_out_attr0.x = dot_s(uniforms.f[0].wzyx, reg_tmp3);
vs_out_attr0.y = dot_s(uniforms.f[1].wzyx, reg_tmp3);
vs_out_attr0.z = dot_s(uniforms.f[2].wzyx, reg_tmp3);
vs_out_attr0.w = dot_s(uniforms.f[3].wzyx, reg_tmp3);
bool_regs = greaterThanEqual(uniforms.f[5].yy, reg_tmp0.ww);
if (all(bool_regs)) {
sub_2();
} else {
sub_3();
}
bool_regs = notEqual(uniforms.f[5].xx, reg_tmp1.xy);
if (all(not(bool_regs))) {
sub_8();
}
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_9();
}
if (all(bvec2(!bool_regs.x, bool_regs.y))) {
sub_10();
}
if (all(bool_regs)) {
sub_11();
}
reg_tmp8 = uniforms.f[5].xxxx;
addr_regs.z = int(uniforms.i[0].y);
for (uint i = 0u; i <= uniforms.i[0].x; addr_regs.z += int(uniforms.i[0].z), ++i) {
sub_12();
}
vs_out_attr2 = reg_tmp5;
vs_out_attr3 = reg_tmp6;
vs_out_attr4 = reg_tmp7;
return true;
}
bool sub_1() {
reg_tmp4.x = (uniforms.f[4].wwww).x;
reg_tmp4.y = (-uniforms.f[4].zzzz + reg_tmp4.zzzz).y;
reg_tmp4.z = rcp_s(reg_tmp4.z);
reg_tmp4.z = (mul_s(reg_tmp4.yyyy, reg_tmp4.zzzz)).z;
reg_tmp3.x = (fma_s(reg_tmp4.xxxx, reg_tmp4.zzzz, reg_tmp3.xxxx)).x;
return false;
}
bool sub_2() {
vs_out_attr1.xyz = (uniforms.f[5].yyyy).xyz;
vs_out_attr1.w = (reg_tmp0.wwww).w;
return false;
}
bool sub_3() {
addr_regs.y = (ivec2(reg_tmp0.ww)).y;
bool_regs = notEqual(uniforms.f[5].xx, reg_tmp1.xy);
if (all(not(bool_regs))) {
sub_4();
}
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_5();
}
if (all(bvec2(!bool_regs.x, bool_regs.y))) {
sub_6();
}
if (all(bool_regs)) {
sub_7();
}
return false;
}
bool sub_4() {
vs_out_attr1 = uniforms.f[32 + addr_regs.y].wzyx;
return false;
}
bool sub_5() {
vs_out_attr1 = uniforms.f[33 + addr_regs.y].wzyx;
return false;
}
bool sub_6() {
vs_out_attr1 = uniforms.f[34 + addr_regs.y].wzyx;
return false;
}
bool sub_7() {
vs_out_attr1 = uniforms.f[35 + addr_regs.y].wzyx;
return false;
}
bool sub_8() {
reg_tmp5 = uniforms.f[5].xyyy;
reg_tmp6 = uniforms.f[5].xyyy;
reg_tmp7 = uniforms.f[5].xyyy;
return false;
}
bool sub_9() {
reg_tmp5 = uniforms.f[5].yyyy;
reg_tmp6 = uniforms.f[5].yyyy;
reg_tmp7 = uniforms.f[5].yyyy;
return false;
}
bool sub_10() {
reg_tmp5 = uniforms.f[5].xxyy;
reg_tmp6 = uniforms.f[5].xxyy;
reg_tmp7 = uniforms.f[5].xxyy;
return false;
}
bool sub_11() {
reg_tmp5 = uniforms.f[5].yxyy;
reg_tmp6 = uniforms.f[5].yxyy;
reg_tmp7 = uniforms.f[5].yxyy;
return false;
}
bool sub_12() {
bool_regs = equal(uniforms.f[5].yy, reg_tmp8.xy);
if (all(bool_regs)) {
sub_13();
}
bool_regs = lessThan(uniforms.f[5].ww, reg_tmp8.xy);
if (all(bool_regs)) {
sub_18();
}
reg_tmp8 = uniforms.f[5].yyyy + reg_tmp8;
return false;
}
bool sub_13() {
addr_regs.y = (ivec2(reg_tmp0.zz)).y;
bool_regs = notEqual(uniforms.f[5].xx, reg_tmp1.xy);
if (all(not(bool_regs))) {
sub_14();
}
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_15();
}
if (all(bvec2(!bool_regs.x, bool_regs.y))) {
sub_16();
}
if (all(bool_regs)) {
sub_17();
}
return false;
}
bool sub_14() {
reg_tmp5.xy = (uniforms.f[64 + addr_regs.y].wzzz).xy;
reg_tmp6.xy = (uniforms.f[65 + addr_regs.y].wzzz).xy;
reg_tmp7.xy = (uniforms.f[66 + addr_regs.y].wzzz).xy;
return false;
}
bool sub_15() {
reg_tmp5.xy = (uniforms.f[64 + addr_regs.y].yzzz).xy;
reg_tmp6.xy = (uniforms.f[65 + addr_regs.y].yzzz).xy;
reg_tmp7.xy = (uniforms.f[66 + addr_regs.y].yzzz).xy;
return false;
}
bool sub_16() {
reg_tmp5.xy = (uniforms.f[64 + addr_regs.y].wxxx).xy;
reg_tmp6.xy = (uniforms.f[65 + addr_regs.y].wxxx).xy;
reg_tmp7.xy = (uniforms.f[66 + addr_regs.y].wxxx).xy;
return false;
}
bool sub_17() {
reg_tmp5.xy = (uniforms.f[64 + addr_regs.y].yxxx).xy;
reg_tmp6.xy = (uniforms.f[65 + addr_regs.y].yxxx).xy;
reg_tmp7.xy = (uniforms.f[66 + addr_regs.y].yxxx).xy;
return false;
}
bool sub_18() {
bool_regs = notEqual(uniforms.f[5].xx, reg_tmp1.xy);
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_19();
}
if (all(bvec2(!bool_regs.x, bool_regs.y))) {
sub_20();
}
return false;
}
bool sub_19() {
reg_tmp5.xy = (uniforms.f[67 + addr_regs.y].yxxx).xy;
reg_tmp6.xy = (uniforms.f[68 + addr_regs.y].yxxx).xy;
reg_tmp7.xy = (uniforms.f[69 + addr_regs.y].yxxx).xy;
return false;
}
bool sub_20() {
reg_tmp5.xy = (uniforms.f[67 + addr_regs.y].wzzz).xy;
reg_tmp6.xy = (uniforms.f[68 + addr_regs.y].wzzz).xy;
reg_tmp7.xy = (uniforms.f[69 + addr_regs.y].wzzz).xy;
return false;
}
// reference: 456A7DE6CB4A9FA4, 3AE9AAE877A9E01A
// shader: 8B30, B4F49F380E3BB3A3
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = byteround(clamp((const_color[3].rgb) * (vec3(1) - texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_3 = byteround(clamp((const_color[3].a) * (1.0 - texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (texcolor0.rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (texcolor0.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
if (last_tex_env_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 3E1B559886D9AF66, B4F49F380E3BB3A3
// program: 3AE9AAE877A9E01A, B6B95AFD9466EC70, B4F49F380E3BB3A3
// shader: 8B30, 8A654F38DF394AE6
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = byteround(clamp((const_color[3].rgb) * (vec3(1) - texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_3 = byteround(clamp((const_color[3].a) * (1.0 - texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (texcolor0.rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (texcolor0.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_5 = (rounded_primary_color.rgb);
float alpha_output_5 = (rounded_primary_color.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: CCDB6FD5926224E8, 8A654F38DF394AE6
// program: 0000000000000000, 0000000000000000, 8A654F38DF394AE6
// shader: 8B30, 0C903419B28F7036
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = byteround(clamp((const_color[3].rgb) * (vec3(1) - texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_3 = byteround(clamp((const_color[3].a) * (1.0 - texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (texcolor0.rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (texcolor0.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_5 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_5 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 0988B0B9DFD4248B, 0C903419B28F7036
// program: 0000000000000000, 0000000000000000, 0C903419B28F7036
// reference: DE35217764FAD68C, FD29673C2E307195
// reference: E7FF40CE809BD615, FD29673C2E307195
// shader: 8B30, 01F65846F8022197
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_5 = (rounded_primary_color.rgb);
float alpha_output_5 = (rounded_primary_color.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 66D3A0332EE570CC, 01F65846F8022197
// program: 0000000000000000, 0000000000000000, 01F65846F8022197
// shader: 8B30, 35DAEFEA78A196F8
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_5 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_5 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: A3807F5F635370AF, 35DAEFEA78A196F8
// program: 0000000000000000, 0000000000000000, 35DAEFEA78A196F8
// shader: 8B30, 96ECB36D4B8ACF09
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tex_env_out.rgb;
combiner_buffer = next_combiner_buffer;
vec3 color_output_5 = (rounded_primary_color.rgb);
float alpha_output_5 = (rounded_primary_color.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D06CA5EF343F5A35, 96ECB36D4B8ACF09
// program: 0000000000000000, 0000000000000000, 96ECB36D4B8ACF09
// shader: 8B30, 328474F93DE92107
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tex_env_out.rgb;
combiner_buffer = next_combiner_buffer;
vec3 color_output_5 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_5 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 153F7A8379895A56, 328474F93DE92107
// program: 0000000000000000, 0000000000000000, 328474F93DE92107
// shader: 8B30, C3889FFB30647D6D
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = byteround(clamp((vec3(1) - texcolor0.rgb) * (const_color[3].rgb), vec3(0), vec3(1)));
float alpha_output_3 = byteround(clamp((texcolor0.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_4 = byteround(clamp((texcolor0.rgb) * (const_color[4].rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_4 = byteround(clamp((1.0 - texcolor0.a) * (const_color[4].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
if (last_tex_env_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 1BD792B382017F7D, C3889FFB30647D6D
// program: 3AE9AAE877A9E01A, B6B95AFD9466EC70, C3889FFB30647D6D
// shader: 8B30, E0C6E7A6C218A148
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = byteround(clamp((vec3(1) - texcolor0.rgb) * (const_color[3].rgb), vec3(0), vec3(1)));
float alpha_output_3 = byteround(clamp((texcolor0.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_4 = byteround(clamp((texcolor0.rgb) * (const_color[4].rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_4 = byteround(clamp((1.0 - texcolor0.a) * (const_color[4].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (const_color[5].rgb), vec3(0), vec3(1)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (const_color[5].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
if (last_tex_env_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 1BD792B381E398CF, E0C6E7A6C218A148
// program: 3AE9AAE877A9E01A, B6B95AFD9466EC70, E0C6E7A6C218A148
// shader: 8B30, 52D00A3C8996DEE0
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = byteround(clamp((vec3(1) - texcolor0.rgb) * (const_color[3].rgb), vec3(0), vec3(1)));
float alpha_output_3 = byteround(clamp((texcolor0.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_4 = byteround(clamp((texcolor0.rgb) * (const_color[4].rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_4 = byteround(clamp((1.0 - texcolor0.a) * (const_color[4].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_5 = (rounded_primary_color.rgb);
float alpha_output_5 = (rounded_primary_color.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: E917A8FE96BAF4F3, 52D00A3C8996DEE0
// program: 0000000000000000, 0000000000000000, 52D00A3C8996DEE0
// shader: 8B31, F57E43796F666394

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)

#define min_s(x, y) min(x, y)
#define max_s(x, y) max(x, y)

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout(binding=2, std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location=0) in vec4 vs_in_reg0;
layout(location=1) in vec4 vs_in_reg1;
layout(location=2) in vec4 vs_in_reg2;
layout(location=3) in vec4 vs_in_reg3;
layout(location=4) in vec4 vs_in_reg4;
layout(location=5) in vec4 vs_in_reg5;
layout(location=6) in vec4 vs_in_reg6;
layout(location=7) in vec4 vs_in_reg7;
layout(location=8) in vec4 vs_in_reg8;

layout(location=0) out vec4 vs_out_attr0;
layout(location=1) out vec4 vs_out_attr1;
layout(location=2) out vec4 vs_out_attr2;
layout(location=3) out vec4 vs_out_attr3;
layout(location=4) out vec4 vs_out_attr4;
layout(location=5) out vec4 vs_out_attr5;

void main() {
vs_out_attr0 = vec4(0, 0, 0, 1);
vs_out_attr1 = vec4(0, 0, 0, 1);
vs_out_attr2 = vec4(0, 0, 0, 1);
vs_out_attr3 = vec4(0, 0, 0, 1);
vs_out_attr4 = vec4(0, 0, 0, 1);
vs_out_attr5 = vec4(0, 0, 0, 1);
exec_shader();
}
bvec2 bool_regs = bvec2(false);
ivec3 addr_regs = ivec3(0);
vec4 reg_tmp0 = vec4(0, 0, 0, 1);
vec4 reg_tmp1 = vec4(0, 0, 0, 1);
vec4 reg_tmp2 = vec4(0, 0, 0, 1);
vec4 reg_tmp3 = vec4(0, 0, 0, 1);
vec4 reg_tmp4 = vec4(0, 0, 0, 1);
vec4 reg_tmp5 = vec4(0, 0, 0, 1);
vec4 reg_tmp6 = vec4(0, 0, 0, 1);
vec4 reg_tmp7 = vec4(0, 0, 0, 1);
vec4 reg_tmp8 = vec4(0, 0, 0, 1);
vec4 reg_tmp9 = vec4(0, 0, 0, 1);
vec4 reg_tmp10 = vec4(0, 0, 0, 1);
vec4 reg_tmp11 = vec4(0, 0, 0, 1);
vec4 reg_tmp12 = vec4(0, 0, 0, 1);
vec4 reg_tmp13 = vec4(0, 0, 0, 1);
vec4 reg_tmp14 = vec4(0, 0, 0, 1);
vec4 reg_tmp15 = vec4(0, 0, 0, 1);

bool sub_0();
bool sub_32();
bool sub_33();
bool sub_34();
bool sub_35();
bool sub_36();
bool sub_37();
bool sub_38();
bool sub_39();
bool sub_40();
bool sub_41();
bool sub_42();
bool sub_43();
bool sub_44();
bool sub_21();
bool sub_4();
bool sub_9();
bool sub_1();
bool sub_2();
bool sub_3();
bool sub_5();
bool sub_7();
bool sub_8();
bool sub_10();
bool sub_20();
bool sub_22();
bool sub_23();
bool sub_24();
bool sub_25();
bool sub_26();
bool sub_27();
bool sub_28();
bool sub_29();
bool sub_30();
bool sub_31();
bool sub_6();
bool sub_11();
bool sub_12();
bool sub_13();
bool sub_14();
bool sub_15();
bool sub_16();
bool sub_17();
bool sub_18();
bool sub_19();

bool exec_shader() {
sub_0();
return true;
}

bool sub_0() {
sub_1();
reg_tmp8.xy = (uniforms.f[93].xxxx).xy;
reg_tmp0.y = (uniforms.f[7].wwww).y;
bool_regs = notEqual(uniforms.f[93].xx, reg_tmp0.xy);
reg_tmp9.xyz = (uniforms.f[93].xxxx).xyz;
reg_tmp9.w = (uniforms.f[21].wwww).w;
if (bool_regs.y) {
sub_32();
}
bool_regs = equal(uniforms.f[93].xx, reg_tmp8.xy);
if (all(bool_regs)) {
sub_34();
}
vs_out_attr3 = max_s(uniforms.f[93].xxxx, reg_tmp9);
reg_tmp0.xy = (uniforms.f[10].xxxx).xy;
if (uniforms.b[9]) {
sub_35();
} else {
sub_40();
}
reg_tmp0.xy = (uniforms.f[10].yyyy).xy;
bool_regs = equal(uniforms.f[93].yz, reg_tmp0.xy);
if (all(not(bool_regs))) {
sub_41();
} else {
sub_42();
}
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
reg_tmp4.x = dot_s(uniforms.f[14].xywz, reg_tmp6);
reg_tmp4.y = dot_s(uniforms.f[15].xywz, reg_tmp6);
vs_out_attr5 = reg_tmp4;
return true;
}
bool sub_32() {
reg_tmp0 = mul_s(uniforms.f[7].wwww, vs_in_reg3);
if (uniforms.b[7]) {
sub_33();
}
reg_tmp9.xyz = (mul_s(uniforms.f[20].wwww, reg_tmp0.xyzz)).xyz;
reg_tmp8.x = (uniforms.f[93].yyyy).x;
return false;
}
bool sub_33() {
reg_tmp9.w = (mul_s(reg_tmp9.wwww, reg_tmp0.wwww)).w;
return false;
}
bool sub_34() {
reg_tmp9 = uniforms.f[21];
return false;
}
bool sub_35() {
bool_regs = equal(uniforms.f[93].yz, reg_tmp0.xy);
if (all(not(bool_regs))) {
sub_36();
} else {
sub_37();
}
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
reg_tmp3.x = dot_s(uniforms.f[11].xywz, reg_tmp6);
reg_tmp3.y = dot_s(uniforms.f[12].xywz, reg_tmp6);
reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
vs_out_attr4 = reg_tmp3;
return false;
}
bool sub_36() {
reg_tmp6.xy = (mul_s(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
return false;
}
bool sub_37() {
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_38();
} else {
sub_39();
}
return false;
}
bool sub_38() {
reg_tmp6.xy = (mul_s(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
return false;
}
bool sub_39() {
reg_tmp6.xy = (mul_s(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
return false;
}
bool sub_40() {
bool_regs = equal(uniforms.f[95].xy, reg_tmp0.xy);
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
reg_tmp6 = reg_tmp10;
reg_tmp3.x = dot_s(uniforms.f[11], reg_tmp6);
reg_tmp3.y = dot_s(uniforms.f[12], reg_tmp6);
reg_tmp3.z = dot_s(uniforms.f[13], reg_tmp6);
reg_tmp0.xy = (mul_s(uniforms.f[19].xyyy, reg_tmp3.zzzz)).xy;
reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
vs_out_attr4 = reg_tmp3;
return false;
}
bool sub_41() {
reg_tmp6.xy = (mul_s(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
return false;
}
bool sub_42() {
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_43();
} else {
sub_44();
}
return false;
}
bool sub_43() {
reg_tmp6.xy = (mul_s(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
return false;
}
bool sub_44() {
reg_tmp6.xy = (mul_s(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
return false;
}
bool sub_21() {
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp3.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp3.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp3.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
return false;
}
bool sub_4() {
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp3.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp3.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp3.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp4.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
return false;
}
bool sub_9() {
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp3.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp3.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp3.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp4.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp5.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp5.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp5.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
reg_tmp11 = fma_s(reg_tmp1.wwww, reg_tmp5, reg_tmp11);
return false;
}
bool sub_1() {
reg_tmp15.xyz = (mul_s(uniforms.f[7].xxxx, vs_in_reg0)).xyz;
reg_tmp14.xyz = (mul_s(uniforms.f[7].yyyy, vs_in_reg1)).xyz;
reg_tmp13.xyz = (mul_s(uniforms.f[7].zzzz, vs_in_reg2)).xyz;
reg_tmp15.xyz = (uniforms.f[6] + reg_tmp15).xyz;
reg_tmp15.w = (uniforms.f[93].yyyy).w;
if (uniforms.b[1]) {
sub_2();
} else {
sub_24();
}
return false;
}
bool sub_2() {
reg_tmp0 = uniforms.f[7];
bool_regs = notEqual(uniforms.f[93].xx, reg_tmp0.yz);
reg_tmp7 = uniforms.f[93].xxxx;
reg_tmp12 = uniforms.f[93].xxxx;
reg_tmp11 = uniforms.f[93].xxxx;
reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_3();
} else {
sub_7();
}
vs_out_attr2 = -reg_tmp15;
reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
reg_tmp1.x = (-reg_tmp0.wwww).x;
reg_tmp1.y = (mul_s(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
bool_regs.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
bool_regs.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
if (all(bool_regs)) {
sub_23();
}
vs_out_attr0 = reg_tmp0;
return false;
}
bool sub_3() {
bool_regs = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
reg_tmp1.xy = (reg_tmp2.xxxx).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
sub_4();
reg_tmp1.xy = (reg_tmp2.yyyy).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
sub_4();
reg_tmp1.xy = (reg_tmp2.zzzz).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
if (bool_regs.x) {
sub_4();
}
if (uniforms.b[8]) {
sub_5();
}
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp7 = reg_tmp10;
reg_tmp10.x = dot_s(uniforms.f[22], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[23], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[24], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
sub_6();
return false;
}
bool sub_5() {
reg_tmp1.xy = (reg_tmp2.wwww).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
if (bool_regs.y) {
sub_4();
}
return false;
}
bool sub_7() {
if (all(bool_regs)) {
sub_8();
} else {
sub_20();
}
return false;
}
bool sub_8() {
bool_regs = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
reg_tmp1.xy = (reg_tmp2.xxxx).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
sub_9();
reg_tmp1.xy = (reg_tmp2.yyyy).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
sub_9();
reg_tmp1.xy = (reg_tmp2.zzzz).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
if (bool_regs.x) {
sub_9();
}
if (uniforms.b[8]) {
sub_10();
}
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp7 = reg_tmp10;
reg_tmp10.x = dot_s(uniforms.f[22], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[23], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[24], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp13.x = dot_3(uniforms.f[3].xyz, reg_tmp11.xyz);
reg_tmp13.y = dot_3(uniforms.f[4].xyz, reg_tmp11.xyz);
reg_tmp13.z = dot_3(uniforms.f[5].xyz, reg_tmp11.xyz);
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
sub_11();
return false;
}
bool sub_10() {
reg_tmp1.xy = (reg_tmp2.wwww).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
if (bool_regs.y) {
sub_9();
}
return false;
}
bool sub_20() {
bool_regs = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
reg_tmp1.xy = (reg_tmp2.xxxx).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
sub_21();
reg_tmp1.xy = (reg_tmp2.yyyy).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
sub_21();
reg_tmp1.xy = (reg_tmp2.zzzz).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
if (bool_regs.x) {
sub_21();
}
if (uniforms.b[8]) {
sub_22();
}
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp7 = reg_tmp10;
reg_tmp10.x = dot_s(uniforms.f[22], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[23], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[24], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
vs_out_attr1 = uniforms.f[93].xxxx;
return false;
}
bool sub_22() {
reg_tmp1.xy = (reg_tmp2.wwww).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
if (bool_regs.y) {
sub_21();
}
return false;
}
bool sub_23() {
reg_tmp0.x = (-reg_tmp0.wwww).x;
return false;
}
bool sub_24() {
if (uniforms.b[2]) {
sub_25();
} else {
sub_26();
}
reg_tmp0 = uniforms.f[7];
bool_regs = notEqual(uniforms.f[93].xx, reg_tmp0.yz);
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_27();
} else {
sub_28();
}
vs_out_attr2 = -reg_tmp15;
reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
reg_tmp1.x = (-reg_tmp0.wwww).x;
reg_tmp1.y = (mul_s(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
bool_regs.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
bool_regs.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
if (all(bool_regs)) {
sub_31();
}
vs_out_attr0 = reg_tmp0;
return false;
}
bool sub_25() {
reg_tmp1.x = (mul_s(uniforms.f[93].wwww, vs_in_reg7.xxxx)).x;
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp7.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp7.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp7.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
return false;
}
bool sub_26() {
addr_regs.x = (ivec2(uniforms.f[93].xx)).x;
reg_tmp10.x = dot_s(uniforms.f[25], reg_tmp15);
reg_tmp10.y = dot_s(uniforms.f[26], reg_tmp15);
reg_tmp10.z = dot_s(uniforms.f[27], reg_tmp15);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
return false;
}
bool sub_27() {
reg_tmp12.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp7 = reg_tmp10;
reg_tmp10.x = dot_s(uniforms.f[22], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[23], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[24], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
sub_6();
return false;
}
bool sub_28() {
if (all(bool_regs)) {
sub_29();
} else {
sub_30();
}
return false;
}
bool sub_29() {
reg_tmp12.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp11.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp11.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp11.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp7 = reg_tmp10;
reg_tmp10.x = dot_s(uniforms.f[22], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[23], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[24], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
reg_tmp13.x = dot_3(uniforms.f[3].xyz, reg_tmp11.xyz);
reg_tmp13.y = dot_3(uniforms.f[4].xyz, reg_tmp11.xyz);
reg_tmp13.z = dot_3(uniforms.f[5].xyz, reg_tmp11.xyz);
sub_11();
return false;
}
bool sub_30() {
reg_tmp7 = reg_tmp10;
reg_tmp10.x = dot_s(uniforms.f[22], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[23], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[24], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
vs_out_attr1 = uniforms.f[93].xxxx;
return false;
}
bool sub_31() {
reg_tmp0.x = (-reg_tmp0.wwww).x;
return false;
}
bool sub_6() {
uint jmp_to = 293u;
while (true) {
switch (jmp_to) {
case 293u:
reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
reg_tmp6.x = rsq_s(reg_tmp6.x);
reg_tmp7.x = rsq_s(reg_tmp7.x);
reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp0 = uniforms.f[93].yxxx;
if (!uniforms.b[15]) {
jmp_to = 309u; break;
}
reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
reg_tmp4 = mul_s(uniforms.f[94].zzzz, reg_tmp4);
bool_regs = greaterThanEqual(uniforms.f[93].xx, reg_tmp4.xx);
reg_tmp4 = vec4(rsq_s(reg_tmp4.x));
reg_tmp5 = mul_s(uniforms.f[94].zzzz, reg_tmp14);
if (bool_regs.x) {
jmp_to = 309u; break;
}
reg_tmp0.z = rcp_s(reg_tmp4.x);
reg_tmp0.xy = (mul_s(reg_tmp5, reg_tmp4)).xy;
case 309u:
vs_out_attr1 = reg_tmp0;
default: return false;
}
}
return false;
}
bool sub_11() {
uint jmp_to = 310u;
while (true) {
switch (jmp_to) {
case 310u:
reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
reg_tmp6.x = rsq_s(reg_tmp6.x);
reg_tmp7.x = rsq_s(reg_tmp7.x);
reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp13.xyz = (mul_s(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp11.xyz = (mul_s(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp0 = uniforms.f[93].yxxx;
if (!uniforms.b[15]) {
jmp_to = 385u; break;
}
reg_tmp13.xyz = (mul_s(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp11.xyz = (mul_s(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp5 = mul_s(reg_tmp14.yzxx, reg_tmp13.zxyy);
reg_tmp5 = fma_s(-reg_tmp13.yzxx, reg_tmp14.zxyy, reg_tmp5);
reg_tmp5.w = dot_3(reg_tmp5.xyz, reg_tmp5.xyz);
reg_tmp5.w = rsq_s(reg_tmp5.w);
reg_tmp5 = mul_s(reg_tmp5, reg_tmp5.wwww);
reg_tmp6.w = (reg_tmp14.zzzz + reg_tmp5.yyyy).w;
reg_tmp13 = mul_s(reg_tmp5.yzxx, reg_tmp14.zxyy);
reg_tmp13 = fma_s(-reg_tmp14.yzxx, reg_tmp5.zxyy, reg_tmp13);
reg_tmp6.w = (reg_tmp13.xxxx + reg_tmp6).w;
reg_tmp13.w = (reg_tmp5.zzzz).w;
reg_tmp5.z = (reg_tmp13.xxxx).z;
reg_tmp6.w = (uniforms.f[93].yyyy + reg_tmp6).w;
reg_tmp14.w = (reg_tmp5.xxxx).w;
reg_tmp5.x = (reg_tmp14.zzzz).x;
bool_regs = lessThan(uniforms.f[94].yy, reg_tmp6.ww);
reg_tmp6.x = (uniforms.f[93].yyyy).x;
reg_tmp6.y = (-uniforms.f[93].yyyy).y;
if (!bool_regs.x) {
jmp_to = 347u; break;
}
reg_tmp7.xz = (reg_tmp13.wwyy + -reg_tmp14.yyww).xz;
reg_tmp7.y = (reg_tmp14.xxxx + -reg_tmp13.zzzz).y;
reg_tmp7.w = (reg_tmp6).w;
reg_tmp6 = vec4(dot_s(reg_tmp7, reg_tmp7));
reg_tmp6 = vec4(rsq_s(reg_tmp6.x));
reg_tmp0 = mul_s(reg_tmp7, reg_tmp6);
if (uniforms.b[0]) {
jmp_to = 385u; break;
}
case 347u:
bool_regs = greaterThan(reg_tmp5.zy, reg_tmp5.yx);
if (bool_regs.x) {
sub_12();
} else {
sub_17();
}
reg_tmp6 = vec4(dot_s(reg_tmp8, reg_tmp8));
reg_tmp6 = vec4(rsq_s(reg_tmp6.x));
reg_tmp0 = mul_s(reg_tmp8, reg_tmp6);
case 385u:
vs_out_attr1 = reg_tmp0;
default: return false;
}
}
return false;
}
bool sub_12() {
if (bool_regs.y) {
sub_13();
} else {
sub_14();
}
reg_tmp8.w = (-reg_tmp8).w;
return false;
}
bool sub_13() {
reg_tmp8 = mul_s(reg_tmp13.yyzw, reg_tmp6.xxxy);
reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
return false;
}
bool sub_14() {
bool_regs = greaterThan(reg_tmp5.zz, reg_tmp5.xx);
reg_tmp8 = mul_s(reg_tmp13.yyzw, reg_tmp6.xxxy);
reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
if (bool_regs.x) {
sub_15();
} else {
sub_16();
}
return false;
}
bool sub_15() {
reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
return false;
}
bool sub_16() {
reg_tmp8 = mul_s(reg_tmp13.zwwy, reg_tmp6.xxxy);
reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
return false;
}
bool sub_17() {
if (bool_regs.y) {
sub_18();
} else {
sub_19();
}
return false;
}
bool sub_18() {
reg_tmp8 = mul_s(reg_tmp13.yywz, reg_tmp6.xxxy);
reg_tmp8.y = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).y;
reg_tmp9 = reg_tmp5.yyyy + -reg_tmp5.xxxx;
reg_tmp8.xzw = (reg_tmp8 + reg_tmp14.wwyx).xzw;
reg_tmp8.y = (reg_tmp9 + reg_tmp8).y;
return false;
}
bool sub_19() {
reg_tmp8 = mul_s(reg_tmp13.zwwy, reg_tmp6.xxxy);
reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
reg_tmp8.w = (-reg_tmp8).w;
return false;
}
// reference: D532576A448B58F1, F57E43796F666394
// shader: 8B30, F705E732A249D088
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(light_vector, normal)));
refl_value.g = (lut_scale_rg * LookupLightingLUTSigned(5, dot(light_vector, normal)));
refl_value.b = (lut_scale_rb * LookupLightingLUTSigned(4, dot(light_vector, normal)));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = (texcolor1.rgb);
float alpha_output_0 = (secondary_fragment_color.r);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1) - (last_tex_env_out.aaa)), vec3(0), vec3(1)));
float alpha_output_1 = (texcolor1.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = byteround(clamp((primary_fragment_color.rgb) * (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tex_env_out.rgb;
vec3 color_output_4 = byteround(clamp((vec3(1) - textureProj(tex0, vec3(texcoord0, texcoord0_w)).rgb) * (const_color[4].rgb), vec3(0), vec3(1)));
float alpha_output_4 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_5 = byteround(clamp((combiner_buffer.rgb) * (vec3(1) - last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
if (last_tex_env_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 7E7A37C390F5E1A8, F705E732A249D088
// program: F57E43796F666394, F777123A8C3D5E20, F705E732A249D088
// shader: 8B30, B7A9B6AE77A46D16
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(light_vector, normal)));
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = (texcolor1.rgb);
float alpha_output_0 = (secondary_fragment_color.r);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1) - (last_tex_env_out.aaa)), vec3(0), vec3(1)));
float alpha_output_1 = (texcolor1.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = byteround(clamp((primary_fragment_color.rgb) * (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tex_env_out.rgb;
vec3 color_output_4 = byteround(clamp((vec3(1) - textureProj(tex0, vec3(texcoord0, texcoord0_w)).rgb) * (const_color[4].rgb), vec3(0), vec3(1)));
float alpha_output_4 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_5 = byteround(clamp((combiner_buffer.rgb) * (vec3(1) - last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
if (last_tex_env_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D5BC3BF6FD5AA7DB, B7A9B6AE77A46D16
// program: F57E43796F666394, F777123A8C3D5E20, B7A9B6AE77A46D16
// shader: 8B30, 4BE170182235D0BB
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += ((light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[2].position + view);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * LookupLightingLUTUnsigned(18, clamp(light_src[2].dist_atten_scale * length(-light_src[2].position - view) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[2].specular_0) + (light_src[2].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(18, clamp(light_src[2].dist_atten_scale * length(-light_src[2].position - view) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[3].position + view);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * LookupLightingLUTUnsigned(19, clamp(light_src[3].dist_atten_scale * length(-light_src[3].position - view) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[3].specular_0) + (light_src[3].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(19, clamp(light_src[3].dist_atten_scale * length(-light_src[3].position - view) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tex_env_out.rgb;
vec3 color_output_2 = byteround(clamp((texcolor1.rgb) + (secondary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (const_color[2].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (last_tex_env_out.aaa) + (combiner_buffer.rgb) * (vec3(1) - (last_tex_env_out.aaa)), vec3(0), vec3(1)));
float alpha_output_3 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tex_env_out.rgb;
combiner_buffer = next_combiner_buffer;
if (last_tex_env_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: BBE78052A0D60032, 4BE170182235D0BB
// program: 625982782CCD0D7B, F777123A8C3D5E20, 4BE170182235D0BB
// shader: 8B30, 11F75D1954448C2C
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += ((light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[2].position + view);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * LookupLightingLUTUnsigned(18, clamp(light_src[2].dist_atten_scale * length(-light_src[2].position - view) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[2].specular_0) + (light_src[2].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(18, clamp(light_src[2].dist_atten_scale * length(-light_src[2].position - view) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[3].position + view);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * LookupLightingLUTUnsigned(19, clamp(light_src[3].dist_atten_scale * length(-light_src[3].position - view) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[3].specular_0) + (light_src[3].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(19, clamp(light_src[3].dist_atten_scale * length(-light_src[3].position - view) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tex_env_out.rgb;
combiner_buffer = next_combiner_buffer;
if (last_tex_env_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: AD48125B67FC0A03, 11F75D1954448C2C
// program: 625982782CCD0D7B, F777123A8C3D5E20, 11F75D1954448C2C
// shader: 8B30, FF4FD8DEB017F2B5
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += ((light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[2].position + view);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * LookupLightingLUTUnsigned(18, clamp(light_src[2].dist_atten_scale * length(-light_src[2].position - view) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[2].specular_0) + (light_src[2].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(18, clamp(light_src[2].dist_atten_scale * length(-light_src[2].position - view) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[3].position + view);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * LookupLightingLUTUnsigned(19, clamp(light_src[3].dist_atten_scale * length(-light_src[3].position - view) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[3].specular_0) + (light_src[3].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(19, clamp(light_src[3].dist_atten_scale * length(-light_src[3].position - view) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tex_env_out.rgb;
combiner_buffer = next_combiner_buffer;
if (last_tex_env_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: B09163DA67FC0A03, FF4FD8DEB017F2B5
// program: 625982782CCD0D7B, F777123A8C3D5E20, FF4FD8DEB017F2B5
// reference: D29E8B37A0D60032, 4BE170182235D0BB
// shader: 8B30, B1FB792FA3003901
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb) + (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tex_env_out.rgb;
combiner_buffer = next_combiner_buffer;
if (last_tex_env_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 00AA78B823E92077, B1FB792FA3003901
// program: 625982782CCD0D7B, F777123A8C3D5E20, B1FB792FA3003901
// shader: 8B30, E92BD36993FCEF08
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += ((light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[2].position + view);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * LookupLightingLUTUnsigned(18, clamp(light_src[2].dist_atten_scale * length(-light_src[2].position - view) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[2].specular_0) + (light_src[2].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(18, clamp(light_src[2].dist_atten_scale * length(-light_src[2].position - view) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[3].position + view);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * LookupLightingLUTUnsigned(19, clamp(light_src[3].dist_atten_scale * length(-light_src[3].position - view) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[3].specular_0) + (light_src[3].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(19, clamp(light_src[3].dist_atten_scale * length(-light_src[3].position - view) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tex_env_out.rgb;
combiner_buffer = next_combiner_buffer;
if (last_tex_env_out.a <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: AD48125B8053B7C7, E92BD36993FCEF08
// program: 625982782CCD0D7B, F777123A8C3D5E20, E92BD36993FCEF08
// shader: 8B30, B0E49DB341B018F2
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0), vec3(1)));
float alpha_output_0 = (secondary_fragment_color.r);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1) - (last_tex_env_out.aaa)), vec3(0), vec3(1)));
float alpha_output_1 = (texcolor0.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = byteround(clamp((primary_fragment_color.rgb) * (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tex_env_out.rgb;
combiner_buffer = next_combiner_buffer;
if (last_tex_env_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 1D43E73885298F5E, B0E49DB341B018F2
// program: F57E43796F666394, F777123A8C3D5E20, B0E49DB341B018F2
// shader: 8DD9, EADA2116091C5E01

layout(triangles) in;
layout(triangle_strip, max_vertices=3) out;

layout(location=1) out vec4 primary_color;
layout(location=2) out vec2 texcoord0;
layout(location=3) out vec2 texcoord1;
layout(location=4) out vec2 texcoord2;
layout(location=5) out float texcoord0_w;
layout(location=6) out vec4 normquat;
layout(location=7) out vec3 view;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

layout(location=0) in vec4 vs_out_attr0[];
layout(location=1) in vec4 vs_out_attr1[];
layout(location=2) in vec4 vs_out_attr2[];
layout(location=3) in vec4 vs_out_attr3[];
layout(location=4) in vec4 vs_out_attr4[];
layout(location=5) in vec4 vs_out_attr5[];
layout(location=6) in vec4 vs_out_attr6[];
struct Vertex {
    vec4 attributes[7];
};

vec4 GetVertexQuaternion(Vertex vtx) {
    return vec4(vtx.attributes[1].x, vtx.attributes[1].y, vtx.attributes[1].z, vtx.attributes[1].w);
}

void EmitVtx(Vertex vtx, bool quats_opposite) {
    vec4 vtx_pos = vec4(vtx.attributes[0].x, vtx.attributes[0].y, vtx.attributes[0].z, vtx.attributes[0].w);
    gl_Position = vtx_pos;
#if !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)
    gl_ClipDistance[0] = -vtx_pos.z;
    gl_ClipDistance[1] = dot(clip_coef, vtx_pos);
#endif // !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)

    vec4 vtx_quat = GetVertexQuaternion(vtx);
    normquat = mix(vtx_quat, -vtx_quat, bvec4(quats_opposite));

    vec4 vtx_color = vec4(vtx.attributes[3].x, vtx.attributes[3].y, vtx.attributes[3].z, vtx.attributes[3].w);
    primary_color = clamp(vtx_color, vec4(0), vec4(1));

    texcoord0 = vec2(vtx.attributes[4].x, vtx.attributes[4].y);
    texcoord1 = vec2(vtx.attributes[5].x, vtx.attributes[5].y);

    texcoord0_w = vtx.attributes[4].z;
    view = vec3(vtx.attributes[2].x, vtx.attributes[2].y, vtx.attributes[2].z);
    texcoord2 = vec2(vtx.attributes[6].x, vtx.attributes[6].y);

    EmitVertex();
}

bool AreQuaternionsOpposite(vec4 qa, vec4 qb) {
    return (dot(qa, qb) < 0.0);
}

void EmitPrim(Vertex vtx0, Vertex vtx1, Vertex vtx2) {
    EmitVtx(vtx0, false);
    EmitVtx(vtx1, AreQuaternionsOpposite(GetVertexQuaternion(vtx0), GetVertexQuaternion(vtx1)));
    EmitVtx(vtx2, AreQuaternionsOpposite(GetVertexQuaternion(vtx0), GetVertexQuaternion(vtx2)));
    EndPrimitive();
}

void main() {
    Vertex prim_buffer[3];
    prim_buffer[0].attributes = vec4[7](vs_out_attr0[0], vs_out_attr1[0], vs_out_attr2[0], vs_out_attr3[0], vs_out_attr4[0], vs_out_attr5[0], vs_out_attr6[0]);
    prim_buffer[1].attributes = vec4[7](vs_out_attr0[1], vs_out_attr1[1], vs_out_attr2[1], vs_out_attr3[1], vs_out_attr4[1], vs_out_attr5[1], vs_out_attr6[1]);
    prim_buffer[2].attributes = vec4[7](vs_out_attr0[2], vs_out_attr1[2], vs_out_attr2[2], vs_out_attr3[2], vs_out_attr4[2], vs_out_attr5[2], vs_out_attr6[2]);
    EmitPrim(prim_buffer[0], prim_buffer[1], prim_buffer[2]);
}
// reference: FC74FA4ACA1C8C74, EADA2116091C5E01
// shader: 8B31, 9C1CAD21F8AE5682

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)

#define min_s(x, y) min(x, y)
#define max_s(x, y) max(x, y)

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout(binding=2, std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location=0) in vec4 vs_in_reg0;
layout(location=3) in vec4 vs_in_reg3;
layout(location=4) in vec4 vs_in_reg4;
layout(location=5) in vec4 vs_in_reg5;
layout(location=6) in vec4 vs_in_reg6;

layout(location=0) out vec4 vs_out_attr0;
layout(location=1) out vec4 vs_out_attr1;
layout(location=2) out vec4 vs_out_attr2;
layout(location=3) out vec4 vs_out_attr3;
layout(location=4) out vec4 vs_out_attr4;
layout(location=5) out vec4 vs_out_attr5;
layout(location=6) out vec4 vs_out_attr6;

void main() {
vs_out_attr0 = vec4(0, 0, 0, 1);
vs_out_attr1 = vec4(0, 0, 0, 1);
vs_out_attr2 = vec4(0, 0, 0, 1);
vs_out_attr3 = vec4(0, 0, 0, 1);
vs_out_attr4 = vec4(0, 0, 0, 1);
vs_out_attr5 = vec4(0, 0, 0, 1);
vs_out_attr6 = vec4(0, 0, 0, 1);
exec_shader();
}
bvec2 bool_regs = bvec2(false);
ivec3 addr_regs = ivec3(0);
vec4 reg_tmp0 = vec4(0, 0, 0, 1);
vec4 reg_tmp1 = vec4(0, 0, 0, 1);
vec4 reg_tmp2 = vec4(0, 0, 0, 1);
vec4 reg_tmp3 = vec4(0, 0, 0, 1);
vec4 reg_tmp4 = vec4(0, 0, 0, 1);
vec4 reg_tmp5 = vec4(0, 0, 0, 1);
vec4 reg_tmp6 = vec4(0, 0, 0, 1);
vec4 reg_tmp7 = vec4(0, 0, 0, 1);
vec4 reg_tmp8 = vec4(0, 0, 0, 1);
vec4 reg_tmp9 = vec4(0, 0, 0, 1);
vec4 reg_tmp10 = vec4(0, 0, 0, 1);
vec4 reg_tmp11 = vec4(0, 0, 0, 1);
vec4 reg_tmp12 = vec4(0, 0, 0, 1);
vec4 reg_tmp13 = vec4(0, 0, 0, 1);
vec4 reg_tmp14 = vec4(0, 0, 0, 1);
vec4 reg_tmp15 = vec4(0, 0, 0, 1);

bool sub_0();
bool sub_1();
bool sub_2();
bool sub_3();
bool sub_15();
bool sub_4();
bool sub_5();
bool sub_6();
bool sub_7();
bool sub_8();
bool sub_9();
bool sub_10();
bool sub_11();
bool sub_12();
bool sub_13();
bool sub_14();
bool sub_16();
bool sub_17();
bool sub_23();
bool sub_24();
bool sub_25();
bool sub_26();
bool sub_28();
bool sub_18();
bool sub_19();
bool sub_20();
bool sub_21();
bool sub_22();
bool sub_27();
bool sub_29();
bool sub_30();
bool sub_31();
bool sub_32();
bool sub_33();
bool sub_34();
bool sub_35();
bool sub_36();
bool sub_37();
bool sub_38();
bool sub_39();
bool sub_40();
bool sub_41();

bool exec_shader() {
sub_0();
return true;
}

bool sub_0() {
reg_tmp0 = vs_in_reg0;
vs_out_attr0 = reg_tmp0;
vs_out_attr2 = reg_tmp0;
vs_out_attr1 = reg_tmp0;
sub_1();
sub_16();
sub_30();
sub_37();
return true;
}
bool sub_1() {
reg_tmp8.xy = (uniforms.f[93].xxxx).xy;
reg_tmp0.y = (uniforms.f[7].wwww).y;
bool_regs = notEqual(uniforms.f[93].xx, reg_tmp0.xy);
reg_tmp9.xyz = (uniforms.f[93].xxxx).xyz;
reg_tmp9.w = (uniforms.f[21].wwww).w;
if (bool_regs.y) {
sub_2();
}
if (uniforms.b[12]) {
sub_4();
}
if (uniforms.b[5]) {
sub_13();
}
bool_regs = equal(uniforms.f[93].xx, reg_tmp8.xy);
if (all(bool_regs)) {
sub_15();
}
reg_tmp9 = uniforms.f[74] + reg_tmp9;
vs_out_attr3 = max_s(uniforms.f[93].xxxx, reg_tmp9);
return false;
}
bool sub_2() {
reg_tmp0 = mul_s(uniforms.f[7].wwww, vs_in_reg3);
if (uniforms.b[7]) {
sub_3();
}
reg_tmp9.xyz = (mul_s(uniforms.f[20].wwww, reg_tmp0.xyzz)).xyz;
reg_tmp8.x = (uniforms.f[93].yyyy).x;
return false;
}
bool sub_3() {
reg_tmp9.w = (mul_s(reg_tmp9.wwww, reg_tmp0.wwww)).w;
return false;
}
bool sub_15() {
reg_tmp9 = uniforms.f[21];
return false;
}
bool sub_4() {
reg_tmp1 = uniforms.f[20];
reg_tmp2 = uniforms.f[21];
reg_tmp3 = uniforms.f[93].xxxx;
addr_regs.z = int(uniforms.i[0].y);
for (uint i = 0u; i <= uniforms.i[0].x; addr_regs.z += int(uniforms.i[0].z), ++i) {
sub_5();
}
reg_tmp8.x = (uniforms.f[93].yyyy).x;
return false;
}
bool sub_5() {
addr_regs.x = (ivec2(reg_tmp3.xy)).x;
reg_tmp4.x = (uniforms.f[69 + addr_regs.x].wwww).x;
reg_tmp4.y = (uniforms.f[71 + addr_regs.x].wwww).y;
bool_regs = equal(uniforms.f[93].xy, reg_tmp4.xy);
if (bool_regs.x) {
sub_6();
} else {
sub_7();
}
bool_regs.x = uniforms.f[93].xxxx.x == reg_tmp6.xyyy.x;
bool_regs.y = uniforms.f[93].xxxx.y < reg_tmp6.xyyy.y;
if (bool_regs.y) {
sub_12();
}
reg_tmp3 = -uniforms.f[95].wwww + reg_tmp3;
return false;
}
bool sub_6() {
reg_tmp6.x = dot_3(uniforms.f[69 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp6.y = (uniforms.f[93].yyyy).y;
return false;
}
bool sub_7() {
reg_tmp4 = uniforms.f[69 + addr_regs.x] + -reg_tmp15;
reg_tmp6.y = (uniforms.f[93].yyyy).y;
if (bool_regs.y) {
sub_8();
}
reg_tmp5 = uniforms.f[70 + addr_regs.x];
bool_regs = equal(uniforms.f[93].yy, reg_tmp5.ww);
reg_tmp4.w = dot_3(reg_tmp4.xyz, reg_tmp4.xyz);
reg_tmp4.w = rsq_s(reg_tmp4.w);
reg_tmp4 = mul_s(reg_tmp4, reg_tmp4.wwww);
if (bool_regs.x) {
sub_9();
}
reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp4.xyz);
return false;
}
bool sub_8() {
reg_tmp5.x = (uniforms.f[93].yyyy).x;
reg_tmp5.z = dot_3(reg_tmp4.xyz, reg_tmp4.xyz);
reg_tmp5.y = (mul_s(reg_tmp5.zzzz, reg_tmp5.zzzz)).y;
reg_tmp6.y = dot_3(uniforms.f[71 + addr_regs.x].xyz, reg_tmp5.xyz);
reg_tmp6.y = rcp_s(reg_tmp6.y);
return false;
}
bool sub_9() {
reg_tmp5.x = dot_3(uniforms.f[70 + addr_regs.x].xyz, -reg_tmp4.xyz);
reg_tmp5.y = (vec4(lessThan(reg_tmp5.xxxx, uniforms.f[72 + addr_regs.x].yyyy))).y;
bool_regs = equal(uniforms.f[93].yy, reg_tmp5.xy);
if (bool_regs.y) {
sub_10();
} else {
sub_11();
}
reg_tmp6.y = (mul_s(reg_tmp6.yyyy, reg_tmp5.xxxx)).y;
return false;
}
bool sub_10() {
reg_tmp5.x = (uniforms.f[93].xxxx).x;
return false;
}
bool sub_11() {
reg_tmp5.y = log2(reg_tmp5.x);
reg_tmp5.y = (mul_s(uniforms.f[72 + addr_regs.x].xxxx, reg_tmp5.yyyy)).y;
reg_tmp5.x = exp2(reg_tmp5.y);
return false;
}
bool sub_12() {
reg_tmp6.x = (max_s(uniforms.f[93].xxxx, reg_tmp6.xxxx)).x;
reg_tmp9.xyz = (fma_s(reg_tmp1.xyzz, uniforms.f[67 + addr_regs.x].xyzz, reg_tmp9.xyzz)).xyz;
reg_tmp4 = mul_s(uniforms.f[68 + addr_regs.x], reg_tmp2);
reg_tmp5.xyz = (mul_s(reg_tmp6.xxxx, reg_tmp4.xyzz)).xyz;
reg_tmp5.xyz = (mul_s(reg_tmp6.yyyy, reg_tmp5.xyzz)).xyz;
reg_tmp9.xyz = (reg_tmp9.xyzz + reg_tmp5.xyzz).xyz;
reg_tmp9.w = (reg_tmp9.wwww + reg_tmp4.wwww).w;
return false;
}
bool sub_13() {
reg_tmp1 = vec4(dot_3(uniforms.f[24].xyz, reg_tmp14.xyz));
reg_tmp2 = uniforms.f[24].wwww;
reg_tmp1 = fma_s(reg_tmp1, reg_tmp2, reg_tmp2);
reg_tmp3 = uniforms.f[22];
reg_tmp2 = uniforms.f[23] + -reg_tmp3;
reg_tmp4 = fma_s(reg_tmp2, reg_tmp1, reg_tmp3);
if (uniforms.b[6]) {
sub_14();
}
reg_tmp9.xyz = (fma_s(reg_tmp4, uniforms.f[21], reg_tmp9)).xyz;
reg_tmp8.x = (uniforms.f[93].yyyy).x;
return false;
}
bool sub_14() {
reg_tmp4 = mul_s(reg_tmp4, reg_tmp9.wwww);
return false;
}
bool sub_16() {
reg_tmp0.xy = (uniforms.f[10].xxxx).xy;
if (uniforms.b[9]) {
sub_17();
} else {
sub_23();
}
return false;
}
bool sub_17() {
sub_18();
reg_tmp3.x = dot_s(uniforms.f[11].xywz, reg_tmp6);
reg_tmp3.y = dot_s(uniforms.f[12].xywz, reg_tmp6);
reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
vs_out_attr4 = reg_tmp3;
return false;
}
bool sub_23() {
bool_regs = equal(uniforms.f[95].xy, reg_tmp0.xy);
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
if (all(not(bool_regs))) {
sub_24();
} else {
sub_25();
}
vs_out_attr4 = reg_tmp3;
return false;
}
bool sub_24() {
reg_tmp6 = reg_tmp10;
reg_tmp3.x = dot_s(uniforms.f[11], reg_tmp6);
reg_tmp3.y = dot_s(uniforms.f[12], reg_tmp6);
reg_tmp3.z = dot_s(uniforms.f[13], reg_tmp6);
reg_tmp0.xy = (mul_s(uniforms.f[19].xyyy, reg_tmp3.zzzz)).xy;
reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
return false;
}
bool sub_25() {
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_26();
} else {
sub_28();
}
return false;
}
bool sub_26() {
sub_27();
reg_tmp3.x = dot_3(uniforms.f[11].xyz, reg_tmp6.xyz);
reg_tmp3.y = dot_3(uniforms.f[12].xyz, reg_tmp6.xyz);
reg_tmp3.z = dot_3(uniforms.f[13].xyz, reg_tmp6.xyz);
return false;
}
bool sub_28() {
sub_29();
reg_tmp3.x = dot_s(uniforms.f[11], reg_tmp6);
reg_tmp3.y = dot_s(uniforms.f[12], reg_tmp6);
return false;
}
bool sub_18() {
bool_regs = equal(uniforms.f[93].yz, reg_tmp0.xy);
if (all(not(bool_regs))) {
sub_19();
} else {
sub_20();
}
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
return false;
}
bool sub_19() {
reg_tmp6.xy = (mul_s(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
return false;
}
bool sub_20() {
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_21();
} else {
sub_22();
}
return false;
}
bool sub_21() {
reg_tmp6.xy = (mul_s(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
return false;
}
bool sub_22() {
reg_tmp6.xy = (mul_s(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
return false;
}
bool sub_27() {
reg_tmp2 = -reg_tmp15;
reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
reg_tmp2.w = rsq_s(reg_tmp2.w);
reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
reg_tmp1 = reg_tmp1 + reg_tmp1;
reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
return false;
}
bool sub_29() {
reg_tmp1.xy = (uniforms.f[94].zzzz).xy;
reg_tmp1.zw = (uniforms.f[93].xxxx).zw;
reg_tmp6 = fma_s(reg_tmp14, reg_tmp1, reg_tmp1);
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
return false;
}
bool sub_30() {
reg_tmp0.xy = (uniforms.f[10].yyyy).xy;
if (uniforms.b[10]) {
sub_31();
} else {
sub_32();
}
return false;
}
bool sub_31() {
sub_18();
reg_tmp4.x = dot_s(uniforms.f[14].xywz, reg_tmp6);
reg_tmp4.y = dot_s(uniforms.f[15].xywz, reg_tmp6);
vs_out_attr5 = reg_tmp4;
return false;
}
bool sub_32() {
if (uniforms.b[13]) {
sub_33();
} else {
sub_36();
}
return false;
}
bool sub_33() {
bool_regs = equal(uniforms.f[95].xy, reg_tmp0.xy);
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
if (all(not(bool_regs))) {
sub_34();
} else {
sub_35();
}
vs_out_attr5 = reg_tmp4;
return false;
}
bool sub_34() {
reg_tmp6 = reg_tmp10;
reg_tmp4.x = dot_s(uniforms.f[14], reg_tmp6);
reg_tmp4.y = dot_s(uniforms.f[15], reg_tmp6);
reg_tmp4.z = dot_s(uniforms.f[16], reg_tmp6);
reg_tmp6.w = rcp_s(reg_tmp4.z);
reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
reg_tmp4.xy = (uniforms.f[19].zwww + reg_tmp4.xyyy).xy;
return false;
}
bool sub_35() {
sub_29();
reg_tmp4.x = dot_s(uniforms.f[14], reg_tmp6);
reg_tmp4.y = dot_s(uniforms.f[15], reg_tmp6);
return false;
}
bool sub_36() {
vs_out_attr5 = uniforms.f[93].xxxx;
return false;
}
bool sub_37() {
reg_tmp0.xy = (uniforms.f[10].zzzz).xy;
if (uniforms.b[11]) {
sub_38();
} else {
sub_39();
}
return false;
}
bool sub_38() {
sub_18();
reg_tmp5.x = dot_s(uniforms.f[17].xywz, reg_tmp6);
reg_tmp5.y = dot_s(uniforms.f[18].xywz, reg_tmp6);
vs_out_attr6 = reg_tmp5;
return false;
}
bool sub_39() {
if (uniforms.b[14]) {
sub_40();
} else {
sub_41();
}
return false;
}
bool sub_40() {
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
reg_tmp5.zw = (reg_tmp6.zwww).zw;
sub_29();
reg_tmp5.x = dot_s(uniforms.f[17], reg_tmp6);
reg_tmp5.y = dot_s(uniforms.f[18], reg_tmp6);
vs_out_attr6 = reg_tmp5;
return false;
}
bool sub_41() {
vs_out_attr6 = uniforms.f[93].xxxx;
return false;
}
// reference: 96A413ACD5ACD331, 9C1CAD21F8AE5682
// shader: 8B30, 95B8E534AADF3E9E
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))) + tex_lod_bias[2]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((vec3(1) - texcolor0.rrr) - (vec3(1) - texcolor1.rrr), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((1.0 - texcolor0.r) - (1.0 - texcolor2.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0 * 4.0, alpha_output_0 * 4.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) + (last_tex_env_out.aaa), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1 * 4.0, alpha_output_1 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2 * 4.0, alpha_output_2 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = byteround(clamp(min((last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(1)) * (vec3(1) - texcolor0.rrr), vec3(0), vec3(1)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_4 = (vec3(1) - last_tex_env_out.rgb);
float alpha_output_4 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_5 = byteround(clamp((texcolor0.rgb) + (const_color[5].rgb), vec3(0), vec3(1)));
float alpha_output_5 = byteround(clamp((1.0 - last_tex_env_out.r) - (const_color[5].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 7A4144A38E836A4C, 95B8E534AADF3E9E
// program: 9C1CAD21F8AE5682, EADA2116091C5E01, 95B8E534AADF3E9E
// shader: 8B30, 4E49D908F8986C97
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))) + tex_lod_bias[2]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((vec3(1) - texcolor0.rrr) - (vec3(1) - texcolor1.rrr), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((1.0 - texcolor0.r) - (1.0 - texcolor2.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0 * 4.0, alpha_output_0 * 4.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) + (last_tex_env_out.aaa), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1 * 4.0, alpha_output_1 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2 * 4.0, alpha_output_2 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = byteround(clamp(min((last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(1)) * (vec3(1) - texcolor0.rrr), vec3(0), vec3(1)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_4 = byteround(clamp((vec3(1) - last_tex_env_out.rgb) + (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_4 = byteround(clamp((1.0 - last_tex_env_out.r) + (const_color[4].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: E7D0A001C436485A, 4E49D908F8986C97
// program: 9C1CAD21F8AE5682, EADA2116091C5E01, 4E49D908F8986C97
// shader: 8B30, 0AC6110A4E33F0FC
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = (primary_fragment_color.rgb);
float alpha_output_0 = (rounded_primary_color.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: C4AFFEA11E6962DB, 0AC6110A4E33F0FC
// program: 625982782CCD0D7B, F777123A8C3D5E20, 0AC6110A4E33F0FC
// shader: 8B31, E975381023D83439

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)

#define min_s(x, y) min(x, y)
#define max_s(x, y) max(x, y)

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout(binding=2, std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location=0) in vec4 vs_in_reg0;
layout(location=1) in vec4 vs_in_reg1;
layout(location=2) in vec4 vs_in_reg2;
layout(location=3) in vec4 vs_in_reg3;
layout(location=7) in vec4 vs_in_reg7;
layout(location=8) in vec4 vs_in_reg8;

layout(location=0) out vec4 vs_out_attr0;
layout(location=1) out vec4 vs_out_attr1;
layout(location=2) out vec4 vs_out_attr2;
layout(location=3) out vec4 vs_out_attr3;
layout(location=4) out vec4 vs_out_attr4;
layout(location=5) out vec4 vs_out_attr5;
layout(location=6) out vec4 vs_out_attr6;

void main() {
vs_out_attr0 = vec4(0, 0, 0, 1);
vs_out_attr1 = vec4(0, 0, 0, 1);
vs_out_attr2 = vec4(0, 0, 0, 1);
vs_out_attr3 = vec4(0, 0, 0, 1);
vs_out_attr4 = vec4(0, 0, 0, 1);
vs_out_attr5 = vec4(0, 0, 0, 1);
vs_out_attr6 = vec4(0, 0, 0, 1);
exec_shader();
}
bvec2 bool_regs = bvec2(false);
ivec3 addr_regs = ivec3(0);
vec4 reg_tmp0 = vec4(0, 0, 0, 1);
vec4 reg_tmp1 = vec4(0, 0, 0, 1);
vec4 reg_tmp2 = vec4(0, 0, 0, 1);
vec4 reg_tmp3 = vec4(0, 0, 0, 1);
vec4 reg_tmp4 = vec4(0, 0, 0, 1);
vec4 reg_tmp5 = vec4(0, 0, 0, 1);
vec4 reg_tmp6 = vec4(0, 0, 0, 1);
vec4 reg_tmp7 = vec4(0, 0, 0, 1);
vec4 reg_tmp8 = vec4(0, 0, 0, 1);
vec4 reg_tmp9 = vec4(0, 0, 0, 1);
vec4 reg_tmp10 = vec4(0, 0, 0, 1);
vec4 reg_tmp11 = vec4(0, 0, 0, 1);
vec4 reg_tmp12 = vec4(0, 0, 0, 1);
vec4 reg_tmp13 = vec4(0, 0, 0, 1);
vec4 reg_tmp14 = vec4(0, 0, 0, 1);
vec4 reg_tmp15 = vec4(0, 0, 0, 1);

bool sub_0();
bool sub_21();
bool sub_4();
bool sub_9();
bool sub_1();
bool sub_2();
bool sub_3();
bool sub_5();
bool sub_7();
bool sub_8();
bool sub_10();
bool sub_20();
bool sub_22();
bool sub_23();
bool sub_24();
bool sub_25();
bool sub_26();
bool sub_27();
bool sub_28();
bool sub_29();
bool sub_30();
bool sub_31();
bool sub_6();
bool sub_11();
bool sub_12();
bool sub_13();
bool sub_14();
bool sub_15();
bool sub_16();
bool sub_17();
bool sub_18();
bool sub_19();
bool sub_32();
bool sub_33();
bool sub_34();
bool sub_44();
bool sub_35();
bool sub_36();
bool sub_37();
bool sub_38();
bool sub_39();
bool sub_40();
bool sub_41();
bool sub_42();
bool sub_43();

bool exec_shader() {
sub_0();
return true;
}

bool sub_0() {
sub_1();
sub_32();
vs_out_attr4 = uniforms.f[93].xxxx;
vs_out_attr5 = uniforms.f[93].xxxx;
vs_out_attr6 = uniforms.f[93].xxxx;
return true;
}
bool sub_21() {
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp3.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp3.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp3.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
return false;
}
bool sub_4() {
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp3.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp3.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp3.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp4.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
return false;
}
bool sub_9() {
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp3.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp3.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp3.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp4.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp5.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp5.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp5.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
reg_tmp11 = fma_s(reg_tmp1.wwww, reg_tmp5, reg_tmp11);
return false;
}
bool sub_1() {
reg_tmp15.xyz = (mul_s(uniforms.f[7].xxxx, vs_in_reg0)).xyz;
reg_tmp14.xyz = (mul_s(uniforms.f[7].yyyy, vs_in_reg1)).xyz;
reg_tmp13.xyz = (mul_s(uniforms.f[7].zzzz, vs_in_reg2)).xyz;
reg_tmp15.xyz = (uniforms.f[6] + reg_tmp15).xyz;
reg_tmp15.w = (uniforms.f[93].yyyy).w;
if (uniforms.b[1]) {
sub_2();
} else {
sub_24();
}
return false;
}
bool sub_2() {
reg_tmp0 = uniforms.f[7];
bool_regs = notEqual(uniforms.f[93].xx, reg_tmp0.yz);
reg_tmp7 = uniforms.f[93].xxxx;
reg_tmp12 = uniforms.f[93].xxxx;
reg_tmp11 = uniforms.f[93].xxxx;
reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_3();
} else {
sub_7();
}
vs_out_attr2 = -reg_tmp15;
reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
reg_tmp1.x = (-reg_tmp0.wwww).x;
reg_tmp1.y = (mul_s(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
bool_regs.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
bool_regs.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
if (all(bool_regs)) {
sub_23();
}
vs_out_attr0 = reg_tmp0;
return false;
}
bool sub_3() {
bool_regs = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
reg_tmp1.xy = (reg_tmp2.xxxx).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
sub_4();
reg_tmp1.xy = (reg_tmp2.yyyy).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
sub_4();
reg_tmp1.xy = (reg_tmp2.zzzz).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
if (bool_regs.x) {
sub_4();
}
if (uniforms.b[8]) {
sub_5();
}
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp6.y = (-uniforms.f[85].wwww + reg_tmp10.yyyy).y;
reg_tmp9.xyz = (uniforms.f[85].xyzz).xyz;
reg_tmp7.x = dot_s(reg_tmp9.xyzz, reg_tmp9.xyzz);
reg_tmp7.x = rsq_s(reg_tmp7.x);
reg_tmp7.xyz = (mul_s(reg_tmp9.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp8.y = rcp_s(-reg_tmp7.y);
reg_tmp8.y = (mul_s(reg_tmp6.yyyy, reg_tmp8.yyyy)).y;
reg_tmp7.xyz = (mul_s(reg_tmp7.xyzz, reg_tmp8.yyyy)).xyz;
reg_tmp10.xyz = (reg_tmp10.xyzz + reg_tmp7.xyzz).xyz;
reg_tmp10.y = (uniforms.f[94].zzzz + reg_tmp10.yyyy).y;
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
sub_6();
return false;
}
bool sub_5() {
reg_tmp1.xy = (reg_tmp2.wwww).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
if (bool_regs.y) {
sub_4();
}
return false;
}
bool sub_7() {
if (all(bool_regs)) {
sub_8();
} else {
sub_20();
}
return false;
}
bool sub_8() {
bool_regs = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
reg_tmp1.xy = (reg_tmp2.xxxx).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
sub_9();
reg_tmp1.xy = (reg_tmp2.yyyy).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
sub_9();
reg_tmp1.xy = (reg_tmp2.zzzz).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
if (bool_regs.x) {
sub_9();
}
if (uniforms.b[8]) {
sub_10();
}
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp13.x = dot_3(uniforms.f[3].xyz, reg_tmp11.xyz);
reg_tmp13.y = dot_3(uniforms.f[4].xyz, reg_tmp11.xyz);
reg_tmp13.z = dot_3(uniforms.f[5].xyz, reg_tmp11.xyz);
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
reg_tmp6.y = (-uniforms.f[85].wwww + reg_tmp10.yyyy).y;
reg_tmp9.xyz = (uniforms.f[85].xyzz).xyz;
reg_tmp7.x = dot_s(reg_tmp9.xyzz, reg_tmp9.xyzz);
reg_tmp7.x = rsq_s(reg_tmp7.x);
reg_tmp7.xyz = (mul_s(reg_tmp9.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp8.y = rcp_s(-reg_tmp7.y);
reg_tmp8.y = (mul_s(reg_tmp6.yyyy, reg_tmp8.yyyy)).y;
reg_tmp7.xyz = (mul_s(reg_tmp7.xyzz, reg_tmp8.yyyy)).xyz;
reg_tmp10.xyz = (reg_tmp10.xyzz + reg_tmp7.xyzz).xyz;
reg_tmp10.y = (uniforms.f[94].zzzz + reg_tmp10.yyyy).y;
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
sub_11();
return false;
}
bool sub_10() {
reg_tmp1.xy = (reg_tmp2.wwww).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
if (bool_regs.y) {
sub_9();
}
return false;
}
bool sub_20() {
bool_regs = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
reg_tmp1.xy = (reg_tmp2.xxxx).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
sub_21();
reg_tmp1.xy = (reg_tmp2.yyyy).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
sub_21();
reg_tmp1.xy = (reg_tmp2.zzzz).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
if (bool_regs.x) {
sub_21();
}
if (uniforms.b[8]) {
sub_22();
}
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp6.y = (-uniforms.f[85].wwww + reg_tmp10.yyyy).y;
reg_tmp9.xyz = (uniforms.f[85].xyzz).xyz;
reg_tmp7.x = dot_s(reg_tmp9.xyzz, reg_tmp9.xyzz);
reg_tmp7.x = rsq_s(reg_tmp7.x);
reg_tmp7.xyz = (mul_s(reg_tmp9.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp8.y = rcp_s(-reg_tmp7.y);
reg_tmp8.y = (mul_s(reg_tmp6.yyyy, reg_tmp8.yyyy)).y;
reg_tmp7.xyz = (mul_s(reg_tmp7.xyzz, reg_tmp8.yyyy)).xyz;
reg_tmp10.xyz = (reg_tmp10.xyzz + reg_tmp7.xyzz).xyz;
reg_tmp10.y = (uniforms.f[94].zzzz + reg_tmp10.yyyy).y;
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
vs_out_attr1 = uniforms.f[93].xxxx;
return false;
}
bool sub_22() {
reg_tmp1.xy = (reg_tmp2.wwww).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
if (bool_regs.y) {
sub_21();
}
return false;
}
bool sub_23() {
reg_tmp0.x = (-reg_tmp0.wwww).x;
return false;
}
bool sub_24() {
reg_tmp0 = uniforms.f[7];
bool_regs = notEqual(uniforms.f[93].xx, reg_tmp0.yz);
if (uniforms.b[2]) {
sub_25();
} else {
sub_26();
}
reg_tmp6.y = (-uniforms.f[85].wwww + reg_tmp10.yyyy).y;
reg_tmp9.xyz = (uniforms.f[85].xyzz).xyz;
reg_tmp7.x = dot_s(reg_tmp9.xyzz, reg_tmp9.xyzz);
reg_tmp7.x = rsq_s(reg_tmp7.x);
reg_tmp7.xyz = (mul_s(reg_tmp9.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp8.y = rcp_s(-reg_tmp7.y);
reg_tmp8.y = (mul_s(reg_tmp6.yyyy, reg_tmp8.yyyy)).y;
reg_tmp7.xyz = (mul_s(reg_tmp7.xyzz, reg_tmp8.yyyy)).xyz;
reg_tmp10.xyz = (reg_tmp10.xyzz + reg_tmp7.xyzz).xyz;
reg_tmp10.y = (uniforms.f[94].zzzz + reg_tmp10.yyyy).y;
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_27();
} else {
sub_28();
}
vs_out_attr2 = -reg_tmp15;
reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
reg_tmp1.x = (-reg_tmp0.wwww).x;
reg_tmp1.y = (mul_s(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
bool_regs.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
bool_regs.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
if (all(bool_regs)) {
sub_31();
}
vs_out_attr0 = reg_tmp0;
return false;
}
bool sub_25() {
reg_tmp1.x = (mul_s(uniforms.f[93].wwww, vs_in_reg7.xxxx)).x;
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp7.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp7.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp7.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
return false;
}
bool sub_26() {
addr_regs.x = (ivec2(uniforms.f[93].xx)).x;
reg_tmp10.x = dot_s(uniforms.f[25], reg_tmp15);
reg_tmp10.y = dot_s(uniforms.f[26], reg_tmp15);
reg_tmp10.z = dot_s(uniforms.f[27], reg_tmp15);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
return false;
}
bool sub_27() {
reg_tmp12.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
sub_6();
return false;
}
bool sub_28() {
if (all(bool_regs)) {
sub_29();
} else {
sub_30();
}
return false;
}
bool sub_29() {
reg_tmp12.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp11.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp11.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp11.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
reg_tmp13.x = dot_3(uniforms.f[3].xyz, reg_tmp11.xyz);
reg_tmp13.y = dot_3(uniforms.f[4].xyz, reg_tmp11.xyz);
reg_tmp13.z = dot_3(uniforms.f[5].xyz, reg_tmp11.xyz);
sub_11();
return false;
}
bool sub_30() {
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
vs_out_attr1 = uniforms.f[93].xxxx;
return false;
}
bool sub_31() {
reg_tmp0.x = (-reg_tmp0.wwww).x;
return false;
}
bool sub_6() {
uint jmp_to = 254u;
while (true) {
switch (jmp_to) {
case 254u:
reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
reg_tmp6.x = rsq_s(reg_tmp6.x);
reg_tmp7.x = rsq_s(reg_tmp7.x);
reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp0 = uniforms.f[93].yxxx;
if (!uniforms.b[15]) {
jmp_to = 270u; break;
}
reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
reg_tmp4 = mul_s(uniforms.f[94].zzzz, reg_tmp4);
bool_regs = greaterThanEqual(uniforms.f[93].xx, reg_tmp4.xx);
reg_tmp4 = vec4(rsq_s(reg_tmp4.x));
reg_tmp5 = mul_s(uniforms.f[94].zzzz, reg_tmp14);
if (bool_regs.x) {
jmp_to = 270u; break;
}
reg_tmp0.z = rcp_s(reg_tmp4.x);
reg_tmp0.xy = (mul_s(reg_tmp5, reg_tmp4)).xy;
case 270u:
vs_out_attr1 = reg_tmp0;
default: return false;
}
}
return false;
}
bool sub_11() {
uint jmp_to = 271u;
while (true) {
switch (jmp_to) {
case 271u:
reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
reg_tmp6.x = rsq_s(reg_tmp6.x);
reg_tmp7.x = rsq_s(reg_tmp7.x);
reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp13.xyz = (mul_s(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp11.xyz = (mul_s(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp0 = uniforms.f[93].yxxx;
if (!uniforms.b[15]) {
jmp_to = 346u; break;
}
reg_tmp13.xyz = (mul_s(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp11.xyz = (mul_s(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp5 = mul_s(reg_tmp14.yzxx, reg_tmp13.zxyy);
reg_tmp5 = fma_s(-reg_tmp13.yzxx, reg_tmp14.zxyy, reg_tmp5);
reg_tmp5.w = dot_3(reg_tmp5.xyz, reg_tmp5.xyz);
reg_tmp5.w = rsq_s(reg_tmp5.w);
reg_tmp5 = mul_s(reg_tmp5, reg_tmp5.wwww);
reg_tmp6.w = (reg_tmp14.zzzz + reg_tmp5.yyyy).w;
reg_tmp13 = mul_s(reg_tmp5.yzxx, reg_tmp14.zxyy);
reg_tmp13 = fma_s(-reg_tmp14.yzxx, reg_tmp5.zxyy, reg_tmp13);
reg_tmp6.w = (reg_tmp13.xxxx + reg_tmp6).w;
reg_tmp13.w = (reg_tmp5.zzzz).w;
reg_tmp5.z = (reg_tmp13.xxxx).z;
reg_tmp6.w = (uniforms.f[93].yyyy + reg_tmp6).w;
reg_tmp14.w = (reg_tmp5.xxxx).w;
reg_tmp5.x = (reg_tmp14.zzzz).x;
bool_regs = lessThan(uniforms.f[94].yy, reg_tmp6.ww);
reg_tmp6.x = (uniforms.f[93].yyyy).x;
reg_tmp6.y = (-uniforms.f[93].yyyy).y;
if (!bool_regs.x) {
jmp_to = 308u; break;
}
reg_tmp7.xz = (reg_tmp13.wwyy + -reg_tmp14.yyww).xz;
reg_tmp7.y = (reg_tmp14.xxxx + -reg_tmp13.zzzz).y;
reg_tmp7.w = (reg_tmp6).w;
reg_tmp6 = vec4(dot_s(reg_tmp7, reg_tmp7));
reg_tmp6 = vec4(rsq_s(reg_tmp6.x));
reg_tmp0 = mul_s(reg_tmp7, reg_tmp6);
if (uniforms.b[0]) {
jmp_to = 346u; break;
}
case 308u:
bool_regs = greaterThan(reg_tmp5.zy, reg_tmp5.yx);
if (bool_regs.x) {
sub_12();
} else {
sub_17();
}
reg_tmp6 = vec4(dot_s(reg_tmp8, reg_tmp8));
reg_tmp6 = vec4(rsq_s(reg_tmp6.x));
reg_tmp0 = mul_s(reg_tmp8, reg_tmp6);
case 346u:
vs_out_attr1 = reg_tmp0;
default: return false;
}
}
return false;
}
bool sub_12() {
if (bool_regs.y) {
sub_13();
} else {
sub_14();
}
reg_tmp8.w = (-reg_tmp8).w;
return false;
}
bool sub_13() {
reg_tmp8 = mul_s(reg_tmp13.yyzw, reg_tmp6.xxxy);
reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
return false;
}
bool sub_14() {
bool_regs = greaterThan(reg_tmp5.zz, reg_tmp5.xx);
reg_tmp8 = mul_s(reg_tmp13.yyzw, reg_tmp6.xxxy);
reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
if (bool_regs.x) {
sub_15();
} else {
sub_16();
}
return false;
}
bool sub_15() {
reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
return false;
}
bool sub_16() {
reg_tmp8 = mul_s(reg_tmp13.zwwy, reg_tmp6.xxxy);
reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
return false;
}
bool sub_17() {
if (bool_regs.y) {
sub_18();
} else {
sub_19();
}
return false;
}
bool sub_18() {
reg_tmp8 = mul_s(reg_tmp13.yywz, reg_tmp6.xxxy);
reg_tmp8.y = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).y;
reg_tmp9 = reg_tmp5.yyyy + -reg_tmp5.xxxx;
reg_tmp8.xzw = (reg_tmp8 + reg_tmp14.wwyx).xzw;
reg_tmp8.y = (reg_tmp9 + reg_tmp8).y;
return false;
}
bool sub_19() {
reg_tmp8 = mul_s(reg_tmp13.zwwy, reg_tmp6.xxxy);
reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
reg_tmp8.w = (-reg_tmp8).w;
return false;
}
bool sub_32() {
reg_tmp8.xy = (uniforms.f[93].xxxx).xy;
reg_tmp0.y = (uniforms.f[7].wwww).y;
bool_regs = notEqual(uniforms.f[93].xx, reg_tmp0.xy);
reg_tmp9.xyz = (uniforms.f[93].xxxx).xyz;
reg_tmp9.w = (uniforms.f[21].wwww).w;
if (bool_regs.y) {
sub_33();
}
if (uniforms.b[12]) {
sub_35();
}
bool_regs = equal(uniforms.f[93].xx, reg_tmp8.xy);
if (all(bool_regs)) {
sub_44();
}
reg_tmp0.xyz = (uniforms.f[24].xyzz + -reg_tmp10.xyzz).xyz;
reg_tmp0.w = rcp_s(uniforms.f[24].w);
reg_tmp1.w = dot_3(reg_tmp0.xyz, reg_tmp0.xyz);
reg_tmp1.w = (mul_s(reg_tmp0.wwww, reg_tmp1.wwww)).w;
reg_tmp1.w = (min_s(uniforms.f[93].yyyy, reg_tmp1.wwww)).w;
reg_tmp9.w = (uniforms.f[93].yyyy + -reg_tmp1.wwww).w;
vs_out_attr3 = max_s(uniforms.f[93].xxxx, reg_tmp9);
return false;
}
bool sub_33() {
reg_tmp0 = mul_s(uniforms.f[7].wwww, vs_in_reg3);
if (uniforms.b[7]) {
sub_34();
}
reg_tmp9.xyz = (mul_s(uniforms.f[20].wwww, reg_tmp0.xyzz)).xyz;
reg_tmp8.x = (uniforms.f[93].yyyy).x;
return false;
}
bool sub_34() {
reg_tmp9.w = (mul_s(reg_tmp9.wwww, reg_tmp0.wwww)).w;
return false;
}
bool sub_44() {
reg_tmp9 = uniforms.f[21];
return false;
}
bool sub_35() {
reg_tmp1 = uniforms.f[20];
reg_tmp2 = uniforms.f[21];
reg_tmp3 = uniforms.f[93].xxxx;
addr_regs.z = int(uniforms.i[0].y);
for (uint i = 0u; i <= uniforms.i[0].x; addr_regs.z += int(uniforms.i[0].z), ++i) {
sub_36();
}
reg_tmp8.x = (uniforms.f[93].yyyy).x;
return false;
}
bool sub_36() {
addr_regs.x = (ivec2(reg_tmp3.xy)).x;
reg_tmp4.x = (uniforms.f[81 + addr_regs.x].wwww).x;
reg_tmp4.y = (uniforms.f[83 + addr_regs.x].wwww).y;
bool_regs = equal(uniforms.f[93].xy, reg_tmp4.xy);
if (bool_regs.x) {
sub_37();
} else {
sub_38();
}
bool_regs.x = uniforms.f[93].xxxx.x == reg_tmp6.xyyy.x;
bool_regs.y = uniforms.f[93].xxxx.y < reg_tmp6.xyyy.y;
if (bool_regs.y) {
sub_43();
}
reg_tmp3 = -uniforms.f[95].wwww + reg_tmp3;
return false;
}
bool sub_37() {
reg_tmp6.x = dot_3(uniforms.f[81 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp6.y = (uniforms.f[93].yyyy).y;
return false;
}
bool sub_38() {
reg_tmp4 = uniforms.f[81 + addr_regs.x] + -reg_tmp15;
reg_tmp6.y = (uniforms.f[93].yyyy).y;
if (bool_regs.y) {
sub_39();
}
reg_tmp5 = uniforms.f[82 + addr_regs.x];
bool_regs = equal(uniforms.f[93].yy, reg_tmp5.ww);
reg_tmp4.w = dot_3(reg_tmp4.xyz, reg_tmp4.xyz);
reg_tmp4.w = rsq_s(reg_tmp4.w);
reg_tmp4 = mul_s(reg_tmp4, reg_tmp4.wwww);
if (bool_regs.x) {
sub_40();
}
reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp4.xyz);
return false;
}
bool sub_39() {
reg_tmp5.x = (uniforms.f[93].yyyy).x;
reg_tmp5.z = dot_3(reg_tmp4.xyz, reg_tmp4.xyz);
reg_tmp5.y = (mul_s(reg_tmp5.zzzz, reg_tmp5.zzzz)).y;
reg_tmp6.y = dot_3(uniforms.f[83 + addr_regs.x].xyz, reg_tmp5.xyz);
reg_tmp6.y = rcp_s(reg_tmp6.y);
return false;
}
bool sub_40() {
reg_tmp5.x = dot_3(uniforms.f[82 + addr_regs.x].xyz, -reg_tmp4.xyz);
reg_tmp5.y = (vec4(lessThan(reg_tmp5.xxxx, uniforms.f[84 + addr_regs.x].yyyy))).y;
bool_regs = equal(uniforms.f[93].yy, reg_tmp5.xy);
if (bool_regs.y) {
sub_41();
} else {
sub_42();
}
reg_tmp6.y = (mul_s(reg_tmp6.yyyy, reg_tmp5.xxxx)).y;
return false;
}
bool sub_41() {
reg_tmp5.x = (uniforms.f[93].xxxx).x;
return false;
}
bool sub_42() {
reg_tmp5.y = log2(reg_tmp5.x);
reg_tmp5.y = (mul_s(uniforms.f[84 + addr_regs.x].xxxx, reg_tmp5.yyyy)).y;
reg_tmp5.x = exp2(reg_tmp5.y);
return false;
}
bool sub_43() {
reg_tmp6.x = (max_s(uniforms.f[93].xxxx, reg_tmp6.xxxx)).x;
reg_tmp9.xyz = (fma_s(reg_tmp1.xyzz, uniforms.f[79 + addr_regs.x].xyzz, reg_tmp9.xyzz)).xyz;
reg_tmp4 = mul_s(uniforms.f[80 + addr_regs.x], reg_tmp2);
reg_tmp5.xyz = (mul_s(reg_tmp6.xxxx, reg_tmp4.xyzz)).xyz;
reg_tmp5.xyz = (mul_s(reg_tmp6.yyyy, reg_tmp5.xyzz)).xyz;
reg_tmp9.xyz = (reg_tmp9.xyzz + reg_tmp5.xyzz).xyz;
reg_tmp9.w = (reg_tmp9.wwww + reg_tmp4.wwww).w;
return false;
}
// reference: BDB4F0648008392F, E975381023D83439
// shader: 8B30, 3CE788AAD98E52BD
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((vec3(1) - rounded_primary_color.aaa) + (const_color[0].aaa), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((const_color[0].a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) + (vec3(1) - const_color[1].aaa), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 122B1BC87A7F08A4, 3CE788AAD98E52BD
// program: E975381023D83439, EADA2116091C5E01, 3CE788AAD98E52BD
// shader: 8B30, 7EC0468B999B1DDE
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((vec3(1) - rounded_primary_color.aaa) + (const_color[0].aaa), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((const_color[0].a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) + (vec3(1) - const_color[1].aaa), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_5 = (rounded_primary_color.rgb);
float alpha_output_5 = (rounded_primary_color.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 122B1BC8CEDB8484, 7EC0468B999B1DDE
// program: 0000000000000000, 0000000000000000, 7EC0468B999B1DDE
// shader: 8B30, 457EC63A7A40DFEE
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((vec3(1) - rounded_primary_color.aaa) + (const_color[0].aaa), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((const_color[0].a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) + (vec3(1) - const_color[1].aaa), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = byteround(clamp((const_color[3].rgb) * (vec3(1) - texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_3 = byteround(clamp((const_color[3].a) * (1.0 - texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (texcolor0.rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (texcolor0.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
if (last_tex_env_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 8B925B604401717D, 457EC63A7A40DFEE
// program: 3AE9AAE877A9E01A, B6B95AFD9466EC70, 457EC63A7A40DFEE
// shader: 8B30, 0C1BCF5B3871257A
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((vec3(1) - rounded_primary_color.aaa) + (const_color[0].aaa), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((const_color[0].a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) + (vec3(1) - const_color[1].aaa), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = byteround(clamp((const_color[3].rgb) * (vec3(1) - texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_3 = byteround(clamp((const_color[3].a) * (1.0 - texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (texcolor0.rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (texcolor0.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_5 = (rounded_primary_color.rgb);
float alpha_output_5 = (rounded_primary_color.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 7952612D50BAFAF3, 0C1BCF5B3871257A
// program: 0000000000000000, 0000000000000000, 0C1BCF5B3871257A
// reference: D5BC3BF65E2851B9, B7A9B6AE77A46D16
// reference: B09163DAC48EFC61, FF4FD8DEB017F2B5
// reference: AD48125BC48EFC61, 11F75D1954448C2C
// reference: 7E7A37C3338717CA, F705E732A249D088
// reference: D29E8B3703A4F650, 4BE170182235D0BB
// reference: AD48125B232141A5, E92BD36993FCEF08
// shader: 8B30, 8560378E1617BECE
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = (rounded_primary_color.rgb);
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (1.0 - texcolor0.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 3DF731E0BFC60E39, 8560378E1617BECE
// program: 625982782CCD0D7B, F777123A8C3D5E20, 8560378E1617BECE
// reference: 2EC95D1F338717CA, F705E732A249D088
// reference: 7E7A37C35ACB123B, F705E732A249D088
// shader: 8B30, 916CA6876C957D82
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((vec3(1) - rounded_primary_color.aaa) + (const_color[0].aaa), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((const_color[0].a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) + (vec3(1) - const_color[1].aaa), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = byteround(clamp((const_color[3].rgb) * (vec3(1) - texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_3 = byteround(clamp((const_color[3].a) * (1.0 - texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (texcolor0.rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (texcolor0.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (const_color[5].rgb), vec3(0), vec3(1)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (const_color[5].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
if (last_tex_env_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 8B925B6047E396CF, 916CA6876C957D82
// program: 3AE9AAE877A9E01A, B6B95AFD9466EC70, 916CA6876C957D82
// shader: 8B30, 993677A7EEF1569D
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((vec3(1) - rounded_primary_color.aaa) + (const_color[0].aaa), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((const_color[0].a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) + (vec3(1) - const_color[1].aaa), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = byteround(clamp((vec3(1) - texcolor0.rgb) * (const_color[3].rgb), vec3(0), vec3(1)));
float alpha_output_3 = byteround(clamp((texcolor0.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_4 = byteround(clamp((texcolor0.rgb) * (const_color[4].rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_4 = byteround(clamp((1.0 - texcolor0.a) * (const_color[4].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
if (last_tex_env_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: AE5E9C4B40D9A166, 993677A7EEF1569D
// program: 3AE9AAE877A9E01A, B6B95AFD9466EC70, 993677A7EEF1569D
// shader: 8B30, 29ABCF6758FE232A
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * LookupLightingLUTUnsigned(16, clamp(light_src[0].dist_atten_scale * length(-light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(16, clamp(light_src[0].dist_atten_scale * length(-light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * LookupLightingLUTUnsigned(17, clamp(light_src[1].dist_atten_scale * length(-light_src[1].position) + light_src[1].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(17, clamp(light_src[1].dist_atten_scale * length(-light_src[1].position) + light_src[1].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[2].position + view);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * LookupLightingLUTUnsigned(18, clamp(light_src[2].dist_atten_scale * length(-light_src[2].position - view) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[2].specular_0) + (light_src[2].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(18, clamp(light_src[2].dist_atten_scale * length(-light_src[2].position - view) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[3].position + view);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * LookupLightingLUTUnsigned(19, clamp(light_src[3].dist_atten_scale * length(-light_src[3].position - view) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[3].specular_0) + (light_src[3].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(19, clamp(light_src[3].dist_atten_scale * length(-light_src[3].position - view) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((vec4(0).rgb) * (const_color[0].rgb), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((secondary_fragment_color.r) * (1.0 - const_color[0].a) + (secondary_fragment_color.b) * (1.0 - (1.0 - const_color[0].a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((vec4(0).rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1) - (last_tex_env_out.aaa)), vec3(0), vec3(1)));
float alpha_output_1 = (vec4(0).a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = byteround(clamp((secondary_fragment_color.ggg) * (last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_4 = (last_tex_env_out.rgb);
float alpha_output_4 = byteround(clamp((rounded_primary_color.a) * (const_color[4].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
if (last_tex_env_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 8E25827BC28731B4, 29ABCF6758FE232A
// program: 625982782CCD0D7B, F777123A8C3D5E20, 29ABCF6758FE232A
// shader: 8B30, 85D1E0630696A9D8
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))) + tex_lod_bias[2]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp(vec3(dot((texcolor0.rgb) - vec3(0.5), (texcolor1.rgb) - vec3(0.5)) * 4.0), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((texcolor0.a) + (1.0 - texcolor1.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
vec3 color_output_1 = byteround(clamp(vec3(dot((texcolor0.rgb) - vec3(0.5), (texcolor2.rgb) - vec3(0.5)) * 4.0), vec3(0), vec3(1)));
float alpha_output_1 = byteround(clamp(min((texcolor1.a) + (1.0 - texcolor0.a), 1.0) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (combiner_buffer.rgb) + (const_color[2].rgb), vec3(0), vec3(1)));
float alpha_output_2 = byteround(clamp(min((texcolor0.a) + (1.0 - texcolor2.a), 1.0) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_3 = byteround(clamp(min((texcolor2.a) + (1.0 - texcolor0.a), 1.0) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) * (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_4 = byteround(clamp((last_tex_env_out.a) - (const_color[4].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4 * 1.0, alpha_output_4 * 4.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (last_tex_env_out.aaa) + (const_color[5].rgb), vec3(0), vec3(1)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a) - (primary_fragment_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5 * 1.0, alpha_output_5 * 4.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: BF6C0DC937FDC8AD, 85D1E0630696A9D8
// program: 9C1CAD21F8AE5682, EADA2116091C5E01, 85D1E0630696A9D8
// shader: 8B30, E5AB7B68911F4494
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))) + tex_lod_bias[2]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((vec3(1) - texcolor0.rrr) - (vec3(1) - texcolor1.rrr), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((1.0 - texcolor0.r) - (1.0 - texcolor2.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0 * 4.0, alpha_output_0 * 4.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) + (last_tex_env_out.aaa), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1 * 4.0, alpha_output_1 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2 * 4.0, alpha_output_2 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = byteround(clamp(min((last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(1)) * (vec3(1) - texcolor0.rrr), vec3(0), vec3(1)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_4 = byteround(clamp((vec3(1) - last_tex_env_out.rgb) + (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_4 = byteround(clamp((1.0 - last_tex_env_out.r) + (const_color[4].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_5 = (rounded_primary_color.rgb);
float alpha_output_5 = (rounded_primary_color.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: E7D0A001722E7EA6, E5AB7B68911F4494
// program: 0000000000000000, 0000000000000000, E5AB7B68911F4494
// shader: 8B30, A4B0586DF10E0E4C
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * LookupLightingLUTUnsigned(16, clamp(light_src[0].dist_atten_scale * length(-light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(16, clamp(light_src[0].dist_atten_scale * length(-light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * LookupLightingLUTUnsigned(17, clamp(light_src[1].dist_atten_scale * length(-light_src[1].position) + light_src[1].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(17, clamp(light_src[1].dist_atten_scale * length(-light_src[1].position) + light_src[1].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[2].position + view);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * LookupLightingLUTUnsigned(18, clamp(light_src[2].dist_atten_scale * length(-light_src[2].position - view) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[2].specular_0) + (light_src[2].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(18, clamp(light_src[2].dist_atten_scale * length(-light_src[2].position - view) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[3].position + view);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * LookupLightingLUTUnsigned(19, clamp(light_src[3].dist_atten_scale * length(-light_src[3].position - view) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[3].specular_0) + (light_src[3].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(19, clamp(light_src[3].dist_atten_scale * length(-light_src[3].position - view) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tex_env_out.rgb;
combiner_buffer = next_combiner_buffer;
if (last_tex_env_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 6945BB7E67FC0A03, A4B0586DF10E0E4C
// program: 625982782CCD0D7B, F777123A8C3D5E20, A4B0586DF10E0E4C
// reference: 8E25827B61F5C7D6, 29ABCF6758FE232A
// shader: 8B30, 09756F4214CB3E9E
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * LookupLightingLUTUnsigned(16, clamp(light_src[0].dist_atten_scale * length(-light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(16, clamp(light_src[0].dist_atten_scale * length(-light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * LookupLightingLUTUnsigned(17, clamp(light_src[1].dist_atten_scale * length(-light_src[1].position) + light_src[1].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(17, clamp(light_src[1].dist_atten_scale * length(-light_src[1].position) + light_src[1].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[2].position + view);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * LookupLightingLUTUnsigned(18, clamp(light_src[2].dist_atten_scale * length(-light_src[2].position - view) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[2].specular_0) + (light_src[2].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(18, clamp(light_src[2].dist_atten_scale * length(-light_src[2].position - view) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[3].position + view);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * LookupLightingLUTUnsigned(19, clamp(light_src[3].dist_atten_scale * length(-light_src[3].position - view) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[3].specular_0) + (light_src[3].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(19, clamp(light_src[3].dist_atten_scale * length(-light_src[3].position - view) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = (primary_fragment_color.rgb);
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) + (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: CD21D69CDBCB78CC, 09756F4214CB3E9E
// program: 625982782CCD0D7B, F777123A8C3D5E20, 09756F4214CB3E9E
// shader: 8B30, 5A216962B0AC0396
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].aaa), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (const_color[1].aaa) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (const_color[1].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (const_color[2].rgb), vec3(0), vec3(1)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: C3408FC32F3E1ED2, 5A216962B0AC0396
// program: 625982782CCD0D7B, F777123A8C3D5E20, 5A216962B0AC0396
// shader: 8B30, 61971FB2D7BF35C1
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].aaa), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (const_color[0].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (const_color[1].aaa) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (const_color[1].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (const_color[2].rgb), vec3(0), vec3(1)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: A6657E36BF59E4DE, 61971FB2D7BF35C1
// program: 625982782CCD0D7B, F777123A8C3D5E20, 61971FB2D7BF35C1
// reference: 4D023EFDBD5B37F9, 5A216962B0AC0396
// reference: 6945BB7EC48EFC61, A4B0586DF10E0E4C
// reference: C3408FC38C4CE8B0, 5A216962B0AC0396
// shader: 8B31, E7DC3ED593602690

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)

#define min_s(x, y) min(x, y)
#define max_s(x, y) max(x, y)

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout(binding=2, std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location=0) in vec4 vs_in_reg0;
layout(location=1) in vec4 vs_in_reg1;
layout(location=3) in vec4 vs_in_reg3;
layout(location=4) in vec4 vs_in_reg4;
layout(location=5) in vec4 vs_in_reg5;
layout(location=6) in vec4 vs_in_reg6;
layout(location=7) in vec4 vs_in_reg7;
layout(location=8) in vec4 vs_in_reg8;

layout(location=0) out vec4 vs_out_attr0;
layout(location=1) out vec4 vs_out_attr1;
layout(location=2) out vec4 vs_out_attr2;
layout(location=3) out vec4 vs_out_attr3;
layout(location=4) out vec4 vs_out_attr4;
layout(location=5) out vec4 vs_out_attr5;

void main() {
vs_out_attr0 = vec4(0, 0, 0, 1);
vs_out_attr1 = vec4(0, 0, 0, 1);
vs_out_attr2 = vec4(0, 0, 0, 1);
vs_out_attr3 = vec4(0, 0, 0, 1);
vs_out_attr4 = vec4(0, 0, 0, 1);
vs_out_attr5 = vec4(0, 0, 0, 1);
exec_shader();
}
bvec2 bool_regs = bvec2(false);
ivec3 addr_regs = ivec3(0);
vec4 reg_tmp0 = vec4(0, 0, 0, 1);
vec4 reg_tmp1 = vec4(0, 0, 0, 1);
vec4 reg_tmp2 = vec4(0, 0, 0, 1);
vec4 reg_tmp3 = vec4(0, 0, 0, 1);
vec4 reg_tmp4 = vec4(0, 0, 0, 1);
vec4 reg_tmp5 = vec4(0, 0, 0, 1);
vec4 reg_tmp6 = vec4(0, 0, 0, 1);
vec4 reg_tmp7 = vec4(0, 0, 0, 1);
vec4 reg_tmp8 = vec4(0, 0, 0, 1);
vec4 reg_tmp9 = vec4(0, 0, 0, 1);
vec4 reg_tmp10 = vec4(0, 0, 0, 1);
vec4 reg_tmp11 = vec4(0, 0, 0, 1);
vec4 reg_tmp12 = vec4(0, 0, 0, 1);
vec4 reg_tmp13 = vec4(0, 0, 0, 1);
vec4 reg_tmp14 = vec4(0, 0, 0, 1);
vec4 reg_tmp15 = vec4(0, 0, 0, 1);

bool sub_11();
bool sub_4();
bool sub_8();
bool sub_1();
bool sub_2();
bool sub_3();
bool sub_5();
bool sub_6();
bool sub_7();
bool sub_9();
bool sub_10();
bool sub_12();
bool sub_13();
bool sub_14();
bool sub_15();
bool sub_16();
bool sub_17();
bool sub_18();
bool sub_19();
bool sub_20();
bool sub_21();
bool sub_22();
bool sub_23();
bool sub_24();
bool sub_36();
bool sub_25();
bool sub_26();
bool sub_27();
bool sub_28();
bool sub_29();
bool sub_30();
bool sub_31();
bool sub_32();
bool sub_33();
bool sub_34();
bool sub_35();
bool sub_51();
bool sub_39();
bool sub_40();
bool sub_41();
bool sub_42();
bool sub_43();
bool sub_50();
bool sub_0();
bool sub_37();
bool sub_38();
bool sub_44();
bool sub_45();
bool sub_46();
bool sub_47();
bool sub_49();
bool sub_48();

bool exec_shader() {
sub_0();
return true;
}

bool sub_11() {
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp3.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp3.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp3.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
return false;
}
bool sub_4() {
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp3.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp3.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp3.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp4.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
return false;
}
bool sub_8() {
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp3.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp3.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp3.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp4.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
return false;
}
bool sub_1() {
reg_tmp15.xyz = (mul_s(uniforms.f[7].xxxx, vs_in_reg0)).xyz;
reg_tmp14.xyz = (mul_s(uniforms.f[7].yyyy, vs_in_reg1)).xyz;
reg_tmp15.xyz = (uniforms.f[6] + reg_tmp15).xyz;
reg_tmp15.w = (uniforms.f[93].yyyy).w;
if (uniforms.b[1]) {
sub_2();
} else {
sub_14();
}
vs_out_attr1 = uniforms.f[93].xxxx;
vs_out_attr2 = uniforms.f[93].xxxx;
return false;
}
bool sub_2() {
reg_tmp0 = uniforms.f[7];
bool_regs = notEqual(uniforms.f[93].xx, reg_tmp0.yz);
reg_tmp7 = uniforms.f[93].xxxx;
reg_tmp12 = uniforms.f[93].xxxx;
reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_3();
} else {
sub_6();
}
reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
reg_tmp1.x = (-reg_tmp0.wwww).x;
reg_tmp1.y = (mul_s(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
bool_regs.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
bool_regs.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
if (all(bool_regs)) {
sub_13();
}
vs_out_attr0 = reg_tmp0;
return false;
}
bool sub_3() {
bool_regs = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
reg_tmp1.xy = (reg_tmp2.xxxx).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
sub_4();
reg_tmp1.xy = (reg_tmp2.yyyy).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
sub_4();
reg_tmp1.xy = (reg_tmp2.zzzz).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
if (bool_regs.x) {
sub_4();
}
if (uniforms.b[8]) {
sub_5();
}
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
return false;
}
bool sub_5() {
reg_tmp1.xy = (reg_tmp2.wwww).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
if (bool_regs.y) {
sub_4();
}
return false;
}
bool sub_6() {
if (all(bool_regs)) {
sub_7();
} else {
sub_10();
}
return false;
}
bool sub_7() {
bool_regs = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
reg_tmp1.xy = (reg_tmp2.xxxx).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
sub_8();
reg_tmp1.xy = (reg_tmp2.yyyy).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
sub_8();
reg_tmp1.xy = (reg_tmp2.zzzz).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
if (bool_regs.x) {
sub_8();
}
if (uniforms.b[8]) {
sub_9();
}
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
return false;
}
bool sub_9() {
reg_tmp1.xy = (reg_tmp2.wwww).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
if (bool_regs.y) {
sub_8();
}
return false;
}
bool sub_10() {
bool_regs = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
reg_tmp1.xy = (reg_tmp2.xxxx).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
sub_11();
reg_tmp1.xy = (reg_tmp2.yyyy).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
sub_11();
reg_tmp1.xy = (reg_tmp2.zzzz).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
if (bool_regs.x) {
sub_11();
}
if (uniforms.b[8]) {
sub_12();
}
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
return false;
}
bool sub_12() {
reg_tmp1.xy = (reg_tmp2.wwww).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
if (bool_regs.y) {
sub_11();
}
return false;
}
bool sub_13() {
reg_tmp0.x = (-reg_tmp0.wwww).x;
return false;
}
bool sub_14() {
reg_tmp0 = uniforms.f[7];
bool_regs = notEqual(uniforms.f[93].xx, reg_tmp0.yz);
if (uniforms.b[2]) {
sub_15();
} else {
sub_16();
}
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_17();
} else {
sub_18();
}
reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
reg_tmp1.x = (-reg_tmp0.wwww).x;
reg_tmp1.y = (mul_s(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
bool_regs.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
bool_regs.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
if (all(bool_regs)) {
sub_21();
}
vs_out_attr0 = reg_tmp0;
return false;
}
bool sub_15() {
reg_tmp1.x = (mul_s(uniforms.f[93].wwww, vs_in_reg7.xxxx)).x;
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp7.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp7.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp7.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
return false;
}
bool sub_16() {
addr_regs.x = (ivec2(uniforms.f[93].xx)).x;
reg_tmp10.x = dot_s(uniforms.f[25], reg_tmp15);
reg_tmp10.y = dot_s(uniforms.f[26], reg_tmp15);
reg_tmp10.z = dot_s(uniforms.f[27], reg_tmp15);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
return false;
}
bool sub_17() {
reg_tmp12.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
return false;
}
bool sub_18() {
if (all(bool_regs)) {
sub_19();
} else {
sub_20();
}
return false;
}
bool sub_19() {
reg_tmp12.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
return false;
}
bool sub_20() {
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
return false;
}
bool sub_21() {
reg_tmp0.x = (-reg_tmp0.wwww).x;
return false;
}
bool sub_22() {
reg_tmp8.xy = (uniforms.f[93].xxxx).xy;
reg_tmp0.y = (uniforms.f[7].wwww).y;
bool_regs = notEqual(uniforms.f[93].xx, reg_tmp0.xy);
reg_tmp9.xyz = (uniforms.f[93].xxxx).xyz;
reg_tmp9.w = (uniforms.f[21].wwww).w;
if (bool_regs.y) {
sub_23();
}
if (uniforms.b[12]) {
sub_25();
}
if (uniforms.b[5]) {
sub_34();
}
bool_regs = equal(uniforms.f[93].xx, reg_tmp8.xy);
if (all(bool_regs)) {
sub_36();
}
vs_out_attr3 = max_s(uniforms.f[93].xxxx, reg_tmp9);
return false;
}
bool sub_23() {
reg_tmp0 = mul_s(uniforms.f[7].wwww, vs_in_reg3);
if (uniforms.b[7]) {
sub_24();
}
reg_tmp9.xyz = (mul_s(uniforms.f[20].wwww, reg_tmp0.xyzz)).xyz;
reg_tmp8.x = (uniforms.f[93].yyyy).x;
return false;
}
bool sub_24() {
reg_tmp9.w = (mul_s(reg_tmp9.wwww, reg_tmp0.wwww)).w;
return false;
}
bool sub_36() {
reg_tmp9 = uniforms.f[21];
return false;
}
bool sub_25() {
reg_tmp1 = uniforms.f[20];
reg_tmp2 = uniforms.f[21];
reg_tmp3 = uniforms.f[93].xxxx;
addr_regs.z = int(uniforms.i[0].y);
for (uint i = 0u; i <= uniforms.i[0].x; addr_regs.z += int(uniforms.i[0].z), ++i) {
sub_26();
}
reg_tmp8.x = (uniforms.f[93].yyyy).x;
return false;
}
bool sub_26() {
addr_regs.x = (ivec2(reg_tmp3.xy)).x;
reg_tmp4.x = (uniforms.f[81 + addr_regs.x].wwww).x;
reg_tmp4.y = (uniforms.f[83 + addr_regs.x].wwww).y;
bool_regs = equal(uniforms.f[93].xy, reg_tmp4.xy);
if (bool_regs.x) {
sub_27();
} else {
sub_28();
}
bool_regs.x = uniforms.f[93].xxxx.x == reg_tmp6.xyyy.x;
bool_regs.y = uniforms.f[93].xxxx.y < reg_tmp6.xyyy.y;
if (bool_regs.y) {
sub_33();
}
reg_tmp3 = -uniforms.f[95].wwww + reg_tmp3;
return false;
}
bool sub_27() {
reg_tmp6.x = dot_3(uniforms.f[81 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp6.y = (uniforms.f[93].yyyy).y;
return false;
}
bool sub_28() {
reg_tmp4 = uniforms.f[81 + addr_regs.x] + -reg_tmp15;
reg_tmp6.y = (uniforms.f[93].yyyy).y;
if (bool_regs.y) {
sub_29();
}
reg_tmp5 = uniforms.f[82 + addr_regs.x];
bool_regs = equal(uniforms.f[93].yy, reg_tmp5.ww);
reg_tmp4.w = dot_3(reg_tmp4.xyz, reg_tmp4.xyz);
reg_tmp4.w = rsq_s(reg_tmp4.w);
reg_tmp4 = mul_s(reg_tmp4, reg_tmp4.wwww);
if (bool_regs.x) {
sub_30();
}
reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp4.xyz);
return false;
}
bool sub_29() {
reg_tmp5.x = (uniforms.f[93].yyyy).x;
reg_tmp5.z = dot_3(reg_tmp4.xyz, reg_tmp4.xyz);
reg_tmp5.y = (mul_s(reg_tmp5.zzzz, reg_tmp5.zzzz)).y;
reg_tmp6.y = dot_3(uniforms.f[83 + addr_regs.x].xyz, reg_tmp5.xyz);
reg_tmp6.y = rcp_s(reg_tmp6.y);
return false;
}
bool sub_30() {
reg_tmp5.x = dot_3(uniforms.f[82 + addr_regs.x].xyz, -reg_tmp4.xyz);
reg_tmp5.y = (vec4(lessThan(reg_tmp5.xxxx, uniforms.f[84 + addr_regs.x].yyyy))).y;
bool_regs = equal(uniforms.f[93].yy, reg_tmp5.xy);
if (bool_regs.y) {
sub_31();
} else {
sub_32();
}
reg_tmp6.y = (mul_s(reg_tmp6.yyyy, reg_tmp5.xxxx)).y;
return false;
}
bool sub_31() {
reg_tmp5.x = (uniforms.f[93].xxxx).x;
return false;
}
bool sub_32() {
reg_tmp5.y = log2(reg_tmp5.x);
reg_tmp5.y = (mul_s(uniforms.f[84 + addr_regs.x].xxxx, reg_tmp5.yyyy)).y;
reg_tmp5.x = exp2(reg_tmp5.y);
return false;
}
bool sub_33() {
reg_tmp6.x = (max_s(uniforms.f[93].xxxx, reg_tmp6.xxxx)).x;
reg_tmp9.xyz = (fma_s(reg_tmp1.xyzz, uniforms.f[79 + addr_regs.x].xyzz, reg_tmp9.xyzz)).xyz;
reg_tmp4 = mul_s(uniforms.f[80 + addr_regs.x], reg_tmp2);
reg_tmp5.xyz = (mul_s(reg_tmp6.xxxx, reg_tmp4.xyzz)).xyz;
reg_tmp5.xyz = (mul_s(reg_tmp6.yyyy, reg_tmp5.xyzz)).xyz;
reg_tmp9.xyz = (reg_tmp9.xyzz + reg_tmp5.xyzz).xyz;
reg_tmp9.w = (reg_tmp9.wwww + reg_tmp4.wwww).w;
return false;
}
bool sub_34() {
reg_tmp1 = vec4(dot_3(uniforms.f[24].xyz, reg_tmp14.xyz));
reg_tmp2 = uniforms.f[24].wwww;
reg_tmp1 = fma_s(reg_tmp1, reg_tmp2, reg_tmp2);
reg_tmp3 = uniforms.f[22];
reg_tmp2 = uniforms.f[23] + -reg_tmp3;
reg_tmp4 = fma_s(reg_tmp2, reg_tmp1, reg_tmp3);
if (uniforms.b[6]) {
sub_35();
}
reg_tmp9.xyz = (fma_s(reg_tmp4, uniforms.f[21], reg_tmp9)).xyz;
reg_tmp8.x = (uniforms.f[93].yyyy).x;
return false;
}
bool sub_35() {
reg_tmp4 = mul_s(reg_tmp4, reg_tmp9.wwww);
return false;
}
bool sub_51() {
reg_tmp5.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
reg_tmp5.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
reg_tmp5.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
reg_tmp4.x = dot_s(reg_tmp5.xyzz, reg_tmp5.xyzz);
reg_tmp4.x = rsq_s(reg_tmp4.x);
reg_tmp4.xyz = (mul_s(reg_tmp5.xyzz, reg_tmp4.xxxx)).xyz;
reg_tmp4 = mul_s(uniforms.f[94].zzzz, reg_tmp4);
reg_tmp12 = uniforms.f[94].zzzz + reg_tmp4;
vs_out_attr5 = reg_tmp12;
return false;
}
bool sub_39() {
bool_regs = equal(uniforms.f[93].yz, reg_tmp0.xy);
if (all(not(bool_regs))) {
sub_40();
} else {
sub_41();
}
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
return false;
}
bool sub_40() {
reg_tmp6.xy = (mul_s(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
return false;
}
bool sub_41() {
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_42();
} else {
sub_43();
}
return false;
}
bool sub_42() {
reg_tmp6.xy = (mul_s(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
return false;
}
bool sub_43() {
reg_tmp6.xy = (mul_s(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
return false;
}
bool sub_50() {
reg_tmp1.xy = (uniforms.f[94].zzzz).xy;
reg_tmp1.zw = (uniforms.f[93].xxxx).zw;
reg_tmp6 = fma_s(reg_tmp14, reg_tmp1, reg_tmp1);
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
return false;
}
bool sub_0() {
sub_1();
sub_22();
sub_37();
sub_51();
return true;
}
bool sub_37() {
reg_tmp0.xy = (uniforms.f[10].xxxx).xy;
if (uniforms.b[9]) {
sub_38();
} else {
sub_44();
}
return false;
}
bool sub_38() {
sub_39();
reg_tmp3.x = dot_s(uniforms.f[11].xywz, reg_tmp6);
reg_tmp3.y = dot_s(uniforms.f[12].xywz, reg_tmp6);
reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
vs_out_attr4 = reg_tmp3;
return false;
}
bool sub_44() {
bool_regs = equal(uniforms.f[95].xy, reg_tmp0.xy);
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
if (all(not(bool_regs))) {
sub_45();
} else {
sub_46();
}
vs_out_attr4 = reg_tmp3;
return false;
}
bool sub_45() {
reg_tmp6 = reg_tmp10;
reg_tmp3.x = dot_s(uniforms.f[11], reg_tmp6);
reg_tmp3.y = dot_s(uniforms.f[12], reg_tmp6);
reg_tmp3.z = dot_s(uniforms.f[13], reg_tmp6);
reg_tmp0.xy = (mul_s(uniforms.f[19].xyyy, reg_tmp3.zzzz)).xy;
reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
return false;
}
bool sub_46() {
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_47();
} else {
sub_49();
}
return false;
}
bool sub_47() {
sub_48();
reg_tmp3.x = dot_3(uniforms.f[11].xyz, reg_tmp6.xyz);
reg_tmp3.y = dot_3(uniforms.f[12].xyz, reg_tmp6.xyz);
reg_tmp3.z = dot_3(uniforms.f[13].xyz, reg_tmp6.xyz);
return false;
}
bool sub_49() {
sub_50();
reg_tmp3.x = dot_s(uniforms.f[11], reg_tmp6);
reg_tmp3.y = dot_s(uniforms.f[12], reg_tmp6);
return false;
}
bool sub_48() {
reg_tmp2 = -reg_tmp15;
reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
reg_tmp2.w = rsq_s(reg_tmp2.w);
reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
reg_tmp1 = reg_tmp1 + reg_tmp1;
reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
return false;
}
// reference: C801BC2B8FA4DB71, E7DC3ED593602690
// shader: 8B30, 7FF56148DAB844CE
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = (texcolor1.rgb);
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
if (last_tex_env_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 9D888D1284E929C4, 7FF56148DAB844CE
// program: E7DC3ED593602690, F777123A8C3D5E20, 7FF56148DAB844CE
// shader: 8B30, A5F32A6ABE370BE3
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
if (last_tex_env_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 9D888D12A1C55406, A5F32A6ABE370BE3
// program: E7DC3ED593602690, F777123A8C3D5E20, A5F32A6ABE370BE3
// shader: 8B31, F9DE065AA4FD5288

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)

#define min_s(x, y) min(x, y)
#define max_s(x, y) max(x, y)

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout(binding=2, std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location=0) in vec4 vs_in_reg0;
layout(location=1) in vec4 vs_in_reg1;
layout(location=2) in vec4 vs_in_reg2;
layout(location=3) in vec4 vs_in_reg3;
layout(location=4) in vec4 vs_in_reg4;
layout(location=5) in vec4 vs_in_reg5;
layout(location=6) in vec4 vs_in_reg6;
layout(location=7) in vec4 vs_in_reg7;
layout(location=8) in vec4 vs_in_reg8;

layout(location=0) out vec4 vs_out_attr0;
layout(location=1) out vec4 vs_out_attr1;
layout(location=2) out vec4 vs_out_attr2;
layout(location=3) out vec4 vs_out_attr3;
layout(location=4) out vec4 vs_out_attr4;
layout(location=5) out vec4 vs_out_attr5;
layout(location=6) out vec4 vs_out_attr6;

void main() {
vs_out_attr0 = vec4(0, 0, 0, 1);
vs_out_attr1 = vec4(0, 0, 0, 1);
vs_out_attr2 = vec4(0, 0, 0, 1);
vs_out_attr3 = vec4(0, 0, 0, 1);
vs_out_attr4 = vec4(0, 0, 0, 1);
vs_out_attr5 = vec4(0, 0, 0, 1);
vs_out_attr6 = vec4(0, 0, 0, 1);
exec_shader();
}
bvec2 bool_regs = bvec2(false);
ivec3 addr_regs = ivec3(0);
vec4 reg_tmp0 = vec4(0, 0, 0, 1);
vec4 reg_tmp1 = vec4(0, 0, 0, 1);
vec4 reg_tmp2 = vec4(0, 0, 0, 1);
vec4 reg_tmp3 = vec4(0, 0, 0, 1);
vec4 reg_tmp4 = vec4(0, 0, 0, 1);
vec4 reg_tmp5 = vec4(0, 0, 0, 1);
vec4 reg_tmp6 = vec4(0, 0, 0, 1);
vec4 reg_tmp7 = vec4(0, 0, 0, 1);
vec4 reg_tmp8 = vec4(0, 0, 0, 1);
vec4 reg_tmp9 = vec4(0, 0, 0, 1);
vec4 reg_tmp10 = vec4(0, 0, 0, 1);
vec4 reg_tmp11 = vec4(0, 0, 0, 1);
vec4 reg_tmp12 = vec4(0, 0, 0, 1);
vec4 reg_tmp13 = vec4(0, 0, 0, 1);
vec4 reg_tmp14 = vec4(0, 0, 0, 1);
vec4 reg_tmp15 = vec4(0, 0, 0, 1);

bool sub_0();
bool sub_21();
bool sub_4();
bool sub_9();
bool sub_1();
bool sub_2();
bool sub_3();
bool sub_5();
bool sub_7();
bool sub_8();
bool sub_10();
bool sub_20();
bool sub_22();
bool sub_23();
bool sub_24();
bool sub_25();
bool sub_26();
bool sub_27();
bool sub_28();
bool sub_29();
bool sub_30();
bool sub_31();
bool sub_6();
bool sub_11();
bool sub_12();
bool sub_13();
bool sub_14();
bool sub_15();
bool sub_16();
bool sub_17();
bool sub_18();
bool sub_19();
bool sub_32();
bool sub_33();
bool sub_34();
bool sub_40();
bool sub_41();
bool sub_42();
bool sub_43();
bool sub_45();
bool sub_35();
bool sub_36();
bool sub_37();
bool sub_38();
bool sub_39();
bool sub_44();
bool sub_46();
bool sub_47();
bool sub_48();
bool sub_49();
bool sub_50();
bool sub_51();
bool sub_52();
bool sub_53();
bool sub_54();
bool sub_55();
bool sub_56();
bool sub_57();
bool sub_58();

bool exec_shader() {
sub_0();
return true;
}

bool sub_0() {
sub_1();
sub_32();
sub_33();
sub_47();
sub_54();
return true;
}
bool sub_21() {
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp3.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp3.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp3.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
return false;
}
bool sub_4() {
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp3.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp3.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp3.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp4.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
return false;
}
bool sub_9() {
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp3.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp3.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp3.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp4.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp5.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp5.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp5.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
reg_tmp11 = fma_s(reg_tmp1.wwww, reg_tmp5, reg_tmp11);
return false;
}
bool sub_1() {
reg_tmp15.xyz = (mul_s(uniforms.f[7].xxxx, vs_in_reg0)).xyz;
reg_tmp14.xyz = (mul_s(uniforms.f[7].yyyy, vs_in_reg1)).xyz;
reg_tmp13.xyz = (mul_s(uniforms.f[7].zzzz, vs_in_reg2)).xyz;
reg_tmp15.xyz = (uniforms.f[6] + reg_tmp15).xyz;
reg_tmp15.w = (uniforms.f[93].yyyy).w;
if (uniforms.b[1]) {
sub_2();
} else {
sub_24();
}
return false;
}
bool sub_2() {
reg_tmp0 = uniforms.f[7];
bool_regs = notEqual(uniforms.f[93].xx, reg_tmp0.yz);
reg_tmp7 = uniforms.f[93].xxxx;
reg_tmp12 = uniforms.f[93].xxxx;
reg_tmp11 = uniforms.f[93].xxxx;
reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_3();
} else {
sub_7();
}
vs_out_attr2 = -reg_tmp15;
reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
reg_tmp1.x = (-reg_tmp0.wwww).x;
reg_tmp1.y = (mul_s(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
bool_regs.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
bool_regs.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
if (all(bool_regs)) {
sub_23();
}
vs_out_attr0 = reg_tmp0;
return false;
}
bool sub_3() {
bool_regs = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
reg_tmp1.xy = (reg_tmp2.xxxx).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
sub_4();
reg_tmp1.xy = (reg_tmp2.yyyy).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
sub_4();
reg_tmp1.xy = (reg_tmp2.zzzz).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
if (bool_regs.x) {
sub_4();
}
if (uniforms.b[8]) {
sub_5();
}
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
sub_6();
return false;
}
bool sub_5() {
reg_tmp1.xy = (reg_tmp2.wwww).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
if (bool_regs.y) {
sub_4();
}
return false;
}
bool sub_7() {
if (all(bool_regs)) {
sub_8();
} else {
sub_20();
}
return false;
}
bool sub_8() {
bool_regs = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
reg_tmp1.xy = (reg_tmp2.xxxx).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
sub_9();
reg_tmp1.xy = (reg_tmp2.yyyy).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
sub_9();
reg_tmp1.xy = (reg_tmp2.zzzz).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
if (bool_regs.x) {
sub_9();
}
if (uniforms.b[8]) {
sub_10();
}
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp13.x = dot_3(uniforms.f[3].xyz, reg_tmp11.xyz);
reg_tmp13.y = dot_3(uniforms.f[4].xyz, reg_tmp11.xyz);
reg_tmp13.z = dot_3(uniforms.f[5].xyz, reg_tmp11.xyz);
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
sub_11();
return false;
}
bool sub_10() {
reg_tmp1.xy = (reg_tmp2.wwww).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
if (bool_regs.y) {
sub_9();
}
return false;
}
bool sub_20() {
bool_regs = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
reg_tmp1.xy = (reg_tmp2.xxxx).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
sub_21();
reg_tmp1.xy = (reg_tmp2.yyyy).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
sub_21();
reg_tmp1.xy = (reg_tmp2.zzzz).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
if (bool_regs.x) {
sub_21();
}
if (uniforms.b[8]) {
sub_22();
}
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
vs_out_attr1 = uniforms.f[93].xxxx;
return false;
}
bool sub_22() {
reg_tmp1.xy = (reg_tmp2.wwww).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
if (bool_regs.y) {
sub_21();
}
return false;
}
bool sub_23() {
reg_tmp0.x = (-reg_tmp0.wwww).x;
return false;
}
bool sub_24() {
reg_tmp0 = uniforms.f[7];
bool_regs = notEqual(uniforms.f[93].xx, reg_tmp0.yz);
if (uniforms.b[2]) {
sub_25();
} else {
sub_26();
}
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_27();
} else {
sub_28();
}
vs_out_attr2 = -reg_tmp15;
reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
reg_tmp1.x = (-reg_tmp0.wwww).x;
reg_tmp1.y = (mul_s(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
bool_regs.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
bool_regs.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
if (all(bool_regs)) {
sub_31();
}
vs_out_attr0 = reg_tmp0;
return false;
}
bool sub_25() {
reg_tmp1.x = (mul_s(uniforms.f[93].wwww, vs_in_reg7.xxxx)).x;
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp7.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp7.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp7.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
return false;
}
bool sub_26() {
addr_regs.x = (ivec2(uniforms.f[93].xx)).x;
reg_tmp10.x = dot_s(uniforms.f[25], reg_tmp15);
reg_tmp10.y = dot_s(uniforms.f[26], reg_tmp15);
reg_tmp10.z = dot_s(uniforms.f[27], reg_tmp15);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
return false;
}
bool sub_27() {
reg_tmp12.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
sub_6();
return false;
}
bool sub_28() {
if (all(bool_regs)) {
sub_29();
} else {
sub_30();
}
return false;
}
bool sub_29() {
reg_tmp12.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp11.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp11.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp11.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
reg_tmp13.x = dot_3(uniforms.f[3].xyz, reg_tmp11.xyz);
reg_tmp13.y = dot_3(uniforms.f[4].xyz, reg_tmp11.xyz);
reg_tmp13.z = dot_3(uniforms.f[5].xyz, reg_tmp11.xyz);
sub_11();
return false;
}
bool sub_30() {
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
vs_out_attr1 = uniforms.f[93].xxxx;
return false;
}
bool sub_31() {
reg_tmp0.x = (-reg_tmp0.wwww).x;
return false;
}
bool sub_6() {
uint jmp_to = 214u;
while (true) {
switch (jmp_to) {
case 214u:
reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
reg_tmp6.x = rsq_s(reg_tmp6.x);
reg_tmp7.x = rsq_s(reg_tmp7.x);
reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp0 = uniforms.f[93].yxxx;
if (!uniforms.b[15]) {
jmp_to = 230u; break;
}
reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
reg_tmp4 = mul_s(uniforms.f[94].zzzz, reg_tmp4);
bool_regs = greaterThanEqual(uniforms.f[93].xx, reg_tmp4.xx);
reg_tmp4 = vec4(rsq_s(reg_tmp4.x));
reg_tmp5 = mul_s(uniforms.f[94].zzzz, reg_tmp14);
if (bool_regs.x) {
jmp_to = 230u; break;
}
reg_tmp0.z = rcp_s(reg_tmp4.x);
reg_tmp0.xy = (mul_s(reg_tmp5, reg_tmp4)).xy;
case 230u:
vs_out_attr1 = reg_tmp0;
default: return false;
}
}
return false;
}
bool sub_11() {
uint jmp_to = 231u;
while (true) {
switch (jmp_to) {
case 231u:
reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
reg_tmp6.x = rsq_s(reg_tmp6.x);
reg_tmp7.x = rsq_s(reg_tmp7.x);
reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp13.xyz = (mul_s(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp11.xyz = (mul_s(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp0 = uniforms.f[93].yxxx;
if (!uniforms.b[15]) {
jmp_to = 306u; break;
}
reg_tmp13.xyz = (mul_s(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp11.xyz = (mul_s(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp5 = mul_s(reg_tmp14.yzxx, reg_tmp13.zxyy);
reg_tmp5 = fma_s(-reg_tmp13.yzxx, reg_tmp14.zxyy, reg_tmp5);
reg_tmp5.w = dot_3(reg_tmp5.xyz, reg_tmp5.xyz);
reg_tmp5.w = rsq_s(reg_tmp5.w);
reg_tmp5 = mul_s(reg_tmp5, reg_tmp5.wwww);
reg_tmp6.w = (reg_tmp14.zzzz + reg_tmp5.yyyy).w;
reg_tmp13 = mul_s(reg_tmp5.yzxx, reg_tmp14.zxyy);
reg_tmp13 = fma_s(-reg_tmp14.yzxx, reg_tmp5.zxyy, reg_tmp13);
reg_tmp6.w = (reg_tmp13.xxxx + reg_tmp6).w;
reg_tmp13.w = (reg_tmp5.zzzz).w;
reg_tmp5.z = (reg_tmp13.xxxx).z;
reg_tmp6.w = (uniforms.f[93].yyyy + reg_tmp6).w;
reg_tmp14.w = (reg_tmp5.xxxx).w;
reg_tmp5.x = (reg_tmp14.zzzz).x;
bool_regs = lessThan(uniforms.f[94].yy, reg_tmp6.ww);
reg_tmp6.x = (uniforms.f[93].yyyy).x;
reg_tmp6.y = (-uniforms.f[93].yyyy).y;
if (!bool_regs.x) {
jmp_to = 268u; break;
}
reg_tmp7.xz = (reg_tmp13.wwyy + -reg_tmp14.yyww).xz;
reg_tmp7.y = (reg_tmp14.xxxx + -reg_tmp13.zzzz).y;
reg_tmp7.w = (reg_tmp6).w;
reg_tmp6 = vec4(dot_s(reg_tmp7, reg_tmp7));
reg_tmp6 = vec4(rsq_s(reg_tmp6.x));
reg_tmp0 = mul_s(reg_tmp7, reg_tmp6);
if (uniforms.b[0]) {
jmp_to = 306u; break;
}
case 268u:
bool_regs = greaterThan(reg_tmp5.zy, reg_tmp5.yx);
if (bool_regs.x) {
sub_12();
} else {
sub_17();
}
reg_tmp6 = vec4(dot_s(reg_tmp8, reg_tmp8));
reg_tmp6 = vec4(rsq_s(reg_tmp6.x));
reg_tmp0 = mul_s(reg_tmp8, reg_tmp6);
case 306u:
vs_out_attr1 = reg_tmp0;
default: return false;
}
}
return false;
}
bool sub_12() {
if (bool_regs.y) {
sub_13();
} else {
sub_14();
}
reg_tmp8.w = (-reg_tmp8).w;
return false;
}
bool sub_13() {
reg_tmp8 = mul_s(reg_tmp13.yyzw, reg_tmp6.xxxy);
reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
return false;
}
bool sub_14() {
bool_regs = greaterThan(reg_tmp5.zz, reg_tmp5.xx);
reg_tmp8 = mul_s(reg_tmp13.yyzw, reg_tmp6.xxxy);
reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
if (bool_regs.x) {
sub_15();
} else {
sub_16();
}
return false;
}
bool sub_15() {
reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
return false;
}
bool sub_16() {
reg_tmp8 = mul_s(reg_tmp13.zwwy, reg_tmp6.xxxy);
reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
return false;
}
bool sub_17() {
if (bool_regs.y) {
sub_18();
} else {
sub_19();
}
return false;
}
bool sub_18() {
reg_tmp8 = mul_s(reg_tmp13.yywz, reg_tmp6.xxxy);
reg_tmp8.y = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).y;
reg_tmp9 = reg_tmp5.yyyy + -reg_tmp5.xxxx;
reg_tmp8.xzw = (reg_tmp8 + reg_tmp14.wwyx).xzw;
reg_tmp8.y = (reg_tmp9 + reg_tmp8).y;
return false;
}
bool sub_19() {
reg_tmp8 = mul_s(reg_tmp13.zwwy, reg_tmp6.xxxy);
reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
reg_tmp8.w = (-reg_tmp8).w;
return false;
}
bool sub_32() {
reg_tmp1.xyz = (uniforms.f[93].xxyx).xyz;
reg_tmp8.x = dot_3(uniforms.f[0].xyz, reg_tmp12.xyz);
reg_tmp8.y = dot_3(uniforms.f[1].xyz, reg_tmp12.xyz);
reg_tmp8.z = dot_3(uniforms.f[2].xyz, reg_tmp12.xyz);
reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp8.xyz);
reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp8.xyz);
reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp8.xyz);
reg_tmp14.w = (uniforms.f[93].xxxx).w;
reg_tmp8 = reg_tmp14;
reg_tmp14.x = dot_s(reg_tmp8, reg_tmp8);
reg_tmp14.x = rsq_s(reg_tmp14.x);
reg_tmp14 = mul_s(reg_tmp8, reg_tmp14.xxxx);
reg_tmp9.x = dot_3(reg_tmp14.xyz, reg_tmp1.xyz);
reg_tmp9.x = (max_s(uniforms.f[93].xxxx, reg_tmp9.xxxx)).x;
reg_tmp9.x = (min_s(uniforms.f[93].yyyy, reg_tmp9.xxxx)).x;
reg_tmp9.x = (uniforms.f[93].yyyy + -reg_tmp9.xxxx).x;
reg_tmp9.x = log2(reg_tmp9.x);
reg_tmp9.x = (mul_s(uniforms.f[85].xxxx, reg_tmp9.xxxx)).x;
reg_tmp9.x = exp2(reg_tmp9.x);
reg_tmp2.w = (mul_s(uniforms.f[85].yyyy, reg_tmp9.xxxx)).w;
reg_tmp0 = mul_s(uniforms.f[7].wwww, vs_in_reg3);
reg_tmp2.xyz = (mul_s(uniforms.f[20].wwww, reg_tmp0.xyzz)).xyz;
vs_out_attr3 = reg_tmp2;
return false;
}
bool sub_33() {
reg_tmp0.xy = (uniforms.f[10].xxxx).xy;
if (uniforms.b[9]) {
sub_34();
} else {
sub_40();
}
return false;
}
bool sub_34() {
sub_35();
reg_tmp3.x = dot_s(uniforms.f[11].xywz, reg_tmp6);
reg_tmp3.y = dot_s(uniforms.f[12].xywz, reg_tmp6);
reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
vs_out_attr4 = reg_tmp3;
return false;
}
bool sub_40() {
bool_regs = equal(uniforms.f[95].xy, reg_tmp0.xy);
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
if (all(not(bool_regs))) {
sub_41();
} else {
sub_42();
}
vs_out_attr4 = reg_tmp3;
return false;
}
bool sub_41() {
reg_tmp6 = reg_tmp10;
reg_tmp3.x = dot_s(uniforms.f[11], reg_tmp6);
reg_tmp3.y = dot_s(uniforms.f[12], reg_tmp6);
reg_tmp3.z = dot_s(uniforms.f[13], reg_tmp6);
reg_tmp0.xy = (mul_s(uniforms.f[19].xyyy, reg_tmp3.zzzz)).xy;
reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
return false;
}
bool sub_42() {
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_43();
} else {
sub_45();
}
return false;
}
bool sub_43() {
sub_44();
reg_tmp3.x = dot_3(uniforms.f[11].xyz, reg_tmp6.xyz);
reg_tmp3.y = dot_3(uniforms.f[12].xyz, reg_tmp6.xyz);
reg_tmp3.z = dot_3(uniforms.f[13].xyz, reg_tmp6.xyz);
return false;
}
bool sub_45() {
sub_46();
reg_tmp3.x = dot_s(uniforms.f[11], reg_tmp6);
reg_tmp3.y = dot_s(uniforms.f[12], reg_tmp6);
return false;
}
bool sub_35() {
bool_regs = equal(uniforms.f[93].yz, reg_tmp0.xy);
if (all(not(bool_regs))) {
sub_36();
} else {
sub_37();
}
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
return false;
}
bool sub_36() {
reg_tmp6.xy = (mul_s(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
return false;
}
bool sub_37() {
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_38();
} else {
sub_39();
}
return false;
}
bool sub_38() {
reg_tmp6.xy = (mul_s(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
return false;
}
bool sub_39() {
reg_tmp6.xy = (mul_s(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
return false;
}
bool sub_44() {
reg_tmp2 = -reg_tmp15;
reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
reg_tmp2.w = rsq_s(reg_tmp2.w);
reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
reg_tmp1 = reg_tmp1 + reg_tmp1;
reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
return false;
}
bool sub_46() {
reg_tmp1.xy = (uniforms.f[94].zzzz).xy;
reg_tmp1.zw = (uniforms.f[93].xxxx).zw;
reg_tmp6 = fma_s(reg_tmp14, reg_tmp1, reg_tmp1);
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
return false;
}
bool sub_47() {
reg_tmp0.xy = (uniforms.f[10].yyyy).xy;
if (uniforms.b[10]) {
sub_48();
} else {
sub_49();
}
return false;
}
bool sub_48() {
sub_35();
reg_tmp4.x = dot_s(uniforms.f[14].xywz, reg_tmp6);
reg_tmp4.y = dot_s(uniforms.f[15].xywz, reg_tmp6);
vs_out_attr5 = reg_tmp4;
return false;
}
bool sub_49() {
if (uniforms.b[13]) {
sub_50();
} else {
sub_53();
}
return false;
}
bool sub_50() {
bool_regs = equal(uniforms.f[95].xy, reg_tmp0.xy);
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
if (all(not(bool_regs))) {
sub_51();
} else {
sub_52();
}
vs_out_attr5 = reg_tmp4;
return false;
}
bool sub_51() {
reg_tmp6 = reg_tmp10;
reg_tmp4.x = dot_s(uniforms.f[14], reg_tmp6);
reg_tmp4.y = dot_s(uniforms.f[15], reg_tmp6);
reg_tmp4.z = dot_s(uniforms.f[16], reg_tmp6);
reg_tmp6.w = rcp_s(reg_tmp4.z);
reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
reg_tmp4.xy = (uniforms.f[19].zwww + reg_tmp4.xyyy).xy;
return false;
}
bool sub_52() {
sub_46();
reg_tmp4.x = dot_s(uniforms.f[14], reg_tmp6);
reg_tmp4.y = dot_s(uniforms.f[15], reg_tmp6);
return false;
}
bool sub_53() {
vs_out_attr5 = uniforms.f[93].xxxx;
return false;
}
bool sub_54() {
reg_tmp0.xy = (uniforms.f[10].zzzz).xy;
if (uniforms.b[11]) {
sub_55();
} else {
sub_56();
}
return false;
}
bool sub_55() {
sub_35();
reg_tmp5.x = dot_s(uniforms.f[17].xywz, reg_tmp6);
reg_tmp5.y = dot_s(uniforms.f[18].xywz, reg_tmp6);
vs_out_attr6 = reg_tmp5;
return false;
}
bool sub_56() {
if (uniforms.b[14]) {
sub_57();
} else {
sub_58();
}
return false;
}
bool sub_57() {
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
reg_tmp5.zw = (reg_tmp6.zwww).zw;
sub_46();
reg_tmp5.x = dot_s(uniforms.f[17], reg_tmp6);
reg_tmp5.y = dot_s(uniforms.f[18], reg_tmp6);
vs_out_attr6 = reg_tmp5;
return false;
}
bool sub_58() {
vs_out_attr6 = uniforms.f[93].xxxx;
return false;
}
// reference: C66C2950A668CF17, F9DE065AA4FD5288
// shader: 8B30, 2B7E429A428B86E4
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(light_vector, normal)));
refl_value.g = (lut_scale_rg * LookupLightingLUTSigned(5, dot(light_vector, normal)));
refl_value.b = (lut_scale_rb * LookupLightingLUTSigned(4, dot(light_vector, normal)));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((secondary_fragment_color.r) * (1.0 - const_color[0].a) + (secondary_fragment_color.b) * (1.0 - (1.0 - const_color[0].a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1) - (last_tex_env_out.aaa)), vec3(0), vec3(1)));
float alpha_output_1 = (texcolor0.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = byteround(clamp((secondary_fragment_color.ggg) * (last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) + (texcolor1.rgb), vec3(0), vec3(1)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb), vec3(0), vec3(1)));
float alpha_output_5 = byteround(clamp((last_tex_env_out.a) * (const_color[5].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
if (last_tex_env_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 5054AEBD1F881058, 2B7E429A428B86E4
// program: F9DE065AA4FD5288, EADA2116091C5E01, 2B7E429A428B86E4
// shader: 8B30, B5CB7AC2AE3AD291
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * LookupLightingLUTUnsigned(16, clamp(light_src[0].dist_atten_scale * length(-light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(16, clamp(light_src[0].dist_atten_scale * length(-light_src[0].position) + light_src[0].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * LookupLightingLUTUnsigned(17, clamp(light_src[1].dist_atten_scale * length(-light_src[1].position) + light_src[1].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(17, clamp(light_src[1].dist_atten_scale * length(-light_src[1].position) + light_src[1].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[2].position + view);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * LookupLightingLUTUnsigned(18, clamp(light_src[2].dist_atten_scale * length(-light_src[2].position - view) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[2].specular_0) + (light_src[2].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(18, clamp(light_src[2].dist_atten_scale * length(-light_src[2].position - view) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[3].position + view);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * LookupLightingLUTUnsigned(19, clamp(light_src[3].dist_atten_scale * length(-light_src[3].position - view) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[3].specular_0) + (light_src[3].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(19, clamp(light_src[3].dist_atten_scale * length(-light_src[3].position - view) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((secondary_fragment_color.r) * (1.0 - const_color[0].a) + (secondary_fragment_color.b) * (1.0 - (1.0 - const_color[0].a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1) - (last_tex_env_out.aaa)), vec3(0), vec3(1)));
float alpha_output_1 = (texcolor0.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = byteround(clamp((secondary_fragment_color.ggg) * (last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_4 = (last_tex_env_out.rgb);
float alpha_output_4 = byteround(clamp((rounded_primary_color.a) * (const_color[4].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_5 = (last_tex_env_out.rgb);
float alpha_output_5 = byteround(clamp((last_tex_env_out.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
if (last_tex_env_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 7437756DCFE71A40, B5CB7AC2AE3AD291
// program: 625982782CCD0D7B, F777123A8C3D5E20, B5CB7AC2AE3AD291
// reference: 5054AEBDBCFAE63A, 2B7E429A428B86E4
// reference: 7437756D6C95EC22, B5CB7AC2AE3AD291
// shader: 8B31, 85A5116CCB32BF2A

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)

#define min_s(x, y) min(x, y)
#define max_s(x, y) max(x, y)

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout(binding=2, std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location=0) in vec4 vs_in_reg0;
layout(location=1) in vec4 vs_in_reg1;
layout(location=3) in vec4 vs_in_reg3;
layout(location=4) in vec4 vs_in_reg4;
layout(location=5) in vec4 vs_in_reg5;
layout(location=6) in vec4 vs_in_reg6;
layout(location=7) in vec4 vs_in_reg7;
layout(location=8) in vec4 vs_in_reg8;

layout(location=0) out vec4 vs_out_attr0;
layout(location=1) out vec4 vs_out_attr1;
layout(location=2) out vec4 vs_out_attr2;
layout(location=3) out vec4 vs_out_attr3;
layout(location=4) out vec4 vs_out_attr4;
layout(location=5) out vec4 vs_out_attr5;

void main() {
vs_out_attr0 = vec4(0, 0, 0, 1);
vs_out_attr1 = vec4(0, 0, 0, 1);
vs_out_attr2 = vec4(0, 0, 0, 1);
vs_out_attr3 = vec4(0, 0, 0, 1);
vs_out_attr4 = vec4(0, 0, 0, 1);
vs_out_attr5 = vec4(0, 0, 0, 1);
exec_shader();
}
bvec2 bool_regs = bvec2(false);
ivec3 addr_regs = ivec3(0);
vec4 reg_tmp0 = vec4(0, 0, 0, 1);
vec4 reg_tmp1 = vec4(0, 0, 0, 1);
vec4 reg_tmp2 = vec4(0, 0, 0, 1);
vec4 reg_tmp3 = vec4(0, 0, 0, 1);
vec4 reg_tmp4 = vec4(0, 0, 0, 1);
vec4 reg_tmp5 = vec4(0, 0, 0, 1);
vec4 reg_tmp6 = vec4(0, 0, 0, 1);
vec4 reg_tmp7 = vec4(0, 0, 0, 1);
vec4 reg_tmp8 = vec4(0, 0, 0, 1);
vec4 reg_tmp9 = vec4(0, 0, 0, 1);
vec4 reg_tmp10 = vec4(0, 0, 0, 1);
vec4 reg_tmp11 = vec4(0, 0, 0, 1);
vec4 reg_tmp12 = vec4(0, 0, 0, 1);
vec4 reg_tmp13 = vec4(0, 0, 0, 1);
vec4 reg_tmp14 = vec4(0, 0, 0, 1);
vec4 reg_tmp15 = vec4(0, 0, 0, 1);

bool sub_0();
bool sub_11();
bool sub_4();
bool sub_8();
bool sub_1();
bool sub_2();
bool sub_3();
bool sub_5();
bool sub_6();
bool sub_7();
bool sub_9();
bool sub_10();
bool sub_12();
bool sub_13();
bool sub_14();
bool sub_15();
bool sub_16();
bool sub_17();
bool sub_18();
bool sub_19();
bool sub_20();
bool sub_21();
bool sub_22();
bool sub_23();
bool sub_24();
bool sub_36();
bool sub_25();
bool sub_26();
bool sub_27();
bool sub_28();
bool sub_29();
bool sub_30();
bool sub_31();
bool sub_32();
bool sub_33();
bool sub_34();
bool sub_35();
bool sub_37();
bool sub_38();
bool sub_39();
bool sub_45();
bool sub_46();
bool sub_47();
bool sub_48();
bool sub_50();
bool sub_40();
bool sub_41();
bool sub_42();
bool sub_43();
bool sub_44();
bool sub_49();

bool exec_shader() {
sub_0();
return true;
}

bool sub_0() {
sub_1();
sub_22();
sub_37();
sub_38();
return true;
}
bool sub_11() {
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp3.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp3.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp3.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
return false;
}
bool sub_4() {
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp3.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp3.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp3.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp4.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
return false;
}
bool sub_8() {
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp3.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp3.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp3.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp4.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
return false;
}
bool sub_1() {
reg_tmp15.xyz = (mul_s(uniforms.f[7].xxxx, vs_in_reg0)).xyz;
reg_tmp14.xyz = (mul_s(uniforms.f[7].yyyy, vs_in_reg1)).xyz;
reg_tmp15.xyz = (uniforms.f[6] + reg_tmp15).xyz;
reg_tmp15.w = (uniforms.f[93].yyyy).w;
if (uniforms.b[1]) {
sub_2();
} else {
sub_14();
}
vs_out_attr1 = uniforms.f[93].xxxx;
vs_out_attr2 = uniforms.f[93].xxxx;
return false;
}
bool sub_2() {
reg_tmp0 = uniforms.f[7];
bool_regs = notEqual(uniforms.f[93].xx, reg_tmp0.yz);
reg_tmp7 = uniforms.f[93].xxxx;
reg_tmp12 = uniforms.f[93].xxxx;
reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_3();
} else {
sub_6();
}
reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
reg_tmp1.x = (-reg_tmp0.wwww).x;
reg_tmp1.y = (mul_s(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
bool_regs.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
bool_regs.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
if (all(bool_regs)) {
sub_13();
}
vs_out_attr0 = reg_tmp0;
return false;
}
bool sub_3() {
bool_regs = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
reg_tmp1.xy = (reg_tmp2.xxxx).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
sub_4();
reg_tmp1.xy = (reg_tmp2.yyyy).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
sub_4();
reg_tmp1.xy = (reg_tmp2.zzzz).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
if (bool_regs.x) {
sub_4();
}
if (uniforms.b[8]) {
sub_5();
}
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
return false;
}
bool sub_5() {
reg_tmp1.xy = (reg_tmp2.wwww).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
if (bool_regs.y) {
sub_4();
}
return false;
}
bool sub_6() {
if (all(bool_regs)) {
sub_7();
} else {
sub_10();
}
return false;
}
bool sub_7() {
bool_regs = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
reg_tmp1.xy = (reg_tmp2.xxxx).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
sub_8();
reg_tmp1.xy = (reg_tmp2.yyyy).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
sub_8();
reg_tmp1.xy = (reg_tmp2.zzzz).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
if (bool_regs.x) {
sub_8();
}
if (uniforms.b[8]) {
sub_9();
}
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
return false;
}
bool sub_9() {
reg_tmp1.xy = (reg_tmp2.wwww).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
if (bool_regs.y) {
sub_8();
}
return false;
}
bool sub_10() {
bool_regs = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
reg_tmp1.xy = (reg_tmp2.xxxx).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
sub_11();
reg_tmp1.xy = (reg_tmp2.yyyy).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
sub_11();
reg_tmp1.xy = (reg_tmp2.zzzz).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
if (bool_regs.x) {
sub_11();
}
if (uniforms.b[8]) {
sub_12();
}
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
return false;
}
bool sub_12() {
reg_tmp1.xy = (reg_tmp2.wwww).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
if (bool_regs.y) {
sub_11();
}
return false;
}
bool sub_13() {
reg_tmp0.x = (-reg_tmp0.wwww).x;
return false;
}
bool sub_14() {
reg_tmp0 = uniforms.f[7];
bool_regs = notEqual(uniforms.f[93].xx, reg_tmp0.yz);
if (uniforms.b[2]) {
sub_15();
} else {
sub_16();
}
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_17();
} else {
sub_18();
}
reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
reg_tmp1.x = (-reg_tmp0.wwww).x;
reg_tmp1.y = (mul_s(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
bool_regs.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
bool_regs.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
if (all(bool_regs)) {
sub_21();
}
vs_out_attr0 = reg_tmp0;
return false;
}
bool sub_15() {
reg_tmp1.x = (mul_s(uniforms.f[93].wwww, vs_in_reg7.xxxx)).x;
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp7.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp7.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp7.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
return false;
}
bool sub_16() {
addr_regs.x = (ivec2(uniforms.f[93].xx)).x;
reg_tmp10.x = dot_s(uniforms.f[25], reg_tmp15);
reg_tmp10.y = dot_s(uniforms.f[26], reg_tmp15);
reg_tmp10.z = dot_s(uniforms.f[27], reg_tmp15);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
return false;
}
bool sub_17() {
reg_tmp12.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
return false;
}
bool sub_18() {
if (all(bool_regs)) {
sub_19();
} else {
sub_20();
}
return false;
}
bool sub_19() {
reg_tmp12.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
return false;
}
bool sub_20() {
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
return false;
}
bool sub_21() {
reg_tmp0.x = (-reg_tmp0.wwww).x;
return false;
}
bool sub_22() {
reg_tmp8.xy = (uniforms.f[93].xxxx).xy;
reg_tmp0.y = (uniforms.f[7].wwww).y;
bool_regs = notEqual(uniforms.f[93].xx, reg_tmp0.xy);
reg_tmp9.xyz = (uniforms.f[93].xxxx).xyz;
reg_tmp9.w = (uniforms.f[21].wwww).w;
if (bool_regs.y) {
sub_23();
}
if (uniforms.b[12]) {
sub_25();
}
if (uniforms.b[5]) {
sub_34();
}
bool_regs = equal(uniforms.f[93].xx, reg_tmp8.xy);
if (all(bool_regs)) {
sub_36();
}
vs_out_attr3 = max_s(uniforms.f[93].xxxx, reg_tmp9);
return false;
}
bool sub_23() {
reg_tmp0 = mul_s(uniforms.f[7].wwww, vs_in_reg3);
if (uniforms.b[7]) {
sub_24();
}
reg_tmp9.xyz = (mul_s(uniforms.f[20].wwww, reg_tmp0.xyzz)).xyz;
reg_tmp8.x = (uniforms.f[93].yyyy).x;
return false;
}
bool sub_24() {
reg_tmp9.w = (mul_s(reg_tmp9.wwww, reg_tmp0.wwww)).w;
return false;
}
bool sub_36() {
reg_tmp9 = uniforms.f[21];
return false;
}
bool sub_25() {
reg_tmp1 = uniforms.f[20];
reg_tmp2 = uniforms.f[21];
reg_tmp3 = uniforms.f[93].xxxx;
addr_regs.z = int(uniforms.i[0].y);
for (uint i = 0u; i <= uniforms.i[0].x; addr_regs.z += int(uniforms.i[0].z), ++i) {
sub_26();
}
reg_tmp8.x = (uniforms.f[93].yyyy).x;
return false;
}
bool sub_26() {
addr_regs.x = (ivec2(reg_tmp3.xy)).x;
reg_tmp4.x = (uniforms.f[81 + addr_regs.x].wwww).x;
reg_tmp4.y = (uniforms.f[83 + addr_regs.x].wwww).y;
bool_regs = equal(uniforms.f[93].xy, reg_tmp4.xy);
if (bool_regs.x) {
sub_27();
} else {
sub_28();
}
bool_regs.x = uniforms.f[93].xxxx.x == reg_tmp6.xyyy.x;
bool_regs.y = uniforms.f[93].xxxx.y < reg_tmp6.xyyy.y;
if (bool_regs.y) {
sub_33();
}
reg_tmp3 = -uniforms.f[95].wwww + reg_tmp3;
return false;
}
bool sub_27() {
reg_tmp6.x = dot_3(uniforms.f[81 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp6.y = (uniforms.f[93].yyyy).y;
return false;
}
bool sub_28() {
reg_tmp4 = uniforms.f[81 + addr_regs.x] + -reg_tmp15;
reg_tmp6.y = (uniforms.f[93].yyyy).y;
if (bool_regs.y) {
sub_29();
}
reg_tmp5 = uniforms.f[82 + addr_regs.x];
bool_regs = equal(uniforms.f[93].yy, reg_tmp5.ww);
reg_tmp4.w = dot_3(reg_tmp4.xyz, reg_tmp4.xyz);
reg_tmp4.w = rsq_s(reg_tmp4.w);
reg_tmp4 = mul_s(reg_tmp4, reg_tmp4.wwww);
if (bool_regs.x) {
sub_30();
}
reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp4.xyz);
return false;
}
bool sub_29() {
reg_tmp5.x = (uniforms.f[93].yyyy).x;
reg_tmp5.z = dot_3(reg_tmp4.xyz, reg_tmp4.xyz);
reg_tmp5.y = (mul_s(reg_tmp5.zzzz, reg_tmp5.zzzz)).y;
reg_tmp6.y = dot_3(uniforms.f[83 + addr_regs.x].xyz, reg_tmp5.xyz);
reg_tmp6.y = rcp_s(reg_tmp6.y);
return false;
}
bool sub_30() {
reg_tmp5.x = dot_3(uniforms.f[82 + addr_regs.x].xyz, -reg_tmp4.xyz);
reg_tmp5.y = (vec4(lessThan(reg_tmp5.xxxx, uniforms.f[84 + addr_regs.x].yyyy))).y;
bool_regs = equal(uniforms.f[93].yy, reg_tmp5.xy);
if (bool_regs.y) {
sub_31();
} else {
sub_32();
}
reg_tmp6.y = (mul_s(reg_tmp6.yyyy, reg_tmp5.xxxx)).y;
return false;
}
bool sub_31() {
reg_tmp5.x = (uniforms.f[93].xxxx).x;
return false;
}
bool sub_32() {
reg_tmp5.y = log2(reg_tmp5.x);
reg_tmp5.y = (mul_s(uniforms.f[84 + addr_regs.x].xxxx, reg_tmp5.yyyy)).y;
reg_tmp5.x = exp2(reg_tmp5.y);
return false;
}
bool sub_33() {
reg_tmp6.x = (max_s(uniforms.f[93].xxxx, reg_tmp6.xxxx)).x;
reg_tmp9.xyz = (fma_s(reg_tmp1.xyzz, uniforms.f[79 + addr_regs.x].xyzz, reg_tmp9.xyzz)).xyz;
reg_tmp4 = mul_s(uniforms.f[80 + addr_regs.x], reg_tmp2);
reg_tmp5.xyz = (mul_s(reg_tmp6.xxxx, reg_tmp4.xyzz)).xyz;
reg_tmp5.xyz = (mul_s(reg_tmp6.yyyy, reg_tmp5.xyzz)).xyz;
reg_tmp9.xyz = (reg_tmp9.xyzz + reg_tmp5.xyzz).xyz;
reg_tmp9.w = (reg_tmp9.wwww + reg_tmp4.wwww).w;
return false;
}
bool sub_34() {
reg_tmp1 = vec4(dot_3(uniforms.f[24].xyz, reg_tmp14.xyz));
reg_tmp2 = uniforms.f[24].wwww;
reg_tmp1 = fma_s(reg_tmp1, reg_tmp2, reg_tmp2);
reg_tmp3 = uniforms.f[22];
reg_tmp2 = uniforms.f[23] + -reg_tmp3;
reg_tmp4 = fma_s(reg_tmp2, reg_tmp1, reg_tmp3);
if (uniforms.b[6]) {
sub_35();
}
reg_tmp9.xyz = (fma_s(reg_tmp4, uniforms.f[21], reg_tmp9)).xyz;
reg_tmp8.x = (uniforms.f[93].yyyy).x;
return false;
}
bool sub_35() {
reg_tmp4 = mul_s(reg_tmp4, reg_tmp9.wwww);
return false;
}
bool sub_37() {
reg_tmp5.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
reg_tmp5.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
reg_tmp5.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
reg_tmp4.x = dot_s(reg_tmp5.xyzz, reg_tmp5.xyzz);
reg_tmp4.x = rsq_s(reg_tmp4.x);
reg_tmp4.xyz = (mul_s(reg_tmp5.xyzz, reg_tmp4.xxxx)).xyz;
reg_tmp4 = mul_s(uniforms.f[94].zzzz, reg_tmp4);
reg_tmp12 = uniforms.f[94].zzzz + reg_tmp4;
vs_out_attr4 = reg_tmp12;
return false;
}
bool sub_38() {
reg_tmp0.xy = (uniforms.f[10].yyyy).xy;
if (uniforms.b[10]) {
sub_39();
} else {
sub_45();
}
return false;
}
bool sub_39() {
sub_40();
reg_tmp4.x = dot_s(uniforms.f[14].xywz, reg_tmp6);
reg_tmp4.y = dot_s(uniforms.f[15].xywz, reg_tmp6);
vs_out_attr5 = reg_tmp4;
return false;
}
bool sub_45() {
if (uniforms.b[13]) {
sub_46();
} else {
sub_50();
}
return false;
}
bool sub_46() {
bool_regs = equal(uniforms.f[95].xy, reg_tmp0.xy);
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
if (all(not(bool_regs))) {
sub_47();
} else {
sub_48();
}
vs_out_attr5 = reg_tmp4;
return false;
}
bool sub_47() {
reg_tmp6 = reg_tmp10;
reg_tmp4.x = dot_s(uniforms.f[14], reg_tmp6);
reg_tmp4.y = dot_s(uniforms.f[15], reg_tmp6);
reg_tmp4.z = dot_s(uniforms.f[16], reg_tmp6);
reg_tmp6.w = rcp_s(reg_tmp4.z);
reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
reg_tmp4.xy = (uniforms.f[19].zwww + reg_tmp4.xyyy).xy;
return false;
}
bool sub_48() {
sub_49();
reg_tmp4.x = dot_s(uniforms.f[14], reg_tmp6);
reg_tmp4.y = dot_s(uniforms.f[15], reg_tmp6);
return false;
}
bool sub_50() {
vs_out_attr5 = uniforms.f[93].xxxx;
return false;
}
bool sub_40() {
bool_regs = equal(uniforms.f[93].yz, reg_tmp0.xy);
if (all(not(bool_regs))) {
sub_41();
} else {
sub_42();
}
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
return false;
}
bool sub_41() {
reg_tmp6.xy = (mul_s(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
return false;
}
bool sub_42() {
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_43();
} else {
sub_44();
}
return false;
}
bool sub_43() {
reg_tmp6.xy = (mul_s(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
return false;
}
bool sub_44() {
reg_tmp6.xy = (mul_s(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
return false;
}
bool sub_49() {
reg_tmp1.xy = (uniforms.f[94].zzzz).xy;
reg_tmp1.zw = (uniforms.f[93].xxxx).zw;
reg_tmp6 = fma_s(reg_tmp14, reg_tmp1, reg_tmp1);
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
return false;
}
// reference: C801BC2BA1E583C5, 85A5116CCB32BF2A
// shader: 8B30, 47CB4E54EF5379E5
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (rounded_primary_color.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
if (last_tex_env_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: F33C1B80C9B2834D, 47CB4E54EF5379E5
// program: 85A5116CCB32BF2A, F777123A8C3D5E20, 47CB4E54EF5379E5
// shader: 8B30, 10BF65E8D1BE0D7D
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))) + tex_lod_bias[2]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((vec3(1) - texcolor0.rrr) - (vec3(1) - texcolor1.rrr), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((1.0 - texcolor0.r) - (1.0 - texcolor2.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0 * 4.0, alpha_output_0 * 4.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) + (last_tex_env_out.aaa), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1 * 4.0, alpha_output_1 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2 * 4.0, alpha_output_2 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = byteround(clamp((const_color[3].rgb) * (vec3(1) - texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_3 = byteround(clamp((const_color[3].a) * (1.0 - texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (texcolor0.rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (texcolor0.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
if (last_tex_env_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 9464B5347B9036C4, 10BF65E8D1BE0D7D
// program: 3AE9AAE877A9E01A, B6B95AFD9466EC70, 10BF65E8D1BE0D7D
// shader: 8B30, 2E8DDCC14806C441
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))) + tex_lod_bias[2]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((vec3(1) - texcolor0.rrr) - (vec3(1) - texcolor1.rrr), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((1.0 - texcolor0.r) - (1.0 - texcolor2.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0 * 4.0, alpha_output_0 * 4.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) + (last_tex_env_out.aaa), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1 * 4.0, alpha_output_1 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2 * 4.0, alpha_output_2 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = byteround(clamp((const_color[3].rgb) * (vec3(1) - texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_3 = byteround(clamp((const_color[3].a) * (1.0 - texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (texcolor0.rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (texcolor0.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_5 = (rounded_primary_color.rgb);
float alpha_output_5 = (rounded_primary_color.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 66A48F796F2BBD4A, 2E8DDCC14806C441
// program: 0000000000000000, 0000000000000000, 2E8DDCC14806C441
// shader: 8B30, 0AB8BDAA1E48628C
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += ((light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[2].position + view);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * LookupLightingLUTUnsigned(18, clamp(light_src[2].dist_atten_scale * length(-light_src[2].position - view) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[2].specular_0) + (light_src[2].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(18, clamp(light_src[2].dist_atten_scale * length(-light_src[2].position - view) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[3].position + view);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * LookupLightingLUTUnsigned(19, clamp(light_src[3].dist_atten_scale * length(-light_src[3].position - view) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[3].specular_0) + (light_src[3].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(19, clamp(light_src[3].dist_atten_scale * length(-light_src[3].position - view) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = (primary_fragment_color.rgb);
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) + (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 30E61E003FAA7855, 0AB8BDAA1E48628C
// program: 625982782CCD0D7B, F777123A8C3D5E20, 0AB8BDAA1E48628C
// shader: 8B30, 150702E3F406903E
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tex_env_out.rgb;
combiner_buffer = next_combiner_buffer;
if (last_tex_env_out.a <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 8D655B5F83556B48, 150702E3F406903E
// program: 625982782CCD0D7B, F777123A8C3D5E20, 150702E3F406903E
// shader: 8B30, EC963DCE3A5CC151
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += ((light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[2].position + view);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * LookupLightingLUTUnsigned(18, clamp(light_src[2].dist_atten_scale * length(-light_src[2].position - view) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[2].specular_0) + (light_src[2].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(18, clamp(light_src[2].dist_atten_scale * length(-light_src[2].position - view) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[3].position + view);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * LookupLightingLUTUnsigned(19, clamp(light_src[3].dist_atten_scale * length(-light_src[3].position - view) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[3].specular_0) + (light_src[3].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(19, clamp(light_src[3].dist_atten_scale * length(-light_src[3].position - view) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor1.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = (texcolor1.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tex_env_out.rgb;
vec3 color_output_4 = byteround(clamp((vec3(1) - textureProj(tex0, vec3(texcoord0, texcoord0_w)).rgb) * (const_color[4].rgb), vec3(0), vec3(1)));
float alpha_output_4 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_5 = byteround(clamp((combiner_buffer.rgb) * (vec3(1) - last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
if (last_tex_env_out.a <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: AD5900534DA74CED, EC963DCE3A5CC151
// program: 625982782CCD0D7B, F777123A8C3D5E20, EC963DCE3A5CC151
// shader: 8B30, 1FF646FF8F39536E
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tex_env_out.rgb;
combiner_buffer = next_combiner_buffer;
if (last_tex_env_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: FA26314F23E92077, 1FF646FF8F39536E
// program: 625982782CCD0D7B, F777123A8C3D5E20, 1FF646FF8F39536E
// shader: 8B30, 0049E2EDD992FDDF
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = 2.0 * (texcolor1).rgb - 1.0;
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += ((light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[2].position + view);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * LookupLightingLUTUnsigned(18, clamp(light_src[2].dist_atten_scale * length(-light_src[2].position - view) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[2].specular_0) + (light_src[2].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(18, clamp(light_src[2].dist_atten_scale * length(-light_src[2].position - view) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[3].position + view);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * LookupLightingLUTUnsigned(19, clamp(light_src[3].dist_atten_scale * length(-light_src[3].position - view) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[3].specular_0) + (light_src[3].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(19, clamp(light_src[3].dist_atten_scale * length(-light_src[3].position - view) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((secondary_fragment_color.r) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (last_tex_env_out.aaa), vec3(0), vec3(1)));
float alpha_output_1 = (texcolor0.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_2 = byteround(clamp((combiner_buffer.rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tex_env_out.rgb;
combiner_buffer = next_combiner_buffer;
if (last_tex_env_out.a <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 78ABFADC53A588B8, 0049E2EDD992FDDF
// program: 625982782CCD0D7B, F777123A8C3D5E20, 0049E2EDD992FDDF
// reference: FA26314FC4469DB3, 150702E3F406903E
// shader: 8B30, 2ABF755DBC001504
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tex_env_out.rgb;
combiner_buffer = next_combiner_buffer;
if (last_tex_env_out.a <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: E7FF40CEC4469DB3, 2ABF755DBC001504
// program: 625982782CCD0D7B, F777123A8C3D5E20, 2ABF755DBC001504
// shader: 8B30, 40AC75E82F61755E
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor1.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = (texcolor1.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tex_env_out.rgb;
vec3 color_output_4 = byteround(clamp((vec3(1) - textureProj(tex0, vec3(texcoord0, texcoord0_w)).rgb) * (const_color[4].rgb), vec3(0), vec3(1)));
float alpha_output_4 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_5 = byteround(clamp((combiner_buffer.rgb) * (vec3(1) - last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
if (last_tex_env_out.a <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: E7EE52C609B26699, 40AC75E82F61755E
// program: 625982782CCD0D7B, F777123A8C3D5E20, 40AC75E82F61755E
// shader: 8B30, A929CF6B7E6FB0BA
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += ((light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[2].position + view);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * LookupLightingLUTUnsigned(18, clamp(light_src[2].dist_atten_scale * length(-light_src[2].position - view) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[2].specular_0) + (light_src[2].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(18, clamp(light_src[2].dist_atten_scale * length(-light_src[2].position - view) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[3].position + view);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * LookupLightingLUTUnsigned(19, clamp(light_src[3].dist_atten_scale * length(-light_src[3].position - view) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[3].specular_0) + (light_src[3].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(19, clamp(light_src[3].dist_atten_scale * length(-light_src[3].position - view) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_1 = byteround(clamp((texcolor1.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tex_env_out.rgb;
vec3 color_output_2 = byteround(clamp((texcolor1.rgb) + (secondary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (const_color[2].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (last_tex_env_out.aaa) + (combiner_buffer.rgb) * (vec3(1) - (last_tex_env_out.aaa)), vec3(0), vec3(1)));
float alpha_output_3 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tex_env_out.rgb;
combiner_buffer = next_combiner_buffer;
if (last_tex_env_out.a <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D29E8B374779BDF6, A929CF6B7E6FB0BA
// program: 625982782CCD0D7B, F777123A8C3D5E20, A929CF6B7E6FB0BA
// shader: 8B30, 06E7DDEE0C953BDE
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += ((light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[2].position + view);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * LookupLightingLUTUnsigned(18, clamp(light_src[2].dist_atten_scale * length(-light_src[2].position - view) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[2].specular_0) + (light_src[2].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(18, clamp(light_src[2].dist_atten_scale * length(-light_src[2].position - view) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[3].position + view);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * LookupLightingLUTUnsigned(19, clamp(light_src[3].dist_atten_scale * length(-light_src[3].position - view) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[3].specular_0) + (light_src[3].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(19, clamp(light_src[3].dist_atten_scale * length(-light_src[3].position - view) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor1.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = (texcolor1.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tex_env_out.rgb;
vec3 color_output_4 = byteround(clamp((vec3(1) - textureProj(tex0, vec3(texcoord0, texcoord0_w)).rgb) * (const_color[4].rgb), vec3(0), vec3(1)));
float alpha_output_4 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_5 = byteround(clamp((combiner_buffer.rgb) * (vec3(1) - last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 9ACAE5724DA74CED, 06E7DDEE0C953BDE
// program: 625982782CCD0D7B, F777123A8C3D5E20, 06E7DDEE0C953BDE
// shader: 8B31, FD0389CDB7BCC57E

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)

#define min_s(x, y) min(x, y)
#define max_s(x, y) max(x, y)

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout(binding=2, std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location=0) in vec4 vs_in_reg0;
layout(location=1) in vec4 vs_in_reg1;
layout(location=2) in vec4 vs_in_reg2;
layout(location=3) in vec4 vs_in_reg3;
layout(location=4) in vec4 vs_in_reg4;
layout(location=5) in vec4 vs_in_reg5;
layout(location=6) in vec4 vs_in_reg6;
layout(location=7) in vec4 vs_in_reg7;
layout(location=8) in vec4 vs_in_reg8;

layout(location=0) out vec4 vs_out_attr0;
layout(location=1) out vec4 vs_out_attr1;
layout(location=2) out vec4 vs_out_attr2;
layout(location=3) out vec4 vs_out_attr3;
layout(location=4) out vec4 vs_out_attr4;
layout(location=5) out vec4 vs_out_attr5;
layout(location=6) out vec4 vs_out_attr6;

void main() {
vs_out_attr0 = vec4(0, 0, 0, 1);
vs_out_attr1 = vec4(0, 0, 0, 1);
vs_out_attr2 = vec4(0, 0, 0, 1);
vs_out_attr3 = vec4(0, 0, 0, 1);
vs_out_attr4 = vec4(0, 0, 0, 1);
vs_out_attr5 = vec4(0, 0, 0, 1);
vs_out_attr6 = vec4(0, 0, 0, 1);
exec_shader();
}
bvec2 bool_regs = bvec2(false);
ivec3 addr_regs = ivec3(0);
vec4 reg_tmp0 = vec4(0, 0, 0, 1);
vec4 reg_tmp1 = vec4(0, 0, 0, 1);
vec4 reg_tmp2 = vec4(0, 0, 0, 1);
vec4 reg_tmp3 = vec4(0, 0, 0, 1);
vec4 reg_tmp4 = vec4(0, 0, 0, 1);
vec4 reg_tmp5 = vec4(0, 0, 0, 1);
vec4 reg_tmp6 = vec4(0, 0, 0, 1);
vec4 reg_tmp7 = vec4(0, 0, 0, 1);
vec4 reg_tmp8 = vec4(0, 0, 0, 1);
vec4 reg_tmp9 = vec4(0, 0, 0, 1);
vec4 reg_tmp10 = vec4(0, 0, 0, 1);
vec4 reg_tmp11 = vec4(0, 0, 0, 1);
vec4 reg_tmp12 = vec4(0, 0, 0, 1);
vec4 reg_tmp13 = vec4(0, 0, 0, 1);
vec4 reg_tmp14 = vec4(0, 0, 0, 1);
vec4 reg_tmp15 = vec4(0, 0, 0, 1);

bool sub_21();
bool sub_4();
bool sub_9();
bool sub_1();
bool sub_2();
bool sub_3();
bool sub_5();
bool sub_7();
bool sub_8();
bool sub_10();
bool sub_20();
bool sub_22();
bool sub_23();
bool sub_24();
bool sub_25();
bool sub_26();
bool sub_27();
bool sub_28();
bool sub_29();
bool sub_6();
bool sub_11();
bool sub_12();
bool sub_13();
bool sub_14();
bool sub_15();
bool sub_16();
bool sub_17();
bool sub_18();
bool sub_19();
bool sub_0();
bool sub_30();
bool sub_31();
bool sub_32();
bool sub_33();
bool sub_34();
bool sub_35();
bool sub_36();
bool sub_37();
bool sub_38();
bool sub_39();
bool sub_40();
bool sub_41();
bool sub_42();
bool sub_43();
bool sub_44();
bool sub_45();
bool sub_46();

bool exec_shader() {
sub_0();
return true;
}

bool sub_21() {
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp3.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp3.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp3.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
return false;
}
bool sub_4() {
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp3.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp3.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp3.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp4.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
return false;
}
bool sub_9() {
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp3.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp3.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp3.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp4.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp5.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp5.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp5.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
reg_tmp11 = fma_s(reg_tmp1.wwww, reg_tmp5, reg_tmp11);
return false;
}
bool sub_1() {
reg_tmp15.xyz = (mul_s(uniforms.f[7].xxxx, vs_in_reg0)).xyz;
reg_tmp14.xyz = (mul_s(uniforms.f[7].yyyy, vs_in_reg1)).xyz;
reg_tmp13.xyz = (mul_s(uniforms.f[7].zzzz, vs_in_reg2)).xyz;
reg_tmp15.xyz = (uniforms.f[6] + reg_tmp15).xyz;
reg_tmp15.w = (uniforms.f[93].yyyy).w;
if (uniforms.b[1]) {
sub_2();
} else {
sub_23();
}
return false;
}
bool sub_2() {
reg_tmp0 = uniforms.f[7];
bool_regs = notEqual(uniforms.f[93].xx, reg_tmp0.yz);
reg_tmp7 = uniforms.f[93].xxxx;
reg_tmp12 = uniforms.f[93].xxxx;
reg_tmp11 = uniforms.f[93].xxxx;
reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_3();
} else {
sub_7();
}
vs_out_attr2 = -reg_tmp15;
vs_out_attr0.x = dot_s(uniforms.f[86], reg_tmp15);
vs_out_attr0.y = dot_s(uniforms.f[87], reg_tmp15);
vs_out_attr0.z = dot_s(uniforms.f[88], reg_tmp15);
vs_out_attr0.w = dot_s(uniforms.f[89], reg_tmp15);
return false;
}
bool sub_3() {
bool_regs = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
reg_tmp1.xy = (reg_tmp2.xxxx).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
sub_4();
reg_tmp1.xy = (reg_tmp2.yyyy).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
sub_4();
reg_tmp1.xy = (reg_tmp2.zzzz).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
if (bool_regs.x) {
sub_4();
}
if (uniforms.b[8]) {
sub_5();
}
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
sub_6();
return false;
}
bool sub_5() {
reg_tmp1.xy = (reg_tmp2.wwww).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
if (bool_regs.y) {
sub_4();
}
return false;
}
bool sub_7() {
if (all(bool_regs)) {
sub_8();
} else {
sub_20();
}
return false;
}
bool sub_8() {
bool_regs = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
reg_tmp1.xy = (reg_tmp2.xxxx).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
sub_9();
reg_tmp1.xy = (reg_tmp2.yyyy).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
sub_9();
reg_tmp1.xy = (reg_tmp2.zzzz).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
if (bool_regs.x) {
sub_9();
}
if (uniforms.b[8]) {
sub_10();
}
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp13.x = dot_3(uniforms.f[3].xyz, reg_tmp11.xyz);
reg_tmp13.y = dot_3(uniforms.f[4].xyz, reg_tmp11.xyz);
reg_tmp13.z = dot_3(uniforms.f[5].xyz, reg_tmp11.xyz);
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
sub_11();
return false;
}
bool sub_10() {
reg_tmp1.xy = (reg_tmp2.wwww).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
if (bool_regs.y) {
sub_9();
}
return false;
}
bool sub_20() {
bool_regs = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
reg_tmp1.xy = (reg_tmp2.xxxx).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
sub_21();
reg_tmp1.xy = (reg_tmp2.yyyy).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
sub_21();
reg_tmp1.xy = (reg_tmp2.zzzz).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
if (bool_regs.x) {
sub_21();
}
if (uniforms.b[8]) {
sub_22();
}
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
vs_out_attr1 = uniforms.f[93].xxxx;
return false;
}
bool sub_22() {
reg_tmp1.xy = (reg_tmp2.wwww).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
if (bool_regs.y) {
sub_21();
}
return false;
}
bool sub_23() {
reg_tmp0 = uniforms.f[7];
bool_regs = notEqual(uniforms.f[93].xx, reg_tmp0.yz);
if (uniforms.b[2]) {
sub_24();
} else {
sub_25();
}
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_26();
} else {
sub_27();
}
vs_out_attr2 = -reg_tmp15;
vs_out_attr0.x = dot_s(uniforms.f[86], reg_tmp15);
vs_out_attr0.y = dot_s(uniforms.f[87], reg_tmp15);
vs_out_attr0.z = dot_s(uniforms.f[88], reg_tmp15);
vs_out_attr0.w = dot_s(uniforms.f[89], reg_tmp15);
return false;
}
bool sub_24() {
reg_tmp1.x = (mul_s(uniforms.f[93].wwww, vs_in_reg7.xxxx)).x;
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp7.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp7.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp7.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
return false;
}
bool sub_25() {
addr_regs.x = (ivec2(uniforms.f[93].xx)).x;
reg_tmp10.x = dot_s(uniforms.f[25], reg_tmp15);
reg_tmp10.y = dot_s(uniforms.f[26], reg_tmp15);
reg_tmp10.z = dot_s(uniforms.f[27], reg_tmp15);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
return false;
}
bool sub_26() {
reg_tmp12.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
sub_6();
return false;
}
bool sub_27() {
if (all(bool_regs)) {
sub_28();
} else {
sub_29();
}
return false;
}
bool sub_28() {
reg_tmp12.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp11.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp11.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp11.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
reg_tmp13.x = dot_3(uniforms.f[3].xyz, reg_tmp11.xyz);
reg_tmp13.y = dot_3(uniforms.f[4].xyz, reg_tmp11.xyz);
reg_tmp13.z = dot_3(uniforms.f[5].xyz, reg_tmp11.xyz);
sub_11();
return false;
}
bool sub_29() {
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
vs_out_attr1 = uniforms.f[93].xxxx;
return false;
}
bool sub_6() {
uint jmp_to = 251u;
while (true) {
switch (jmp_to) {
case 251u:
reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
reg_tmp6.x = rsq_s(reg_tmp6.x);
reg_tmp7.x = rsq_s(reg_tmp7.x);
reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp0 = uniforms.f[93].yxxx;
if (!uniforms.b[15]) {
jmp_to = 267u; break;
}
reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
reg_tmp4 = mul_s(uniforms.f[94].zzzz, reg_tmp4);
bool_regs = greaterThanEqual(uniforms.f[93].xx, reg_tmp4.xx);
reg_tmp4 = vec4(rsq_s(reg_tmp4.x));
reg_tmp5 = mul_s(uniforms.f[94].zzzz, reg_tmp14);
if (bool_regs.x) {
jmp_to = 267u; break;
}
reg_tmp0.z = rcp_s(reg_tmp4.x);
reg_tmp0.xy = (mul_s(reg_tmp5, reg_tmp4)).xy;
case 267u:
vs_out_attr1 = reg_tmp0;
default: return false;
}
}
return false;
}
bool sub_11() {
uint jmp_to = 268u;
while (true) {
switch (jmp_to) {
case 268u:
reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
reg_tmp6.x = rsq_s(reg_tmp6.x);
reg_tmp7.x = rsq_s(reg_tmp7.x);
reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp13.xyz = (mul_s(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp11.xyz = (mul_s(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp0 = uniforms.f[93].yxxx;
if (!uniforms.b[15]) {
jmp_to = 343u; break;
}
reg_tmp13.xyz = (mul_s(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp11.xyz = (mul_s(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp5 = mul_s(reg_tmp14.yzxx, reg_tmp13.zxyy);
reg_tmp5 = fma_s(-reg_tmp13.yzxx, reg_tmp14.zxyy, reg_tmp5);
reg_tmp5.w = dot_3(reg_tmp5.xyz, reg_tmp5.xyz);
reg_tmp5.w = rsq_s(reg_tmp5.w);
reg_tmp5 = mul_s(reg_tmp5, reg_tmp5.wwww);
reg_tmp6.w = (reg_tmp14.zzzz + reg_tmp5.yyyy).w;
reg_tmp13 = mul_s(reg_tmp5.yzxx, reg_tmp14.zxyy);
reg_tmp13 = fma_s(-reg_tmp14.yzxx, reg_tmp5.zxyy, reg_tmp13);
reg_tmp6.w = (reg_tmp13.xxxx + reg_tmp6).w;
reg_tmp13.w = (reg_tmp5.zzzz).w;
reg_tmp5.z = (reg_tmp13.xxxx).z;
reg_tmp6.w = (uniforms.f[93].yyyy + reg_tmp6).w;
reg_tmp14.w = (reg_tmp5.xxxx).w;
reg_tmp5.x = (reg_tmp14.zzzz).x;
bool_regs = lessThan(uniforms.f[94].yy, reg_tmp6.ww);
reg_tmp6.x = (uniforms.f[93].yyyy).x;
reg_tmp6.y = (-uniforms.f[93].yyyy).y;
if (!bool_regs.x) {
jmp_to = 305u; break;
}
reg_tmp7.xz = (reg_tmp13.wwyy + -reg_tmp14.yyww).xz;
reg_tmp7.y = (reg_tmp14.xxxx + -reg_tmp13.zzzz).y;
reg_tmp7.w = (reg_tmp6).w;
reg_tmp6 = vec4(dot_s(reg_tmp7, reg_tmp7));
reg_tmp6 = vec4(rsq_s(reg_tmp6.x));
reg_tmp0 = mul_s(reg_tmp7, reg_tmp6);
if (uniforms.b[0]) {
jmp_to = 343u; break;
}
case 305u:
bool_regs = greaterThan(reg_tmp5.zy, reg_tmp5.yx);
if (bool_regs.x) {
sub_12();
} else {
sub_17();
}
reg_tmp6 = vec4(dot_s(reg_tmp8, reg_tmp8));
reg_tmp6 = vec4(rsq_s(reg_tmp6.x));
reg_tmp0 = mul_s(reg_tmp8, reg_tmp6);
case 343u:
vs_out_attr1 = reg_tmp0;
default: return false;
}
}
return false;
}
bool sub_12() {
if (bool_regs.y) {
sub_13();
} else {
sub_14();
}
reg_tmp8.w = (-reg_tmp8).w;
return false;
}
bool sub_13() {
reg_tmp8 = mul_s(reg_tmp13.yyzw, reg_tmp6.xxxy);
reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
return false;
}
bool sub_14() {
bool_regs = greaterThan(reg_tmp5.zz, reg_tmp5.xx);
reg_tmp8 = mul_s(reg_tmp13.yyzw, reg_tmp6.xxxy);
reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
if (bool_regs.x) {
sub_15();
} else {
sub_16();
}
return false;
}
bool sub_15() {
reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
return false;
}
bool sub_16() {
reg_tmp8 = mul_s(reg_tmp13.zwwy, reg_tmp6.xxxy);
reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
return false;
}
bool sub_17() {
if (bool_regs.y) {
sub_18();
} else {
sub_19();
}
return false;
}
bool sub_18() {
reg_tmp8 = mul_s(reg_tmp13.yywz, reg_tmp6.xxxy);
reg_tmp8.y = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).y;
reg_tmp9 = reg_tmp5.yyyy + -reg_tmp5.xxxx;
reg_tmp8.xzw = (reg_tmp8 + reg_tmp14.wwyx).xzw;
reg_tmp8.y = (reg_tmp9 + reg_tmp8).y;
return false;
}
bool sub_19() {
reg_tmp8 = mul_s(reg_tmp13.zwwy, reg_tmp6.xxxy);
reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
reg_tmp8.w = (-reg_tmp8).w;
return false;
}
bool sub_0() {
sub_1();
reg_tmp8.xy = (uniforms.f[93].xxxx).xy;
reg_tmp0.y = (uniforms.f[7].wwww).y;
bool_regs = notEqual(uniforms.f[93].xx, reg_tmp0.xy);
reg_tmp9.xyz = (uniforms.f[93].xxxx).xyz;
reg_tmp9.w = (uniforms.f[21].wwww).w;
if (bool_regs.y) {
sub_30();
}
bool_regs = equal(uniforms.f[93].xx, reg_tmp8.xy);
if (all(bool_regs)) {
sub_32();
}
vs_out_attr3 = max_s(uniforms.f[93].xxxx, reg_tmp9);
reg_tmp0.xy = (uniforms.f[10].xxxx).xy;
if (uniforms.b[9]) {
sub_33();
} else {
sub_38();
}
reg_tmp0.xy = (uniforms.f[10].yyyy).xy;
bool_regs = equal(uniforms.f[93].yz, reg_tmp0.xy);
if (all(not(bool_regs))) {
sub_39();
} else {
sub_40();
}
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
reg_tmp4.x = dot_s(uniforms.f[14].xywz, reg_tmp6);
reg_tmp4.y = dot_s(uniforms.f[15].xywz, reg_tmp6);
vs_out_attr5 = reg_tmp4;
reg_tmp0.xy = (uniforms.f[10].zzzz).xy;
bool_regs = equal(uniforms.f[93].yz, reg_tmp0.xy);
if (all(not(bool_regs))) {
sub_43();
} else {
sub_44();
}
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
reg_tmp5.x = dot_s(uniforms.f[17].xywz, reg_tmp6);
reg_tmp5.y = dot_s(uniforms.f[18].xywz, reg_tmp6);
vs_out_attr6 = reg_tmp5;
return true;
}
bool sub_30() {
reg_tmp0 = mul_s(uniforms.f[7].wwww, vs_in_reg3);
if (uniforms.b[7]) {
sub_31();
}
reg_tmp9.xyz = (mul_s(uniforms.f[20].wwww, reg_tmp0.xyzz)).xyz;
reg_tmp8.x = (uniforms.f[93].yyyy).x;
return false;
}
bool sub_31() {
reg_tmp9.w = (mul_s(reg_tmp9.wwww, reg_tmp0.wwww)).w;
return false;
}
bool sub_32() {
reg_tmp9 = uniforms.f[21];
return false;
}
bool sub_33() {
bool_regs = equal(uniforms.f[93].yz, reg_tmp0.xy);
if (all(not(bool_regs))) {
sub_34();
} else {
sub_35();
}
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
reg_tmp3.x = dot_s(uniforms.f[11].xywz, reg_tmp6);
reg_tmp3.y = dot_s(uniforms.f[12].xywz, reg_tmp6);
reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
vs_out_attr4 = reg_tmp3;
return false;
}
bool sub_34() {
reg_tmp6.xy = (mul_s(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
return false;
}
bool sub_35() {
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_36();
} else {
sub_37();
}
return false;
}
bool sub_36() {
reg_tmp6.xy = (mul_s(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
return false;
}
bool sub_37() {
reg_tmp6.xy = (mul_s(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
return false;
}
bool sub_38() {
bool_regs = equal(uniforms.f[95].xy, reg_tmp0.xy);
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
reg_tmp6 = reg_tmp10;
reg_tmp3.x = dot_s(uniforms.f[11], reg_tmp6);
reg_tmp3.y = dot_s(uniforms.f[12], reg_tmp6);
reg_tmp3.z = dot_s(uniforms.f[13], reg_tmp6);
reg_tmp0.xy = (mul_s(uniforms.f[19].xyyy, reg_tmp3.zzzz)).xy;
reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
vs_out_attr4 = reg_tmp3;
return false;
}
bool sub_39() {
reg_tmp6.xy = (mul_s(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
return false;
}
bool sub_40() {
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_41();
} else {
sub_42();
}
return false;
}
bool sub_41() {
reg_tmp6.xy = (mul_s(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
return false;
}
bool sub_42() {
reg_tmp6.xy = (mul_s(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
return false;
}
bool sub_43() {
reg_tmp6.xy = (mul_s(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
return false;
}
bool sub_44() {
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_45();
} else {
sub_46();
}
return false;
}
bool sub_45() {
reg_tmp6.xy = (mul_s(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
return false;
}
bool sub_46() {
reg_tmp6.xy = (mul_s(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
return false;
}
// reference: EC3CAA1DF0CDF4E1, FD0389CDB7BCC57E
// shader: 8B30, 21292E7E60EA16A3
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))) + tex_lod_bias[2]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += ((light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[2].position + view);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * LookupLightingLUTUnsigned(18, clamp(light_src[2].dist_atten_scale * length(-light_src[2].position - view) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[2].specular_0) + (light_src[2].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(18, clamp(light_src[2].dist_atten_scale * length(-light_src[2].position - view) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[3].position + view);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * LookupLightingLUTUnsigned(19, clamp(light_src[3].dist_atten_scale * length(-light_src[3].position - view) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[3].specular_0) + (light_src[3].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(19, clamp(light_src[3].dist_atten_scale * length(-light_src[3].position - view) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor1.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((texcolor1.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_1 = byteround(clamp((texcolor2.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tex_env_out.rgb;
vec3 color_output_2 = byteround(clamp((texcolor2.rgb) + (secondary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (const_color[2].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (last_tex_env_out.aaa) + (combiner_buffer.rgb) * (vec3(1) - (last_tex_env_out.aaa)), vec3(0), vec3(1)));
float alpha_output_3 = byteround(clamp((texcolor1.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tex_env_out.rgb;
vec3 color_output_4 = byteround(clamp((vec3(1) - textureProj(tex0, vec3(texcoord0, texcoord0_w)).rgb) * (const_color[4].rgb), vec3(0), vec3(1)));
float alpha_output_4 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_5 = byteround(clamp((combiner_buffer.rgb) * (vec3(1) - last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
if (last_tex_env_out.a <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D28F993F60BA1241, 21292E7E60EA16A3
// program: FD0389CDB7BCC57E, EADA2116091C5E01, 21292E7E60EA16A3
// shader: 8B30, 16A434779407E7AE
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))) + tex_lod_bias[2]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += ((light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[2].position + view);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * LookupLightingLUTUnsigned(18, clamp(light_src[2].dist_atten_scale * length(-light_src[2].position - view) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[2].specular_0) + (light_src[2].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(18, clamp(light_src[2].dist_atten_scale * length(-light_src[2].position - view) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[3].position + view);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
specular_sum.a = (lut_scale_fr * LookupLightingLUTSigned(3, dot(normal, normalize(view))));
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * LookupLightingLUTUnsigned(19, clamp(light_src[3].dist_atten_scale * length(-light_src[3].position - view) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[3].specular_0) + (light_src[3].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(19, clamp(light_src[3].dist_atten_scale * length(-light_src[3].position - view) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((vec3(1) - secondary_fragment_color.aaa) * (texcolor1.rgb), vec3(0), vec3(1)));
float alpha_output_0 = (texcolor1.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((secondary_fragment_color.aaa) * (texcolor2.rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_3 = (texcolor1.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tex_env_out.rgb;
vec3 color_output_4 = byteround(clamp((vec3(1) - textureProj(tex0, vec3(texcoord0, texcoord0_w)).rgb) * (const_color[4].rgb), vec3(0), vec3(1)));
float alpha_output_4 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_5 = byteround(clamp((combiner_buffer.rgb) * (vec3(1) - last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
if (last_tex_env_out.a <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: E175EA4712E7E9A9, 16A434779407E7AE
// program: FD0389CDB7BCC57E, EADA2116091C5E01, 16A434779407E7AE
// shader: 8B30, 6BCA0D2C173D7CF0
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += ((light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[2].position + view);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * LookupLightingLUTUnsigned(18, clamp(light_src[2].dist_atten_scale * length(-light_src[2].position - view) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[2].specular_0) + (light_src[2].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(18, clamp(light_src[2].dist_atten_scale * length(-light_src[2].position - view) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[3].position + view);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * LookupLightingLUTUnsigned(19, clamp(light_src[3].dist_atten_scale * length(-light_src[3].position - view) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[3].specular_0) + (light_src[3].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(19, clamp(light_src[3].dist_atten_scale * length(-light_src[3].position - view) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tex_env_out.rgb;
combiner_buffer = next_combiner_buffer;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 9ADBF77A8053B7C7, 6BCA0D2C173D7CF0
// program: 625982782CCD0D7B, F777123A8C3D5E20, 6BCA0D2C173D7CF0
// reference: 035253C78799BF7E, EC963DCE3A5CC151
// program: FD0389CDB7BCC57E, EADA2116091C5E01, EC963DCE3A5CC151
// shader: 8B30, 4361FEDB67ED2EA0
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))) + tex_lod_bias[2]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += ((light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[2].position + view);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * LookupLightingLUTUnsigned(18, clamp(light_src[2].dist_atten_scale * length(-light_src[2].position - view) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[2].specular_0) + (light_src[2].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(18, clamp(light_src[2].dist_atten_scale * length(-light_src[2].position - view) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[3].position + view);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * LookupLightingLUTUnsigned(19, clamp(light_src[3].dist_atten_scale * length(-light_src[3].position - view) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[3].specular_0) + (light_src[3].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(19, clamp(light_src[3].dist_atten_scale * length(-light_src[3].position - view) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor2.rgb) * (texcolor2.aaa), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((texcolor1.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (secondary_fragment_color.aaa), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tex_env_out.rgb;
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
vec3 color_output_4 = byteround(clamp((vec3(1) - textureProj(tex0, vec3(texcoord0, texcoord0_w)).rgb) * (const_color[4].rgb), vec3(0), vec3(1)));
float alpha_output_4 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_5 = byteround(clamp((combiner_buffer.rgb) * (vec3(1) - last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
if (last_tex_env_out.a <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 21AED8EF7101A906, 4361FEDB67ED2EA0
// program: FD0389CDB7BCC57E, EADA2116091C5E01, 4361FEDB67ED2EA0
// shader: 8B30, 8F3C3633B9CAA7A1
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb) * (vec3(1) - const_color[0].aaa) + (const_color[0].rgb) * (vec3(1) - (vec3(1) - const_color[0].aaa)), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (texcolor1.b) + (1.0 - texcolor1.b) * (1.0 - (texcolor1.b)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = (last_tex_env_out.rgb);
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (const_color[1].r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
if (last_tex_env_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 8E8994F0A85CC4E3, 8F3C3633B9CAA7A1
// program: 625982782CCD0D7B, F777123A8C3D5E20, 8F3C3633B9CAA7A1
// shader: 8B30, BCB6996A612CD231
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb) * (vec3(1) - const_color[0].aaa) + (const_color[0].rgb) * (vec3(1) - (vec3(1) - const_color[0].aaa)), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (texcolor1.b) + (1.0 - texcolor1.b) * (1.0 - (texcolor1.b)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = (last_tex_env_out.rgb);
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (const_color[1].r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
if (last_tex_env_out.a <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 8E8994F04FF37927, BCB6996A612CD231
// program: 625982782CCD0D7B, F777123A8C3D5E20, BCB6996A612CD231
// shader: 8B30, A9DA56A1A3E1427F
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb) * (vec3(1) - const_color[0].aaa) + (const_color[0].rgb) * (vec3(1) - (vec3(1) - const_color[0].aaa)), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (texcolor1.b) + (1.0 - texcolor1.b) * (1.0 - (texcolor1.b)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = (last_tex_env_out.rgb);
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (const_color[1].r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
if (last_tex_env_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 6640EC1BD3B6CF9A, A9DA56A1A3E1427F
// program: 625982782CCD0D7B, F777123A8C3D5E20, A9DA56A1A3E1427F
// reference: 4D023EFD1E29C19B, 5A216962B0AC0396
// reference: AD590053EED5BA8F, EC963DCE3A5CC151
// reference: E7FF40CE67346BD1, 2ABF755DBC001504
// reference: 9ACAE572EED5BA8F, 06E7DDEE0C953BDE
// reference: 9ADBF77A232141A5, 6BCA0D2C173D7CF0
// reference: 035253C7EED5BA8F, EC963DCE3A5CC151
// reference: E175EA477BABEC58, 16A434779407E7AE
// reference: 21AED8EFD2735F64, 4361FEDB67ED2EA0
// reference: 8E8994F00B2E3281, 8F3C3633B9CAA7A1
// reference: 8E8994F0EC818F45, BCB6996A612CD231
// reference: 6640EC1B70C439F8, A9DA56A1A3E1427F
// reference: 30E61E0078B98EAE, 0AB8BDAA1E48628C
// reference: 092C7FB9DBCB78CC, 0AB8BDAA1E48628C
// reference: 47A574109CD88E37, 0AB8BDAA1E48628C
// reference: 47A57410DBCB78CC, 0AB8BDAA1E48628C
// reference: 605574DCDBCB78CC, 0AB8BDAA1E48628C
// reference: 092C7FB99CD88E37, 0AB8BDAA1E48628C
// shader: 8B30, 7C0D3CEB7377967A
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb) + (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tex_env_out.rgb;
combiner_buffer = next_combiner_buffer;
if (last_tex_env_out.a <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 00AA78B8C4469DB3, 7C0D3CEB7377967A
// program: 625982782CCD0D7B, F777123A8C3D5E20, 7C0D3CEB7377967A
// reference: 7E6F15A93FAA7855, 0AB8BDAA1E48628C
// reference: 78ABFADCF0D77EDA, 0049E2EDD992FDDF
// reference: DA1A6A430AB4BA16, EC963DCE3A5CC151
// reference: 7E6F15A978B98EAE, 0AB8BDAA1E48628C
// shader: 8B30, D964AA78D393E956
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += ((light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[2].position + view);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * LookupLightingLUTUnsigned(18, clamp(light_src[2].dist_atten_scale * length(-light_src[2].position - view) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[2].specular_0) + (light_src[2].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(18, clamp(light_src[2].dist_atten_scale * length(-light_src[2].position - view) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[3].position + view);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * LookupLightingLUTUnsigned(19, clamp(light_src[3].dist_atten_scale * length(-light_src[3].position - view) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[3].specular_0) + (light_src[3].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(19, clamp(light_src[3].dist_atten_scale * length(-light_src[3].position - view) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((rounded_primary_color.a) * (texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
if (last_tex_env_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 52E2616386108830, D964AA78D393E956
// program: 625982782CCD0D7B, F777123A8C3D5E20, D964AA78D393E956
// shader: 8B31, D08A93B7A308A32C

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)

#define min_s(x, y) min(x, y)
#define max_s(x, y) max(x, y)

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout(binding=2, std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location=0) in vec4 vs_in_reg0;
layout(location=1) in vec4 vs_in_reg1;
layout(location=2) in vec4 vs_in_reg2;
layout(location=3) in vec4 vs_in_reg3;
layout(location=4) in vec4 vs_in_reg4;
layout(location=5) in vec4 vs_in_reg5;
layout(location=6) in vec4 vs_in_reg6;

layout(location=0) out vec4 vs_out_attr0;
layout(location=1) out vec4 vs_out_attr1;
layout(location=2) out vec4 vs_out_attr2;
layout(location=3) out vec4 vs_out_attr3;
layout(location=4) out vec4 vs_out_attr4;
layout(location=5) out vec4 vs_out_attr5;
layout(location=6) out vec4 vs_out_attr6;

void main() {
vs_out_attr0 = vec4(0, 0, 0, 1);
vs_out_attr1 = vec4(0, 0, 0, 1);
vs_out_attr2 = vec4(0, 0, 0, 1);
vs_out_attr3 = vec4(0, 0, 0, 1);
vs_out_attr4 = vec4(0, 0, 0, 1);
vs_out_attr5 = vec4(0, 0, 0, 1);
vs_out_attr6 = vec4(0, 0, 0, 1);
exec_shader();
}
bvec2 bool_regs = bvec2(false);
ivec3 addr_regs = ivec3(0);
vec4 reg_tmp0 = vec4(0, 0, 0, 1);
vec4 reg_tmp1 = vec4(0, 0, 0, 1);
vec4 reg_tmp2 = vec4(0, 0, 0, 1);
vec4 reg_tmp3 = vec4(0, 0, 0, 1);
vec4 reg_tmp4 = vec4(0, 0, 0, 1);
vec4 reg_tmp5 = vec4(0, 0, 0, 1);
vec4 reg_tmp6 = vec4(0, 0, 0, 1);
vec4 reg_tmp7 = vec4(0, 0, 0, 1);
vec4 reg_tmp8 = vec4(0, 0, 0, 1);
vec4 reg_tmp9 = vec4(0, 0, 0, 1);
vec4 reg_tmp10 = vec4(0, 0, 0, 1);
vec4 reg_tmp11 = vec4(0, 0, 0, 1);
vec4 reg_tmp12 = vec4(0, 0, 0, 1);
vec4 reg_tmp13 = vec4(0, 0, 0, 1);
vec4 reg_tmp14 = vec4(0, 0, 0, 1);
vec4 reg_tmp15 = vec4(0, 0, 0, 1);

bool sub_0();
bool sub_1();
bool sub_2();
bool sub_3();
bool sub_4();
bool sub_5();
bool sub_17();
bool sub_6();
bool sub_7();
bool sub_8();
bool sub_9();
bool sub_10();
bool sub_11();
bool sub_12();
bool sub_13();
bool sub_14();
bool sub_15();
bool sub_16();
bool sub_18();
bool sub_19();
bool sub_25();
bool sub_26();
bool sub_27();
bool sub_28();
bool sub_30();
bool sub_20();
bool sub_21();
bool sub_22();
bool sub_23();
bool sub_24();
bool sub_29();
bool sub_31();
bool sub_32();
bool sub_33();
bool sub_34();
bool sub_35();
bool sub_36();
bool sub_37();
bool sub_38();
bool sub_39();
bool sub_40();
bool sub_41();
bool sub_42();
bool sub_43();

bool exec_shader() {
sub_0();
return true;
}

bool sub_0() {
sub_1();
sub_3();
sub_18();
sub_32();
sub_39();
return true;
}
bool sub_1() {
reg_tmp15.xyz = (mul_s(uniforms.f[7].xxxx, vs_in_reg0)).xyz;
reg_tmp14.xyz = (mul_s(uniforms.f[7].yyyy, vs_in_reg1)).xyz;
reg_tmp13.xyz = (mul_s(uniforms.f[7].zzzz, vs_in_reg2)).xyz;
reg_tmp15.xyz = (uniforms.f[6] + reg_tmp15).xyz;
reg_tmp15.w = (uniforms.f[93].yyyy).w;
reg_tmp0 = uniforms.f[7];
reg_tmp10.x = dot_s(uniforms.f[25], reg_tmp15);
reg_tmp10.y = dot_s(uniforms.f[26], reg_tmp15);
reg_tmp10.z = dot_s(uniforms.f[27], reg_tmp15);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp12.x = dot_3(uniforms.f[25].xyz, reg_tmp14.xyz);
reg_tmp12.y = dot_3(uniforms.f[26].xyz, reg_tmp14.xyz);
reg_tmp12.z = dot_3(uniforms.f[27].xyz, reg_tmp14.xyz);
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
sub_2();
vs_out_attr2 = -reg_tmp15;
reg_tmp0.x = (uniforms.f[93].yyyy).x;
addr_regs.x = (ivec2(vs_in_reg3.xx)).x;
reg_tmp0.x = (mul_s(uniforms.f[28 + addr_regs.x].xxxx, reg_tmp0.xxxx)).x;
addr_regs.x = (ivec2(vs_in_reg3.yy)).x;
reg_tmp0.x = (mul_s(uniforms.f[28 + addr_regs.x].yyyy, reg_tmp0.xxxx)).x;
addr_regs.x = (ivec2(vs_in_reg3.zz)).x;
reg_tmp0.x = (mul_s(uniforms.f[28 + addr_regs.x].zzzz, reg_tmp0.xxxx)).x;
addr_regs.x = (ivec2(vs_in_reg3.ww)).x;
reg_tmp0.x = (mul_s(uniforms.f[28 + addr_regs.x].wwww, reg_tmp0.xxxx)).x;
reg_tmp15.xyz = (mul_s(reg_tmp15.xyzz, reg_tmp0.xxxx)).xyz;
vs_out_attr0.x = dot_s(uniforms.f[86], reg_tmp15);
vs_out_attr0.y = dot_s(uniforms.f[87], reg_tmp15);
vs_out_attr0.z = dot_s(uniforms.f[88], reg_tmp15);
vs_out_attr0.w = dot_s(uniforms.f[89], reg_tmp15);
return false;
}
bool sub_2() {
uint jmp_to = 73u;
while (true) {
switch (jmp_to) {
case 73u:
reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
reg_tmp6.x = rsq_s(reg_tmp6.x);
reg_tmp7.x = rsq_s(reg_tmp7.x);
reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp0 = uniforms.f[93].yxxx;
if (!uniforms.b[15]) {
jmp_to = 89u; break;
}
reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
reg_tmp4 = mul_s(uniforms.f[94].zzzz, reg_tmp4);
bool_regs = greaterThanEqual(uniforms.f[93].xx, reg_tmp4.xx);
reg_tmp4 = vec4(rsq_s(reg_tmp4.x));
reg_tmp5 = mul_s(uniforms.f[94].zzzz, reg_tmp14);
if (bool_regs.x) {
jmp_to = 89u; break;
}
reg_tmp0.z = rcp_s(reg_tmp4.x);
reg_tmp0.xy = (mul_s(reg_tmp5, reg_tmp4)).xy;
case 89u:
vs_out_attr1 = reg_tmp0;
default: return false;
}
}
return false;
}
bool sub_3() {
reg_tmp8.xy = (uniforms.f[93].xxxx).xy;
reg_tmp0.y = (uniforms.f[7].wwww).y;
bool_regs = notEqual(uniforms.f[93].xx, reg_tmp0.xy);
reg_tmp9.xyz = (uniforms.f[93].xxxx).xyz;
reg_tmp9.w = (uniforms.f[21].wwww).w;
if (bool_regs.y) {
sub_4();
}
if (uniforms.b[12]) {
sub_6();
}
if (uniforms.b[5]) {
sub_15();
}
bool_regs = equal(uniforms.f[93].xx, reg_tmp8.xy);
if (all(bool_regs)) {
sub_17();
}
vs_out_attr3 = max_s(uniforms.f[93].xxxx, reg_tmp9);
return false;
}
bool sub_4() {
reg_tmp0 = mul_s(uniforms.f[7].wwww, vs_in_reg3);
if (uniforms.b[7]) {
sub_5();
}
reg_tmp9.xyz = (mul_s(uniforms.f[20].wwww, reg_tmp0.xyzz)).xyz;
reg_tmp8.x = (uniforms.f[93].yyyy).x;
return false;
}
bool sub_5() {
reg_tmp9.w = (mul_s(reg_tmp9.wwww, reg_tmp0.wwww)).w;
return false;
}
bool sub_17() {
reg_tmp9 = uniforms.f[21];
return false;
}
bool sub_6() {
reg_tmp1 = uniforms.f[20];
reg_tmp2 = uniforms.f[21];
reg_tmp3 = uniforms.f[93].xxxx;
addr_regs.z = int(uniforms.i[0].y);
for (uint i = 0u; i <= uniforms.i[0].x; addr_regs.z += int(uniforms.i[0].z), ++i) {
sub_7();
}
reg_tmp8.x = (uniforms.f[93].yyyy).x;
return false;
}
bool sub_7() {
addr_regs.x = (ivec2(reg_tmp3.xy)).x;
reg_tmp4.x = (uniforms.f[49 + addr_regs.x].wwww).x;
reg_tmp4.y = (uniforms.f[51 + addr_regs.x].wwww).y;
bool_regs = equal(uniforms.f[93].xy, reg_tmp4.xy);
if (bool_regs.x) {
sub_8();
} else {
sub_9();
}
bool_regs.x = uniforms.f[93].xxxx.x == reg_tmp6.xyyy.x;
bool_regs.y = uniforms.f[93].xxxx.y < reg_tmp6.xyyy.y;
if (bool_regs.y) {
sub_14();
}
reg_tmp3 = -uniforms.f[95].wwww + reg_tmp3;
return false;
}
bool sub_8() {
reg_tmp6.x = dot_3(uniforms.f[49 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp6.y = (uniforms.f[93].yyyy).y;
return false;
}
bool sub_9() {
reg_tmp4 = uniforms.f[49 + addr_regs.x] + -reg_tmp15;
reg_tmp6.y = (uniforms.f[93].yyyy).y;
if (bool_regs.y) {
sub_10();
}
reg_tmp5 = uniforms.f[50 + addr_regs.x];
bool_regs = equal(uniforms.f[93].yy, reg_tmp5.ww);
reg_tmp4.w = dot_3(reg_tmp4.xyz, reg_tmp4.xyz);
reg_tmp4.w = rsq_s(reg_tmp4.w);
reg_tmp4 = mul_s(reg_tmp4, reg_tmp4.wwww);
if (bool_regs.x) {
sub_11();
}
reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp4.xyz);
return false;
}
bool sub_10() {
reg_tmp5.x = (uniforms.f[93].yyyy).x;
reg_tmp5.z = dot_3(reg_tmp4.xyz, reg_tmp4.xyz);
reg_tmp5.y = (mul_s(reg_tmp5.zzzz, reg_tmp5.zzzz)).y;
reg_tmp6.y = dot_3(uniforms.f[51 + addr_regs.x].xyz, reg_tmp5.xyz);
reg_tmp6.y = rcp_s(reg_tmp6.y);
return false;
}
bool sub_11() {
reg_tmp5.x = dot_3(uniforms.f[50 + addr_regs.x].xyz, -reg_tmp4.xyz);
reg_tmp5.y = (vec4(lessThan(reg_tmp5.xxxx, uniforms.f[52 + addr_regs.x].yyyy))).y;
bool_regs = equal(uniforms.f[93].yy, reg_tmp5.xy);
if (bool_regs.y) {
sub_12();
} else {
sub_13();
}
reg_tmp6.y = (mul_s(reg_tmp6.yyyy, reg_tmp5.xxxx)).y;
return false;
}
bool sub_12() {
reg_tmp5.x = (uniforms.f[93].xxxx).x;
return false;
}
bool sub_13() {
reg_tmp5.y = log2(reg_tmp5.x);
reg_tmp5.y = (mul_s(uniforms.f[52 + addr_regs.x].xxxx, reg_tmp5.yyyy)).y;
reg_tmp5.x = exp2(reg_tmp5.y);
return false;
}
bool sub_14() {
reg_tmp6.x = (max_s(uniforms.f[93].xxxx, reg_tmp6.xxxx)).x;
reg_tmp9.xyz = (fma_s(reg_tmp1.xyzz, uniforms.f[47 + addr_regs.x].xyzz, reg_tmp9.xyzz)).xyz;
reg_tmp4 = mul_s(uniforms.f[48 + addr_regs.x], reg_tmp2);
reg_tmp5.xyz = (mul_s(reg_tmp6.xxxx, reg_tmp4.xyzz)).xyz;
reg_tmp5.xyz = (mul_s(reg_tmp6.yyyy, reg_tmp5.xyzz)).xyz;
reg_tmp9.xyz = (reg_tmp9.xyzz + reg_tmp5.xyzz).xyz;
reg_tmp9.w = (reg_tmp9.wwww + reg_tmp4.wwww).w;
return false;
}
bool sub_15() {
reg_tmp1 = vec4(dot_3(uniforms.f[24].xyz, reg_tmp14.xyz));
reg_tmp2 = uniforms.f[24].wwww;
reg_tmp1 = fma_s(reg_tmp1, reg_tmp2, reg_tmp2);
reg_tmp3 = uniforms.f[22];
reg_tmp2 = uniforms.f[23] + -reg_tmp3;
reg_tmp4 = fma_s(reg_tmp2, reg_tmp1, reg_tmp3);
if (uniforms.b[6]) {
sub_16();
}
reg_tmp9.xyz = (fma_s(reg_tmp4, uniforms.f[21], reg_tmp9)).xyz;
reg_tmp8.x = (uniforms.f[93].yyyy).x;
return false;
}
bool sub_16() {
reg_tmp4 = mul_s(reg_tmp4, reg_tmp9.wwww);
return false;
}
bool sub_18() {
reg_tmp0.xy = (uniforms.f[10].xxxx).xy;
if (uniforms.b[9]) {
sub_19();
} else {
sub_25();
}
return false;
}
bool sub_19() {
sub_20();
reg_tmp3.x = dot_s(uniforms.f[11].xywz, reg_tmp6);
reg_tmp3.y = dot_s(uniforms.f[12].xywz, reg_tmp6);
reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
vs_out_attr4 = reg_tmp3;
return false;
}
bool sub_25() {
bool_regs = equal(uniforms.f[95].xy, reg_tmp0.xy);
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
if (all(not(bool_regs))) {
sub_26();
} else {
sub_27();
}
vs_out_attr4 = reg_tmp3;
return false;
}
bool sub_26() {
reg_tmp6 = reg_tmp10;
reg_tmp3.x = dot_s(uniforms.f[11], reg_tmp6);
reg_tmp3.y = dot_s(uniforms.f[12], reg_tmp6);
reg_tmp3.z = dot_s(uniforms.f[13], reg_tmp6);
reg_tmp0.xy = (mul_s(uniforms.f[19].xyyy, reg_tmp3.zzzz)).xy;
reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
return false;
}
bool sub_27() {
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_28();
} else {
sub_30();
}
return false;
}
bool sub_28() {
sub_29();
reg_tmp3.x = dot_3(uniforms.f[11].xyz, reg_tmp6.xyz);
reg_tmp3.y = dot_3(uniforms.f[12].xyz, reg_tmp6.xyz);
reg_tmp3.z = dot_3(uniforms.f[13].xyz, reg_tmp6.xyz);
return false;
}
bool sub_30() {
sub_31();
reg_tmp3.x = dot_s(uniforms.f[11], reg_tmp6);
reg_tmp3.y = dot_s(uniforms.f[12], reg_tmp6);
return false;
}
bool sub_20() {
bool_regs = equal(uniforms.f[93].yz, reg_tmp0.xy);
if (all(not(bool_regs))) {
sub_21();
} else {
sub_22();
}
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
return false;
}
bool sub_21() {
reg_tmp6.xy = (mul_s(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
return false;
}
bool sub_22() {
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_23();
} else {
sub_24();
}
return false;
}
bool sub_23() {
reg_tmp6.xy = (mul_s(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
return false;
}
bool sub_24() {
reg_tmp6.xy = (mul_s(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
return false;
}
bool sub_29() {
reg_tmp2 = -reg_tmp15;
reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
reg_tmp2.w = rsq_s(reg_tmp2.w);
reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
reg_tmp1 = reg_tmp1 + reg_tmp1;
reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
return false;
}
bool sub_31() {
reg_tmp1.xy = (uniforms.f[94].zzzz).xy;
reg_tmp1.zw = (uniforms.f[93].xxxx).zw;
reg_tmp6 = fma_s(reg_tmp14, reg_tmp1, reg_tmp1);
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
return false;
}
bool sub_32() {
reg_tmp0.xy = (uniforms.f[10].yyyy).xy;
if (uniforms.b[10]) {
sub_33();
} else {
sub_34();
}
return false;
}
bool sub_33() {
sub_20();
reg_tmp4.x = dot_s(uniforms.f[14].xywz, reg_tmp6);
reg_tmp4.y = dot_s(uniforms.f[15].xywz, reg_tmp6);
vs_out_attr5 = reg_tmp4;
return false;
}
bool sub_34() {
if (uniforms.b[13]) {
sub_35();
} else {
sub_38();
}
return false;
}
bool sub_35() {
bool_regs = equal(uniforms.f[95].xy, reg_tmp0.xy);
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
if (all(not(bool_regs))) {
sub_36();
} else {
sub_37();
}
vs_out_attr5 = reg_tmp4;
return false;
}
bool sub_36() {
reg_tmp6 = reg_tmp10;
reg_tmp4.x = dot_s(uniforms.f[14], reg_tmp6);
reg_tmp4.y = dot_s(uniforms.f[15], reg_tmp6);
reg_tmp4.z = dot_s(uniforms.f[16], reg_tmp6);
reg_tmp6.w = rcp_s(reg_tmp4.z);
reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
reg_tmp4.xy = (uniforms.f[19].zwww + reg_tmp4.xyyy).xy;
return false;
}
bool sub_37() {
sub_31();
reg_tmp4.x = dot_s(uniforms.f[14], reg_tmp6);
reg_tmp4.y = dot_s(uniforms.f[15], reg_tmp6);
return false;
}
bool sub_38() {
vs_out_attr5 = uniforms.f[93].xxxx;
return false;
}
bool sub_39() {
reg_tmp0.xy = (uniforms.f[10].zzzz).xy;
if (uniforms.b[11]) {
sub_40();
} else {
sub_41();
}
return false;
}
bool sub_40() {
sub_20();
reg_tmp5.x = dot_s(uniforms.f[17].xywz, reg_tmp6);
reg_tmp5.y = dot_s(uniforms.f[18].xywz, reg_tmp6);
vs_out_attr6 = reg_tmp5;
return false;
}
bool sub_41() {
if (uniforms.b[14]) {
sub_42();
} else {
sub_43();
}
return false;
}
bool sub_42() {
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
reg_tmp5.zw = (reg_tmp6.zwww).zw;
sub_31();
reg_tmp5.x = dot_s(uniforms.f[17], reg_tmp6);
reg_tmp5.y = dot_s(uniforms.f[18], reg_tmp6);
vs_out_attr6 = reg_tmp5;
return false;
}
bool sub_43() {
vs_out_attr6 = uniforms.f[93].xxxx;
return false;
}
// reference: 8F16A4083B573E98, D08A93B7A308A32C
// shader: 8B30, 8F65D4C9937515E7
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += ((light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[2].position + view);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * LookupLightingLUTUnsigned(18, clamp(light_src[2].dist_atten_scale * length(-light_src[2].position - view) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[2].specular_0) + (light_src[2].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(18, clamp(light_src[2].dist_atten_scale * length(-light_src[2].position - view) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[3].position + view);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * LookupLightingLUTUnsigned(19, clamp(light_src[3].dist_atten_scale * length(-light_src[3].position - view) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[3].specular_0) + (light_src[3].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(19, clamp(light_src[3].dist_atten_scale * length(-light_src[3].position - view) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = (secondary_fragment_color.r);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
vec3 color_output_1 = byteround(clamp((texcolor1.rgb) * (last_tex_env_out.aaa), vec3(0), vec3(1)));
float alpha_output_1 = (texcolor0.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_2 = byteround(clamp((combiner_buffer.rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tex_env_out.rgb;
combiner_buffer = next_combiner_buffer;
if (last_tex_env_out.a <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 58C8621D62B257F1, 8F65D4C9937515E7
// program: D08A93B7A308A32C, EADA2116091C5E01, 8F65D4C9937515E7
// shader: 8B30, 827335DA69BDA0DB
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += ((light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[2].position + view);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * LookupLightingLUTUnsigned(18, clamp(light_src[2].dist_atten_scale * length(-light_src[2].position - view) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[2].specular_0) + (light_src[2].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(18, clamp(light_src[2].dist_atten_scale * length(-light_src[2].position - view) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[3].position + view);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * LookupLightingLUTUnsigned(19, clamp(light_src[3].dist_atten_scale * length(-light_src[3].position - view) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[3].specular_0) + (light_src[3].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(19, clamp(light_src[3].dist_atten_scale * length(-light_src[3].position - view) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor1.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = (texcolor1.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tex_env_out.rgb;
vec3 color_output_4 = byteround(clamp((vec3(1) - textureProj(tex0, vec3(texcoord0, texcoord0_w)).rgb) * (const_color[4].rgb), vec3(0), vec3(1)));
float alpha_output_4 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_5 = byteround(clamp((combiner_buffer.rgb) * (vec3(1) - last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
if (last_tex_env_out.a <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 84E1CDBB803FDFD4, 827335DA69BDA0DB
// program: 625982782CCD0D7B, F777123A8C3D5E20, 827335DA69BDA0DB
// shader: 8B30, DC30A32F29D57F45
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += ((light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[2].position + view);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * LookupLightingLUTUnsigned(18, clamp(light_src[2].dist_atten_scale * length(-light_src[2].position - view) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[2].specular_0) + (light_src[2].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(18, clamp(light_src[2].dist_atten_scale * length(-light_src[2].position - view) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[3].position + view);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * LookupLightingLUTUnsigned(19, clamp(light_src[3].dist_atten_scale * length(-light_src[3].position - view) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[3].specular_0) + (light_src[3].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(19, clamp(light_src[3].dist_atten_scale * length(-light_src[3].position - view) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.rgb) * (texcolor1.rgb), vec3(0), vec3(1)));
float alpha_output_0 = (texcolor1.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tex_env_out.rgb;
vec3 color_output_4 = byteround(clamp((vec3(1) - textureProj(tex0, vec3(texcoord0, texcoord0_w)).rgb) * (const_color[4].rgb), vec3(0), vec3(1)));
float alpha_output_4 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_5 = byteround(clamp((combiner_buffer.rgb) * (vec3(1) - last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
if (last_tex_env_out.a <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 84E1CDBBEF98E897, DC30A32F29D57F45
// program: 625982782CCD0D7B, F777123A8C3D5E20, DC30A32F29D57F45
// shader: 8B30, C18C877C3284B236
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += ((light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[2].position + view);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * LookupLightingLUTUnsigned(18, clamp(light_src[2].dist_atten_scale * length(-light_src[2].position - view) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[2].specular_0) + (light_src[2].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(18, clamp(light_src[2].dist_atten_scale * length(-light_src[2].position - view) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[3].position + view);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * LookupLightingLUTUnsigned(19, clamp(light_src[3].dist_atten_scale * length(-light_src[3].position - view) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[3].specular_0) + (light_src[3].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(19, clamp(light_src[3].dist_atten_scale * length(-light_src[3].position - view) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((primary_fragment_color.aaa) * (texcolor1.rgb), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((texcolor1.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_2 = (last_tex_env_out.aaa);
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tex_env_out.rgb;
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
vec3 color_output_4 = byteround(clamp((vec3(1) - textureProj(tex0, vec3(texcoord0, texcoord0_w)).rgb) * (const_color[4].rgb), vec3(0), vec3(1)));
float alpha_output_4 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_5 = byteround(clamp((combiner_buffer.rgb) * (vec3(1) - last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
if (last_tex_env_out.a <= alphatest_ref) discard;
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 1321A0491E678F20, C18C877C3284B236
// program: FD0389CDB7BCC57E, EADA2116091C5E01, C18C877C3284B236
// shader: 8B30, 8CE512B08922067E
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))) + tex_lod_bias[2]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[1].position);
spot_dir = light_src[1].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[1].diffuse * dot_product) + light_src[1].ambient) * 1.0;
specular_sum.rgb += ((light_src[1].specular_0) + (light_src[1].specular_1)) * clamp_highlights * 1.0;
light_vector = normalize(light_src[2].position + view);
spot_dir = light_src[2].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[2].diffuse * dot_product) + light_src[2].ambient) * LookupLightingLUTUnsigned(18, clamp(light_src[2].dist_atten_scale * length(-light_src[2].position - view) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[2].specular_0) + (light_src[2].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(18, clamp(light_src[2].dist_atten_scale * length(-light_src[2].position - view) + light_src[2].dist_atten_bias, 0.0, 1.0)) * 1.0;
light_vector = normalize(light_src[3].position + view);
spot_dir = light_src[3].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
specular_sum.a = (lut_scale_fr * LookupLightingLUTSigned(3, dot(normal, normalize(view))));
diffuse_sum.rgb += ((light_src[3].diffuse * dot_product) + light_src[3].ambient) * LookupLightingLUTUnsigned(19, clamp(light_src[3].dist_atten_scale * length(-light_src[3].position - view) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
specular_sum.rgb += ((light_src[3].specular_0) + (light_src[3].specular_1)) * clamp_highlights * LookupLightingLUTUnsigned(19, clamp(light_src[3].dist_atten_scale * length(-light_src[3].position - view) + light_src[3].dist_atten_bias, 0.0, 1.0)) * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((vec3(1) - secondary_fragment_color.aaa) * (texcolor1.rgb), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((texcolor1.a) * (1.0 - secondary_fragment_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_1 = byteround(clamp((texcolor2.a) * (secondary_fragment_color.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = byteround(clamp((secondary_fragment_color.aaa) * (texcolor2.rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tex_env_out.rgb;
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
vec3 color_output_4 = byteround(clamp((vec3(1) - textureProj(tex0, vec3(texcoord0, texcoord0_w)).rgb) * (const_color[4].rgb), vec3(0), vec3(1)));
float alpha_output_4 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_5 = byteround(clamp((combiner_buffer.rgb) * (vec3(1) - last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
float fog_index = depth * 128.0;
float fog_i = clamp(floor(fog_index), 0.0, 127.0);
float fog_f = fog_index - fog_i;
vec2 fog_lut_entry = texelFetch(tex_lut_lf, int(fog_i) + fog_lut_offset).rg;
float fog_factor = fog_lut_entry.r + fog_lut_entry.g * fog_f;
fog_factor = clamp(fog_factor, 0.0, 1.0);
last_tex_env_out.rgb = mix(fog_color.rgb, last_tex_env_out.rgb, fog_factor);
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D0866EB864DB1C66, 8CE512B08922067E
// program: FD0389CDB7BCC57E, EADA2116091C5E01, 8CE512B08922067E
// reference: 2F8B080DC1C0A193, 8F65D4C9937515E7
// reference: 84E1CDBB234D29B6, 827335DA69BDA0DB
// reference: 84E1CDBB4CEA1EF5, DC30A32F29D57F45
// reference: 1321A049772B8AD1, C18C877C3284B236
// reference: D0866EB80D971997, 8CE512B08922067E
// shader: 8B30, F1885D0AF8BF4994
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))) + tex_lod_bias[2]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((vec3(1) - texcolor0.rrr) - (vec3(1) - texcolor1.rrr), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((1.0 - texcolor0.r) - (1.0 - texcolor2.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0 * 4.0, alpha_output_0 * 4.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) + (last_tex_env_out.aaa), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1 * 4.0, alpha_output_1 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2 * 4.0, alpha_output_2 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = byteround(clamp((const_color[3].rgb) * (vec3(1) - texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_3 = byteround(clamp((const_color[3].a) * (1.0 - texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (texcolor0.rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (texcolor0.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (const_color[5].rgb), vec3(0), vec3(1)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (const_color[5].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
if (last_tex_env_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 9464B5347872D176, F1885D0AF8BF4994
// program: 3AE9AAE877A9E01A, B6B95AFD9466EC70, F1885D0AF8BF4994
// shader: 8B30, 863363E2F8C23DC0
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))) + tex_lod_bias[2]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((vec3(1) - texcolor0.rrr) - (vec3(1) - texcolor1.rrr), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((1.0 - texcolor0.r) - (1.0 - texcolor2.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0 * 4.0, alpha_output_0 * 4.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) + (last_tex_env_out.aaa), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1 * 4.0, alpha_output_1 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2 * 4.0, alpha_output_2 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = byteround(clamp((vec3(1) - texcolor0.rgb) * (const_color[3].rgb), vec3(0), vec3(1)));
float alpha_output_3 = byteround(clamp((texcolor0.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_4 = byteround(clamp((texcolor0.rgb) * (const_color[4].rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_4 = byteround(clamp((1.0 - texcolor0.a) * (const_color[4].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
if (last_tex_env_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: B1A8721F7F48E6DF, 863363E2F8C23DC0
// program: 3AE9AAE877A9E01A, B6B95AFD9466EC70, 863363E2F8C23DC0
// shader: 8B30, 45E2174AE15FBF0E
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (rounded_primary_color.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: C4AFFEA1C9B2834D, 45E2174AE15FBF0E
// program: 85A5116CCB32BF2A, F777123A8C3D5E20, 45E2174AE15FBF0E
// shader: 8B30, 8BBFD0CFE94448D9
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = (rounded_primary_color.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
if (last_tex_env_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: F33C1B80981B7211, 8BBFD0CFE94448D9
// program: 85A5116CCB32BF2A, F777123A8C3D5E20, 8BBFD0CFE94448D9
// shader: 8B30, 086D9EB605D403CF
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = (rounded_primary_color.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: C4AFFEA1981B7211, 086D9EB605D403CF
// program: 85A5116CCB32BF2A, F777123A8C3D5E20, 086D9EB605D403CF
// shader: 8B31, 344AB4D45FEDDC9A

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)

#define min_s(x, y) min(x, y)
#define max_s(x, y) max(x, y)

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout(binding=2, std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location=0) in vec4 vs_in_reg0;
layout(location=1) in vec4 vs_in_reg1;
layout(location=2) in vec4 vs_in_reg2;
layout(location=4) in vec4 vs_in_reg4;
layout(location=5) in vec4 vs_in_reg5;
layout(location=6) in vec4 vs_in_reg6;
layout(location=7) in vec4 vs_in_reg7;
layout(location=8) in vec4 vs_in_reg8;

layout(location=0) out vec4 vs_out_attr0;
layout(location=1) out vec4 vs_out_attr1;
layout(location=2) out vec4 vs_out_attr2;
layout(location=3) out vec4 vs_out_attr3;
layout(location=4) out vec4 vs_out_attr4;
layout(location=5) out vec4 vs_out_attr5;
layout(location=6) out vec4 vs_out_attr6;

void main() {
vs_out_attr0 = vec4(0, 0, 0, 1);
vs_out_attr1 = vec4(0, 0, 0, 1);
vs_out_attr2 = vec4(0, 0, 0, 1);
vs_out_attr3 = vec4(0, 0, 0, 1);
vs_out_attr4 = vec4(0, 0, 0, 1);
vs_out_attr5 = vec4(0, 0, 0, 1);
vs_out_attr6 = vec4(0, 0, 0, 1);
exec_shader();
}
bvec2 bool_regs = bvec2(false);
ivec3 addr_regs = ivec3(0);
vec4 reg_tmp0 = vec4(0, 0, 0, 1);
vec4 reg_tmp1 = vec4(0, 0, 0, 1);
vec4 reg_tmp2 = vec4(0, 0, 0, 1);
vec4 reg_tmp3 = vec4(0, 0, 0, 1);
vec4 reg_tmp4 = vec4(0, 0, 0, 1);
vec4 reg_tmp5 = vec4(0, 0, 0, 1);
vec4 reg_tmp6 = vec4(0, 0, 0, 1);
vec4 reg_tmp7 = vec4(0, 0, 0, 1);
vec4 reg_tmp8 = vec4(0, 0, 0, 1);
vec4 reg_tmp9 = vec4(0, 0, 0, 1);
vec4 reg_tmp10 = vec4(0, 0, 0, 1);
vec4 reg_tmp11 = vec4(0, 0, 0, 1);
vec4 reg_tmp12 = vec4(0, 0, 0, 1);
vec4 reg_tmp13 = vec4(0, 0, 0, 1);
vec4 reg_tmp14 = vec4(0, 0, 0, 1);
vec4 reg_tmp15 = vec4(0, 0, 0, 1);

bool sub_7();
bool sub_8();
bool sub_9();
bool sub_10();
bool sub_12();
bool sub_13();
bool sub_19();
bool sub_20();
bool sub_21();
bool sub_22();
bool sub_24();
bool sub_14();
bool sub_15();
bool sub_16();
bool sub_17();
bool sub_18();
bool sub_23();
bool sub_25();
bool sub_26();
bool sub_27();
bool sub_28();
bool sub_29();
bool sub_30();
bool sub_31();
bool sub_32();
bool sub_33();
bool sub_34();
bool sub_35();
bool sub_36();
bool sub_37();
bool sub_0();
bool sub_6();
bool sub_11();
bool sub_2();
bool sub_4();
bool sub_1();
bool sub_3();
bool sub_5();

bool exec_shader() {
sub_0();
return true;
}

bool sub_7() {
reg_tmp1.xyz = (uniforms.f[93].xxyx).xyz;
reg_tmp8.x = dot_3(uniforms.f[0].xyz, reg_tmp12.xyz);
reg_tmp8.y = dot_3(uniforms.f[1].xyz, reg_tmp12.xyz);
reg_tmp8.z = dot_3(uniforms.f[2].xyz, reg_tmp12.xyz);
reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp8.xyz);
reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp8.xyz);
reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp8.xyz);
reg_tmp14.w = (uniforms.f[93].xxxx).w;
reg_tmp8 = reg_tmp14;
reg_tmp14.x = dot_s(reg_tmp8, reg_tmp8);
reg_tmp14.x = rsq_s(reg_tmp14.x);
reg_tmp14 = mul_s(reg_tmp8, reg_tmp14.xxxx);
reg_tmp0 = uniforms.f[23];
reg_tmp8.x = dot_3(uniforms.f[0].xyz, reg_tmp0.xyz);
reg_tmp8.y = dot_3(uniforms.f[1].xyz, reg_tmp0.xyz);
reg_tmp8.z = dot_3(uniforms.f[2].xyz, reg_tmp0.xyz);
reg_tmp6.x = dot_3(uniforms.f[90].xyz, reg_tmp8.xyz);
reg_tmp6.y = dot_3(uniforms.f[91].xyz, reg_tmp8.xyz);
reg_tmp6.z = dot_3(uniforms.f[92].xyz, reg_tmp8.xyz);
reg_tmp8.xyz = (reg_tmp6.xyzz + reg_tmp1.xyzz).xyz;
reg_tmp8.w = (uniforms.f[93].xxxx).w;
reg_tmp0.x = dot_s(reg_tmp8, reg_tmp8);
reg_tmp0.x = rsq_s(reg_tmp0.x);
reg_tmp0 = mul_s(reg_tmp8, reg_tmp0.xxxx);
if (uniforms.b[5]) {
sub_8();
}
if (uniforms.b[3]) {
sub_9();
}
if (uniforms.b[4]) {
sub_10();
}
vs_out_attr3 = reg_tmp2;
return false;
}
bool sub_8() {
reg_tmp8.x = dot_3(reg_tmp14.xyz, -reg_tmp6.xyz);
reg_tmp8.y = dot_3(reg_tmp1.xyz, -reg_tmp6.xyz);
reg_tmp8 = max_s(uniforms.f[93].xxxx, reg_tmp8);
reg_tmp8.y = (mul_s(uniforms.f[94].zzzz, reg_tmp8.yyyy)).y;
reg_tmp8.y = (uniforms.f[94].zzzz + reg_tmp8.yyyy).y;
reg_tmp2.y = (mul_s(reg_tmp8.xxxx, reg_tmp8.yyyy)).y;
return false;
}
bool sub_9() {
reg_tmp9.z = dot_3(reg_tmp14.xyz, reg_tmp0.xyz);
reg_tmp9.z = (max_s(uniforms.f[93].xxxx, reg_tmp9.zzzz)).z;
reg_tmp9.z = (min_s(uniforms.f[93].yyyy, reg_tmp9.zzzz)).z;
reg_tmp9.z = log2(reg_tmp9.z);
reg_tmp9.z = (mul_s(uniforms.f[22].zzzz, reg_tmp9.zzzz)).z;
reg_tmp9.z = exp2(reg_tmp9.z);
reg_tmp2.z = (mul_s(uniforms.f[22].wwww, reg_tmp9.zzzz)).z;
return false;
}
bool sub_10() {
reg_tmp9.x = dot_3(reg_tmp14.xyz, reg_tmp1.xyz);
reg_tmp9.x = (max_s(uniforms.f[93].xxxx, reg_tmp9.xxxx)).x;
reg_tmp9.x = (min_s(uniforms.f[93].yyyy, reg_tmp9.xxxx)).x;
reg_tmp9.x = (uniforms.f[93].yyyy + -reg_tmp9.xxxx).x;
reg_tmp9.x = log2(reg_tmp9.x);
reg_tmp9.x = (mul_s(uniforms.f[22].xxxx, reg_tmp9.xxxx)).x;
reg_tmp9.x = exp2(reg_tmp9.x);
reg_tmp2.w = (mul_s(uniforms.f[22].yyyy, reg_tmp9.xxxx)).w;
return false;
}
bool sub_12() {
reg_tmp0.xy = (uniforms.f[10].xxxx).xy;
if (uniforms.b[9]) {
sub_13();
} else {
sub_19();
}
return false;
}
bool sub_13() {
sub_14();
reg_tmp3.x = dot_s(uniforms.f[11].xywz, reg_tmp6);
reg_tmp3.y = dot_s(uniforms.f[12].xywz, reg_tmp6);
reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
vs_out_attr4 = reg_tmp3;
return false;
}
bool sub_19() {
bool_regs = equal(uniforms.f[95].xy, reg_tmp0.xy);
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
if (all(not(bool_regs))) {
sub_20();
} else {
sub_21();
}
vs_out_attr4 = reg_tmp3;
return false;
}
bool sub_20() {
reg_tmp6 = reg_tmp10;
reg_tmp3.x = dot_s(uniforms.f[11], reg_tmp6);
reg_tmp3.y = dot_s(uniforms.f[12], reg_tmp6);
reg_tmp3.z = dot_s(uniforms.f[13], reg_tmp6);
reg_tmp0.xy = (mul_s(uniforms.f[19].xyyy, reg_tmp3.zzzz)).xy;
reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
return false;
}
bool sub_21() {
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_22();
} else {
sub_24();
}
return false;
}
bool sub_22() {
sub_23();
reg_tmp3.x = dot_3(uniforms.f[11].xyz, reg_tmp6.xyz);
reg_tmp3.y = dot_3(uniforms.f[12].xyz, reg_tmp6.xyz);
reg_tmp3.z = dot_3(uniforms.f[13].xyz, reg_tmp6.xyz);
return false;
}
bool sub_24() {
sub_25();
reg_tmp3.x = dot_s(uniforms.f[11], reg_tmp6);
reg_tmp3.y = dot_s(uniforms.f[12], reg_tmp6);
return false;
}
bool sub_14() {
bool_regs = equal(uniforms.f[93].yz, reg_tmp0.xy);
if (all(not(bool_regs))) {
sub_15();
} else {
sub_16();
}
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
return false;
}
bool sub_15() {
reg_tmp6.xy = (mul_s(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
return false;
}
bool sub_16() {
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_17();
} else {
sub_18();
}
return false;
}
bool sub_17() {
reg_tmp6.xy = (mul_s(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
return false;
}
bool sub_18() {
reg_tmp6.xy = (mul_s(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
return false;
}
bool sub_23() {
reg_tmp2 = -reg_tmp15;
reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
reg_tmp2.w = rsq_s(reg_tmp2.w);
reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
reg_tmp1 = reg_tmp1 + reg_tmp1;
reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
return false;
}
bool sub_25() {
reg_tmp1.xy = (uniforms.f[94].zzzz).xy;
reg_tmp1.zw = (uniforms.f[93].xxxx).zw;
reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
reg_tmp6.x = rsq_s(reg_tmp6.x);
reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp6 = fma_s(reg_tmp14, reg_tmp1, reg_tmp1);
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
return false;
}
bool sub_26() {
reg_tmp0.xy = (uniforms.f[10].yyyy).xy;
if (uniforms.b[10]) {
sub_27();
} else {
sub_28();
}
return false;
}
bool sub_27() {
sub_14();
reg_tmp4.x = dot_s(uniforms.f[14].xywz, reg_tmp6);
reg_tmp4.y = dot_s(uniforms.f[15].xywz, reg_tmp6);
vs_out_attr5 = reg_tmp4;
return false;
}
bool sub_28() {
if (uniforms.b[13]) {
sub_29();
} else {
sub_32();
}
return false;
}
bool sub_29() {
bool_regs = equal(uniforms.f[95].xy, reg_tmp0.xy);
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
if (all(not(bool_regs))) {
sub_30();
} else {
sub_31();
}
vs_out_attr5 = reg_tmp4;
return false;
}
bool sub_30() {
reg_tmp6 = reg_tmp10;
reg_tmp4.x = dot_s(uniforms.f[14], reg_tmp6);
reg_tmp4.y = dot_s(uniforms.f[15], reg_tmp6);
reg_tmp4.z = dot_s(uniforms.f[16], reg_tmp6);
reg_tmp6.w = rcp_s(reg_tmp4.z);
reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
reg_tmp4.xy = (uniforms.f[19].zwww + reg_tmp4.xyyy).xy;
return false;
}
bool sub_31() {
sub_25();
reg_tmp4.x = dot_s(uniforms.f[14], reg_tmp6);
reg_tmp4.y = dot_s(uniforms.f[15], reg_tmp6);
return false;
}
bool sub_32() {
vs_out_attr5 = uniforms.f[93].xxxx;
return false;
}
bool sub_33() {
reg_tmp0.xy = (uniforms.f[10].zzzz).xy;
if (uniforms.b[11]) {
sub_34();
} else {
sub_35();
}
return false;
}
bool sub_34() {
sub_14();
reg_tmp5.x = dot_s(uniforms.f[17].xywz, reg_tmp6);
reg_tmp5.y = dot_s(uniforms.f[18].xywz, reg_tmp6);
vs_out_attr6 = reg_tmp5;
return false;
}
bool sub_35() {
if (uniforms.b[14]) {
sub_36();
} else {
sub_37();
}
return false;
}
bool sub_36() {
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
reg_tmp5.zw = (reg_tmp6.zwww).zw;
sub_25();
reg_tmp5.x = dot_s(uniforms.f[17], reg_tmp6);
reg_tmp5.y = dot_s(uniforms.f[18], reg_tmp6);
vs_out_attr6 = reg_tmp5;
return false;
}
bool sub_37() {
vs_out_attr6 = uniforms.f[93].xxxx;
return false;
}
bool sub_0() {
sub_1();
if (uniforms.b[6]) {
sub_6();
} else {
sub_11();
}
sub_12();
sub_26();
sub_33();
return true;
}
bool sub_6() {
sub_7();
return false;
}
bool sub_11() {
vs_out_attr3 = uniforms.f[93].yyyy;
return false;
}
bool sub_2() {
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp3.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp3.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp3.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
reg_tmp3.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp3.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp3.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp12);
reg_tmp3.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp3.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp3.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp11 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp11);
reg_tmp3.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp5.xyz);
reg_tmp3.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp5.xyz);
reg_tmp3.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp5.xyz);
reg_tmp9 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp9);
reg_tmp3.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp6.xyz);
reg_tmp3.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp6.xyz);
reg_tmp3.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp6.xyz);
reg_tmp8 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp8);
return false;
}
bool sub_4() {
reg_tmp0.xyz = (mul_s(reg_tmp9.yzxx, reg_tmp8.zxyy)).xyz;
reg_tmp0.xyz = (fma_s(-reg_tmp8.yzxx, reg_tmp9.zxyy, reg_tmp0)).xyz;
reg_tmp1 = uniforms.f[23];
reg_tmp2.x = dot_s(reg_tmp1.xyzz, reg_tmp1.xyzz);
reg_tmp2.x = rsq_s(reg_tmp2.x);
reg_tmp2.xyz = (mul_s(reg_tmp1.xyzz, reg_tmp2.xxxx)).xyz;
reg_tmp1.x = dot_3(reg_tmp2.xyz, reg_tmp8.xyz);
reg_tmp1.y = dot_3(reg_tmp2.xyz, reg_tmp0.xyz);
reg_tmp1.z = dot_3(reg_tmp2.xyz, reg_tmp9.xyz);
reg_tmp2.x = dot_s(reg_tmp1.xyzz, reg_tmp1.xyzz);
reg_tmp2.x = rsq_s(reg_tmp2.x);
reg_tmp2.xyz = (mul_s(reg_tmp1.xyzz, reg_tmp2.xxxx)).xyz;
reg_tmp2.w = (uniforms.f[93].yyyy).w;
vs_out_attr2 = reg_tmp2;
return false;
}
bool sub_1() {
reg_tmp15.xyz = (mul_s(uniforms.f[7].xxxx, vs_in_reg0)).xyz;
reg_tmp14.xyz = (mul_s(uniforms.f[7].yyyy, vs_in_reg1)).xyz;
reg_tmp13.xyz = (mul_s(uniforms.f[7].zzzz, vs_in_reg2)).xyz;
reg_tmp15.xyz = (uniforms.f[6] + reg_tmp15).xyz;
reg_tmp15.w = (uniforms.f[93].yyyy).w;
reg_tmp5 = uniforms.f[93].xxyy;
reg_tmp6 = uniforms.f[93].yxxy;
reg_tmp7 = uniforms.f[93].xxxx;
reg_tmp12 = uniforms.f[93].xxxx;
reg_tmp11 = uniforms.f[93].xxxx;
reg_tmp9 = uniforms.f[93].xxxx;
reg_tmp8 = uniforms.f[93].xxxx;
reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
bool_regs = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
reg_tmp1.xy = (reg_tmp2.xxxx).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
sub_2();
reg_tmp1.xy = (reg_tmp2.yyyy).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
sub_2();
reg_tmp1.xy = (reg_tmp2.zzzz).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
if (bool_regs.x) {
sub_2();
}
if (uniforms.b[8]) {
sub_3();
}
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10 = reg_tmp7;
reg_tmp13.x = dot_3(uniforms.f[3].xyz, reg_tmp11.xyz);
reg_tmp13.y = dot_3(uniforms.f[4].xyz, reg_tmp11.xyz);
reg_tmp13.z = dot_3(uniforms.f[5].xyz, reg_tmp11.xyz);
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
sub_4();
vs_out_attr1 = uniforms.f[93].xxxy;
reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
reg_tmp1.x = (-reg_tmp0.wwww).x;
reg_tmp1.y = (mul_s(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
bool_regs.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
bool_regs.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
if (all(bool_regs)) {
sub_5();
}
vs_out_attr0 = reg_tmp0;
return false;
}
bool sub_3() {
reg_tmp1.xy = (reg_tmp2.wwww).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
if (bool_regs.y) {
sub_2();
}
return false;
}
bool sub_5() {
reg_tmp0.x = (-reg_tmp0.wwww).x;
return false;
}
// reference: F2378FBB3660DE07, 344AB4D45FEDDC9A
// shader: 8B30, 2385CCAFF1B43030
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))) + tex_lod_bias[2]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = 2.0 * (texcolor2).rgb - 1.0;
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(normal, normalize(view))));
refl_value.g = (lut_scale_rg * LookupLightingLUTSigned(5, dot(normal, normalize(view))));
refl_value.b = (lut_scale_rb * LookupLightingLUTSigned(4, dot(normal, normalize(view))));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor1.rgb) * (vec3(1) - const_color[0].aaa) + (const_color[0].rgb) * (vec3(1) - (vec3(1) - const_color[0].aaa)), vec3(0), vec3(1)));
float alpha_output_0 = (texcolor1.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
vec3 color_output_1 = byteround(clamp((texcolor0.rgb) + (last_tex_env_out.rgb) - vec3(0.5), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (combiner_buffer.rgb) - vec3(0.5), vec3(0), vec3(1)));
float alpha_output_2 = byteround(clamp((secondary_fragment_color.r) * (1.0 - const_color[2].a) + (secondary_fragment_color.b) * (1.0 - (1.0 - const_color[2].a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1) - (last_tex_env_out.aaa)), vec3(0), vec3(1)));
float alpha_output_3 = (texcolor1.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_4 = byteround(clamp((secondary_fragment_color.ggg) * (last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_4 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb), vec3(0), vec3(1)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 01539B5D1AE735D6, 2385CCAFF1B43030
// program: 344AB4D45FEDDC9A, EADA2116091C5E01, 2385CCAFF1B43030
// shader: 8B30, 6AE6BDA06561AFE5
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))) + tex_lod_bias[2]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = 2.0 * (texcolor2).rgb - 1.0;
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(normal, normalize(view))));
refl_value.g = (lut_scale_rg * LookupLightingLUTSigned(5, dot(normal, normalize(view))));
refl_value.b = (lut_scale_rb * LookupLightingLUTSigned(4, dot(normal, normalize(view))));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = byteround(clamp((secondary_fragment_color.r) * (texcolor2.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((texcolor0.rgb) * (const_color[1].rgb), vec3(0), vec3(1)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (1.0 - const_color[1].a) + (secondary_fragment_color.b) * (1.0 - (1.0 - const_color[1].a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1) - (last_tex_env_out.aaa)), vec3(0), vec3(1)));
float alpha_output_2 = (texcolor1.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = byteround(clamp((secondary_fragment_color.ggg) * (const_color[3].rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_4 = byteround(clamp((rounded_primary_color.aaa) * (const_color[4].rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_4 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb), vec3(0), vec3(1)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: C3F52DFCA28D0604, 6AE6BDA06561AFE5
// program: 344AB4D45FEDDC9A, EADA2116091C5E01, 6AE6BDA06561AFE5
// shader: 8B30, 8A4ED6F49BB0A314
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))) + tex_lod_bias[2]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = 2.0 * (texcolor2).rgb - 1.0;
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(normal, normalize(view))));
refl_value.g = (lut_scale_rg * LookupLightingLUTSigned(5, dot(normal, normalize(view))));
refl_value.b = (lut_scale_rb * LookupLightingLUTSigned(4, dot(normal, normalize(view))));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.ggg) * (const_color[0].aaa), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((secondary_fragment_color.r) * (texcolor2.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
vec3 color_output_1 = byteround(clamp((texcolor0.rgb) * (const_color[1].rgb), vec3(0), vec3(1)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (1.0 - const_color[1].a) + (secondary_fragment_color.b) * (1.0 - (1.0 - const_color[1].a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_2 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1) - (last_tex_env_out.aaa)), vec3(0), vec3(1)));
float alpha_output_2 = (texcolor0.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = byteround(clamp((secondary_fragment_color.ggg) * (last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_3 = byteround(clamp((rounded_primary_color.a) * (1.0 - combiner_buffer.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1) - (last_tex_env_out.aaa)), vec3(0), vec3(1)));
float alpha_output_4 = (texcolor1.a);
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb), vec3(0), vec3(1)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
if (last_tex_env_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 06D2E7A34AF782AA, 8A4ED6F49BB0A314
// program: 344AB4D45FEDDC9A, EADA2116091C5E01, 8A4ED6F49BB0A314
// shader: 8B30, 333023FE25AF3950
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))) + tex_lod_bias[2]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = 2.0 * (texcolor2).rgb - 1.0;
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(normal, normalize(view))));
refl_value.g = (lut_scale_rg * LookupLightingLUTSigned(5, dot(normal, normalize(view))));
refl_value.b = (lut_scale_rb * LookupLightingLUTSigned(4, dot(normal, normalize(view))));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((secondary_fragment_color.r) * (1.0 - const_color[0].a) + (secondary_fragment_color.b) * (1.0 - (1.0 - const_color[0].a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1) - (last_tex_env_out.aaa)), vec3(0), vec3(1)));
float alpha_output_1 = (texcolor0.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = byteround(clamp((secondary_fragment_color.ggg) * (const_color[2].rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = byteround(clamp((rounded_primary_color.aaa) * (const_color[3].rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_3 = (texcolor1.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb), vec3(0), vec3(1)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: A228BC735118CB19, 333023FE25AF3950
// program: 344AB4D45FEDDC9A, EADA2116091C5E01, 333023FE25AF3950
// shader: 8B30, 7BD9DD75396B6EAD
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position + view);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tex_env_out.rgb;
combiner_buffer = next_combiner_buffer;
if (last_tex_env_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D400B5FD23E92077, 7BD9DD75396B6EAD
// program: 625982782CCD0D7B, F777123A8C3D5E20, 7BD9DD75396B6EAD
// shader: 8B30, B69FA15109672E1C
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position + view);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = 1.0;
refl_value.g = refl_value.r;
refl_value.b = refl_value.r;
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
primary_fragment_color = clamp(diffuse_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = (last_tex_env_out.rgb);
float alpha_output_2 = byteround(clamp((last_tex_env_out.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((last_tex_env_out.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
next_combiner_buffer.rgb = last_tex_env_out.rgb;
combiner_buffer = next_combiner_buffer;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: E39350DC23E92077, B69FA15109672E1C
// program: 625982782CCD0D7B, F777123A8C3D5E20, B69FA15109672E1C
// shader: 8B30, 8D56B0D64926E396
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))) + tex_lod_bias[2]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = 2.0 * (texcolor2).rgb - 1.0;
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(normal, normalize(view))));
refl_value.g = (lut_scale_rg * LookupLightingLUTSigned(5, dot(normal, normalize(view))));
refl_value.b = (lut_scale_rb * LookupLightingLUTSigned(4, dot(normal, normalize(view))));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((secondary_fragment_color.r) * (1.0 - const_color[0].a) + (secondary_fragment_color.b) * (1.0 - (1.0 - const_color[0].a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1) - (last_tex_env_out.aaa)), vec3(0), vec3(1)));
float alpha_output_1 = (texcolor0.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = byteround(clamp((secondary_fragment_color.ggg) * (const_color[2].rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = (last_tex_env_out.rgb);
float alpha_output_3 = byteround(clamp((texcolor1.a) * (texcolor2.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb), vec3(0), vec3(1)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
if (last_tex_env_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 3461C8D7ED0F20C3, 8D56B0D64926E396
// program: 344AB4D45FEDDC9A, EADA2116091C5E01, 8D56B0D64926E396
// shader: 8B30, 289527836A86E733
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))) + tex_lod_bias[2]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = 2.0 * (texcolor2).rgb - 1.0;
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(normal, normalize(view))));
refl_value.g = (lut_scale_rg * LookupLightingLUTSigned(5, dot(normal, normalize(view))));
refl_value.b = (lut_scale_rb * LookupLightingLUTSigned(4, dot(normal, normalize(view))));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor1.rgb) * (vec3(1) - const_color[0].aaa) + (const_color[0].rgb) * (vec3(1) - (vec3(1) - const_color[0].aaa)), vec3(0), vec3(1)));
float alpha_output_0 = (texcolor1.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
next_combiner_buffer.rgb = last_tex_env_out.rgb;
vec3 color_output_1 = byteround(clamp((texcolor0.rgb) + (last_tex_env_out.rgb) - vec3(0.5), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (combiner_buffer.rgb) - vec3(0.5), vec3(0), vec3(1)));
float alpha_output_2 = byteround(clamp((secondary_fragment_color.r) * (1.0 - const_color[2].a) + (secondary_fragment_color.b) * (1.0 - (1.0 - const_color[2].a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1) - (last_tex_env_out.aaa)), vec3(0), vec3(1)));
float alpha_output_3 = byteround(clamp((texcolor1.a) * (texcolor2.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_4 = byteround(clamp((secondary_fragment_color.ggg) * (last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_4 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb), vec3(0), vec3(1)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
if (last_tex_env_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: F7B1CB7F02F050F5, 289527836A86E733
// program: 344AB4D45FEDDC9A, EADA2116091C5E01, 289527836A86E733
// shader: 8B30, 1BA140846BAC988F
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))) + tex_lod_bias[2]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((vec3(1) - texcolor0.rrr) - (vec3(1) - texcolor1.rrr), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((1.0 - texcolor0.r) - (1.0 - texcolor2.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0 * 4.0, alpha_output_0 * 4.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) + (last_tex_env_out.aaa), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1 * 4.0, alpha_output_1 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2 * 4.0, alpha_output_2 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = byteround(clamp(min((last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(1)) * (vec3(1) - texcolor0.rrr), vec3(0), vec3(1)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_4 = byteround(clamp((vec3(1) - last_tex_env_out.rgb) + (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_4 = byteround(clamp((1.0 - last_tex_env_out.r) + (const_color[4].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_5 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_5 = (rounded_primary_color.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D891887BC44673CD, 1BA140846BAC988F
// program: 0000000000000000, 0000000000000000, 1BA140846BAC988F
// shader: 8B30, 8C312B5A648CFC68
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))) + tex_lod_bias[2]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((vec3(1) - texcolor0.rrr) - (vec3(1) - texcolor1.rrr), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((1.0 - texcolor0.r) - (1.0 - texcolor2.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0 * 4.0, alpha_output_0 * 4.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) + (last_tex_env_out.aaa), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1 * 4.0, alpha_output_1 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2 * 4.0, alpha_output_2 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = byteround(clamp(min((last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(1)) * (vec3(1) - texcolor0.rrr), vec3(0), vec3(1)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_4 = byteround(clamp((vec3(1) - last_tex_env_out.rgb) + (primary_fragment_color.rgb), vec3(0), vec3(1)));
float alpha_output_4 = byteround(clamp((1.0 - last_tex_env_out.r) + (const_color[4].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_5 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_5 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 22837F6D3F987EC5, 8C312B5A648CFC68
// program: 0000000000000000, 0000000000000000, 8C312B5A648CFC68
// shader: 8B30, 19A2BB30F658ACB8
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = (const_color[0].a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
if (last_tex_env_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: F33C1B80F9A18CC3, 19A2BB30F658ACB8
// program: 85A5116CCB32BF2A, F777123A8C3D5E20, 19A2BB30F658ACB8
// reference: C00F400223E92077, FD29673C2E307195
// shader: 8B31, C9A4CA31273244A0

#define mul_s(x, y) (x * y)
#define fma_s(x, y, z) fma(x, y, z)
#define dot_s(x, y) dot(x, y)
#define dot_3(x, y) dot(x, y)

#define rcp_s(x) (1.0 / x)
#define rsq_s(x) inversesqrt(x)

#define min_s(x, y) min(x, y)
#define max_s(x, y) max(x, y)

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout(binding=2, std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location=0) in vec4 vs_in_reg0;
layout(location=1) in vec4 vs_in_reg1;
layout(location=2) in vec4 vs_in_reg2;
layout(location=4) in vec4 vs_in_reg4;
layout(location=5) in vec4 vs_in_reg5;
layout(location=6) in vec4 vs_in_reg6;
layout(location=7) in vec4 vs_in_reg7;
layout(location=8) in vec4 vs_in_reg8;

layout(location=0) out vec4 vs_out_attr0;
layout(location=1) out vec4 vs_out_attr1;
layout(location=2) out vec4 vs_out_attr2;
layout(location=3) out vec4 vs_out_attr3;
layout(location=4) out vec4 vs_out_attr4;
layout(location=5) out vec4 vs_out_attr5;
layout(location=6) out vec4 vs_out_attr6;

void main() {
vs_out_attr0 = vec4(0, 0, 0, 1);
vs_out_attr1 = vec4(0, 0, 0, 1);
vs_out_attr2 = vec4(0, 0, 0, 1);
vs_out_attr3 = vec4(0, 0, 0, 1);
vs_out_attr4 = vec4(0, 0, 0, 1);
vs_out_attr5 = vec4(0, 0, 0, 1);
vs_out_attr6 = vec4(0, 0, 0, 1);
exec_shader();
}
bvec2 bool_regs = bvec2(false);
ivec3 addr_regs = ivec3(0);
vec4 reg_tmp0 = vec4(0, 0, 0, 1);
vec4 reg_tmp1 = vec4(0, 0, 0, 1);
vec4 reg_tmp2 = vec4(0, 0, 0, 1);
vec4 reg_tmp3 = vec4(0, 0, 0, 1);
vec4 reg_tmp4 = vec4(0, 0, 0, 1);
vec4 reg_tmp5 = vec4(0, 0, 0, 1);
vec4 reg_tmp6 = vec4(0, 0, 0, 1);
vec4 reg_tmp7 = vec4(0, 0, 0, 1);
vec4 reg_tmp8 = vec4(0, 0, 0, 1);
vec4 reg_tmp9 = vec4(0, 0, 0, 1);
vec4 reg_tmp10 = vec4(0, 0, 0, 1);
vec4 reg_tmp11 = vec4(0, 0, 0, 1);
vec4 reg_tmp12 = vec4(0, 0, 0, 1);
vec4 reg_tmp13 = vec4(0, 0, 0, 1);
vec4 reg_tmp14 = vec4(0, 0, 0, 1);
vec4 reg_tmp15 = vec4(0, 0, 0, 1);

bool sub_0();
bool sub_21();
bool sub_4();
bool sub_9();
bool sub_1();
bool sub_2();
bool sub_3();
bool sub_5();
bool sub_7();
bool sub_8();
bool sub_10();
bool sub_20();
bool sub_22();
bool sub_23();
bool sub_24();
bool sub_25();
bool sub_26();
bool sub_27();
bool sub_28();
bool sub_29();
bool sub_30();
bool sub_31();
bool sub_6();
bool sub_11();
bool sub_12();
bool sub_13();
bool sub_14();
bool sub_15();
bool sub_16();
bool sub_17();
bool sub_18();
bool sub_19();
bool sub_32();
bool sub_33();
bool sub_34();
bool sub_40();
bool sub_41();
bool sub_42();
bool sub_43();
bool sub_45();
bool sub_35();
bool sub_36();
bool sub_37();
bool sub_38();
bool sub_39();
bool sub_44();
bool sub_46();
bool sub_47();
bool sub_48();
bool sub_49();
bool sub_50();
bool sub_51();
bool sub_52();
bool sub_53();
bool sub_54();
bool sub_55();
bool sub_56();
bool sub_57();
bool sub_58();

bool exec_shader() {
sub_0();
return true;
}

bool sub_0() {
sub_1();
sub_32();
sub_33();
sub_47();
sub_54();
return true;
}
bool sub_21() {
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp3.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp3.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp3.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
return false;
}
bool sub_4() {
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp3.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp3.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp3.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp4.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
return false;
}
bool sub_9() {
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp3.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp3.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp3.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp4.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp5.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp5.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp5.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
reg_tmp11 = fma_s(reg_tmp1.wwww, reg_tmp5, reg_tmp11);
return false;
}
bool sub_1() {
reg_tmp15.xyz = (mul_s(uniforms.f[7].xxxx, vs_in_reg0)).xyz;
reg_tmp14.xyz = (mul_s(uniforms.f[7].yyyy, vs_in_reg1)).xyz;
reg_tmp13.xyz = (mul_s(uniforms.f[7].zzzz, vs_in_reg2)).xyz;
reg_tmp15.xyz = (uniforms.f[6] + reg_tmp15).xyz;
reg_tmp15.w = (uniforms.f[93].yyyy).w;
if (uniforms.b[1]) {
sub_2();
} else {
sub_24();
}
return false;
}
bool sub_2() {
reg_tmp0 = uniforms.f[7];
bool_regs = notEqual(uniforms.f[93].xx, reg_tmp0.yz);
reg_tmp7 = uniforms.f[93].xxxx;
reg_tmp12 = uniforms.f[93].xxxx;
reg_tmp11 = uniforms.f[93].xxxx;
reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_3();
} else {
sub_7();
}
vs_out_attr2 = -reg_tmp15;
reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
reg_tmp1.x = (-reg_tmp0.wwww).x;
reg_tmp1.y = (mul_s(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
bool_regs.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
bool_regs.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
if (all(bool_regs)) {
sub_23();
}
vs_out_attr0 = reg_tmp0;
return false;
}
bool sub_3() {
bool_regs = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
reg_tmp1.xy = (reg_tmp2.xxxx).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
sub_4();
reg_tmp1.xy = (reg_tmp2.yyyy).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
sub_4();
reg_tmp1.xy = (reg_tmp2.zzzz).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
if (bool_regs.x) {
sub_4();
}
if (uniforms.b[8]) {
sub_5();
}
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
sub_6();
return false;
}
bool sub_5() {
reg_tmp1.xy = (reg_tmp2.wwww).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
if (bool_regs.y) {
sub_4();
}
return false;
}
bool sub_7() {
if (all(bool_regs)) {
sub_8();
} else {
sub_20();
}
return false;
}
bool sub_8() {
bool_regs = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
reg_tmp1.xy = (reg_tmp2.xxxx).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
sub_9();
reg_tmp1.xy = (reg_tmp2.yyyy).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
sub_9();
reg_tmp1.xy = (reg_tmp2.zzzz).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
if (bool_regs.x) {
sub_9();
}
if (uniforms.b[8]) {
sub_10();
}
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp13.x = dot_3(uniforms.f[3].xyz, reg_tmp11.xyz);
reg_tmp13.y = dot_3(uniforms.f[4].xyz, reg_tmp11.xyz);
reg_tmp13.z = dot_3(uniforms.f[5].xyz, reg_tmp11.xyz);
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
sub_11();
return false;
}
bool sub_10() {
reg_tmp1.xy = (reg_tmp2.wwww).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
if (bool_regs.y) {
sub_9();
}
return false;
}
bool sub_20() {
bool_regs = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
reg_tmp1.xy = (reg_tmp2.xxxx).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
sub_21();
reg_tmp1.xy = (reg_tmp2.yyyy).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
sub_21();
reg_tmp1.xy = (reg_tmp2.zzzz).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
if (bool_regs.x) {
sub_21();
}
if (uniforms.b[8]) {
sub_22();
}
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
vs_out_attr1 = uniforms.f[93].xxxx;
return false;
}
bool sub_22() {
reg_tmp1.xy = (reg_tmp2.wwww).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
if (bool_regs.y) {
sub_21();
}
return false;
}
bool sub_23() {
reg_tmp0.x = (-reg_tmp0.wwww).x;
return false;
}
bool sub_24() {
reg_tmp0 = uniforms.f[7];
bool_regs = notEqual(uniforms.f[93].xx, reg_tmp0.yz);
if (uniforms.b[2]) {
sub_25();
} else {
sub_26();
}
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_27();
} else {
sub_28();
}
vs_out_attr2 = -reg_tmp15;
reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
reg_tmp1.x = (-reg_tmp0.wwww).x;
reg_tmp1.y = (mul_s(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
bool_regs.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
bool_regs.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
if (all(bool_regs)) {
sub_31();
}
vs_out_attr0 = reg_tmp0;
return false;
}
bool sub_25() {
reg_tmp1.x = (mul_s(uniforms.f[93].wwww, vs_in_reg7.xxxx)).x;
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp7.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp7.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp7.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
return false;
}
bool sub_26() {
addr_regs.x = (ivec2(uniforms.f[93].xx)).x;
reg_tmp10.x = dot_s(uniforms.f[25], reg_tmp15);
reg_tmp10.y = dot_s(uniforms.f[26], reg_tmp15);
reg_tmp10.z = dot_s(uniforms.f[27], reg_tmp15);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
return false;
}
bool sub_27() {
reg_tmp12.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
sub_6();
return false;
}
bool sub_28() {
if (all(bool_regs)) {
sub_29();
} else {
sub_30();
}
return false;
}
bool sub_29() {
reg_tmp12.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp11.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp11.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp11.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
reg_tmp13.x = dot_3(uniforms.f[3].xyz, reg_tmp11.xyz);
reg_tmp13.y = dot_3(uniforms.f[4].xyz, reg_tmp11.xyz);
reg_tmp13.z = dot_3(uniforms.f[5].xyz, reg_tmp11.xyz);
sub_11();
return false;
}
bool sub_30() {
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
vs_out_attr1 = uniforms.f[93].xxxx;
return false;
}
bool sub_31() {
reg_tmp0.x = (-reg_tmp0.wwww).x;
return false;
}
bool sub_6() {
uint jmp_to = 214u;
while (true) {
switch (jmp_to) {
case 214u:
reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
reg_tmp6.x = rsq_s(reg_tmp6.x);
reg_tmp7.x = rsq_s(reg_tmp7.x);
reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp0 = uniforms.f[93].yxxx;
if (!uniforms.b[15]) {
jmp_to = 230u; break;
}
reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
reg_tmp4 = mul_s(uniforms.f[94].zzzz, reg_tmp4);
bool_regs = greaterThanEqual(uniforms.f[93].xx, reg_tmp4.xx);
reg_tmp4 = vec4(rsq_s(reg_tmp4.x));
reg_tmp5 = mul_s(uniforms.f[94].zzzz, reg_tmp14);
if (bool_regs.x) {
jmp_to = 230u; break;
}
reg_tmp0.z = rcp_s(reg_tmp4.x);
reg_tmp0.xy = (mul_s(reg_tmp5, reg_tmp4)).xy;
case 230u:
vs_out_attr1 = reg_tmp0;
default: return false;
}
}
return false;
}
bool sub_11() {
uint jmp_to = 231u;
while (true) {
switch (jmp_to) {
case 231u:
reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
reg_tmp6.x = rsq_s(reg_tmp6.x);
reg_tmp7.x = rsq_s(reg_tmp7.x);
reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp13.xyz = (mul_s(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp11.xyz = (mul_s(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp0 = uniforms.f[93].yxxx;
if (!uniforms.b[15]) {
jmp_to = 306u; break;
}
reg_tmp13.xyz = (mul_s(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp11.xyz = (mul_s(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp5 = mul_s(reg_tmp14.yzxx, reg_tmp13.zxyy);
reg_tmp5 = fma_s(-reg_tmp13.yzxx, reg_tmp14.zxyy, reg_tmp5);
reg_tmp5.w = dot_3(reg_tmp5.xyz, reg_tmp5.xyz);
reg_tmp5.w = rsq_s(reg_tmp5.w);
reg_tmp5 = mul_s(reg_tmp5, reg_tmp5.wwww);
reg_tmp6.w = (reg_tmp14.zzzz + reg_tmp5.yyyy).w;
reg_tmp13 = mul_s(reg_tmp5.yzxx, reg_tmp14.zxyy);
reg_tmp13 = fma_s(-reg_tmp14.yzxx, reg_tmp5.zxyy, reg_tmp13);
reg_tmp6.w = (reg_tmp13.xxxx + reg_tmp6).w;
reg_tmp13.w = (reg_tmp5.zzzz).w;
reg_tmp5.z = (reg_tmp13.xxxx).z;
reg_tmp6.w = (uniforms.f[93].yyyy + reg_tmp6).w;
reg_tmp14.w = (reg_tmp5.xxxx).w;
reg_tmp5.x = (reg_tmp14.zzzz).x;
bool_regs = lessThan(uniforms.f[94].yy, reg_tmp6.ww);
reg_tmp6.x = (uniforms.f[93].yyyy).x;
reg_tmp6.y = (-uniforms.f[93].yyyy).y;
if (!bool_regs.x) {
jmp_to = 268u; break;
}
reg_tmp7.xz = (reg_tmp13.wwyy + -reg_tmp14.yyww).xz;
reg_tmp7.y = (reg_tmp14.xxxx + -reg_tmp13.zzzz).y;
reg_tmp7.w = (reg_tmp6).w;
reg_tmp6 = vec4(dot_s(reg_tmp7, reg_tmp7));
reg_tmp6 = vec4(rsq_s(reg_tmp6.x));
reg_tmp0 = mul_s(reg_tmp7, reg_tmp6);
if (uniforms.b[0]) {
jmp_to = 306u; break;
}
case 268u:
bool_regs = greaterThan(reg_tmp5.zy, reg_tmp5.yx);
if (bool_regs.x) {
sub_12();
} else {
sub_17();
}
reg_tmp6 = vec4(dot_s(reg_tmp8, reg_tmp8));
reg_tmp6 = vec4(rsq_s(reg_tmp6.x));
reg_tmp0 = mul_s(reg_tmp8, reg_tmp6);
case 306u:
vs_out_attr1 = reg_tmp0;
default: return false;
}
}
return false;
}
bool sub_12() {
if (bool_regs.y) {
sub_13();
} else {
sub_14();
}
reg_tmp8.w = (-reg_tmp8).w;
return false;
}
bool sub_13() {
reg_tmp8 = mul_s(reg_tmp13.yyzw, reg_tmp6.xxxy);
reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
return false;
}
bool sub_14() {
bool_regs = greaterThan(reg_tmp5.zz, reg_tmp5.xx);
reg_tmp8 = mul_s(reg_tmp13.yyzw, reg_tmp6.xxxy);
reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
if (bool_regs.x) {
sub_15();
} else {
sub_16();
}
return false;
}
bool sub_15() {
reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
return false;
}
bool sub_16() {
reg_tmp8 = mul_s(reg_tmp13.zwwy, reg_tmp6.xxxy);
reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
return false;
}
bool sub_17() {
if (bool_regs.y) {
sub_18();
} else {
sub_19();
}
return false;
}
bool sub_18() {
reg_tmp8 = mul_s(reg_tmp13.yywz, reg_tmp6.xxxy);
reg_tmp8.y = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).y;
reg_tmp9 = reg_tmp5.yyyy + -reg_tmp5.xxxx;
reg_tmp8.xzw = (reg_tmp8 + reg_tmp14.wwyx).xzw;
reg_tmp8.y = (reg_tmp9 + reg_tmp8).y;
return false;
}
bool sub_19() {
reg_tmp8 = mul_s(reg_tmp13.zwwy, reg_tmp6.xxxy);
reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
reg_tmp8.w = (-reg_tmp8).w;
return false;
}
bool sub_32() {
reg_tmp1.xyz = (uniforms.f[93].xxyx).xyz;
reg_tmp8.x = dot_3(uniforms.f[0].xyz, reg_tmp12.xyz);
reg_tmp8.y = dot_3(uniforms.f[1].xyz, reg_tmp12.xyz);
reg_tmp8.z = dot_3(uniforms.f[2].xyz, reg_tmp12.xyz);
reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp8.xyz);
reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp8.xyz);
reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp8.xyz);
reg_tmp14.w = (uniforms.f[93].xxxx).w;
reg_tmp8 = reg_tmp14;
reg_tmp14.x = dot_s(reg_tmp8, reg_tmp8);
reg_tmp14.x = rsq_s(reg_tmp14.x);
reg_tmp14 = mul_s(reg_tmp8, reg_tmp14.xxxx);
reg_tmp0 = uniforms.f[23];
reg_tmp8.x = dot_3(uniforms.f[0].xyz, reg_tmp0.xyz);
reg_tmp8.y = dot_3(uniforms.f[1].xyz, reg_tmp0.xyz);
reg_tmp8.z = dot_3(uniforms.f[2].xyz, reg_tmp0.xyz);
reg_tmp6.x = dot_3(uniforms.f[90].xyz, reg_tmp8.xyz);
reg_tmp6.y = dot_3(uniforms.f[91].xyz, reg_tmp8.xyz);
reg_tmp6.z = dot_3(uniforms.f[92].xyz, reg_tmp8.xyz);
reg_tmp8.xyz = (reg_tmp6.xyzz + reg_tmp1.xyzz).xyz;
reg_tmp8.w = (uniforms.f[93].xxxx).w;
reg_tmp0.x = dot_s(reg_tmp8, reg_tmp8);
reg_tmp0.x = rsq_s(reg_tmp0.x);
reg_tmp0 = mul_s(reg_tmp8, reg_tmp0.xxxx);
reg_tmp8.x = dot_3(reg_tmp14.xyz, -reg_tmp6.xyz);
reg_tmp8.y = dot_3(reg_tmp1.xyz, -reg_tmp6.xyz);
reg_tmp8 = max_s(uniforms.f[93].xxxx, reg_tmp8);
reg_tmp2.y = (mul_s(reg_tmp8.xxxx, reg_tmp8.yyyy)).y;
reg_tmp9.z = dot_3(reg_tmp14.xyz, reg_tmp0.xyz);
reg_tmp9.z = (max_s(uniforms.f[93].xxxx, reg_tmp9.zzzz)).z;
reg_tmp9.z = (min_s(uniforms.f[93].yyyy, reg_tmp9.zzzz)).z;
reg_tmp9.z = log2(reg_tmp9.z);
reg_tmp9.z = (mul_s(uniforms.f[22].zzzz, reg_tmp9.zzzz)).z;
reg_tmp9.z = exp2(reg_tmp9.z);
reg_tmp2.z = (mul_s(uniforms.f[22].wwww, reg_tmp9.zzzz)).z;
reg_tmp9.x = dot_3(reg_tmp14.xyz, reg_tmp1.xyz);
reg_tmp9.x = (max_s(uniforms.f[93].xxxx, reg_tmp9.xxxx)).x;
reg_tmp9.x = (min_s(uniforms.f[93].yyyy, reg_tmp9.xxxx)).x;
reg_tmp9.x = (uniforms.f[93].yyyy + -reg_tmp9.xxxx).x;
reg_tmp9.x = log2(reg_tmp9.x);
reg_tmp9.x = (mul_s(uniforms.f[22].xxxx, reg_tmp9.xxxx)).x;
reg_tmp9.x = exp2(reg_tmp9.x);
reg_tmp2.w = (mul_s(uniforms.f[22].yyyy, reg_tmp9.xxxx)).w;
vs_out_attr3 = reg_tmp2;
return false;
}
bool sub_33() {
reg_tmp0.xy = (uniforms.f[10].xxxx).xy;
if (uniforms.b[9]) {
sub_34();
} else {
sub_40();
}
return false;
}
bool sub_34() {
sub_35();
reg_tmp3.x = dot_s(uniforms.f[11].xywz, reg_tmp6);
reg_tmp3.y = dot_s(uniforms.f[12].xywz, reg_tmp6);
reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
vs_out_attr4 = reg_tmp3;
return false;
}
bool sub_40() {
bool_regs = equal(uniforms.f[95].xy, reg_tmp0.xy);
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
if (all(not(bool_regs))) {
sub_41();
} else {
sub_42();
}
vs_out_attr4 = reg_tmp3;
return false;
}
bool sub_41() {
reg_tmp6 = reg_tmp10;
reg_tmp3.x = dot_s(uniforms.f[11], reg_tmp6);
reg_tmp3.y = dot_s(uniforms.f[12], reg_tmp6);
reg_tmp3.z = dot_s(uniforms.f[13], reg_tmp6);
reg_tmp0.xy = (mul_s(uniforms.f[19].xyyy, reg_tmp3.zzzz)).xy;
reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
return false;
}
bool sub_42() {
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_43();
} else {
sub_45();
}
return false;
}
bool sub_43() {
sub_44();
reg_tmp3.x = dot_3(uniforms.f[11].xyz, reg_tmp6.xyz);
reg_tmp3.y = dot_3(uniforms.f[12].xyz, reg_tmp6.xyz);
reg_tmp3.z = dot_3(uniforms.f[13].xyz, reg_tmp6.xyz);
return false;
}
bool sub_45() {
sub_46();
reg_tmp3.x = dot_s(uniforms.f[11], reg_tmp6);
reg_tmp3.y = dot_s(uniforms.f[12], reg_tmp6);
return false;
}
bool sub_35() {
bool_regs = equal(uniforms.f[93].yz, reg_tmp0.xy);
if (all(not(bool_regs))) {
sub_36();
} else {
sub_37();
}
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
return false;
}
bool sub_36() {
reg_tmp6.xy = (mul_s(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
return false;
}
bool sub_37() {
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_38();
} else {
sub_39();
}
return false;
}
bool sub_38() {
reg_tmp6.xy = (mul_s(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
return false;
}
bool sub_39() {
reg_tmp6.xy = (mul_s(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
return false;
}
bool sub_44() {
reg_tmp2 = -reg_tmp15;
reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
reg_tmp2.w = rsq_s(reg_tmp2.w);
reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
reg_tmp1 = reg_tmp1 + reg_tmp1;
reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
return false;
}
bool sub_46() {
reg_tmp1.xy = (uniforms.f[94].zzzz).xy;
reg_tmp1.zw = (uniforms.f[93].xxxx).zw;
reg_tmp6 = fma_s(reg_tmp14, reg_tmp1, reg_tmp1);
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
return false;
}
bool sub_47() {
reg_tmp0.xy = (uniforms.f[10].yyyy).xy;
if (uniforms.b[10]) {
sub_48();
} else {
sub_49();
}
return false;
}
bool sub_48() {
sub_35();
reg_tmp4.x = dot_s(uniforms.f[14].xywz, reg_tmp6);
reg_tmp4.y = dot_s(uniforms.f[15].xywz, reg_tmp6);
vs_out_attr5 = reg_tmp4;
return false;
}
bool sub_49() {
if (uniforms.b[13]) {
sub_50();
} else {
sub_53();
}
return false;
}
bool sub_50() {
bool_regs = equal(uniforms.f[95].xy, reg_tmp0.xy);
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
if (all(not(bool_regs))) {
sub_51();
} else {
sub_52();
}
vs_out_attr5 = reg_tmp4;
return false;
}
bool sub_51() {
reg_tmp6 = reg_tmp10;
reg_tmp4.x = dot_s(uniforms.f[14], reg_tmp6);
reg_tmp4.y = dot_s(uniforms.f[15], reg_tmp6);
reg_tmp4.z = dot_s(uniforms.f[16], reg_tmp6);
reg_tmp6.w = rcp_s(reg_tmp4.z);
reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
reg_tmp4.xy = (uniforms.f[19].zwww + reg_tmp4.xyyy).xy;
return false;
}
bool sub_52() {
sub_46();
reg_tmp4.x = dot_s(uniforms.f[14], reg_tmp6);
reg_tmp4.y = dot_s(uniforms.f[15], reg_tmp6);
return false;
}
bool sub_53() {
vs_out_attr5 = uniforms.f[93].xxxx;
return false;
}
bool sub_54() {
reg_tmp0.xy = (uniforms.f[10].zzzz).xy;
if (uniforms.b[11]) {
sub_55();
} else {
sub_56();
}
return false;
}
bool sub_55() {
sub_35();
reg_tmp5.x = dot_s(uniforms.f[17].xywz, reg_tmp6);
reg_tmp5.y = dot_s(uniforms.f[18].xywz, reg_tmp6);
vs_out_attr6 = reg_tmp5;
return false;
}
bool sub_56() {
if (uniforms.b[14]) {
sub_57();
} else {
sub_58();
}
return false;
}
bool sub_57() {
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
reg_tmp5.zw = (reg_tmp6.zwww).zw;
sub_46();
reg_tmp5.x = dot_s(uniforms.f[17], reg_tmp6);
reg_tmp5.y = dot_s(uniforms.f[18], reg_tmp6);
vs_out_attr6 = reg_tmp5;
return false;
}
bool sub_58() {
vs_out_attr6 = uniforms.f[93].xxxx;
return false;
}
// reference: 0358855A330BFB49, C9A4CA31273244A0
// shader: 8B30, B18B4F8E8E479EBB
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);

vec4 diffuse_sum = vec4(0, 0, 0, 1);
vec4 specular_sum = vec4(0, 0, 0, 1);
vec3 light_vector = vec3(0);
vec3 refl_value = vec3(0);
vec3 spot_dir = vec3(0);
vec3 half_vector = vec3(0);
float dot_product = 0.0;
float clamp_highlights = 1.0;
float geo_factor = 1.0;
vec3 surface_normal = vec3(0, 0, 1);
vec3 surface_tangent = vec3(1, 0, 0);
vec4 normalized_normquat = normalize(normquat);
vec3 normal = QuaternionRotate(normalized_normquat, surface_normal);
vec3 tangent = QuaternionRotate(normalized_normquat, surface_tangent);
vec4 shadow = vec4(1);
light_vector = normalize(light_src[0].position);
spot_dir = light_src[0].spot_direction;
half_vector = normalize(view) + light_vector;
dot_product = max(dot(light_vector, normal), 0.0);
refl_value.r = (lut_scale_rr * LookupLightingLUTSigned(6, dot(light_vector, normal)));
refl_value.g = (lut_scale_rg * LookupLightingLUTSigned(5, dot(light_vector, normal)));
refl_value.b = (lut_scale_rb * LookupLightingLUTSigned(4, dot(light_vector, normal)));
diffuse_sum.rgb += ((light_src[0].diffuse * dot_product) + light_src[0].ambient) * 1.0;
specular_sum.rgb += ((light_src[0].specular_0) + (refl_value * light_src[0].specular_1)) * clamp_highlights * 1.0;
diffuse_sum.rgb += lighting_global_ambient;
secondary_fragment_color = clamp(specular_sum, vec4(0), vec4(1));
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (const_color[0].rgb), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((secondary_fragment_color.r) * (1.0 - const_color[0].a) + (secondary_fragment_color.b) * (1.0 - (1.0 - const_color[0].a)), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((texcolor0.rgb) * (last_tex_env_out.aaa) + (last_tex_env_out.rgb) * (vec3(1) - (last_tex_env_out.aaa)), vec3(0), vec3(1)));
float alpha_output_1 = (texcolor0.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = byteround(clamp((secondary_fragment_color.ggg) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (rounded_primary_color.aaa) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_4 = byteround(clamp((last_tex_env_out.rgb) - (texcolor1.rgb), vec3(0), vec3(1)));
float alpha_output_4 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb), vec3(0), vec3(1)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
if (last_tex_env_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: C0E603C85340B82B, B18B4F8E8E479EBB
// program: C9A4CA31273244A0, EADA2116091C5E01, B18B4F8E8E479EBB
// reference: E7FF40CE23E92077, FD29673C2E307195
// reference: 01539B5DB995C3B4, 2385CCAFF1B43030
// reference: 06D2E7A3E98574C8, 8A4ED6F49BB0A314
// reference: C3F52DFC01FFF066, 6AE6BDA06561AFE5
// reference: E39350DC809BD615, B69FA15109672E1C
// reference: 3461C8D74E7DD6A1, 8D56B0D64926E396
// reference: F7B1CB7FA182A697, 289527836A86E733
// reference: D400B5FD809BD615, 7BD9DD75396B6EAD
// reference: C0E603C8F0324E49, B18B4F8E8E479EBB
// shader: 8B31, DB0B4C6763B81C5A

#define mul_s(x, y) mix(x * y, vec4(0), isnan(x * y))
#define mul_3(x, y) mix(x * y, vec3(0), isnan(x * y))
#define fma_s(x, y, z) (mul_s(x, y) + z)
#define dot_s(x, y) dot(mul_s(x, y), vec4(1))
#define dot_3(x, y) dot(mul_3(x, y), vec3(1))

float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x == 0.0) return x;
    return inversesqrt(x);
}

#define min_s(x, y) min(x, y)
#define max_s(x, y) max(x, y)

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout(binding=2, std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location=0) in vec4 vs_in_reg0;
layout(location=3) in vec4 vs_in_reg3;
layout(location=4) in vec4 vs_in_reg4;
layout(location=5) in vec4 vs_in_reg5;
layout(location=6) in vec4 vs_in_reg6;

layout(location=0) out vec4 vs_out_attr0;
layout(location=1) out vec4 vs_out_attr1;
layout(location=2) out vec4 vs_out_attr2;
layout(location=3) out vec4 vs_out_attr3;
layout(location=4) out vec4 vs_out_attr4;
layout(location=5) out vec4 vs_out_attr5;
layout(location=6) out vec4 vs_out_attr6;

void main() {
vs_out_attr0 = vec4(0, 0, 0, 1);
vs_out_attr1 = vec4(0, 0, 0, 1);
vs_out_attr2 = vec4(0, 0, 0, 1);
vs_out_attr3 = vec4(0, 0, 0, 1);
vs_out_attr4 = vec4(0, 0, 0, 1);
vs_out_attr5 = vec4(0, 0, 0, 1);
vs_out_attr6 = vec4(0, 0, 0, 1);
exec_shader();
}
bvec2 bool_regs = bvec2(false);
ivec3 addr_regs = ivec3(0);
vec4 reg_tmp0 = vec4(0, 0, 0, 1);
vec4 reg_tmp1 = vec4(0, 0, 0, 1);
vec4 reg_tmp2 = vec4(0, 0, 0, 1);
vec4 reg_tmp3 = vec4(0, 0, 0, 1);
vec4 reg_tmp4 = vec4(0, 0, 0, 1);
vec4 reg_tmp5 = vec4(0, 0, 0, 1);
vec4 reg_tmp6 = vec4(0, 0, 0, 1);
vec4 reg_tmp7 = vec4(0, 0, 0, 1);
vec4 reg_tmp8 = vec4(0, 0, 0, 1);
vec4 reg_tmp9 = vec4(0, 0, 0, 1);
vec4 reg_tmp10 = vec4(0, 0, 0, 1);
vec4 reg_tmp11 = vec4(0, 0, 0, 1);
vec4 reg_tmp12 = vec4(0, 0, 0, 1);
vec4 reg_tmp13 = vec4(0, 0, 0, 1);
vec4 reg_tmp14 = vec4(0, 0, 0, 1);
vec4 reg_tmp15 = vec4(0, 0, 0, 1);

bool sub_0();
bool sub_1();
bool sub_2();
bool sub_3();
bool sub_15();
bool sub_4();
bool sub_5();
bool sub_6();
bool sub_7();
bool sub_8();
bool sub_9();
bool sub_10();
bool sub_11();
bool sub_12();
bool sub_13();
bool sub_14();
bool sub_16();
bool sub_17();
bool sub_23();
bool sub_24();
bool sub_25();
bool sub_26();
bool sub_28();
bool sub_18();
bool sub_19();
bool sub_20();
bool sub_21();
bool sub_22();
bool sub_27();
bool sub_29();
bool sub_30();
bool sub_31();
bool sub_32();
bool sub_33();
bool sub_34();
bool sub_35();
bool sub_36();
bool sub_37();
bool sub_38();
bool sub_39();
bool sub_40();
bool sub_41();

bool exec_shader() {
sub_0();
return true;
}

bool sub_0() {
reg_tmp0 = vs_in_reg0;
vs_out_attr0 = reg_tmp0;
vs_out_attr2 = reg_tmp0;
vs_out_attr1 = reg_tmp0;
sub_1();
sub_16();
sub_30();
sub_37();
return true;
}
bool sub_1() {
reg_tmp8.xy = (uniforms.f[93].xxxx).xy;
reg_tmp0.y = (uniforms.f[7].wwww).y;
bool_regs = notEqual(uniforms.f[93].xx, reg_tmp0.xy);
reg_tmp9.xyz = (uniforms.f[93].xxxx).xyz;
reg_tmp9.w = (uniforms.f[21].wwww).w;
if (bool_regs.y) {
sub_2();
}
if (uniforms.b[12]) {
sub_4();
}
if (uniforms.b[5]) {
sub_13();
}
bool_regs = equal(uniforms.f[93].xx, reg_tmp8.xy);
if (all(bool_regs)) {
sub_15();
}
reg_tmp9 = uniforms.f[74] + reg_tmp9;
vs_out_attr3 = max_s(uniforms.f[93].xxxx, reg_tmp9);
return false;
}
bool sub_2() {
reg_tmp0 = mul_s(uniforms.f[7].wwww, vs_in_reg3);
if (uniforms.b[7]) {
sub_3();
}
reg_tmp9.xyz = (mul_s(uniforms.f[20].wwww, reg_tmp0.xyzz)).xyz;
reg_tmp8.x = (uniforms.f[93].yyyy).x;
return false;
}
bool sub_3() {
reg_tmp9.w = (mul_s(reg_tmp9.wwww, reg_tmp0.wwww)).w;
return false;
}
bool sub_15() {
reg_tmp9 = uniforms.f[21];
return false;
}
bool sub_4() {
reg_tmp1 = uniforms.f[20];
reg_tmp2 = uniforms.f[21];
reg_tmp3 = uniforms.f[93].xxxx;
addr_regs.z = int(uniforms.i[0].y);
for (uint i = 0u; i <= uniforms.i[0].x; addr_regs.z += int(uniforms.i[0].z), ++i) {
sub_5();
}
reg_tmp8.x = (uniforms.f[93].yyyy).x;
return false;
}
bool sub_5() {
addr_regs.x = (ivec2(reg_tmp3.xy)).x;
reg_tmp4.x = (uniforms.f[69 + addr_regs.x].wwww).x;
reg_tmp4.y = (uniforms.f[71 + addr_regs.x].wwww).y;
bool_regs = equal(uniforms.f[93].xy, reg_tmp4.xy);
if (bool_regs.x) {
sub_6();
} else {
sub_7();
}
bool_regs.x = uniforms.f[93].xxxx.x == reg_tmp6.xyyy.x;
bool_regs.y = uniforms.f[93].xxxx.y < reg_tmp6.xyyy.y;
if (bool_regs.y) {
sub_12();
}
reg_tmp3 = -uniforms.f[95].wwww + reg_tmp3;
return false;
}
bool sub_6() {
reg_tmp6.x = dot_3(uniforms.f[69 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp6.y = (uniforms.f[93].yyyy).y;
return false;
}
bool sub_7() {
reg_tmp4 = uniforms.f[69 + addr_regs.x] + -reg_tmp15;
reg_tmp6.y = (uniforms.f[93].yyyy).y;
if (bool_regs.y) {
sub_8();
}
reg_tmp5 = uniforms.f[70 + addr_regs.x];
bool_regs = equal(uniforms.f[93].yy, reg_tmp5.ww);
reg_tmp4.w = dot_3(reg_tmp4.xyz, reg_tmp4.xyz);
reg_tmp4.w = rsq_s(reg_tmp4.w);
reg_tmp4 = mul_s(reg_tmp4, reg_tmp4.wwww);
if (bool_regs.x) {
sub_9();
}
reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp4.xyz);
return false;
}
bool sub_8() {
reg_tmp5.x = (uniforms.f[93].yyyy).x;
reg_tmp5.z = dot_3(reg_tmp4.xyz, reg_tmp4.xyz);
reg_tmp5.y = (mul_s(reg_tmp5.zzzz, reg_tmp5.zzzz)).y;
reg_tmp6.y = dot_3(uniforms.f[71 + addr_regs.x].xyz, reg_tmp5.xyz);
reg_tmp6.y = rcp_s(reg_tmp6.y);
return false;
}
bool sub_9() {
reg_tmp5.x = dot_3(uniforms.f[70 + addr_regs.x].xyz, -reg_tmp4.xyz);
reg_tmp5.y = (vec4(lessThan(reg_tmp5.xxxx, uniforms.f[72 + addr_regs.x].yyyy))).y;
bool_regs = equal(uniforms.f[93].yy, reg_tmp5.xy);
if (bool_regs.y) {
sub_10();
} else {
sub_11();
}
reg_tmp6.y = (mul_s(reg_tmp6.yyyy, reg_tmp5.xxxx)).y;
return false;
}
bool sub_10() {
reg_tmp5.x = (uniforms.f[93].xxxx).x;
return false;
}
bool sub_11() {
reg_tmp5.y = log2(reg_tmp5.x);
reg_tmp5.y = (mul_s(uniforms.f[72 + addr_regs.x].xxxx, reg_tmp5.yyyy)).y;
reg_tmp5.x = exp2(reg_tmp5.y);
return false;
}
bool sub_12() {
reg_tmp6.x = (max_s(uniforms.f[93].xxxx, reg_tmp6.xxxx)).x;
reg_tmp9.xyz = (fma_s(reg_tmp1.xyzz, uniforms.f[67 + addr_regs.x].xyzz, reg_tmp9.xyzz)).xyz;
reg_tmp4 = mul_s(uniforms.f[68 + addr_regs.x], reg_tmp2);
reg_tmp5.xyz = (mul_s(reg_tmp6.xxxx, reg_tmp4.xyzz)).xyz;
reg_tmp5.xyz = (mul_s(reg_tmp6.yyyy, reg_tmp5.xyzz)).xyz;
reg_tmp9.xyz = (reg_tmp9.xyzz + reg_tmp5.xyzz).xyz;
reg_tmp9.w = (reg_tmp9.wwww + reg_tmp4.wwww).w;
return false;
}
bool sub_13() {
reg_tmp1 = vec4(dot_3(uniforms.f[24].xyz, reg_tmp14.xyz));
reg_tmp2 = uniforms.f[24].wwww;
reg_tmp1 = fma_s(reg_tmp1, reg_tmp2, reg_tmp2);
reg_tmp3 = uniforms.f[22];
reg_tmp2 = uniforms.f[23] + -reg_tmp3;
reg_tmp4 = fma_s(reg_tmp2, reg_tmp1, reg_tmp3);
if (uniforms.b[6]) {
sub_14();
}
reg_tmp9.xyz = (fma_s(reg_tmp4, uniforms.f[21], reg_tmp9)).xyz;
reg_tmp8.x = (uniforms.f[93].yyyy).x;
return false;
}
bool sub_14() {
reg_tmp4 = mul_s(reg_tmp4, reg_tmp9.wwww);
return false;
}
bool sub_16() {
reg_tmp0.xy = (uniforms.f[10].xxxx).xy;
if (uniforms.b[9]) {
sub_17();
} else {
sub_23();
}
return false;
}
bool sub_17() {
sub_18();
reg_tmp3.x = dot_s(uniforms.f[11].xywz, reg_tmp6);
reg_tmp3.y = dot_s(uniforms.f[12].xywz, reg_tmp6);
reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
vs_out_attr4 = reg_tmp3;
return false;
}
bool sub_23() {
bool_regs = equal(uniforms.f[95].xy, reg_tmp0.xy);
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
if (all(not(bool_regs))) {
sub_24();
} else {
sub_25();
}
vs_out_attr4 = reg_tmp3;
return false;
}
bool sub_24() {
reg_tmp6 = reg_tmp10;
reg_tmp3.x = dot_s(uniforms.f[11], reg_tmp6);
reg_tmp3.y = dot_s(uniforms.f[12], reg_tmp6);
reg_tmp3.z = dot_s(uniforms.f[13], reg_tmp6);
reg_tmp0.xy = (mul_s(uniforms.f[19].xyyy, reg_tmp3.zzzz)).xy;
reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
return false;
}
bool sub_25() {
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_26();
} else {
sub_28();
}
return false;
}
bool sub_26() {
sub_27();
reg_tmp3.x = dot_3(uniforms.f[11].xyz, reg_tmp6.xyz);
reg_tmp3.y = dot_3(uniforms.f[12].xyz, reg_tmp6.xyz);
reg_tmp3.z = dot_3(uniforms.f[13].xyz, reg_tmp6.xyz);
return false;
}
bool sub_28() {
sub_29();
reg_tmp3.x = dot_s(uniforms.f[11], reg_tmp6);
reg_tmp3.y = dot_s(uniforms.f[12], reg_tmp6);
return false;
}
bool sub_18() {
bool_regs = equal(uniforms.f[93].yz, reg_tmp0.xy);
if (all(not(bool_regs))) {
sub_19();
} else {
sub_20();
}
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
return false;
}
bool sub_19() {
reg_tmp6.xy = (mul_s(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
return false;
}
bool sub_20() {
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_21();
} else {
sub_22();
}
return false;
}
bool sub_21() {
reg_tmp6.xy = (mul_s(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
return false;
}
bool sub_22() {
reg_tmp6.xy = (mul_s(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
return false;
}
bool sub_27() {
reg_tmp2 = -reg_tmp15;
reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
reg_tmp2.w = rsq_s(reg_tmp2.w);
reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
reg_tmp1 = reg_tmp1 + reg_tmp1;
reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
return false;
}
bool sub_29() {
reg_tmp1.xy = (uniforms.f[94].zzzz).xy;
reg_tmp1.zw = (uniforms.f[93].xxxx).zw;
reg_tmp6 = fma_s(reg_tmp14, reg_tmp1, reg_tmp1);
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
return false;
}
bool sub_30() {
reg_tmp0.xy = (uniforms.f[10].yyyy).xy;
if (uniforms.b[10]) {
sub_31();
} else {
sub_32();
}
return false;
}
bool sub_31() {
sub_18();
reg_tmp4.x = dot_s(uniforms.f[14].xywz, reg_tmp6);
reg_tmp4.y = dot_s(uniforms.f[15].xywz, reg_tmp6);
vs_out_attr5 = reg_tmp4;
return false;
}
bool sub_32() {
if (uniforms.b[13]) {
sub_33();
} else {
sub_36();
}
return false;
}
bool sub_33() {
bool_regs = equal(uniforms.f[95].xy, reg_tmp0.xy);
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
if (all(not(bool_regs))) {
sub_34();
} else {
sub_35();
}
vs_out_attr5 = reg_tmp4;
return false;
}
bool sub_34() {
reg_tmp6 = reg_tmp10;
reg_tmp4.x = dot_s(uniforms.f[14], reg_tmp6);
reg_tmp4.y = dot_s(uniforms.f[15], reg_tmp6);
reg_tmp4.z = dot_s(uniforms.f[16], reg_tmp6);
reg_tmp6.w = rcp_s(reg_tmp4.z);
reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
reg_tmp4.xy = (uniforms.f[19].zwww + reg_tmp4.xyyy).xy;
return false;
}
bool sub_35() {
sub_29();
reg_tmp4.x = dot_s(uniforms.f[14], reg_tmp6);
reg_tmp4.y = dot_s(uniforms.f[15], reg_tmp6);
return false;
}
bool sub_36() {
vs_out_attr5 = uniforms.f[93].xxxx;
return false;
}
bool sub_37() {
reg_tmp0.xy = (uniforms.f[10].zzzz).xy;
if (uniforms.b[11]) {
sub_38();
} else {
sub_39();
}
return false;
}
bool sub_38() {
sub_18();
reg_tmp5.x = dot_s(uniforms.f[17].xywz, reg_tmp6);
reg_tmp5.y = dot_s(uniforms.f[18].xywz, reg_tmp6);
vs_out_attr6 = reg_tmp5;
return false;
}
bool sub_39() {
if (uniforms.b[14]) {
sub_40();
} else {
sub_41();
}
return false;
}
bool sub_40() {
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
reg_tmp5.zw = (reg_tmp6.zwww).zw;
sub_29();
reg_tmp5.x = dot_s(uniforms.f[17], reg_tmp6);
reg_tmp5.y = dot_s(uniforms.f[18], reg_tmp6);
vs_out_attr6 = reg_tmp5;
return false;
}
bool sub_41() {
vs_out_attr6 = uniforms.f[93].xxxx;
return false;
}
// reference: 96A413AC243C7C5A, DB0B4C6763B81C5A
// program: DB0B4C6763B81C5A, EADA2116091C5E01, 95B8E534AADF3E9E
// program: DB0B4C6763B81C5A, EADA2116091C5E01, 85D1E0630696A9D8
// program: DB0B4C6763B81C5A, EADA2116091C5E01, 4E49D908F8986C97
// shader: 8B31, 4DBF54CC7897BA20

#define mul_s(x, y) mix(x * y, vec4(0), isnan(x * y))
#define mul_3(x, y) mix(x * y, vec3(0), isnan(x * y))
#define fma_s(x, y, z) (mul_s(x, y) + z)
#define dot_s(x, y) dot(mul_s(x, y), vec4(1))
#define dot_3(x, y) dot(mul_3(x, y), vec3(1))

float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x == 0.0) return x;
    return inversesqrt(x);
}

#define min_s(x, y) min(x, y)
#define max_s(x, y) max(x, y)

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout(binding=2, std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location=0) in vec4 vs_in_reg0;

layout(location=0) out vec4 vs_out_attr0;
layout(location=1) out vec4 vs_out_attr1;
layout(location=2) out vec4 vs_out_attr2;
layout(location=3) out vec4 vs_out_attr3;
layout(location=4) out vec4 vs_out_attr4;

void main() {
vs_out_attr0 = vec4(0, 0, 0, 1);
vs_out_attr1 = vec4(0, 0, 0, 1);
vs_out_attr2 = vec4(0, 0, 0, 1);
vs_out_attr3 = vec4(0, 0, 0, 1);
vs_out_attr4 = vec4(0, 0, 0, 1);
exec_shader();
}
bvec2 bool_regs = bvec2(false);
ivec3 addr_regs = ivec3(0);
vec4 reg_tmp0 = vec4(0, 0, 0, 1);
vec4 reg_tmp1 = vec4(0, 0, 0, 1);
vec4 reg_tmp2 = vec4(0, 0, 0, 1);
vec4 reg_tmp3 = vec4(0, 0, 0, 1);
vec4 reg_tmp4 = vec4(0, 0, 0, 1);
vec4 reg_tmp5 = vec4(0, 0, 0, 1);
vec4 reg_tmp6 = vec4(0, 0, 0, 1);
vec4 reg_tmp7 = vec4(0, 0, 0, 1);
vec4 reg_tmp8 = vec4(0, 0, 0, 1);
vec4 reg_tmp9 = vec4(0, 0, 0, 1);
vec4 reg_tmp10 = vec4(0, 0, 0, 1);
vec4 reg_tmp11 = vec4(0, 0, 0, 1);
vec4 reg_tmp12 = vec4(0, 0, 0, 1);
vec4 reg_tmp13 = vec4(0, 0, 0, 1);
vec4 reg_tmp14 = vec4(0, 0, 0, 1);
vec4 reg_tmp15 = vec4(0, 0, 0, 1);

bool sub_0();
bool sub_1();
bool sub_2();
bool sub_3();
bool sub_4();
bool sub_5();
bool sub_6();
bool sub_7();
bool sub_8();
bool sub_9();
bool sub_10();
bool sub_11();
bool sub_12();
bool sub_13();
bool sub_14();
bool sub_15();
bool sub_16();
bool sub_17();
bool sub_18();
bool sub_19();
bool sub_20();

bool exec_shader() {
sub_0();
return true;
}

bool sub_0() {
addr_regs.x = (ivec2(vs_in_reg0.xy)).x;
reg_tmp0 = uniforms.f[6 + addr_regs.x].wzyx;
reg_tmp1.xy = (vs_in_reg0.zwzw).xy;
reg_tmp1.zw = (uniforms.f[5].xyxy).zw;
addr_regs.xy = ivec2(reg_tmp0.xy);
reg_tmp2.xw = (uniforms.f[64 + addr_regs.y].wwyy).xw;
reg_tmp2.yz = (uniforms.f[5].xxxx).yz;
reg_tmp4.x = dot_s(reg_tmp1, reg_tmp2);
reg_tmp2.yw = (uniforms.f[64 + addr_regs.y].zzxx).yw;
reg_tmp2.xz = (uniforms.f[5].xxxx).xz;
reg_tmp4.y = dot_s(reg_tmp1, reg_tmp2);
reg_tmp4.zw = (reg_tmp1.zwzw).zw;
reg_tmp3.x = dot_s(uniforms.f[32 + addr_regs.x].wzyx, reg_tmp4);
reg_tmp3.y = dot_s(uniforms.f[33 + addr_regs.x].wzyx, reg_tmp4);
reg_tmp3.z = dot_s(uniforms.f[34 + addr_regs.x].wzyx, reg_tmp4);
reg_tmp3.w = (reg_tmp1.wwww).w;
reg_tmp4.z = (uniforms.f[34 + addr_regs.x].xxxx).z;
reg_tmp4.z = (abs(reg_tmp4.zzzz)).z;
reg_tmp4.z = (uniforms.f[4].yyyy + reg_tmp4.zzzz).z;
reg_tmp4.x = (uniforms.f[4].wwww).x;
bool_regs = notEqual(uniforms.f[5].xx, reg_tmp4.xz);
if (all(bool_regs)) {
sub_1();
}
vs_out_attr0.x = dot_s(uniforms.f[0].wzyx, reg_tmp3);
vs_out_attr0.y = dot_s(uniforms.f[1].wzyx, reg_tmp3);
vs_out_attr0.z = dot_s(uniforms.f[2].wzyx, reg_tmp3);
vs_out_attr0.w = dot_s(uniforms.f[3].wzyx, reg_tmp3);
bool_regs = greaterThanEqual(uniforms.f[5].yy, reg_tmp0.ww);
if (all(bool_regs)) {
sub_2();
} else {
sub_3();
}
bool_regs = notEqual(uniforms.f[5].xx, reg_tmp1.xy);
if (all(not(bool_regs))) {
sub_8();
}
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_9();
}
if (all(bvec2(!bool_regs.x, bool_regs.y))) {
sub_10();
}
if (all(bool_regs)) {
sub_11();
}
reg_tmp8 = uniforms.f[5].xxxx;
addr_regs.z = int(uniforms.i[0].y);
for (uint i = 0u; i <= uniforms.i[0].x; addr_regs.z += int(uniforms.i[0].z), ++i) {
sub_12();
}
vs_out_attr2 = reg_tmp5;
vs_out_attr3 = reg_tmp6;
vs_out_attr4 = reg_tmp7;
return true;
}
bool sub_1() {
reg_tmp4.x = (uniforms.f[4].wwww).x;
reg_tmp4.y = (-uniforms.f[4].zzzz + reg_tmp4.zzzz).y;
reg_tmp4.z = rcp_s(reg_tmp4.z);
reg_tmp4.z = (mul_s(reg_tmp4.yyyy, reg_tmp4.zzzz)).z;
reg_tmp3.x = (fma_s(reg_tmp4.xxxx, reg_tmp4.zzzz, reg_tmp3.xxxx)).x;
return false;
}
bool sub_2() {
vs_out_attr1.xyz = (uniforms.f[5].yyyy).xyz;
vs_out_attr1.w = (reg_tmp0.wwww).w;
return false;
}
bool sub_3() {
addr_regs.y = (ivec2(reg_tmp0.ww)).y;
bool_regs = notEqual(uniforms.f[5].xx, reg_tmp1.xy);
if (all(not(bool_regs))) {
sub_4();
}
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_5();
}
if (all(bvec2(!bool_regs.x, bool_regs.y))) {
sub_6();
}
if (all(bool_regs)) {
sub_7();
}
return false;
}
bool sub_4() {
vs_out_attr1 = uniforms.f[32 + addr_regs.y].wzyx;
return false;
}
bool sub_5() {
vs_out_attr1 = uniforms.f[33 + addr_regs.y].wzyx;
return false;
}
bool sub_6() {
vs_out_attr1 = uniforms.f[34 + addr_regs.y].wzyx;
return false;
}
bool sub_7() {
vs_out_attr1 = uniforms.f[35 + addr_regs.y].wzyx;
return false;
}
bool sub_8() {
reg_tmp5 = uniforms.f[5].xyyy;
reg_tmp6 = uniforms.f[5].xyyy;
reg_tmp7 = uniforms.f[5].xyyy;
return false;
}
bool sub_9() {
reg_tmp5 = uniforms.f[5].yyyy;
reg_tmp6 = uniforms.f[5].yyyy;
reg_tmp7 = uniforms.f[5].yyyy;
return false;
}
bool sub_10() {
reg_tmp5 = uniforms.f[5].xxyy;
reg_tmp6 = uniforms.f[5].xxyy;
reg_tmp7 = uniforms.f[5].xxyy;
return false;
}
bool sub_11() {
reg_tmp5 = uniforms.f[5].yxyy;
reg_tmp6 = uniforms.f[5].yxyy;
reg_tmp7 = uniforms.f[5].yxyy;
return false;
}
bool sub_12() {
bool_regs = equal(uniforms.f[5].yy, reg_tmp8.xy);
if (all(bool_regs)) {
sub_13();
}
bool_regs = lessThan(uniforms.f[5].ww, reg_tmp8.xy);
if (all(bool_regs)) {
sub_18();
}
reg_tmp8 = uniforms.f[5].yyyy + reg_tmp8;
return false;
}
bool sub_13() {
addr_regs.y = (ivec2(reg_tmp0.zz)).y;
bool_regs = notEqual(uniforms.f[5].xx, reg_tmp1.xy);
if (all(not(bool_regs))) {
sub_14();
}
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_15();
}
if (all(bvec2(!bool_regs.x, bool_regs.y))) {
sub_16();
}
if (all(bool_regs)) {
sub_17();
}
return false;
}
bool sub_14() {
reg_tmp5.xy = (uniforms.f[64 + addr_regs.y].wzzz).xy;
reg_tmp6.xy = (uniforms.f[65 + addr_regs.y].wzzz).xy;
reg_tmp7.xy = (uniforms.f[66 + addr_regs.y].wzzz).xy;
return false;
}
bool sub_15() {
reg_tmp5.xy = (uniforms.f[64 + addr_regs.y].yzzz).xy;
reg_tmp6.xy = (uniforms.f[65 + addr_regs.y].yzzz).xy;
reg_tmp7.xy = (uniforms.f[66 + addr_regs.y].yzzz).xy;
return false;
}
bool sub_16() {
reg_tmp5.xy = (uniforms.f[64 + addr_regs.y].wxxx).xy;
reg_tmp6.xy = (uniforms.f[65 + addr_regs.y].wxxx).xy;
reg_tmp7.xy = (uniforms.f[66 + addr_regs.y].wxxx).xy;
return false;
}
bool sub_17() {
reg_tmp5.xy = (uniforms.f[64 + addr_regs.y].yxxx).xy;
reg_tmp6.xy = (uniforms.f[65 + addr_regs.y].yxxx).xy;
reg_tmp7.xy = (uniforms.f[66 + addr_regs.y].yxxx).xy;
return false;
}
bool sub_18() {
bool_regs = notEqual(uniforms.f[5].xx, reg_tmp1.xy);
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_19();
}
if (all(bvec2(!bool_regs.x, bool_regs.y))) {
sub_20();
}
return false;
}
bool sub_19() {
reg_tmp5.xy = (uniforms.f[67 + addr_regs.y].yxxx).xy;
reg_tmp6.xy = (uniforms.f[68 + addr_regs.y].yxxx).xy;
reg_tmp7.xy = (uniforms.f[69 + addr_regs.y].yxxx).xy;
return false;
}
bool sub_20() {
reg_tmp5.xy = (uniforms.f[67 + addr_regs.y].wzzz).xy;
reg_tmp6.xy = (uniforms.f[68 + addr_regs.y].wzzz).xy;
reg_tmp7.xy = (uniforms.f[69 + addr_regs.y].wzzz).xy;
return false;
}
// reference: 456A7DE63ADA30CF, 4DBF54CC7897BA20
// program: 4DBF54CC7897BA20, B6B95AFD9466EC70, 10BF65E8D1BE0D7D
// program: 4DBF54CC7897BA20, B6B95AFD9466EC70, 863363E2F8C23DC0
// shader: 8B31, 1C4FF6A809801458

#define mul_s(x, y) mix(x * y, vec4(0), isnan(x * y))
#define mul_3(x, y) mix(x * y, vec3(0), isnan(x * y))
#define fma_s(x, y, z) (mul_s(x, y) + z)
#define dot_s(x, y) dot(mul_s(x, y), vec4(1))
#define dot_3(x, y) dot(mul_3(x, y), vec3(1))

float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x == 0.0) return x;
    return inversesqrt(x);
}

#define min_s(x, y) min(x, y)
#define max_s(x, y) max(x, y)

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout(binding=2, std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location=0) in vec4 vs_in_reg0;
layout(location=1) in vec4 vs_in_reg1;
layout(location=3) in vec4 vs_in_reg3;
layout(location=4) in vec4 vs_in_reg4;
layout(location=5) in vec4 vs_in_reg5;
layout(location=6) in vec4 vs_in_reg6;
layout(location=7) in vec4 vs_in_reg7;
layout(location=8) in vec4 vs_in_reg8;

layout(location=0) out vec4 vs_out_attr0;
layout(location=1) out vec4 vs_out_attr1;
layout(location=2) out vec4 vs_out_attr2;
layout(location=3) out vec4 vs_out_attr3;
layout(location=4) out vec4 vs_out_attr4;
layout(location=5) out vec4 vs_out_attr5;

void main() {
vs_out_attr0 = vec4(0, 0, 0, 1);
vs_out_attr1 = vec4(0, 0, 0, 1);
vs_out_attr2 = vec4(0, 0, 0, 1);
vs_out_attr3 = vec4(0, 0, 0, 1);
vs_out_attr4 = vec4(0, 0, 0, 1);
vs_out_attr5 = vec4(0, 0, 0, 1);
exec_shader();
}
bvec2 bool_regs = bvec2(false);
ivec3 addr_regs = ivec3(0);
vec4 reg_tmp0 = vec4(0, 0, 0, 1);
vec4 reg_tmp1 = vec4(0, 0, 0, 1);
vec4 reg_tmp2 = vec4(0, 0, 0, 1);
vec4 reg_tmp3 = vec4(0, 0, 0, 1);
vec4 reg_tmp4 = vec4(0, 0, 0, 1);
vec4 reg_tmp5 = vec4(0, 0, 0, 1);
vec4 reg_tmp6 = vec4(0, 0, 0, 1);
vec4 reg_tmp7 = vec4(0, 0, 0, 1);
vec4 reg_tmp8 = vec4(0, 0, 0, 1);
vec4 reg_tmp9 = vec4(0, 0, 0, 1);
vec4 reg_tmp10 = vec4(0, 0, 0, 1);
vec4 reg_tmp11 = vec4(0, 0, 0, 1);
vec4 reg_tmp12 = vec4(0, 0, 0, 1);
vec4 reg_tmp13 = vec4(0, 0, 0, 1);
vec4 reg_tmp14 = vec4(0, 0, 0, 1);
vec4 reg_tmp15 = vec4(0, 0, 0, 1);

bool sub_0();
bool sub_11();
bool sub_4();
bool sub_8();
bool sub_1();
bool sub_2();
bool sub_3();
bool sub_5();
bool sub_6();
bool sub_7();
bool sub_9();
bool sub_10();
bool sub_12();
bool sub_13();
bool sub_14();
bool sub_15();
bool sub_16();
bool sub_17();
bool sub_18();
bool sub_19();
bool sub_20();
bool sub_21();
bool sub_22();
bool sub_23();
bool sub_24();
bool sub_36();
bool sub_25();
bool sub_26();
bool sub_27();
bool sub_28();
bool sub_29();
bool sub_30();
bool sub_31();
bool sub_32();
bool sub_33();
bool sub_34();
bool sub_35();
bool sub_37();
bool sub_38();
bool sub_39();
bool sub_45();
bool sub_46();
bool sub_47();
bool sub_48();
bool sub_50();
bool sub_40();
bool sub_41();
bool sub_42();
bool sub_43();
bool sub_44();
bool sub_49();

bool exec_shader() {
sub_0();
return true;
}

bool sub_0() {
sub_1();
sub_22();
sub_37();
sub_38();
return true;
}
bool sub_11() {
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp3.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp3.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp3.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
return false;
}
bool sub_4() {
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp3.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp3.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp3.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp4.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
return false;
}
bool sub_8() {
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp3.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp3.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp3.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp4.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
return false;
}
bool sub_1() {
reg_tmp15.xyz = (mul_s(uniforms.f[7].xxxx, vs_in_reg0)).xyz;
reg_tmp14.xyz = (mul_s(uniforms.f[7].yyyy, vs_in_reg1)).xyz;
reg_tmp15.xyz = (uniforms.f[6] + reg_tmp15).xyz;
reg_tmp15.w = (uniforms.f[93].yyyy).w;
if (uniforms.b[1]) {
sub_2();
} else {
sub_14();
}
vs_out_attr1 = uniforms.f[93].xxxx;
vs_out_attr2 = uniforms.f[93].xxxx;
return false;
}
bool sub_2() {
reg_tmp0 = uniforms.f[7];
bool_regs = notEqual(uniforms.f[93].xx, reg_tmp0.yz);
reg_tmp7 = uniforms.f[93].xxxx;
reg_tmp12 = uniforms.f[93].xxxx;
reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_3();
} else {
sub_6();
}
reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
reg_tmp1.x = (-reg_tmp0.wwww).x;
reg_tmp1.y = (mul_s(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
bool_regs.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
bool_regs.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
if (all(bool_regs)) {
sub_13();
}
vs_out_attr0 = reg_tmp0;
return false;
}
bool sub_3() {
bool_regs = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
reg_tmp1.xy = (reg_tmp2.xxxx).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
sub_4();
reg_tmp1.xy = (reg_tmp2.yyyy).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
sub_4();
reg_tmp1.xy = (reg_tmp2.zzzz).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
if (bool_regs.x) {
sub_4();
}
if (uniforms.b[8]) {
sub_5();
}
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
return false;
}
bool sub_5() {
reg_tmp1.xy = (reg_tmp2.wwww).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
if (bool_regs.y) {
sub_4();
}
return false;
}
bool sub_6() {
if (all(bool_regs)) {
sub_7();
} else {
sub_10();
}
return false;
}
bool sub_7() {
bool_regs = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
reg_tmp1.xy = (reg_tmp2.xxxx).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
sub_8();
reg_tmp1.xy = (reg_tmp2.yyyy).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
sub_8();
reg_tmp1.xy = (reg_tmp2.zzzz).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
if (bool_regs.x) {
sub_8();
}
if (uniforms.b[8]) {
sub_9();
}
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
return false;
}
bool sub_9() {
reg_tmp1.xy = (reg_tmp2.wwww).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
if (bool_regs.y) {
sub_8();
}
return false;
}
bool sub_10() {
bool_regs = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
reg_tmp1.xy = (reg_tmp2.xxxx).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
sub_11();
reg_tmp1.xy = (reg_tmp2.yyyy).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
sub_11();
reg_tmp1.xy = (reg_tmp2.zzzz).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
if (bool_regs.x) {
sub_11();
}
if (uniforms.b[8]) {
sub_12();
}
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
return false;
}
bool sub_12() {
reg_tmp1.xy = (reg_tmp2.wwww).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
if (bool_regs.y) {
sub_11();
}
return false;
}
bool sub_13() {
reg_tmp0.x = (-reg_tmp0.wwww).x;
return false;
}
bool sub_14() {
reg_tmp0 = uniforms.f[7];
bool_regs = notEqual(uniforms.f[93].xx, reg_tmp0.yz);
if (uniforms.b[2]) {
sub_15();
} else {
sub_16();
}
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_17();
} else {
sub_18();
}
reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
reg_tmp1.x = (-reg_tmp0.wwww).x;
reg_tmp1.y = (mul_s(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
bool_regs.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
bool_regs.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
if (all(bool_regs)) {
sub_21();
}
vs_out_attr0 = reg_tmp0;
return false;
}
bool sub_15() {
reg_tmp1.x = (mul_s(uniforms.f[93].wwww, vs_in_reg7.xxxx)).x;
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp7.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp7.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp7.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
return false;
}
bool sub_16() {
addr_regs.x = (ivec2(uniforms.f[93].xx)).x;
reg_tmp10.x = dot_s(uniforms.f[25], reg_tmp15);
reg_tmp10.y = dot_s(uniforms.f[26], reg_tmp15);
reg_tmp10.z = dot_s(uniforms.f[27], reg_tmp15);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
return false;
}
bool sub_17() {
reg_tmp12.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
return false;
}
bool sub_18() {
if (all(bool_regs)) {
sub_19();
} else {
sub_20();
}
return false;
}
bool sub_19() {
reg_tmp12.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
return false;
}
bool sub_20() {
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
return false;
}
bool sub_21() {
reg_tmp0.x = (-reg_tmp0.wwww).x;
return false;
}
bool sub_22() {
reg_tmp8.xy = (uniforms.f[93].xxxx).xy;
reg_tmp0.y = (uniforms.f[7].wwww).y;
bool_regs = notEqual(uniforms.f[93].xx, reg_tmp0.xy);
reg_tmp9.xyz = (uniforms.f[93].xxxx).xyz;
reg_tmp9.w = (uniforms.f[21].wwww).w;
if (bool_regs.y) {
sub_23();
}
if (uniforms.b[12]) {
sub_25();
}
if (uniforms.b[5]) {
sub_34();
}
bool_regs = equal(uniforms.f[93].xx, reg_tmp8.xy);
if (all(bool_regs)) {
sub_36();
}
vs_out_attr3 = max_s(uniforms.f[93].xxxx, reg_tmp9);
return false;
}
bool sub_23() {
reg_tmp0 = mul_s(uniforms.f[7].wwww, vs_in_reg3);
if (uniforms.b[7]) {
sub_24();
}
reg_tmp9.xyz = (mul_s(uniforms.f[20].wwww, reg_tmp0.xyzz)).xyz;
reg_tmp8.x = (uniforms.f[93].yyyy).x;
return false;
}
bool sub_24() {
reg_tmp9.w = (mul_s(reg_tmp9.wwww, reg_tmp0.wwww)).w;
return false;
}
bool sub_36() {
reg_tmp9 = uniforms.f[21];
return false;
}
bool sub_25() {
reg_tmp1 = uniforms.f[20];
reg_tmp2 = uniforms.f[21];
reg_tmp3 = uniforms.f[93].xxxx;
addr_regs.z = int(uniforms.i[0].y);
for (uint i = 0u; i <= uniforms.i[0].x; addr_regs.z += int(uniforms.i[0].z), ++i) {
sub_26();
}
reg_tmp8.x = (uniforms.f[93].yyyy).x;
return false;
}
bool sub_26() {
addr_regs.x = (ivec2(reg_tmp3.xy)).x;
reg_tmp4.x = (uniforms.f[81 + addr_regs.x].wwww).x;
reg_tmp4.y = (uniforms.f[83 + addr_regs.x].wwww).y;
bool_regs = equal(uniforms.f[93].xy, reg_tmp4.xy);
if (bool_regs.x) {
sub_27();
} else {
sub_28();
}
bool_regs.x = uniforms.f[93].xxxx.x == reg_tmp6.xyyy.x;
bool_regs.y = uniforms.f[93].xxxx.y < reg_tmp6.xyyy.y;
if (bool_regs.y) {
sub_33();
}
reg_tmp3 = -uniforms.f[95].wwww + reg_tmp3;
return false;
}
bool sub_27() {
reg_tmp6.x = dot_3(uniforms.f[81 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp6.y = (uniforms.f[93].yyyy).y;
return false;
}
bool sub_28() {
reg_tmp4 = uniforms.f[81 + addr_regs.x] + -reg_tmp15;
reg_tmp6.y = (uniforms.f[93].yyyy).y;
if (bool_regs.y) {
sub_29();
}
reg_tmp5 = uniforms.f[82 + addr_regs.x];
bool_regs = equal(uniforms.f[93].yy, reg_tmp5.ww);
reg_tmp4.w = dot_3(reg_tmp4.xyz, reg_tmp4.xyz);
reg_tmp4.w = rsq_s(reg_tmp4.w);
reg_tmp4 = mul_s(reg_tmp4, reg_tmp4.wwww);
if (bool_regs.x) {
sub_30();
}
reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp4.xyz);
return false;
}
bool sub_29() {
reg_tmp5.x = (uniforms.f[93].yyyy).x;
reg_tmp5.z = dot_3(reg_tmp4.xyz, reg_tmp4.xyz);
reg_tmp5.y = (mul_s(reg_tmp5.zzzz, reg_tmp5.zzzz)).y;
reg_tmp6.y = dot_3(uniforms.f[83 + addr_regs.x].xyz, reg_tmp5.xyz);
reg_tmp6.y = rcp_s(reg_tmp6.y);
return false;
}
bool sub_30() {
reg_tmp5.x = dot_3(uniforms.f[82 + addr_regs.x].xyz, -reg_tmp4.xyz);
reg_tmp5.y = (vec4(lessThan(reg_tmp5.xxxx, uniforms.f[84 + addr_regs.x].yyyy))).y;
bool_regs = equal(uniforms.f[93].yy, reg_tmp5.xy);
if (bool_regs.y) {
sub_31();
} else {
sub_32();
}
reg_tmp6.y = (mul_s(reg_tmp6.yyyy, reg_tmp5.xxxx)).y;
return false;
}
bool sub_31() {
reg_tmp5.x = (uniforms.f[93].xxxx).x;
return false;
}
bool sub_32() {
reg_tmp5.y = log2(reg_tmp5.x);
reg_tmp5.y = (mul_s(uniforms.f[84 + addr_regs.x].xxxx, reg_tmp5.yyyy)).y;
reg_tmp5.x = exp2(reg_tmp5.y);
return false;
}
bool sub_33() {
reg_tmp6.x = (max_s(uniforms.f[93].xxxx, reg_tmp6.xxxx)).x;
reg_tmp9.xyz = (fma_s(reg_tmp1.xyzz, uniforms.f[79 + addr_regs.x].xyzz, reg_tmp9.xyzz)).xyz;
reg_tmp4 = mul_s(uniforms.f[80 + addr_regs.x], reg_tmp2);
reg_tmp5.xyz = (mul_s(reg_tmp6.xxxx, reg_tmp4.xyzz)).xyz;
reg_tmp5.xyz = (mul_s(reg_tmp6.yyyy, reg_tmp5.xyzz)).xyz;
reg_tmp9.xyz = (reg_tmp9.xyzz + reg_tmp5.xyzz).xyz;
reg_tmp9.w = (reg_tmp9.wwww + reg_tmp4.wwww).w;
return false;
}
bool sub_34() {
reg_tmp1 = vec4(dot_3(uniforms.f[24].xyz, reg_tmp14.xyz));
reg_tmp2 = uniforms.f[24].wwww;
reg_tmp1 = fma_s(reg_tmp1, reg_tmp2, reg_tmp2);
reg_tmp3 = uniforms.f[22];
reg_tmp2 = uniforms.f[23] + -reg_tmp3;
reg_tmp4 = fma_s(reg_tmp2, reg_tmp1, reg_tmp3);
if (uniforms.b[6]) {
sub_35();
}
reg_tmp9.xyz = (fma_s(reg_tmp4, uniforms.f[21], reg_tmp9)).xyz;
reg_tmp8.x = (uniforms.f[93].yyyy).x;
return false;
}
bool sub_35() {
reg_tmp4 = mul_s(reg_tmp4, reg_tmp9.wwww);
return false;
}
bool sub_37() {
reg_tmp5.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
reg_tmp5.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
reg_tmp5.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
reg_tmp4.x = dot_s(reg_tmp5.xyzz, reg_tmp5.xyzz);
reg_tmp4.x = rsq_s(reg_tmp4.x);
reg_tmp4.xyz = (mul_s(reg_tmp5.xyzz, reg_tmp4.xxxx)).xyz;
reg_tmp4 = mul_s(uniforms.f[94].zzzz, reg_tmp4);
reg_tmp12 = uniforms.f[94].zzzz + reg_tmp4;
vs_out_attr4 = reg_tmp12;
return false;
}
bool sub_38() {
reg_tmp0.xy = (uniforms.f[10].yyyy).xy;
if (uniforms.b[10]) {
sub_39();
} else {
sub_45();
}
return false;
}
bool sub_39() {
sub_40();
reg_tmp4.x = dot_s(uniforms.f[14].xywz, reg_tmp6);
reg_tmp4.y = dot_s(uniforms.f[15].xywz, reg_tmp6);
vs_out_attr5 = reg_tmp4;
return false;
}
bool sub_45() {
if (uniforms.b[13]) {
sub_46();
} else {
sub_50();
}
return false;
}
bool sub_46() {
bool_regs = equal(uniforms.f[95].xy, reg_tmp0.xy);
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
if (all(not(bool_regs))) {
sub_47();
} else {
sub_48();
}
vs_out_attr5 = reg_tmp4;
return false;
}
bool sub_47() {
reg_tmp6 = reg_tmp10;
reg_tmp4.x = dot_s(uniforms.f[14], reg_tmp6);
reg_tmp4.y = dot_s(uniforms.f[15], reg_tmp6);
reg_tmp4.z = dot_s(uniforms.f[16], reg_tmp6);
reg_tmp6.w = rcp_s(reg_tmp4.z);
reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
reg_tmp4.xy = (uniforms.f[19].zwww + reg_tmp4.xyyy).xy;
return false;
}
bool sub_48() {
sub_49();
reg_tmp4.x = dot_s(uniforms.f[14], reg_tmp6);
reg_tmp4.y = dot_s(uniforms.f[15], reg_tmp6);
return false;
}
bool sub_50() {
vs_out_attr5 = uniforms.f[93].xxxx;
return false;
}
bool sub_40() {
bool_regs = equal(uniforms.f[93].yz, reg_tmp0.xy);
if (all(not(bool_regs))) {
sub_41();
} else {
sub_42();
}
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
return false;
}
bool sub_41() {
reg_tmp6.xy = (mul_s(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
return false;
}
bool sub_42() {
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_43();
} else {
sub_44();
}
return false;
}
bool sub_43() {
reg_tmp6.xy = (mul_s(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
return false;
}
bool sub_44() {
reg_tmp6.xy = (mul_s(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
return false;
}
bool sub_49() {
reg_tmp1.xy = (uniforms.f[94].zzzz).xy;
reg_tmp1.zw = (uniforms.f[93].xxxx).zw;
reg_tmp6 = fma_s(reg_tmp14, reg_tmp1, reg_tmp1);
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
return false;
}
// reference: C801BC2B50752CAE, 1C4FF6A809801458
// program: 1C4FF6A809801458, F777123A8C3D5E20, 47CB4E54EF5379E5
// program: 1C4FF6A809801458, F777123A8C3D5E20, 19A2BB30F658ACB8
// shader: 8B31, AEF4EEAE6F9585E0

#define mul_s(x, y) mix(x * y, vec4(0), isnan(x * y))
#define mul_3(x, y) mix(x * y, vec3(0), isnan(x * y))
#define fma_s(x, y, z) (mul_s(x, y) + z)
#define dot_s(x, y) dot(mul_s(x, y), vec4(1))
#define dot_3(x, y) dot(mul_3(x, y), vec3(1))

float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x == 0.0) return x;
    return inversesqrt(x);
}

#define min_s(x, y) min(x, y)
#define max_s(x, y) max(x, y)

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout(binding=2, std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location=0) in vec4 vs_in_reg0;
layout(location=1) in vec4 vs_in_reg1;
layout(location=2) in vec4 vs_in_reg2;
layout(location=3) in vec4 vs_in_reg3;
layout(location=4) in vec4 vs_in_reg4;
layout(location=5) in vec4 vs_in_reg5;
layout(location=6) in vec4 vs_in_reg6;
layout(location=7) in vec4 vs_in_reg7;
layout(location=8) in vec4 vs_in_reg8;

layout(location=0) out vec4 vs_out_attr0;
layout(location=1) out vec4 vs_out_attr1;
layout(location=2) out vec4 vs_out_attr2;
layout(location=3) out vec4 vs_out_attr3;
layout(location=4) out vec4 vs_out_attr4;
layout(location=5) out vec4 vs_out_attr5;

void main() {
vs_out_attr0 = vec4(0, 0, 0, 1);
vs_out_attr1 = vec4(0, 0, 0, 1);
vs_out_attr2 = vec4(0, 0, 0, 1);
vs_out_attr3 = vec4(0, 0, 0, 1);
vs_out_attr4 = vec4(0, 0, 0, 1);
vs_out_attr5 = vec4(0, 0, 0, 1);
exec_shader();
}
bvec2 bool_regs = bvec2(false);
ivec3 addr_regs = ivec3(0);
vec4 reg_tmp0 = vec4(0, 0, 0, 1);
vec4 reg_tmp1 = vec4(0, 0, 0, 1);
vec4 reg_tmp2 = vec4(0, 0, 0, 1);
vec4 reg_tmp3 = vec4(0, 0, 0, 1);
vec4 reg_tmp4 = vec4(0, 0, 0, 1);
vec4 reg_tmp5 = vec4(0, 0, 0, 1);
vec4 reg_tmp6 = vec4(0, 0, 0, 1);
vec4 reg_tmp7 = vec4(0, 0, 0, 1);
vec4 reg_tmp8 = vec4(0, 0, 0, 1);
vec4 reg_tmp9 = vec4(0, 0, 0, 1);
vec4 reg_tmp10 = vec4(0, 0, 0, 1);
vec4 reg_tmp11 = vec4(0, 0, 0, 1);
vec4 reg_tmp12 = vec4(0, 0, 0, 1);
vec4 reg_tmp13 = vec4(0, 0, 0, 1);
vec4 reg_tmp14 = vec4(0, 0, 0, 1);
vec4 reg_tmp15 = vec4(0, 0, 0, 1);

bool sub_0();
bool sub_30();
bool sub_31();
bool sub_32();
bool sub_33();
bool sub_34();
bool sub_35();
bool sub_36();
bool sub_37();
bool sub_38();
bool sub_39();
bool sub_40();
bool sub_41();
bool sub_42();
bool sub_21();
bool sub_4();
bool sub_9();
bool sub_1();
bool sub_2();
bool sub_3();
bool sub_5();
bool sub_7();
bool sub_8();
bool sub_10();
bool sub_20();
bool sub_22();
bool sub_23();
bool sub_24();
bool sub_25();
bool sub_26();
bool sub_27();
bool sub_28();
bool sub_29();
bool sub_6();
bool sub_11();
bool sub_12();
bool sub_13();
bool sub_14();
bool sub_15();
bool sub_16();
bool sub_17();
bool sub_18();
bool sub_19();

bool exec_shader() {
sub_0();
return true;
}

bool sub_0() {
sub_1();
reg_tmp8.xy = (uniforms.f[93].xxxx).xy;
reg_tmp0.y = (uniforms.f[7].wwww).y;
bool_regs = notEqual(uniforms.f[93].xx, reg_tmp0.xy);
reg_tmp9.xyz = (uniforms.f[93].xxxx).xyz;
reg_tmp9.w = (uniforms.f[21].wwww).w;
if (bool_regs.y) {
sub_30();
}
bool_regs = equal(uniforms.f[93].xx, reg_tmp8.xy);
if (all(bool_regs)) {
sub_32();
}
vs_out_attr3 = max_s(uniforms.f[93].xxxx, reg_tmp9);
reg_tmp0.xy = (uniforms.f[10].xxxx).xy;
if (uniforms.b[9]) {
sub_33();
} else {
sub_38();
}
reg_tmp0.xy = (uniforms.f[10].yyyy).xy;
bool_regs = equal(uniforms.f[93].yz, reg_tmp0.xy);
if (all(not(bool_regs))) {
sub_39();
} else {
sub_40();
}
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
reg_tmp4.x = dot_s(uniforms.f[14].xywz, reg_tmp6);
reg_tmp4.y = dot_s(uniforms.f[15].xywz, reg_tmp6);
vs_out_attr5 = reg_tmp4;
return true;
}
bool sub_30() {
reg_tmp0 = mul_s(uniforms.f[7].wwww, vs_in_reg3);
if (uniforms.b[7]) {
sub_31();
}
reg_tmp9.xyz = (mul_s(uniforms.f[20].wwww, reg_tmp0.xyzz)).xyz;
reg_tmp8.x = (uniforms.f[93].yyyy).x;
return false;
}
bool sub_31() {
reg_tmp9.w = (mul_s(reg_tmp9.wwww, reg_tmp0.wwww)).w;
return false;
}
bool sub_32() {
reg_tmp9 = uniforms.f[21];
return false;
}
bool sub_33() {
bool_regs = equal(uniforms.f[93].yz, reg_tmp0.xy);
if (all(not(bool_regs))) {
sub_34();
} else {
sub_35();
}
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
reg_tmp3.x = dot_s(uniforms.f[11].xywz, reg_tmp6);
reg_tmp3.y = dot_s(uniforms.f[12].xywz, reg_tmp6);
reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
vs_out_attr4 = reg_tmp3;
return false;
}
bool sub_34() {
reg_tmp6.xy = (mul_s(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
return false;
}
bool sub_35() {
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_36();
} else {
sub_37();
}
return false;
}
bool sub_36() {
reg_tmp6.xy = (mul_s(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
return false;
}
bool sub_37() {
reg_tmp6.xy = (mul_s(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
return false;
}
bool sub_38() {
bool_regs = equal(uniforms.f[95].xy, reg_tmp0.xy);
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
reg_tmp6 = reg_tmp10;
reg_tmp3.x = dot_s(uniforms.f[11], reg_tmp6);
reg_tmp3.y = dot_s(uniforms.f[12], reg_tmp6);
reg_tmp3.z = dot_s(uniforms.f[13], reg_tmp6);
reg_tmp0.xy = (mul_s(uniforms.f[19].xyyy, reg_tmp3.zzzz)).xy;
reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
vs_out_attr4 = reg_tmp3;
return false;
}
bool sub_39() {
reg_tmp6.xy = (mul_s(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
return false;
}
bool sub_40() {
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_41();
} else {
sub_42();
}
return false;
}
bool sub_41() {
reg_tmp6.xy = (mul_s(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
return false;
}
bool sub_42() {
reg_tmp6.xy = (mul_s(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
return false;
}
bool sub_21() {
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp3.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp3.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp3.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
return false;
}
bool sub_4() {
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp3.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp3.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp3.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp4.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
return false;
}
bool sub_9() {
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp3.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp3.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp3.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp4.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp5.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp5.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp5.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
reg_tmp11 = fma_s(reg_tmp1.wwww, reg_tmp5, reg_tmp11);
return false;
}
bool sub_1() {
reg_tmp15.xyz = (mul_s(uniforms.f[7].xxxx, vs_in_reg0)).xyz;
reg_tmp14.xyz = (mul_s(uniforms.f[7].yyyy, vs_in_reg1)).xyz;
reg_tmp13.xyz = (mul_s(uniforms.f[7].zzzz, vs_in_reg2)).xyz;
reg_tmp15.xyz = (uniforms.f[6] + reg_tmp15).xyz;
reg_tmp15.w = (uniforms.f[93].yyyy).w;
if (uniforms.b[1]) {
sub_2();
} else {
sub_23();
}
return false;
}
bool sub_2() {
reg_tmp0 = uniforms.f[7];
bool_regs = notEqual(uniforms.f[93].xx, reg_tmp0.yz);
reg_tmp7 = uniforms.f[93].xxxx;
reg_tmp12 = uniforms.f[93].xxxx;
reg_tmp11 = uniforms.f[93].xxxx;
reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_3();
} else {
sub_7();
}
vs_out_attr2 = -reg_tmp15;
vs_out_attr0.x = dot_s(uniforms.f[86], reg_tmp15);
vs_out_attr0.y = dot_s(uniforms.f[87], reg_tmp15);
vs_out_attr0.z = dot_s(uniforms.f[88], reg_tmp15);
vs_out_attr0.w = dot_s(uniforms.f[89], reg_tmp15);
return false;
}
bool sub_3() {
bool_regs = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
reg_tmp1.xy = (reg_tmp2.xxxx).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
sub_4();
reg_tmp1.xy = (reg_tmp2.yyyy).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
sub_4();
reg_tmp1.xy = (reg_tmp2.zzzz).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
if (bool_regs.x) {
sub_4();
}
if (uniforms.b[8]) {
sub_5();
}
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
sub_6();
return false;
}
bool sub_5() {
reg_tmp1.xy = (reg_tmp2.wwww).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
if (bool_regs.y) {
sub_4();
}
return false;
}
bool sub_7() {
if (all(bool_regs)) {
sub_8();
} else {
sub_20();
}
return false;
}
bool sub_8() {
bool_regs = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
reg_tmp1.xy = (reg_tmp2.xxxx).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
sub_9();
reg_tmp1.xy = (reg_tmp2.yyyy).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
sub_9();
reg_tmp1.xy = (reg_tmp2.zzzz).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
if (bool_regs.x) {
sub_9();
}
if (uniforms.b[8]) {
sub_10();
}
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp13.x = dot_3(uniforms.f[3].xyz, reg_tmp11.xyz);
reg_tmp13.y = dot_3(uniforms.f[4].xyz, reg_tmp11.xyz);
reg_tmp13.z = dot_3(uniforms.f[5].xyz, reg_tmp11.xyz);
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
sub_11();
return false;
}
bool sub_10() {
reg_tmp1.xy = (reg_tmp2.wwww).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
if (bool_regs.y) {
sub_9();
}
return false;
}
bool sub_20() {
bool_regs = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
reg_tmp1.xy = (reg_tmp2.xxxx).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
sub_21();
reg_tmp1.xy = (reg_tmp2.yyyy).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
sub_21();
reg_tmp1.xy = (reg_tmp2.zzzz).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
if (bool_regs.x) {
sub_21();
}
if (uniforms.b[8]) {
sub_22();
}
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
vs_out_attr1 = uniforms.f[93].xxxx;
return false;
}
bool sub_22() {
reg_tmp1.xy = (reg_tmp2.wwww).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
if (bool_regs.y) {
sub_21();
}
return false;
}
bool sub_23() {
reg_tmp0 = uniforms.f[7];
bool_regs = notEqual(uniforms.f[93].xx, reg_tmp0.yz);
if (uniforms.b[2]) {
sub_24();
} else {
sub_25();
}
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_26();
} else {
sub_27();
}
vs_out_attr2 = -reg_tmp15;
vs_out_attr0.x = dot_s(uniforms.f[86], reg_tmp15);
vs_out_attr0.y = dot_s(uniforms.f[87], reg_tmp15);
vs_out_attr0.z = dot_s(uniforms.f[88], reg_tmp15);
vs_out_attr0.w = dot_s(uniforms.f[89], reg_tmp15);
return false;
}
bool sub_24() {
reg_tmp1.x = (mul_s(uniforms.f[93].wwww, vs_in_reg7.xxxx)).x;
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp7.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp7.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp7.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
return false;
}
bool sub_25() {
addr_regs.x = (ivec2(uniforms.f[93].xx)).x;
reg_tmp10.x = dot_s(uniforms.f[25], reg_tmp15);
reg_tmp10.y = dot_s(uniforms.f[26], reg_tmp15);
reg_tmp10.z = dot_s(uniforms.f[27], reg_tmp15);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
return false;
}
bool sub_26() {
reg_tmp12.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
sub_6();
return false;
}
bool sub_27() {
if (all(bool_regs)) {
sub_28();
} else {
sub_29();
}
return false;
}
bool sub_28() {
reg_tmp12.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp11.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp11.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp11.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
reg_tmp13.x = dot_3(uniforms.f[3].xyz, reg_tmp11.xyz);
reg_tmp13.y = dot_3(uniforms.f[4].xyz, reg_tmp11.xyz);
reg_tmp13.z = dot_3(uniforms.f[5].xyz, reg_tmp11.xyz);
sub_11();
return false;
}
bool sub_29() {
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
vs_out_attr1 = uniforms.f[93].xxxx;
return false;
}
bool sub_6() {
uint jmp_to = 251u;
while (true) {
switch (jmp_to) {
case 251u:
reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
reg_tmp6.x = rsq_s(reg_tmp6.x);
reg_tmp7.x = rsq_s(reg_tmp7.x);
reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp0 = uniforms.f[93].yxxx;
if (!uniforms.b[15]) {
jmp_to = 267u; break;
}
reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
reg_tmp4 = mul_s(uniforms.f[94].zzzz, reg_tmp4);
bool_regs = greaterThanEqual(uniforms.f[93].xx, reg_tmp4.xx);
reg_tmp4 = vec4(rsq_s(reg_tmp4.x));
reg_tmp5 = mul_s(uniforms.f[94].zzzz, reg_tmp14);
if (bool_regs.x) {
jmp_to = 267u; break;
}
reg_tmp0.z = rcp_s(reg_tmp4.x);
reg_tmp0.xy = (mul_s(reg_tmp5, reg_tmp4)).xy;
case 267u:
vs_out_attr1 = reg_tmp0;
default: return false;
}
}
return false;
}
bool sub_11() {
uint jmp_to = 268u;
while (true) {
switch (jmp_to) {
case 268u:
reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
reg_tmp6.x = rsq_s(reg_tmp6.x);
reg_tmp7.x = rsq_s(reg_tmp7.x);
reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp13.xyz = (mul_s(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp11.xyz = (mul_s(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp0 = uniforms.f[93].yxxx;
if (!uniforms.b[15]) {
jmp_to = 343u; break;
}
reg_tmp13.xyz = (mul_s(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp11.xyz = (mul_s(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp5 = mul_s(reg_tmp14.yzxx, reg_tmp13.zxyy);
reg_tmp5 = fma_s(-reg_tmp13.yzxx, reg_tmp14.zxyy, reg_tmp5);
reg_tmp5.w = dot_3(reg_tmp5.xyz, reg_tmp5.xyz);
reg_tmp5.w = rsq_s(reg_tmp5.w);
reg_tmp5 = mul_s(reg_tmp5, reg_tmp5.wwww);
reg_tmp6.w = (reg_tmp14.zzzz + reg_tmp5.yyyy).w;
reg_tmp13 = mul_s(reg_tmp5.yzxx, reg_tmp14.zxyy);
reg_tmp13 = fma_s(-reg_tmp14.yzxx, reg_tmp5.zxyy, reg_tmp13);
reg_tmp6.w = (reg_tmp13.xxxx + reg_tmp6).w;
reg_tmp13.w = (reg_tmp5.zzzz).w;
reg_tmp5.z = (reg_tmp13.xxxx).z;
reg_tmp6.w = (uniforms.f[93].yyyy + reg_tmp6).w;
reg_tmp14.w = (reg_tmp5.xxxx).w;
reg_tmp5.x = (reg_tmp14.zzzz).x;
bool_regs = lessThan(uniforms.f[94].yy, reg_tmp6.ww);
reg_tmp6.x = (uniforms.f[93].yyyy).x;
reg_tmp6.y = (-uniforms.f[93].yyyy).y;
if (!bool_regs.x) {
jmp_to = 305u; break;
}
reg_tmp7.xz = (reg_tmp13.wwyy + -reg_tmp14.yyww).xz;
reg_tmp7.y = (reg_tmp14.xxxx + -reg_tmp13.zzzz).y;
reg_tmp7.w = (reg_tmp6).w;
reg_tmp6 = vec4(dot_s(reg_tmp7, reg_tmp7));
reg_tmp6 = vec4(rsq_s(reg_tmp6.x));
reg_tmp0 = mul_s(reg_tmp7, reg_tmp6);
if (uniforms.b[0]) {
jmp_to = 343u; break;
}
case 305u:
bool_regs = greaterThan(reg_tmp5.zy, reg_tmp5.yx);
if (bool_regs.x) {
sub_12();
} else {
sub_17();
}
reg_tmp6 = vec4(dot_s(reg_tmp8, reg_tmp8));
reg_tmp6 = vec4(rsq_s(reg_tmp6.x));
reg_tmp0 = mul_s(reg_tmp8, reg_tmp6);
case 343u:
vs_out_attr1 = reg_tmp0;
default: return false;
}
}
return false;
}
bool sub_12() {
if (bool_regs.y) {
sub_13();
} else {
sub_14();
}
reg_tmp8.w = (-reg_tmp8).w;
return false;
}
bool sub_13() {
reg_tmp8 = mul_s(reg_tmp13.yyzw, reg_tmp6.xxxy);
reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
return false;
}
bool sub_14() {
bool_regs = greaterThan(reg_tmp5.zz, reg_tmp5.xx);
reg_tmp8 = mul_s(reg_tmp13.yyzw, reg_tmp6.xxxy);
reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
if (bool_regs.x) {
sub_15();
} else {
sub_16();
}
return false;
}
bool sub_15() {
reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
return false;
}
bool sub_16() {
reg_tmp8 = mul_s(reg_tmp13.zwwy, reg_tmp6.xxxy);
reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
return false;
}
bool sub_17() {
if (bool_regs.y) {
sub_18();
} else {
sub_19();
}
return false;
}
bool sub_18() {
reg_tmp8 = mul_s(reg_tmp13.yywz, reg_tmp6.xxxy);
reg_tmp8.y = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).y;
reg_tmp9 = reg_tmp5.yyyy + -reg_tmp5.xxxx;
reg_tmp8.xzw = (reg_tmp8 + reg_tmp14.wwyx).xzw;
reg_tmp8.y = (reg_tmp9 + reg_tmp8).y;
return false;
}
bool sub_19() {
reg_tmp8 = mul_s(reg_tmp13.zwwy, reg_tmp6.xxxy);
reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
reg_tmp8.w = (-reg_tmp8).w;
return false;
}
// reference: FBC45F3FC0DBE7A8, AEF4EEAE6F9585E0
// program: AEF4EEAE6F9585E0, F777123A8C3D5E20, FD29673C2E307195
// shader: 8B31, 0DC2C13FBB70BE34

#define mul_s(x, y) mix(x * y, vec4(0), isnan(x * y))
#define mul_3(x, y) mix(x * y, vec3(0), isnan(x * y))
#define fma_s(x, y, z) (mul_s(x, y) + z)
#define dot_s(x, y) dot(mul_s(x, y), vec4(1))
#define dot_3(x, y) dot(mul_3(x, y), vec3(1))

float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x == 0.0) return x;
    return inversesqrt(x);
}

#define min_s(x, y) min(x, y)
#define max_s(x, y) max(x, y)

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout(binding=2, std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location=0) in vec4 vs_in_reg0;
layout(location=1) in vec4 vs_in_reg1;
layout(location=2) in vec4 vs_in_reg2;
layout(location=4) in vec4 vs_in_reg4;
layout(location=5) in vec4 vs_in_reg5;
layout(location=6) in vec4 vs_in_reg6;
layout(location=7) in vec4 vs_in_reg7;
layout(location=8) in vec4 vs_in_reg8;

layout(location=0) out vec4 vs_out_attr0;
layout(location=1) out vec4 vs_out_attr1;
layout(location=2) out vec4 vs_out_attr2;
layout(location=3) out vec4 vs_out_attr3;
layout(location=4) out vec4 vs_out_attr4;
layout(location=5) out vec4 vs_out_attr5;
layout(location=6) out vec4 vs_out_attr6;

void main() {
vs_out_attr0 = vec4(0, 0, 0, 1);
vs_out_attr1 = vec4(0, 0, 0, 1);
vs_out_attr2 = vec4(0, 0, 0, 1);
vs_out_attr3 = vec4(0, 0, 0, 1);
vs_out_attr4 = vec4(0, 0, 0, 1);
vs_out_attr5 = vec4(0, 0, 0, 1);
vs_out_attr6 = vec4(0, 0, 0, 1);
exec_shader();
}
bvec2 bool_regs = bvec2(false);
ivec3 addr_regs = ivec3(0);
vec4 reg_tmp0 = vec4(0, 0, 0, 1);
vec4 reg_tmp1 = vec4(0, 0, 0, 1);
vec4 reg_tmp2 = vec4(0, 0, 0, 1);
vec4 reg_tmp3 = vec4(0, 0, 0, 1);
vec4 reg_tmp4 = vec4(0, 0, 0, 1);
vec4 reg_tmp5 = vec4(0, 0, 0, 1);
vec4 reg_tmp6 = vec4(0, 0, 0, 1);
vec4 reg_tmp7 = vec4(0, 0, 0, 1);
vec4 reg_tmp8 = vec4(0, 0, 0, 1);
vec4 reg_tmp9 = vec4(0, 0, 0, 1);
vec4 reg_tmp10 = vec4(0, 0, 0, 1);
vec4 reg_tmp11 = vec4(0, 0, 0, 1);
vec4 reg_tmp12 = vec4(0, 0, 0, 1);
vec4 reg_tmp13 = vec4(0, 0, 0, 1);
vec4 reg_tmp14 = vec4(0, 0, 0, 1);
vec4 reg_tmp15 = vec4(0, 0, 0, 1);

bool sub_0();
bool sub_21();
bool sub_4();
bool sub_9();
bool sub_1();
bool sub_2();
bool sub_3();
bool sub_5();
bool sub_7();
bool sub_8();
bool sub_10();
bool sub_20();
bool sub_22();
bool sub_23();
bool sub_24();
bool sub_25();
bool sub_26();
bool sub_27();
bool sub_28();
bool sub_29();
bool sub_30();
bool sub_31();
bool sub_6();
bool sub_11();
bool sub_12();
bool sub_13();
bool sub_14();
bool sub_15();
bool sub_16();
bool sub_17();
bool sub_18();
bool sub_19();
bool sub_32();
bool sub_33();
bool sub_34();
bool sub_40();
bool sub_41();
bool sub_42();
bool sub_43();
bool sub_45();
bool sub_35();
bool sub_36();
bool sub_37();
bool sub_38();
bool sub_39();
bool sub_44();
bool sub_46();
bool sub_47();
bool sub_48();
bool sub_49();
bool sub_50();
bool sub_51();
bool sub_52();
bool sub_53();
bool sub_54();
bool sub_55();
bool sub_56();
bool sub_57();
bool sub_58();

bool exec_shader() {
sub_0();
return true;
}

bool sub_0() {
sub_1();
sub_32();
sub_33();
sub_47();
sub_54();
return true;
}
bool sub_21() {
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp3.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp3.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp3.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
return false;
}
bool sub_4() {
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp3.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp3.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp3.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp4.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
return false;
}
bool sub_9() {
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp3.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp3.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp3.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp4.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp5.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp5.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp5.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
reg_tmp11 = fma_s(reg_tmp1.wwww, reg_tmp5, reg_tmp11);
return false;
}
bool sub_1() {
reg_tmp15.xyz = (mul_s(uniforms.f[7].xxxx, vs_in_reg0)).xyz;
reg_tmp14.xyz = (mul_s(uniforms.f[7].yyyy, vs_in_reg1)).xyz;
reg_tmp13.xyz = (mul_s(uniforms.f[7].zzzz, vs_in_reg2)).xyz;
reg_tmp15.xyz = (uniforms.f[6] + reg_tmp15).xyz;
reg_tmp15.w = (uniforms.f[93].yyyy).w;
if (uniforms.b[1]) {
sub_2();
} else {
sub_24();
}
return false;
}
bool sub_2() {
reg_tmp0 = uniforms.f[7];
bool_regs = notEqual(uniforms.f[93].xx, reg_tmp0.yz);
reg_tmp7 = uniforms.f[93].xxxx;
reg_tmp12 = uniforms.f[93].xxxx;
reg_tmp11 = uniforms.f[93].xxxx;
reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_3();
} else {
sub_7();
}
vs_out_attr2 = -reg_tmp15;
reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
reg_tmp1.x = (-reg_tmp0.wwww).x;
reg_tmp1.y = (mul_s(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
bool_regs.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
bool_regs.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
if (all(bool_regs)) {
sub_23();
}
vs_out_attr0 = reg_tmp0;
return false;
}
bool sub_3() {
bool_regs = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
reg_tmp1.xy = (reg_tmp2.xxxx).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
sub_4();
reg_tmp1.xy = (reg_tmp2.yyyy).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
sub_4();
reg_tmp1.xy = (reg_tmp2.zzzz).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
if (bool_regs.x) {
sub_4();
}
if (uniforms.b[8]) {
sub_5();
}
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
sub_6();
return false;
}
bool sub_5() {
reg_tmp1.xy = (reg_tmp2.wwww).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
if (bool_regs.y) {
sub_4();
}
return false;
}
bool sub_7() {
if (all(bool_regs)) {
sub_8();
} else {
sub_20();
}
return false;
}
bool sub_8() {
bool_regs = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
reg_tmp1.xy = (reg_tmp2.xxxx).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
sub_9();
reg_tmp1.xy = (reg_tmp2.yyyy).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
sub_9();
reg_tmp1.xy = (reg_tmp2.zzzz).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
if (bool_regs.x) {
sub_9();
}
if (uniforms.b[8]) {
sub_10();
}
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp13.x = dot_3(uniforms.f[3].xyz, reg_tmp11.xyz);
reg_tmp13.y = dot_3(uniforms.f[4].xyz, reg_tmp11.xyz);
reg_tmp13.z = dot_3(uniforms.f[5].xyz, reg_tmp11.xyz);
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
sub_11();
return false;
}
bool sub_10() {
reg_tmp1.xy = (reg_tmp2.wwww).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
if (bool_regs.y) {
sub_9();
}
return false;
}
bool sub_20() {
bool_regs = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
reg_tmp1.xy = (reg_tmp2.xxxx).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
sub_21();
reg_tmp1.xy = (reg_tmp2.yyyy).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
sub_21();
reg_tmp1.xy = (reg_tmp2.zzzz).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
if (bool_regs.x) {
sub_21();
}
if (uniforms.b[8]) {
sub_22();
}
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
vs_out_attr1 = uniforms.f[93].xxxx;
return false;
}
bool sub_22() {
reg_tmp1.xy = (reg_tmp2.wwww).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
if (bool_regs.y) {
sub_21();
}
return false;
}
bool sub_23() {
reg_tmp0.x = (-reg_tmp0.wwww).x;
return false;
}
bool sub_24() {
reg_tmp0 = uniforms.f[7];
bool_regs = notEqual(uniforms.f[93].xx, reg_tmp0.yz);
if (uniforms.b[2]) {
sub_25();
} else {
sub_26();
}
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_27();
} else {
sub_28();
}
vs_out_attr2 = -reg_tmp15;
reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
reg_tmp1.x = (-reg_tmp0.wwww).x;
reg_tmp1.y = (mul_s(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
bool_regs.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
bool_regs.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
if (all(bool_regs)) {
sub_31();
}
vs_out_attr0 = reg_tmp0;
return false;
}
bool sub_25() {
reg_tmp1.x = (mul_s(uniforms.f[93].wwww, vs_in_reg7.xxxx)).x;
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp7.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp7.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp7.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
return false;
}
bool sub_26() {
addr_regs.x = (ivec2(uniforms.f[93].xx)).x;
reg_tmp10.x = dot_s(uniforms.f[25], reg_tmp15);
reg_tmp10.y = dot_s(uniforms.f[26], reg_tmp15);
reg_tmp10.z = dot_s(uniforms.f[27], reg_tmp15);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
return false;
}
bool sub_27() {
reg_tmp12.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
sub_6();
return false;
}
bool sub_28() {
if (all(bool_regs)) {
sub_29();
} else {
sub_30();
}
return false;
}
bool sub_29() {
reg_tmp12.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp11.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp11.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp11.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
reg_tmp13.x = dot_3(uniforms.f[3].xyz, reg_tmp11.xyz);
reg_tmp13.y = dot_3(uniforms.f[4].xyz, reg_tmp11.xyz);
reg_tmp13.z = dot_3(uniforms.f[5].xyz, reg_tmp11.xyz);
sub_11();
return false;
}
bool sub_30() {
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
vs_out_attr1 = uniforms.f[93].xxxx;
return false;
}
bool sub_31() {
reg_tmp0.x = (-reg_tmp0.wwww).x;
return false;
}
bool sub_6() {
uint jmp_to = 214u;
while (true) {
switch (jmp_to) {
case 214u:
reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
reg_tmp6.x = rsq_s(reg_tmp6.x);
reg_tmp7.x = rsq_s(reg_tmp7.x);
reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp0 = uniforms.f[93].yxxx;
if (!uniforms.b[15]) {
jmp_to = 230u; break;
}
reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
reg_tmp4 = mul_s(uniforms.f[94].zzzz, reg_tmp4);
bool_regs = greaterThanEqual(uniforms.f[93].xx, reg_tmp4.xx);
reg_tmp4 = vec4(rsq_s(reg_tmp4.x));
reg_tmp5 = mul_s(uniforms.f[94].zzzz, reg_tmp14);
if (bool_regs.x) {
jmp_to = 230u; break;
}
reg_tmp0.z = rcp_s(reg_tmp4.x);
reg_tmp0.xy = (mul_s(reg_tmp5, reg_tmp4)).xy;
case 230u:
vs_out_attr1 = reg_tmp0;
default: return false;
}
}
return false;
}
bool sub_11() {
uint jmp_to = 231u;
while (true) {
switch (jmp_to) {
case 231u:
reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
reg_tmp6.x = rsq_s(reg_tmp6.x);
reg_tmp7.x = rsq_s(reg_tmp7.x);
reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp13.xyz = (mul_s(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp11.xyz = (mul_s(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp0 = uniforms.f[93].yxxx;
if (!uniforms.b[15]) {
jmp_to = 306u; break;
}
reg_tmp13.xyz = (mul_s(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp11.xyz = (mul_s(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp5 = mul_s(reg_tmp14.yzxx, reg_tmp13.zxyy);
reg_tmp5 = fma_s(-reg_tmp13.yzxx, reg_tmp14.zxyy, reg_tmp5);
reg_tmp5.w = dot_3(reg_tmp5.xyz, reg_tmp5.xyz);
reg_tmp5.w = rsq_s(reg_tmp5.w);
reg_tmp5 = mul_s(reg_tmp5, reg_tmp5.wwww);
reg_tmp6.w = (reg_tmp14.zzzz + reg_tmp5.yyyy).w;
reg_tmp13 = mul_s(reg_tmp5.yzxx, reg_tmp14.zxyy);
reg_tmp13 = fma_s(-reg_tmp14.yzxx, reg_tmp5.zxyy, reg_tmp13);
reg_tmp6.w = (reg_tmp13.xxxx + reg_tmp6).w;
reg_tmp13.w = (reg_tmp5.zzzz).w;
reg_tmp5.z = (reg_tmp13.xxxx).z;
reg_tmp6.w = (uniforms.f[93].yyyy + reg_tmp6).w;
reg_tmp14.w = (reg_tmp5.xxxx).w;
reg_tmp5.x = (reg_tmp14.zzzz).x;
bool_regs = lessThan(uniforms.f[94].yy, reg_tmp6.ww);
reg_tmp6.x = (uniforms.f[93].yyyy).x;
reg_tmp6.y = (-uniforms.f[93].yyyy).y;
if (!bool_regs.x) {
jmp_to = 268u; break;
}
reg_tmp7.xz = (reg_tmp13.wwyy + -reg_tmp14.yyww).xz;
reg_tmp7.y = (reg_tmp14.xxxx + -reg_tmp13.zzzz).y;
reg_tmp7.w = (reg_tmp6).w;
reg_tmp6 = vec4(dot_s(reg_tmp7, reg_tmp7));
reg_tmp6 = vec4(rsq_s(reg_tmp6.x));
reg_tmp0 = mul_s(reg_tmp7, reg_tmp6);
if (uniforms.b[0]) {
jmp_to = 306u; break;
}
case 268u:
bool_regs = greaterThan(reg_tmp5.zy, reg_tmp5.yx);
if (bool_regs.x) {
sub_12();
} else {
sub_17();
}
reg_tmp6 = vec4(dot_s(reg_tmp8, reg_tmp8));
reg_tmp6 = vec4(rsq_s(reg_tmp6.x));
reg_tmp0 = mul_s(reg_tmp8, reg_tmp6);
case 306u:
vs_out_attr1 = reg_tmp0;
default: return false;
}
}
return false;
}
bool sub_12() {
if (bool_regs.y) {
sub_13();
} else {
sub_14();
}
reg_tmp8.w = (-reg_tmp8).w;
return false;
}
bool sub_13() {
reg_tmp8 = mul_s(reg_tmp13.yyzw, reg_tmp6.xxxy);
reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
return false;
}
bool sub_14() {
bool_regs = greaterThan(reg_tmp5.zz, reg_tmp5.xx);
reg_tmp8 = mul_s(reg_tmp13.yyzw, reg_tmp6.xxxy);
reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
if (bool_regs.x) {
sub_15();
} else {
sub_16();
}
return false;
}
bool sub_15() {
reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
return false;
}
bool sub_16() {
reg_tmp8 = mul_s(reg_tmp13.zwwy, reg_tmp6.xxxy);
reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
return false;
}
bool sub_17() {
if (bool_regs.y) {
sub_18();
} else {
sub_19();
}
return false;
}
bool sub_18() {
reg_tmp8 = mul_s(reg_tmp13.yywz, reg_tmp6.xxxy);
reg_tmp8.y = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).y;
reg_tmp9 = reg_tmp5.yyyy + -reg_tmp5.xxxx;
reg_tmp8.xzw = (reg_tmp8 + reg_tmp14.wwyx).xzw;
reg_tmp8.y = (reg_tmp9 + reg_tmp8).y;
return false;
}
bool sub_19() {
reg_tmp8 = mul_s(reg_tmp13.zwwy, reg_tmp6.xxxy);
reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
reg_tmp8.w = (-reg_tmp8).w;
return false;
}
bool sub_32() {
reg_tmp1.xyz = (uniforms.f[93].xxyx).xyz;
reg_tmp8.x = dot_3(uniforms.f[0].xyz, reg_tmp12.xyz);
reg_tmp8.y = dot_3(uniforms.f[1].xyz, reg_tmp12.xyz);
reg_tmp8.z = dot_3(uniforms.f[2].xyz, reg_tmp12.xyz);
reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp8.xyz);
reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp8.xyz);
reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp8.xyz);
reg_tmp14.w = (uniforms.f[93].xxxx).w;
reg_tmp8 = reg_tmp14;
reg_tmp14.x = dot_s(reg_tmp8, reg_tmp8);
reg_tmp14.x = rsq_s(reg_tmp14.x);
reg_tmp14 = mul_s(reg_tmp8, reg_tmp14.xxxx);
reg_tmp0 = uniforms.f[23];
reg_tmp8.x = dot_3(uniforms.f[0].xyz, reg_tmp0.xyz);
reg_tmp8.y = dot_3(uniforms.f[1].xyz, reg_tmp0.xyz);
reg_tmp8.z = dot_3(uniforms.f[2].xyz, reg_tmp0.xyz);
reg_tmp6.x = dot_3(uniforms.f[90].xyz, reg_tmp8.xyz);
reg_tmp6.y = dot_3(uniforms.f[91].xyz, reg_tmp8.xyz);
reg_tmp6.z = dot_3(uniforms.f[92].xyz, reg_tmp8.xyz);
reg_tmp8.xyz = (reg_tmp6.xyzz + reg_tmp1.xyzz).xyz;
reg_tmp8.w = (uniforms.f[93].xxxx).w;
reg_tmp0.x = dot_s(reg_tmp8, reg_tmp8);
reg_tmp0.x = rsq_s(reg_tmp0.x);
reg_tmp0 = mul_s(reg_tmp8, reg_tmp0.xxxx);
reg_tmp8.x = dot_3(reg_tmp14.xyz, -reg_tmp6.xyz);
reg_tmp8.y = dot_3(reg_tmp1.xyz, -reg_tmp6.xyz);
reg_tmp8 = max_s(uniforms.f[93].xxxx, reg_tmp8);
reg_tmp2.y = (mul_s(reg_tmp8.xxxx, reg_tmp8.yyyy)).y;
reg_tmp9.z = dot_3(reg_tmp14.xyz, reg_tmp0.xyz);
reg_tmp9.z = (max_s(uniforms.f[93].xxxx, reg_tmp9.zzzz)).z;
reg_tmp9.z = (min_s(uniforms.f[93].yyyy, reg_tmp9.zzzz)).z;
reg_tmp9.z = log2(reg_tmp9.z);
reg_tmp9.z = (mul_s(uniforms.f[22].zzzz, reg_tmp9.zzzz)).z;
reg_tmp9.z = exp2(reg_tmp9.z);
reg_tmp2.z = (mul_s(uniforms.f[22].wwww, reg_tmp9.zzzz)).z;
reg_tmp9.x = dot_3(reg_tmp14.xyz, reg_tmp1.xyz);
reg_tmp9.x = (max_s(uniforms.f[93].xxxx, reg_tmp9.xxxx)).x;
reg_tmp9.x = (min_s(uniforms.f[93].yyyy, reg_tmp9.xxxx)).x;
reg_tmp9.x = (uniforms.f[93].yyyy + -reg_tmp9.xxxx).x;
reg_tmp9.x = log2(reg_tmp9.x);
reg_tmp9.x = (mul_s(uniforms.f[22].xxxx, reg_tmp9.xxxx)).x;
reg_tmp9.x = exp2(reg_tmp9.x);
reg_tmp2.w = (mul_s(uniforms.f[22].yyyy, reg_tmp9.xxxx)).w;
vs_out_attr3 = reg_tmp2;
return false;
}
bool sub_33() {
reg_tmp0.xy = (uniforms.f[10].xxxx).xy;
if (uniforms.b[9]) {
sub_34();
} else {
sub_40();
}
return false;
}
bool sub_34() {
sub_35();
reg_tmp3.x = dot_s(uniforms.f[11].xywz, reg_tmp6);
reg_tmp3.y = dot_s(uniforms.f[12].xywz, reg_tmp6);
reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
vs_out_attr4 = reg_tmp3;
return false;
}
bool sub_40() {
bool_regs = equal(uniforms.f[95].xy, reg_tmp0.xy);
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
if (all(not(bool_regs))) {
sub_41();
} else {
sub_42();
}
vs_out_attr4 = reg_tmp3;
return false;
}
bool sub_41() {
reg_tmp6 = reg_tmp10;
reg_tmp3.x = dot_s(uniforms.f[11], reg_tmp6);
reg_tmp3.y = dot_s(uniforms.f[12], reg_tmp6);
reg_tmp3.z = dot_s(uniforms.f[13], reg_tmp6);
reg_tmp0.xy = (mul_s(uniforms.f[19].xyyy, reg_tmp3.zzzz)).xy;
reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
return false;
}
bool sub_42() {
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_43();
} else {
sub_45();
}
return false;
}
bool sub_43() {
sub_44();
reg_tmp3.x = dot_3(uniforms.f[11].xyz, reg_tmp6.xyz);
reg_tmp3.y = dot_3(uniforms.f[12].xyz, reg_tmp6.xyz);
reg_tmp3.z = dot_3(uniforms.f[13].xyz, reg_tmp6.xyz);
return false;
}
bool sub_45() {
sub_46();
reg_tmp3.x = dot_s(uniforms.f[11], reg_tmp6);
reg_tmp3.y = dot_s(uniforms.f[12], reg_tmp6);
return false;
}
bool sub_35() {
bool_regs = equal(uniforms.f[93].yz, reg_tmp0.xy);
if (all(not(bool_regs))) {
sub_36();
} else {
sub_37();
}
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
return false;
}
bool sub_36() {
reg_tmp6.xy = (mul_s(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
return false;
}
bool sub_37() {
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_38();
} else {
sub_39();
}
return false;
}
bool sub_38() {
reg_tmp6.xy = (mul_s(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
return false;
}
bool sub_39() {
reg_tmp6.xy = (mul_s(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
return false;
}
bool sub_44() {
reg_tmp2 = -reg_tmp15;
reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
reg_tmp2.w = rsq_s(reg_tmp2.w);
reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
reg_tmp1 = reg_tmp1 + reg_tmp1;
reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
return false;
}
bool sub_46() {
reg_tmp1.xy = (uniforms.f[94].zzzz).xy;
reg_tmp1.zw = (uniforms.f[93].xxxx).zw;
reg_tmp6 = fma_s(reg_tmp14, reg_tmp1, reg_tmp1);
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
return false;
}
bool sub_47() {
reg_tmp0.xy = (uniforms.f[10].yyyy).xy;
if (uniforms.b[10]) {
sub_48();
} else {
sub_49();
}
return false;
}
bool sub_48() {
sub_35();
reg_tmp4.x = dot_s(uniforms.f[14].xywz, reg_tmp6);
reg_tmp4.y = dot_s(uniforms.f[15].xywz, reg_tmp6);
vs_out_attr5 = reg_tmp4;
return false;
}
bool sub_49() {
if (uniforms.b[13]) {
sub_50();
} else {
sub_53();
}
return false;
}
bool sub_50() {
bool_regs = equal(uniforms.f[95].xy, reg_tmp0.xy);
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
if (all(not(bool_regs))) {
sub_51();
} else {
sub_52();
}
vs_out_attr5 = reg_tmp4;
return false;
}
bool sub_51() {
reg_tmp6 = reg_tmp10;
reg_tmp4.x = dot_s(uniforms.f[14], reg_tmp6);
reg_tmp4.y = dot_s(uniforms.f[15], reg_tmp6);
reg_tmp4.z = dot_s(uniforms.f[16], reg_tmp6);
reg_tmp6.w = rcp_s(reg_tmp4.z);
reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
reg_tmp4.xy = (uniforms.f[19].zwww + reg_tmp4.xyyy).xy;
return false;
}
bool sub_52() {
sub_46();
reg_tmp4.x = dot_s(uniforms.f[14], reg_tmp6);
reg_tmp4.y = dot_s(uniforms.f[15], reg_tmp6);
return false;
}
bool sub_53() {
vs_out_attr5 = uniforms.f[93].xxxx;
return false;
}
bool sub_54() {
reg_tmp0.xy = (uniforms.f[10].zzzz).xy;
if (uniforms.b[11]) {
sub_55();
} else {
sub_56();
}
return false;
}
bool sub_55() {
sub_35();
reg_tmp5.x = dot_s(uniforms.f[17].xywz, reg_tmp6);
reg_tmp5.y = dot_s(uniforms.f[18].xywz, reg_tmp6);
vs_out_attr6 = reg_tmp5;
return false;
}
bool sub_56() {
if (uniforms.b[14]) {
sub_57();
} else {
sub_58();
}
return false;
}
bool sub_57() {
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
reg_tmp5.zw = (reg_tmp6.zwww).zw;
sub_46();
reg_tmp5.x = dot_s(uniforms.f[17], reg_tmp6);
reg_tmp5.y = dot_s(uniforms.f[18], reg_tmp6);
vs_out_attr6 = reg_tmp5;
return false;
}
bool sub_58() {
vs_out_attr6 = uniforms.f[93].xxxx;
return false;
}
// reference: 0358855AC29B5422, 0DC2C13FBB70BE34
// program: 0DC2C13FBB70BE34, EADA2116091C5E01, B18B4F8E8E479EBB
// program: 1C4FF6A809801458, F777123A8C3D5E20, 45E2174AE15FBF0E
// program: 1C4FF6A809801458, F777123A8C3D5E20, 8BBFD0CFE94448D9
// program: 1C4FF6A809801458, F777123A8C3D5E20, 086D9EB605D403CF
// shader: 8B31, C9DB819577AE2179

#define mul_s(x, y) mix(x * y, vec4(0), isnan(x * y))
#define mul_3(x, y) mix(x * y, vec3(0), isnan(x * y))
#define fma_s(x, y, z) (mul_s(x, y) + z)
#define dot_s(x, y) dot(mul_s(x, y), vec4(1))
#define dot_3(x, y) dot(mul_3(x, y), vec3(1))

float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x == 0.0) return x;
    return inversesqrt(x);
}

#define min_s(x, y) min(x, y)
#define max_s(x, y) max(x, y)

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout(binding=2, std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location=0) in vec4 vs_in_reg0;
layout(location=1) in vec4 vs_in_reg1;
layout(location=2) in vec4 vs_in_reg2;
layout(location=4) in vec4 vs_in_reg4;
layout(location=5) in vec4 vs_in_reg5;
layout(location=6) in vec4 vs_in_reg6;
layout(location=7) in vec4 vs_in_reg7;
layout(location=8) in vec4 vs_in_reg8;

layout(location=0) out vec4 vs_out_attr0;
layout(location=1) out vec4 vs_out_attr1;
layout(location=2) out vec4 vs_out_attr2;
layout(location=3) out vec4 vs_out_attr3;
layout(location=4) out vec4 vs_out_attr4;
layout(location=5) out vec4 vs_out_attr5;
layout(location=6) out vec4 vs_out_attr6;

void main() {
vs_out_attr0 = vec4(0, 0, 0, 1);
vs_out_attr1 = vec4(0, 0, 0, 1);
vs_out_attr2 = vec4(0, 0, 0, 1);
vs_out_attr3 = vec4(0, 0, 0, 1);
vs_out_attr4 = vec4(0, 0, 0, 1);
vs_out_attr5 = vec4(0, 0, 0, 1);
vs_out_attr6 = vec4(0, 0, 0, 1);
exec_shader();
}
bvec2 bool_regs = bvec2(false);
ivec3 addr_regs = ivec3(0);
vec4 reg_tmp0 = vec4(0, 0, 0, 1);
vec4 reg_tmp1 = vec4(0, 0, 0, 1);
vec4 reg_tmp2 = vec4(0, 0, 0, 1);
vec4 reg_tmp3 = vec4(0, 0, 0, 1);
vec4 reg_tmp4 = vec4(0, 0, 0, 1);
vec4 reg_tmp5 = vec4(0, 0, 0, 1);
vec4 reg_tmp6 = vec4(0, 0, 0, 1);
vec4 reg_tmp7 = vec4(0, 0, 0, 1);
vec4 reg_tmp8 = vec4(0, 0, 0, 1);
vec4 reg_tmp9 = vec4(0, 0, 0, 1);
vec4 reg_tmp10 = vec4(0, 0, 0, 1);
vec4 reg_tmp11 = vec4(0, 0, 0, 1);
vec4 reg_tmp12 = vec4(0, 0, 0, 1);
vec4 reg_tmp13 = vec4(0, 0, 0, 1);
vec4 reg_tmp14 = vec4(0, 0, 0, 1);
vec4 reg_tmp15 = vec4(0, 0, 0, 1);

bool sub_7();
bool sub_8();
bool sub_9();
bool sub_10();
bool sub_12();
bool sub_13();
bool sub_19();
bool sub_20();
bool sub_21();
bool sub_22();
bool sub_24();
bool sub_14();
bool sub_15();
bool sub_16();
bool sub_17();
bool sub_18();
bool sub_23();
bool sub_25();
bool sub_26();
bool sub_27();
bool sub_28();
bool sub_29();
bool sub_30();
bool sub_31();
bool sub_32();
bool sub_33();
bool sub_34();
bool sub_35();
bool sub_36();
bool sub_37();
bool sub_0();
bool sub_6();
bool sub_11();
bool sub_2();
bool sub_4();
bool sub_1();
bool sub_3();
bool sub_5();

bool exec_shader() {
sub_0();
return true;
}

bool sub_7() {
reg_tmp1.xyz = (uniforms.f[93].xxyx).xyz;
reg_tmp8.x = dot_3(uniforms.f[0].xyz, reg_tmp12.xyz);
reg_tmp8.y = dot_3(uniforms.f[1].xyz, reg_tmp12.xyz);
reg_tmp8.z = dot_3(uniforms.f[2].xyz, reg_tmp12.xyz);
reg_tmp14.x = dot_3(uniforms.f[90].xyz, reg_tmp8.xyz);
reg_tmp14.y = dot_3(uniforms.f[91].xyz, reg_tmp8.xyz);
reg_tmp14.z = dot_3(uniforms.f[92].xyz, reg_tmp8.xyz);
reg_tmp14.w = (uniforms.f[93].xxxx).w;
reg_tmp8 = reg_tmp14;
reg_tmp14.x = dot_s(reg_tmp8, reg_tmp8);
reg_tmp14.x = rsq_s(reg_tmp14.x);
reg_tmp14 = mul_s(reg_tmp8, reg_tmp14.xxxx);
reg_tmp0 = uniforms.f[23];
reg_tmp8.x = dot_3(uniforms.f[0].xyz, reg_tmp0.xyz);
reg_tmp8.y = dot_3(uniforms.f[1].xyz, reg_tmp0.xyz);
reg_tmp8.z = dot_3(uniforms.f[2].xyz, reg_tmp0.xyz);
reg_tmp6.x = dot_3(uniforms.f[90].xyz, reg_tmp8.xyz);
reg_tmp6.y = dot_3(uniforms.f[91].xyz, reg_tmp8.xyz);
reg_tmp6.z = dot_3(uniforms.f[92].xyz, reg_tmp8.xyz);
reg_tmp8.xyz = (reg_tmp6.xyzz + reg_tmp1.xyzz).xyz;
reg_tmp8.w = (uniforms.f[93].xxxx).w;
reg_tmp0.x = dot_s(reg_tmp8, reg_tmp8);
reg_tmp0.x = rsq_s(reg_tmp0.x);
reg_tmp0 = mul_s(reg_tmp8, reg_tmp0.xxxx);
if (uniforms.b[5]) {
sub_8();
}
if (uniforms.b[3]) {
sub_9();
}
if (uniforms.b[4]) {
sub_10();
}
vs_out_attr3 = reg_tmp2;
return false;
}
bool sub_8() {
reg_tmp8.x = dot_3(reg_tmp14.xyz, -reg_tmp6.xyz);
reg_tmp8.y = dot_3(reg_tmp1.xyz, -reg_tmp6.xyz);
reg_tmp8 = max_s(uniforms.f[93].xxxx, reg_tmp8);
reg_tmp8.y = (mul_s(uniforms.f[94].zzzz, reg_tmp8.yyyy)).y;
reg_tmp8.y = (uniforms.f[94].zzzz + reg_tmp8.yyyy).y;
reg_tmp2.y = (mul_s(reg_tmp8.xxxx, reg_tmp8.yyyy)).y;
return false;
}
bool sub_9() {
reg_tmp9.z = dot_3(reg_tmp14.xyz, reg_tmp0.xyz);
reg_tmp9.z = (max_s(uniforms.f[93].xxxx, reg_tmp9.zzzz)).z;
reg_tmp9.z = (min_s(uniforms.f[93].yyyy, reg_tmp9.zzzz)).z;
reg_tmp9.z = log2(reg_tmp9.z);
reg_tmp9.z = (mul_s(uniforms.f[22].zzzz, reg_tmp9.zzzz)).z;
reg_tmp9.z = exp2(reg_tmp9.z);
reg_tmp2.z = (mul_s(uniforms.f[22].wwww, reg_tmp9.zzzz)).z;
return false;
}
bool sub_10() {
reg_tmp9.x = dot_3(reg_tmp14.xyz, reg_tmp1.xyz);
reg_tmp9.x = (max_s(uniforms.f[93].xxxx, reg_tmp9.xxxx)).x;
reg_tmp9.x = (min_s(uniforms.f[93].yyyy, reg_tmp9.xxxx)).x;
reg_tmp9.x = (uniforms.f[93].yyyy + -reg_tmp9.xxxx).x;
reg_tmp9.x = log2(reg_tmp9.x);
reg_tmp9.x = (mul_s(uniforms.f[22].xxxx, reg_tmp9.xxxx)).x;
reg_tmp9.x = exp2(reg_tmp9.x);
reg_tmp2.w = (mul_s(uniforms.f[22].yyyy, reg_tmp9.xxxx)).w;
return false;
}
bool sub_12() {
reg_tmp0.xy = (uniforms.f[10].xxxx).xy;
if (uniforms.b[9]) {
sub_13();
} else {
sub_19();
}
return false;
}
bool sub_13() {
sub_14();
reg_tmp3.x = dot_s(uniforms.f[11].xywz, reg_tmp6);
reg_tmp3.y = dot_s(uniforms.f[12].xywz, reg_tmp6);
reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
vs_out_attr4 = reg_tmp3;
return false;
}
bool sub_19() {
bool_regs = equal(uniforms.f[95].xy, reg_tmp0.xy);
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
if (all(not(bool_regs))) {
sub_20();
} else {
sub_21();
}
vs_out_attr4 = reg_tmp3;
return false;
}
bool sub_20() {
reg_tmp6 = reg_tmp10;
reg_tmp3.x = dot_s(uniforms.f[11], reg_tmp6);
reg_tmp3.y = dot_s(uniforms.f[12], reg_tmp6);
reg_tmp3.z = dot_s(uniforms.f[13], reg_tmp6);
reg_tmp0.xy = (mul_s(uniforms.f[19].xyyy, reg_tmp3.zzzz)).xy;
reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
return false;
}
bool sub_21() {
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_22();
} else {
sub_24();
}
return false;
}
bool sub_22() {
sub_23();
reg_tmp3.x = dot_3(uniforms.f[11].xyz, reg_tmp6.xyz);
reg_tmp3.y = dot_3(uniforms.f[12].xyz, reg_tmp6.xyz);
reg_tmp3.z = dot_3(uniforms.f[13].xyz, reg_tmp6.xyz);
return false;
}
bool sub_24() {
sub_25();
reg_tmp3.x = dot_s(uniforms.f[11], reg_tmp6);
reg_tmp3.y = dot_s(uniforms.f[12], reg_tmp6);
return false;
}
bool sub_14() {
bool_regs = equal(uniforms.f[93].yz, reg_tmp0.xy);
if (all(not(bool_regs))) {
sub_15();
} else {
sub_16();
}
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
return false;
}
bool sub_15() {
reg_tmp6.xy = (mul_s(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
return false;
}
bool sub_16() {
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_17();
} else {
sub_18();
}
return false;
}
bool sub_17() {
reg_tmp6.xy = (mul_s(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
return false;
}
bool sub_18() {
reg_tmp6.xy = (mul_s(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
return false;
}
bool sub_23() {
reg_tmp2 = -reg_tmp15;
reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
reg_tmp2.w = rsq_s(reg_tmp2.w);
reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
reg_tmp1 = reg_tmp1 + reg_tmp1;
reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
return false;
}
bool sub_25() {
reg_tmp1.xy = (uniforms.f[94].zzzz).xy;
reg_tmp1.zw = (uniforms.f[93].xxxx).zw;
reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
reg_tmp6.x = rsq_s(reg_tmp6.x);
reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp6 = fma_s(reg_tmp14, reg_tmp1, reg_tmp1);
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
return false;
}
bool sub_26() {
reg_tmp0.xy = (uniforms.f[10].yyyy).xy;
if (uniforms.b[10]) {
sub_27();
} else {
sub_28();
}
return false;
}
bool sub_27() {
sub_14();
reg_tmp4.x = dot_s(uniforms.f[14].xywz, reg_tmp6);
reg_tmp4.y = dot_s(uniforms.f[15].xywz, reg_tmp6);
vs_out_attr5 = reg_tmp4;
return false;
}
bool sub_28() {
if (uniforms.b[13]) {
sub_29();
} else {
sub_32();
}
return false;
}
bool sub_29() {
bool_regs = equal(uniforms.f[95].xy, reg_tmp0.xy);
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
if (all(not(bool_regs))) {
sub_30();
} else {
sub_31();
}
vs_out_attr5 = reg_tmp4;
return false;
}
bool sub_30() {
reg_tmp6 = reg_tmp10;
reg_tmp4.x = dot_s(uniforms.f[14], reg_tmp6);
reg_tmp4.y = dot_s(uniforms.f[15], reg_tmp6);
reg_tmp4.z = dot_s(uniforms.f[16], reg_tmp6);
reg_tmp6.w = rcp_s(reg_tmp4.z);
reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
reg_tmp4.xy = (uniforms.f[19].zwww + reg_tmp4.xyyy).xy;
return false;
}
bool sub_31() {
sub_25();
reg_tmp4.x = dot_s(uniforms.f[14], reg_tmp6);
reg_tmp4.y = dot_s(uniforms.f[15], reg_tmp6);
return false;
}
bool sub_32() {
vs_out_attr5 = uniforms.f[93].xxxx;
return false;
}
bool sub_33() {
reg_tmp0.xy = (uniforms.f[10].zzzz).xy;
if (uniforms.b[11]) {
sub_34();
} else {
sub_35();
}
return false;
}
bool sub_34() {
sub_14();
reg_tmp5.x = dot_s(uniforms.f[17].xywz, reg_tmp6);
reg_tmp5.y = dot_s(uniforms.f[18].xywz, reg_tmp6);
vs_out_attr6 = reg_tmp5;
return false;
}
bool sub_35() {
if (uniforms.b[14]) {
sub_36();
} else {
sub_37();
}
return false;
}
bool sub_36() {
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
reg_tmp5.zw = (reg_tmp6.zwww).zw;
sub_25();
reg_tmp5.x = dot_s(uniforms.f[17], reg_tmp6);
reg_tmp5.y = dot_s(uniforms.f[18], reg_tmp6);
vs_out_attr6 = reg_tmp5;
return false;
}
bool sub_37() {
vs_out_attr6 = uniforms.f[93].xxxx;
return false;
}
bool sub_0() {
sub_1();
if (uniforms.b[6]) {
sub_6();
} else {
sub_11();
}
sub_12();
sub_26();
sub_33();
return true;
}
bool sub_6() {
sub_7();
return false;
}
bool sub_11() {
vs_out_attr3 = uniforms.f[93].yyyy;
return false;
}
bool sub_2() {
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp3.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp3.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp3.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
reg_tmp3.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp3.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp3.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp12);
reg_tmp3.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp3.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp3.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp11 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp11);
reg_tmp3.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp5.xyz);
reg_tmp3.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp5.xyz);
reg_tmp3.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp5.xyz);
reg_tmp9 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp9);
reg_tmp3.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp6.xyz);
reg_tmp3.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp6.xyz);
reg_tmp3.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp6.xyz);
reg_tmp8 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp8);
return false;
}
bool sub_4() {
reg_tmp0.xyz = (mul_s(reg_tmp9.yzxx, reg_tmp8.zxyy)).xyz;
reg_tmp0.xyz = (fma_s(-reg_tmp8.yzxx, reg_tmp9.zxyy, reg_tmp0)).xyz;
reg_tmp1 = uniforms.f[23];
reg_tmp2.x = dot_s(reg_tmp1.xyzz, reg_tmp1.xyzz);
reg_tmp2.x = rsq_s(reg_tmp2.x);
reg_tmp2.xyz = (mul_s(reg_tmp1.xyzz, reg_tmp2.xxxx)).xyz;
reg_tmp1.x = dot_3(reg_tmp2.xyz, reg_tmp8.xyz);
reg_tmp1.y = dot_3(reg_tmp2.xyz, reg_tmp0.xyz);
reg_tmp1.z = dot_3(reg_tmp2.xyz, reg_tmp9.xyz);
reg_tmp2.x = dot_s(reg_tmp1.xyzz, reg_tmp1.xyzz);
reg_tmp2.x = rsq_s(reg_tmp2.x);
reg_tmp2.xyz = (mul_s(reg_tmp1.xyzz, reg_tmp2.xxxx)).xyz;
reg_tmp2.w = (uniforms.f[93].yyyy).w;
vs_out_attr2 = reg_tmp2;
return false;
}
bool sub_1() {
reg_tmp15.xyz = (mul_s(uniforms.f[7].xxxx, vs_in_reg0)).xyz;
reg_tmp14.xyz = (mul_s(uniforms.f[7].yyyy, vs_in_reg1)).xyz;
reg_tmp13.xyz = (mul_s(uniforms.f[7].zzzz, vs_in_reg2)).xyz;
reg_tmp15.xyz = (uniforms.f[6] + reg_tmp15).xyz;
reg_tmp15.w = (uniforms.f[93].yyyy).w;
reg_tmp5 = uniforms.f[93].xxyy;
reg_tmp6 = uniforms.f[93].yxxy;
reg_tmp7 = uniforms.f[93].xxxx;
reg_tmp12 = uniforms.f[93].xxxx;
reg_tmp11 = uniforms.f[93].xxxx;
reg_tmp9 = uniforms.f[93].xxxx;
reg_tmp8 = uniforms.f[93].xxxx;
reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
bool_regs = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
reg_tmp1.xy = (reg_tmp2.xxxx).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
sub_2();
reg_tmp1.xy = (reg_tmp2.yyyy).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
sub_2();
reg_tmp1.xy = (reg_tmp2.zzzz).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
if (bool_regs.x) {
sub_2();
}
if (uniforms.b[8]) {
sub_3();
}
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10 = reg_tmp7;
reg_tmp13.x = dot_3(uniforms.f[3].xyz, reg_tmp11.xyz);
reg_tmp13.y = dot_3(uniforms.f[4].xyz, reg_tmp11.xyz);
reg_tmp13.z = dot_3(uniforms.f[5].xyz, reg_tmp11.xyz);
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
sub_4();
vs_out_attr1 = uniforms.f[93].xxxy;
reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
reg_tmp1.x = (-reg_tmp0.wwww).x;
reg_tmp1.y = (mul_s(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
bool_regs.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
bool_regs.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
if (all(bool_regs)) {
sub_5();
}
vs_out_attr0 = reg_tmp0;
return false;
}
bool sub_3() {
reg_tmp1.xy = (reg_tmp2.wwww).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
if (bool_regs.y) {
sub_2();
}
return false;
}
bool sub_5() {
reg_tmp0.x = (-reg_tmp0.wwww).x;
return false;
}
// reference: F2378FBBC7F0716C, C9DB819577AE2179
// program: C9DB819577AE2179, EADA2116091C5E01, 2385CCAFF1B43030
// program: C9DB819577AE2179, EADA2116091C5E01, 6AE6BDA06561AFE5
// program: C9DB819577AE2179, EADA2116091C5E01, 8A4ED6F49BB0A314
// program: C9DB819577AE2179, EADA2116091C5E01, 333023FE25AF3950
// program: AEF4EEAE6F9585E0, F777123A8C3D5E20, 7BD9DD75396B6EAD
// program: AEF4EEAE6F9585E0, F777123A8C3D5E20, B69FA15109672E1C
// program: C9DB819577AE2179, EADA2116091C5E01, 8D56B0D64926E396
// program: C9DB819577AE2179, EADA2116091C5E01, 289527836A86E733
// shader: 8B30, 67045B004219C3ED
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))) + tex_lod_bias[2]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((vec3(1) - texcolor0.rrr) - (vec3(1) - texcolor1.rrr), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((1.0 - texcolor0.r) - (1.0 - texcolor2.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0 * 4.0, alpha_output_0 * 4.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) + (last_tex_env_out.aaa), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1 * 4.0, alpha_output_1 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2 * 4.0, alpha_output_2 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = byteround(clamp((vec3(1) - texcolor0.rgb) * (const_color[3].rgb), vec3(0), vec3(1)));
float alpha_output_3 = byteround(clamp((texcolor0.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_4 = byteround(clamp((texcolor0.rgb) * (const_color[4].rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_4 = byteround(clamp((1.0 - texcolor0.a) * (const_color[4].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (const_color[5].rgb), vec3(0), vec3(1)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (const_color[5].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
if (last_tex_env_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: B1A8721F7CAA016D, 67045B004219C3ED
// program: 4DBF54CC7897BA20, B6B95AFD9466EC70, 67045B004219C3ED
// shader: 8B30, 1A215544E086A7A4
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))) + tex_lod_bias[2]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((vec3(1) - texcolor0.rrr) - (vec3(1) - texcolor1.rrr), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((1.0 - texcolor0.r) - (1.0 - texcolor2.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0 * 4.0, alpha_output_0 * 4.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) + (last_tex_env_out.aaa), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1 * 4.0, alpha_output_1 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2 * 4.0, alpha_output_2 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = byteround(clamp((vec3(1) - texcolor0.rgb) * (const_color[3].rgb), vec3(0), vec3(1)));
float alpha_output_3 = byteround(clamp((texcolor0.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_4 = byteround(clamp((texcolor0.rgb) * (const_color[4].rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_4 = byteround(clamp((1.0 - texcolor0.a) * (const_color[4].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_5 = (rounded_primary_color.rgb);
float alpha_output_5 = (rounded_primary_color.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 436848526BF36D51, 1A215544E086A7A4
// program: 0000000000000000, 0000000000000000, 1A215544E086A7A4
// program: AEF4EEAE6F9585E0, F777123A8C3D5E20, 0AB8BDAA1E48628C
// program: AEF4EEAE6F9585E0, F777123A8C3D5E20, 11F75D1954448C2C
// program: AEF4EEAE6F9585E0, F777123A8C3D5E20, 5A216962B0AC0396
// program: AEF4EEAE6F9585E0, F777123A8C3D5E20, 61971FB2D7BF35C1
// program: AEF4EEAE6F9585E0, F777123A8C3D5E20, EC963DCE3A5CC151
// shader: 8B31, 5A04B7D2F3342460

#define mul_s(x, y) mix(x * y, vec4(0), isnan(x * y))
#define mul_3(x, y) mix(x * y, vec3(0), isnan(x * y))
#define fma_s(x, y, z) (mul_s(x, y) + z)
#define dot_s(x, y) dot(mul_s(x, y), vec4(1))
#define dot_3(x, y) dot(mul_3(x, y), vec3(1))

float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x == 0.0) return x;
    return inversesqrt(x);
}

#define min_s(x, y) min(x, y)
#define max_s(x, y) max(x, y)

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout(binding=2, std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location=0) in vec4 vs_in_reg0;
layout(location=1) in vec4 vs_in_reg1;
layout(location=2) in vec4 vs_in_reg2;
layout(location=3) in vec4 vs_in_reg3;
layout(location=4) in vec4 vs_in_reg4;
layout(location=5) in vec4 vs_in_reg5;
layout(location=6) in vec4 vs_in_reg6;
layout(location=7) in vec4 vs_in_reg7;
layout(location=8) in vec4 vs_in_reg8;

layout(location=0) out vec4 vs_out_attr0;
layout(location=1) out vec4 vs_out_attr1;
layout(location=2) out vec4 vs_out_attr2;
layout(location=3) out vec4 vs_out_attr3;
layout(location=4) out vec4 vs_out_attr4;
layout(location=5) out vec4 vs_out_attr5;
layout(location=6) out vec4 vs_out_attr6;

void main() {
vs_out_attr0 = vec4(0, 0, 0, 1);
vs_out_attr1 = vec4(0, 0, 0, 1);
vs_out_attr2 = vec4(0, 0, 0, 1);
vs_out_attr3 = vec4(0, 0, 0, 1);
vs_out_attr4 = vec4(0, 0, 0, 1);
vs_out_attr5 = vec4(0, 0, 0, 1);
vs_out_attr6 = vec4(0, 0, 0, 1);
exec_shader();
}
bvec2 bool_regs = bvec2(false);
ivec3 addr_regs = ivec3(0);
vec4 reg_tmp0 = vec4(0, 0, 0, 1);
vec4 reg_tmp1 = vec4(0, 0, 0, 1);
vec4 reg_tmp2 = vec4(0, 0, 0, 1);
vec4 reg_tmp3 = vec4(0, 0, 0, 1);
vec4 reg_tmp4 = vec4(0, 0, 0, 1);
vec4 reg_tmp5 = vec4(0, 0, 0, 1);
vec4 reg_tmp6 = vec4(0, 0, 0, 1);
vec4 reg_tmp7 = vec4(0, 0, 0, 1);
vec4 reg_tmp8 = vec4(0, 0, 0, 1);
vec4 reg_tmp9 = vec4(0, 0, 0, 1);
vec4 reg_tmp10 = vec4(0, 0, 0, 1);
vec4 reg_tmp11 = vec4(0, 0, 0, 1);
vec4 reg_tmp12 = vec4(0, 0, 0, 1);
vec4 reg_tmp13 = vec4(0, 0, 0, 1);
vec4 reg_tmp14 = vec4(0, 0, 0, 1);
vec4 reg_tmp15 = vec4(0, 0, 0, 1);

bool sub_21();
bool sub_4();
bool sub_9();
bool sub_1();
bool sub_2();
bool sub_3();
bool sub_5();
bool sub_7();
bool sub_8();
bool sub_10();
bool sub_20();
bool sub_22();
bool sub_23();
bool sub_24();
bool sub_25();
bool sub_26();
bool sub_27();
bool sub_28();
bool sub_29();
bool sub_6();
bool sub_11();
bool sub_12();
bool sub_13();
bool sub_14();
bool sub_15();
bool sub_16();
bool sub_17();
bool sub_18();
bool sub_19();
bool sub_0();
bool sub_30();
bool sub_31();
bool sub_32();
bool sub_33();
bool sub_34();
bool sub_35();
bool sub_36();
bool sub_37();
bool sub_38();
bool sub_39();
bool sub_40();
bool sub_41();
bool sub_42();
bool sub_43();
bool sub_44();
bool sub_45();
bool sub_46();

bool exec_shader() {
sub_0();
return true;
}

bool sub_21() {
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp3.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp3.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp3.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
return false;
}
bool sub_4() {
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp3.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp3.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp3.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp4.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
return false;
}
bool sub_9() {
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp3.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp3.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp3.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp4.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp5.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp5.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp5.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
reg_tmp11 = fma_s(reg_tmp1.wwww, reg_tmp5, reg_tmp11);
return false;
}
bool sub_1() {
reg_tmp15.xyz = (mul_s(uniforms.f[7].xxxx, vs_in_reg0)).xyz;
reg_tmp14.xyz = (mul_s(uniforms.f[7].yyyy, vs_in_reg1)).xyz;
reg_tmp13.xyz = (mul_s(uniforms.f[7].zzzz, vs_in_reg2)).xyz;
reg_tmp15.xyz = (uniforms.f[6] + reg_tmp15).xyz;
reg_tmp15.w = (uniforms.f[93].yyyy).w;
if (uniforms.b[1]) {
sub_2();
} else {
sub_23();
}
return false;
}
bool sub_2() {
reg_tmp0 = uniforms.f[7];
bool_regs = notEqual(uniforms.f[93].xx, reg_tmp0.yz);
reg_tmp7 = uniforms.f[93].xxxx;
reg_tmp12 = uniforms.f[93].xxxx;
reg_tmp11 = uniforms.f[93].xxxx;
reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_3();
} else {
sub_7();
}
vs_out_attr2 = -reg_tmp15;
vs_out_attr0.x = dot_s(uniforms.f[86], reg_tmp15);
vs_out_attr0.y = dot_s(uniforms.f[87], reg_tmp15);
vs_out_attr0.z = dot_s(uniforms.f[88], reg_tmp15);
vs_out_attr0.w = dot_s(uniforms.f[89], reg_tmp15);
return false;
}
bool sub_3() {
bool_regs = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
reg_tmp1.xy = (reg_tmp2.xxxx).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
sub_4();
reg_tmp1.xy = (reg_tmp2.yyyy).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
sub_4();
reg_tmp1.xy = (reg_tmp2.zzzz).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
if (bool_regs.x) {
sub_4();
}
if (uniforms.b[8]) {
sub_5();
}
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
sub_6();
return false;
}
bool sub_5() {
reg_tmp1.xy = (reg_tmp2.wwww).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
if (bool_regs.y) {
sub_4();
}
return false;
}
bool sub_7() {
if (all(bool_regs)) {
sub_8();
} else {
sub_20();
}
return false;
}
bool sub_8() {
bool_regs = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
reg_tmp1.xy = (reg_tmp2.xxxx).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
sub_9();
reg_tmp1.xy = (reg_tmp2.yyyy).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
sub_9();
reg_tmp1.xy = (reg_tmp2.zzzz).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
if (bool_regs.x) {
sub_9();
}
if (uniforms.b[8]) {
sub_10();
}
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp13.x = dot_3(uniforms.f[3].xyz, reg_tmp11.xyz);
reg_tmp13.y = dot_3(uniforms.f[4].xyz, reg_tmp11.xyz);
reg_tmp13.z = dot_3(uniforms.f[5].xyz, reg_tmp11.xyz);
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
sub_11();
return false;
}
bool sub_10() {
reg_tmp1.xy = (reg_tmp2.wwww).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
if (bool_regs.y) {
sub_9();
}
return false;
}
bool sub_20() {
bool_regs = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
reg_tmp1.xy = (reg_tmp2.xxxx).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
sub_21();
reg_tmp1.xy = (reg_tmp2.yyyy).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
sub_21();
reg_tmp1.xy = (reg_tmp2.zzzz).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
if (bool_regs.x) {
sub_21();
}
if (uniforms.b[8]) {
sub_22();
}
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
vs_out_attr1 = uniforms.f[93].xxxx;
return false;
}
bool sub_22() {
reg_tmp1.xy = (reg_tmp2.wwww).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
if (bool_regs.y) {
sub_21();
}
return false;
}
bool sub_23() {
reg_tmp0 = uniforms.f[7];
bool_regs = notEqual(uniforms.f[93].xx, reg_tmp0.yz);
if (uniforms.b[2]) {
sub_24();
} else {
sub_25();
}
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_26();
} else {
sub_27();
}
vs_out_attr2 = -reg_tmp15;
vs_out_attr0.x = dot_s(uniforms.f[86], reg_tmp15);
vs_out_attr0.y = dot_s(uniforms.f[87], reg_tmp15);
vs_out_attr0.z = dot_s(uniforms.f[88], reg_tmp15);
vs_out_attr0.w = dot_s(uniforms.f[89], reg_tmp15);
return false;
}
bool sub_24() {
reg_tmp1.x = (mul_s(uniforms.f[93].wwww, vs_in_reg7.xxxx)).x;
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp7.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp7.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp7.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
return false;
}
bool sub_25() {
addr_regs.x = (ivec2(uniforms.f[93].xx)).x;
reg_tmp10.x = dot_s(uniforms.f[25], reg_tmp15);
reg_tmp10.y = dot_s(uniforms.f[26], reg_tmp15);
reg_tmp10.z = dot_s(uniforms.f[27], reg_tmp15);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
return false;
}
bool sub_26() {
reg_tmp12.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
sub_6();
return false;
}
bool sub_27() {
if (all(bool_regs)) {
sub_28();
} else {
sub_29();
}
return false;
}
bool sub_28() {
reg_tmp12.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp11.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp11.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp11.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
reg_tmp13.x = dot_3(uniforms.f[3].xyz, reg_tmp11.xyz);
reg_tmp13.y = dot_3(uniforms.f[4].xyz, reg_tmp11.xyz);
reg_tmp13.z = dot_3(uniforms.f[5].xyz, reg_tmp11.xyz);
sub_11();
return false;
}
bool sub_29() {
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
vs_out_attr1 = uniforms.f[93].xxxx;
return false;
}
bool sub_6() {
uint jmp_to = 251u;
while (true) {
switch (jmp_to) {
case 251u:
reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
reg_tmp6.x = rsq_s(reg_tmp6.x);
reg_tmp7.x = rsq_s(reg_tmp7.x);
reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp0 = uniforms.f[93].yxxx;
if (!uniforms.b[15]) {
jmp_to = 267u; break;
}
reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
reg_tmp4 = mul_s(uniforms.f[94].zzzz, reg_tmp4);
bool_regs = greaterThanEqual(uniforms.f[93].xx, reg_tmp4.xx);
reg_tmp4 = vec4(rsq_s(reg_tmp4.x));
reg_tmp5 = mul_s(uniforms.f[94].zzzz, reg_tmp14);
if (bool_regs.x) {
jmp_to = 267u; break;
}
reg_tmp0.z = rcp_s(reg_tmp4.x);
reg_tmp0.xy = (mul_s(reg_tmp5, reg_tmp4)).xy;
case 267u:
vs_out_attr1 = reg_tmp0;
default: return false;
}
}
return false;
}
bool sub_11() {
uint jmp_to = 268u;
while (true) {
switch (jmp_to) {
case 268u:
reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
reg_tmp6.x = rsq_s(reg_tmp6.x);
reg_tmp7.x = rsq_s(reg_tmp7.x);
reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp13.xyz = (mul_s(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp11.xyz = (mul_s(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp0 = uniforms.f[93].yxxx;
if (!uniforms.b[15]) {
jmp_to = 343u; break;
}
reg_tmp13.xyz = (mul_s(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp11.xyz = (mul_s(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp5 = mul_s(reg_tmp14.yzxx, reg_tmp13.zxyy);
reg_tmp5 = fma_s(-reg_tmp13.yzxx, reg_tmp14.zxyy, reg_tmp5);
reg_tmp5.w = dot_3(reg_tmp5.xyz, reg_tmp5.xyz);
reg_tmp5.w = rsq_s(reg_tmp5.w);
reg_tmp5 = mul_s(reg_tmp5, reg_tmp5.wwww);
reg_tmp6.w = (reg_tmp14.zzzz + reg_tmp5.yyyy).w;
reg_tmp13 = mul_s(reg_tmp5.yzxx, reg_tmp14.zxyy);
reg_tmp13 = fma_s(-reg_tmp14.yzxx, reg_tmp5.zxyy, reg_tmp13);
reg_tmp6.w = (reg_tmp13.xxxx + reg_tmp6).w;
reg_tmp13.w = (reg_tmp5.zzzz).w;
reg_tmp5.z = (reg_tmp13.xxxx).z;
reg_tmp6.w = (uniforms.f[93].yyyy + reg_tmp6).w;
reg_tmp14.w = (reg_tmp5.xxxx).w;
reg_tmp5.x = (reg_tmp14.zzzz).x;
bool_regs = lessThan(uniforms.f[94].yy, reg_tmp6.ww);
reg_tmp6.x = (uniforms.f[93].yyyy).x;
reg_tmp6.y = (-uniforms.f[93].yyyy).y;
if (!bool_regs.x) {
jmp_to = 305u; break;
}
reg_tmp7.xz = (reg_tmp13.wwyy + -reg_tmp14.yyww).xz;
reg_tmp7.y = (reg_tmp14.xxxx + -reg_tmp13.zzzz).y;
reg_tmp7.w = (reg_tmp6).w;
reg_tmp6 = vec4(dot_s(reg_tmp7, reg_tmp7));
reg_tmp6 = vec4(rsq_s(reg_tmp6.x));
reg_tmp0 = mul_s(reg_tmp7, reg_tmp6);
if (uniforms.b[0]) {
jmp_to = 343u; break;
}
case 305u:
bool_regs = greaterThan(reg_tmp5.zy, reg_tmp5.yx);
if (bool_regs.x) {
sub_12();
} else {
sub_17();
}
reg_tmp6 = vec4(dot_s(reg_tmp8, reg_tmp8));
reg_tmp6 = vec4(rsq_s(reg_tmp6.x));
reg_tmp0 = mul_s(reg_tmp8, reg_tmp6);
case 343u:
vs_out_attr1 = reg_tmp0;
default: return false;
}
}
return false;
}
bool sub_12() {
if (bool_regs.y) {
sub_13();
} else {
sub_14();
}
reg_tmp8.w = (-reg_tmp8).w;
return false;
}
bool sub_13() {
reg_tmp8 = mul_s(reg_tmp13.yyzw, reg_tmp6.xxxy);
reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
return false;
}
bool sub_14() {
bool_regs = greaterThan(reg_tmp5.zz, reg_tmp5.xx);
reg_tmp8 = mul_s(reg_tmp13.yyzw, reg_tmp6.xxxy);
reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
if (bool_regs.x) {
sub_15();
} else {
sub_16();
}
return false;
}
bool sub_15() {
reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
return false;
}
bool sub_16() {
reg_tmp8 = mul_s(reg_tmp13.zwwy, reg_tmp6.xxxy);
reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
return false;
}
bool sub_17() {
if (bool_regs.y) {
sub_18();
} else {
sub_19();
}
return false;
}
bool sub_18() {
reg_tmp8 = mul_s(reg_tmp13.yywz, reg_tmp6.xxxy);
reg_tmp8.y = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).y;
reg_tmp9 = reg_tmp5.yyyy + -reg_tmp5.xxxx;
reg_tmp8.xzw = (reg_tmp8 + reg_tmp14.wwyx).xzw;
reg_tmp8.y = (reg_tmp9 + reg_tmp8).y;
return false;
}
bool sub_19() {
reg_tmp8 = mul_s(reg_tmp13.zwwy, reg_tmp6.xxxy);
reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
reg_tmp8.w = (-reg_tmp8).w;
return false;
}
bool sub_0() {
sub_1();
reg_tmp8.xy = (uniforms.f[93].xxxx).xy;
reg_tmp0.y = (uniforms.f[7].wwww).y;
bool_regs = notEqual(uniforms.f[93].xx, reg_tmp0.xy);
reg_tmp9.xyz = (uniforms.f[93].xxxx).xyz;
reg_tmp9.w = (uniforms.f[21].wwww).w;
if (bool_regs.y) {
sub_30();
}
bool_regs = equal(uniforms.f[93].xx, reg_tmp8.xy);
if (all(bool_regs)) {
sub_32();
}
vs_out_attr3 = max_s(uniforms.f[93].xxxx, reg_tmp9);
reg_tmp0.xy = (uniforms.f[10].xxxx).xy;
if (uniforms.b[9]) {
sub_33();
} else {
sub_38();
}
reg_tmp0.xy = (uniforms.f[10].yyyy).xy;
bool_regs = equal(uniforms.f[93].yz, reg_tmp0.xy);
if (all(not(bool_regs))) {
sub_39();
} else {
sub_40();
}
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
reg_tmp4.x = dot_s(uniforms.f[14].xywz, reg_tmp6);
reg_tmp4.y = dot_s(uniforms.f[15].xywz, reg_tmp6);
vs_out_attr5 = reg_tmp4;
reg_tmp0.xy = (uniforms.f[10].zzzz).xy;
bool_regs = equal(uniforms.f[93].yz, reg_tmp0.xy);
if (all(not(bool_regs))) {
sub_43();
} else {
sub_44();
}
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
reg_tmp5.x = dot_s(uniforms.f[17].xywz, reg_tmp6);
reg_tmp5.y = dot_s(uniforms.f[18].xywz, reg_tmp6);
vs_out_attr6 = reg_tmp5;
return true;
}
bool sub_30() {
reg_tmp0 = mul_s(uniforms.f[7].wwww, vs_in_reg3);
if (uniforms.b[7]) {
sub_31();
}
reg_tmp9.xyz = (mul_s(uniforms.f[20].wwww, reg_tmp0.xyzz)).xyz;
reg_tmp8.x = (uniforms.f[93].yyyy).x;
return false;
}
bool sub_31() {
reg_tmp9.w = (mul_s(reg_tmp9.wwww, reg_tmp0.wwww)).w;
return false;
}
bool sub_32() {
reg_tmp9 = uniforms.f[21];
return false;
}
bool sub_33() {
bool_regs = equal(uniforms.f[93].yz, reg_tmp0.xy);
if (all(not(bool_regs))) {
sub_34();
} else {
sub_35();
}
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
reg_tmp3.x = dot_s(uniforms.f[11].xywz, reg_tmp6);
reg_tmp3.y = dot_s(uniforms.f[12].xywz, reg_tmp6);
reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
vs_out_attr4 = reg_tmp3;
return false;
}
bool sub_34() {
reg_tmp6.xy = (mul_s(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
return false;
}
bool sub_35() {
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_36();
} else {
sub_37();
}
return false;
}
bool sub_36() {
reg_tmp6.xy = (mul_s(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
return false;
}
bool sub_37() {
reg_tmp6.xy = (mul_s(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
return false;
}
bool sub_38() {
bool_regs = equal(uniforms.f[95].xy, reg_tmp0.xy);
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
reg_tmp6 = reg_tmp10;
reg_tmp3.x = dot_s(uniforms.f[11], reg_tmp6);
reg_tmp3.y = dot_s(uniforms.f[12], reg_tmp6);
reg_tmp3.z = dot_s(uniforms.f[13], reg_tmp6);
reg_tmp0.xy = (mul_s(uniforms.f[19].xyyy, reg_tmp3.zzzz)).xy;
reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
vs_out_attr4 = reg_tmp3;
return false;
}
bool sub_39() {
reg_tmp6.xy = (mul_s(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
return false;
}
bool sub_40() {
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_41();
} else {
sub_42();
}
return false;
}
bool sub_41() {
reg_tmp6.xy = (mul_s(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
return false;
}
bool sub_42() {
reg_tmp6.xy = (mul_s(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
return false;
}
bool sub_43() {
reg_tmp6.xy = (mul_s(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
return false;
}
bool sub_44() {
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_45();
} else {
sub_46();
}
return false;
}
bool sub_45() {
reg_tmp6.xy = (mul_s(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
return false;
}
bool sub_46() {
reg_tmp6.xy = (mul_s(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
return false;
}
// reference: EC3CAA1D015D5B8A, 5A04B7D2F3342460
// program: 5A04B7D2F3342460, EADA2116091C5E01, EC963DCE3A5CC151
// shader: 8B31, 37194F1D205A4454

#define mul_s(x, y) mix(x * y, vec4(0), isnan(x * y))
#define mul_3(x, y) mix(x * y, vec3(0), isnan(x * y))
#define fma_s(x, y, z) (mul_s(x, y) + z)
#define dot_s(x, y) dot(mul_s(x, y), vec4(1))
#define dot_3(x, y) dot(mul_3(x, y), vec3(1))

float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x == 0.0) return x;
    return inversesqrt(x);
}

#define min_s(x, y) min(x, y)
#define max_s(x, y) max(x, y)

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout(binding=2, std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location=0) in vec4 vs_in_reg0;
layout(location=1) in vec4 vs_in_reg1;
layout(location=2) in vec4 vs_in_reg2;
layout(location=3) in vec4 vs_in_reg3;
layout(location=4) in vec4 vs_in_reg4;
layout(location=5) in vec4 vs_in_reg5;
layout(location=6) in vec4 vs_in_reg6;
layout(location=7) in vec4 vs_in_reg7;
layout(location=8) in vec4 vs_in_reg8;

layout(location=0) out vec4 vs_out_attr0;
layout(location=1) out vec4 vs_out_attr1;
layout(location=2) out vec4 vs_out_attr2;
layout(location=3) out vec4 vs_out_attr3;
layout(location=4) out vec4 vs_out_attr4;
layout(location=5) out vec4 vs_out_attr5;

void main() {
vs_out_attr0 = vec4(0, 0, 0, 1);
vs_out_attr1 = vec4(0, 0, 0, 1);
vs_out_attr2 = vec4(0, 0, 0, 1);
vs_out_attr3 = vec4(0, 0, 0, 1);
vs_out_attr4 = vec4(0, 0, 0, 1);
vs_out_attr5 = vec4(0, 0, 0, 1);
exec_shader();
}
bvec2 bool_regs = bvec2(false);
ivec3 addr_regs = ivec3(0);
vec4 reg_tmp0 = vec4(0, 0, 0, 1);
vec4 reg_tmp1 = vec4(0, 0, 0, 1);
vec4 reg_tmp2 = vec4(0, 0, 0, 1);
vec4 reg_tmp3 = vec4(0, 0, 0, 1);
vec4 reg_tmp4 = vec4(0, 0, 0, 1);
vec4 reg_tmp5 = vec4(0, 0, 0, 1);
vec4 reg_tmp6 = vec4(0, 0, 0, 1);
vec4 reg_tmp7 = vec4(0, 0, 0, 1);
vec4 reg_tmp8 = vec4(0, 0, 0, 1);
vec4 reg_tmp9 = vec4(0, 0, 0, 1);
vec4 reg_tmp10 = vec4(0, 0, 0, 1);
vec4 reg_tmp11 = vec4(0, 0, 0, 1);
vec4 reg_tmp12 = vec4(0, 0, 0, 1);
vec4 reg_tmp13 = vec4(0, 0, 0, 1);
vec4 reg_tmp14 = vec4(0, 0, 0, 1);
vec4 reg_tmp15 = vec4(0, 0, 0, 1);

bool sub_0();
bool sub_32();
bool sub_33();
bool sub_34();
bool sub_35();
bool sub_36();
bool sub_37();
bool sub_38();
bool sub_39();
bool sub_40();
bool sub_41();
bool sub_42();
bool sub_43();
bool sub_44();
bool sub_21();
bool sub_4();
bool sub_9();
bool sub_1();
bool sub_2();
bool sub_3();
bool sub_5();
bool sub_7();
bool sub_8();
bool sub_10();
bool sub_20();
bool sub_22();
bool sub_23();
bool sub_24();
bool sub_25();
bool sub_26();
bool sub_27();
bool sub_28();
bool sub_29();
bool sub_30();
bool sub_31();
bool sub_6();
bool sub_11();
bool sub_12();
bool sub_13();
bool sub_14();
bool sub_15();
bool sub_16();
bool sub_17();
bool sub_18();
bool sub_19();

bool exec_shader() {
sub_0();
return true;
}

bool sub_0() {
sub_1();
reg_tmp8.xy = (uniforms.f[93].xxxx).xy;
reg_tmp0.y = (uniforms.f[7].wwww).y;
bool_regs = notEqual(uniforms.f[93].xx, reg_tmp0.xy);
reg_tmp9.xyz = (uniforms.f[93].xxxx).xyz;
reg_tmp9.w = (uniforms.f[21].wwww).w;
if (bool_regs.y) {
sub_32();
}
bool_regs = equal(uniforms.f[93].xx, reg_tmp8.xy);
if (all(bool_regs)) {
sub_34();
}
vs_out_attr3 = max_s(uniforms.f[93].xxxx, reg_tmp9);
reg_tmp0.xy = (uniforms.f[10].xxxx).xy;
if (uniforms.b[9]) {
sub_35();
} else {
sub_40();
}
reg_tmp0.xy = (uniforms.f[10].yyyy).xy;
bool_regs = equal(uniforms.f[93].yz, reg_tmp0.xy);
if (all(not(bool_regs))) {
sub_41();
} else {
sub_42();
}
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
reg_tmp4.x = dot_s(uniforms.f[14].xywz, reg_tmp6);
reg_tmp4.y = dot_s(uniforms.f[15].xywz, reg_tmp6);
vs_out_attr5 = reg_tmp4;
return true;
}
bool sub_32() {
reg_tmp0 = mul_s(uniforms.f[7].wwww, vs_in_reg3);
if (uniforms.b[7]) {
sub_33();
}
reg_tmp9.xyz = (mul_s(uniforms.f[20].wwww, reg_tmp0.xyzz)).xyz;
reg_tmp8.x = (uniforms.f[93].yyyy).x;
return false;
}
bool sub_33() {
reg_tmp9.w = (mul_s(reg_tmp9.wwww, reg_tmp0.wwww)).w;
return false;
}
bool sub_34() {
reg_tmp9 = uniforms.f[21];
return false;
}
bool sub_35() {
bool_regs = equal(uniforms.f[93].yz, reg_tmp0.xy);
if (all(not(bool_regs))) {
sub_36();
} else {
sub_37();
}
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
reg_tmp3.x = dot_s(uniforms.f[11].xywz, reg_tmp6);
reg_tmp3.y = dot_s(uniforms.f[12].xywz, reg_tmp6);
reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
vs_out_attr4 = reg_tmp3;
return false;
}
bool sub_36() {
reg_tmp6.xy = (mul_s(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
return false;
}
bool sub_37() {
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_38();
} else {
sub_39();
}
return false;
}
bool sub_38() {
reg_tmp6.xy = (mul_s(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
return false;
}
bool sub_39() {
reg_tmp6.xy = (mul_s(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
return false;
}
bool sub_40() {
bool_regs = equal(uniforms.f[95].xy, reg_tmp0.xy);
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
reg_tmp6 = reg_tmp10;
reg_tmp3.x = dot_s(uniforms.f[11], reg_tmp6);
reg_tmp3.y = dot_s(uniforms.f[12], reg_tmp6);
reg_tmp3.z = dot_s(uniforms.f[13], reg_tmp6);
reg_tmp0.xy = (mul_s(uniforms.f[19].xyyy, reg_tmp3.zzzz)).xy;
reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
vs_out_attr4 = reg_tmp3;
return false;
}
bool sub_41() {
reg_tmp6.xy = (mul_s(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
return false;
}
bool sub_42() {
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_43();
} else {
sub_44();
}
return false;
}
bool sub_43() {
reg_tmp6.xy = (mul_s(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
return false;
}
bool sub_44() {
reg_tmp6.xy = (mul_s(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
return false;
}
bool sub_21() {
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp3.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp3.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp3.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
return false;
}
bool sub_4() {
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp3.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp3.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp3.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp4.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
return false;
}
bool sub_9() {
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp3.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp3.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp3.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp4.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp5.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp5.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp5.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
reg_tmp11 = fma_s(reg_tmp1.wwww, reg_tmp5, reg_tmp11);
return false;
}
bool sub_1() {
reg_tmp15.xyz = (mul_s(uniforms.f[7].xxxx, vs_in_reg0)).xyz;
reg_tmp14.xyz = (mul_s(uniforms.f[7].yyyy, vs_in_reg1)).xyz;
reg_tmp13.xyz = (mul_s(uniforms.f[7].zzzz, vs_in_reg2)).xyz;
reg_tmp15.xyz = (uniforms.f[6] + reg_tmp15).xyz;
reg_tmp15.w = (uniforms.f[93].yyyy).w;
if (uniforms.b[1]) {
sub_2();
} else {
sub_24();
}
return false;
}
bool sub_2() {
reg_tmp0 = uniforms.f[7];
bool_regs = notEqual(uniforms.f[93].xx, reg_tmp0.yz);
reg_tmp7 = uniforms.f[93].xxxx;
reg_tmp12 = uniforms.f[93].xxxx;
reg_tmp11 = uniforms.f[93].xxxx;
reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_3();
} else {
sub_7();
}
vs_out_attr2 = -reg_tmp15;
reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
reg_tmp1.x = (-reg_tmp0.wwww).x;
reg_tmp1.y = (mul_s(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
bool_regs.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
bool_regs.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
if (all(bool_regs)) {
sub_23();
}
vs_out_attr0 = reg_tmp0;
return false;
}
bool sub_3() {
bool_regs = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
reg_tmp1.xy = (reg_tmp2.xxxx).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
sub_4();
reg_tmp1.xy = (reg_tmp2.yyyy).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
sub_4();
reg_tmp1.xy = (reg_tmp2.zzzz).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
if (bool_regs.x) {
sub_4();
}
if (uniforms.b[8]) {
sub_5();
}
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp7 = reg_tmp10;
reg_tmp10.x = dot_s(uniforms.f[22], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[23], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[24], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
sub_6();
return false;
}
bool sub_5() {
reg_tmp1.xy = (reg_tmp2.wwww).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
if (bool_regs.y) {
sub_4();
}
return false;
}
bool sub_7() {
if (all(bool_regs)) {
sub_8();
} else {
sub_20();
}
return false;
}
bool sub_8() {
bool_regs = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
reg_tmp1.xy = (reg_tmp2.xxxx).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
sub_9();
reg_tmp1.xy = (reg_tmp2.yyyy).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
sub_9();
reg_tmp1.xy = (reg_tmp2.zzzz).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
if (bool_regs.x) {
sub_9();
}
if (uniforms.b[8]) {
sub_10();
}
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp7 = reg_tmp10;
reg_tmp10.x = dot_s(uniforms.f[22], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[23], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[24], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp13.x = dot_3(uniforms.f[3].xyz, reg_tmp11.xyz);
reg_tmp13.y = dot_3(uniforms.f[4].xyz, reg_tmp11.xyz);
reg_tmp13.z = dot_3(uniforms.f[5].xyz, reg_tmp11.xyz);
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
sub_11();
return false;
}
bool sub_10() {
reg_tmp1.xy = (reg_tmp2.wwww).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
if (bool_regs.y) {
sub_9();
}
return false;
}
bool sub_20() {
bool_regs = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
reg_tmp1.xy = (reg_tmp2.xxxx).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
sub_21();
reg_tmp1.xy = (reg_tmp2.yyyy).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
sub_21();
reg_tmp1.xy = (reg_tmp2.zzzz).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
if (bool_regs.x) {
sub_21();
}
if (uniforms.b[8]) {
sub_22();
}
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp7 = reg_tmp10;
reg_tmp10.x = dot_s(uniforms.f[22], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[23], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[24], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
vs_out_attr1 = uniforms.f[93].xxxx;
return false;
}
bool sub_22() {
reg_tmp1.xy = (reg_tmp2.wwww).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
if (bool_regs.y) {
sub_21();
}
return false;
}
bool sub_23() {
reg_tmp0.x = (-reg_tmp0.wwww).x;
return false;
}
bool sub_24() {
if (uniforms.b[2]) {
sub_25();
} else {
sub_26();
}
reg_tmp0 = uniforms.f[7];
bool_regs = notEqual(uniforms.f[93].xx, reg_tmp0.yz);
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_27();
} else {
sub_28();
}
vs_out_attr2 = -reg_tmp15;
reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
reg_tmp1.x = (-reg_tmp0.wwww).x;
reg_tmp1.y = (mul_s(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
bool_regs.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
bool_regs.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
if (all(bool_regs)) {
sub_31();
}
vs_out_attr0 = reg_tmp0;
return false;
}
bool sub_25() {
reg_tmp1.x = (mul_s(uniforms.f[93].wwww, vs_in_reg7.xxxx)).x;
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp7.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp7.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp7.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
return false;
}
bool sub_26() {
addr_regs.x = (ivec2(uniforms.f[93].xx)).x;
reg_tmp10.x = dot_s(uniforms.f[25], reg_tmp15);
reg_tmp10.y = dot_s(uniforms.f[26], reg_tmp15);
reg_tmp10.z = dot_s(uniforms.f[27], reg_tmp15);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
return false;
}
bool sub_27() {
reg_tmp12.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp7 = reg_tmp10;
reg_tmp10.x = dot_s(uniforms.f[22], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[23], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[24], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
sub_6();
return false;
}
bool sub_28() {
if (all(bool_regs)) {
sub_29();
} else {
sub_30();
}
return false;
}
bool sub_29() {
reg_tmp12.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp11.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp11.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp11.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp7 = reg_tmp10;
reg_tmp10.x = dot_s(uniforms.f[22], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[23], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[24], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
reg_tmp13.x = dot_3(uniforms.f[3].xyz, reg_tmp11.xyz);
reg_tmp13.y = dot_3(uniforms.f[4].xyz, reg_tmp11.xyz);
reg_tmp13.z = dot_3(uniforms.f[5].xyz, reg_tmp11.xyz);
sub_11();
return false;
}
bool sub_30() {
reg_tmp7 = reg_tmp10;
reg_tmp10.x = dot_s(uniforms.f[22], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[23], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[24], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
vs_out_attr1 = uniforms.f[93].xxxx;
return false;
}
bool sub_31() {
reg_tmp0.x = (-reg_tmp0.wwww).x;
return false;
}
bool sub_6() {
uint jmp_to = 293u;
while (true) {
switch (jmp_to) {
case 293u:
reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
reg_tmp6.x = rsq_s(reg_tmp6.x);
reg_tmp7.x = rsq_s(reg_tmp7.x);
reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp0 = uniforms.f[93].yxxx;
if (!uniforms.b[15]) {
jmp_to = 309u; break;
}
reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
reg_tmp4 = mul_s(uniforms.f[94].zzzz, reg_tmp4);
bool_regs = greaterThanEqual(uniforms.f[93].xx, reg_tmp4.xx);
reg_tmp4 = vec4(rsq_s(reg_tmp4.x));
reg_tmp5 = mul_s(uniforms.f[94].zzzz, reg_tmp14);
if (bool_regs.x) {
jmp_to = 309u; break;
}
reg_tmp0.z = rcp_s(reg_tmp4.x);
reg_tmp0.xy = (mul_s(reg_tmp5, reg_tmp4)).xy;
case 309u:
vs_out_attr1 = reg_tmp0;
default: return false;
}
}
return false;
}
bool sub_11() {
uint jmp_to = 310u;
while (true) {
switch (jmp_to) {
case 310u:
reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
reg_tmp6.x = rsq_s(reg_tmp6.x);
reg_tmp7.x = rsq_s(reg_tmp7.x);
reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp13.xyz = (mul_s(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp11.xyz = (mul_s(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp0 = uniforms.f[93].yxxx;
if (!uniforms.b[15]) {
jmp_to = 385u; break;
}
reg_tmp13.xyz = (mul_s(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp11.xyz = (mul_s(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp5 = mul_s(reg_tmp14.yzxx, reg_tmp13.zxyy);
reg_tmp5 = fma_s(-reg_tmp13.yzxx, reg_tmp14.zxyy, reg_tmp5);
reg_tmp5.w = dot_3(reg_tmp5.xyz, reg_tmp5.xyz);
reg_tmp5.w = rsq_s(reg_tmp5.w);
reg_tmp5 = mul_s(reg_tmp5, reg_tmp5.wwww);
reg_tmp6.w = (reg_tmp14.zzzz + reg_tmp5.yyyy).w;
reg_tmp13 = mul_s(reg_tmp5.yzxx, reg_tmp14.zxyy);
reg_tmp13 = fma_s(-reg_tmp14.yzxx, reg_tmp5.zxyy, reg_tmp13);
reg_tmp6.w = (reg_tmp13.xxxx + reg_tmp6).w;
reg_tmp13.w = (reg_tmp5.zzzz).w;
reg_tmp5.z = (reg_tmp13.xxxx).z;
reg_tmp6.w = (uniforms.f[93].yyyy + reg_tmp6).w;
reg_tmp14.w = (reg_tmp5.xxxx).w;
reg_tmp5.x = (reg_tmp14.zzzz).x;
bool_regs = lessThan(uniforms.f[94].yy, reg_tmp6.ww);
reg_tmp6.x = (uniforms.f[93].yyyy).x;
reg_tmp6.y = (-uniforms.f[93].yyyy).y;
if (!bool_regs.x) {
jmp_to = 347u; break;
}
reg_tmp7.xz = (reg_tmp13.wwyy + -reg_tmp14.yyww).xz;
reg_tmp7.y = (reg_tmp14.xxxx + -reg_tmp13.zzzz).y;
reg_tmp7.w = (reg_tmp6).w;
reg_tmp6 = vec4(dot_s(reg_tmp7, reg_tmp7));
reg_tmp6 = vec4(rsq_s(reg_tmp6.x));
reg_tmp0 = mul_s(reg_tmp7, reg_tmp6);
if (uniforms.b[0]) {
jmp_to = 385u; break;
}
case 347u:
bool_regs = greaterThan(reg_tmp5.zy, reg_tmp5.yx);
if (bool_regs.x) {
sub_12();
} else {
sub_17();
}
reg_tmp6 = vec4(dot_s(reg_tmp8, reg_tmp8));
reg_tmp6 = vec4(rsq_s(reg_tmp6.x));
reg_tmp0 = mul_s(reg_tmp8, reg_tmp6);
case 385u:
vs_out_attr1 = reg_tmp0;
default: return false;
}
}
return false;
}
bool sub_12() {
if (bool_regs.y) {
sub_13();
} else {
sub_14();
}
reg_tmp8.w = (-reg_tmp8).w;
return false;
}
bool sub_13() {
reg_tmp8 = mul_s(reg_tmp13.yyzw, reg_tmp6.xxxy);
reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
return false;
}
bool sub_14() {
bool_regs = greaterThan(reg_tmp5.zz, reg_tmp5.xx);
reg_tmp8 = mul_s(reg_tmp13.yyzw, reg_tmp6.xxxy);
reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
if (bool_regs.x) {
sub_15();
} else {
sub_16();
}
return false;
}
bool sub_15() {
reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
return false;
}
bool sub_16() {
reg_tmp8 = mul_s(reg_tmp13.zwwy, reg_tmp6.xxxy);
reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
return false;
}
bool sub_17() {
if (bool_regs.y) {
sub_18();
} else {
sub_19();
}
return false;
}
bool sub_18() {
reg_tmp8 = mul_s(reg_tmp13.yywz, reg_tmp6.xxxy);
reg_tmp8.y = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).y;
reg_tmp9 = reg_tmp5.yyyy + -reg_tmp5.xxxx;
reg_tmp8.xzw = (reg_tmp8 + reg_tmp14.wwyx).xzw;
reg_tmp8.y = (reg_tmp9 + reg_tmp8).y;
return false;
}
bool sub_19() {
reg_tmp8 = mul_s(reg_tmp13.zwwy, reg_tmp6.xxxy);
reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
reg_tmp8.w = (-reg_tmp8).w;
return false;
}
// reference: D532576AB51BF79A, 37194F1D205A4454
// program: 37194F1D205A4454, F777123A8C3D5E20, B7A9B6AE77A46D16
// program: AEF4EEAE6F9585E0, F777123A8C3D5E20, 2ABF755DBC001504
// program: 37194F1D205A4454, F777123A8C3D5E20, F705E732A249D088
// program: AEF4EEAE6F9585E0, F777123A8C3D5E20, 40AC75E82F61755E
// shader: 8B31, F1DF7EB1C21EA0F1

#define mul_s(x, y) mix(x * y, vec4(0), isnan(x * y))
#define mul_3(x, y) mix(x * y, vec3(0), isnan(x * y))
#define fma_s(x, y, z) (mul_s(x, y) + z)
#define dot_s(x, y) dot(mul_s(x, y), vec4(1))
#define dot_3(x, y) dot(mul_3(x, y), vec3(1))

float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x == 0.0) return x;
    return inversesqrt(x);
}

#define min_s(x, y) min(x, y)
#define max_s(x, y) max(x, y)

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout(binding=2, std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location=0) in vec4 vs_in_reg0;
layout(location=1) in vec4 vs_in_reg1;
layout(location=2) in vec4 vs_in_reg2;
layout(location=3) in vec4 vs_in_reg3;
layout(location=4) in vec4 vs_in_reg4;
layout(location=5) in vec4 vs_in_reg5;
layout(location=6) in vec4 vs_in_reg6;

layout(location=0) out vec4 vs_out_attr0;
layout(location=1) out vec4 vs_out_attr1;
layout(location=2) out vec4 vs_out_attr2;
layout(location=3) out vec4 vs_out_attr3;
layout(location=4) out vec4 vs_out_attr4;
layout(location=5) out vec4 vs_out_attr5;
layout(location=6) out vec4 vs_out_attr6;

void main() {
vs_out_attr0 = vec4(0, 0, 0, 1);
vs_out_attr1 = vec4(0, 0, 0, 1);
vs_out_attr2 = vec4(0, 0, 0, 1);
vs_out_attr3 = vec4(0, 0, 0, 1);
vs_out_attr4 = vec4(0, 0, 0, 1);
vs_out_attr5 = vec4(0, 0, 0, 1);
vs_out_attr6 = vec4(0, 0, 0, 1);
exec_shader();
}
bvec2 bool_regs = bvec2(false);
ivec3 addr_regs = ivec3(0);
vec4 reg_tmp0 = vec4(0, 0, 0, 1);
vec4 reg_tmp1 = vec4(0, 0, 0, 1);
vec4 reg_tmp2 = vec4(0, 0, 0, 1);
vec4 reg_tmp3 = vec4(0, 0, 0, 1);
vec4 reg_tmp4 = vec4(0, 0, 0, 1);
vec4 reg_tmp5 = vec4(0, 0, 0, 1);
vec4 reg_tmp6 = vec4(0, 0, 0, 1);
vec4 reg_tmp7 = vec4(0, 0, 0, 1);
vec4 reg_tmp8 = vec4(0, 0, 0, 1);
vec4 reg_tmp9 = vec4(0, 0, 0, 1);
vec4 reg_tmp10 = vec4(0, 0, 0, 1);
vec4 reg_tmp11 = vec4(0, 0, 0, 1);
vec4 reg_tmp12 = vec4(0, 0, 0, 1);
vec4 reg_tmp13 = vec4(0, 0, 0, 1);
vec4 reg_tmp14 = vec4(0, 0, 0, 1);
vec4 reg_tmp15 = vec4(0, 0, 0, 1);

bool sub_0();
bool sub_1();
bool sub_2();
bool sub_3();
bool sub_4();
bool sub_5();
bool sub_17();
bool sub_6();
bool sub_7();
bool sub_8();
bool sub_9();
bool sub_10();
bool sub_11();
bool sub_12();
bool sub_13();
bool sub_14();
bool sub_15();
bool sub_16();
bool sub_18();
bool sub_19();
bool sub_25();
bool sub_26();
bool sub_27();
bool sub_28();
bool sub_30();
bool sub_20();
bool sub_21();
bool sub_22();
bool sub_23();
bool sub_24();
bool sub_29();
bool sub_31();
bool sub_32();
bool sub_33();
bool sub_34();
bool sub_35();
bool sub_36();
bool sub_37();
bool sub_38();
bool sub_39();
bool sub_40();
bool sub_41();
bool sub_42();
bool sub_43();

bool exec_shader() {
sub_0();
return true;
}

bool sub_0() {
sub_1();
sub_3();
sub_18();
sub_32();
sub_39();
return true;
}
bool sub_1() {
reg_tmp15.xyz = (mul_s(uniforms.f[7].xxxx, vs_in_reg0)).xyz;
reg_tmp14.xyz = (mul_s(uniforms.f[7].yyyy, vs_in_reg1)).xyz;
reg_tmp13.xyz = (mul_s(uniforms.f[7].zzzz, vs_in_reg2)).xyz;
reg_tmp15.xyz = (uniforms.f[6] + reg_tmp15).xyz;
reg_tmp15.w = (uniforms.f[93].yyyy).w;
reg_tmp0 = uniforms.f[7];
reg_tmp10.x = dot_s(uniforms.f[25], reg_tmp15);
reg_tmp10.y = dot_s(uniforms.f[26], reg_tmp15);
reg_tmp10.z = dot_s(uniforms.f[27], reg_tmp15);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp12.x = dot_3(uniforms.f[25].xyz, reg_tmp14.xyz);
reg_tmp12.y = dot_3(uniforms.f[26].xyz, reg_tmp14.xyz);
reg_tmp12.z = dot_3(uniforms.f[27].xyz, reg_tmp14.xyz);
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
sub_2();
vs_out_attr2 = -reg_tmp15;
reg_tmp0.x = (uniforms.f[93].yyyy).x;
addr_regs.x = (ivec2(vs_in_reg3.xx)).x;
reg_tmp0.x = (mul_s(uniforms.f[28 + addr_regs.x].xxxx, reg_tmp0.xxxx)).x;
addr_regs.x = (ivec2(vs_in_reg3.yy)).x;
reg_tmp0.x = (mul_s(uniforms.f[28 + addr_regs.x].yyyy, reg_tmp0.xxxx)).x;
addr_regs.x = (ivec2(vs_in_reg3.zz)).x;
reg_tmp0.x = (mul_s(uniforms.f[28 + addr_regs.x].zzzz, reg_tmp0.xxxx)).x;
addr_regs.x = (ivec2(vs_in_reg3.ww)).x;
reg_tmp0.x = (mul_s(uniforms.f[28 + addr_regs.x].wwww, reg_tmp0.xxxx)).x;
reg_tmp15.xyz = (mul_s(reg_tmp15.xyzz, reg_tmp0.xxxx)).xyz;
vs_out_attr0.x = dot_s(uniforms.f[86], reg_tmp15);
vs_out_attr0.y = dot_s(uniforms.f[87], reg_tmp15);
vs_out_attr0.z = dot_s(uniforms.f[88], reg_tmp15);
vs_out_attr0.w = dot_s(uniforms.f[89], reg_tmp15);
return false;
}
bool sub_2() {
uint jmp_to = 73u;
while (true) {
switch (jmp_to) {
case 73u:
reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
reg_tmp6.x = rsq_s(reg_tmp6.x);
reg_tmp7.x = rsq_s(reg_tmp7.x);
reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp0 = uniforms.f[93].yxxx;
if (!uniforms.b[15]) {
jmp_to = 89u; break;
}
reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
reg_tmp4 = mul_s(uniforms.f[94].zzzz, reg_tmp4);
bool_regs = greaterThanEqual(uniforms.f[93].xx, reg_tmp4.xx);
reg_tmp4 = vec4(rsq_s(reg_tmp4.x));
reg_tmp5 = mul_s(uniforms.f[94].zzzz, reg_tmp14);
if (bool_regs.x) {
jmp_to = 89u; break;
}
reg_tmp0.z = rcp_s(reg_tmp4.x);
reg_tmp0.xy = (mul_s(reg_tmp5, reg_tmp4)).xy;
case 89u:
vs_out_attr1 = reg_tmp0;
default: return false;
}
}
return false;
}
bool sub_3() {
reg_tmp8.xy = (uniforms.f[93].xxxx).xy;
reg_tmp0.y = (uniforms.f[7].wwww).y;
bool_regs = notEqual(uniforms.f[93].xx, reg_tmp0.xy);
reg_tmp9.xyz = (uniforms.f[93].xxxx).xyz;
reg_tmp9.w = (uniforms.f[21].wwww).w;
if (bool_regs.y) {
sub_4();
}
if (uniforms.b[12]) {
sub_6();
}
if (uniforms.b[5]) {
sub_15();
}
bool_regs = equal(uniforms.f[93].xx, reg_tmp8.xy);
if (all(bool_regs)) {
sub_17();
}
vs_out_attr3 = max_s(uniforms.f[93].xxxx, reg_tmp9);
return false;
}
bool sub_4() {
reg_tmp0 = mul_s(uniforms.f[7].wwww, vs_in_reg3);
if (uniforms.b[7]) {
sub_5();
}
reg_tmp9.xyz = (mul_s(uniforms.f[20].wwww, reg_tmp0.xyzz)).xyz;
reg_tmp8.x = (uniforms.f[93].yyyy).x;
return false;
}
bool sub_5() {
reg_tmp9.w = (mul_s(reg_tmp9.wwww, reg_tmp0.wwww)).w;
return false;
}
bool sub_17() {
reg_tmp9 = uniforms.f[21];
return false;
}
bool sub_6() {
reg_tmp1 = uniforms.f[20];
reg_tmp2 = uniforms.f[21];
reg_tmp3 = uniforms.f[93].xxxx;
addr_regs.z = int(uniforms.i[0].y);
for (uint i = 0u; i <= uniforms.i[0].x; addr_regs.z += int(uniforms.i[0].z), ++i) {
sub_7();
}
reg_tmp8.x = (uniforms.f[93].yyyy).x;
return false;
}
bool sub_7() {
addr_regs.x = (ivec2(reg_tmp3.xy)).x;
reg_tmp4.x = (uniforms.f[49 + addr_regs.x].wwww).x;
reg_tmp4.y = (uniforms.f[51 + addr_regs.x].wwww).y;
bool_regs = equal(uniforms.f[93].xy, reg_tmp4.xy);
if (bool_regs.x) {
sub_8();
} else {
sub_9();
}
bool_regs.x = uniforms.f[93].xxxx.x == reg_tmp6.xyyy.x;
bool_regs.y = uniforms.f[93].xxxx.y < reg_tmp6.xyyy.y;
if (bool_regs.y) {
sub_14();
}
reg_tmp3 = -uniforms.f[95].wwww + reg_tmp3;
return false;
}
bool sub_8() {
reg_tmp6.x = dot_3(uniforms.f[49 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp6.y = (uniforms.f[93].yyyy).y;
return false;
}
bool sub_9() {
reg_tmp4 = uniforms.f[49 + addr_regs.x] + -reg_tmp15;
reg_tmp6.y = (uniforms.f[93].yyyy).y;
if (bool_regs.y) {
sub_10();
}
reg_tmp5 = uniforms.f[50 + addr_regs.x];
bool_regs = equal(uniforms.f[93].yy, reg_tmp5.ww);
reg_tmp4.w = dot_3(reg_tmp4.xyz, reg_tmp4.xyz);
reg_tmp4.w = rsq_s(reg_tmp4.w);
reg_tmp4 = mul_s(reg_tmp4, reg_tmp4.wwww);
if (bool_regs.x) {
sub_11();
}
reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp4.xyz);
return false;
}
bool sub_10() {
reg_tmp5.x = (uniforms.f[93].yyyy).x;
reg_tmp5.z = dot_3(reg_tmp4.xyz, reg_tmp4.xyz);
reg_tmp5.y = (mul_s(reg_tmp5.zzzz, reg_tmp5.zzzz)).y;
reg_tmp6.y = dot_3(uniforms.f[51 + addr_regs.x].xyz, reg_tmp5.xyz);
reg_tmp6.y = rcp_s(reg_tmp6.y);
return false;
}
bool sub_11() {
reg_tmp5.x = dot_3(uniforms.f[50 + addr_regs.x].xyz, -reg_tmp4.xyz);
reg_tmp5.y = (vec4(lessThan(reg_tmp5.xxxx, uniforms.f[52 + addr_regs.x].yyyy))).y;
bool_regs = equal(uniforms.f[93].yy, reg_tmp5.xy);
if (bool_regs.y) {
sub_12();
} else {
sub_13();
}
reg_tmp6.y = (mul_s(reg_tmp6.yyyy, reg_tmp5.xxxx)).y;
return false;
}
bool sub_12() {
reg_tmp5.x = (uniforms.f[93].xxxx).x;
return false;
}
bool sub_13() {
reg_tmp5.y = log2(reg_tmp5.x);
reg_tmp5.y = (mul_s(uniforms.f[52 + addr_regs.x].xxxx, reg_tmp5.yyyy)).y;
reg_tmp5.x = exp2(reg_tmp5.y);
return false;
}
bool sub_14() {
reg_tmp6.x = (max_s(uniforms.f[93].xxxx, reg_tmp6.xxxx)).x;
reg_tmp9.xyz = (fma_s(reg_tmp1.xyzz, uniforms.f[47 + addr_regs.x].xyzz, reg_tmp9.xyzz)).xyz;
reg_tmp4 = mul_s(uniforms.f[48 + addr_regs.x], reg_tmp2);
reg_tmp5.xyz = (mul_s(reg_tmp6.xxxx, reg_tmp4.xyzz)).xyz;
reg_tmp5.xyz = (mul_s(reg_tmp6.yyyy, reg_tmp5.xyzz)).xyz;
reg_tmp9.xyz = (reg_tmp9.xyzz + reg_tmp5.xyzz).xyz;
reg_tmp9.w = (reg_tmp9.wwww + reg_tmp4.wwww).w;
return false;
}
bool sub_15() {
reg_tmp1 = vec4(dot_3(uniforms.f[24].xyz, reg_tmp14.xyz));
reg_tmp2 = uniforms.f[24].wwww;
reg_tmp1 = fma_s(reg_tmp1, reg_tmp2, reg_tmp2);
reg_tmp3 = uniforms.f[22];
reg_tmp2 = uniforms.f[23] + -reg_tmp3;
reg_tmp4 = fma_s(reg_tmp2, reg_tmp1, reg_tmp3);
if (uniforms.b[6]) {
sub_16();
}
reg_tmp9.xyz = (fma_s(reg_tmp4, uniforms.f[21], reg_tmp9)).xyz;
reg_tmp8.x = (uniforms.f[93].yyyy).x;
return false;
}
bool sub_16() {
reg_tmp4 = mul_s(reg_tmp4, reg_tmp9.wwww);
return false;
}
bool sub_18() {
reg_tmp0.xy = (uniforms.f[10].xxxx).xy;
if (uniforms.b[9]) {
sub_19();
} else {
sub_25();
}
return false;
}
bool sub_19() {
sub_20();
reg_tmp3.x = dot_s(uniforms.f[11].xywz, reg_tmp6);
reg_tmp3.y = dot_s(uniforms.f[12].xywz, reg_tmp6);
reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
vs_out_attr4 = reg_tmp3;
return false;
}
bool sub_25() {
bool_regs = equal(uniforms.f[95].xy, reg_tmp0.xy);
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
if (all(not(bool_regs))) {
sub_26();
} else {
sub_27();
}
vs_out_attr4 = reg_tmp3;
return false;
}
bool sub_26() {
reg_tmp6 = reg_tmp10;
reg_tmp3.x = dot_s(uniforms.f[11], reg_tmp6);
reg_tmp3.y = dot_s(uniforms.f[12], reg_tmp6);
reg_tmp3.z = dot_s(uniforms.f[13], reg_tmp6);
reg_tmp0.xy = (mul_s(uniforms.f[19].xyyy, reg_tmp3.zzzz)).xy;
reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
return false;
}
bool sub_27() {
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_28();
} else {
sub_30();
}
return false;
}
bool sub_28() {
sub_29();
reg_tmp3.x = dot_3(uniforms.f[11].xyz, reg_tmp6.xyz);
reg_tmp3.y = dot_3(uniforms.f[12].xyz, reg_tmp6.xyz);
reg_tmp3.z = dot_3(uniforms.f[13].xyz, reg_tmp6.xyz);
return false;
}
bool sub_30() {
sub_31();
reg_tmp3.x = dot_s(uniforms.f[11], reg_tmp6);
reg_tmp3.y = dot_s(uniforms.f[12], reg_tmp6);
return false;
}
bool sub_20() {
bool_regs = equal(uniforms.f[93].yz, reg_tmp0.xy);
if (all(not(bool_regs))) {
sub_21();
} else {
sub_22();
}
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
return false;
}
bool sub_21() {
reg_tmp6.xy = (mul_s(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
return false;
}
bool sub_22() {
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_23();
} else {
sub_24();
}
return false;
}
bool sub_23() {
reg_tmp6.xy = (mul_s(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
return false;
}
bool sub_24() {
reg_tmp6.xy = (mul_s(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
return false;
}
bool sub_29() {
reg_tmp2 = -reg_tmp15;
reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
reg_tmp2.w = rsq_s(reg_tmp2.w);
reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
reg_tmp1 = reg_tmp1 + reg_tmp1;
reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
return false;
}
bool sub_31() {
reg_tmp1.xy = (uniforms.f[94].zzzz).xy;
reg_tmp1.zw = (uniforms.f[93].xxxx).zw;
reg_tmp6 = fma_s(reg_tmp14, reg_tmp1, reg_tmp1);
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
return false;
}
bool sub_32() {
reg_tmp0.xy = (uniforms.f[10].yyyy).xy;
if (uniforms.b[10]) {
sub_33();
} else {
sub_34();
}
return false;
}
bool sub_33() {
sub_20();
reg_tmp4.x = dot_s(uniforms.f[14].xywz, reg_tmp6);
reg_tmp4.y = dot_s(uniforms.f[15].xywz, reg_tmp6);
vs_out_attr5 = reg_tmp4;
return false;
}
bool sub_34() {
if (uniforms.b[13]) {
sub_35();
} else {
sub_38();
}
return false;
}
bool sub_35() {
bool_regs = equal(uniforms.f[95].xy, reg_tmp0.xy);
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
if (all(not(bool_regs))) {
sub_36();
} else {
sub_37();
}
vs_out_attr5 = reg_tmp4;
return false;
}
bool sub_36() {
reg_tmp6 = reg_tmp10;
reg_tmp4.x = dot_s(uniforms.f[14], reg_tmp6);
reg_tmp4.y = dot_s(uniforms.f[15], reg_tmp6);
reg_tmp4.z = dot_s(uniforms.f[16], reg_tmp6);
reg_tmp6.w = rcp_s(reg_tmp4.z);
reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
reg_tmp4.xy = (uniforms.f[19].zwww + reg_tmp4.xyyy).xy;
return false;
}
bool sub_37() {
sub_31();
reg_tmp4.x = dot_s(uniforms.f[14], reg_tmp6);
reg_tmp4.y = dot_s(uniforms.f[15], reg_tmp6);
return false;
}
bool sub_38() {
vs_out_attr5 = uniforms.f[93].xxxx;
return false;
}
bool sub_39() {
reg_tmp0.xy = (uniforms.f[10].zzzz).xy;
if (uniforms.b[11]) {
sub_40();
} else {
sub_41();
}
return false;
}
bool sub_40() {
sub_20();
reg_tmp5.x = dot_s(uniforms.f[17].xywz, reg_tmp6);
reg_tmp5.y = dot_s(uniforms.f[18].xywz, reg_tmp6);
vs_out_attr6 = reg_tmp5;
return false;
}
bool sub_41() {
if (uniforms.b[14]) {
sub_42();
} else {
sub_43();
}
return false;
}
bool sub_42() {
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
reg_tmp5.zw = (reg_tmp6.zwww).zw;
sub_31();
reg_tmp5.x = dot_s(uniforms.f[17], reg_tmp6);
reg_tmp5.y = dot_s(uniforms.f[18], reg_tmp6);
vs_out_attr6 = reg_tmp5;
return false;
}
bool sub_43() {
vs_out_attr6 = uniforms.f[93].xxxx;
return false;
}
// reference: 8F16A408CAC791F3, F1DF7EB1C21EA0F1
// program: F1DF7EB1C21EA0F1, EADA2116091C5E01, 8F65D4C9937515E7
// program: AEF4EEAE6F9585E0, F777123A8C3D5E20, E92BD36993FCEF08
// program: 5A04B7D2F3342460, EADA2116091C5E01, 21292E7E60EA16A3
// program: AEF4EEAE6F9585E0, F777123A8C3D5E20, 827335DA69BDA0DB
// program: 5A04B7D2F3342460, EADA2116091C5E01, 16A434779407E7AE
// program: AEF4EEAE6F9585E0, F777123A8C3D5E20, 6BCA0D2C173D7CF0
// program: AEF4EEAE6F9585E0, F777123A8C3D5E20, 06E7DDEE0C953BDE
// program: AEF4EEAE6F9585E0, F777123A8C3D5E20, 150702E3F406903E
// program: AEF4EEAE6F9585E0, F777123A8C3D5E20, DC30A32F29D57F45
// program: 5A04B7D2F3342460, EADA2116091C5E01, C18C877C3284B236
// program: 5A04B7D2F3342460, EADA2116091C5E01, 4361FEDB67ED2EA0
// program: 5A04B7D2F3342460, EADA2116091C5E01, 8CE512B08922067E
// program: AEF4EEAE6F9585E0, F777123A8C3D5E20, 8F3C3633B9CAA7A1
// program: AEF4EEAE6F9585E0, F777123A8C3D5E20, BCB6996A612CD231
// program: AEF4EEAE6F9585E0, F777123A8C3D5E20, 7C0D3CEB7377967A
// program: 4DBF54CC7897BA20, B6B95AFD9466EC70, F1885D0AF8BF4994
// program: AEF4EEAE6F9585E0, F777123A8C3D5E20, 0049E2EDD992FDDF
// program: AEF4EEAE6F9585E0, F777123A8C3D5E20, A9DA56A1A3E1427F
// program: AEF4EEAE6F9585E0, F777123A8C3D5E20, 0AC6110A4E33F0FC
// shader: 8B31, E600307F5D520B6A

#define mul_s(x, y) mix(x * y, vec4(0), isnan(x * y))
#define mul_3(x, y) mix(x * y, vec3(0), isnan(x * y))
#define fma_s(x, y, z) (mul_s(x, y) + z)
#define dot_s(x, y) dot(mul_s(x, y), vec4(1))
#define dot_3(x, y) dot(mul_3(x, y), vec3(1))

float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x == 0.0) return x;
    return inversesqrt(x);
}

#define min_s(x, y) min(x, y)
#define max_s(x, y) max(x, y)

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout(binding=2, std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location=0) in vec4 vs_in_reg0;
layout(location=1) in vec4 vs_in_reg1;
layout(location=2) in vec4 vs_in_reg2;
layout(location=3) in vec4 vs_in_reg3;
layout(location=7) in vec4 vs_in_reg7;
layout(location=8) in vec4 vs_in_reg8;

layout(location=0) out vec4 vs_out_attr0;
layout(location=1) out vec4 vs_out_attr1;
layout(location=2) out vec4 vs_out_attr2;
layout(location=3) out vec4 vs_out_attr3;
layout(location=4) out vec4 vs_out_attr4;
layout(location=5) out vec4 vs_out_attr5;
layout(location=6) out vec4 vs_out_attr6;

void main() {
vs_out_attr0 = vec4(0, 0, 0, 1);
vs_out_attr1 = vec4(0, 0, 0, 1);
vs_out_attr2 = vec4(0, 0, 0, 1);
vs_out_attr3 = vec4(0, 0, 0, 1);
vs_out_attr4 = vec4(0, 0, 0, 1);
vs_out_attr5 = vec4(0, 0, 0, 1);
vs_out_attr6 = vec4(0, 0, 0, 1);
exec_shader();
}
bvec2 bool_regs = bvec2(false);
ivec3 addr_regs = ivec3(0);
vec4 reg_tmp0 = vec4(0, 0, 0, 1);
vec4 reg_tmp1 = vec4(0, 0, 0, 1);
vec4 reg_tmp2 = vec4(0, 0, 0, 1);
vec4 reg_tmp3 = vec4(0, 0, 0, 1);
vec4 reg_tmp4 = vec4(0, 0, 0, 1);
vec4 reg_tmp5 = vec4(0, 0, 0, 1);
vec4 reg_tmp6 = vec4(0, 0, 0, 1);
vec4 reg_tmp7 = vec4(0, 0, 0, 1);
vec4 reg_tmp8 = vec4(0, 0, 0, 1);
vec4 reg_tmp9 = vec4(0, 0, 0, 1);
vec4 reg_tmp10 = vec4(0, 0, 0, 1);
vec4 reg_tmp11 = vec4(0, 0, 0, 1);
vec4 reg_tmp12 = vec4(0, 0, 0, 1);
vec4 reg_tmp13 = vec4(0, 0, 0, 1);
vec4 reg_tmp14 = vec4(0, 0, 0, 1);
vec4 reg_tmp15 = vec4(0, 0, 0, 1);

bool sub_0();
bool sub_21();
bool sub_4();
bool sub_9();
bool sub_1();
bool sub_2();
bool sub_3();
bool sub_5();
bool sub_7();
bool sub_8();
bool sub_10();
bool sub_20();
bool sub_22();
bool sub_23();
bool sub_24();
bool sub_25();
bool sub_26();
bool sub_27();
bool sub_28();
bool sub_29();
bool sub_30();
bool sub_31();
bool sub_6();
bool sub_11();
bool sub_12();
bool sub_13();
bool sub_14();
bool sub_15();
bool sub_16();
bool sub_17();
bool sub_18();
bool sub_19();
bool sub_32();
bool sub_33();
bool sub_34();
bool sub_44();
bool sub_35();
bool sub_36();
bool sub_37();
bool sub_38();
bool sub_39();
bool sub_40();
bool sub_41();
bool sub_42();
bool sub_43();

bool exec_shader() {
sub_0();
return true;
}

bool sub_0() {
sub_1();
sub_32();
vs_out_attr4 = uniforms.f[93].xxxx;
vs_out_attr5 = uniforms.f[93].xxxx;
vs_out_attr6 = uniforms.f[93].xxxx;
return true;
}
bool sub_21() {
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp3.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp3.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp3.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
return false;
}
bool sub_4() {
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp3.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp3.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp3.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp4.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
return false;
}
bool sub_9() {
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp3.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp3.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp3.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp4.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp5.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp5.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp5.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
reg_tmp11 = fma_s(reg_tmp1.wwww, reg_tmp5, reg_tmp11);
return false;
}
bool sub_1() {
reg_tmp15.xyz = (mul_s(uniforms.f[7].xxxx, vs_in_reg0)).xyz;
reg_tmp14.xyz = (mul_s(uniforms.f[7].yyyy, vs_in_reg1)).xyz;
reg_tmp13.xyz = (mul_s(uniforms.f[7].zzzz, vs_in_reg2)).xyz;
reg_tmp15.xyz = (uniforms.f[6] + reg_tmp15).xyz;
reg_tmp15.w = (uniforms.f[93].yyyy).w;
if (uniforms.b[1]) {
sub_2();
} else {
sub_24();
}
return false;
}
bool sub_2() {
reg_tmp0 = uniforms.f[7];
bool_regs = notEqual(uniforms.f[93].xx, reg_tmp0.yz);
reg_tmp7 = uniforms.f[93].xxxx;
reg_tmp12 = uniforms.f[93].xxxx;
reg_tmp11 = uniforms.f[93].xxxx;
reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_3();
} else {
sub_7();
}
vs_out_attr2 = -reg_tmp15;
reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
reg_tmp1.x = (-reg_tmp0.wwww).x;
reg_tmp1.y = (mul_s(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
bool_regs.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
bool_regs.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
if (all(bool_regs)) {
sub_23();
}
vs_out_attr0 = reg_tmp0;
return false;
}
bool sub_3() {
bool_regs = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
reg_tmp1.xy = (reg_tmp2.xxxx).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
sub_4();
reg_tmp1.xy = (reg_tmp2.yyyy).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
sub_4();
reg_tmp1.xy = (reg_tmp2.zzzz).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
if (bool_regs.x) {
sub_4();
}
if (uniforms.b[8]) {
sub_5();
}
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp6.y = (-uniforms.f[85].wwww + reg_tmp10.yyyy).y;
reg_tmp9.xyz = (uniforms.f[85].xyzz).xyz;
reg_tmp7.x = dot_s(reg_tmp9.xyzz, reg_tmp9.xyzz);
reg_tmp7.x = rsq_s(reg_tmp7.x);
reg_tmp7.xyz = (mul_s(reg_tmp9.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp8.y = rcp_s(-reg_tmp7.y);
reg_tmp8.y = (mul_s(reg_tmp6.yyyy, reg_tmp8.yyyy)).y;
reg_tmp7.xyz = (mul_s(reg_tmp7.xyzz, reg_tmp8.yyyy)).xyz;
reg_tmp10.xyz = (reg_tmp10.xyzz + reg_tmp7.xyzz).xyz;
reg_tmp10.y = (uniforms.f[94].zzzz + reg_tmp10.yyyy).y;
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
sub_6();
return false;
}
bool sub_5() {
reg_tmp1.xy = (reg_tmp2.wwww).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
if (bool_regs.y) {
sub_4();
}
return false;
}
bool sub_7() {
if (all(bool_regs)) {
sub_8();
} else {
sub_20();
}
return false;
}
bool sub_8() {
bool_regs = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
reg_tmp1.xy = (reg_tmp2.xxxx).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
sub_9();
reg_tmp1.xy = (reg_tmp2.yyyy).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
sub_9();
reg_tmp1.xy = (reg_tmp2.zzzz).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
if (bool_regs.x) {
sub_9();
}
if (uniforms.b[8]) {
sub_10();
}
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp13.x = dot_3(uniforms.f[3].xyz, reg_tmp11.xyz);
reg_tmp13.y = dot_3(uniforms.f[4].xyz, reg_tmp11.xyz);
reg_tmp13.z = dot_3(uniforms.f[5].xyz, reg_tmp11.xyz);
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
reg_tmp6.y = (-uniforms.f[85].wwww + reg_tmp10.yyyy).y;
reg_tmp9.xyz = (uniforms.f[85].xyzz).xyz;
reg_tmp7.x = dot_s(reg_tmp9.xyzz, reg_tmp9.xyzz);
reg_tmp7.x = rsq_s(reg_tmp7.x);
reg_tmp7.xyz = (mul_s(reg_tmp9.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp8.y = rcp_s(-reg_tmp7.y);
reg_tmp8.y = (mul_s(reg_tmp6.yyyy, reg_tmp8.yyyy)).y;
reg_tmp7.xyz = (mul_s(reg_tmp7.xyzz, reg_tmp8.yyyy)).xyz;
reg_tmp10.xyz = (reg_tmp10.xyzz + reg_tmp7.xyzz).xyz;
reg_tmp10.y = (uniforms.f[94].zzzz + reg_tmp10.yyyy).y;
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
sub_11();
return false;
}
bool sub_10() {
reg_tmp1.xy = (reg_tmp2.wwww).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
if (bool_regs.y) {
sub_9();
}
return false;
}
bool sub_20() {
bool_regs = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
reg_tmp1.xy = (reg_tmp2.xxxx).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
sub_21();
reg_tmp1.xy = (reg_tmp2.yyyy).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
sub_21();
reg_tmp1.xy = (reg_tmp2.zzzz).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
if (bool_regs.x) {
sub_21();
}
if (uniforms.b[8]) {
sub_22();
}
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp6.y = (-uniforms.f[85].wwww + reg_tmp10.yyyy).y;
reg_tmp9.xyz = (uniforms.f[85].xyzz).xyz;
reg_tmp7.x = dot_s(reg_tmp9.xyzz, reg_tmp9.xyzz);
reg_tmp7.x = rsq_s(reg_tmp7.x);
reg_tmp7.xyz = (mul_s(reg_tmp9.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp8.y = rcp_s(-reg_tmp7.y);
reg_tmp8.y = (mul_s(reg_tmp6.yyyy, reg_tmp8.yyyy)).y;
reg_tmp7.xyz = (mul_s(reg_tmp7.xyzz, reg_tmp8.yyyy)).xyz;
reg_tmp10.xyz = (reg_tmp10.xyzz + reg_tmp7.xyzz).xyz;
reg_tmp10.y = (uniforms.f[94].zzzz + reg_tmp10.yyyy).y;
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
vs_out_attr1 = uniforms.f[93].xxxx;
return false;
}
bool sub_22() {
reg_tmp1.xy = (reg_tmp2.wwww).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
if (bool_regs.y) {
sub_21();
}
return false;
}
bool sub_23() {
reg_tmp0.x = (-reg_tmp0.wwww).x;
return false;
}
bool sub_24() {
reg_tmp0 = uniforms.f[7];
bool_regs = notEqual(uniforms.f[93].xx, reg_tmp0.yz);
if (uniforms.b[2]) {
sub_25();
} else {
sub_26();
}
reg_tmp6.y = (-uniforms.f[85].wwww + reg_tmp10.yyyy).y;
reg_tmp9.xyz = (uniforms.f[85].xyzz).xyz;
reg_tmp7.x = dot_s(reg_tmp9.xyzz, reg_tmp9.xyzz);
reg_tmp7.x = rsq_s(reg_tmp7.x);
reg_tmp7.xyz = (mul_s(reg_tmp9.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp8.y = rcp_s(-reg_tmp7.y);
reg_tmp8.y = (mul_s(reg_tmp6.yyyy, reg_tmp8.yyyy)).y;
reg_tmp7.xyz = (mul_s(reg_tmp7.xyzz, reg_tmp8.yyyy)).xyz;
reg_tmp10.xyz = (reg_tmp10.xyzz + reg_tmp7.xyzz).xyz;
reg_tmp10.y = (uniforms.f[94].zzzz + reg_tmp10.yyyy).y;
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_27();
} else {
sub_28();
}
vs_out_attr2 = -reg_tmp15;
reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
reg_tmp1.x = (-reg_tmp0.wwww).x;
reg_tmp1.y = (mul_s(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
bool_regs.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
bool_regs.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
if (all(bool_regs)) {
sub_31();
}
vs_out_attr0 = reg_tmp0;
return false;
}
bool sub_25() {
reg_tmp1.x = (mul_s(uniforms.f[93].wwww, vs_in_reg7.xxxx)).x;
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp7.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp7.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp7.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
return false;
}
bool sub_26() {
addr_regs.x = (ivec2(uniforms.f[93].xx)).x;
reg_tmp10.x = dot_s(uniforms.f[25], reg_tmp15);
reg_tmp10.y = dot_s(uniforms.f[26], reg_tmp15);
reg_tmp10.z = dot_s(uniforms.f[27], reg_tmp15);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
return false;
}
bool sub_27() {
reg_tmp12.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
sub_6();
return false;
}
bool sub_28() {
if (all(bool_regs)) {
sub_29();
} else {
sub_30();
}
return false;
}
bool sub_29() {
reg_tmp12.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp11.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp11.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp11.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
reg_tmp13.x = dot_3(uniforms.f[3].xyz, reg_tmp11.xyz);
reg_tmp13.y = dot_3(uniforms.f[4].xyz, reg_tmp11.xyz);
reg_tmp13.z = dot_3(uniforms.f[5].xyz, reg_tmp11.xyz);
sub_11();
return false;
}
bool sub_30() {
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
vs_out_attr1 = uniforms.f[93].xxxx;
return false;
}
bool sub_31() {
reg_tmp0.x = (-reg_tmp0.wwww).x;
return false;
}
bool sub_6() {
uint jmp_to = 254u;
while (true) {
switch (jmp_to) {
case 254u:
reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
reg_tmp6.x = rsq_s(reg_tmp6.x);
reg_tmp7.x = rsq_s(reg_tmp7.x);
reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp0 = uniforms.f[93].yxxx;
if (!uniforms.b[15]) {
jmp_to = 270u; break;
}
reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
reg_tmp4 = mul_s(uniforms.f[94].zzzz, reg_tmp4);
bool_regs = greaterThanEqual(uniforms.f[93].xx, reg_tmp4.xx);
reg_tmp4 = vec4(rsq_s(reg_tmp4.x));
reg_tmp5 = mul_s(uniforms.f[94].zzzz, reg_tmp14);
if (bool_regs.x) {
jmp_to = 270u; break;
}
reg_tmp0.z = rcp_s(reg_tmp4.x);
reg_tmp0.xy = (mul_s(reg_tmp5, reg_tmp4)).xy;
case 270u:
vs_out_attr1 = reg_tmp0;
default: return false;
}
}
return false;
}
bool sub_11() {
uint jmp_to = 271u;
while (true) {
switch (jmp_to) {
case 271u:
reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
reg_tmp6.x = rsq_s(reg_tmp6.x);
reg_tmp7.x = rsq_s(reg_tmp7.x);
reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp13.xyz = (mul_s(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp11.xyz = (mul_s(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp0 = uniforms.f[93].yxxx;
if (!uniforms.b[15]) {
jmp_to = 346u; break;
}
reg_tmp13.xyz = (mul_s(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp11.xyz = (mul_s(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp5 = mul_s(reg_tmp14.yzxx, reg_tmp13.zxyy);
reg_tmp5 = fma_s(-reg_tmp13.yzxx, reg_tmp14.zxyy, reg_tmp5);
reg_tmp5.w = dot_3(reg_tmp5.xyz, reg_tmp5.xyz);
reg_tmp5.w = rsq_s(reg_tmp5.w);
reg_tmp5 = mul_s(reg_tmp5, reg_tmp5.wwww);
reg_tmp6.w = (reg_tmp14.zzzz + reg_tmp5.yyyy).w;
reg_tmp13 = mul_s(reg_tmp5.yzxx, reg_tmp14.zxyy);
reg_tmp13 = fma_s(-reg_tmp14.yzxx, reg_tmp5.zxyy, reg_tmp13);
reg_tmp6.w = (reg_tmp13.xxxx + reg_tmp6).w;
reg_tmp13.w = (reg_tmp5.zzzz).w;
reg_tmp5.z = (reg_tmp13.xxxx).z;
reg_tmp6.w = (uniforms.f[93].yyyy + reg_tmp6).w;
reg_tmp14.w = (reg_tmp5.xxxx).w;
reg_tmp5.x = (reg_tmp14.zzzz).x;
bool_regs = lessThan(uniforms.f[94].yy, reg_tmp6.ww);
reg_tmp6.x = (uniforms.f[93].yyyy).x;
reg_tmp6.y = (-uniforms.f[93].yyyy).y;
if (!bool_regs.x) {
jmp_to = 308u; break;
}
reg_tmp7.xz = (reg_tmp13.wwyy + -reg_tmp14.yyww).xz;
reg_tmp7.y = (reg_tmp14.xxxx + -reg_tmp13.zzzz).y;
reg_tmp7.w = (reg_tmp6).w;
reg_tmp6 = vec4(dot_s(reg_tmp7, reg_tmp7));
reg_tmp6 = vec4(rsq_s(reg_tmp6.x));
reg_tmp0 = mul_s(reg_tmp7, reg_tmp6);
if (uniforms.b[0]) {
jmp_to = 346u; break;
}
case 308u:
bool_regs = greaterThan(reg_tmp5.zy, reg_tmp5.yx);
if (bool_regs.x) {
sub_12();
} else {
sub_17();
}
reg_tmp6 = vec4(dot_s(reg_tmp8, reg_tmp8));
reg_tmp6 = vec4(rsq_s(reg_tmp6.x));
reg_tmp0 = mul_s(reg_tmp8, reg_tmp6);
case 346u:
vs_out_attr1 = reg_tmp0;
default: return false;
}
}
return false;
}
bool sub_12() {
if (bool_regs.y) {
sub_13();
} else {
sub_14();
}
reg_tmp8.w = (-reg_tmp8).w;
return false;
}
bool sub_13() {
reg_tmp8 = mul_s(reg_tmp13.yyzw, reg_tmp6.xxxy);
reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
return false;
}
bool sub_14() {
bool_regs = greaterThan(reg_tmp5.zz, reg_tmp5.xx);
reg_tmp8 = mul_s(reg_tmp13.yyzw, reg_tmp6.xxxy);
reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
if (bool_regs.x) {
sub_15();
} else {
sub_16();
}
return false;
}
bool sub_15() {
reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
return false;
}
bool sub_16() {
reg_tmp8 = mul_s(reg_tmp13.zwwy, reg_tmp6.xxxy);
reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
return false;
}
bool sub_17() {
if (bool_regs.y) {
sub_18();
} else {
sub_19();
}
return false;
}
bool sub_18() {
reg_tmp8 = mul_s(reg_tmp13.yywz, reg_tmp6.xxxy);
reg_tmp8.y = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).y;
reg_tmp9 = reg_tmp5.yyyy + -reg_tmp5.xxxx;
reg_tmp8.xzw = (reg_tmp8 + reg_tmp14.wwyx).xzw;
reg_tmp8.y = (reg_tmp9 + reg_tmp8).y;
return false;
}
bool sub_19() {
reg_tmp8 = mul_s(reg_tmp13.zwwy, reg_tmp6.xxxy);
reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
reg_tmp8.w = (-reg_tmp8).w;
return false;
}
bool sub_32() {
reg_tmp8.xy = (uniforms.f[93].xxxx).xy;
reg_tmp0.y = (uniforms.f[7].wwww).y;
bool_regs = notEqual(uniforms.f[93].xx, reg_tmp0.xy);
reg_tmp9.xyz = (uniforms.f[93].xxxx).xyz;
reg_tmp9.w = (uniforms.f[21].wwww).w;
if (bool_regs.y) {
sub_33();
}
if (uniforms.b[12]) {
sub_35();
}
bool_regs = equal(uniforms.f[93].xx, reg_tmp8.xy);
if (all(bool_regs)) {
sub_44();
}
reg_tmp0.xyz = (uniforms.f[24].xyzz + -reg_tmp10.xyzz).xyz;
reg_tmp0.w = rcp_s(uniforms.f[24].w);
reg_tmp1.w = dot_3(reg_tmp0.xyz, reg_tmp0.xyz);
reg_tmp1.w = (mul_s(reg_tmp0.wwww, reg_tmp1.wwww)).w;
reg_tmp1.w = (min_s(uniforms.f[93].yyyy, reg_tmp1.wwww)).w;
reg_tmp9.w = (uniforms.f[93].yyyy + -reg_tmp1.wwww).w;
vs_out_attr3 = max_s(uniforms.f[93].xxxx, reg_tmp9);
return false;
}
bool sub_33() {
reg_tmp0 = mul_s(uniforms.f[7].wwww, vs_in_reg3);
if (uniforms.b[7]) {
sub_34();
}
reg_tmp9.xyz = (mul_s(uniforms.f[20].wwww, reg_tmp0.xyzz)).xyz;
reg_tmp8.x = (uniforms.f[93].yyyy).x;
return false;
}
bool sub_34() {
reg_tmp9.w = (mul_s(reg_tmp9.wwww, reg_tmp0.wwww)).w;
return false;
}
bool sub_44() {
reg_tmp9 = uniforms.f[21];
return false;
}
bool sub_35() {
reg_tmp1 = uniforms.f[20];
reg_tmp2 = uniforms.f[21];
reg_tmp3 = uniforms.f[93].xxxx;
addr_regs.z = int(uniforms.i[0].y);
for (uint i = 0u; i <= uniforms.i[0].x; addr_regs.z += int(uniforms.i[0].z), ++i) {
sub_36();
}
reg_tmp8.x = (uniforms.f[93].yyyy).x;
return false;
}
bool sub_36() {
addr_regs.x = (ivec2(reg_tmp3.xy)).x;
reg_tmp4.x = (uniforms.f[81 + addr_regs.x].wwww).x;
reg_tmp4.y = (uniforms.f[83 + addr_regs.x].wwww).y;
bool_regs = equal(uniforms.f[93].xy, reg_tmp4.xy);
if (bool_regs.x) {
sub_37();
} else {
sub_38();
}
bool_regs.x = uniforms.f[93].xxxx.x == reg_tmp6.xyyy.x;
bool_regs.y = uniforms.f[93].xxxx.y < reg_tmp6.xyyy.y;
if (bool_regs.y) {
sub_43();
}
reg_tmp3 = -uniforms.f[95].wwww + reg_tmp3;
return false;
}
bool sub_37() {
reg_tmp6.x = dot_3(uniforms.f[81 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp6.y = (uniforms.f[93].yyyy).y;
return false;
}
bool sub_38() {
reg_tmp4 = uniforms.f[81 + addr_regs.x] + -reg_tmp15;
reg_tmp6.y = (uniforms.f[93].yyyy).y;
if (bool_regs.y) {
sub_39();
}
reg_tmp5 = uniforms.f[82 + addr_regs.x];
bool_regs = equal(uniforms.f[93].yy, reg_tmp5.ww);
reg_tmp4.w = dot_3(reg_tmp4.xyz, reg_tmp4.xyz);
reg_tmp4.w = rsq_s(reg_tmp4.w);
reg_tmp4 = mul_s(reg_tmp4, reg_tmp4.wwww);
if (bool_regs.x) {
sub_40();
}
reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp4.xyz);
return false;
}
bool sub_39() {
reg_tmp5.x = (uniforms.f[93].yyyy).x;
reg_tmp5.z = dot_3(reg_tmp4.xyz, reg_tmp4.xyz);
reg_tmp5.y = (mul_s(reg_tmp5.zzzz, reg_tmp5.zzzz)).y;
reg_tmp6.y = dot_3(uniforms.f[83 + addr_regs.x].xyz, reg_tmp5.xyz);
reg_tmp6.y = rcp_s(reg_tmp6.y);
return false;
}
bool sub_40() {
reg_tmp5.x = dot_3(uniforms.f[82 + addr_regs.x].xyz, -reg_tmp4.xyz);
reg_tmp5.y = (vec4(lessThan(reg_tmp5.xxxx, uniforms.f[84 + addr_regs.x].yyyy))).y;
bool_regs = equal(uniforms.f[93].yy, reg_tmp5.xy);
if (bool_regs.y) {
sub_41();
} else {
sub_42();
}
reg_tmp6.y = (mul_s(reg_tmp6.yyyy, reg_tmp5.xxxx)).y;
return false;
}
bool sub_41() {
reg_tmp5.x = (uniforms.f[93].xxxx).x;
return false;
}
bool sub_42() {
reg_tmp5.y = log2(reg_tmp5.x);
reg_tmp5.y = (mul_s(uniforms.f[84 + addr_regs.x].xxxx, reg_tmp5.yyyy)).y;
reg_tmp5.x = exp2(reg_tmp5.y);
return false;
}
bool sub_43() {
reg_tmp6.x = (max_s(uniforms.f[93].xxxx, reg_tmp6.xxxx)).x;
reg_tmp9.xyz = (fma_s(reg_tmp1.xyzz, uniforms.f[79 + addr_regs.x].xyzz, reg_tmp9.xyzz)).xyz;
reg_tmp4 = mul_s(uniforms.f[80 + addr_regs.x], reg_tmp2);
reg_tmp5.xyz = (mul_s(reg_tmp6.xxxx, reg_tmp4.xyzz)).xyz;
reg_tmp5.xyz = (mul_s(reg_tmp6.yyyy, reg_tmp5.xyzz)).xyz;
reg_tmp9.xyz = (reg_tmp9.xyzz + reg_tmp5.xyzz).xyz;
reg_tmp9.w = (reg_tmp9.wwww + reg_tmp4.wwww).w;
return false;
}
// reference: BDB4F06471989644, E600307F5D520B6A
// program: E600307F5D520B6A, EADA2116091C5E01, 3CE788AAD98E52BD
// program: 4DBF54CC7897BA20, B6B95AFD9466EC70, 457EC63A7A40DFEE
// program: 4DBF54CC7897BA20, B6B95AFD9466EC70, 916CA6876C957D82
// program: 4DBF54CC7897BA20, B6B95AFD9466EC70, 993677A7EEF1569D
// reference: 2EC95D1F90F5E1A8, F705E732A249D088
// program: AEF4EEAE6F9585E0, F777123A8C3D5E20, D964AA78D393E956
// shader: 8B31, 347CF703F011E4BE

#define mul_s(x, y) mix(x * y, vec4(0), isnan(x * y))
#define mul_3(x, y) mix(x * y, vec3(0), isnan(x * y))
#define fma_s(x, y, z) (mul_s(x, y) + z)
#define dot_s(x, y) dot(mul_s(x, y), vec4(1))
#define dot_3(x, y) dot(mul_3(x, y), vec3(1))

float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x == 0.0) return x;
    return inversesqrt(x);
}

#define min_s(x, y) min(x, y)
#define max_s(x, y) max(x, y)

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout(binding=2, std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location=0) in vec4 vs_in_reg0;
layout(location=1) in vec4 vs_in_reg1;
layout(location=3) in vec4 vs_in_reg3;
layout(location=4) in vec4 vs_in_reg4;
layout(location=5) in vec4 vs_in_reg5;
layout(location=6) in vec4 vs_in_reg6;
layout(location=7) in vec4 vs_in_reg7;
layout(location=8) in vec4 vs_in_reg8;

layout(location=0) out vec4 vs_out_attr0;
layout(location=1) out vec4 vs_out_attr1;
layout(location=2) out vec4 vs_out_attr2;
layout(location=3) out vec4 vs_out_attr3;
layout(location=4) out vec4 vs_out_attr4;
layout(location=5) out vec4 vs_out_attr5;

void main() {
vs_out_attr0 = vec4(0, 0, 0, 1);
vs_out_attr1 = vec4(0, 0, 0, 1);
vs_out_attr2 = vec4(0, 0, 0, 1);
vs_out_attr3 = vec4(0, 0, 0, 1);
vs_out_attr4 = vec4(0, 0, 0, 1);
vs_out_attr5 = vec4(0, 0, 0, 1);
exec_shader();
}
bvec2 bool_regs = bvec2(false);
ivec3 addr_regs = ivec3(0);
vec4 reg_tmp0 = vec4(0, 0, 0, 1);
vec4 reg_tmp1 = vec4(0, 0, 0, 1);
vec4 reg_tmp2 = vec4(0, 0, 0, 1);
vec4 reg_tmp3 = vec4(0, 0, 0, 1);
vec4 reg_tmp4 = vec4(0, 0, 0, 1);
vec4 reg_tmp5 = vec4(0, 0, 0, 1);
vec4 reg_tmp6 = vec4(0, 0, 0, 1);
vec4 reg_tmp7 = vec4(0, 0, 0, 1);
vec4 reg_tmp8 = vec4(0, 0, 0, 1);
vec4 reg_tmp9 = vec4(0, 0, 0, 1);
vec4 reg_tmp10 = vec4(0, 0, 0, 1);
vec4 reg_tmp11 = vec4(0, 0, 0, 1);
vec4 reg_tmp12 = vec4(0, 0, 0, 1);
vec4 reg_tmp13 = vec4(0, 0, 0, 1);
vec4 reg_tmp14 = vec4(0, 0, 0, 1);
vec4 reg_tmp15 = vec4(0, 0, 0, 1);

bool sub_11();
bool sub_4();
bool sub_8();
bool sub_1();
bool sub_2();
bool sub_3();
bool sub_5();
bool sub_6();
bool sub_7();
bool sub_9();
bool sub_10();
bool sub_12();
bool sub_13();
bool sub_14();
bool sub_15();
bool sub_16();
bool sub_17();
bool sub_18();
bool sub_19();
bool sub_20();
bool sub_21();
bool sub_22();
bool sub_23();
bool sub_24();
bool sub_36();
bool sub_25();
bool sub_26();
bool sub_27();
bool sub_28();
bool sub_29();
bool sub_30();
bool sub_31();
bool sub_32();
bool sub_33();
bool sub_34();
bool sub_35();
bool sub_51();
bool sub_39();
bool sub_40();
bool sub_41();
bool sub_42();
bool sub_43();
bool sub_50();
bool sub_0();
bool sub_37();
bool sub_38();
bool sub_44();
bool sub_45();
bool sub_46();
bool sub_47();
bool sub_49();
bool sub_48();

bool exec_shader() {
sub_0();
return true;
}

bool sub_11() {
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp3.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp3.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp3.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
return false;
}
bool sub_4() {
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp3.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp3.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp3.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp4.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
return false;
}
bool sub_8() {
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp3.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp3.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp3.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp4.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
return false;
}
bool sub_1() {
reg_tmp15.xyz = (mul_s(uniforms.f[7].xxxx, vs_in_reg0)).xyz;
reg_tmp14.xyz = (mul_s(uniforms.f[7].yyyy, vs_in_reg1)).xyz;
reg_tmp15.xyz = (uniforms.f[6] + reg_tmp15).xyz;
reg_tmp15.w = (uniforms.f[93].yyyy).w;
if (uniforms.b[1]) {
sub_2();
} else {
sub_14();
}
vs_out_attr1 = uniforms.f[93].xxxx;
vs_out_attr2 = uniforms.f[93].xxxx;
return false;
}
bool sub_2() {
reg_tmp0 = uniforms.f[7];
bool_regs = notEqual(uniforms.f[93].xx, reg_tmp0.yz);
reg_tmp7 = uniforms.f[93].xxxx;
reg_tmp12 = uniforms.f[93].xxxx;
reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_3();
} else {
sub_6();
}
reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
reg_tmp1.x = (-reg_tmp0.wwww).x;
reg_tmp1.y = (mul_s(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
bool_regs.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
bool_regs.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
if (all(bool_regs)) {
sub_13();
}
vs_out_attr0 = reg_tmp0;
return false;
}
bool sub_3() {
bool_regs = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
reg_tmp1.xy = (reg_tmp2.xxxx).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
sub_4();
reg_tmp1.xy = (reg_tmp2.yyyy).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
sub_4();
reg_tmp1.xy = (reg_tmp2.zzzz).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
if (bool_regs.x) {
sub_4();
}
if (uniforms.b[8]) {
sub_5();
}
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
return false;
}
bool sub_5() {
reg_tmp1.xy = (reg_tmp2.wwww).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
if (bool_regs.y) {
sub_4();
}
return false;
}
bool sub_6() {
if (all(bool_regs)) {
sub_7();
} else {
sub_10();
}
return false;
}
bool sub_7() {
bool_regs = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
reg_tmp1.xy = (reg_tmp2.xxxx).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
sub_8();
reg_tmp1.xy = (reg_tmp2.yyyy).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
sub_8();
reg_tmp1.xy = (reg_tmp2.zzzz).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
if (bool_regs.x) {
sub_8();
}
if (uniforms.b[8]) {
sub_9();
}
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
return false;
}
bool sub_9() {
reg_tmp1.xy = (reg_tmp2.wwww).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
if (bool_regs.y) {
sub_8();
}
return false;
}
bool sub_10() {
bool_regs = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
reg_tmp1.xy = (reg_tmp2.xxxx).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
sub_11();
reg_tmp1.xy = (reg_tmp2.yyyy).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
sub_11();
reg_tmp1.xy = (reg_tmp2.zzzz).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
if (bool_regs.x) {
sub_11();
}
if (uniforms.b[8]) {
sub_12();
}
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
return false;
}
bool sub_12() {
reg_tmp1.xy = (reg_tmp2.wwww).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
if (bool_regs.y) {
sub_11();
}
return false;
}
bool sub_13() {
reg_tmp0.x = (-reg_tmp0.wwww).x;
return false;
}
bool sub_14() {
reg_tmp0 = uniforms.f[7];
bool_regs = notEqual(uniforms.f[93].xx, reg_tmp0.yz);
if (uniforms.b[2]) {
sub_15();
} else {
sub_16();
}
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_17();
} else {
sub_18();
}
reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
reg_tmp1.x = (-reg_tmp0.wwww).x;
reg_tmp1.y = (mul_s(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
bool_regs.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
bool_regs.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
if (all(bool_regs)) {
sub_21();
}
vs_out_attr0 = reg_tmp0;
return false;
}
bool sub_15() {
reg_tmp1.x = (mul_s(uniforms.f[93].wwww, vs_in_reg7.xxxx)).x;
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp7.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp7.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp7.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
return false;
}
bool sub_16() {
addr_regs.x = (ivec2(uniforms.f[93].xx)).x;
reg_tmp10.x = dot_s(uniforms.f[25], reg_tmp15);
reg_tmp10.y = dot_s(uniforms.f[26], reg_tmp15);
reg_tmp10.z = dot_s(uniforms.f[27], reg_tmp15);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
return false;
}
bool sub_17() {
reg_tmp12.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
return false;
}
bool sub_18() {
if (all(bool_regs)) {
sub_19();
} else {
sub_20();
}
return false;
}
bool sub_19() {
reg_tmp12.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
return false;
}
bool sub_20() {
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
return false;
}
bool sub_21() {
reg_tmp0.x = (-reg_tmp0.wwww).x;
return false;
}
bool sub_22() {
reg_tmp8.xy = (uniforms.f[93].xxxx).xy;
reg_tmp0.y = (uniforms.f[7].wwww).y;
bool_regs = notEqual(uniforms.f[93].xx, reg_tmp0.xy);
reg_tmp9.xyz = (uniforms.f[93].xxxx).xyz;
reg_tmp9.w = (uniforms.f[21].wwww).w;
if (bool_regs.y) {
sub_23();
}
if (uniforms.b[12]) {
sub_25();
}
if (uniforms.b[5]) {
sub_34();
}
bool_regs = equal(uniforms.f[93].xx, reg_tmp8.xy);
if (all(bool_regs)) {
sub_36();
}
vs_out_attr3 = max_s(uniforms.f[93].xxxx, reg_tmp9);
return false;
}
bool sub_23() {
reg_tmp0 = mul_s(uniforms.f[7].wwww, vs_in_reg3);
if (uniforms.b[7]) {
sub_24();
}
reg_tmp9.xyz = (mul_s(uniforms.f[20].wwww, reg_tmp0.xyzz)).xyz;
reg_tmp8.x = (uniforms.f[93].yyyy).x;
return false;
}
bool sub_24() {
reg_tmp9.w = (mul_s(reg_tmp9.wwww, reg_tmp0.wwww)).w;
return false;
}
bool sub_36() {
reg_tmp9 = uniforms.f[21];
return false;
}
bool sub_25() {
reg_tmp1 = uniforms.f[20];
reg_tmp2 = uniforms.f[21];
reg_tmp3 = uniforms.f[93].xxxx;
addr_regs.z = int(uniforms.i[0].y);
for (uint i = 0u; i <= uniforms.i[0].x; addr_regs.z += int(uniforms.i[0].z), ++i) {
sub_26();
}
reg_tmp8.x = (uniforms.f[93].yyyy).x;
return false;
}
bool sub_26() {
addr_regs.x = (ivec2(reg_tmp3.xy)).x;
reg_tmp4.x = (uniforms.f[81 + addr_regs.x].wwww).x;
reg_tmp4.y = (uniforms.f[83 + addr_regs.x].wwww).y;
bool_regs = equal(uniforms.f[93].xy, reg_tmp4.xy);
if (bool_regs.x) {
sub_27();
} else {
sub_28();
}
bool_regs.x = uniforms.f[93].xxxx.x == reg_tmp6.xyyy.x;
bool_regs.y = uniforms.f[93].xxxx.y < reg_tmp6.xyyy.y;
if (bool_regs.y) {
sub_33();
}
reg_tmp3 = -uniforms.f[95].wwww + reg_tmp3;
return false;
}
bool sub_27() {
reg_tmp6.x = dot_3(uniforms.f[81 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp6.y = (uniforms.f[93].yyyy).y;
return false;
}
bool sub_28() {
reg_tmp4 = uniforms.f[81 + addr_regs.x] + -reg_tmp15;
reg_tmp6.y = (uniforms.f[93].yyyy).y;
if (bool_regs.y) {
sub_29();
}
reg_tmp5 = uniforms.f[82 + addr_regs.x];
bool_regs = equal(uniforms.f[93].yy, reg_tmp5.ww);
reg_tmp4.w = dot_3(reg_tmp4.xyz, reg_tmp4.xyz);
reg_tmp4.w = rsq_s(reg_tmp4.w);
reg_tmp4 = mul_s(reg_tmp4, reg_tmp4.wwww);
if (bool_regs.x) {
sub_30();
}
reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp4.xyz);
return false;
}
bool sub_29() {
reg_tmp5.x = (uniforms.f[93].yyyy).x;
reg_tmp5.z = dot_3(reg_tmp4.xyz, reg_tmp4.xyz);
reg_tmp5.y = (mul_s(reg_tmp5.zzzz, reg_tmp5.zzzz)).y;
reg_tmp6.y = dot_3(uniforms.f[83 + addr_regs.x].xyz, reg_tmp5.xyz);
reg_tmp6.y = rcp_s(reg_tmp6.y);
return false;
}
bool sub_30() {
reg_tmp5.x = dot_3(uniforms.f[82 + addr_regs.x].xyz, -reg_tmp4.xyz);
reg_tmp5.y = (vec4(lessThan(reg_tmp5.xxxx, uniforms.f[84 + addr_regs.x].yyyy))).y;
bool_regs = equal(uniforms.f[93].yy, reg_tmp5.xy);
if (bool_regs.y) {
sub_31();
} else {
sub_32();
}
reg_tmp6.y = (mul_s(reg_tmp6.yyyy, reg_tmp5.xxxx)).y;
return false;
}
bool sub_31() {
reg_tmp5.x = (uniforms.f[93].xxxx).x;
return false;
}
bool sub_32() {
reg_tmp5.y = log2(reg_tmp5.x);
reg_tmp5.y = (mul_s(uniforms.f[84 + addr_regs.x].xxxx, reg_tmp5.yyyy)).y;
reg_tmp5.x = exp2(reg_tmp5.y);
return false;
}
bool sub_33() {
reg_tmp6.x = (max_s(uniforms.f[93].xxxx, reg_tmp6.xxxx)).x;
reg_tmp9.xyz = (fma_s(reg_tmp1.xyzz, uniforms.f[79 + addr_regs.x].xyzz, reg_tmp9.xyzz)).xyz;
reg_tmp4 = mul_s(uniforms.f[80 + addr_regs.x], reg_tmp2);
reg_tmp5.xyz = (mul_s(reg_tmp6.xxxx, reg_tmp4.xyzz)).xyz;
reg_tmp5.xyz = (mul_s(reg_tmp6.yyyy, reg_tmp5.xyzz)).xyz;
reg_tmp9.xyz = (reg_tmp9.xyzz + reg_tmp5.xyzz).xyz;
reg_tmp9.w = (reg_tmp9.wwww + reg_tmp4.wwww).w;
return false;
}
bool sub_34() {
reg_tmp1 = vec4(dot_3(uniforms.f[24].xyz, reg_tmp14.xyz));
reg_tmp2 = uniforms.f[24].wwww;
reg_tmp1 = fma_s(reg_tmp1, reg_tmp2, reg_tmp2);
reg_tmp3 = uniforms.f[22];
reg_tmp2 = uniforms.f[23] + -reg_tmp3;
reg_tmp4 = fma_s(reg_tmp2, reg_tmp1, reg_tmp3);
if (uniforms.b[6]) {
sub_35();
}
reg_tmp9.xyz = (fma_s(reg_tmp4, uniforms.f[21], reg_tmp9)).xyz;
reg_tmp8.x = (uniforms.f[93].yyyy).x;
return false;
}
bool sub_35() {
reg_tmp4 = mul_s(reg_tmp4, reg_tmp9.wwww);
return false;
}
bool sub_51() {
reg_tmp5.x = dot_3(uniforms.f[90].xyz, reg_tmp12.xyz);
reg_tmp5.y = dot_3(uniforms.f[91].xyz, reg_tmp12.xyz);
reg_tmp5.z = dot_3(uniforms.f[92].xyz, reg_tmp12.xyz);
reg_tmp4.x = dot_s(reg_tmp5.xyzz, reg_tmp5.xyzz);
reg_tmp4.x = rsq_s(reg_tmp4.x);
reg_tmp4.xyz = (mul_s(reg_tmp5.xyzz, reg_tmp4.xxxx)).xyz;
reg_tmp4 = mul_s(uniforms.f[94].zzzz, reg_tmp4);
reg_tmp12 = uniforms.f[94].zzzz + reg_tmp4;
vs_out_attr5 = reg_tmp12;
return false;
}
bool sub_39() {
bool_regs = equal(uniforms.f[93].yz, reg_tmp0.xy);
if (all(not(bool_regs))) {
sub_40();
} else {
sub_41();
}
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
return false;
}
bool sub_40() {
reg_tmp6.xy = (mul_s(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
return false;
}
bool sub_41() {
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_42();
} else {
sub_43();
}
return false;
}
bool sub_42() {
reg_tmp6.xy = (mul_s(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
return false;
}
bool sub_43() {
reg_tmp6.xy = (mul_s(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
return false;
}
bool sub_50() {
reg_tmp1.xy = (uniforms.f[94].zzzz).xy;
reg_tmp1.zw = (uniforms.f[93].xxxx).zw;
reg_tmp6 = fma_s(reg_tmp14, reg_tmp1, reg_tmp1);
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
return false;
}
bool sub_0() {
sub_1();
sub_22();
sub_37();
sub_51();
return true;
}
bool sub_37() {
reg_tmp0.xy = (uniforms.f[10].xxxx).xy;
if (uniforms.b[9]) {
sub_38();
} else {
sub_44();
}
return false;
}
bool sub_38() {
sub_39();
reg_tmp3.x = dot_s(uniforms.f[11].xywz, reg_tmp6);
reg_tmp3.y = dot_s(uniforms.f[12].xywz, reg_tmp6);
reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
vs_out_attr4 = reg_tmp3;
return false;
}
bool sub_44() {
bool_regs = equal(uniforms.f[95].xy, reg_tmp0.xy);
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
if (all(not(bool_regs))) {
sub_45();
} else {
sub_46();
}
vs_out_attr4 = reg_tmp3;
return false;
}
bool sub_45() {
reg_tmp6 = reg_tmp10;
reg_tmp3.x = dot_s(uniforms.f[11], reg_tmp6);
reg_tmp3.y = dot_s(uniforms.f[12], reg_tmp6);
reg_tmp3.z = dot_s(uniforms.f[13], reg_tmp6);
reg_tmp0.xy = (mul_s(uniforms.f[19].xyyy, reg_tmp3.zzzz)).xy;
reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
return false;
}
bool sub_46() {
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_47();
} else {
sub_49();
}
return false;
}
bool sub_47() {
sub_48();
reg_tmp3.x = dot_3(uniforms.f[11].xyz, reg_tmp6.xyz);
reg_tmp3.y = dot_3(uniforms.f[12].xyz, reg_tmp6.xyz);
reg_tmp3.z = dot_3(uniforms.f[13].xyz, reg_tmp6.xyz);
return false;
}
bool sub_49() {
sub_50();
reg_tmp3.x = dot_s(uniforms.f[11], reg_tmp6);
reg_tmp3.y = dot_s(uniforms.f[12], reg_tmp6);
return false;
}
bool sub_48() {
reg_tmp2 = -reg_tmp15;
reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
reg_tmp2.w = rsq_s(reg_tmp2.w);
reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
reg_tmp1 = reg_tmp1 + reg_tmp1;
reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
return false;
}
// reference: C801BC2B7E34741A, 347CF703F011E4BE
// program: 347CF703F011E4BE, F777123A8C3D5E20, A5F32A6ABE370BE3
// program: 347CF703F011E4BE, F777123A8C3D5E20, 7FF56148DAB844CE
// program: 0DC2C13FBB70BE34, EADA2116091C5E01, 2B7E429A428B86E4
// shader: 8B30, 7CDF1F7E788B6CEF
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 texcolor1 = textureLod(tex1, texcoord1, getLod(texcoord1 * vec2(textureSize(tex1, 0))) + tex_lod_bias[1]);
vec4 texcolor2 = textureLod(tex2, texcoord2, getLod(texcoord2 * vec2(textureSize(tex2, 0))) + tex_lod_bias[2]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((vec3(1) - texcolor0.rrr) - (vec3(1) - texcolor1.rrr), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((1.0 - texcolor0.r) - (1.0 - texcolor2.r), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0 * 4.0, alpha_output_0 * 4.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) + (last_tex_env_out.aaa), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1 * 4.0, alpha_output_1 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2 * 4.0, alpha_output_2 * 1.0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = byteround(clamp((texcolor0.rgb) * (const_color[3].rgb), vec3(0), vec3(1)));
float alpha_output_3 = byteround(clamp((texcolor0.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_4 = byteround(clamp((vec3(1) - texcolor0.rgb) * (const_color[4].rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_4 = byteround(clamp((1.0 - texcolor0.a) * (const_color[4].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
if (last_tex_env_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: DE27D8C17F48E6DF, 7CDF1F7E788B6CEF
// program: 4DBF54CC7897BA20, B6B95AFD9466EC70, 7CDF1F7E788B6CEF
// shader: 8B30, 70F4D00B02C77879
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp(min((texcolor0.rrr) + (texcolor0.ggg), vec3(1)) * (const_color[0].aaa), vec3(0), vec3(1)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((texcolor0.bbb) * (const_color[1].aaa) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (vec3(1) - const_color[2].aaa) + (const_color[2].rgb) * (vec3(1) - (vec3(1) - const_color[2].aaa)), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = byteround(clamp((last_tex_env_out.rgb) * (const_color[3].rgb), vec3(0), vec3(1)));
float alpha_output_3 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_4 = byteround(clamp((texcolor0.rgb) * (vec3(1) - const_color[4].aaa) + (last_tex_env_out.rgb) * (vec3(1) - (vec3(1) - const_color[4].aaa)), vec3(0), vec3(1)));
float alpha_output_4 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_5 = byteround(clamp((last_tex_env_out.rgb) * (const_color[5].rgb), vec3(0), vec3(1)));
float alpha_output_5 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 3B03772044D7EA3A, 70F4D00B02C77879
// program: DB0B4C6763B81C5A, EADA2116091C5E01, 70F4D00B02C77879
// shader: 8B30, 8BA3C2A2F2F4FFEA
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp(min((texcolor0.rrr) + (texcolor0.ggg), vec3(1)) * (const_color[0].aaa), vec3(0), vec3(1)));
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((texcolor0.bbb) * (const_color[1].aaa) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_1 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_2 = byteround(clamp((last_tex_env_out.rgb) * (vec3(1) - const_color[2].aaa) + (const_color[2].rgb) * (vec3(1) - (vec3(1) - const_color[2].aaa)), vec3(0), vec3(1)));
float alpha_output_2 = (last_tex_env_out.a);
last_tex_env_out = vec4(color_output_2, alpha_output_2);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_3 = byteround(clamp((const_color[3].rgb) * (vec3(1) - texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_3 = byteround(clamp((const_color[3].a) * (1.0 - texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (texcolor0.rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (texcolor0.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
if (last_tex_env_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: D766BACDE03275A5, 8BA3C2A2F2F4FFEA
// program: 4DBF54CC7897BA20, B6B95AFD9466EC70, 8BA3C2A2F2F4FFEA
// reference: B74C2A12C78820EE, FD29673C2E307195
// shader: 8B31, F1277E9BF4ACF0F2

#define mul_s(x, y) mix(x * y, vec4(0), isnan(x * y))
#define mul_3(x, y) mix(x * y, vec3(0), isnan(x * y))
#define fma_s(x, y, z) (mul_s(x, y) + z)
#define dot_s(x, y) dot(mul_s(x, y), vec4(1))
#define dot_3(x, y) dot(mul_3(x, y), vec3(1))

float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x == 0.0) return x;
    return inversesqrt(x);
}

#define min_s(x, y) min(x, y)
#define max_s(x, y) max(x, y)

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout(binding=2, std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location=0) in vec4 vs_in_reg0;
layout(location=1) in vec4 vs_in_reg1;
layout(location=2) in vec4 vs_in_reg2;
layout(location=3) in vec4 vs_in_reg3;
layout(location=4) in vec4 vs_in_reg4;
layout(location=5) in vec4 vs_in_reg5;
layout(location=6) in vec4 vs_in_reg6;
layout(location=7) in vec4 vs_in_reg7;
layout(location=8) in vec4 vs_in_reg8;

layout(location=0) out vec4 vs_out_attr0;
layout(location=1) out vec4 vs_out_attr1;
layout(location=2) out vec4 vs_out_attr2;
layout(location=3) out vec4 vs_out_attr3;
layout(location=4) out vec4 vs_out_attr4;
layout(location=5) out vec4 vs_out_attr5;
layout(location=6) out vec4 vs_out_attr6;

void main() {
vs_out_attr0 = vec4(0, 0, 0, 1);
vs_out_attr1 = vec4(0, 0, 0, 1);
vs_out_attr2 = vec4(0, 0, 0, 1);
vs_out_attr3 = vec4(0, 0, 0, 1);
vs_out_attr4 = vec4(0, 0, 0, 1);
vs_out_attr5 = vec4(0, 0, 0, 1);
vs_out_attr6 = vec4(0, 0, 0, 1);
exec_shader();
}
bvec2 bool_regs = bvec2(false);
ivec3 addr_regs = ivec3(0);
vec4 reg_tmp0 = vec4(0, 0, 0, 1);
vec4 reg_tmp1 = vec4(0, 0, 0, 1);
vec4 reg_tmp2 = vec4(0, 0, 0, 1);
vec4 reg_tmp3 = vec4(0, 0, 0, 1);
vec4 reg_tmp4 = vec4(0, 0, 0, 1);
vec4 reg_tmp5 = vec4(0, 0, 0, 1);
vec4 reg_tmp6 = vec4(0, 0, 0, 1);
vec4 reg_tmp7 = vec4(0, 0, 0, 1);
vec4 reg_tmp8 = vec4(0, 0, 0, 1);
vec4 reg_tmp9 = vec4(0, 0, 0, 1);
vec4 reg_tmp10 = vec4(0, 0, 0, 1);
vec4 reg_tmp11 = vec4(0, 0, 0, 1);
vec4 reg_tmp12 = vec4(0, 0, 0, 1);
vec4 reg_tmp13 = vec4(0, 0, 0, 1);
vec4 reg_tmp14 = vec4(0, 0, 0, 1);
vec4 reg_tmp15 = vec4(0, 0, 0, 1);

bool sub_0();
bool sub_21();
bool sub_4();
bool sub_9();
bool sub_1();
bool sub_2();
bool sub_3();
bool sub_5();
bool sub_7();
bool sub_8();
bool sub_10();
bool sub_20();
bool sub_22();
bool sub_23();
bool sub_24();
bool sub_25();
bool sub_26();
bool sub_27();
bool sub_28();
bool sub_29();
bool sub_30();
bool sub_31();
bool sub_6();
bool sub_11();
bool sub_12();
bool sub_13();
bool sub_14();
bool sub_15();
bool sub_16();
bool sub_17();
bool sub_18();
bool sub_19();
bool sub_32();
bool sub_33();
bool sub_34();
bool sub_35();
bool sub_36();
bool sub_37();
bool sub_38();
bool sub_39();
bool sub_40();
bool sub_46();
bool sub_47();
bool sub_48();
bool sub_49();
bool sub_51();
bool sub_41();
bool sub_42();
bool sub_43();
bool sub_44();
bool sub_45();
bool sub_50();
bool sub_52();
bool sub_53();
bool sub_54();
bool sub_55();
bool sub_56();
bool sub_57();
bool sub_58();
bool sub_59();
bool sub_60();
bool sub_61();
bool sub_62();
bool sub_63();
bool sub_64();

bool exec_shader() {
sub_0();
return true;
}

bool sub_0() {
sub_1();
sub_32();
sub_39();
sub_53();
sub_60();
return true;
}
bool sub_21() {
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp3.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp3.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp3.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
return false;
}
bool sub_4() {
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp3.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp3.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp3.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp4.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
return false;
}
bool sub_9() {
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp3.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp3.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp3.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp4.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp4.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp5.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp5.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp5.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
reg_tmp12 = fma_s(reg_tmp1.wwww, reg_tmp4, reg_tmp12);
reg_tmp11 = fma_s(reg_tmp1.wwww, reg_tmp5, reg_tmp11);
return false;
}
bool sub_1() {
reg_tmp15.xyz = (mul_s(uniforms.f[7].xxxx, vs_in_reg0)).xyz;
reg_tmp14.xyz = (mul_s(uniforms.f[7].yyyy, vs_in_reg1)).xyz;
reg_tmp13.xyz = (mul_s(uniforms.f[7].zzzz, vs_in_reg2)).xyz;
reg_tmp15.xyz = (uniforms.f[6] + reg_tmp15).xyz;
reg_tmp15.w = (uniforms.f[93].yyyy).w;
if (uniforms.b[1]) {
sub_2();
} else {
sub_24();
}
return false;
}
bool sub_2() {
reg_tmp0 = uniforms.f[7];
bool_regs = notEqual(uniforms.f[93].xx, reg_tmp0.yz);
reg_tmp7 = uniforms.f[93].xxxx;
reg_tmp12 = uniforms.f[93].xxxx;
reg_tmp11 = uniforms.f[93].xxxx;
reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_3();
} else {
sub_7();
}
vs_out_attr2 = -reg_tmp15;
reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
reg_tmp1.x = (-reg_tmp0.wwww).x;
reg_tmp1.y = (mul_s(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
bool_regs.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
bool_regs.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
if (all(bool_regs)) {
sub_23();
}
vs_out_attr0 = reg_tmp0;
return false;
}
bool sub_3() {
bool_regs = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
reg_tmp1.xy = (reg_tmp2.xxxx).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
sub_4();
reg_tmp1.xy = (reg_tmp2.yyyy).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
sub_4();
reg_tmp1.xy = (reg_tmp2.zzzz).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
if (bool_regs.x) {
sub_4();
}
if (uniforms.b[8]) {
sub_5();
}
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
sub_6();
return false;
}
bool sub_5() {
reg_tmp1.xy = (reg_tmp2.wwww).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
if (bool_regs.y) {
sub_4();
}
return false;
}
bool sub_7() {
if (all(bool_regs)) {
sub_8();
} else {
sub_20();
}
return false;
}
bool sub_8() {
bool_regs = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
reg_tmp1.xy = (reg_tmp2.xxxx).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
sub_9();
reg_tmp1.xy = (reg_tmp2.yyyy).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
sub_9();
reg_tmp1.xy = (reg_tmp2.zzzz).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
if (bool_regs.x) {
sub_9();
}
if (uniforms.b[8]) {
sub_10();
}
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp13.x = dot_3(uniforms.f[3].xyz, reg_tmp11.xyz);
reg_tmp13.y = dot_3(uniforms.f[4].xyz, reg_tmp11.xyz);
reg_tmp13.z = dot_3(uniforms.f[5].xyz, reg_tmp11.xyz);
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
sub_11();
return false;
}
bool sub_10() {
reg_tmp1.xy = (reg_tmp2.wwww).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
if (bool_regs.y) {
sub_9();
}
return false;
}
bool sub_20() {
bool_regs = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
reg_tmp1.xy = (reg_tmp2.xxxx).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
sub_21();
reg_tmp1.xy = (reg_tmp2.yyyy).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
sub_21();
reg_tmp1.xy = (reg_tmp2.zzzz).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
if (bool_regs.x) {
sub_21();
}
if (uniforms.b[8]) {
sub_22();
}
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
vs_out_attr1 = uniforms.f[93].xxxx;
return false;
}
bool sub_22() {
reg_tmp1.xy = (reg_tmp2.wwww).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
if (bool_regs.y) {
sub_21();
}
return false;
}
bool sub_23() {
reg_tmp0.x = (-reg_tmp0.wwww).x;
return false;
}
bool sub_24() {
reg_tmp0 = uniforms.f[7];
bool_regs = notEqual(uniforms.f[93].xx, reg_tmp0.yz);
if (uniforms.b[2]) {
sub_25();
} else {
sub_26();
}
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_27();
} else {
sub_28();
}
vs_out_attr2 = -reg_tmp15;
reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
reg_tmp1.x = (-reg_tmp0.wwww).x;
reg_tmp1.y = (mul_s(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
bool_regs.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
bool_regs.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
if (all(bool_regs)) {
sub_31();
}
vs_out_attr0 = reg_tmp0;
return false;
}
bool sub_25() {
reg_tmp1.x = (mul_s(uniforms.f[93].wwww, vs_in_reg7.xxxx)).x;
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp7.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp7.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp7.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
return false;
}
bool sub_26() {
addr_regs.x = (ivec2(uniforms.f[93].xx)).x;
reg_tmp10.x = dot_s(uniforms.f[25], reg_tmp15);
reg_tmp10.y = dot_s(uniforms.f[26], reg_tmp15);
reg_tmp10.z = dot_s(uniforms.f[27], reg_tmp15);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
return false;
}
bool sub_27() {
reg_tmp12.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
sub_6();
return false;
}
bool sub_28() {
if (all(bool_regs)) {
sub_29();
} else {
sub_30();
}
return false;
}
bool sub_29() {
reg_tmp12.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp12.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp11.x = dot_3(uniforms.f[25 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp11.y = dot_3(uniforms.f[26 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp11.z = dot_3(uniforms.f[27 + addr_regs.x].xyz, reg_tmp13.xyz);
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
reg_tmp14.x = dot_3(uniforms.f[3].xyz, reg_tmp12.xyz);
reg_tmp14.y = dot_3(uniforms.f[4].xyz, reg_tmp12.xyz);
reg_tmp14.z = dot_3(uniforms.f[5].xyz, reg_tmp12.xyz);
reg_tmp13.x = dot_3(uniforms.f[3].xyz, reg_tmp11.xyz);
reg_tmp13.y = dot_3(uniforms.f[4].xyz, reg_tmp11.xyz);
reg_tmp13.z = dot_3(uniforms.f[5].xyz, reg_tmp11.xyz);
sub_11();
return false;
}
bool sub_30() {
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
vs_out_attr1 = uniforms.f[93].xxxx;
return false;
}
bool sub_31() {
reg_tmp0.x = (-reg_tmp0.wwww).x;
return false;
}
bool sub_6() {
uint jmp_to = 214u;
while (true) {
switch (jmp_to) {
case 214u:
reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
reg_tmp6.x = rsq_s(reg_tmp6.x);
reg_tmp7.x = rsq_s(reg_tmp7.x);
reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp0 = uniforms.f[93].yxxx;
if (!uniforms.b[15]) {
jmp_to = 230u; break;
}
reg_tmp4 = uniforms.f[93].yyyy + reg_tmp14.zzzz;
reg_tmp4 = mul_s(uniforms.f[94].zzzz, reg_tmp4);
bool_regs = greaterThanEqual(uniforms.f[93].xx, reg_tmp4.xx);
reg_tmp4 = vec4(rsq_s(reg_tmp4.x));
reg_tmp5 = mul_s(uniforms.f[94].zzzz, reg_tmp14);
if (bool_regs.x) {
jmp_to = 230u; break;
}
reg_tmp0.z = rcp_s(reg_tmp4.x);
reg_tmp0.xy = (mul_s(reg_tmp5, reg_tmp4)).xy;
case 230u:
vs_out_attr1 = reg_tmp0;
default: return false;
}
}
return false;
}
bool sub_11() {
uint jmp_to = 231u;
while (true) {
switch (jmp_to) {
case 231u:
reg_tmp6.x = dot_3(reg_tmp14.xyz, reg_tmp14.xyz);
reg_tmp7.x = dot_3(reg_tmp12.xyz, reg_tmp12.xyz);
reg_tmp6.x = rsq_s(reg_tmp6.x);
reg_tmp7.x = rsq_s(reg_tmp7.x);
reg_tmp14.xyz = (mul_s(reg_tmp14.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp12.xyz = (mul_s(reg_tmp12.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp13.xyz = (mul_s(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp11.xyz = (mul_s(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp0 = uniforms.f[93].yxxx;
if (!uniforms.b[15]) {
jmp_to = 306u; break;
}
reg_tmp13.xyz = (mul_s(reg_tmp13.xyzz, reg_tmp6.xxxx)).xyz;
reg_tmp11.xyz = (mul_s(reg_tmp11.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp5 = mul_s(reg_tmp14.yzxx, reg_tmp13.zxyy);
reg_tmp5 = fma_s(-reg_tmp13.yzxx, reg_tmp14.zxyy, reg_tmp5);
reg_tmp5.w = dot_3(reg_tmp5.xyz, reg_tmp5.xyz);
reg_tmp5.w = rsq_s(reg_tmp5.w);
reg_tmp5 = mul_s(reg_tmp5, reg_tmp5.wwww);
reg_tmp6.w = (reg_tmp14.zzzz + reg_tmp5.yyyy).w;
reg_tmp13 = mul_s(reg_tmp5.yzxx, reg_tmp14.zxyy);
reg_tmp13 = fma_s(-reg_tmp14.yzxx, reg_tmp5.zxyy, reg_tmp13);
reg_tmp6.w = (reg_tmp13.xxxx + reg_tmp6).w;
reg_tmp13.w = (reg_tmp5.zzzz).w;
reg_tmp5.z = (reg_tmp13.xxxx).z;
reg_tmp6.w = (uniforms.f[93].yyyy + reg_tmp6).w;
reg_tmp14.w = (reg_tmp5.xxxx).w;
reg_tmp5.x = (reg_tmp14.zzzz).x;
bool_regs = lessThan(uniforms.f[94].yy, reg_tmp6.ww);
reg_tmp6.x = (uniforms.f[93].yyyy).x;
reg_tmp6.y = (-uniforms.f[93].yyyy).y;
if (!bool_regs.x) {
jmp_to = 268u; break;
}
reg_tmp7.xz = (reg_tmp13.wwyy + -reg_tmp14.yyww).xz;
reg_tmp7.y = (reg_tmp14.xxxx + -reg_tmp13.zzzz).y;
reg_tmp7.w = (reg_tmp6).w;
reg_tmp6 = vec4(dot_s(reg_tmp7, reg_tmp7));
reg_tmp6 = vec4(rsq_s(reg_tmp6.x));
reg_tmp0 = mul_s(reg_tmp7, reg_tmp6);
if (uniforms.b[0]) {
jmp_to = 306u; break;
}
case 268u:
bool_regs = greaterThan(reg_tmp5.zy, reg_tmp5.yx);
if (bool_regs.x) {
sub_12();
} else {
sub_17();
}
reg_tmp6 = vec4(dot_s(reg_tmp8, reg_tmp8));
reg_tmp6 = vec4(rsq_s(reg_tmp6.x));
reg_tmp0 = mul_s(reg_tmp8, reg_tmp6);
case 306u:
vs_out_attr1 = reg_tmp0;
default: return false;
}
}
return false;
}
bool sub_12() {
if (bool_regs.y) {
sub_13();
} else {
sub_14();
}
reg_tmp8.w = (-reg_tmp8).w;
return false;
}
bool sub_13() {
reg_tmp8 = mul_s(reg_tmp13.yyzw, reg_tmp6.xxxy);
reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
return false;
}
bool sub_14() {
bool_regs = greaterThan(reg_tmp5.zz, reg_tmp5.xx);
reg_tmp8 = mul_s(reg_tmp13.yyzw, reg_tmp6.xxxy);
reg_tmp8.x = (uniforms.f[93].yyyy + -reg_tmp5.yyyy).x;
if (bool_regs.x) {
sub_15();
} else {
sub_16();
}
return false;
}
bool sub_15() {
reg_tmp9 = reg_tmp5.zzzz + -reg_tmp5.xxxx;
reg_tmp8.yzw = (reg_tmp8 + reg_tmp14.wwxy).yzw;
reg_tmp8.x = (reg_tmp9 + reg_tmp8).x;
return false;
}
bool sub_16() {
reg_tmp8 = mul_s(reg_tmp13.zwwy, reg_tmp6.xxxy);
reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
return false;
}
bool sub_17() {
if (bool_regs.y) {
sub_18();
} else {
sub_19();
}
return false;
}
bool sub_18() {
reg_tmp8 = mul_s(reg_tmp13.yywz, reg_tmp6.xxxy);
reg_tmp8.y = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).y;
reg_tmp9 = reg_tmp5.yyyy + -reg_tmp5.xxxx;
reg_tmp8.xzw = (reg_tmp8 + reg_tmp14.wwyx).xzw;
reg_tmp8.y = (reg_tmp9 + reg_tmp8).y;
return false;
}
bool sub_19() {
reg_tmp8 = mul_s(reg_tmp13.zwwy, reg_tmp6.xxxy);
reg_tmp8.z = (uniforms.f[93].yyyy + -reg_tmp5.zzzz).z;
reg_tmp9 = reg_tmp5.xxxx + -reg_tmp5.yyyy;
reg_tmp8.xyw = (reg_tmp8 + reg_tmp14.xyyw).xyw;
reg_tmp8.z = (reg_tmp9 + reg_tmp8).z;
reg_tmp8.w = (-reg_tmp8).w;
return false;
}
bool sub_32() {
reg_tmp8.xy = (uniforms.f[93].xxxx).xy;
reg_tmp0.y = (uniforms.f[7].wwww).y;
bool_regs = notEqual(uniforms.f[93].xx, reg_tmp0.xy);
reg_tmp9.xyz = (uniforms.f[93].xxxx).xyz;
reg_tmp9.w = (uniforms.f[21].wwww).w;
if (bool_regs.y) {
sub_33();
}
if (uniforms.b[12]) {
sub_35();
}
if (uniforms.b[5]) {
sub_37();
}
vs_out_attr3 = max_s(uniforms.f[93].xxxx, reg_tmp9);
return false;
}
bool sub_33() {
reg_tmp0 = mul_s(uniforms.f[7].wwww, vs_in_reg3);
if (uniforms.b[7]) {
sub_34();
}
reg_tmp9.xyz = (mul_s(uniforms.f[20].wwww, reg_tmp0.xyzz)).xyz;
reg_tmp8.x = (uniforms.f[93].yyyy).x;
return false;
}
bool sub_34() {
reg_tmp9.w = (mul_s(reg_tmp9.wwww, reg_tmp0.wwww)).w;
return false;
}
bool sub_35() {
reg_tmp1 = uniforms.f[20];
reg_tmp2 = uniforms.f[21];
reg_tmp3 = uniforms.f[93].xxxx;
reg_tmp0 = uniforms.f[93].xxxx;
addr_regs.z = int(uniforms.i[0].y);
for (uint i = 0u; i <= uniforms.i[0].x; addr_regs.z += int(uniforms.i[0].z), ++i) {
sub_36();
}
reg_tmp9.xyz = (mul_s(reg_tmp9.xyzz, reg_tmp0.xyzz)).xyz;
reg_tmp8.x = (uniforms.f[93].yyyy).x;
return false;
}
bool sub_36() {
addr_regs.x = (ivec2(reg_tmp3.xy)).x;
reg_tmp4.x = (uniforms.f[81 + addr_regs.x].wwww).x;
reg_tmp4.y = (uniforms.f[83 + addr_regs.x].wwww).y;
reg_tmp6.x = dot_3(uniforms.f[81 + addr_regs.x].xyz, reg_tmp14.xyz);
reg_tmp6.x = (max_s(uniforms.f[93].xxxx, reg_tmp6.xxxx)).x;
reg_tmp0.xyz = (fma_s(reg_tmp1.xyzz, uniforms.f[79 + addr_regs.x].xyzz, reg_tmp0.xyzz)).xyz;
reg_tmp4 = mul_s(uniforms.f[80 + addr_regs.x], reg_tmp2);
reg_tmp5.xyz = (mul_s(reg_tmp6.xxxx, reg_tmp4.xyzz)).xyz;
reg_tmp0.xyz = (reg_tmp0.xyzz + reg_tmp5.xyzz).xyz;
reg_tmp0.w = (reg_tmp0.wwww + reg_tmp4.wwww).w;
reg_tmp3 = -uniforms.f[95].wwww + reg_tmp3;
return false;
}
bool sub_37() {
reg_tmp1 = vec4(dot_3(uniforms.f[24].xyz, reg_tmp14.xyz));
reg_tmp2 = uniforms.f[24].wwww;
reg_tmp1 = fma_s(reg_tmp1, reg_tmp2, reg_tmp2);
reg_tmp3 = uniforms.f[22];
reg_tmp2 = uniforms.f[23] + -reg_tmp3;
reg_tmp4 = fma_s(reg_tmp2, reg_tmp1, reg_tmp3);
if (uniforms.b[6]) {
sub_38();
}
reg_tmp9.xyz = (fma_s(reg_tmp4, uniforms.f[21], reg_tmp9)).xyz;
reg_tmp8.x = (uniforms.f[93].yyyy).x;
return false;
}
bool sub_38() {
reg_tmp4 = mul_s(reg_tmp4, reg_tmp9.wwww);
return false;
}
bool sub_39() {
reg_tmp0.xy = (uniforms.f[10].xxxx).xy;
if (uniforms.b[9]) {
sub_40();
} else {
sub_46();
}
return false;
}
bool sub_40() {
sub_41();
reg_tmp3.x = dot_s(uniforms.f[11].xywz, reg_tmp6);
reg_tmp3.y = dot_s(uniforms.f[12].xywz, reg_tmp6);
reg_tmp3.zw = (uniforms.f[93].xxxx).zw;
vs_out_attr4 = reg_tmp3;
return false;
}
bool sub_46() {
bool_regs = equal(uniforms.f[95].xy, reg_tmp0.xy);
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
if (all(not(bool_regs))) {
sub_47();
} else {
sub_48();
}
vs_out_attr4 = reg_tmp3;
return false;
}
bool sub_47() {
reg_tmp6 = reg_tmp10;
reg_tmp3.x = dot_s(uniforms.f[11], reg_tmp6);
reg_tmp3.y = dot_s(uniforms.f[12], reg_tmp6);
reg_tmp3.z = dot_s(uniforms.f[13], reg_tmp6);
reg_tmp0.xy = (mul_s(uniforms.f[19].xyyy, reg_tmp3.zzzz)).xy;
reg_tmp3.xy = (reg_tmp3.xyyy + reg_tmp0.xyyy).xy;
return false;
}
bool sub_48() {
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_49();
} else {
sub_51();
}
return false;
}
bool sub_49() {
sub_50();
reg_tmp3.x = dot_3(uniforms.f[11].xyz, reg_tmp6.xyz);
reg_tmp3.y = dot_3(uniforms.f[12].xyz, reg_tmp6.xyz);
reg_tmp3.z = dot_3(uniforms.f[13].xyz, reg_tmp6.xyz);
return false;
}
bool sub_51() {
sub_52();
reg_tmp3.x = dot_s(uniforms.f[11], reg_tmp6);
reg_tmp3.y = dot_s(uniforms.f[12], reg_tmp6);
return false;
}
bool sub_41() {
bool_regs = equal(uniforms.f[93].yz, reg_tmp0.xy);
if (all(not(bool_regs))) {
sub_42();
} else {
sub_43();
}
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
return false;
}
bool sub_42() {
reg_tmp6.xy = (mul_s(uniforms.f[8].xxxx, vs_in_reg4.xyyy)).xy;
return false;
}
bool sub_43() {
if (all(bvec2(bool_regs.x, !bool_regs.y))) {
sub_44();
} else {
sub_45();
}
return false;
}
bool sub_44() {
reg_tmp6.xy = (mul_s(uniforms.f[8].yyyy, vs_in_reg5.xyyy)).xy;
return false;
}
bool sub_45() {
reg_tmp6.xy = (mul_s(uniforms.f[8].zzzz, vs_in_reg6.xyyy)).xy;
return false;
}
bool sub_50() {
reg_tmp2 = -reg_tmp15;
reg_tmp2.w = dot_3(reg_tmp2.xyz, reg_tmp2.xyz);
reg_tmp2.w = rsq_s(reg_tmp2.w);
reg_tmp2 = mul_s(reg_tmp2, reg_tmp2.wwww);
reg_tmp1 = vec4(dot_3(reg_tmp2.xyz, reg_tmp14.xyz));
reg_tmp1 = reg_tmp1 + reg_tmp1;
reg_tmp6 = fma_s(reg_tmp1, reg_tmp14, -reg_tmp2);
return false;
}
bool sub_52() {
reg_tmp1.xy = (uniforms.f[94].zzzz).xy;
reg_tmp1.zw = (uniforms.f[93].xxxx).zw;
reg_tmp6 = fma_s(reg_tmp14, reg_tmp1, reg_tmp1);
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
return false;
}
bool sub_53() {
reg_tmp0.xy = (uniforms.f[10].yyyy).xy;
if (uniforms.b[10]) {
sub_54();
} else {
sub_55();
}
return false;
}
bool sub_54() {
sub_41();
reg_tmp4.x = dot_s(uniforms.f[14].xywz, reg_tmp6);
reg_tmp4.y = dot_s(uniforms.f[15].xywz, reg_tmp6);
vs_out_attr5 = reg_tmp4;
return false;
}
bool sub_55() {
if (uniforms.b[13]) {
sub_56();
} else {
sub_59();
}
return false;
}
bool sub_56() {
bool_regs = equal(uniforms.f[95].xy, reg_tmp0.xy);
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
if (all(not(bool_regs))) {
sub_57();
} else {
sub_58();
}
vs_out_attr5 = reg_tmp4;
return false;
}
bool sub_57() {
reg_tmp6 = reg_tmp10;
reg_tmp4.x = dot_s(uniforms.f[14], reg_tmp6);
reg_tmp4.y = dot_s(uniforms.f[15], reg_tmp6);
reg_tmp4.z = dot_s(uniforms.f[16], reg_tmp6);
reg_tmp6.w = rcp_s(reg_tmp4.z);
reg_tmp4.xy = (mul_s(reg_tmp4.xyyy, reg_tmp6.wwww)).xy;
reg_tmp4.xy = (uniforms.f[19].zwww + reg_tmp4.xyyy).xy;
return false;
}
bool sub_58() {
sub_52();
reg_tmp4.x = dot_s(uniforms.f[14], reg_tmp6);
reg_tmp4.y = dot_s(uniforms.f[15], reg_tmp6);
return false;
}
bool sub_59() {
vs_out_attr5 = uniforms.f[93].xxxx;
return false;
}
bool sub_60() {
reg_tmp0.xy = (uniforms.f[10].zzzz).xy;
if (uniforms.b[11]) {
sub_61();
} else {
sub_62();
}
return false;
}
bool sub_61() {
sub_41();
reg_tmp5.x = dot_s(uniforms.f[17].xywz, reg_tmp6);
reg_tmp5.y = dot_s(uniforms.f[18].xywz, reg_tmp6);
vs_out_attr6 = reg_tmp5;
return false;
}
bool sub_62() {
if (uniforms.b[14]) {
sub_63();
} else {
sub_64();
}
return false;
}
bool sub_63() {
reg_tmp6.zw = (uniforms.f[93].xxyy).zw;
reg_tmp5.zw = (reg_tmp6.zwww).zw;
sub_52();
reg_tmp5.x = dot_s(uniforms.f[17], reg_tmp6);
reg_tmp5.y = dot_s(uniforms.f[18], reg_tmp6);
vs_out_attr6 = reg_tmp5;
return false;
}
bool sub_64() {
vs_out_attr6 = uniforms.f[93].xxxx;
return false;
}
// reference: 0A1E95F932B945B7, F1277E9BF4ACF0F2
// shader: 8B30, B9C6D51CDD7DAE24
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].rgb), vec3(0), vec3(1)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (const_color[1].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 0EA19F500CC3619A, B9C6D51CDD7DAE24
// program: F1277E9BF4ACF0F2, EADA2116091C5E01, B9C6D51CDD7DAE24
// shader: 8B30, C4766247CEF10397
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_1 = byteround(clamp((last_tex_env_out.rgb) * (const_color[1].rgb), vec3(0), vec3(1)));
float alpha_output_1 = byteround(clamp((last_tex_env_out.a) * (const_color[1].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_1, alpha_output_1);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
if (last_tex_env_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 39327A710CC3619A, C4766247CEF10397
// program: F1277E9BF4ACF0F2, EADA2116091C5E01, C4766247CEF10397
// shader: 8B30, 5CE6405621C2F557
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = (const_color[0].a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 22A391A1F407CE9D, 5CE6405621C2F557
// program: AEF4EEAE6F9585E0, F777123A8C3D5E20, 5CE6405621C2F557
// reference: 22A391A1A2EB76D3, 5CE6405621C2F557
// reference: 55E0FBB11066CE04, 5CE6405621C2F557
// shader: 8DD9, FD710FDC3CE23CF8

#define mul_s(x, y) mix(x * y, vec4(0), isnan(x * y))
#define mul_3(x, y) mix(x * y, vec3(0), isnan(x * y))
#define fma_s(x, y, z) (mul_s(x, y) + z)
#define dot_s(x, y) dot(mul_s(x, y), vec4(1))
#define dot_3(x, y) dot(mul_3(x, y), vec3(1))

float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x == 0.0) return x;
    return inversesqrt(x);
}

#define min_s(x, y) min(x, y)
#define max_s(x, y) max(x, y)
layout(points) in;
layout(triangle_strip, max_vertices=30) out;
layout(location=1) out vec4 primary_color;
layout(location=2) out vec2 texcoord0;
layout(location=3) out vec2 texcoord1;
layout(location=4) out vec2 texcoord2;
layout(location=5) out float texcoord0_w;
layout(location=6) out vec4 normquat;
layout(location=7) out vec3 view;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

layout(location=0) in vec4 vs_out_attr0[];
layout(location=1) in vec4 vs_out_attr1[];
layout(location=2) in vec4 vs_out_attr2[];
layout(location=3) in vec4 vs_out_attr3[];
layout(location=4) in vec4 vs_out_attr4[];
layout(location=5) in vec4 vs_out_attr5[];
layout(location=6) in vec4 vs_out_attr6[];
layout(location=7) in vec4 vs_out_attr7[];

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms gs_uniforms
layout(binding=3, std140) uniform gs_config {
    pica_uniforms uniforms;
};
struct Vertex {
    vec4 attributes[6];
};

vec4 GetVertexQuaternion(Vertex vtx) {
    return vec4(vtx.attributes[1].x, vtx.attributes[1].y, vtx.attributes[1].z, vtx.attributes[1].w);
}

void EmitVtx(Vertex vtx, bool quats_opposite) {
    vec4 vtx_pos = vec4(vtx.attributes[0].x, vtx.attributes[0].y, vtx.attributes[0].z, vtx.attributes[0].w);
    gl_Position = vtx_pos;
#if !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)
    gl_ClipDistance[0] = -vtx_pos.z;
    gl_ClipDistance[1] = dot(clip_coef, vtx_pos);
#endif // !defined(CITRA_GLES) || defined(GL_EXT_clip_cull_distance)

    vec4 vtx_quat = GetVertexQuaternion(vtx);
    normquat = mix(vtx_quat, -vtx_quat, bvec4(quats_opposite));

    vec4 vtx_color = vec4(vtx.attributes[3].x, vtx.attributes[3].y, vtx.attributes[3].z, vtx.attributes[3].w);
    primary_color = clamp(vtx_color, vec4(0), vec4(1));

    texcoord0 = vec2(vtx.attributes[4].x, vtx.attributes[4].y);
    texcoord1 = vec2(vtx.attributes[5].x, vtx.attributes[5].y);

    texcoord0_w = 0.0;
    view = vec3(vtx.attributes[2].x, vtx.attributes[2].y, vtx.attributes[2].z);
    texcoord2 = vec2(0.0, 0.0);

    EmitVertex();
}

bool AreQuaternionsOpposite(vec4 qa, vec4 qb) {
    return (dot(qa, qb) < 0.0);
}

void EmitPrim(Vertex vtx0, Vertex vtx1, Vertex vtx2) {
    EmitVtx(vtx0, false);
    EmitVtx(vtx1, AreQuaternionsOpposite(GetVertexQuaternion(vtx0), GetVertexQuaternion(vtx1)));
    EmitVtx(vtx2, AreQuaternionsOpposite(GetVertexQuaternion(vtx0), GetVertexQuaternion(vtx2)));
    EndPrimitive();
}

Vertex output_buffer;
Vertex prim_buffer[3];
uint vertex_id = 0u;
bool prim_emit = false;
bool winding = false;
void setemit(uint vertex_id_, bool prim_emit_, bool winding_);
void emit();
void main() {
    output_buffer.attributes[0] = vec4(0.0, 0.0, 0.0, 1.0);
    output_buffer.attributes[1] = vec4(0.0, 0.0, 0.0, 1.0);
    output_buffer.attributes[2] = vec4(0.0, 0.0, 0.0, 1.0);
    output_buffer.attributes[3] = vec4(0.0, 0.0, 0.0, 1.0);
    output_buffer.attributes[4] = vec4(0.0, 0.0, 0.0, 1.0);
    output_buffer.attributes[5] = vec4(0.0, 0.0, 0.0, 1.0);
    exec_shader();
}

void setemit(uint vertex_id_, bool prim_emit_, bool winding_) {
    vertex_id = vertex_id_;
    prim_emit = prim_emit_;
    winding = winding_;
}
void emit() {
    prim_buffer[vertex_id] = output_buffer;
    if (prim_emit) {
        if (winding) {
            EmitPrim(prim_buffer[1], prim_buffer[0], prim_buffer[2]);
            winding = false;
        } else {
            EmitPrim(prim_buffer[0], prim_buffer[1], prim_buffer[2]);
        }
    }
}
bvec2 bool_regs = bvec2(false);
ivec3 addr_regs = ivec3(0);
vec4 reg_tmp0 = vec4(0, 0, 0, 1);
vec4 reg_tmp1 = vec4(0, 0, 0, 1);
vec4 reg_tmp2 = vec4(0, 0, 0, 1);
vec4 reg_tmp3 = vec4(0, 0, 0, 1);
vec4 reg_tmp4 = vec4(0, 0, 0, 1);
vec4 reg_tmp5 = vec4(0, 0, 0, 1);
vec4 reg_tmp6 = vec4(0, 0, 0, 1);
vec4 reg_tmp7 = vec4(0, 0, 0, 1);
vec4 reg_tmp8 = vec4(0, 0, 0, 1);
vec4 reg_tmp9 = vec4(0, 0, 0, 1);
vec4 reg_tmp10 = vec4(0, 0, 0, 1);
vec4 reg_tmp11 = vec4(0, 0, 0, 1);
vec4 reg_tmp12 = vec4(0, 0, 0, 1);
vec4 reg_tmp13 = vec4(0, 0, 0, 1);
vec4 reg_tmp14 = vec4(0, 0, 0, 1);
vec4 reg_tmp15 = vec4(0, 0, 0, 1);

bool sub_0();

bool exec_shader() {
sub_0();
return true;
}

bool sub_0() {
reg_tmp0 = vs_out_attr0[0];
reg_tmp0 = reg_tmp0 + vs_out_attr6[0];
output_buffer.attributes[0] = reg_tmp0;
output_buffer.attributes[1] = vs_out_attr1[0];
output_buffer.attributes[2] = vs_out_attr2[0];
output_buffer.attributes[3] = vs_out_attr3[0];
reg_tmp0 = vs_out_attr4[0];
reg_tmp0.xy = (reg_tmp0.xyyy + vs_out_attr5[0].xyyy).xy;
reg_tmp0.xy = (reg_tmp0.xyyy + vs_out_attr5[0].zwww).xy;
output_buffer.attributes[4] = reg_tmp0;
output_buffer.attributes[5] = reg_tmp0;
setemit(0u, false, false);
emit();
reg_tmp0 = vs_out_attr0[0];
reg_tmp0 = reg_tmp0 + -vs_out_attr7[0];
output_buffer.attributes[0] = reg_tmp0;
output_buffer.attributes[1] = vs_out_attr1[0];
output_buffer.attributes[2] = vs_out_attr2[0];
output_buffer.attributes[3] = vs_out_attr3[0];
reg_tmp0 = vs_out_attr4[0];
reg_tmp0.xy = (reg_tmp0.xyyy + vs_out_attr5[0].xyyy).xy;
output_buffer.attributes[4] = reg_tmp0;
output_buffer.attributes[5] = reg_tmp0;
setemit(1u, false, false);
emit();
reg_tmp0 = vs_out_attr0[0];
reg_tmp0 = reg_tmp0 + vs_out_attr7[0];
output_buffer.attributes[0] = reg_tmp0;
output_buffer.attributes[1] = vs_out_attr1[0];
output_buffer.attributes[2] = vs_out_attr2[0];
output_buffer.attributes[3] = vs_out_attr3[0];
reg_tmp0 = vs_out_attr4[0];
reg_tmp0.xy = (reg_tmp0.xyyy + vs_out_attr5[0].zwww).xy;
output_buffer.attributes[4] = reg_tmp0;
output_buffer.attributes[5] = reg_tmp0;
setemit(2u, true, false);
emit();
reg_tmp0 = vs_out_attr0[0];
reg_tmp0 = reg_tmp0 + -vs_out_attr6[0];
output_buffer.attributes[0] = reg_tmp0;
output_buffer.attributes[1] = vs_out_attr1[0];
output_buffer.attributes[2] = vs_out_attr2[0];
output_buffer.attributes[3] = vs_out_attr3[0];
output_buffer.attributes[4] = vs_out_attr4[0];
output_buffer.attributes[5] = vs_out_attr4[0];
setemit(0u, true, true);
emit();
return true;
}
// reference: E441628640DE644D, FD710FDC3CE23CF8
// shader: 8B31, 717C72AE32BA4662

#define mul_s(x, y) mix(x * y, vec4(0), isnan(x * y))
#define mul_3(x, y) mix(x * y, vec3(0), isnan(x * y))
#define fma_s(x, y, z) (mul_s(x, y) + z)
#define dot_s(x, y) dot(mul_s(x, y), vec4(1))
#define dot_3(x, y) dot(mul_3(x, y), vec3(1))

float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x == 0.0) return x;
    return inversesqrt(x);
}

#define min_s(x, y) min(x, y)
#define max_s(x, y) max(x, y)

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout(binding=2, std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location=0) in vec4 vs_in_reg0;
layout(location=1) in vec4 vs_in_reg1;
layout(location=2) in vec4 vs_in_reg2;
layout(location=3) in vec4 vs_in_reg3;
layout(location=4) in vec4 vs_in_reg4;
layout(location=5) in vec4 vs_in_reg5;
layout(location=6) in vec4 vs_in_reg6;
layout(location=7) in vec4 vs_in_reg7;
layout(location=8) in vec4 vs_in_reg8;

layout(location=0) out vec4 vs_out_attr0;
layout(location=1) out vec4 vs_out_attr1;
layout(location=2) out vec4 vs_out_attr2;
layout(location=3) out vec4 vs_out_attr3;
layout(location=4) out vec4 vs_out_attr4;
layout(location=5) out vec4 vs_out_attr5;
layout(location=6) out vec4 vs_out_attr6;
layout(location=7) out vec4 vs_out_attr7;

void main() {
vs_out_attr0 = vec4(0, 0, 0, 1);
vs_out_attr1 = vec4(0, 0, 0, 1);
vs_out_attr2 = vec4(0, 0, 0, 1);
vs_out_attr3 = vec4(0, 0, 0, 1);
vs_out_attr4 = vec4(0, 0, 0, 1);
vs_out_attr5 = vec4(0, 0, 0, 1);
vs_out_attr6 = vec4(0, 0, 0, 1);
vs_out_attr7 = vec4(0, 0, 0, 1);
exec_shader();
}
bvec2 bool_regs = bvec2(false);
ivec3 addr_regs = ivec3(0);
vec4 reg_tmp0 = vec4(0, 0, 0, 1);
vec4 reg_tmp1 = vec4(0, 0, 0, 1);
vec4 reg_tmp2 = vec4(0, 0, 0, 1);
vec4 reg_tmp3 = vec4(0, 0, 0, 1);
vec4 reg_tmp4 = vec4(0, 0, 0, 1);
vec4 reg_tmp5 = vec4(0, 0, 0, 1);
vec4 reg_tmp6 = vec4(0, 0, 0, 1);
vec4 reg_tmp7 = vec4(0, 0, 0, 1);
vec4 reg_tmp8 = vec4(0, 0, 0, 1);
vec4 reg_tmp9 = vec4(0, 0, 0, 1);
vec4 reg_tmp10 = vec4(0, 0, 0, 1);
vec4 reg_tmp11 = vec4(0, 0, 0, 1);
vec4 reg_tmp12 = vec4(0, 0, 0, 1);
vec4 reg_tmp13 = vec4(0, 0, 0, 1);
vec4 reg_tmp14 = vec4(0, 0, 0, 1);
vec4 reg_tmp15 = vec4(0, 0, 0, 1);

bool sub_0();
bool sub_1();
bool sub_2();
bool sub_3();
bool sub_4();
bool sub_5();
bool sub_6();
bool sub_7();
bool sub_8();
bool sub_9();
bool sub_10();
bool sub_11();

bool exec_shader() {
sub_0();
return true;
}

bool sub_0() {
reg_tmp0 = vs_in_reg2;
reg_tmp0 = uniforms.f[39] + reg_tmp0;
reg_tmp0 = mul_s(uniforms.f[84].xxxx, reg_tmp0);
reg_tmp1 = floor(reg_tmp0);
reg_tmp12 = reg_tmp0 + -reg_tmp1;
reg_tmp0 = vs_in_reg1;
reg_tmp0 = mul_s(reg_tmp0, vs_in_reg8);
reg_tmp13 = mul_s(uniforms.f[38], reg_tmp0);
if (uniforms.b[1]) {
sub_1();
}
if (uniforms.b[3]) {
sub_2();
} else {
sub_3();
}
reg_tmp15.w = (uniforms.f[93].yyyy).w;
reg_tmp15.xyz = (uniforms.f[6] + vs_in_reg0).xyz;
reg_tmp10.x = dot_s(uniforms.f[34], reg_tmp15);
reg_tmp10.y = dot_s(uniforms.f[35], reg_tmp15);
reg_tmp10.z = dot_s(uniforms.f[36], reg_tmp15);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
reg_tmp0 = mul_s(uniforms.f[37].xxxx, reg_tmp6);
reg_tmp1 = mul_s(uniforms.f[37].yyyy, reg_tmp7);
reg_tmp15.xyz = (reg_tmp15 + -reg_tmp0).xyz;
reg_tmp15.xyz = (reg_tmp15 + -reg_tmp1).xyz;
vs_out_attr1 = uniforms.f[93].xxxx;
vs_out_attr2 = -reg_tmp15;
vs_out_attr0.x = dot_s(uniforms.f[86], reg_tmp15);
vs_out_attr0.y = dot_s(uniforms.f[87], reg_tmp15);
vs_out_attr0.z = dot_s(uniforms.f[88], reg_tmp15);
vs_out_attr0.w = dot_s(uniforms.f[89], reg_tmp15);
vs_out_attr3.xyz = (vs_in_reg3.xyzz).xyz;
vs_out_attr3.w = (vs_in_reg4.xxxx).w;
reg_tmp0 = mul_s(uniforms.f[84].xxxx, vs_in_reg7);
reg_tmp1 = floor(reg_tmp0);
reg_tmp3 = reg_tmp0 + -reg_tmp1;
reg_tmp1 = uniforms.f[83];
reg_tmp2 = uniforms.f[82];
reg_tmp0.z = (mul_s(reg_tmp3.xxxx, reg_tmp3.xxxx)).z;
reg_tmp0.xy = (fma_s(reg_tmp0.zzzz, reg_tmp1.xyyy, reg_tmp1.zwww)).xy;
reg_tmp0.xy = (fma_s(reg_tmp0.zzzz, reg_tmp0.xyyy, reg_tmp2.xyyy)).xy;
reg_tmp0.xy = (fma_s(reg_tmp0.zzzz, reg_tmp0.xyyy, reg_tmp2.zwww)).xy;
reg_tmp1 = uniforms.f[81];
reg_tmp0.xy = (fma_s(reg_tmp0.zzzz, reg_tmp0.xyyy, reg_tmp1.xyyy)).xy;
reg_tmp0.xy = (fma_s(reg_tmp0.zzzz, reg_tmp0.xyyy, reg_tmp1.zwww)).xy;
reg_tmp0.y = (mul_s(reg_tmp0.yyyy, reg_tmp3.xxxx)).y;
reg_tmp0.x = (fma_s(reg_tmp0.zzzz, reg_tmp0.xxxx, uniforms.f[93].yyyy)).x;
reg_tmp1 = mul_s(vs_in_reg6.xyxy, reg_tmp0.yxxy);
reg_tmp1.x = (-reg_tmp1.xxxx).x;
reg_tmp2.x = (-uniforms.f[94].zzzz + -vs_in_reg5.xxxx).x;
reg_tmp2.y = (-uniforms.f[94].zzzz + vs_in_reg5.yyyy).y;
reg_tmp0 = mul_s(reg_tmp1, reg_tmp2.yyxx);
reg_tmp2.xy = (uniforms.f[94].zzzz + reg_tmp0.xyyy).xy;
reg_tmp0.xy = (reg_tmp0.zwww + reg_tmp2.xyyy).xy;
reg_tmp2.xy = (reg_tmp0).xy;
reg_tmp2.zw = (uniforms.f[93].xxxy).zw;
reg_tmp0.x = dot_s(uniforms.f[11], reg_tmp2);
reg_tmp0.y = dot_s(uniforms.f[12], reg_tmp2);
reg_tmp0.z = dot_s(uniforms.f[13], reg_tmp2);
vs_out_attr4 = reg_tmp0;
reg_tmp2.xy = (reg_tmp1.xyyy).xy;
reg_tmp0.x = dot_3(uniforms.f[11].xyz, reg_tmp2.xyz);
reg_tmp0.y = dot_3(uniforms.f[12].xyz, reg_tmp2.xyz);
vs_out_attr5.xy = (reg_tmp0.xyyy).xy;
reg_tmp2.xy = (reg_tmp1.zwww).xy;
reg_tmp0.x = dot_3(uniforms.f[11].xyz, reg_tmp2.xyz);
reg_tmp0.y = dot_3(uniforms.f[12].xyz, reg_tmp2.xyz);
vs_out_attr5.zw = (reg_tmp0.xxxy).zw;
reg_tmp0.xyz = (reg_tmp6.xyzz + reg_tmp7.xyzz).xyz;
vs_out_attr6.x = dot_3(uniforms.f[86].xyz, reg_tmp0.xyz);
vs_out_attr6.y = dot_3(uniforms.f[87].xyz, reg_tmp0.xyz);
vs_out_attr6.z = dot_3(uniforms.f[88].xyz, reg_tmp0.xyz);
vs_out_attr6.w = dot_3(uniforms.f[89].xyz, reg_tmp0.xyz);
reg_tmp0.xyz = (reg_tmp6.xyzz + -reg_tmp7.xyzz).xyz;
vs_out_attr7.x = dot_3(uniforms.f[86].xyz, reg_tmp0.xyz);
vs_out_attr7.y = dot_3(uniforms.f[87].xyz, reg_tmp0.xyz);
vs_out_attr7.z = dot_3(uniforms.f[88].xyz, reg_tmp0.xyz);
vs_out_attr7.w = dot_3(uniforms.f[89].xyz, reg_tmp0.xyz);
return true;
}
bool sub_1() {
reg_tmp9 = uniforms.f[93].xxxx;
reg_tmp10 = uniforms.f[93].xxxx;
reg_tmp11 = uniforms.f[93].xxxx;
reg_tmp3 = mul_s(reg_tmp12, reg_tmp12);
reg_tmp1 = uniforms.f[83];
reg_tmp2 = uniforms.f[82];
reg_tmp5 = uniforms.f[81];
reg_tmp0.xy = (fma_s(reg_tmp3.xxxx, reg_tmp1.xyyy, reg_tmp1.zwww)).xy;
reg_tmp0.xy = (fma_s(reg_tmp3.xxxx, reg_tmp0.xyyy, reg_tmp2.xyyy)).xy;
reg_tmp0.xy = (fma_s(reg_tmp3.xxxx, reg_tmp0.xyyy, reg_tmp2.zwww)).xy;
reg_tmp0.xy = (fma_s(reg_tmp3.xxxx, reg_tmp0.xyyy, reg_tmp5.xyyy)).xy;
reg_tmp0.xy = (fma_s(reg_tmp3.xxxx, reg_tmp0.xyyy, reg_tmp5.zwww)).xy;
reg_tmp0.y = (mul_s(reg_tmp0.yyyy, reg_tmp12.xxxx)).y;
reg_tmp0.x = (fma_s(reg_tmp3.xxxx, reg_tmp0.xxxx, uniforms.f[93].yyyy)).x;
reg_tmp4.xy = (reg_tmp0).xy;
reg_tmp0.xy = (fma_s(reg_tmp3.yyyy, reg_tmp1.xyyy, reg_tmp1.zwww)).xy;
reg_tmp0.xy = (fma_s(reg_tmp3.yyyy, reg_tmp0.xyyy, reg_tmp2.xyyy)).xy;
reg_tmp0.xy = (fma_s(reg_tmp3.yyyy, reg_tmp0.xyyy, reg_tmp2.zwww)).xy;
reg_tmp0.xy = (fma_s(reg_tmp3.yyyy, reg_tmp0.xyyy, reg_tmp5.xyyy)).xy;
reg_tmp0.xy = (fma_s(reg_tmp3.yyyy, reg_tmp0.xyyy, reg_tmp5.zwww)).xy;
reg_tmp0.y = (mul_s(reg_tmp0.yyyy, reg_tmp12.yyyy)).y;
reg_tmp0.x = (fma_s(reg_tmp3.yyyy, reg_tmp0.xxxx, uniforms.f[93].yyyy)).x;
reg_tmp4.zw = (reg_tmp0.xxxy).zw;
reg_tmp0.xy = (fma_s(reg_tmp3.zzzz, reg_tmp1.xyyy, reg_tmp1.zwww)).xy;
reg_tmp0.xy = (fma_s(reg_tmp3.zzzz, reg_tmp0.xyyy, reg_tmp2.xyyy)).xy;
reg_tmp0.xy = (fma_s(reg_tmp3.zzzz, reg_tmp0.xyyy, reg_tmp2.zwww)).xy;
reg_tmp0.xy = (fma_s(reg_tmp3.zzzz, reg_tmp0.xyyy, reg_tmp5.xyyy)).xy;
reg_tmp0.xy = (fma_s(reg_tmp3.zzzz, reg_tmp0.xyyy, reg_tmp5.zwww)).xy;
reg_tmp0.y = (mul_s(reg_tmp0.yyyy, reg_tmp12.zzzz)).y;
reg_tmp0.x = (fma_s(reg_tmp3.zzzz, reg_tmp0.xxxx, uniforms.f[93].yyyy)).x;
reg_tmp11.x = (-reg_tmp4.wwww).x;
reg_tmp9.x = (mul_s(reg_tmp0.xxxx, reg_tmp4.zzzz)).x;
reg_tmp10.x = (mul_s(reg_tmp0.yyyy, reg_tmp4.zzzz)).x;
reg_tmp11.y = (mul_s(reg_tmp4.yyyy, reg_tmp4.zzzz)).y;
reg_tmp11.z = (mul_s(reg_tmp4.xxxx, reg_tmp4.zzzz)).z;
reg_tmp1.xy = (mul_s(reg_tmp4.xyyy, reg_tmp0.yxxx)).xy;
reg_tmp9.y = (fma_s(reg_tmp1.yyyy, reg_tmp4.wwww, -reg_tmp1.xxxx)).y;
reg_tmp10.z = (fma_s(reg_tmp1.xxxx, reg_tmp4.wwww, -reg_tmp1.yyyy)).z;
reg_tmp1.xy = (mul_s(reg_tmp4.yxxx, reg_tmp0.yxxx)).xy;
reg_tmp9.z = (fma_s(reg_tmp1.yyyy, reg_tmp4.wwww, reg_tmp1.xxxx)).z;
reg_tmp10.y = (fma_s(reg_tmp1.xxxx, reg_tmp4.wwww, reg_tmp1.yyyy)).y;
return false;
}
bool sub_2() {
reg_tmp6.yz = (uniforms.f[93].xxxx).yz;
reg_tmp7.xz = (uniforms.f[93].xxxx).xz;
reg_tmp6.xw = (uniforms.f[93].yyyy).xw;
reg_tmp7.yw = (uniforms.f[93].yyyy).yw;
reg_tmp6.xyz = (mul_s(reg_tmp6, reg_tmp13.xxxx)).xyz;
reg_tmp7.xyz = (mul_s(reg_tmp7, reg_tmp13.yyyy)).xyz;
reg_tmp0.x = dot_3(reg_tmp6.xyz, reg_tmp9.xyz);
reg_tmp0.y = dot_3(reg_tmp6.xyz, reg_tmp10.xyz);
reg_tmp0.z = dot_3(reg_tmp6.xyz, reg_tmp11.xyz);
reg_tmp6 = reg_tmp0;
reg_tmp1.x = dot_3(reg_tmp7.xyz, reg_tmp9.xyz);
reg_tmp1.y = dot_3(reg_tmp7.xyz, reg_tmp10.xyz);
reg_tmp1.z = dot_3(reg_tmp7.xyz, reg_tmp11.xyz);
reg_tmp7 = reg_tmp1;
reg_tmp0 = reg_tmp6;
reg_tmp6.x = dot_3(uniforms.f[25].xyz, reg_tmp0.xyz);
reg_tmp6.y = dot_3(uniforms.f[26].xyz, reg_tmp0.xyz);
reg_tmp6.z = dot_3(uniforms.f[27].xyz, reg_tmp0.xyz);
reg_tmp0 = reg_tmp7;
reg_tmp7.x = dot_3(uniforms.f[25].xyz, reg_tmp0.xyz);
reg_tmp7.y = dot_3(uniforms.f[26].xyz, reg_tmp0.xyz);
reg_tmp7.z = dot_3(uniforms.f[27].xyz, reg_tmp0.xyz);
return false;
}
bool sub_3() {
if (uniforms.b[2]) {
sub_4();
} else {
sub_7();
}
return false;
}
bool sub_4() {
reg_tmp8.x = (uniforms.f[28].zzzz).x;
reg_tmp8.y = (uniforms.f[29].zzzz).y;
reg_tmp8.z = (uniforms.f[30].zzzz).z;
reg_tmp0 = vec4(dot_3(reg_tmp8.xyz, reg_tmp8.xyz));
reg_tmp1 = vec4(rsq_s(reg_tmp0.x));
reg_tmp8 = mul_s(reg_tmp8, reg_tmp1.xxxx);
reg_tmp6 = uniforms.f[93].xxxx;
reg_tmp7 = uniforms.f[93].xxxx;
reg_tmp6.x = (uniforms.f[93].yyyy).x;
reg_tmp7.y = (uniforms.f[93].yyyy).y;
reg_tmp0.x = dot_3(reg_tmp6.xyz, reg_tmp9.xyz);
reg_tmp0.y = dot_3(reg_tmp6.xyz, reg_tmp10.xyz);
reg_tmp0.z = dot_3(reg_tmp6.xyz, reg_tmp11.xyz);
reg_tmp6 = reg_tmp0;
reg_tmp1.x = dot_3(reg_tmp7.xyz, reg_tmp9.xyz);
reg_tmp1.y = dot_3(reg_tmp7.xyz, reg_tmp10.xyz);
reg_tmp1.z = dot_3(reg_tmp7.xyz, reg_tmp11.xyz);
reg_tmp7 = reg_tmp1;
reg_tmp0 = vec4(dot_3(reg_tmp8.xyz, reg_tmp7.xyz));
reg_tmp1 = abs(reg_tmp0);
bool_regs = greaterThan(uniforms.f[84].ww, reg_tmp1.xx);
if (bool_regs.x) {
sub_5();
} else {
sub_6();
}
return false;
}
bool sub_5() {
reg_tmp0.xyz = (mul_s(reg_tmp7.yzxx, reg_tmp8.zxyy)).xyz;
reg_tmp0.xyz = (fma_s(-reg_tmp8.yzxx, reg_tmp7.zxyy, reg_tmp0)).xyz;
reg_tmp8.xyz = (mul_s(reg_tmp0.yzxx, reg_tmp7.zxyy)).xyz;
reg_tmp8.xyz = (fma_s(-reg_tmp7.yzxx, reg_tmp0.zxyy, reg_tmp8)).xyz;
reg_tmp6.xyz = (mul_s(reg_tmp7.yzxx, reg_tmp8.zxyy)).xyz;
reg_tmp6.xyz = (fma_s(-reg_tmp8.yzxx, reg_tmp7.zxyy, reg_tmp6)).xyz;
reg_tmp0 = vec4(dot_3(reg_tmp6.xyz, reg_tmp6.xyz));
reg_tmp1 = vec4(rsq_s(reg_tmp0.x));
reg_tmp6 = mul_s(reg_tmp6, reg_tmp1.xxxx);
reg_tmp0 = reg_tmp6;
reg_tmp6.x = dot_3(uniforms.f[25].xyz, reg_tmp0.xyz);
reg_tmp6.y = dot_3(uniforms.f[26].xyz, reg_tmp0.xyz);
reg_tmp6.z = dot_3(uniforms.f[27].xyz, reg_tmp0.xyz);
reg_tmp0 = reg_tmp7;
reg_tmp7.x = dot_3(uniforms.f[25].xyz, reg_tmp0.xyz);
reg_tmp7.y = dot_3(uniforms.f[26].xyz, reg_tmp0.xyz);
reg_tmp7.z = dot_3(uniforms.f[27].xyz, reg_tmp0.xyz);
reg_tmp6 = mul_s(reg_tmp6, reg_tmp13.xxxx);
reg_tmp7 = mul_s(reg_tmp7, reg_tmp13.yyyy);
return false;
}
bool sub_6() {
reg_tmp6 = uniforms.f[93].xxxx;
reg_tmp7 = uniforms.f[93].xxxx;
return false;
}
bool sub_7() {
if (uniforms.b[4]) {
sub_8();
} else {
sub_11();
}
reg_tmp0 = vec4(dot_3(reg_tmp6.xyz, reg_tmp6.xyz));
reg_tmp1 = vec4(rsq_s(reg_tmp0.x));
reg_tmp6 = mul_s(reg_tmp6, reg_tmp1.xxxx);
reg_tmp0 = vec4(dot_3(reg_tmp7.xyz, reg_tmp7.xyz));
reg_tmp1 = vec4(rsq_s(reg_tmp0.x));
reg_tmp7 = mul_s(reg_tmp7, reg_tmp1.xxxx);
reg_tmp0 = reg_tmp6;
reg_tmp6.x = dot_3(uniforms.f[25].xyz, reg_tmp0.xyz);
reg_tmp6.y = dot_3(uniforms.f[26].xyz, reg_tmp0.xyz);
reg_tmp6.z = dot_3(uniforms.f[27].xyz, reg_tmp0.xyz);
reg_tmp0 = reg_tmp7;
reg_tmp7.x = dot_3(uniforms.f[25].xyz, reg_tmp0.xyz);
reg_tmp7.y = dot_3(uniforms.f[26].xyz, reg_tmp0.xyz);
reg_tmp7.z = dot_3(uniforms.f[27].xyz, reg_tmp0.xyz);
reg_tmp6 = mul_s(reg_tmp6, reg_tmp13.xxxx);
reg_tmp7 = mul_s(reg_tmp7, reg_tmp13.yyyy);
reg_tmp1 = uniforms.f[83];
reg_tmp2 = uniforms.f[82];
reg_tmp0.z = (mul_s(reg_tmp12.zzzz, reg_tmp12.zzzz)).z;
reg_tmp0.xy = (fma_s(reg_tmp0.zzzz, reg_tmp1.xyyy, reg_tmp1.zwww)).xy;
reg_tmp0.xy = (fma_s(reg_tmp0.zzzz, reg_tmp0.xyyy, reg_tmp2.xyyy)).xy;
reg_tmp0.xy = (fma_s(reg_tmp0.zzzz, reg_tmp0.xyyy, reg_tmp2.zwww)).xy;
reg_tmp1 = uniforms.f[81];
reg_tmp0.xy = (fma_s(reg_tmp0.zzzz, reg_tmp0.xyyy, reg_tmp1.xyyy)).xy;
reg_tmp0.xy = (fma_s(reg_tmp0.zzzz, reg_tmp0.xyyy, reg_tmp1.zwww)).xy;
reg_tmp0.y = (mul_s(reg_tmp0.yyyy, reg_tmp12.zzzz)).y;
reg_tmp0.x = (fma_s(reg_tmp0.zzzz, reg_tmp0.xxxx, uniforms.f[93].yyyy)).x;
reg_tmp0.z = (-reg_tmp0.yyyy).z;
reg_tmp1 = mul_s(reg_tmp0.xzyx, reg_tmp6.xyxy);
reg_tmp6.xy = (reg_tmp1.xzzz + reg_tmp1.ywww).xy;
reg_tmp6.zw = (uniforms.f[93].xxxx).zw;
reg_tmp1 = mul_s(reg_tmp0.xzyx, reg_tmp7.xyxy);
reg_tmp7.xy = (reg_tmp1.xzzz + reg_tmp1.ywww).xy;
reg_tmp7.zw = (uniforms.f[93].xxxx).zw;
return false;
}
bool sub_8() {
reg_tmp8.x = (uniforms.f[28].zzzz).x;
reg_tmp8.y = (uniforms.f[29].zzzz).y;
reg_tmp8.z = (uniforms.f[30].zzzz).z;
reg_tmp0 = vec4(dot_3(reg_tmp8.xyz, reg_tmp8.xyz));
reg_tmp1 = vec4(rsq_s(reg_tmp0.x));
reg_tmp8 = mul_s(reg_tmp8, reg_tmp1.xxxx);
reg_tmp1 = abs(reg_tmp8);
bool_regs = greaterThan(uniforms.f[84].ww, reg_tmp1.yy);
if (bool_regs.x) {
sub_9();
} else {
sub_10();
}
reg_tmp0.xyz = (mul_s(reg_tmp7.yzxx, reg_tmp8.zxyy)).xyz;
reg_tmp0.xyz = (fma_s(-reg_tmp8.yzxx, reg_tmp7.zxyy, reg_tmp0)).xyz;
reg_tmp7.xyz = (mul_s(reg_tmp8.yzxx, reg_tmp0.zxyy)).xyz;
reg_tmp7.xyz = (fma_s(-reg_tmp0.yzxx, reg_tmp8.zxyy, reg_tmp7)).xyz;
reg_tmp6.xyz = (mul_s(reg_tmp7.yzxx, reg_tmp8.zxyy)).xyz;
reg_tmp6.xyz = (fma_s(-reg_tmp8.yzxx, reg_tmp7.zxyy, reg_tmp6)).xyz;
return false;
}
bool sub_9() {
reg_tmp7.xz = (uniforms.f[93].xxxx).xz;
reg_tmp7.yw = (uniforms.f[93].yyyy).yw;
return false;
}
bool sub_10() {
reg_tmp7.yz = (uniforms.f[93].xxxx).yz;
reg_tmp7.xw = (uniforms.f[93].yyyy).xw;
return false;
}
bool sub_11() {
reg_tmp8.x = (uniforms.f[28].zzzz).x;
reg_tmp8.y = (uniforms.f[29].zzzz).y;
reg_tmp8.z = (uniforms.f[30].zzzz).z;
reg_tmp0 = vec4(dot_3(reg_tmp8.xyz, reg_tmp8.xyz));
reg_tmp1 = vec4(rsq_s(reg_tmp0.x));
reg_tmp8 = mul_s(reg_tmp8, reg_tmp1.xxxx);
reg_tmp7.x = (uniforms.f[28].yyyy).x;
reg_tmp7.y = (uniforms.f[29].yyyy).y;
reg_tmp7.z = (uniforms.f[30].yyyy).z;
reg_tmp0 = vec4(dot_3(reg_tmp7.xyz, reg_tmp7.xyz));
reg_tmp1 = vec4(rsq_s(reg_tmp0.x));
reg_tmp7 = mul_s(reg_tmp7, reg_tmp1.xxxx);
reg_tmp0.xyz = (mul_s(reg_tmp7.yzxx, reg_tmp8.zxyy)).xyz;
reg_tmp0.xyz = (fma_s(-reg_tmp8.yzxx, reg_tmp7.zxyy, reg_tmp0)).xyz;
reg_tmp7.xyz = (mul_s(reg_tmp8.yzxx, reg_tmp0.zxyy)).xyz;
reg_tmp7.xyz = (fma_s(-reg_tmp0.yzxx, reg_tmp8.zxyy, reg_tmp7)).xyz;
reg_tmp6.xyz = (mul_s(reg_tmp7.yzxx, reg_tmp8.zxyy)).xyz;
reg_tmp6.xyz = (fma_s(-reg_tmp8.yzxx, reg_tmp7.zxyy, reg_tmp6)).xyz;
return false;
}
// reference: 5457500821C15865, 717C72AE32BA4662
// reference: 1904AF06491BB6C7, F46DC34FD2BFE838
// program: 717C72AE32BA4662, FD710FDC3CE23CF8, F46DC34FD2BFE838
// shader: 8B30, 9379424C3C0B1656
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb) * (texcolor0.rgb) + (const_color[0].rgb) * (vec3(1) - (texcolor0.rgb)), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_3 = byteround(clamp((const_color[3].rgb) * (vec3(1) - texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_3 = byteround(clamp((const_color[3].a) * (1.0 - texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (texcolor0.rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (texcolor0.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
if (last_tex_env_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 80BDEFAE97976116, 9379424C3C0B1656
// program: 4DBF54CC7897BA20, B6B95AFD9466EC70, 9379424C3C0B1656
// shader: 8B30, ED5D177FFACB535B
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb) * (texcolor0.rgb) + (const_color[0].rgb) * (vec3(1) - (texcolor0.rgb)), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_3 = byteround(clamp((texcolor0.rgb) * (const_color[3].rgb), vec3(0), vec3(1)));
float alpha_output_3 = byteround(clamp((texcolor0.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_4 = byteround(clamp((vec3(1) - texcolor0.rgb) * (const_color[4].rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_4 = byteround(clamp((1.0 - texcolor0.a) * (const_color[4].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
if (last_tex_env_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: CAFE825B934FB10D, ED5D177FFACB535B
// program: 4DBF54CC7897BA20, B6B95AFD9466EC70, ED5D177FFACB535B
// shader: 8B30, 79D34B0E6A2BBAA0
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb) * (texcolor0.rgb) + (const_color[0].rgb) * (vec3(1) - (texcolor0.rgb)), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_3 = byteround(clamp((const_color[3].rgb) * (vec3(1) - texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_3 = byteround(clamp((const_color[3].a) * (1.0 - texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (texcolor0.rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (texcolor0.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_5 = (rounded_primary_color.rgb);
float alpha_output_5 = (rounded_primary_color.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 727DD5E3832CEA98, 79D34B0E6A2BBAA0
// program: 0000000000000000, 0000000000000000, 79D34B0E6A2BBAA0
// shader: 8B31, 8CDEDA56138024A0

#define mul_s(x, y) mix(x * y, vec4(0), isnan(x * y))
#define mul_3(x, y) mix(x * y, vec3(0), isnan(x * y))
#define fma_s(x, y, z) (mul_s(x, y) + z)
#define dot_s(x, y) dot(mul_s(x, y), vec4(1))
#define dot_3(x, y) dot(mul_3(x, y), vec3(1))

float rcp_s(float x) {
    if (x == 0.0) return x;
    return 1.0 / x;
}
float rsq_s(float x) {
    if (x == 0.0) return x;
    return inversesqrt(x);
}

#define min_s(x, y) min(x, y)
#define max_s(x, y) max(x, y)

struct pica_uniforms {
    bool b[16];
    uvec4 i[4];
    vec4 f[96];
};

bool exec_shader();

#define uniforms vs_uniforms
layout(binding=2, std140) uniform vs_config {
    pica_uniforms uniforms;
};
layout(location=0) in vec4 vs_in_reg0;
layout(location=1) in vec4 vs_in_reg1;
layout(location=2) in vec4 vs_in_reg2;
layout(location=7) in vec4 vs_in_reg7;
layout(location=8) in vec4 vs_in_reg8;

layout(location=0) out vec4 vs_out_attr0;
layout(location=1) out vec4 vs_out_attr1;
layout(location=2) out vec4 vs_out_attr2;
layout(location=3) out vec4 vs_out_attr3;
layout(location=4) out vec4 vs_out_attr4;
layout(location=5) out vec4 vs_out_attr5;
layout(location=6) out vec4 vs_out_attr6;

void main() {
vs_out_attr0 = vec4(0, 0, 0, 1);
vs_out_attr1 = vec4(0, 0, 0, 1);
vs_out_attr2 = vec4(0, 0, 0, 1);
vs_out_attr3 = vec4(0, 0, 0, 1);
vs_out_attr4 = vec4(0, 0, 0, 1);
vs_out_attr5 = vec4(0, 0, 0, 1);
vs_out_attr6 = vec4(0, 0, 0, 1);
exec_shader();
}
bvec2 bool_regs = bvec2(false);
ivec3 addr_regs = ivec3(0);
vec4 reg_tmp0 = vec4(0, 0, 0, 1);
vec4 reg_tmp1 = vec4(0, 0, 0, 1);
vec4 reg_tmp2 = vec4(0, 0, 0, 1);
vec4 reg_tmp3 = vec4(0, 0, 0, 1);
vec4 reg_tmp4 = vec4(0, 0, 0, 1);
vec4 reg_tmp5 = vec4(0, 0, 0, 1);
vec4 reg_tmp6 = vec4(0, 0, 0, 1);
vec4 reg_tmp7 = vec4(0, 0, 0, 1);
vec4 reg_tmp8 = vec4(0, 0, 0, 1);
vec4 reg_tmp9 = vec4(0, 0, 0, 1);
vec4 reg_tmp10 = vec4(0, 0, 0, 1);
vec4 reg_tmp11 = vec4(0, 0, 0, 1);
vec4 reg_tmp12 = vec4(0, 0, 0, 1);
vec4 reg_tmp13 = vec4(0, 0, 0, 1);
vec4 reg_tmp14 = vec4(0, 0, 0, 1);
vec4 reg_tmp15 = vec4(0, 0, 0, 1);

bool sub_0();
bool sub_2();
bool sub_1();
bool sub_3();
bool sub_4();

bool exec_shader() {
sub_0();
return true;
}

bool sub_0() {
sub_1();
vs_out_attr3 = uniforms.f[93].xxxx;
vs_out_attr4 = uniforms.f[93].xxxx;
vs_out_attr5 = uniforms.f[93].xxxx;
vs_out_attr6 = uniforms.f[93].xxxx;
return true;
}
bool sub_2() {
addr_regs.x = (ivec2(reg_tmp1.xx)).x;
reg_tmp3.x = dot_s(uniforms.f[25 + addr_regs.x], reg_tmp15);
reg_tmp3.y = dot_s(uniforms.f[26 + addr_regs.x], reg_tmp15);
reg_tmp3.z = dot_s(uniforms.f[27 + addr_regs.x], reg_tmp15);
reg_tmp7 = fma_s(reg_tmp1.wwww, reg_tmp3, reg_tmp7);
return false;
}
bool sub_1() {
reg_tmp15.xyz = (mul_s(uniforms.f[7].xxxx, vs_in_reg0)).xyz;
reg_tmp14.xyz = (mul_s(uniforms.f[7].yyyy, vs_in_reg1)).xyz;
reg_tmp13.xyz = (mul_s(uniforms.f[7].zzzz, vs_in_reg2)).xyz;
reg_tmp15.xyz = (uniforms.f[6] + reg_tmp15).xyz;
reg_tmp15.w = (uniforms.f[93].yyyy).w;
reg_tmp0 = uniforms.f[7];
bool_regs = notEqual(uniforms.f[93].xx, reg_tmp0.yz);
reg_tmp7 = uniforms.f[93].xxxx;
reg_tmp12 = uniforms.f[93].xxxx;
reg_tmp11 = uniforms.f[93].xxxx;
reg_tmp2 = mul_s(uniforms.f[93].wwww, vs_in_reg7);
bool_regs = notEqual(uniforms.f[93].xx, vs_in_reg8.zw);
reg_tmp1.xy = (reg_tmp2.xxxx).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.xxxx)).w;
sub_2();
reg_tmp1.xy = (reg_tmp2.yyyy).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.yyyy)).w;
sub_2();
reg_tmp1.xy = (reg_tmp2.zzzz).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.zzzz)).w;
if (bool_regs.x) {
sub_2();
}
if (uniforms.b[8]) {
sub_3();
}
reg_tmp7.w = (uniforms.f[93].yyyy).w;
reg_tmp10.x = dot_s(uniforms.f[0], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[1], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[2], reg_tmp7);
reg_tmp10.w = (uniforms.f[93].yyyy).w;
reg_tmp6.y = (-uniforms.f[85].wwww + reg_tmp10.yyyy).y;
reg_tmp9.xyz = (uniforms.f[85].xyzz).xyz;
reg_tmp7.x = dot_s(reg_tmp9.xyzz, reg_tmp9.xyzz);
reg_tmp7.x = rsq_s(reg_tmp7.x);
reg_tmp7.xyz = (mul_s(reg_tmp9.xyzz, reg_tmp7.xxxx)).xyz;
reg_tmp8.y = rcp_s(-reg_tmp7.y);
reg_tmp8.y = (mul_s(reg_tmp6.yyyy, reg_tmp8.yyyy)).y;
reg_tmp7.xyz = (mul_s(reg_tmp7.xyzz, reg_tmp8.yyyy)).xyz;
reg_tmp10.xyz = (reg_tmp10.xyzz + reg_tmp7.xyzz).xyz;
reg_tmp10.y = (uniforms.f[94].zzzz + reg_tmp10.yyyy).y;
reg_tmp7 = reg_tmp10;
reg_tmp10.x = dot_s(uniforms.f[22], reg_tmp7);
reg_tmp10.y = dot_s(uniforms.f[23], reg_tmp7);
reg_tmp10.z = dot_s(uniforms.f[24], reg_tmp7);
reg_tmp15.x = dot_s(uniforms.f[90], reg_tmp10);
reg_tmp15.y = dot_s(uniforms.f[91], reg_tmp10);
reg_tmp15.z = dot_s(uniforms.f[92], reg_tmp10);
reg_tmp15.w = (uniforms.f[93].yyyy).w;
vs_out_attr1 = uniforms.f[93].xxxx;
vs_out_attr2 = -reg_tmp15;
reg_tmp0.x = dot_s(uniforms.f[86], reg_tmp15);
reg_tmp0.y = dot_s(uniforms.f[87], reg_tmp15);
reg_tmp0.z = dot_s(uniforms.f[88], reg_tmp15);
reg_tmp0.w = dot_s(uniforms.f[89], reg_tmp15);
reg_tmp1.x = (-reg_tmp0.wwww).x;
reg_tmp1.y = (mul_s(uniforms.f[95].zzzz, -reg_tmp0.wwww)).y;
bool_regs.x = reg_tmp0.xxxx.x > reg_tmp1.xyyy.x;
bool_regs.y = reg_tmp0.xxxx.y < reg_tmp1.xyyy.y;
if (all(bool_regs)) {
sub_4();
}
vs_out_attr0 = reg_tmp0;
return false;
}
bool sub_3() {
reg_tmp1.xy = (reg_tmp2.wwww).xy;
reg_tmp1.w = (mul_s(uniforms.f[8].wwww, vs_in_reg8.wwww)).w;
if (bool_regs.y) {
sub_2();
}
return false;
}
bool sub_4() {
reg_tmp0.x = (-reg_tmp0.wwww).x;
return false;
}
// reference: F2378FBB90F7E462, 8CDEDA56138024A0
// reference: F33C1B804869DF2A, 19A2BB30F658ACB8
// program: 8CDEDA56138024A0, EADA2116091C5E01, 19A2BB30F658ACB8
// shader: 8B30, 9E6B82E41ACE258A
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb) * (texcolor0.rgb) + (const_color[0].rgb) * (vec3(1) - (texcolor0.rgb)), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_3 = byteround(clamp((vec3(1) - texcolor0.rgb) * (const_color[3].rgb), vec3(0), vec3(1)));
float alpha_output_3 = byteround(clamp((texcolor0.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_4 = byteround(clamp((texcolor0.rgb) * (const_color[4].rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_4 = byteround(clamp((1.0 - texcolor0.a) * (const_color[4].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
if (last_tex_env_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: A5712885934FB10D, 9E6B82E41ACE258A
// program: 4DBF54CC7897BA20, B6B95AFD9466EC70, 9E6B82E41ACE258A
// shader: 8B30, B2592D426F0CF1A2
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((rounded_primary_color.rgb) * (texcolor0.rgb) + (const_color[0].rgb) * (vec3(1) - (texcolor0.rgb)), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_3 = byteround(clamp((vec3(1) - texcolor0.rgb) * (const_color[3].rgb), vec3(0), vec3(1)));
float alpha_output_3 = byteround(clamp((texcolor0.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_4 = byteround(clamp((texcolor0.rgb) * (const_color[4].rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_4 = byteround(clamp((1.0 - texcolor0.a) * (const_color[4].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_5 = (rounded_primary_color.rgb);
float alpha_output_5 = (rounded_primary_color.a);
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 57B112C887F43A83, B2592D426F0CF1A2
// program: 0000000000000000, 0000000000000000, B2592D426F0CF1A2
// reference: A228BC73F26A3D7B, 333023FE25AF3950
// shader: 8B30, 604144BF4F5F5FF1
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb) * (texcolor0.rgb) + (rounded_primary_color.rgb) * (vec3(1) - (texcolor0.rgb)), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 1904AF06EB290E33, 604144BF4F5F5FF1
// program: 717C72AE32BA4662, FD710FDC3CE23CF8, 604144BF4F5F5FF1
// shader: 8B30, 1D44C448833488C7
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb) * (texcolor0.rgb) + (rounded_primary_color.rgb) * (vec3(1) - (texcolor0.rgb)), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_3 = byteround(clamp((const_color[3].rgb) * (vec3(1) - texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_3 = byteround(clamp((const_color[3].a) * (1.0 - texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (texcolor0.rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (texcolor0.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
if (last_tex_env_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 80BDEFAE35A5D9E2, 1D44C448833488C7
// program: 4DBF54CC7897BA20, B6B95AFD9466EC70, 1D44C448833488C7
// shader: 8B30, 6360917B45F4CDCA
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((const_color[0].rgb) * (texcolor0.rgb) + (rounded_primary_color.rgb) * (vec3(1) - (texcolor0.rgb)), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_3 = byteround(clamp((texcolor0.rgb) * (const_color[3].rgb), vec3(0), vec3(1)));
float alpha_output_3 = byteround(clamp((texcolor0.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_4 = byteround(clamp((vec3(1) - texcolor0.rgb) * (const_color[4].rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_4 = byteround(clamp((1.0 - texcolor0.a) * (const_color[4].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
if (last_tex_env_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: CAFE825B317D09F9, 6360917B45F4CDCA
// program: 4DBF54CC7897BA20, B6B95AFD9466EC70, 6360917B45F4CDCA
// reference: F000D86EB0442582, B45DBB7DF2599D81
// program: 717C72AE32BA4662, FD710FDC3CE23CF8, B45DBB7DF2599D81
// shader: 8B30, 22BEACAA022AB58B
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_3 = byteround(clamp((const_color[3].rgb) * (vec3(1) - texcolor0.rgb), vec3(0), vec3(1)));
float alpha_output_3 = byteround(clamp((const_color[3].a) * (1.0 - texcolor0.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_4 = byteround(clamp((const_color[4].rgb) * (texcolor0.rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_4 = byteround(clamp((const_color[4].a) * (texcolor0.a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
if (last_tex_env_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 69B998C66EC8F253, 22BEACAA022AB58B
// program: 4DBF54CC7897BA20, B6B95AFD9466EC70, 22BEACAA022AB58B
// shader: 8B30, DE5FCC30427D2A63
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = byteround(clamp((texcolor0.rgb) * (rounded_primary_color.rgb), vec3(0), vec3(1)));
float alpha_output_0 = byteround(clamp((texcolor0.a) * (rounded_primary_color.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
vec3 color_output_3 = byteround(clamp((texcolor0.rgb) * (const_color[3].rgb), vec3(0), vec3(1)));
float alpha_output_3 = byteround(clamp((texcolor0.a) * (const_color[3].a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_3, alpha_output_3);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_4 = byteround(clamp((vec3(1) - texcolor0.rgb) * (const_color[4].rgb) + (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_4 = byteround(clamp((1.0 - texcolor0.a) * (const_color[4].a) + (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_4, alpha_output_4);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
vec3 color_output_5 = byteround(clamp((rounded_primary_color.rgb) * (last_tex_env_out.rgb), vec3(0), vec3(1)));
float alpha_output_5 = byteround(clamp((rounded_primary_color.a) * (last_tex_env_out.a), 0.0, 1.0));
last_tex_env_out = vec4(color_output_5, alpha_output_5);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
if (last_tex_env_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 23FAF5336A102248, DE5FCC30427D2A63
// program: 4DBF54CC7897BA20, B6B95AFD9466EC70, DE5FCC30427D2A63
// reference: 502C1317F667A94A, 15934979BD14163F
// program: 5A04B7D2F3342460, EADA2116091C5E01, 15934979BD14163F
// shader: 8B30, 9188EE2E3486FB93
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
if (last_tex_env_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 0E6F400C2BBD4598, 9188EE2E3486FB93
// program: DB0B4C6763B81C5A, EADA2116091C5E01, 9188EE2E3486FB93
// shader: 8B30, BE0EFAD295AC1477
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = (const_color[0].rgb);
float alpha_output_0 = (const_color[0].a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 00DB342FA9DEC321, BE0EFAD295AC1477
// program: DB0B4C6763B81C5A, EADA2116091C5E01, BE0EFAD295AC1477
// reference: 599F1565DBCB78CC, 0AB8BDAA1E48628C
// program: AEF4EEAE6F9585E0, F777123A8C3D5E20, 1FF646FF8F39536E
// program: AEF4EEAE6F9585E0, F777123A8C3D5E20, A929CF6B7E6FB0BA
// program: AEF4EEAE6F9585E0, F777123A8C3D5E20, 8560378E1617BECE
// program: AEF4EEAE6F9585E0, F777123A8C3D5E20, 4BE170182235D0BB
// program: AEF4EEAE6F9585E0, F777123A8C3D5E20, FF4FD8DEB017F2B5
// program: AEF4EEAE6F9585E0, F777123A8C3D5E20, B1FB792FA3003901
// program: 37194F1D205A4454, F777123A8C3D5E20, B0E49DB341B018F2
// shader: 8B30, 4F204B909B58951D
layout(location=1) in vec4 primary_color;
layout(location=2) in vec2 texcoord0;
layout(location=3) in vec2 texcoord1;
layout(location=4) in vec2 texcoord2;
layout(location=5) in float texcoord0_w;
layout(location=6) in vec4 normquat;
layout(location=7) in vec3 view;
out vec4 color;

layout(binding=0) uniform sampler2D tex0;
layout(binding=1) uniform sampler2D tex1;
layout(binding=2) uniform sampler2D tex2;
layout(binding=3) uniform samplerBuffer tex_lut_lf;
layout(binding=4) uniform samplerBuffer tex_lut_rg;
layout(binding=5) uniform samplerBuffer tex_lut_rgba;
layout(binding=6) uniform samplerCube tex_cube;

layout(binding=0, std140) uniform shader_data {
    int scissor_x1;
    int scissor_y1;
    int scissor_x2;
    int scissor_y2;
    int fog_lut_offset;
    int proctex_lut_offset;
    int proctex_diff_lut_offset;
    int proctex_noise_lut_offset;
    int proctex_color_map_offset;
    int proctex_alpha_map_offset;
    float alphatest_ref;
    float depth_scale;
    float depth_offset;
    float shadow_bias_constant;
    float shadow_bias_linear;
    float proctex_bias;
    vec3 fog_color;
    vec3 tex_lod_bias;
    vec2 proctex_noise_f;
    vec2 proctex_noise_a;
    vec2 proctex_noise_p;
    vec4 clip_coef;
    vec4 tev_combiner_buffer_color;
    vec4 const_color[6];
};

struct LightSrc {
    vec3 specular_0;
    vec3 specular_1;
    vec3 diffuse;
    vec3 ambient;
    vec3 position;
    vec3 spot_direction;
    float dist_atten_bias;
    float dist_atten_scale;
};
layout(binding=1, std140) uniform shader_light_data {
    ivec4 lighting_lut_offset[6];
    vec3 lighting_global_ambient;
    LightSrc light_src[8];
    float lut_scale_d0;
    float lut_scale_d1;
    float lut_scale_sp;
    float lut_scale_fr;
    float lut_scale_rb;
    float lut_scale_rg;
    float lut_scale_rr;
    int shadow_texture_bias;
};

vec3 QuaternionRotate(vec4 q, vec3 v) {
    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}
float LookupLightingLUT(int lut_index, int index, float delta) {
    vec2 entry = texelFetch(tex_lut_lf, lighting_lut_offset[lut_index >> 2][lut_index & 3] + index).rg;
    return entry.r + entry.g * delta;
}
float LookupLightingLUTUnsigned(int lut_index, float pos) {
    int index = clamp(int(pos * 256.0), 0, 255);
    float delta = pos * 256.0 - float(index);
    return LookupLightingLUT(lut_index, index, delta);
}
float LookupLightingLUTSigned(int lut_index, float pos) {
    int index = clamp(int(pos * 128.0), -128, 127);
    float delta = pos * 128.0 - float(index);
    if (index < 0) index += 256;
    return LookupLightingLUT(lut_index, index, delta);
}

float byteround(float x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec3 byteround(vec3 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
vec4 byteround(vec4 x) {
    return round(x * 255.0) * (1.0 / 255.0);
}
float getLod(vec2 coord) {
    vec2 d = max(abs(dFdx(coord)), abs(dFdy(coord)));
    return log2(max(d.x, d.y));
}

void main() {
vec4 rounded_primary_color = byteround(primary_color);
vec4 primary_fragment_color = vec4(0);
vec4 secondary_fragment_color = vec4(0);
float z_over_w = 2.0 * gl_FragCoord.z - 1.0;
float depth = z_over_w * depth_scale + depth_offset;
vec4 texcolor0 = textureLod(tex0, texcoord0, getLod(texcoord0 * vec2(textureSize(tex0, 0))) + tex_lod_bias[0]);
vec4 combiner_buffer = vec4(0);
vec4 next_combiner_buffer = tev_combiner_buffer_color;
vec4 last_tex_env_out = vec4(0);
vec3 color_output_0 = (texcolor0.rgb);
float alpha_output_0 = (texcolor0.a);
last_tex_env_out = vec4(color_output_0, alpha_output_0);
last_tex_env_out = clamp(last_tex_env_out, vec4(0), vec4(1));
combiner_buffer = next_combiner_buffer;
if (last_tex_env_out.a <= alphatest_ref) discard;
gl_FragDepth = depth;
color = byteround(last_tex_env_out);
}
// reference: 664D47AC9C65E772, 4F204B909B58951D
// program: AEF4EEAE6F9585E0, F777123A8C3D5E20, 4F204B909B58951D
